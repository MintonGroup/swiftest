var tipuesearch = {"pages":[{"title":" swiftest ","text":"swiftest Developer Info David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott The Purdue University Minton Research Group","tags":"home","loc":"index.html"},{"title":"kick.f90 – swiftest","text":"This file depends on sourcefile~~kick.f90~~EfferentGraph sourcefile~kick.f90 kick.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~kick.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_kick Source Code kick.f90 Source Code submodule ( swiftest_classes ) s_kick use swiftest contains module pure subroutine kick_getacch_int_pl ( self ) !! author: David A. Minton !! !! Compute direct cross (third) term heliocentric accelerations of massive bodies !! !! Adapted from Hal Levison's Swift routine getacch_ah3.f !! Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah3.f90 and helio_kick_getacch_int.f90 implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self ! Internals integer ( I4B ) :: k real ( DP ) :: rji2 , irij3 , faci , facj real ( DP ), dimension ( NDIM ) :: dx associate ( pl => self , npl => self % nbody , nplpl => self % nplpl ) do k = 1 , nplpl associate ( i => pl % k_plpl ( 1 , k ), j => pl % k_plpl ( 2 , k )) if ( pl % lmask ( i ) . and . pl % lmask ( j )) then dx (:) = pl % xh (:, j ) - pl % xh (:, i ) rji2 = dot_product ( dx (:), dx (:)) irij3 = 1.0_DP / ( rji2 * sqrt ( rji2 )) faci = pl % Gmass ( i ) * irij3 facj = pl % Gmass ( j ) * irij3 pl % ah (:, i ) = pl % ah (:, i ) + facj * dx (:) pl % ah (:, j ) = pl % ah (:, j ) - faci * dx (:) end if end associate end do end associate return end subroutine kick_getacch_int_pl module pure subroutine kick_getacch_int_tp ( self , GMpl , xhp , npl ) !! author: David A. Minton !! !! Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies !! !! Adapted from Hal Levison's Swift routine getacch_ah3_tp.f !! Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah3.f90 and helio_kick_getacch_int_tp.f90 implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle real ( DP ), dimension (:), intent ( in ) :: GMpl !! Massive body masses real ( DP ), dimension (:,:), intent ( in ) :: xhp !! Massive body position vectors integer ( I4B ), intent ( in ) :: npl !! Number of active massive bodies ! Internals integer ( I4B ) :: i , j real ( DP ) :: rji2 , irij3 , fac , r2 real ( DP ), dimension ( NDIM ) :: dx associate ( tp => self , ntp => self % nbody ) do concurrent ( i = 1 : ntp , tp % lmask ( i )) do j = 1 , npl dx (:) = tp % xh (:, i ) - xhp (:, j ) r2 = dot_product ( dx (:), dx (:)) fac = GMpl ( j ) / ( r2 * sqrt ( r2 )) tp % ah (:, i ) = tp % ah (:, i ) - fac * dx (:) end do end do end associate return end subroutine kick_getacch_int_tp end submodule s_kick","tags":"","loc":"sourcefile/kick.f90.html"},{"title":"tides_getacch_pl.f90 – swiftest","text":"This file depends on sourcefile~~tides_getacch_pl.f90~~EfferentGraph sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_tides_kick_getacch Source Code tides_getacch_pl.f90 Source Code submodule ( swiftest_classes ) s_tides_kick_getacch use swiftest contains module subroutine tides_kick_getacch_pl ( self , system ) !! author: Jennifer L.L. Pouplin, Carlisle A. wishard, and David A. Minton !! !! Calculated tidal torques from central body to any planet and from any planet to central body !! planet - planet interactions are considered negligable. !! This is a constant time lag model. !! !! Adapted from Mercury-T code from Bolmont et al. (2015) !! !! Reference: !!    Bolmont, E., Raymond, S.N., Leconte, J., Hersant, F., Correia, A.C.M., 2015. !!       Mercury-T : A new code to study tidally evolving multi-planet systems. !!       Applications to Kepler-62. A&A 583, A116. https://doi.org/10.1051/0004-6361/201525909 implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object ! Internals integer ( I4B ) :: i real ( DP ) :: rmag , vmag real ( DP ), dimension ( NDIM ) :: r_unit , v_unit , h_unit , theta_unit , theta_dot , F_T real ( DP ) :: Ftr , Ptopl , Ptocb , r5cbterm , r5plterm associate ( pl => self , npl => self % nbody , cb => system % cb ) pl % atide (:,:) = 0.0_DP cb % atide (:) = 0.0_DP do i = 1 , npl rmag = norm2 ( pl % xh (:, i )) vmag = norm2 ( pl % vh (:, i )) r_unit (:) = pl % xh (:, i ) / rmag v_unit (:) = pl % vh (:, i ) / vmag h_unit (:) = r_unit (:) . cross . v_unit (:) theta_unit (:) = h_unit (:) . cross . r_unit (:) theta_dot = dot_product ( pl % vh (:, i ), theta_unit (:)) ! First calculate the tangential component of the force vector (eq. 5 & 6 of Bolmont et al. 2015) ! The radial component is already computed in the obl_acc methods r5cbterm = pl % Gmass ( i ) ** 2 * cb % k2 * cb % radius ** 5 r5plterm = cb % Gmass ** 2 * pl % k2 ( i ) * pl % radius ( i ) ** 5 Ptopl = 3 * r5plterm * pl % tlag ( i ) / rmag ** 7 Ptocb = 3 * r5cbterm * cb % tlag / rmag ** 7 Ftr = - 3 / rmag ** 7 * ( r5cbterm + r5plterm ) - 3 * vmag / rmag * ( Ptocb + Ptopl ) F_T (:) = ( Ftr + ( Ptocb + Ptopl ) * dot_product ( v_unit , r_unit ) / rmag ) * r_unit (:) & + Ptopl * ( pl % rot (:, i ) - theta_dot (:)) . cross . r_unit (:) & + Ptocb * ( cb % rot (:) - theta_dot (:)) . cross . r_unit (:) cb % atide (:) = cb % atide (:) + F_T (:) / cb % Gmass pl % atide (:, i ) = F_T (:) / pl % Gmass ( i ) end do do i = 1 , npl pl % ah (:, i ) = pl % ah (:, i ) + pl % atide (:, i ) + cb % atide (:) end do end associate return end subroutine tides_kick_getacch_pl end submodule s_tides_kick_getacch","tags":"","loc":"sourcefile/tides_getacch_pl.f90.html"},{"title":"tides_spin_step.f90 – swiftest","text":"This file depends on sourcefile~~tides_spin_step.f90~~EfferentGraph sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_tides_step_spin Source Code tides_spin_step.f90 Source Code submodule ( swiftest_classes ) s_tides_step_spin use swiftest type , extends ( lambda_obj_tvar ) :: tides_derivs_func !! Base class for an lambda function object. This object takes no additional arguments other than the dependent variable x, an array of real numbers procedure ( tidederiv ), pointer , nopass :: lambdaptr_tides_deriv real ( DP ), dimension (:,:), allocatable :: xbeg real ( DP ), dimension (:,:), allocatable :: xend real ( DP ) :: dt contains generic :: init => tides_derivs_init procedure :: evalt => tides_derivs_eval procedure , nopass :: tides_derivs_init end type interface lambda_obj module procedure tides_derivs_init end interface abstract interface function tidederiv ( x , t , dt , xbeg , xend ) result ( y ) ! Template for a 0 argument function import DP , swiftest_nbody_system real ( DP ), dimension (:), intent ( in ) :: x real ( DP ), intent ( in ) :: t real ( DP ), intent ( in ) :: dt real ( DP ), dimension (:,:), intent ( in ) :: xbeg real ( DP ), dimension (:,:), intent ( in ) :: xend real ( DP ), dimension (:), allocatable :: y end function end interface contains module subroutine tides_step_spin_system ( self , param , t , dt ) !! author: Jennifer L.L. Pouplin and David A. Minton !! !! Integrates the spin equations for central and massive bodies of the system subjected to tides. implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize ! Internals real ( DP ), dimension (:), allocatable :: rot0 , rot1 real ( DP ) :: subt real ( DP ), parameter :: tol = 1e-6_DP !! Just a guess at the moment real ( DP ) :: subdt associate ( pl => self % pl , npl => self % pl % nbody , cb => self % cb ) allocate ( rot0 ( NDIM * ( npl + 1 ))) rot0 = [ pack ( pl % rot (:, 1 : npl ),. true .), pack ( cb % rot (:),. true .)] ! Use this space call the ode_solver, passing tides_spin_derivs as the function: subdt = dt / 2 0._DP !rot1(:) = util_solve_rkf45(lambda_obj(tides_spin_derivs, subdt, pl%xbeg, pl%xend), rot0, dt, subdt tol) ! Recover with unpack !pl%rot(:,1:npl) = unpack(rot1... !cb%rot(:) = unpack(rot1... end associate return end subroutine tides_step_spin_system function tides_spin_derivs ( rot_pl_cb , t , dt , xbeg , xend ) result ( drot ) !! Need to add more arguments so we can pull in mass, radius, Ip, J2, etc... !! author: Jennifer L.L. Pouplin and David A. Minton !! !! function used to calculate the derivatives that are fed to the ODE solver implicit none ! Arguments real ( DP ), dimension (:,:), intent ( in ) :: rot_pl_cb !! Array of rotations. The last element is the central body, and all others are massive bodies real ( DP ), intent ( in ) :: t !! Current time, which is used to interpolate the massive body positions real ( DP ), intent ( in ) :: dt !! Total step size real ( DP ), dimension (:,:), intent ( in ) :: xbeg real ( DP ), dimension (:,:), intent ( in ) :: xend ! Internals real ( DP ), dimension (:,:), allocatable :: drot real ( DP ), dimension (:), allocatable :: flatrot real ( DP ), dimension ( NDIM ) :: N_Tcb , N_Rcb , N_Tpl , N_Rpl , xinterp real ( DP ) :: C_cb , C_pl , r_dot_rot_cb , r_dot_rot_pl , rmag integer ( I4B ) :: i , n n = size ( rot_pl_cb , 2 ) if ( allocated ( drot )) deallocate ( drot ) allocate ( drot , mold = rot_pl_cb ) drot (:,:) = 0.0_DP do i = 1 , n - 1 xinterp (:) = xbeg (:, i ) + t / dt * ( xend (:, i ) - xbeg (:, i )) ! Calculate Ncb and Npl as a function of xinterp !drot(:,i) = -Mcb / (Mcb + Mpl(i)) * (N_Tpl + N_Rpl) !drot(:,n) = drot(:,n) - Mcb / (Mcb + Mpl(i) * (N_Tcb + N_Rcb) ! end do return end function tides_spin_derivs function tides_derivs_eval ( self , x , t ) result ( y ) implicit none ! Arguments class ( tides_derivs_func ), intent ( inout ) :: self real ( DP ), dimension (:), intent ( in ) :: x real ( DP ), intent ( in ) :: t ! Result real ( DP ), dimension (:), allocatable :: y if ( associated ( self % lambdaptr_tides_deriv )) then y = self % lambdaptr_tides_deriv ( x , t , self % dt , self % xbeg , self % xend ) else error stop \"Lambda function was not initialized\" end if return end function tides_derivs_eval function tides_derivs_init ( lambda , dt , xbeg , xend ) result ( f ) implicit none ! Arguments procedure ( tidederiv ) :: lambda real ( DP ), intent ( in ) :: dt real ( DP ), dimension (:,:), intent ( in ) :: xbeg real ( DP ), dimension (:,:), intent ( in ) :: xend ! Result type ( tides_derivs_func ) :: f f % lambdaptr_tides_deriv => lambda f % dt = dt allocate ( f % xbeg , source = xbeg ) allocate ( f % xend , source = xend ) return end function tides_derivs_init end submodule s_tides_step_spin","tags":"","loc":"sourcefile/tides_spin_step.f90.html"},{"title":"obl.f90 – swiftest","text":"This file depends on sourcefile~~obl.f90~~EfferentGraph sourcefile~obl.f90 obl.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~obl.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_obl Source Code obl.f90 Source Code submodule ( swiftest_classes ) s_obl use swiftest contains module subroutine obl_acc_body ( self , system ) !! author: David A. Minton !! !! Compute the barycentric accelerations of bodies due to the oblateness of the central body !!      Returned values do not include monopole term or terms higher than J4 !! !! Adapted from David E. Kaufmann's Swifter routine: obl_acc.f90 and obl_acc_tp.f90 !! Adapted from Hal Levison's Swift routine obl_acc.f and obl_acc_tp.f implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object ! Internals integer ( I4B ) :: i real ( DP ) :: r2 , irh , rinv2 , t0 , t1 , t2 , t3 , fac1 , fac2 if ( self % nbody == 0 ) return associate ( n => self % nbody , cb => system % cb ) self % aobl (:,:) = 0.0_DP do concurrent ( i = 1 : n , self % lmask ( i )) r2 = dot_product ( self % xh (:, i ), self % xh (:, i )) irh = 1.0_DP / sqrt ( r2 ) rinv2 = irh ** 2 t0 = - cb % Gmass * rinv2 * rinv2 * irh t1 = 1.5_DP * cb % j2rp2 t2 = self % xh ( 3 , i ) * self % xh ( 3 , i ) * rinv2 t3 = 1.875_DP * cb % j4rp4 * rinv2 fac1 = t0 * ( t1 - t3 - ( 5 * t1 - ( 1 4.0_DP - 2 1.0_DP * t2 ) * t3 ) * t2 ) fac2 = 2 * t0 * ( t1 - ( 2.0_DP - ( 1 4.0_DP * t2 / 3.0_DP )) * t3 ) self % aobl (:, i ) = fac1 * self % xh (:, i ) self % aobl ( 3 , i ) = fac2 * self % xh ( 3 , i ) + self % aobl ( 3 , i ) end do end associate return end subroutine obl_acc_body module subroutine obl_acc_pl ( self , system ) !! author: David A. Minton !! !! Compute the barycentric accelerations of massive bodies due to the oblateness of the central body !! !! Adapted from David E. Kaufmann's Swifter routine: obl_acc.f90 and obl_acc_tp.f90 !! Adapted from Hal Levison's Swift routine obl_acc.f and obl_acc_tp.f implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody , cb => system % cb ) call obl_acc_body ( pl , system ) do i = 1 , NDIM cb % aobl ( i ) = - sum ( pl % Gmass ( 1 : npl ) * pl % aobl ( i , 1 : npl ), pl % lmask ( 1 : npl )) / cb % Gmass end do do concurrent ( i = 1 : npl , pl % lmask ( i )) pl % ah (:, i ) = pl % ah (:, i ) + pl % aobl (:, i ) - cb % aobl (:) end do end associate return end subroutine obl_acc_pl module subroutine obl_acc_tp ( self , system ) !! author: David A. Minton !! !! Compute the barycentric accelerations of massive bodies due to the oblateness of the central body !! !! Adapted from David E. Kaufmann's Swifter routine: obl_acc.f90 and obl_acc_tp.f90 !! Adapted from Hal Levison's Swift routine obl_acc.f and obl_acc_tp.f implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object ! Internals real ( DP ), dimension ( NDIM ) :: aoblcb integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody , cb => system % cb ) call obl_acc_body ( tp , system ) if ( system % lbeg ) then aoblcb = cb % aoblbeg else aoblcb = cb % aoblend end if do concurrent ( i = 1 : ntp , tp % lmask ( i )) tp % ah (:, i ) = tp % ah (:, i ) + tp % aobl (:, i ) - aoblcb (:) end do end associate return end subroutine obl_acc_tp module subroutine obl_pot ( npl , Mcb , Mpl , j2rp2 , j4rp4 , xh , irh , oblpot ) !! author: David A. Minton !! !! Compute the contribution to the total gravitational potential due solely to the oblateness of the central body !!    Returned value does not include monopole term or terms higher than J4 !! !!    Reference: MacMillan, W. D. 1958. The Theory of the Potential, (Dover Publications), 363. !! !! Adapted from David E. Kaufmann's Swifter routine: obl_pot.f90 !! Adapted from Hal Levison's Swift routine obl_pot.f implicit none ! Arguments integer ( I4B ), intent ( in ) :: npl real ( DP ), intent ( in ) :: Mcb real ( DP ), dimension (:), intent ( in ) :: Mpl real ( DP ), intent ( in ) :: j2rp2 , j4rp4 real ( DP ), dimension (:), intent ( in ) :: irh real ( DP ), dimension (:, :), intent ( in ) :: xh real ( DP ), intent ( out ) :: oblpot ! Internals integer ( I4B ) :: i real ( DP ) :: rinv2 , t0 , t1 , t2 , t3 , p2 , p4 , mu oblpot = 0.0_DP mu = Mcb do i = 1 , npl rinv2 = irh ( i ) ** 2 t0 = mu * Mpl ( i ) * rinv2 * irh ( i ) t1 = j2rp2 t2 = xh ( 3 , i ) * xh ( 3 , i ) * rinv2 t3 = j4rp4 * rinv2 p2 = 0.5_DP * ( 3 * t2 - 1.0_DP ) p4 = 0.125_DP * (( 35 * t2 - 3 0.0_DP ) * t2 + 3.0_DP ) oblpot = oblpot + t0 * ( t1 * p2 + t3 * p4 ) end do return end subroutine obl_pot end submodule s_obl","tags":"","loc":"sourcefile/obl.f90.html"},{"title":"orbel.f90 – swiftest","text":"This file depends on sourcefile~~orbel.f90~~EfferentGraph sourcefile~orbel.f90 orbel.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~orbel.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_orbel Source Code orbel.f90 Source Code submodule ( swiftest_classes ) s_orbel use swiftest contains module subroutine orbel_el2xv_vec ( self , cb ) !! author: David A. Minton !! !! A wrapper method that converts all of the cartesian position and velocity vectors of a Swiftest body object to orbital elements. implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body objec ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return call self % set_mu ( cb ) do i = 1 , self % nbody call orbel_el2xv ( self % mu ( i ), self % a ( i ), self % e ( i ), self % inc ( i ), self % capom ( i ), & self % omega ( i ), self % capm ( i ), self % xh (:, i ), self % vh (:, i )) end do end subroutine orbel_el2xv_vec pure subroutine orbel_el2xv ( mu , a , ie , inc , capom , omega , capm , x , v ) !! author: David A. Minton !! !! Compute osculating orbital elements from relative C)rtesian position and velocity !!  All angular measures are returned in radians !!      If inclination < TINY, longitude of the ascending node is arbitrarily set to 0 !! !!      If eccentricity < sqrt(TINY), argument of pericenter is arbitrarily set to 0 !! !!      ALGORITHM:  See Fitzpatrick \"Principles of Cel. Mech.\" !! !! Adapted from Martin Duncan's el2xv.f !! DATE WRITTEN:  May 11, 1992. !! REVISIONS: May 26 - now use better Kepler solver for ellipses !!  and hyperbolae called EHYBRID.F and FHYBRID.F implicit none real ( DP ), intent ( in ) :: mu real ( DP ), intent ( in ) :: a , ie , inc , capom , omega , capm real ( DP ), dimension (:), intent ( out ) :: x , v integer ( I4B ) :: iorbit_type real ( DP ) :: e , cape , capf , zpara , em1 real ( DP ) :: sip , cip , so , co , si , ci real ( DP ) :: d11 , d12 , d13 , d21 , d22 , d23 real ( DP ) :: scap , ccap , shcap , chcap real ( DP ) :: sqe , sqgma , xfac1 , xfac2 , ri , vfac1 , vfac2 if ( ie < 0.0_DP ) then !write(*,*) ' ERROR in orbel_el2xv: e<0, setting e=0!!1' e = 0.0_DP iorbit_type = ELLIPSE else e = ie em1 = e - 1._DP if ( abs ( em1 ) < VSMALL ) then iorbit_type = PARABOLA else if ( e > 1.0_DP ) then iorbit_type = HYPERBOLA else iorbit_type = ELLIPSE end if endif call orbel_scget ( omega , sip , cip ) call orbel_scget ( capom , so , co ) call orbel_scget ( inc , si , ci ) d11 = cip * co - sip * so * ci d12 = cip * so + sip * co * ci d13 = sip * si d21 = - sip * co - cip * so * ci d22 = - sip * so + cip * co * ci d23 = cip * si !-- ! Get the other quantities depending on orbit type ! if ( iorbit_type == ELLIPSE ) then cape = orbel_ehybrid ( e , capm ) call orbel_scget ( cape , scap , ccap ) sqe = sqrt ( 1._DP - e ** 2 ) sqgma = sqrt ( mu * a ) xfac1 = a * ( ccap - e ) xfac2 = a * sqe * scap ri = 1._DP / ( a * ( 1._DP - e * ccap )) vfac1 = - ri * sqgma * scap vfac2 = ri * sqgma * sqe * ccap endif !-- if ( iorbit_type == HYPERBOLA ) then capf = orbel_fhybrid ( e , capm ) call orbel_schget ( capf , shcap , chcap ) sqe = sqrt ( e ** 2 - 1._DP ) sqgma = sqrt ( mu * a ) xfac1 = a * ( e - chcap ) xfac2 = a * sqe * shcap ri = 1._DP / ( a * ( e * chcap - 1._DP )) vfac1 = - ri * sqgma * shcap vfac2 = ri * sqgma * sqe * chcap endif !-- if ( iorbit_type == PARABOLA ) then zpara = orbel_zget ( capm ) sqgma = sqrt ( 2 * mu * a ) xfac1 = a * ( 1._DP - zpara * zpara ) xfac2 = 2 * a * zpara ri = 1._DP / ( a * ( 1._DP + zpara * zpara )) vfac1 = - ri * sqgma * zpara vfac2 = ri * sqgma endif !-- x ( 1 ) = d11 * xfac1 + d21 * xfac2 x ( 2 ) = d12 * xfac1 + d22 * xfac2 x ( 3 ) = d13 * xfac1 + d23 * xfac2 v ( 1 ) = d11 * vfac1 + d21 * vfac2 v ( 2 ) = d12 * vfac1 + d22 * vfac2 v ( 3 ) = d13 * vfac1 + d23 * vfac2 return end subroutine orbel_el2xv module pure subroutine orbel_scget ( angle , sx , cx ) !! author: David A. Minton !! !! Efficiently compute the sine and cosine of an input angle !!      Input angle must be in radians !! !! Adapted from David E. Kaufmann's Swifter routine: orbel_scget.f90 !! Adapted from Hal Levison's Swift routine orbel_scget.f implicit none ! Arguments real ( DP ), intent ( in ) :: angle real ( DP ), intent ( out ) :: sx , cx ! Internals integer ( I4B ) :: nper real ( DP ) :: x nper = angle / TWOPI x = angle - nper * TWOPI if ( x < 0.0_DP ) x = x + TWOPI sx = sin ( x ) cx = sqrt ( 1.0_DP - sx ** 2 ) if (( x > PIBY2 ) . and . ( x < PI3BY2 )) cx = - cx return end subroutine orbel_scget !********************************************************************** ! Code converted to Modern Fortran by David A. Minton ! Date: 2020-06-29 !********************************************************************** !                   ORBEL_SCHGET.F !********************************************************************** !     PURPOSE:  Given an angle, efficiently compute sinh and cosh. ! !        Input: !             angle ==> angle in radians (real scalar) ! !        Output: !             shx    ==>  sinh(angle)  (real scalar) !             chx    ==>  cosh(angle)  (real scalar) ! !     ALGORITHM: Obvious from the code !     REMARKS: Based on the routine SCGET for sine's and cosine's. !       We use the sqrt rather than cosh (it's faster) !       BE SURE THE ANGLE IS IN RADIANS AND IT CAN'T BE LARGER THAN 300 !       OR OVERFLOWS WILL OCCUR! !     AUTHOR:  M. Duncan. !     DATE WRITTEN:  May 6, 1992. !     REVISIONS: !********************************************************************** pure subroutine orbel_schget ( angle , shx , chx ) real ( DP ), intent ( in ) :: angle real ( DP ), intent ( out ) :: shx , chx shx = sinh ( angle ) chx = sqrt ( 1._DP + shx * shx ) return end subroutine orbel_schget !********************************************************************** ! Code converted to Modern Fortran by David A. Minton ! Date: 2020-06-29 !        !                    ORBEL_FLON.F !********************************************************************** !     PURPOSE:  Solves Kepler's eqn. for hyperbola using hybrid approach. ! !             Input: !                           e ==> eccentricity anomaly. (real scalar) !                        capn ==> hyperbola mean anomaly. (real scalar) !             Returns: !                  orbel_flon ==>  eccentric anomaly. (real scalar) ! !     ALGORITHM: Uses power series for N in terms of F and Newton,s method !     REMARKS: ONLY GOOD FOR LOW VALUES OF N (N < 0.636*e -0.6) !     AUTHOR: M. Duncan !     DATE WRITTEN: May 26, 1992. !     REVISIONS: !********************************************************************** real ( DP ) pure function orbel_flon ( e , icapn ) implicit none real ( DP ), intent ( in ) :: e , icapn integer ( I4B ) :: iflag , i real ( DP ) :: a , b , sq , biga , bigb , capn real ( DP ) :: x , x2 real ( DP ) :: f , fp , dx real ( DP ) :: diff real ( DP ) :: a0 , a1 real ( DP ) :: b1 integer ( I4B ), parameter :: IMAX = 10 real ( DP ), parameter :: a11 = 15 6._DP , a9 = 1716 0._DP , a7 = 123552 0._DP real ( DP ), parameter :: a5 = 5189184 0._DP , a3 = 103783680 0._DP real ( DP ), parameter :: b11 = 11 * a11 , b9 = 9 * a9 , b7 = 7 * a7 real ( DP ), parameter :: b5 = 5 * a5 , b3 = 3 * a3 real ( DP ), parameter :: THIRD = 1._DP / 3._DP ! Function to solve \"Kepler's eqn\" for F (here called ! x) for given e and CAPN. Only good for smallish CAPN iflag = 0 if ( icapn < 0._DP ) then iflag = 1 capn = - icapn else capn = icapn end if a1 = 622702080 0._DP * ( 1._DP - 1._DP / e ) a0 = - 622702080 0._DP * capn / e b1 = a1 !  set iflag nonzero if capn < 0., in which case solve for -capn !  and change the sign of the final answer for f. !  Begin with a reasonable guess based on solving the cubic for small F a = 6 * ( e - 1.d0 ) / e b = - 6 * capn / e sq = SQRT ( 0.25_DP * b ** 2 + a ** 3 / 2 7._DP ) biga = ( - 0.5_DP * b + sq ) ** ( 1.0_DP / 3.0_DP ) bigb = - ( + 0.5_DP * b + sq ) ** ( 1.0_DP / 3.0_DP ) x = biga + bigb ! write(6,*) 'cubic = ',x**3 +a*x +b orbel_flon = x ! If capn is VSMALL (or zero) no need to go further than cubic even for ! e =1. if ( capn < VSMALL ) go to 100 do i = 1 , IMAX x2 = x * x f = a0 + x * ( a1 + x2 * ( a3 + x2 * ( a5 + x2 * ( a7 + x2 * ( a9 + x2 * ( a11 + x2 )))))) fp = b1 + x2 * ( b3 + x2 * ( b5 + x2 * ( b7 + x2 * ( b9 + x2 * ( b11 + 13 * x2 ))))) dx = - f / fp !   write(6,*) 'i,dx,x,f : ' !   write(6,432) i,dx,x,f 432 format ( 1 x , i3 , 3 ( 2 x , 1 p1e22 . 15 )) orbel_flon = x + dx !   if we have converged here there's no point in going on if ( abs ( dx ) <= VSMALL ) go to 100 x = orbel_flon end do ! abnormal return here - we've gone thru the loop ! imax times without convergence if ( iflag == 1 ) then orbel_flon = - orbel_flon capn = - capn end if !write(*,*) 'flon : returning without complete convergence' diff = e * sinh ( orbel_flon ) - orbel_flon - capn !write(*,*) 'n, f, ecc*sinh(f) - f - n : ' !write(*,*) capn,orbel_flon,diff return !  normal return here, but check if capn was originally negative 100 if ( iflag == 1 ) then orbel_flon = - orbel_flon capn = - capn end if return end function orbel_flon !********************************************************************** ! Code converted to Modern Fortran by David A. Minton ! Date: 2020-06-29 !                    ORBEL_FGET.F !********************************************************************** !     PURPOSE:  Solves Kepler's eqn. for hyperbola using hybrid approach. ! !             Input: !                           e ==> eccentricity anomaly. (real scalar) !                        capn ==> hyperbola mean anomaly. (real scalar) !             Returns: !                  orbel_fget ==>  eccentric anomaly. (real scalar) ! !     ALGORITHM: Based on pp. 70-72 of Fitzpatrick's book \"Principles of !           Cel. Mech. \".  Quartic convergence from Danby's book. !     REMARKS: !     AUTHOR: M. Duncan !     DATE WRITTEN: May 11, 1992. !     REVISIONS: 2/26/93 hfl !********************************************************************** real ( DP ) pure function orbel_fget ( e , capn ) implicit none real ( DP ), intent ( in ) :: e , capn integer :: i real ( DP ) :: tmp , x , shx , chx real ( DP ) :: esh , ech , f , fp , fpp , fppp , dx integer ( I4B ), parameter :: IMAX = 10 !---- !...  executable code ! function to solve \"kepler's eqn\" for f (here called ! x) for given e and capn. !  begin with a guess proposed by danby if ( capn < 0.d0 ) then tmp = - 2 * capn / e + 1.8_DP x = - log ( tmp ) else tmp = + 2 * capn / e + 1.8_DP x = log ( tmp ) end if orbel_fget = x do i = 1 , IMAX call orbel_schget ( x , shx , chx ) esh = e * shx ech = e * chx f = esh - x - capn !   write(6,*) 'i,x,f : ',i,x,f fp = ech - 1.d0 fpp = esh fppp = ech dx = - f / fp dx = - f / ( fp + dx * fpp / 2._DP ) dx = - f / ( fp + dx * fpp / 2._DP + dx ** 2 * fppp / 6._DP ) orbel_fget = x + dx !   if we have converged here there's no point in going on if ( abs ( dx ) <= VSMALL ) return x = orbel_fget end do !write(*,*) 'fget : returning without complete convergence' return end function orbel_fget !********************************************************************** ! Code converted to Modern Fortran by David A. Minton ! Date: 2020-06-29 !                    ORBEL_ZGET.F !********************************************************************** !     PURPOSE:  Solves the equivalent of Kepler's eqn. for a parabola !          given Q (Fitz. notation.) ! !             Input: !                           q ==>  parabola mean anomaly. (real scalar) !             Returns: !                  orbel_zget ==>  eccentric anomaly. (real scalar) ! !     ALGORITHM: p. 70-72 of Fitzpatrick's book \"Princ. of Cel. Mech.\" !     REMARKS: For a parabola we can solve analytically. !     AUTHOR: M. Duncan !     DATE WRITTEN: May 11, 1992. !     REVISIONS: May 27 - corrected it for negative Q and use power !       series for small Q. !********************************************************************** real ( DP ) pure function orbel_zget ( iq ) implicit none real ( DP ), intent ( in ) :: iq integer ( I4B ) :: iflag real ( DP ) :: x , tmp , q iflag = 0 if ( iq < 0.0_DP ) then iflag = 1 q = - iq else q = iq end if if ( q < 1.e-3_DP ) then orbel_zget = q * ( 1._DP - ( q ** 2 / 3._DP ) * ( 1._DP - q ** 2 )) else x = 0.5_DP * ( 3 * q + sqrt ( 9 * q ** 2 + 4._DP )) tmp = x ** ( 1._DP / 3._DP ) orbel_zget = tmp - 1._DP / tmp end if if ( iflag == 1 ) then orbel_zget = - orbel_zget q = - q end if return end function orbel_zget !********************************************************************** ! Code converted to Modern Fortran by David A. Minton ! Date: 2020-06-29 !                    ORBEL_ESOLMD.F !********************************************************************** !     PURPOSE:  Solves Kepler's eqn.   e is ecc.   m is mean anomaly. ! !             Input: !                           e ==> eccentricity anomaly. (real scalar) !                           m ==> mean anomaly. (real scalar) !             Returns: !                orbel_esolmd ==>  eccentric anomaly. (real scalar) ! !     ALGORITHM: Some sort of quartic convergence from Wisdom. !     REMARKS: ONLY GOOD FOR SMALL ECCENTRICITY SINCE IT ONLY !         ITERATES ONCE. (GOOD FOR PLANET CALCS.) !         ALSO DOES NOT PUT M OR E BETWEEN 0. AND 2*PI !     INCLUDES: needs SCGET.F !     AUTHOR: M. Duncan !     DATE WRITTEN: May 7, 1992. !     REVISIONS: 2/26/93 hfl !********************************************************************** real ( DP ) pure function orbel_esolmd ( e , m ) implicit none real ( DP ), intent ( in ) :: e real ( DP ), intent ( in ) :: m real ( DP ) :: x , sm , cm , sx , cx real ( DP ) :: es , ec , f , fp , fpp , fppp , dx !...    function to solve kepler's eqn for e (here called !...    x) for given e and m. returns value of x. call orbel_scget ( m , sm , cm ) x = m + e * sm * ( 1._DP + e * ( cm + e * ( 1._DP - 1.5_DP * sm ** 2 ))) call orbel_scget ( x , sx , cx ) es = e * sx ec = e * cx f = x - es - m fp = 1._DP - ec fpp = es fppp = ec dx = - f / fp dx = - f / ( fp + dx * fpp / 2._DP ) dx = - f / ( fp + dx * fpp / 2._DP + dx ** 2 * fppp / 6._DP ) orbel_esolmd = x + dx return end function orbel_esolmd !********************************************************************** ! Code converted to Modern Fortran by David A. Minton ! Date: 2020-06-29 !                    ORBEL_EHIE.F !********************************************************************** !     PURPOSE:  Solves Kepler's eqn.   e is ecc.   m is mean anomaly. ! !             Input: !                           e ==> eccentricity anomaly. (real scalar) !                           m ==> mean anomaly. (real scalar) !             Returns: !              orbel_ehybrid ==>  eccentric anomaly. (real scalar) ! !     ALGORITHM: Use Danby's quartic for 3 iterations. !                Eqn. is f(x) = x - e*sin(x+M). Note  that !          E = x + M. First guess is very good for e near 1. !          Need to first get M between 0. and PI and use !   symmetry to return right answer if M between PI and 2PI !     REMARKS: Modifies M so that both E and M are in range (0,TWOPI) !     AUTHOR: M. Duncan !     DATE WRITTEN: May 25,1992. !     REVISIONS: !********************************************************************** real ( DP ) pure function orbel_ehie ( e , im ) implicit none real ( DP ), intent ( in ) :: e , im integer ( I4B ) :: iflag , nper , niter real ( DP ) :: dx , x , sa , ca , esa , eca , f , fp , m integer ( I4B ), parameter :: NMAX = 3 ! in this section, bring m into the range (0,TWOPI) and if ! the result is greater than pi, solve for (TWOPI - m). iflag = 0 nper = im / TWOPI m = im - nper * TWOPI if ( m < 0._DP ) m = m + TWOPI if ( m > PI ) then m = TWOPI - m iflag = 1 end if ! make a first guess that works well for e near 1. x = ( 6 * m ) ** ( 1._DP / 3._DP ) - m niter = 0 ! iteration loop do niter = 1 , NMAX call orbel_scget ( x + m , sa , ca ) esa = e * sa eca = e * ca f = x - esa fp = 1._DP - eca dx = - f / fp dx = - f / ( fp + 0.5_DP * dx * esa ) dx = - f / ( fp + 0.5_DP * dx * ( esa + eca * dx / 3.0_DP )) x = x + dx end do orbel_ehie = m + x if ( iflag == 1 ) then orbel_ehie = TWOPI - orbel_ehie m = TWOPI - m end if return end function orbel_ehie !********************************************************************** ! Code converted to Modern Fortran by David A. Minton ! Date: 2020-06-29 !                             ORBEL_EGET.F !********************************************************************** !     PURPOSE:  Solves Kepler's eqn.   e is ecc.   m is mean anomaly. ! !             Input: !                           e ==> eccentricity anomaly. (real scalar) !                           m ==> mean anomaly. (real scalar) !             Returns: !                  orbel_eget ==>  eccentric anomaly. (real scalar) ! !     ALGORITHM: Quartic convergence from Danby !     REMARKS: For results very near roundoff, give it M between !           0 and 2*pi. One can condition M before calling EGET !           by calling my double precision function MOD2PI(M). !           This is not done within the routine to speed it up !           and because it works fine even for large M. !     AUTHOR: M. Duncan !     DATE WRITTEN: May 7, 1992. !     REVISIONS: May 21, 1992.  Now have it go through EXACTLY two iterations !                with the premise that it will only be called if !          we have an ellipse with e between 0.15 and 0.8 !********************************************************************** real ( DP ) pure function orbel_eget ( e , m ) implicit none real ( DP ), intent ( in ) :: e , m real ( DP ) :: x , sm , cm , sx , cx real ( DP ) :: es , ec , f , fp , fpp , fppp , dx ! function to solve kepler's eqn for e (here called ! x) for given e and m. returns value of x. ! may 21 : for e < 0.18 use esolmd for speed and sufficient accuracy ! may 21 : for e > 0.8 use ehie - this one may not converge fast enough. call orbel_scget ( m , sm , cm ) !  begin with a guess accurate to order ecc**3 x = m + e * sm * ( 1._DP + e * ( cm + e * ( 1._DP - 1.5_DP * sm * sm ))) !  go through one iteration for improved estimate call orbel_scget ( x , sx , cx ) es = e * sx ec = e * cx f = x - es - m fp = 1._DP - ec fpp = es fppp = ec dx = - f / fp dx = - f / ( fp + dx * fpp / 2._DP ) dx = - f / ( fp + dx * fpp / 2._DP + dx * 2 * fppp / 6._DP ) orbel_eget = x + dx ! do another iteration. ! for m between 0 and 2*pi this seems to be enough to ! get near roundoff error for eccentricities between 0 and 0.8 x = orbel_eget call orbel_scget ( x , sx , cx ) es = e * sx ec = e * cx f = x - es - m fp = 1._DP - ec fpp = es fppp = ec dx = - f / fp dx = - f / ( fp + dx * fpp / 2._DP ) dx = - f / ( fp + dx * fpp / 2._DP + dx ** 2 * fppp / 6._DP ) orbel_eget = x + dx return end function orbel_eget !********************************************************************** ! Code converted to Modern Fortran by David A. Minton ! Date: 2020-06-29 !                    ORBEL_EHYBRID.F !********************************************************************** !     PURPOSE:  Solves Kepler's eqn.   e is ecc.   m is mean anomaly. ! !             Input: !                           e ==> eccentricity anomaly. (real scalar) !                           m ==> mean anomaly. (real scalar) !             Returns: !              orbel_ehybrid ==>  eccentric anomaly. (real scalar) ! !     ALGORITHM: For e < 0.18 uses fast routine ESOLMD !          For larger e but less than 0.8, uses EGET !          For e > 0.8 uses EHIE !     REMARKS: Only EHIE brings M and E into range (0,TWOPI) !     AUTHOR: M. Duncan !     DATE WRITTEN: May 25,1992. !     REVISIONS: 2/26/93 hfl !********************************************************************** real ( DP ) pure function orbel_ehybrid ( e , m ) implicit none real ( DP ), intent ( in ) :: e , m !real(DP) :: orbel_esolmd,orbel_eget,orbel_ehie if ( e < 0.18_DP ) then orbel_ehybrid = orbel_esolmd ( e , m ) else if ( e <= 0.8_DP ) then orbel_ehybrid = orbel_eget ( e , m ) else orbel_ehybrid = orbel_ehie ( e , m ) end if end if return end function orbel_ehybrid !********************************************************************** ! Code converted to Modern Fortran by David A. Minton ! Date: 2020-06-29 !                    ORBEL_FHYBRID.F !********************************************************************** !     PURPOSE:  Solves Kepler's eqn. for hyperbola using hybrid approach. ! !             Input: !                           e ==> eccentricity anomaly. (real scalar) !                           n ==> hyperbola mean anomaly. (real scalar) !             Returns: !               orbel_fhybrid ==>  eccentric anomaly. (real scalar) ! !     ALGORITHM: For abs(N) < 0.636*ecc -0.6 , use FLON !          For larger N, uses FGET !     REMARKS: !     AUTHOR: M. Duncan !     DATE WRITTEN: May 26,1992. !     REVISIONS:: !     REVISIONS: 2/26/93 hfl !********************************************************************** real ( DP ) pure function orbel_fhybrid ( e , n ) implicit none real ( DP ), intent ( in ) :: e , n real ( DP ) :: abn abn = n if ( n < 0._DP ) abn = - abn if ( abn < 0.636_DP * e - 0.6_DP ) then orbel_fhybrid = orbel_flon ( e , n ) else orbel_fhybrid = orbel_fget ( e , n ) end if return end function orbel_fhybrid module pure subroutine orbel_xv2aeq ( mu , x , v , a , e , q ) !! author: David A. Minton !! !! Compute semimajor axis, eccentricity, and pericentric distance from relative Cartesian position and velocity !! !! Adapted from David E. Kaufmann's Swifter routine: orbel_xv2aeq.f90 !! Adapted from Luke Dones' Swift routine orbel_xv2aeq.f implicit none !! Arguments real ( DP ), intent ( in ) :: mu real ( DP ), dimension (:), intent ( in ) :: x , v real ( DP ), intent ( out ) :: a , e , q integer ( I4B ) :: iorbit_type real ( DP ) :: r , v2 , h2 , energy , fac real ( DP ), dimension ( NDIM ) :: hvec a = 0.0_DP e = 0.0_DP q = 0.0_DP r = sqrt ( dot_product ( x (:), x (:))) v2 = dot_product ( v (:), v (:)) hvec (:) = x (:) . cross . v (:) h2 = dot_product ( hvec (:), hvec (:)) if ( h2 == 0.0_DP ) return energy = 0.5_DP * v2 - mu / r if ( abs ( energy * r / mu ) < sqrt ( VSMALL )) then iorbit_type = PARABOLA else a = - 0.5_DP * mu / energy if ( a < 0.0_DP ) then fac = - h2 / ( mu * a ) if ( fac > VSMALL ) then iorbit_type = HYPERBOLA else iorbit_type = PARABOLA end if else iorbit_type = ELLIPSE end if end if select case ( iorbit_type ) case ( ELLIPSE ) fac = 1.0_DP - h2 / ( mu * a ) if ( fac > VSMALL ) e = sqrt ( fac ) q = a * ( 1.0_DP - e ) case ( PARABOLA ) a = 0.5_DP * h2 / mu e = 1.0_DP q = a case ( HYPERBOLA ) e = sqrt ( 1.0_DP + fac ) q = a * ( 1.0_DP - e ) end select return end subroutine orbel_xv2aeq module pure subroutine orbel_xv2aqt ( mu , x , v , a , q , capm , tperi ) !! author: David A. Minton !! !! Compute semimajor axis, pericentric distance, mean anomaly, and time to nearest pericenter passage from !! relative Cartesian position and velocity !!      tperi > 0 means nearest pericenter passage is in the future !!      tperi < 0 means nearest pericenter passage is in the past !! !! Adapted from David E. Kaufmann's Swifter routine: orbel_xv2aqt.f90 implicit none ! Arguments real ( DP ), intent ( in ) :: mu !! Gravitational constant real ( DP ), dimension (:), intent ( in ) :: x !! Position vector real ( DP ), dimension (:), intent ( in ) :: v !! Velocity vector real ( DP ), intent ( out ) :: a !! semimajor axis real ( DP ), intent ( out ) :: q !! periapsis real ( DP ), intent ( out ) :: capm !! mean anomaly real ( DP ), intent ( out ) :: tperi !! time of pericenter passage ! Internals integer ( I4B ) :: iorbit_type real ( DP ) :: r , v2 , h2 , rdotv , energy , fac , w , face , cape , e , tmpf , capf , mm real ( DP ), dimension ( NDIM ) :: hvec a = 0.0_DP q = 0.0_DP capm = 0.0_DP tperi = 0.0_DP r = sqrt ( dot_product ( x (:), x (:))) v2 = dot_product ( v (:), v (:)) hvec (:) = x (:) . cross . v (:) h2 = dot_product ( hvec (:), hvec (:)) if ( h2 == 0.0_DP ) return rdotv = dot_product ( x (:), v (:)) energy = 0.5_DP * v2 - mu / r if ( abs ( energy * r / mu ) < sqrt ( VSMALL )) then iorbit_type = PARABOLA else a = - 0.5_DP * mu / energy if ( a < 0.0_DP ) then fac = - h2 / ( mu * a ) if ( fac > VSMALL ) then iorbit_type = HYPERBOLA else iorbit_type = PARABOLA end if else iorbit_type = ELLIPSE end if end if select case ( iorbit_type ) case ( ELLIPSE ) fac = 1.0_DP - h2 / ( mu * a ) if ( fac > VSMALL ) then e = sqrt ( fac ) cape = 0.0_DP face = ( a - r ) / ( a * e ) if ( face < - 1.0_DP ) then cape = PI else if ( face < 1.0_DP ) then cape = acos ( face ) end if if ( rdotv < 0.0_DP ) cape = TWOPI - cape else e = 0.0_DP cape = 0.0_DP end if capm = cape - e * sin ( cape ) q = a * ( 1.0_DP - e ) mm = sqrt ( mu / a ** 3 ) if ( capm < PI ) then tperi = - 1.0_DP * capm / mm else tperi = - 1.0_DP * ( capm - TWOPI ) / mm end if case ( PARABOLA ) a = 0.5_DP * h2 / mu e = 1.0_DP w = 0.0_DP fac = 2 * a / r - 1.0_DP if ( fac < - 1.0_DP ) then w = PI else if ( fac < 1.0_DP ) then w = acos ( fac ) end if if ( rdotv < 0.0_DP ) w = TWOPI - w tmpf = tan ( 0.5_DP * w ) capm = tmpf * ( 1.0_DP + tmpf * tmpf / 3.0_DP ) q = a mm = sqrt ( 0.5_DP * mu / q ** 3 ) tperi = - 1.0_DP * capm / mm case ( HYPERBOLA ) e = sqrt ( 1.0_DP + fac ) tmpf = ( a - r ) / ( a * e ) if ( tmpf < 1.0_DP ) tmpf = 1.0_DP capf = log ( tmpf + sqrt ( tmpf * tmpf - 1.0_DP )) if ( rdotv < 0.0_DP ) capf = - capf capm = e * sinh ( capf ) - capf q = a * ( 1.0_DP - e ) mm = sqrt ( - mu / a ** 3 ) tperi = - 1.0_DP * capm / mm end select return end subroutine orbel_xv2aqt module subroutine orbel_xv2el_vec ( self , cb ) !! author: David A. Minton !! !! A wrapper method that converts all of the cartesian position and velocity vectors of a Swiftest body object to orbital elements. implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object ! internals integer ( I4B ) :: i if ( self % nbody == 0 ) return call self % set_mu ( cb ) if (. not . allocated ( self % a )) allocate ( self % a ( self % nbody )) if (. not . allocated ( self % e )) allocate ( self % e ( self % nbody )) if (. not . allocated ( self % inc )) allocate ( self % inc ( self % nbody )) if (. not . allocated ( self % capom )) allocate ( self % capom ( self % nbody )) if (. not . allocated ( self % omega )) allocate ( self % omega ( self % nbody )) if (. not . allocated ( self % capm )) allocate ( self % capm ( self % nbody )) do i = 1 , self % nbody call orbel_xv2el ( self % mu ( i ), self % xh (:, i ), self % vh (:, i ), self % a ( i ), self % e ( i ), self % inc ( i ), & self % capom ( i ), self % omega ( i ), self % capm ( i )) end do end subroutine orbel_xv2el_vec pure subroutine orbel_xv2el ( mu , x , v , a , e , inc , capom , omega , capm ) !! author: David A. Minton !! !! Compute osculating orbital elements from relative Cartesian position and velocity !!  All angular measures are returned in radians !!      If inclination < TINY, longitude of the ascending node is arbitrarily set to 0 !! !!      If eccentricity < sqrt(TINY), argument of pericenter is arbitrarily set to 0 !! !!      References: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 201 - 206. !!              Fitzpatrick, P. M. 1970. Principles of Celestial Mechanics, (Academic Press), 69 - 73. !!              Roy, A. E. 1982. Orbital Motion, (Adam Hilger, Ltd.), 75 - 95 !! !! Adapted from David E. Kaufmann's Swifter routine: orbel_xv2el.f90 !! Adapted from Martin Duncan's Swift routine orbel_xv2el.f implicit none real ( DP ), intent ( in ) :: mu real ( DP ), dimension (:), intent ( in ) :: x , v real ( DP ), intent ( out ) :: a , e , inc , capom , omega , capm integer ( I4B ) :: iorbit_type real ( DP ) :: r , v2 , h2 , h , rdotv , energy , fac , u , w , cw , sw , face , cape , tmpf , capf real ( DP ), dimension ( NDIM ) :: hvec a = 0.0_DP e = 0.0_DP inc = 0.0_DP capom = 0.0_DP omega = 0.0_DP capm = 0.0_DP r = sqrt ( dot_product ( x (:), x (:))) v2 = dot_product ( v (:), v (:)) hvec = x (:) . cross . v (:) h2 = dot_product ( hvec (:), hvec (:)) h = sqrt ( h2 ) if ( h2 == 0.0_DP ) return rdotv = dot_product ( x (:), v (:)) energy = 0.5_DP * v2 - mu / r fac = hvec ( 3 ) / h if ( fac < - 1.0_DP ) then inc = PI else if ( fac < 1.0_DP ) then inc = acos ( fac ) end if fac = sqrt ( hvec ( 1 ) ** 2 + hvec ( 2 ) ** 2 ) / h if ( fac ** 2 < VSMALL ) then u = atan2 ( x ( 2 ), x ( 1 )) if ( hvec ( 3 ) < 0.0_DP ) u = - u else capom = atan2 ( hvec ( 1 ), - hvec ( 2 )) u = atan2 ( x ( 3 ) / sin ( inc ), x ( 1 ) * cos ( capom ) + x ( 2 ) * sin ( capom )) end if if ( capom < 0.0_DP ) capom = capom + TWOPI if ( u < 0.0_DP ) u = u + TWOPI if ( abs ( energy * r / mu ) < sqrt ( VSMALL )) then iorbit_type = parabola else a = - 0.5_DP * mu / energy if ( a < 0.0_DP ) then fac = - h2 / ( mu * a ) if ( fac > VSMALL ) then iorbit_type = HYPERBOLA else iorbit_type = PARABOLA end if else iorbit_type = ELLIPSE end if end if select case ( iorbit_type ) case ( ELLIPSE ) fac = 1.0_DP - h2 / ( mu * a ) if ( fac > VSMALL ) then e = sqrt ( fac ) cape = 0.0_DP face = ( a - r ) / ( a * e ) if ( face < - 1.0_DP ) then cape = PI else if ( face < 1.0_DP ) then cape = acos ( face ) end if if ( rdotv < 0.0_DP ) cape = TWOPI - cape fac = 1.0_DP - e * cos ( cape ) cw = ( cos ( cape ) - e ) / fac sw = sqrt ( 1.0_DP - e ** 2 ) * sin ( cape ) / fac w = atan2 ( sw , cw ) if ( w < 0.0_DP ) w = w + TWOPI else cape = u w = u end if capm = cape - e * sin ( cape ) case ( PARABOLA ) a = 0.5_DP * h2 / mu e = 1.0_DP w = 0.0_DP fac = 2 * a / r - 1.0_DP if ( fac < - 1.0_DP ) then w = PI else if ( fac < 1.0_DP ) then w = acos ( fac ) end if if ( rdotv < 0.0_DP ) w = TWOPI - w tmpf = tan ( 0.5_DP * w ) capm = tmpf * ( 1.0_DP + tmpf * tmpf / 3.0_DP ) case ( HYPERBOLA ) e = sqrt ( 1.0_DP + fac ) tmpf = max (( a - r ) / ( a * e ), 1.0_DP ) capf = log ( tmpf + sqrt ( tmpf ** 2 - 1.0_DP )) if ( rdotv < 0.0_DP ) capf = - capf fac = e * cosh ( capf ) - 1.0_DP cw = ( e - cosh ( capf )) / fac sw = sqrt ( e * e - 1.0_DP ) * sinh ( capf ) / fac w = atan2 ( sw , cw ) if ( w < 0.0_DP ) w = w + TWOPI capm = e * sinh ( capf ) - capf end select omega = u - w if ( omega < 0.0_DP ) omega = omega + TWOPI return end subroutine orbel_xv2el end submodule s_orbel","tags":"","loc":"sourcefile/orbel.f90.html"},{"title":"whm_coord.f90 – swiftest","text":"This file depends on sourcefile~~whm_coord.f90~~EfferentGraph sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~whm_coord.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_whm_coord Source Code whm_coord.f90 Source Code submodule ( whm_classes ) s_whm_coord use swiftest contains module subroutine whm_coord_h2j_pl ( self , cb ) !! author: David A. Minton !! !! Convert from heliocentric to Jacobi coordinates, massive bodies only !! !! Uses pre-computed eta rather than computing it each time !! !! Adapted from David E. Kaufmann's Swifter routine coord_h2j.f90 !! !! Adapted from Hal Levison's Swift routine coord_h2j.f implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body particle data structuree ! Internals integer ( I4B ) :: i real ( DP ), dimension ( NDIM ) :: sumx , sumv , cap , capv if ( self % nbody == 0 ) return associate ( npl => self % nbody , GMpl => self % Gmass , eta => self % eta , xh => self % xh , vh => self % vh , & xj => self % xj , vj => self % vj ) xj (:, 1 ) = xh (:, 1 ) vj (:, 1 ) = vh (:, 1 ) sumx (:) = 0.0_DP sumv (:) = 0.0_DP do i = 2 , npl sumx (:) = sumx (:) + GMpl ( i - 1 ) * xh (:, i - 1 ) sumv (:) = sumv (:) + GMpl ( i - 1 ) * vh (:, i - 1 ) cap (:) = sumx (:) / eta ( i - 1 ) capv (:) = sumv (:) / eta ( i - 1 ) xj (:, i ) = xh (:, i ) - cap (:) vj (:, i ) = vh (:, i ) - capv (:) end do end associate return end subroutine whm_coord_h2j_pl module subroutine whm_coord_j2h_pl ( self , cb ) !! author: David A. Minton !! !! Convert from Jacobi to heliocentric coordinates, massive bodies only. !! !! Uses pre-computed eta rather than computing it each time !! !! !! Adapted from David E. Kaufmann's Swifter routine coord_j2h.f90 !! !! Adapted from Hal Levison's Swift routine coord_j2h.f implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body particle data structuree ! Internals integer ( I4B ) :: i real ( DP ), dimension ( NDIM ) :: sumx , sumv if ( self % nbody == 0 ) return associate ( npl => self % nbody , GMpl => self % Gmass , eta => self % eta , xh => self % xh , vh => self % vh , & xj => self % xj , vj => self % vj ) xh (:, 1 ) = xj (:, 1 ) vh (:, 1 ) = vj (:, 1 ) sumx (:) = 0.0_DP sumv (:) = 0.0_DP do i = 2 , npl sumx (:) = sumx (:) + GMpl ( i - 1 ) * xj (:, i - 1 ) / eta ( i - 1 ) sumv (:) = sumv (:) + GMpl ( i - 1 ) * vj (:, i - 1 ) / eta ( i - 1 ) xh (:, i ) = xj (:, i ) + sumx (:) vh (:, i ) = vj (:, i ) + sumv (:) end do end associate return end subroutine whm_coord_j2h_pl module subroutine whm_coord_vh2vj_pl ( self , cb ) !! author: David A. Minton !! !! Convert from heliocentric to Jadcobi coordinates, massive body velocities only !! !! Uses pre-computed eta rather than computing it each time !! !! Adapted from David E. Kaufmann's Swifter routine coord_vh2vj.f90 !! !! Adapted from Hal Levison's Swift routine coord_vh2vj.f implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body particle data structuree ! Internals integer ( I4B ) :: i real ( DP ), dimension ( NDIM ) :: sumv , capv if ( self % nbody == 0 ) return associate ( npl => self % nbody , GMpl => self % Gmass , vh => self % vh , vj => self % vj , eta => self % eta ) vj (:, 1 ) = vh (:, 1 ) sumv (:) = 0.0_DP do i = 2 , npl sumv (:) = sumv (:) + GMpl ( i - 1 ) * vh (:, i - 1 ) capv (:) = sumv (:) / eta ( i - 1 ) vj (:, i ) = vh (:, i ) - capv (:) end do end associate return end subroutine whm_coord_vh2vj_pl end submodule s_whm_coord","tags":"","loc":"sourcefile/whm_coord.f90.html"},{"title":"whm_gr.f90 – swiftest","text":"This file depends on sourcefile~~whm_gr.f90~~EfferentGraph sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~whm_gr.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_whm_gr Source Code whm_gr.f90 Source Code submodule ( whm_classes ) s_whm_gr use swiftest contains module subroutine whm_gr_kick_getacch_pl ( self , param ) !! author: David A. Minton !! !! Compute relativisitic accelerations of massive bodies !!    Based on Saha & Tremaine (1994) Eq. 28 !! !! Adapted from David A. Minton's Swifter routine routine gr_whm_kick_getacch.f90 implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i real ( DP ), dimension ( NDIM ) :: suma real ( DP ), dimension (:, :), allocatable :: aj real ( DP ) :: beta , rjmag4 if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody , inv_c2 => param % inv_c2 ) call gr_kick_getacch ( pl % muj , pl % xj , pl % lmask , npl , param % inv_c2 , pl % agr ) suma (:) = 0.0_DP pl % ah (:, 1 ) = pl % ah (:, 1 ) + pl % agr (:, 1 ) do i = 2 , npl suma (:) = suma (:) + pl % Gmass ( i ) * pl % agr (:, i ) / pl % eta ( i ) pl % ah (:, i ) = pl % ah (:, i ) + pl % agr (:, i ) + suma (:) end do end associate return end subroutine whm_gr_kick_getacch_pl module subroutine whm_gr_kick_getacch_tp ( self , param ) !! author: David A. Minton !! !! Compute relativisitic accelerations of test particles !!    Based on Saha & Tremaine (1994) Eq. 28 !! !! Adapted from David A. Minton's Swifter routine routine gr_whm_kick_getacch.f90 implicit none ! Arguments class ( whm_tp ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i real ( DP ) :: rjmag4 , beta if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody , inv_c2 => param % inv_c2 ) call gr_kick_getacch ( tp % mu , tp % xh , tp % lmask , ntp , param % inv_c2 , tp % agr ) tp % ah (:, 1 : ntp ) = tp % ah (:, 1 : ntp ) + tp % agr (:, 1 : ntp ) end associate return end subroutine whm_gr_kick_getacch_tp module pure subroutine whm_gr_p4_pl ( self , param , dt ) !! author: David A. Minton !! !! Position kick to massive bodies due to p**4 term in the post-Newtonian correction !!    Based on Saha & Tremaine (1994) Eq. 28 !! !! Adapted from David A. Minton's Swifter routine routine gr_whm_p4.f90 implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Step size ! Internals integer ( I4B ) :: i associate ( pl => self , npl => self % nbody ) if ( npl == 0 ) return do concurrent ( i = 1 : npl , pl % lmask ( i )) call gr_p4_pos_kick ( param , pl % xj (:, i ), pl % vj (:, i ), dt ) end do end associate return end subroutine whm_gr_p4_pl module pure subroutine whm_gr_p4_tp ( self , param , dt ) !! author: David A. Minton !! !! Position kick to test particles due to p**4 term in the post-Newtonian correction !!    Based on Saha & Tremaine (1994) Eq. 28 !! !! Adapted from David A. Minton's Swifter routine routine gr_whm_p4.f90 implicit none ! Arguments class ( whm_tp ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Step size ! Internals integer ( I4B ) :: i associate ( tp => self , ntp => self % nbody ) if ( ntp == 0 ) return do concurrent ( i = 1 : ntp , tp % lmask ( i )) call gr_p4_pos_kick ( param , tp % xh (:, i ), tp % vh (:, i ), dt ) end do end associate return end subroutine whm_gr_p4_tp end submodule s_whm_gr","tags":"","loc":"sourcefile/whm_gr.f90.html"},{"title":"whm_step.f90 – swiftest","text":"This file depends on sourcefile~~whm_step.f90~~EfferentGraph sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~whm_step.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_whm_step Source Code whm_step.f90 Source Code submodule ( whm_classes ) s_whm_step use swiftest contains module subroutine whm_step_system ( self , param , t , dt ) !! author: David A. Minton !! !! Step massive bodies and and active test particles ahead in heliocentric coordinates !! !! Adapted from Hal Levison's Swift routine step_kdk.f !! Adapted from David E. Kaufmann's Swifter routine whm_step.f90 implicit none ! Arguments class ( whm_nbody_system ), intent ( inout ) :: self !! WHM nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize associate ( system => self , cb => self % cb , pl => self % pl , tp => self % tp ) tp % lfirst = pl % lfirst call pl % step ( system , param , t , dt ) call tp % step ( system , param , t , dt ) if ( param % ltides ) call system % step_spin ( param , t , dt ) end associate return end subroutine whm_step_system module subroutine whm_step_pl ( self , system , param , t , dt ) !! author: David A. Minton !! !! Step planets ahead using kick-drift-kick algorithm !! !! Adapted from Hal Levison's Swift routine step_kdk_pl.f !! Adapted from David E. Kaufmann's Swifter routine whm_step_pl.f90 !logical, save :: lfirst = .true. implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize ! Internals real ( DP ) :: dth if ( self % nbody == 0 ) return associate ( pl => self , cb => system % cb ) dth = 0.5_DP * dt call pl % kick ( system , param , t , dth , lbeg = . true .) call pl % vh2vj ( cb ) if ( param % lgr ) call pl % gr_pos_kick ( param , dth ) call pl % drift ( system , param , dt ) if ( param % lgr ) call pl % gr_pos_kick ( param , dth ) call pl % j2h ( cb ) call pl % kick ( system , param , t + dt , dth , lbeg = . false .) end associate return end subroutine whm_step_pl module subroutine whm_step_tp ( self , system , param , t , dt ) !! author: David A. Minton !! !! Step active test particles ahead using kick-drift-kick algorithm !! !! Adapted from Hal Levison's Swift routine step_kdk_tp.f !! Adapted from David E. Kaufmann's Swifter routine whm_step_tp.f90 implicit none ! Arguments class ( whm_tp ), intent ( inout ) :: self !! WHM test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize ! Internals real ( DP ) :: dth if ( self % nbody == 0 ) return select type ( system ) class is ( whm_nbody_system ) associate ( tp => self , cb => system % cb , pl => system % pl ) dth = 0.5_DP * dt call tp % kick ( system , param , t , dth , lbeg = . true .) if ( param % lgr ) call tp % gr_pos_kick ( param , dth ) call tp % drift ( system , param , dt ) if ( param % lgr ) call tp % gr_pos_kick ( param , dth ) call tp % kick ( system , param , t + dt , dth , lbeg = . false .) end associate end select return end subroutine whm_step_tp end submodule s_whm_step","tags":"","loc":"sourcefile/whm_step.f90.html"},{"title":"whm_drift.f90 – swiftest","text":"This file depends on sourcefile~~whm_drift.f90~~EfferentGraph sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~whm_drift.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules whm_drift Source Code whm_drift.f90 Source Code submodule ( whm_classes ) whm_drift use swiftest contains module subroutine whm_drift_pl ( self , system , param , dt ) !! author: David A. Minton !! !! Loop through planets and call Danby drift routine !! !! Adapted from Hal Levison's Swift routine drift.f !! Adapted from David E. Kaufmann's Swifter routine whm_drift.f90 implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! WHM nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize ! Internals integer ( I4B ) :: i integer ( I4B ), dimension (:), allocatable :: iflag if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) allocate ( iflag ( npl )) iflag (:) = 0 call drift_all ( pl % muj , pl % xj , pl % vj , npl , param , dt , pl % lmask , iflag ) if ( any ( iflag ( 1 : npl ) /= 0 )) then where ( iflag ( 1 : npl ) /= 0 ) pl % status ( 1 : npl ) = DISCARDED_DRIFTERR pl % lmask ( 1 : npl ) = . false . end where do i = 1 , npl if ( iflag ( i ) /= 0 ) then write ( * , * ) \" Planet \" , pl % id ( i ), \" is lost!!!!!!!!!!!!\" WRITE ( * , * ) pl % muj ( i ), dt WRITE ( * , * ) pl % xj (:, i ) WRITE ( * , * ) pl % vj (:, i ) WRITE ( * , * ) \" STOPPING \" end if end do call util_exit ( FAILURE ) end if end associate return end subroutine whm_drift_pl end submodule whm_drift","tags":"","loc":"sourcefile/whm_drift.f90.html"},{"title":"whm_kick.f90 – swiftest","text":"This file depends on sourcefile~~whm_kick.f90~~EfferentGraph sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~whm_kick.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_whm_kick Source Code whm_kick.f90 Source Code submodule ( whm_classes ) s_whm_kick use swiftest contains module subroutine whm_kick_getacch_pl ( self , system , param , t , lbeg ) !! author: David A. Minton !! !! Compute heliocentric accelerations of planets !! !! Adapted from Hal Levison's Swift routine getacch.f !! Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch.f90 implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest central body particle data structure class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step ! Internals integer ( I4B ) :: i real ( DP ), dimension ( NDIM ) :: ah0 if ( self % nbody == 0 ) return associate ( cb => system % cb , pl => self , npl => self % nbody ) call pl % set_ir3 () ah0 (:) = whm_kick_getacch_ah0 ( pl % Gmass ( 2 : npl ), pl % xh (:, 2 : npl ), npl - 1 ) do i = 1 , npl pl % ah (:, i ) = pl % ah (:, i ) + ah0 (:) end do call whm_kick_getacch_ah1 ( cb , pl ) call whm_kick_getacch_ah2 ( cb , pl ) call pl % accel_int () if ( param % loblatecb ) then call pl % accel_obl ( system ) if ( lbeg ) then cb % aoblbeg = cb % aobl else cb % aoblend = cb % aobl end if if ( param % ltides ) then cb % atidebeg = cb % aobl call pl % accel_tides ( system ) cb % atideend = cb % atide end if end if if ( param % lgr ) call pl % accel_gr ( param ) if ( param % lextra_force ) call pl % accel_user ( system , param , t , lbeg ) end associate return end subroutine whm_kick_getacch_pl module subroutine whm_kick_getacch_tp ( self , system , param , t , lbeg ) !! author: David A. Minton !! !! Compute heliocentric accelerations of test particles !! !! Adapted from Hal Levison's Swift routine getacch_tp.f !! Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_tp.f90 implicit none ! Arguments class ( whm_tp ), intent ( inout ) :: self !! WHM test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest central body particle data structure class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step ! Internals integer ( I4B ) :: i real ( DP ), dimension ( NDIM ) :: ah0 associate ( tp => self , ntp => self % nbody , pl => system % pl , cb => system % cb , npl => system % pl % nbody ) if ( ntp == 0 . or . npl == 0 ) return system % lbeg = lbeg if ( lbeg ) then ah0 (:) = whm_kick_getacch_ah0 ( pl % Gmass (:), pl % xbeg (:,:), npl ) do concurrent ( i = 1 : ntp , tp % lmask ( i )) tp % ah (:, i ) = tp % ah (:, i ) + ah0 (:) end do call tp % accel_int ( pl % Gmass (:), pl % xbeg (:,:), npl ) else ah0 (:) = whm_kick_getacch_ah0 ( pl % Gmass (:), pl % xend (:,:), npl ) do concurrent ( i = 1 : ntp , tp % lmask ( i )) tp % ah (:, i ) = tp % ah (:, i ) + ah0 (:) end do call tp % accel_int ( pl % Gmass (:), pl % xend (:,:), npl ) end if if ( param % loblatecb ) call tp % accel_obl ( system ) if ( param % lextra_force ) call tp % accel_user ( system , param , t , lbeg ) if ( param % lgr ) call tp % accel_gr ( param ) end associate return end subroutine whm_kick_getacch_tp function whm_kick_getacch_ah0 ( mu , xhp , n ) result ( ah0 ) !! author: David A. Minton !! !! Compute zeroth term heliocentric accelerations of planets implicit none ! Arguments real ( DP ), dimension (:), intent ( in ) :: mu real ( DP ), dimension (:,:), intent ( in ) :: xhp integer ( I4B ), intent ( in ) :: n ! Result real ( DP ), dimension ( NDIM ) :: ah0 ! Internals real ( DP ) :: fac , r2 , ir3h , irh integer ( I4B ) :: i ah0 (:) = 0.0_DP do i = 1 , n r2 = dot_product ( xhp (:, i ), xhp (:, i )) irh = 1.0_DP / sqrt ( r2 ) ir3h = irh / r2 fac = mu ( i ) * ir3h ah0 (:) = ah0 (:) - fac * xhp (:, i ) end do return end function whm_kick_getacch_ah0 pure subroutine whm_kick_getacch_ah1 ( cb , pl ) !! author: David A. Minton !! !! Compute first term heliocentric accelerations of planets !! !! Adapted from Hal Levison's Swift routine getacch_ah1.f !! Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah1.f90 implicit none ! Arguments class ( swiftest_cb ), intent ( in ) :: cb !! WHM central body object class ( whm_pl ), intent ( inout ) :: pl !! WHM massive body object ! Internals integer ( I4B ) :: i real ( DP ), dimension ( NDIM ) :: ah1h , ah1j associate ( npl => pl % nbody ) do concurrent ( i = 2 : npl , pl % lmask ( i )) ah1j (:) = pl % xj (:, i ) * pl % ir3j ( i ) ah1h (:) = pl % xh (:, i ) * pl % ir3h ( i ) pl % ah (:, i ) = pl % ah (:, i ) + cb % Gmass * ( ah1j (:) - ah1h (:)) end do end associate return end subroutine whm_kick_getacch_ah1 pure subroutine whm_kick_getacch_ah2 ( cb , pl ) !! author: David A. Minton !! !! Compute second term heliocentric accelerations of planets !! !! Adapted from Hal Levison's Swift routine getacch_ah2.f !! Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah2.f90 implicit none ! Arguments class ( swiftest_cb ), intent ( in ) :: cb !! Swiftest central body object class ( whm_pl ), intent ( inout ) :: pl !! WHM massive body object ! Internals integer ( I4B ) :: i real ( DP ) :: etaj , fac real ( DP ), dimension ( NDIM ) :: ah2 , ah2o associate ( npl => pl % nbody ) ah2 (:) = 0.0_DP ah2o (:) = 0.0_DP etaj = cb % Gmass do concurrent ( i = 2 : npl , pl % lmask ( i )) etaj = etaj + pl % Gmass ( i - 1 ) fac = pl % Gmass ( i ) * cb % Gmass * pl % ir3j ( i ) / etaj ah2 (:) = ah2o + fac * pl % xj (:, i ) pl % ah (:, i ) = pl % ah (:, i ) + ah2 (:) ah2o (:) = ah2 (:) end do end associate return end subroutine whm_kick_getacch_ah2 module subroutine whm_kick_vh_pl ( self , system , param , t , dt , lbeg ) !! author: David A. Minton !! !! Kick heliocentric velocities of massive bodies !! !! Adapted from Martin Duncan and Hal Levison's Swift routine kickvh.f !! Adapted from David E. Kaufmann's Swifter routine whm_kickvh.f90 implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Logical flag indicating whether this is the beginning of the half step or not. ! Internals integer ( I4B ) :: i associate ( pl => self , npl => self % nbody , cb => system % cb ) if ( npl == 0 ) return if ( lbeg ) then if ( pl % lfirst ) then call pl % h2j ( cb ) pl % ah (:,:) = 0.0_DP call pl % accel ( system , param , t , lbeg ) pl % lfirst = . false . end if call pl % set_beg_end ( xbeg = pl % xh ) else pl % ah (:,:) = 0.0_DP call pl % accel ( system , param , t , lbeg ) call pl % set_beg_end ( xend = pl % xh ) end if do concurrent ( i = 1 : npl , pl % lmask ( i )) pl % vh (:, i ) = pl % vh (:, i ) + pl % ah (:, i ) * dt end do end associate return end subroutine whm_kick_vh_pl module subroutine whm_kick_vh_tp ( self , system , param , t , dt , lbeg ) !! author: David A. Minton !! !! Kick heliocentric velocities of test particles !! !! Adapted from Martin Duncan and Hal Levison's Swift routine kickvh_tp.f !! Adapted from David E. Kaufmann's Swifter routine whm_kickvh_tp.f90 implicit none ! Arguments class ( whm_tp ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Logical flag indicating whether this is the beginning of the half step or not. ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) if ( tp % lfirst ) then where ( tp % lmask ( 1 : ntp )) tp % ah ( 1 , 1 : ntp ) = 0.0_DP tp % ah ( 2 , 1 : ntp ) = 0.0_DP tp % ah ( 3 , 1 : ntp ) = 0.0_DP end where call tp % accel ( system , param , t , lbeg = . true .) tp % lfirst = . false . end if if (. not . lbeg ) then where ( tp % lmask ( 1 : ntp )) tp % ah ( 1 , 1 : ntp ) = 0.0_DP tp % ah ( 2 , 1 : ntp ) = 0.0_DP tp % ah ( 3 , 1 : ntp ) = 0.0_DP end where call tp % accel ( system , param , t , lbeg ) end if do concurrent ( i = 1 : ntp , tp % lmask ( i )) tp % vh (:, i ) = tp % vh (:, i ) + tp % ah (:, i ) * dt end do end associate return end subroutine whm_kick_vh_tp end submodule s_whm_kick","tags":"","loc":"sourcefile/whm_kick.f90.html"},{"title":"whm_setup.f90 – swiftest","text":"This file depends on sourcefile~~whm_setup.f90~~EfferentGraph sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~whm_setup.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_whm_setup Source Code whm_setup.f90 Source Code submodule ( whm_classes ) s_whm_setup use swiftest contains module subroutine whm_setup_pl ( self , n , param ) !! author: David A. Minton !! !! Allocate WHM planet structure !! !! Equivalent in functionality to David E. Kaufmann's Swifter routine whm_setup.f90 implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! Swiftest test particle object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameter !> Call allocation method for parent class call setup_pl ( self , n , param ) if ( n <= 0 ) return if ( allocated ( self % eta )) deallocate ( self % eta ) if ( allocated ( self % muj )) deallocate ( self % muj ) if ( allocated ( self % xj )) deallocate ( self % xj ) if ( allocated ( self % vj )) deallocate ( self % vj ) if ( allocated ( self % ir3j )) deallocate ( self % ir3j ) allocate ( self % eta ( n )) allocate ( self % muj ( n )) allocate ( self % xj ( NDIM , n )) allocate ( self % vj ( NDIM , n )) allocate ( self % ir3j ( n )) self % eta (:) = 0.0_DP self % muj (:) = 0.0_DP self % xj (:,:) = 0.0_DP self % vj (:,:) = 0.0_DP self % ir3j (:) = 0.0_DP return end subroutine whm_setup_pl module subroutine whm_util_set_mu_eta_pl ( self , cb ) !! author: David A. Minton !! !! Sets the Jacobi mass value eta for all massive bodies implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM system object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object ! Internals integer ( I4B ) :: i associate ( pl => self , npl => self % nbody ) if ( npl == 0 ) return call util_set_mu_pl ( pl , cb ) pl % eta ( 1 ) = cb % Gmass + pl % Gmass ( 1 ) pl % muj ( 1 ) = pl % eta ( 1 ) do i = 2 , npl pl % eta ( i ) = pl % eta ( i - 1 ) + pl % Gmass ( i ) pl % muj ( i ) = cb % Gmass * pl % eta ( i ) / pl % eta ( i - 1 ) end do end associate return end subroutine whm_util_set_mu_eta_pl module subroutine whm_setup_initialize_system ( self , param ) !! author: David A. Minton !! !! Initialize a WHM nbody system from files !! implicit none ! Arguments class ( whm_nbody_system ), intent ( inout ) :: self !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters call setup_initialize_system ( self , param ) ! First we need to make sure that the massive bodies are sorted by heliocentric distance before computing jacobies call util_set_ir3h ( self % pl ) call self % pl % sort ( \"ir3h\" , ascending = . false .) ! Make sure that the discard list gets allocated initially call self % tp_discards % setup ( 0 , param ) call self % pl % set_mu ( self % cb ) call self % tp % set_mu ( self % cb ) if ( param % lgr ) then call self % pl % v2pv ( param ) call self % tp % v2pv ( param ) end if return end subroutine whm_setup_initialize_system end submodule s_whm_setup","tags":"","loc":"sourcefile/whm_setup.f90.html"},{"title":"whm_util.f90 – swiftest","text":"This file depends on sourcefile~~whm_util.f90~~EfferentGraph sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~whm_util.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_whm_util Source Code whm_util.f90 Source Code submodule ( whm_classes ) s_whm_util use swiftest contains module subroutine whm_util_append_pl ( self , source , lsource_mask ) !! author: David A. Minton !! !! Append components from one massive body object to another. !! This method will automatically resize the destination body if it is too small implicit none !! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to select type ( source ) class is ( whm_pl ) associate ( nold => self % nbody , nsrc => source % nbody ) call util_append ( self % eta , source % eta , nold , nsrc , lsource_mask ) call util_append ( self % muj , source % muj , nold , nsrc , lsource_mask ) call util_append ( self % ir3j , source % ir3j , nold , nsrc , lsource_mask ) call util_append ( self % xj , source % xj , nold , nsrc , lsource_mask ) call util_append ( self % vj , source % vj , nold , nsrc , lsource_mask ) call util_append_pl ( self , source , lsource_mask ) end associate class default write ( * , * ) \"Invalid object passed to the append method. Source must be of class whm_pl or its descendents\" call util_exit ( FAILURE ) end select return end subroutine whm_util_append_pl module subroutine whm_util_fill_pl ( self , inserts , lfill_list ) !! author: David A. Minton !! !! Insert new WHM test particle structure into an old one. !! This is the inverse of a fill operation. !! !! Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_body ), intent ( in ) :: inserts !! inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps ! Internals integer ( I4B ) :: i associate ( keeps => self ) select type ( inserts ) class is ( whm_pl ) call util_fill ( keeps % eta , inserts % eta , lfill_list ) call util_fill ( keeps % muj , inserts % muj , lfill_list ) call util_fill ( keeps % ir3j , inserts % ir3j , lfill_list ) call util_fill ( keeps % xj , inserts % xj , lfill_list ) call util_fill ( keeps % vj , inserts % vj , lfill_list ) call util_fill_pl ( keeps , inserts , lfill_list ) class default write ( * , * ) \"Invalid object passed to the fill method. Inserts must be of class whm_pl or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine whm_util_fill_pl module subroutine whm_util_resize_pl ( self , nnew ) !! author: David A. Minton !! !! Checks the current size of a massive body against the requested size and resizes it if it is too small. implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object integer ( I4B ), intent ( in ) :: nnew !! New size neded call util_resize ( self % eta , nnew ) call util_resize ( self % xj , nnew ) call util_resize ( self % vj , nnew ) call util_resize ( self % muj , nnew ) call util_resize ( self % ir3j , nnew ) call util_resize_pl ( self , nnew ) return end subroutine whm_util_resize_pl module subroutine whm_util_set_ir3j ( self ) !! author: David A. Minton !! !! Sets the inverse Jacobi and heliocentric radii cubed (1/rj**3 and 1/rh**3) implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object ! Internals integer ( I4B ) :: i real ( DP ) :: r2 , ir if ( self % nbody > 0 ) then do i = 1 , self % nbody r2 = dot_product ( self % xh (:, i ), self % xh (:, i )) ir = 1.0_DP / sqrt ( r2 ) self % ir3h ( i ) = ir / r2 r2 = dot_product ( self % xj (:, i ), self % xj (:, i )) ir = 1.0_DP / sqrt ( r2 ) self % ir3j ( i ) = ir / r2 end do end if return end subroutine whm_util_set_ir3j module subroutine whm_util_sort_pl ( self , sortby , ascending ) !! author: David A. Minton !! !! Sort a WHM massive body object in-place. !! sortby is a string indicating which array component to sort. implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order ! Internals integer ( I4B ), dimension ( self % nbody ) :: ind integer ( I4B ) :: direction if ( ascending ) then direction = 1 else direction = - 1 end if associate ( pl => self , npl => self % nbody ) select case ( sortby ) case ( \"eta\" ) call util_sort ( direction * pl % eta ( 1 : npl ), ind ( 1 : npl )) case ( \"muj\" ) call util_sort ( direction * pl % muj ( 1 : npl ), ind ( 1 : npl )) case ( \"ir3j\" ) call util_sort ( direction * pl % ir3j ( 1 : npl ), ind ( 1 : npl )) case ( \"xj\" , \"vj\" ) write ( * , * ) 'Cannot sort by ' // trim ( adjustl ( sortby )) // '. Component not sortable!' case default call util_sort_pl ( pl , sortby , ascending ) return end select call pl % rearrange ( ind ) end associate return end subroutine whm_util_sort_pl module subroutine whm_util_sort_rearrange_pl ( self , ind ) !! author: David A. Minton !! !! Rearrange WHM massive body structure in-place from an index list. !! This is a helper utility used to make polymorphic sorting work on Swiftest structures. implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) ! Internals class ( whm_pl ), allocatable :: pl_sorted !! Temporary holder for sorted body integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) call util_sort_rearrange_pl ( pl , ind ) allocate ( pl_sorted , source = self ) if ( allocated ( pl % eta )) pl % eta ( 1 : npl ) = pl_sorted % eta ( ind ( 1 : npl )) if ( allocated ( pl % xj )) pl % xj (:, 1 : npl ) = pl_sorted % xj (:, ind ( 1 : npl )) if ( allocated ( pl % vj )) pl % vj (:, 1 : npl ) = pl_sorted % vj (:, ind ( 1 : npl )) if ( allocated ( pl % muj )) pl % muj ( 1 : npl ) = pl_sorted % muj ( ind ( 1 : npl )) if ( allocated ( pl % ir3j )) pl % ir3j ( 1 : npl ) = pl_sorted % ir3j ( ind ( 1 : npl )) deallocate ( pl_sorted ) end associate return end subroutine whm_util_sort_rearrange_pl module subroutine whm_util_spill_pl ( self , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Move spilled (discarded) WHM test particle structure from active list to discard list !! !! Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not ! Internals integer ( I4B ) :: i associate ( keeps => self ) select type ( discards ) class is ( whm_pl ) call util_spill ( keeps % eta , discards % eta , lspill_list , ldestructive ) call util_spill ( keeps % muj , discards % muj , lspill_list , ldestructive ) call util_spill ( keeps % ir3j , discards % ir3j , lspill_list , ldestructive ) call util_spill ( keeps % xj , discards % xj , lspill_list , ldestructive ) call util_spill ( keeps % vj , discards % vj , lspill_list , ldestructive ) call util_spill_pl ( keeps , discards , lspill_list , ldestructive ) class default write ( * , * ) \"Invalid object passed to the spill method. Source must be of class whm_pl or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine whm_util_spill_pl end submodule s_whm_util","tags":"","loc":"sourcefile/whm_util.f90.html"},{"title":"operator_cross.f90 – swiftest","text":"This file depends on sourcefile~~operator_cross.f90~~EfferentGraph sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~operator_cross.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_operator_cross Source Code operator_cross.f90 Source Code submodule ( swiftest_operators ) s_operator_cross use swiftest !! author: David A. Minton !! !! Contains implementations for the .cross. operator for all defined integer and real types !! Single vector implementations: C(1:3)   = A(1:3)   .cross. B(1:3) !! Vector list implementations:   C(1:3, :) = A(1:3, :) .cross. B(1:3, :) contains module pure function operator_cross_sp ( A , B ) result ( C ) implicit none real ( SP ), dimension (:), intent ( in ) :: A , B real ( SP ), dimension ( 3 ) :: C C ( 1 ) = A ( 2 ) * B ( 3 ) - A ( 3 ) * B ( 2 ) C ( 2 ) = A ( 3 ) * B ( 1 ) - A ( 1 ) * B ( 3 ) C ( 3 ) = A ( 1 ) * B ( 2 ) - A ( 2 ) * B ( 1 ) return end function operator_cross_sp module pure function operator_cross_dp ( A , B ) result ( C ) implicit none real ( DP ), dimension (:), intent ( in ) :: A , B real ( DP ), dimension ( 3 ) :: C C ( 1 ) = A ( 2 ) * B ( 3 ) - A ( 3 ) * B ( 2 ) C ( 2 ) = A ( 3 ) * B ( 1 ) - A ( 1 ) * B ( 3 ) C ( 3 ) = A ( 1 ) * B ( 2 ) - A ( 2 ) * B ( 1 ) return end function operator_cross_dp module pure function operator_cross_qp ( A , B ) result ( C ) implicit none real ( QP ), dimension (:), intent ( in ) :: A , B real ( QP ), dimension ( 3 ) :: C C ( 1 ) = A ( 2 ) * B ( 3 ) - A ( 3 ) * B ( 2 ) C ( 2 ) = A ( 3 ) * B ( 1 ) - A ( 1 ) * B ( 3 ) C ( 3 ) = A ( 1 ) * B ( 2 ) - A ( 2 ) * B ( 1 ) return end function operator_cross_qp module pure function operator_cross_i1b ( A , B ) result ( C ) implicit none integer ( I1B ), dimension (:), intent ( in ) :: A , B integer ( I1B ), dimension ( 3 ) :: C C ( 1 ) = A ( 2 ) * B ( 3 ) - A ( 3 ) * B ( 2 ) C ( 2 ) = A ( 3 ) * B ( 1 ) - A ( 1 ) * B ( 3 ) C ( 3 ) = A ( 1 ) * B ( 2 ) - A ( 2 ) * B ( 1 ) return end function operator_cross_i1b module pure function operator_cross_i2b ( A , B ) result ( C ) implicit none integer ( I2B ), dimension (:), intent ( in ) :: A , B integer ( I2B ), dimension ( 3 ) :: C C ( 1 ) = A ( 2 ) * B ( 3 ) - A ( 3 ) * B ( 2 ) C ( 2 ) = A ( 3 ) * B ( 1 ) - A ( 1 ) * B ( 3 ) C ( 3 ) = A ( 1 ) * B ( 2 ) - A ( 2 ) * B ( 1 ) return end function operator_cross_i2b module pure function operator_cross_i4b ( A , B ) result ( C ) implicit none integer ( I4B ), dimension (:), intent ( in ) :: A , B integer ( I4B ), dimension ( 3 ) :: C C ( 1 ) = A ( 2 ) * B ( 3 ) - A ( 3 ) * B ( 2 ) C ( 2 ) = A ( 3 ) * B ( 1 ) - A ( 1 ) * B ( 3 ) C ( 3 ) = A ( 1 ) * B ( 2 ) - A ( 2 ) * B ( 1 ) return end function operator_cross_i4b module pure function operator_cross_i8b ( A , B ) result ( C ) implicit none integer ( I8B ), dimension (:), intent ( in ) :: A , B integer ( I8B ), dimension ( 3 ) :: C C ( 1 ) = A ( 2 ) * B ( 3 ) - A ( 3 ) * B ( 2 ) C ( 2 ) = A ( 3 ) * B ( 1 ) - A ( 1 ) * B ( 3 ) C ( 3 ) = A ( 1 ) * B ( 2 ) - A ( 2 ) * B ( 1 ) return end function operator_cross_i8b module pure function operator_cross_el_sp ( A , B ) result ( C ) implicit none real ( SP ), dimension (:,:), intent ( in ) :: A , B real ( SP ), dimension (:,:), allocatable :: C integer ( I4B ) :: i , n n = size ( A , 2 ) if ( allocated ( C )) deallocate ( C ) allocate ( C , mold = A ) do concurrent ( i = 1 : n ) C ( 1 , i ) = A ( 2 , i ) * B ( 3 , i ) - A ( 3 , i ) * B ( 2 , i ) C ( 2 , i ) = A ( 3 , i ) * B ( 1 , i ) - A ( 1 , i ) * B ( 3 , i ) C ( 3 , i ) = A ( 1 , i ) * B ( 2 , i ) - A ( 2 , i ) * B ( 1 , i ) end do return end function operator_cross_el_sp module pure function operator_cross_el_dp ( A , B ) result ( C ) implicit none real ( DP ), dimension (:,:), intent ( in ) :: A , B real ( DP ), dimension (:,:), allocatable :: C integer ( I4B ) :: i , n n = size ( A , 2 ) if ( allocated ( C )) deallocate ( C ) allocate ( C , mold = A ) do concurrent ( i = 1 : n ) C ( 1 , i ) = A ( 2 , i ) * B ( 3 , i ) - A ( 3 , i ) * B ( 2 , i ) C ( 2 , i ) = A ( 3 , i ) * B ( 1 , i ) - A ( 1 , i ) * B ( 3 , i ) C ( 3 , i ) = A ( 1 , i ) * B ( 2 , i ) - A ( 2 , i ) * B ( 1 , i ) end do return end function operator_cross_el_dp module pure function operator_cross_el_qp ( A , B ) result ( C ) implicit none real ( QP ), dimension (:,:), intent ( in ) :: A , B real ( QP ), dimension (:,:), allocatable :: C integer ( I4B ) :: i , n n = size ( A , 2 ) if ( allocated ( C )) deallocate ( C ) allocate ( C , mold = A ) do concurrent ( i = 1 : n ) C ( 1 , i ) = A ( 2 , i ) * B ( 3 , i ) - A ( 3 , i ) * B ( 2 , i ) C ( 2 , i ) = A ( 3 , i ) * B ( 1 , i ) - A ( 1 , i ) * B ( 3 , i ) C ( 3 , i ) = A ( 1 , i ) * B ( 2 , i ) - A ( 2 , i ) * B ( 1 , i ) end do return end function operator_cross_el_qp module pure function operator_cross_el_i1b ( A , B ) result ( C ) implicit none integer ( I1B ), dimension (:,:), intent ( in ) :: A , B integer ( I1B ), dimension (:,:), allocatable :: C integer ( I4B ) :: i , n n = size ( A , 2 ) if ( allocated ( C )) deallocate ( C ) allocate ( C , mold = A ) do concurrent ( i = 1 : n ) C ( 1 , i ) = A ( 2 , i ) * B ( 3 , i ) - A ( 3 , i ) * B ( 2 , i ) C ( 2 , i ) = A ( 3 , i ) * B ( 1 , i ) - A ( 1 , i ) * B ( 3 , i ) C ( 3 , i ) = A ( 1 , i ) * B ( 2 , i ) - A ( 2 , i ) * B ( 1 , i ) end do return end function operator_cross_el_i1b module pure function operator_cross_el_i2b ( A , B ) result ( C ) implicit none integer ( I2B ), dimension (:,:), intent ( in ) :: A , B integer ( I2B ), dimension (:,:), allocatable :: C integer ( I4B ) :: i , n n = size ( A , 2 ) if ( allocated ( C )) deallocate ( C ) allocate ( C , mold = A ) do concurrent ( i = 1 : n ) C ( 1 , i ) = A ( 2 , i ) * B ( 3 , i ) - A ( 3 , i ) * B ( 2 , i ) C ( 2 , i ) = A ( 3 , i ) * B ( 1 , i ) - A ( 1 , i ) * B ( 3 , i ) C ( 3 , i ) = A ( 1 , i ) * B ( 2 , i ) - A ( 2 , i ) * B ( 1 , i ) end do return end function operator_cross_el_i2b module pure function operator_cross_el_i4b ( A , B ) result ( C ) implicit none integer ( I4B ), dimension (:,:), intent ( in ) :: A , B integer ( I4B ), dimension (:,:), allocatable :: C integer ( I4B ) :: i , n n = size ( A , 2 ) if ( allocated ( C )) deallocate ( C ) allocate ( C , mold = A ) do concurrent ( i = 1 : n ) C ( 1 , i ) = A ( 2 , i ) * B ( 3 , i ) - A ( 3 , i ) * B ( 2 , i ) C ( 2 , i ) = A ( 3 , i ) * B ( 1 , i ) - A ( 1 , i ) * B ( 3 , i ) C ( 3 , i ) = A ( 1 , i ) * B ( 2 , i ) - A ( 2 , i ) * B ( 1 , i ) end do return end function operator_cross_el_i4b module pure function operator_cross_el_i8b ( A , B ) result ( C ) implicit none integer ( I8B ), dimension (:,:), intent ( in ) :: A , B integer ( I8B ), dimension (:,:), allocatable :: C integer ( I4B ) :: i , n n = size ( A , 2 ) if ( allocated ( C )) deallocate ( C ) allocate ( C , mold = A ) do concurrent ( i = 1 : n ) C ( 1 , i ) = A ( 2 , i ) * B ( 3 , i ) - A ( 3 , i ) * B ( 2 , i ) C ( 2 , i ) = A ( 3 , i ) * B ( 1 , i ) - A ( 1 , i ) * B ( 3 , i ) C ( 3 , i ) = A ( 1 , i ) * B ( 2 , i ) - A ( 2 , i ) * B ( 1 , i ) end do return end function operator_cross_el_i8b end submodule s_operator_cross","tags":"","loc":"sourcefile/operator_cross.f90.html"},{"title":"operator_mag.f90 – swiftest","text":"This file depends on sourcefile~~operator_mag.f90~~EfferentGraph sourcefile~operator_mag.f90 operator_mag.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~operator_mag.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_operator_mag Source Code operator_mag.f90 Source Code submodule ( swiftest_operators ) s_operator_mag !! author: David A. Minton !! !! Contains implementations for the .mag. operator for all defined real types !! Single vector implementations:  B   = .mag. A(1:3) !! Vector list implementations:   B(:) = .mag. A(1:3, :) contains module pure function operator_mag_sp ( A ) result ( B ) implicit none real ( SP ), dimension (:), intent ( in ) :: A real ( SP ) :: B B = norm2 ( A (:)) return end function operator_mag_sp module pure function operator_mag_dp ( A ) result ( B ) implicit none real ( DP ), dimension (:), intent ( in ) :: A real ( DP ) :: B B = norm2 ( A (:)) return end function operator_mag_dp module pure function operator_mag_el_sp ( A ) result ( B ) implicit none real ( SP ), dimension (:,:), intent ( in ) :: A real ( SP ), dimension (:), allocatable :: B integer ( I4B ) :: i , n n = size ( A , 2 ) if ( allocated ( B )) deallocate ( B ) allocate ( B ( n )) do concurrent ( i = 1 : n ) B ( i ) = norm2 ( A (:, i )) end do return end function operator_mag_el_sp module pure function operator_mag_el_dp ( A ) result ( B ) implicit none real ( DP ), dimension (:,:), intent ( in ) :: A real ( DP ), dimension (:), allocatable :: B integer ( I4B ) :: i , n n = size ( A , 2 ) if ( allocated ( B )) deallocate ( B ) allocate ( B ( n )) do concurrent ( i = 1 : n ) B ( i ) = norm2 ( A (:, i )) end do return end function operator_mag_el_dp module pure function operator_mag_el_qp ( A ) result ( B ) implicit none real ( QP ), dimension (:,:), intent ( in ) :: A real ( QP ), dimension (:), allocatable :: B integer ( I4B ) :: i , n n = size ( A , 2 ) if ( allocated ( B )) deallocate ( B ) allocate ( B ( n )) do concurrent ( i = 1 : n ) B ( i ) = norm2 ( A (:, i )) end do return end function operator_mag_el_qp end submodule s_operator_mag","tags":"","loc":"sourcefile/operator_mag.f90.html"},{"title":"util_solve.f90 – swiftest","text":"This file depends on sourcefile~~util_solve.f90~~EfferentGraph sourcefile~util_solve.f90 util_solve.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_solve.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_solve Source Code util_solve.f90 Source Code submodule ( swiftest_classes ) s_util_solve use swiftest contains module function util_solve_linear_system_d ( A , b , n , lerr ) result ( x ) !! Author: David A. Minton !! !! Solves the linear equation of the form A*x = b for x. !!   A is an (n,n) arrays !!   x and b are (n) arrays !! Uses Gaussian elimination, so will have issues if system is ill-conditioned. !! Uses quad precision intermidiate values, so works best on small arrays. use , intrinsic :: ieee_exceptions implicit none ! Arguments integer ( I4B ), intent ( in ) :: n real ( DP ), dimension (:,:), intent ( in ) :: A real ( DP ), dimension (:), intent ( in ) :: b logical , intent ( out ) :: lerr ! Result real ( DP ), dimension ( n ) :: x ! Internals real ( QP ), dimension (:), allocatable :: qx type ( ieee_status_type ) :: original_fpe_status logical , dimension (:), allocatable :: fpe_flag call ieee_get_status ( original_fpe_status ) ! Save the original floating point exception status call ieee_set_flag ( ieee_all , . false .) ! Set all flags to quiet allocate ( fpe_flag ( size ( ieee_usual ))) qx = solve_wbs ( ge_wpp ( real ( A , kind = QP ), real ( b , kind = QP ))) call ieee_get_flag ( ieee_usual , fpe_flag ) lerr = any ( fpe_flag ) if ( lerr . or . ( any ( abs ( qx ) > huge ( x ))) . or . ( any ( abs ( qx ) < tiny ( x )))) then x = 0.0_DP else x = real ( qx , kind = DP ) end if call ieee_set_status ( original_fpe_status ) return end function util_solve_linear_system_d module function util_solve_linear_system_q ( A , b , n , lerr ) result ( x ) !! Author: David A. Minton !! !! Solves the linear equation of the form A*x = b for x. !!   A is an (n,n) arrays !!   x and b are (n) arrays !! Uses Gaussian elimination, so will have issues if system is ill-conditioned. !! Uses quad precision intermidiate values, so works best on small arrays. use , intrinsic :: ieee_exceptions implicit none ! Arguments integer ( I4B ), intent ( in ) :: n real ( QP ), dimension (:,:), intent ( in ) :: A real ( QP ), dimension (:), intent ( in ) :: b logical , intent ( out ) :: lerr ! Result real ( QP ), dimension ( n ) :: x ! Internals type ( ieee_status_type ) :: original_fpe_status logical , dimension (:), allocatable :: fpe_flag call ieee_get_status ( original_fpe_status ) ! Save the original floating point exception status call ieee_set_flag ( ieee_all , . false .) ! Set all flags to quiet allocate ( fpe_flag ( size ( ieee_usual ))) x = solve_wbs ( ge_wpp ( A , b )) call ieee_get_flag ( ieee_usual , fpe_flag ) lerr = any ( fpe_flag ) if ( lerr ) x = 0.0_DP call ieee_set_status ( original_fpe_status ) return end function util_solve_linear_system_q function solve_wbs ( u ) result ( x ) ! solve with backward substitution !! Based on code available on Rosetta Code: https://rosettacode.org/wiki/Gaussian_elimination#Fortran use , intrinsic :: ieee_exceptions use swiftest implicit none ! Arguments real ( QP ), intent ( in ), dimension (:,:), allocatable :: u ! Result real ( QP ), dimension (:), allocatable :: x ! Internals integer ( I4B ) :: i , n n = size ( u , 1 ) if ( allocated ( x )) deallocate ( x ) if (. not . allocated ( x )) allocate ( x ( n )) if ( any ( abs ( u ) < tiny ( 1._DP )) . or . any ( abs ( u ) > huge ( 1._DP ))) then x (:) = 0._DP return end if call ieee_set_halting_mode ( ieee_divide_by_zero , . false .) do i = n , 1 , - 1 x ( i ) = ( u ( i , n + 1 ) - sum ( u ( i , i + 1 : n ) * x ( i + 1 : n ))) / u ( i , i ) end do return end function solve_wbs function ge_wpp ( A , b ) result ( u ) ! gaussian eliminate with partial pivoting !! Solve  Ax=b  using Gaussian elimination then backwards substitution. !!   A being an n by n matrix. !!   x and b are n by 1 vectors. !! Based on code available on Rosetta Code: https://rosettacode.org/wiki/Gaussian_elimination#Fortran use , intrinsic :: ieee_exceptions use swiftest implicit none ! Arguments real ( QP ), dimension (:,:), intent ( in ) :: A real ( QP ), dimension (:), intent ( in ) :: b ! Result real ( QP ), dimension (:,:), allocatable :: u ! Internals integer ( I4B ) :: i , j , n , p real ( QP ) :: upi n = size ( a , 1 ) allocate ( u ( n , ( n + 1 ))) u = reshape ([ A , b ], [ n , n + 1 ]) call ieee_set_halting_mode ( ieee_divide_by_zero , . false .) do j = 1 , n p = maxloc ( abs ( u ( j : n , j )), 1 ) + j - 1 ! maxloc returns indices between (1, n - j + 1) if ( p /= j ) u ([ p , j ], j ) = u ([ j , p ], j ) u ( j + 1 :, j ) = u ( j + 1 :, j ) / u ( j , j ) do i = j + 1 , n + 1 upi = u ( p , i ) if ( p /= j ) u ([ p , j ], i ) = u ([ j , p ], i ) u ( j + 1 : n , i ) = u ( j + 1 : n , i ) - upi * u ( j + 1 : n , j ) end do end do return end function ge_wpp module function util_solve_rkf45 ( f , y0in , t1 , dt0 , tol ) result ( y1 ) !! author: David A. Minton !! !! Implements the 4th order Runge-Kutta-Fehlberg ODE solver for initial value problems of the form f=dy/dt, y0 = y(t=0), solving for y1 = y(t=t1). Uses a 5th order adaptive step size control. !! Uses a lambda function object as defined in the lambda_function module implicit none ! Arguments class ( lambda_obj ), intent ( inout ) :: f !! lambda function object that has been initialized to be a function of derivatives. The object will return with components lastarg and lasteval set real ( DP ), dimension (:), intent ( in ) :: y0in !! Initial value at t=0 real ( DP ), intent ( in ) :: t1 !! Final time real ( DP ), intent ( in ) :: dt0 !! Initial step size guess real ( DP ), intent ( in ) :: tol !! Tolerance on solution ! Result real ( DP ), dimension (:), allocatable :: y1 !! Final result ! Internals integer ( I4B ), parameter :: MAXREDUX = 1000 !! Maximum number of times step size can be reduced real ( DP ), parameter :: DTFAC = 0.95_DP !! Step size reduction safety factor (Value just under 1.0 to prevent adaptive step size control from discarding steps too aggressively) integer ( I4B ), parameter :: RKS = 6 !! Number of RK stages real ( DP ), dimension ( RKS , RKS - 1 ), parameter :: rkf45_btab = reshape ( & !! Butcher tableau for Runge-Kutta-Fehlberg method ( / 1. / 4. , 1. / 4. , 0. , 0. , 0. , 0. ,& 3. / 8. , 3. / 3 2. , 9. / 3 2. , 0. , 0. , 0. ,& 1 2. / 1 3. , 193 2. / 219 7. , - 720 0. / 219 7. , 729 6. / 219 7. , 0. , 0. ,& 1. , 43 9. / 21 6. , - 8. , 368 0. / 51 3. , - 84 5. / 410 4. , 0. ,& 1. / 2. , - 8. / 2 7. , 2. , - 354 4. / 256 5. , 185 9. / 410 4. , - 1 1. / 4 0. / ), shape ( rkf45_btab )) real ( DP ), dimension ( RKS ), parameter :: rkf4_coeff = ( / 2 5. / 21 6. , 0. , 140 8. / 256 5. , 219 7. / 410 4. , - 1. / 5. , 0. / ) real ( DP ), dimension ( RKS ), parameter :: rkf5_coeff = ( / 1 6. / 13 5. , 0. , 665 6. / 1282 5. , 2856 1. / 5643 0. , - 9. / 5 0. , 2. / 5 5. / ) real ( DP ), dimension (:, :), allocatable :: k !! Runge-Kutta coefficient vector real ( DP ), dimension (:), allocatable :: ynorm !! Normalized y value used for adaptive step size control real ( DP ), dimension (:), allocatable :: y0 !! Value of y at the beginning of each substep integer ( I4B ) :: Nvar !! Number of variables in problem integer ( I4B ) :: rkn !! Runge-Kutta loop index real ( DP ) :: t , x1 , dt , trem !! Current time, step size and total time remaining real ( DP ) :: s , yerr , yscale !!  Step size reduction factor, error in dependent variable, and error scale factor integer ( I4B ) :: i , n allocate ( y0 , source = y0in ) allocate ( y1 , mold = y0 ) allocate ( ynorm , mold = y0 ) Nvar = size ( y0 ) allocate ( k ( Nvar , RKS )) dt = dt0 trem = t1 t = 0._DP do yscale = norm2 ( y0 (:)) do i = 1 , MAXREDUX select type ( f ) class is ( lambda_obj_tvar ) do rkn = 1 , RKS y1 (:) = y0 (:) + matmul ( k (:, 1 : rkn - 1 ), rkf45_btab ( 2 : rkn , rkn - 1 )) if ( rkn == 1 ) then x1 = t else x1 = t + rkf45_btab ( 1 , rkn - 1 ) end if k (:, rkn ) = dt * f % evalt ( y1 (:), t ) end do class is ( lambda_obj ) do rkn = 1 , RKS y1 (:) = y0 (:) + matmul ( k (:, 1 : rkn - 1 ), rkf45_btab ( 2 : rkn , rkn - 1 )) k (:, rkn ) = dt * f % eval ( y1 (:)) end do end select ! Now determine if the step size needs adjusting ynorm (:) = matmul ( k (:,:), ( rkf5_coeff (:) - rkf4_coeff (:))) / yscale yerr = norm2 ( ynorm (:)) s = ( tol / ( 2 * yerr )) ** ( 0.25_DP ) dt = min ( s * DTFAC * dt , trem ) ! Alter step size either up or down, but never bigger than the remaining time if ( s >= 1.0_DP ) exit ! Good step! if ( i == MAXREDUX ) then write ( * , * ) \"Something has gone wrong in util_solve_rkf45!! Step size reduction has gone too far this time!\" call util_exit ( FAILURE ) end if end do ! Compute new value then step ahead in time y1 (:) = y0 (:) + matmul ( k (:, :), rkf4_coeff (:)) trem = trem - dt t = t + dt if ( trem <= 0._DP ) exit y0 (:) = y1 (:) end do return end function util_solve_rkf45 end submodule s_util_solve","tags":"","loc":"sourcefile/util_solve.f90.html"},{"title":"util_set.f90 – swiftest","text":"This file depends on sourcefile~~util_set.f90~~EfferentGraph sourcefile~util_set.f90 util_set.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_set.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_set Source Code util_set.f90 Source Code submodule ( swiftest_classes ) s_util_set !! author: David A. Minton !! This submodule contains a collection of setter method implementations use swiftest contains module subroutine util_set_beg_end_pl ( self , xbeg , xend , vbeg ) !! author: David A. Minton !! !! Sets one or more of the values of xbeg, xend, and vbeg implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object real ( DP ), dimension (:,:), intent ( in ), optional :: xbeg , xend , vbeg if ( present ( xbeg )) then if ( allocated ( self % xbeg )) deallocate ( self % xbeg ) allocate ( self % xbeg , source = xbeg ) end if if ( present ( xend )) then if ( allocated ( self % xend )) deallocate ( self % xend ) allocate ( self % xend , source = xend ) end if if ( present ( vbeg )) then if ( allocated ( self % vbeg )) deallocate ( self % vbeg ) allocate ( self % vbeg , source = vbeg ) end if return end subroutine util_set_beg_end_pl module subroutine util_set_ir3h ( self ) !! author: David A. Minton !! !! Sets the inverse heliocentric radius term (1/rh**3) for all bodies in a structure implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest generic body object ! Internals integer ( I4B ) :: i real ( DP ) :: r2 , irh if ( self % nbody > 0 ) then do i = 1 , self % nbody r2 = dot_product ( self % xh (:, i ), self % xh (:, i )) irh = 1.0_DP / sqrt ( r2 ) self % ir3h ( i ) = irh / r2 end do end if return end subroutine util_set_ir3h module subroutine util_set_msys ( self ) !! author: David A. Minton !! !! Sets the value of msys and the vector mass quantities based on the total mass of the system implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nobdy system object self % Gmtot = self % cb % Gmass + sum ( self % pl % Gmass ( 1 : self % pl % nbody ), self % pl % status ( 1 : self % pl % nbody ) /= INACTIVE ) return end subroutine util_set_msys module subroutine util_set_mu_pl ( self , cb ) !! author: David A. Minton !! !! Computes G * (M + m) for each massive body implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object if ( self % nbody > 0 ) self % mu (:) = cb % Gmass + self % Gmass (:) return end subroutine util_set_mu_pl module subroutine util_set_mu_tp ( self , cb ) !! author: David A. Minton !! !! Converts certain scalar values to arrays so that they can be used in elemental functions implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object if ( self % nbody > 0 ) self % mu (:) = cb % Gmass return end subroutine util_set_mu_tp module subroutine util_set_rhill ( self , cb ) !! author: David A. Minton !! !! Sets the value of the Hill's radius implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object if ( self % nbody > 0 ) then call self % xv2el ( cb ) self % rhill (:) = self % a (:) * ( self % Gmass (:) / cb % Gmass / 3 ) ** THIRD end if return end subroutine util_set_rhill module subroutine util_set_rhill_approximate ( self , cb ) !! author: David A. Minton !! !! Sets the approximate value of the Hill's radius using the heliocentric radius instead of computing the semimajor axis implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object ! Internals real ( DP ), dimension (:), allocatable :: rh if ( self % nbody > 0 ) then rh (:) = . mag . self % xh (:,:) self % rhill (:) = rh (:) * ( self % Gmass (:) / cb % Gmass / 3 ) ** THIRD end if return end subroutine util_set_rhill_approximate end submodule s_util_set","tags":"","loc":"sourcefile/util_set.f90.html"},{"title":"util_peri.f90 – swiftest","text":"This file depends on sourcefile~~util_peri.f90~~EfferentGraph sourcefile~util_peri.f90 util_peri.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_peri.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_peri Source Code util_peri.f90 Source Code submodule ( swiftest_classes ) s_util_peri use swiftest contains module subroutine util_peri_tp ( self , system , param ) !! author: David A. Minton !! !! Determine system pericenter passages for test particles !! Note:  If the coordinate system used is barycentric, then this routine assumes that the barycentric coordinates in the !!        test particle structures are up-to-date and are not recomputed !! !! Adapted from David E. Kaufmann's Swifter routine: util_peri.f90 !! Adapted from Hal Levison's Swift routine util_peri.f implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i real ( DP ) :: e real ( DP ), dimension (:), allocatable :: vdotr associate ( tp => self , ntp => self % nbody ) allocate ( vdotr ( ntp )) if ( param % qmin_coord == \"HELIO\" ) then do i = 1 , ntp vdotr ( i ) = dot_product ( tp % xh (:, i ), tp % vh (:, i )) if ( tp % isperi ( i ) == - 1 ) then if ( vdotr ( i ) >= 0.0_DP ) then tp % isperi ( i ) = 0 call orbel_xv2aeq ( tp % mu ( i ), tp % xh (:, i ), tp % vh (:, i ), tp % atp ( i ), e , tp % peri ( i )) end if else if ( vdotr ( i ) > 0.0_DP ) then tp % isperi ( i ) = 1 else tp % isperi ( i ) = - 1 end if end if end do else do i = 1 , ntp vdotr ( i ) = dot_product ( tp % xb (:, i ), tp % vb (:, i )) if ( tp % isperi ( i ) == - 1 ) then if ( vdotr ( i ) >= 0.0_DP ) then tp % isperi ( i ) = 0 call orbel_xv2aeq ( system % Gmtot , tp % xb (:, i ), tp % vb (:, i ), tp % atp ( i ), e , tp % peri ( i )) end if else if ( vdotr ( i ) > 0.0_DP ) then tp % isperi ( i ) = 1 else tp % isperi ( i ) = - 1 end if end if end do end if end associate return end subroutine util_peri_tp end submodule s_util_peri","tags":"","loc":"sourcefile/util_peri.f90.html"},{"title":"util_coord.f90 – swiftest","text":"This file depends on sourcefile~~util_coord.f90~~EfferentGraph sourcefile~util_coord.f90 util_coord.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_coord.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_coord Source Code util_coord.f90 Source Code submodule ( swiftest_classes ) s_util_coord use swiftest contains module subroutine util_coord_h2b_pl ( self , cb ) !! author: David A. Minton !! !! Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) !! !! Adapted from David E. Kaufmann's Swifter routine coord_h2b.f90 !! Adapted from Hal Levison's Swift routine coord_h2b.f implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object ! Internals integer ( I4B ) :: i real ( DP ) :: Gmtot real ( DP ), dimension ( NDIM ) :: xtmp , vtmp if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) Gmtot = cb % Gmass xtmp (:) = 0.0_DP vtmp (:) = 0.0_DP do i = 1 , npl if ( pl % status ( i ) == INACTIVE ) cycle Gmtot = Gmtot + pl % Gmass ( i ) xtmp (:) = xtmp (:) + pl % Gmass ( i ) * pl % xh (:, i ) vtmp (:) = vtmp (:) + pl % Gmass ( i ) * pl % vh (:, i ) end do cb % xb (:) = - xtmp (:) / Gmtot cb % vb (:) = - vtmp (:) / Gmtot do i = 1 , npl if ( pl % status ( i ) == INACTIVE ) cycle pl % xb (:, i ) = pl % xh (:, i ) + cb % xb (:) pl % vb (:, i ) = pl % vh (:, i ) + cb % vb (:) end do end associate return end subroutine util_coord_h2b_pl module subroutine util_coord_h2b_tp ( self , cb ) !! author: David A. Minton !! !! Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) !! !! Adapted from David E. Kaufmann's Swifter routine coord_h2b_tp.f90 !! Adapted from Hal Levison's Swift routine coord_h2b_tp.f implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_cb ), intent ( in ) :: cb !! Swiftest central body object ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) do concurrent ( i = 1 : ntp , tp % status ( i ) /= INACTIVE ) tp % xb (:, i ) = tp % xh (:, i ) + cb % xb (:) tp % vb (:, i ) = tp % vh (:, i ) + cb % vb (:) end do end associate return end subroutine util_coord_h2b_tp module subroutine util_coord_b2h_pl ( self , cb ) !! author: David A. Minton !! !! Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) !! !! Adapted from David E. Kaufmann's Swifter routine coord_b2h.f90 !! Adapted from Hal Levison's Swift routine coord_b2h.f implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) do concurrent ( i = 1 : npl , pl % status ( i ) /= INACTIVE ) pl % xh (:, i ) = pl % xb (:, i ) - cb % xb (:) pl % vh (:, i ) = pl % vb (:, i ) - cb % vb (:) end do end associate return end subroutine util_coord_b2h_pl module subroutine util_coord_b2h_tp ( self , cb ) !! author: David A. Minton !! !! Convert test particles from barycentric to heliocentric coordinates (position and velocity) !! !! Adapted from David E. Kaufmann's Swifter routine coord_b2h_tp.f90 !! Adapted from Hal Levison's Swift routine coord_b2h_tp.f implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( in ) :: cb !! Swiftest central body object ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) do concurrent ( i = 1 : ntp , tp % status ( i ) /= INACTIVE ) tp % xh (:, i ) = tp % xb (:, i ) - cb % xb (:) tp % vh (:, i ) = tp % vb (:, i ) - cb % vb (:) end do end associate return end subroutine util_coord_b2h_tp end submodule s_util_coord","tags":"","loc":"sourcefile/util_coord.f90.html"},{"title":"util_rescale.f90 – swiftest","text":"This file depends on sourcefile~~util_rescale.f90~~EfferentGraph sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_rescale.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_rescale Source Code util_rescale.f90 Source Code submodule ( swiftest_classes ) s_util_rescale use swiftest contains module subroutine util_rescale_system ( self , param , mscale , dscale , tscale ) !! author: David A. Minton !! !! Rescales an nbody system to a new set of units. Inputs are the multipliers on the mass (mscale), distance (dscale), and time units (tscale). !! Rescales all united quantities in the system, as well as the mass conversion factors, gravitational constant, and Einstein's constant in the parameter object. implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters. Returns with new values of the scale vactors and GU real ( DP ), intent ( in ) :: mscale , dscale , tscale !! Scale factors for mass, distance, and time units, respectively. ! Internals real ( DP ) :: vscale param % MU2KG = param % MU2KG * mscale param % DU2M = param % DU2M * dscale param % TU2S = param % TU2S * tscale ! Calculate the G for the system units param % GU = GC / ( param % DU2M ** 3 / ( param % MU2KG * param % TU2S ** 2 )) ! Calculate the inverse speed of light in the system units param % inv_c2 = einsteinC * param % TU2S / param % DU2M param % inv_c2 = ( param % inv_c2 ) ** ( - 2 ) vscale = dscale / tscale associate ( cb => self % cb , pl => self % pl , npl => self % pl % nbody , tp => self % tp , ntp => self % tp % nbody ) cb % mass = cb % mass / mscale cb % Gmass = param % GU * cb % mass cb % radius = cb % radius / dscale cb % xb (:) = cb % xb (:) / dscale cb % vb (:) = cb % vb (:) / vscale cb % rot (:) = cb % rot (:) * tscale pl % mass ( 1 : npl ) = pl % mass ( 1 : npl ) / mscale pl % Gmass ( 1 : npl ) = param % GU * pl % mass ( 1 : npl ) pl % radius ( 1 : npl ) = pl % radius ( 1 : npl ) / dscale pl % xh (:, 1 : npl ) = pl % xh (:, 1 : npl ) / dscale pl % vh (:, 1 : npl ) = pl % vh (:, 1 : npl ) / vscale pl % xb (:, 1 : npl ) = pl % xb (:, 1 : npl ) / dscale pl % vb (:, 1 : npl ) = pl % vb (:, 1 : npl ) / vscale pl % rot (:, 1 : npl ) = pl % rot (:, 1 : npl ) * tscale end associate return end subroutine util_rescale_system end submodule s_util_rescale","tags":"","loc":"sourcefile/util_rescale.f90.html"},{"title":"util_version.f90 – swiftest","text":"This file depends on sourcefile~~util_version.f90~~EfferentGraph sourcefile~util_version.f90 util_version.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_version.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_version Source Code util_version.f90 Source Code submodule ( swiftest_classes ) s_util_version use swiftest contains module subroutine util_version () !! author: David A. Minton !! !! Print program version information to terminale !! !! Adapted from David E. Kaufmann's Swifter routine: util_version.f90 implicit none write ( * , 200 ) VERSION_NUMBER 200 format ( / , \"************* Swiftest: Version \" , f3 . 1 , \" *************\" , // , & \"Based off of Swifter:\" , // , & \"Authors:\" , // , & \"    The Purdue University Swiftest Development team \" , / , & \"    Lead by David A. Minton \" , / , & \"    Single loop blocking by Jacob R. Elliott\" , / , & \"    Fragmentation by Carlisle A. Wishard and\" , // , & \"    Jennifer L. L. Poutplin                 \" , // , & \"Please address comments and questions to:\" , // , & \"    David A. Minton\" , / , & \"    Department Earth, Atmospheric, & Planetary Sciences \" , / , & \"    Purdue University\" , / , & \"    550 Stadium Mall Drive\" , / , & \"    West Lafayette, Indiana 47907\" , / , & \"    765-250-8034 \" , / , & \"    daminton@purdue.edu\" , / , & \"Special thanks to Hal Levison and Martin Duncan for the original\" , / ,& \"SWIFTER and SWIFT codes that made this possible.\" , // , & \"************************************************\" , / ) 100 FORMAT ( / , \"************* SWIFTER: Version \" , F3 . 1 , \" *************\" , // , & \"Authors:\" , // , & \"    Martin Duncan: Queen's University\" , / , & \"    Hal Levison  : Southwest Research Institute\" , // , & \"Please address comments and questions to:\" , // , & \"    Hal Levison or David Kaufmann\" , / , & \"    Department of Space Studies\" , / , & \"    Southwest Research Institute\" , / , & \"    1050 Walnut Street, Suite 400\" , / , & \"    Boulder, Colorado  80302\" , / , & \"    303-546-0290 (HFL), 720-240-0119 (DEK)\" , / , & \"    303-546-9687 (fax)\" , / , & \"    hal@gort.boulder.swri.edu (HFL)\" , / , & \"    kaufmann@boulder.swri.edu (DEK)\" , // , & \"************************************************\" , / ) return end subroutine util_version end submodule s_util_version","tags":"","loc":"sourcefile/util_version.f90.html"},{"title":"util_sort.f90 – swiftest","text":"This file depends on sourcefile~~util_sort.f90~~EfferentGraph sourcefile~util_sort.f90 util_sort.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_sort.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_sort Source Code util_sort.f90 Source Code submodule ( swiftest_classes ) s_util_sort use swiftest contains module subroutine util_sort_body ( self , sortby , ascending ) !! author: David A. Minton !! !! Sort a Swiftest body structure in-place. !! sortby is a string indicating which array component to sort. implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order ! Internals integer ( I4B ), dimension ( self % nbody ) :: ind integer ( I4B ) :: direction if ( ascending ) then direction = 1 else direction = - 1 end if associate ( body => self , n => self % nbody ) select case ( sortby ) case ( \"id\" ) call util_sort ( direction * body % id ( 1 : n ), ind ( 1 : n )) case ( \"status\" ) call util_sort ( direction * body % status ( 1 : n ), ind ( 1 : n )) case ( \"ir3h\" ) call util_sort ( direction * body % ir3h ( 1 : n ), ind ( 1 : n )) case ( \"a\" ) call util_sort ( direction * body % a ( 1 : n ), ind ( 1 : n )) case ( \"e\" ) call util_sort ( direction * body % e ( 1 : n ), ind ( 1 : n )) case ( \"inc\" ) call util_sort ( direction * body % inc ( 1 : n ), ind ( 1 : n )) case ( \"capom\" ) call util_sort ( direction * body % capom ( 1 : n ), ind ( 1 : n )) case ( \"mu\" ) call util_sort ( direction * body % mu ( 1 : n ), ind ( 1 : n )) case ( \"lfirst\" , \"nbody\" , \"ldiscard\" , \"xh\" , \"vh\" , \"xb\" , \"vb\" , \"ah\" , \"aobl\" , \"atide\" , \"agr\" ) write ( * , * ) 'Cannot sort by ' // trim ( adjustl ( sortby )) // '. Component not sortable!' case default write ( * , * ) 'Cannot sort by ' // trim ( adjustl ( sortby )) // '. Component not found!' return end select call body % rearrange ( ind ) end associate return end subroutine util_sort_body module subroutine util_sort_pl ( self , sortby , ascending ) !! author: David A. Minton !! !! Sort a Swiftest massive body object in-place. !! sortby is a string indicating which array component to sort. implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order ! Internals integer ( I4B ), dimension ( self % nbody ) :: ind integer ( I4B ) :: direction if ( ascending ) then direction = 1 else direction = - 1 end if associate ( pl => self , npl => self % nbody ) select case ( sortby ) case ( \"Gmass\" , \"mass\" ) call util_sort ( direction * pl % Gmass ( 1 : npl ), ind ( 1 : npl )) case ( \"rhill\" ) call util_sort ( direction * pl % rhill ( 1 : npl ), ind ( 1 : npl )) case ( \"radius\" ) call util_sort ( direction * pl % radius ( 1 : npl ), ind ( 1 : npl )) case ( \"density\" ) call util_sort ( direction * pl % density ( 1 : npl ), ind ( 1 : npl )) case ( \"k2\" ) call util_sort ( direction * pl % k2 ( 1 : npl ), ind ( 1 : npl )) case ( \"Q\" ) call util_sort ( direction * pl % Q ( 1 : npl ), ind ( 1 : npl )) case ( \"tlag\" ) call util_sort ( direction * pl % tlag ( 1 : npl ), ind ( 1 : npl )) case ( \"xbeg\" , \"xend\" , \"vbeg\" , \"Ip\" , \"rot\" , \"k_plpl\" , \"nplpl\" ) write ( * , * ) 'Cannot sort by ' // trim ( adjustl ( sortby )) // '. Component not sortable!' case default ! Look for components in the parent class call util_sort_body ( pl , sortby , ascending ) return end select call pl % rearrange ( ind ) end associate return end subroutine util_sort_pl module subroutine util_sort_tp ( self , sortby , ascending ) !! author: David A. Minton !! !! Sort a Swiftest test particle object  in-place. !! sortby is a string indicating which array component to sort. implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order ! Internals integer ( I4B ), dimension ( self % nbody ) :: ind integer ( I4B ) :: direction if ( ascending ) then direction = 1 else direction = - 1 end if associate ( tp => self , ntp => self % nbody ) select case ( sortby ) case ( \"peri\" ) call util_sort ( direction * tp % peri ( 1 : ntp ), ind ( 1 : ntp )) case ( \"atp\" ) call util_sort ( direction * tp % atp ( 1 : ntp ), ind ( 1 : ntp )) case ( \"isperi\" ) write ( * , * ) 'Cannot sort by ' // trim ( adjustl ( sortby )) // '. Component not sortable!' case default ! Look for components in the parent class call util_sort_body ( tp , sortby , ascending ) return end select call tp % rearrange ( ind ) end associate return end subroutine util_sort_tp module subroutine util_sort_rearrange_body ( self , ind ) !! author: David A. Minton !! !! Rearrange Swiftest body structure in-place from an index list. !! This is a helper utility used to make polymorphic sorting work on Swiftest structures. implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) ! Internals class ( swiftest_body ), allocatable :: body_sorted !! Temporary holder for sorted body associate ( n => self % nbody ) allocate ( body_sorted , source = self ) if ( allocated ( self % id )) self % id ( 1 : n ) = body_sorted % id ( ind ( 1 : n )) if ( allocated ( self % name )) self % name ( 1 : n ) = body_sorted % name ( ind ( 1 : n )) if ( allocated ( self % status )) self % status ( 1 : n ) = body_sorted % status ( ind ( 1 : n )) if ( allocated ( self % ldiscard )) self % ldiscard ( 1 : n ) = body_sorted % ldiscard ( ind ( 1 : n )) if ( allocated ( self % xh )) self % xh (:, 1 : n ) = body_sorted % xh (:, ind ( 1 : n )) if ( allocated ( self % vh )) self % vh (:, 1 : n ) = body_sorted % vh (:, ind ( 1 : n )) if ( allocated ( self % xb )) self % xb (:, 1 : n ) = body_sorted % xb (:, ind ( 1 : n )) if ( allocated ( self % vb )) self % vb (:, 1 : n ) = body_sorted % vb (:, ind ( 1 : n )) if ( allocated ( self % ah )) self % ah (:, 1 : n ) = body_sorted % ah (:, ind ( 1 : n )) if ( allocated ( self % ir3h )) self % ir3h ( 1 : n ) = body_sorted % ir3h ( ind ( 1 : n )) if ( allocated ( self % mu )) self % mu ( 1 : n ) = body_sorted % mu ( ind ( 1 : n )) if ( allocated ( self % lmask )) self % lmask ( 1 : n ) = body_sorted % lmask ( ind ( 1 : n )) if ( allocated ( self % a )) self % a ( 1 : n ) = body_sorted % a ( ind ( 1 : n )) if ( allocated ( self % e )) self % e ( 1 : n ) = body_sorted % e ( ind ( 1 : n )) if ( allocated ( self % inc )) self % inc ( 1 : n ) = body_sorted % inc ( ind ( 1 : n )) if ( allocated ( self % capom )) self % capom ( 1 : n ) = body_sorted % capom ( ind ( 1 : n )) if ( allocated ( self % omega )) self % omega ( 1 : n ) = body_sorted % omega ( ind ( 1 : n )) if ( allocated ( self % capm )) self % capm ( 1 : n ) = body_sorted % capm ( ind ( 1 : n )) if ( allocated ( self % aobl )) self % aobl (:, 1 : n ) = body_sorted % aobl (:, ind ( 1 : n )) if ( allocated ( self % atide )) self % atide (:, 1 : n ) = body_sorted % atide (:, ind ( 1 : n )) if ( allocated ( self % agr )) self % agr (:, 1 : n ) = body_sorted % agr (:, ind ( 1 : n )) deallocate ( body_sorted ) end associate return end subroutine util_sort_rearrange_body module subroutine util_sort_rearrange_pl ( self , ind ) !! author: David A. Minton !! !! Rearrange Swiftest massive body structure in-place from an index list. !! This is a helper utility used to make polymorphic sorting work on Swiftest structures. implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) ! Internals class ( swiftest_pl ), allocatable :: pl_sorted !! Temporary holder for sorted body associate ( pl => self , npl => self % nbody ) call util_sort_rearrange_body ( pl , ind ) allocate ( pl_sorted , source = self ) if ( allocated ( pl % mass )) pl % mass ( 1 : npl ) = pl_sorted % mass ( ind ( 1 : npl )) if ( allocated ( pl % Gmass )) pl % Gmass ( 1 : npl ) = pl_sorted % Gmass ( ind ( 1 : npl )) if ( allocated ( pl % rhill )) pl % rhill ( 1 : npl ) = pl_sorted % rhill ( ind ( 1 : npl )) if ( allocated ( pl % xbeg )) pl % xbeg (:, 1 : npl ) = pl_sorted % xbeg (:, ind ( 1 : npl )) if ( allocated ( pl % xend )) pl % xend (:, 1 : npl ) = pl_sorted % xend (:, ind ( 1 : npl )) if ( allocated ( pl % vbeg )) pl % vbeg (:, 1 : npl ) = pl_sorted % vbeg (:, ind ( 1 : npl )) if ( allocated ( pl % radius )) pl % radius ( 1 : npl ) = pl_sorted % radius ( ind ( 1 : npl )) if ( allocated ( pl % density )) pl % density ( 1 : npl ) = pl_sorted % density ( ind ( 1 : npl )) if ( allocated ( pl % Ip )) pl % Ip (:, 1 : npl ) = pl_sorted % Ip (:, ind ( 1 : npl )) if ( allocated ( pl % rot )) pl % rot (:, 1 : npl ) = pl_sorted % rot (:, ind ( 1 : npl )) if ( allocated ( pl % k2 )) pl % k2 ( 1 : npl ) = pl_sorted % k2 ( ind ( 1 : npl )) if ( allocated ( pl % Q )) pl % Q ( 1 : npl ) = pl_sorted % Q ( ind ( 1 : npl )) if ( allocated ( pl % tlag )) pl % tlag ( 1 : npl ) = pl_sorted % tlag ( ind ( 1 : npl )) deallocate ( pl_sorted ) end associate return end subroutine util_sort_rearrange_pl module subroutine util_sort_rearrange_tp ( self , ind ) !! author: David A. Minton !! !! Rearrange Swiftest massive body structure in-place from an index list. !! This is a helper utility used to make polymorphic sorting work on Swiftest structures. implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) ! Internals class ( swiftest_tp ), allocatable :: tp_sorted !! Temporary holder for sorted body associate ( tp => self , ntp => self % nbody ) call util_sort_rearrange_body ( tp , ind ) allocate ( tp_sorted , source = self ) if ( allocated ( tp % isperi )) tp % isperi ( 1 : ntp ) = tp_sorted % isperi ( ind ( 1 : ntp )) if ( allocated ( tp % peri )) tp % peri ( 1 : ntp ) = tp_sorted % peri ( ind ( 1 : ntp )) if ( allocated ( tp % atp )) tp % atp ( 1 : ntp ) = tp_sorted % atp ( ind ( 1 : ntp )) deallocate ( tp_sorted ) end associate return end subroutine util_sort_rearrange_tp module subroutine util_sort_dp ( arr ) !! author: David A. Minton !! !! Sort input double precision array in place into ascending numerical order using insertion sort. !! This algorithm works well for partially sorted arrays (which is usually the case here) !! implicit none ! Arguments real ( DP ), dimension (:), intent ( inout ) :: arr ! Internals real ( DP ) :: tmp integer ( I4B ) :: n , i , j n = size ( arr ) do i = 2 , n tmp = arr ( i ) do j = i - 1 , 1 , - 1 if ( arr ( j ) <= tmp ) exit arr ( j + 1 ) = arr ( j ) end do arr ( j + 1 ) = tmp end do return end subroutine util_sort_dp module subroutine util_sort_index_dp ( arr , ind ) !! author: David A. Minton !! !! Sort input double precision array by index in ascending numerical order using insertion sort. !! This algorithm works well for partially sorted arrays (which is usually the case here) !! implicit none ! Arguments real ( DP ), dimension (:), intent ( in ) :: arr integer ( I4B ), dimension (:), intent ( out ) :: ind ! Internals real ( DP ) :: tmp integer ( I4B ) :: n , i , j n = size ( arr ) ind = [( i , i = 1 , n )] do i = 2 , n tmp = arr ( ind ( i )) do j = i - 1 , 1 , - 1 if ( arr ( ind ( j )) <= tmp ) exit ind ( j + 1 ) = ind ( j ) end do ind ( j + 1 ) = i end do return end subroutine util_sort_index_dp module subroutine util_sort_i4b ( arr ) !! author: David A. Minton !! !! Sort input integer array in place into ascending numerical order using insertion sort. !! This algorithm works well for partially sorted arrays (which is usually the case here) !! implicit none ! Arguments integer ( I4B ), dimension (:), intent ( inout ) :: arr ! Internals integer ( I4B ) :: tmp integer ( I4B ) :: n , i , j n = size ( arr ) do i = 2 , n tmp = arr ( i ) do j = i - 1 , 1 , - 1 if ( arr ( j ) <= tmp ) exit arr ( j + 1 ) = arr ( j ) end do arr ( j + 1 ) = tmp end do return end subroutine util_sort_i4b module subroutine util_sort_index_i4b ( arr , ind ) !! author: David A. Minton !! !! Sort input integer array by index in ascending numerical order using insertion sort. !! This algorithm works well for partially sorted arrays (which is usually the case here) !! implicit none ! Arguments integer ( I4B ), dimension (:), intent ( in ) :: arr integer ( I4B ), dimension (:), intent ( out ) :: ind ! Internals integer ( I4B ) :: tmp integer ( I4B ) :: n , i , j n = size ( arr ) ind = [( i , i = 1 , n )] do i = 2 , n tmp = arr ( ind ( i )) do j = i - 1 , 1 , - 1 if ( arr ( ind ( j )) <= tmp ) exit ind ( j + 1 ) = ind ( j ) end do ind ( j + 1 ) = i end do return end subroutine util_sort_index_i4b module subroutine util_sort_sp ( arr ) !! author: David A. Minton !! !! Sort input single precision array in place into ascending numerical order using insertion sort. !! This algorithm works well for partially sorted arrays (which is usually the case here) ! implicit none ! Arguments real ( SP ), dimension (:), intent ( inout ) :: arr ! Internals real ( SP ) :: tmp integer ( I4B ) :: n , i , j n = size ( arr ) do i = 2 , n tmp = arr ( i ) do j = i - 1 , 1 , - 1 if ( arr ( j ) <= tmp ) exit arr ( j + 1 ) = arr ( j ) end do arr ( j + 1 ) = tmp end do return end subroutine util_sort_sp module subroutine util_sort_index_sp ( arr , ind ) !! author: David A. Minton !! !! Sort input single precision array by index in ascending numerical order using insertion sort. !! This algorithm works well for partially sorted arrays (which is usually the case here) !! implicit none ! Arguments real ( SP ), dimension (:), intent ( in ) :: arr integer ( I4B ), dimension (:), intent ( out ) :: ind ! Internals real ( SP ) :: tmp integer ( I4B ) :: n , i , j n = size ( arr ) ind = [( i , i = 1 , n )] do i = 2 , n tmp = arr ( ind ( i )) do j = i - 1 , 1 , - 1 if ( arr ( ind ( j )) <= tmp ) exit ind ( j + 1 ) = ind ( j ) end do ind ( j + 1 ) = i end do return end subroutine util_sort_index_sp end submodule s_util_sort","tags":"","loc":"sourcefile/util_sort.f90.html"},{"title":"util_spill.f90 – swiftest","text":"This file depends on sourcefile~~util_spill.f90~~EfferentGraph sourcefile~util_spill.f90 util_spill.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_spill.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_spill Source Code util_spill.f90 Source Code submodule ( swiftest_classes ) s_util_spill use swiftest contains module subroutine util_spill_arr_char_string ( keeps , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Performs a spill operation on a single array of type character strings !! This is the inverse of a spill operation implicit none ! Arguments character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not if (. not . allocated ( keeps ) . or . count ( lspill_list (:)) == 0 ) return if (. not . allocated ( discards )) allocate ( discards ( count ( lspill_list (:)))) discards (:) = pack ( keeps (:), lspill_list (:)) if ( ldestructive ) then if ( count (. not . lspill_list (:)) > 0 ) then keeps (:) = pack ( keeps (:), . not . lspill_list (:)) else deallocate ( keeps ) end if end if return end subroutine util_spill_arr_char_string module subroutine util_spill_arr_DP ( keeps , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Performs a spill operation on a single array of type DP !! This is the inverse of a spill operation implicit none ! Arguments real ( DP ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep real ( DP ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discardss logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not if (. not . allocated ( keeps ) . or . count ( lspill_list (:)) == 0 ) return if (. not . allocated ( discards )) allocate ( discards ( count ( lspill_list (:)))) discards (:) = pack ( keeps (:), lspill_list (:)) if ( ldestructive ) then if ( count (. not . lspill_list (:)) > 0 ) then keeps (:) = pack ( keeps (:), . not . lspill_list (:)) else deallocate ( keeps ) end if end if return end subroutine util_spill_arr_DP module subroutine util_spill_arr_DPvec ( keeps , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Performs a spill operation on a single array of DP vectors with shape (NDIM, n) !! This is the inverse of a spill operation implicit none ! Arguments real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: keeps !! Array of values to keep real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: discards !! Array discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not ! Internals integer ( I4B ) :: i if (. not . allocated ( keeps ) . or . count ( lspill_list (:)) == 0 ) return if (. not . allocated ( discards )) allocate ( discards ( NDIM , count ( lspill_list (:)))) do i = 1 , NDIM discards ( i ,:) = pack ( keeps ( i ,:), lspill_list (:)) end do if ( ldestructive ) then if ( count (. not . lspill_list (:)) > 0 ) then do i = 1 , NDIM keeps ( i ,:) = pack ( keeps ( i ,:), . not . lspill_list (:)) end do end if end if return end subroutine util_spill_arr_DPvec module subroutine util_spill_arr_I4B ( keeps , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Performs a spill operation on a single array of type I4B !! This is the inverse of a spill operation implicit none ! Arguments integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not if (. not . allocated ( keeps ) . or . count ( lspill_list (:)) == 0 ) return if (. not . allocated ( discards )) allocate ( discards ( count ( lspill_list (:)))) discards (:) = pack ( keeps (:), lspill_list (:)) if ( ldestructive ) then if ( count (. not . lspill_list (:)) > 0 ) then keeps (:) = pack ( keeps (:), . not . lspill_list (:)) else deallocate ( keeps ) end if end if return end subroutine util_spill_arr_I4B module subroutine util_spill_arr_logical ( keeps , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Performs a spill operation on a single array of logicals !! This is the inverse of a spill operation implicit none ! Arguments logical , dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep logical , dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or no if (. not . allocated ( keeps ) . or . count ( lspill_list (:)) == 0 ) return if (. not . allocated ( discards )) allocate ( discards ( count ( lspill_list (:)))) discards (:) = pack ( keeps (:), lspill_list (:)) if ( ldestructive ) then if ( count (. not . lspill_list (:)) > 0 ) then keeps (:) = pack ( keeps (:), . not . lspill_list (:)) else deallocate ( keeps ) end if end if return end subroutine util_spill_arr_logical module subroutine util_spill_body ( self , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Move spilled (discarded) Swiftest generic particle structure from active list to discard list !! Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest generic body object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter body by removing the discard list ! Internals integer ( I4B ) :: i ! For each component, pack the discarded bodies into the discard object and do the inverse with the keeps !> Spill all the common components associate ( keeps => self ) call util_spill ( keeps % id , discards % id , lspill_list , ldestructive ) call util_spill ( keeps % name , discards % name , lspill_list , ldestructive ) call util_spill ( keeps % status , discards % status , lspill_list , ldestructive ) call util_spill ( keeps % lmask , discards % lmask , lspill_list , ldestructive ) call util_spill ( keeps % ldiscard , discards % ldiscard , lspill_list , ldestructive ) call util_spill ( keeps % mu , discards % mu , lspill_list , ldestructive ) call util_spill ( keeps % xh , discards % xh , lspill_list , ldestructive ) call util_spill ( keeps % vh , discards % vh , lspill_list , ldestructive ) call util_spill ( keeps % xb , discards % xb , lspill_list , ldestructive ) call util_spill ( keeps % vb , discards % vb , lspill_list , ldestructive ) call util_spill ( keeps % ah , discards % ah , lspill_list , ldestructive ) call util_spill ( keeps % aobl , discards % aobl , lspill_list , ldestructive ) call util_spill ( keeps % agr , discards % agr , lspill_list , ldestructive ) call util_spill ( keeps % atide , discards % atide , lspill_list , ldestructive ) call util_spill ( keeps % a , discards % a , lspill_list , ldestructive ) call util_spill ( keeps % e , discards % e , lspill_list , ldestructive ) call util_spill ( keeps % inc , discards % inc , lspill_list , ldestructive ) call util_spill ( keeps % capom , discards % capom , lspill_list , ldestructive ) call util_spill ( keeps % omega , discards % omega , lspill_list , ldestructive ) call util_spill ( keeps % capm , discards % capm , lspill_list , ldestructive ) ! This is the base class, so will be the last to be called in the cascade. ! Therefore we need to set the nbody values for both the keeps and discareds discards % nbody = count ( lspill_list (:)) keeps % nbody = keeps % nbody - discards % nbody if ( keeps % nbody > size ( keeps % status )) keeps % status ( keeps % nbody + 1 : size ( keeps % status )) = INACTIVE end associate return end subroutine util_spill_body module subroutine util_spill_encounter ( self , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Move spilled (discarded) Swiftest encounter structure from active list to discard list implicit none ! Arguments class ( swiftest_encounter ), intent ( inout ) :: self !! Swiftest encounter list class ( swiftest_encounter ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter body by removing the discard list ! Internals integer ( I4B ) :: i associate ( keeps => self ) call util_spill ( keeps % lvdotr , discards % lvdotr , lspill_list , ldestructive ) call util_spill ( keeps % status , discards % status , lspill_list , ldestructive ) call util_spill ( keeps % index1 , discards % index1 , lspill_list , ldestructive ) call util_spill ( keeps % index2 , discards % index2 , lspill_list , ldestructive ) call util_spill ( keeps % x1 , discards % x1 , lspill_list , ldestructive ) call util_spill ( keeps % x2 , discards % x2 , lspill_list , ldestructive ) call util_spill ( keeps % v1 , discards % v1 , lspill_list , ldestructive ) call util_spill ( keeps % v2 , discards % v2 , lspill_list , ldestructive ) ! This is the base class, so will be the last to be called in the cascade. ! Therefore we need to set the nenc values for both the keeps and discareds discards % nenc = count ( lspill_list (:)) keeps % nenc = count (. not . lspill_list (:)) if ( keeps % nenc > size ( keeps % status )) keeps % status ( keeps % nenc + 1 : size ( keeps % status )) = INACTIVE end associate return end subroutine util_spill_encounter module subroutine util_spill_pl ( self , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Move spilled (discarded) Swiftest massive body structure from active list to discard list !! Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter body by removing the discard list ! Internals integer ( I4B ) :: i associate ( keeps => self ) select type ( discards ) ! The standard requires us to select the type of both arguments in order to access all the components class is ( swiftest_pl ) !> Spill components specific to the massive body class call util_spill ( keeps % mass , discards % mass , lspill_list , ldestructive ) call util_spill ( keeps % Gmass , discards % Gmass , lspill_list , ldestructive ) call util_spill ( keeps % rhill , discards % rhill , lspill_list , ldestructive ) call util_spill ( keeps % radius , discards % radius , lspill_list , ldestructive ) call util_spill ( keeps % density , discards % density , lspill_list , ldestructive ) call util_spill ( keeps % k2 , discards % k2 , lspill_list , ldestructive ) call util_spill ( keeps % Q , discards % Q , lspill_list , ldestructive ) call util_spill ( keeps % tlag , discards % tlag , lspill_list , ldestructive ) call util_spill ( keeps % xbeg , discards % xbeg , lspill_list , ldestructive ) call util_spill ( keeps % vbeg , discards % vbeg , lspill_list , ldestructive ) call util_spill ( keeps % Ip , discards % Ip , lspill_list , ldestructive ) call util_spill ( keeps % rot , discards % rot , lspill_list , ldestructive ) call util_spill_body ( keeps , discards , lspill_list , ldestructive ) class default write ( * , * ) 'Error! spill method called for incompatible return type on swiftest_pl' end select end associate return end subroutine util_spill_pl module subroutine util_spill_tp ( self , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Move spilled (discarded) Swiftest test particle structure from active list to discard list !! Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discardse logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter body by removing the discard list associate ( keeps => self , ntp => self % nbody ) select type ( discards ) class is ( swiftest_tp ) !> Spill components specific to the test particle class call util_spill ( keeps % isperi , discards % isperi , lspill_list , ldestructive ) call util_spill ( keeps % peri , discards % peri , lspill_list , ldestructive ) call util_spill ( keeps % atp , discards % atp , lspill_list , ldestructive ) call util_spill_body ( keeps , discards , lspill_list , ldestructive ) class default write ( * , * ) 'Error! spill method called for incompatible return type on swiftest_tp' end select end associate return end subroutine util_spill_tp end submodule s_util_spill","tags":"","loc":"sourcefile/util_spill.f90.html"},{"title":"util_valid.f90 – swiftest","text":"This file depends on sourcefile~~util_valid.f90~~EfferentGraph sourcefile~util_valid.f90 util_valid.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_valid.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_valid Source Code util_valid.f90 Source Code submodule ( swiftest_classes ) s_util_valid use swiftest contains module subroutine util_valid_id_system ( self , param ) !! author: David A. Minton !! !! Validate massive body and test particle ids !! Subroutine causes program to exit with error if any ids are not unique !! !! Adapted from David E. Kaufmann's Swifter routine: util_valid.f90 implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i integer ( I4B ), dimension (:), allocatable :: idarr associate ( cb => self % cb , pl => self % pl , npl => self % pl % nbody , tp => self % tp , ntp => self % tp % nbody ) allocate ( idarr ( 1 + npl + ntp )) idarr ( 1 ) = cb % id do i = 1 , npl idarr ( 1 + i ) = pl % id ( i ) end do do i = 1 , ntp idarr ( 1 + npl + i ) = tp % id ( i ) end do call util_sort ( idarr ) do i = 1 , npl + ntp if ( idarr ( i ) == idarr ( i + 1 )) then write ( * , * ) \"Swiftest error:\" write ( * , * ) \"   more than one body/particle has id = \" , idarr ( i ) call util_exit ( FAILURE ) end if end do self % maxid = maxval ( idarr ) end associate return end subroutine util_valid_id_system end submodule s_util_valid","tags":"","loc":"sourcefile/util_valid.f90.html"},{"title":"util_exit.f90 – swiftest","text":"This file depends on sourcefile~~util_exit.f90~~EfferentGraph sourcefile~util_exit.f90 util_exit.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_exit.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_exit Source Code util_exit.f90 Source Code submodule ( swiftest_classes ) s_util_exit use swiftest contains module subroutine util_exit ( code ) !! author: David A. Minton !! !! Print termination message and exit program !! !! Adapted from David E. Kaufmann's Swifter routine: util_exit.f90 !! Adapted from Hal Levison's Swift routine util_exit.f implicit none ! Arguments integer ( I4B ), intent ( in ) :: code ! Internals character ( * ), parameter :: BAR = '(\"------------------------------------------------\")' select case ( code ) case ( SUCCESS ) write ( * , SUCCESS_MSG ) VERSION_NUMBER write ( * , BAR ) case ( USAGE ) write ( * , USAGE_MSG ) case ( HELP ) write ( * , HELP_MSG ) case default write ( * , FAIL_MSG ) VERSION_NUMBER write ( * , BAR ) error stop end select stop end subroutine util_exit end submodule s_util_exit","tags":"","loc":"sourcefile/util_exit.f90.html"},{"title":"util_fill.f90 – swiftest","text":"This file depends on sourcefile~~util_fill.f90~~EfferentGraph sourcefile~util_fill.f90 util_fill.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_fill.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_fill Source Code util_fill.f90 Source Code submodule ( swiftest_classes ) s_util_fill use swiftest contains module subroutine util_fill_arr_char_string ( keeps , inserts , lfill_list ) !! author: David A. Minton !! !! Performs a fill operation on a single array of type character strings !! This is the inverse of a spill operation implicit none ! Arguments character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep character ( len = STRMAX ), dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps if (. not . allocated ( keeps ) . or . . not . allocated ( inserts )) return keeps (:) = unpack ( keeps (:), . not . lfill_list (:), keeps (:)) keeps (:) = unpack ( inserts (:), lfill_list (:), keeps (:)) return end subroutine util_fill_arr_char_string module subroutine util_fill_arr_DP ( keeps , inserts , lfill_list ) !! author: David A. Minton !! !! Performs a fill operation on a single array of type DP !! This is the inverse of a spill operation implicit none ! Arguments real ( DP ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep real ( DP ), dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps if (. not . allocated ( keeps ) . or . . not . allocated ( inserts )) return keeps (:) = unpack ( keeps (:), . not . lfill_list (:), keeps (:)) keeps (:) = unpack ( inserts (:), lfill_list (:), keeps (:)) return end subroutine util_fill_arr_DP module subroutine util_fill_arr_DPvec ( keeps , inserts , lfill_list ) !! author: David A. Minton !! !! Performs a fill operation on a single array of DP vectors with shape (NDIM, n) !! This is the inverse of a spill operation implicit none ! Arguments real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: keeps !! Array of values to keep real ( DP ), dimension (:,:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps ! Internals integer ( I4B ) :: i if (. not . allocated ( keeps ) . or . . not . allocated ( inserts )) return do i = 1 , NDIM keeps ( i ,:) = unpack ( keeps ( i ,:), . not . lfill_list (:), keeps ( i ,:)) keeps ( i ,:) = unpack ( inserts ( i ,:), lfill_list (:), keeps ( i ,:)) end do return end subroutine util_fill_arr_DPvec module subroutine util_fill_arr_I4B ( keeps , inserts , lfill_list ) !! author: David A. Minton !! !! Performs a fill operation on a single array of type I4B !! This is the inverse of a spill operation implicit none ! Arguments integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep integer ( I4B ), dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps if (. not . allocated ( keeps ) . or . . not . allocated ( inserts )) return keeps (:) = unpack ( keeps (:), . not . lfill_list (:), keeps (:)) keeps (:) = unpack ( inserts (:), lfill_list (:), keeps (:)) return end subroutine util_fill_arr_I4B module subroutine util_fill_arr_logical ( keeps , inserts , lfill_list ) !! author: David A. Minton !! !! Performs a fill operation on a single array of logicals !! This is the inverse of a spill operation implicit none ! Arguments logical , dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep logical , dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps if (. not . allocated ( keeps ) . or . . not . allocated ( inserts )) return keeps (:) = unpack ( keeps (:), . not . lfill_list (:), keeps (:)) keeps (:) = unpack ( inserts (:), lfill_list (:), keeps (:)) return end subroutine util_fill_arr_logical module subroutine util_fill_body ( self , inserts , lfill_list ) !! author: David A. Minton !! !! Insert new Swiftest generic particle structure into an old one. !! This is the inverse of a spill operation. implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest generic body object class ( swiftest_body ), intent ( in ) :: inserts !! Inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps ! internals integer ( I4B ) :: i ! For each component, pack the discarded bodies into the discard object and do the inverse with the keeps !> Fill all the common components associate ( keeps => self ) call util_fill ( keeps % id , inserts % id , lfill_list ) call util_fill ( keeps % name , inserts % name , lfill_list ) call util_fill ( keeps % status , inserts % status , lfill_list ) call util_fill ( keeps % ldiscard , inserts % ldiscard , lfill_list ) call util_fill ( keeps % lmask , inserts % lmask , lfill_list ) call util_fill ( keeps % mu , inserts % mu , lfill_list ) call util_fill ( keeps % xh , inserts % xh , lfill_list ) call util_fill ( keeps % vh , inserts % vh , lfill_list ) call util_fill ( keeps % xb , inserts % xb , lfill_list ) call util_fill ( keeps % vb , inserts % vb , lfill_list ) call util_fill ( keeps % ah , inserts % ah , lfill_list ) call util_fill ( keeps % aobl , inserts % aobl , lfill_list ) call util_fill ( keeps % agr , inserts % agr , lfill_list ) call util_fill ( keeps % atide , inserts % atide , lfill_list ) call util_fill ( keeps % a , inserts % a , lfill_list ) call util_fill ( keeps % e , inserts % e , lfill_list ) call util_fill ( keeps % inc , inserts % inc , lfill_list ) call util_fill ( keeps % capom , inserts % capom , lfill_list ) call util_fill ( keeps % omega , inserts % omega , lfill_list ) call util_fill ( keeps % capm , inserts % capm , lfill_list ) ! This is the base class, so will be the last to be called in the cascade. keeps % nbody = size ( keeps % id (:)) end associate return end subroutine util_fill_body module subroutine util_fill_pl ( self , inserts , lfill_list ) !! author: David A. Minton !! !! Insert new Swiftest massive body structure into an old one. !! This is the inverse of a spill operation. implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_body ), intent ( in ) :: inserts !! Swiftest body object to be inserted logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps ! Internals integer ( I4B ) :: i associate ( keeps => self ) select type ( inserts ) ! The standard requires us to select the type of both arguments in order to access all the components class is ( swiftest_pl ) !> Fill components specific to the massive body class call util_fill ( keeps % mass , inserts % mass , lfill_list ) call util_fill ( keeps % Gmass , inserts % Gmass , lfill_list ) call util_fill ( keeps % rhill , inserts % rhill , lfill_list ) call util_fill ( keeps % radius , inserts % radius , lfill_list ) call util_fill ( keeps % density , inserts % density , lfill_list ) call util_fill ( keeps % k2 , inserts % k2 , lfill_list ) call util_fill ( keeps % Q , inserts % Q , lfill_list ) call util_fill ( keeps % tlag , inserts % tlag , lfill_list ) call util_fill ( keeps % xbeg , inserts % xbeg , lfill_list ) call util_fill ( keeps % vbeg , inserts % vbeg , lfill_list ) call util_fill ( keeps % Ip , inserts % Ip , lfill_list ) call util_fill ( keeps % rot , inserts % rot , lfill_list ) call util_fill_body ( keeps , inserts , lfill_list ) class default write ( * , * ) 'Error! fill method called for incompatible return type on swiftest_pl' end select end associate return end subroutine util_fill_pl module subroutine util_fill_tp ( self , inserts , lfill_list ) !! author: David A. Minton !! !! Insert new Swiftest test particle structure into an old one. !! This is the inverse of a fill operation. implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_body ), intent ( in ) :: inserts !! Swiftest body object to be inserted logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps associate ( keeps => self ) select type ( inserts ) class is ( swiftest_tp ) !> Spill components specific to the test particle class call util_fill ( keeps % isperi , inserts % isperi , lfill_list ) call util_fill ( keeps % peri , inserts % peri , lfill_list ) call util_fill ( keeps % atp , inserts % atp , lfill_list ) call util_fill_body ( keeps , inserts , lfill_list ) class default write ( * , * ) 'Error! fill method called for incompatible return type on swiftest_tp' end select end associate return end subroutine util_fill_tp end submodule s_util_fill","tags":"","loc":"sourcefile/util_fill.f90.html"},{"title":"util_resize.f90 – swiftest","text":"This file depends on sourcefile~~util_resize.f90~~EfferentGraph sourcefile~util_resize.f90 util_resize.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_resize.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_resize Source Code util_resize.f90 Source Code submodule ( swiftest_classes ) s_util_resize use swiftest contains module subroutine util_resize_arr_char_string ( arr , nnew ) !! author: David A. Minton !! !! Resizes an array component of type character string. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. implicit none ! Arguments character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size ! Internals character ( len = STRMAX ), dimension (:), allocatable :: tmp !! Temporary storage array in case the input array is already allocated integer ( I4B ) :: nold !! Old size if (. not . allocated ( arr ) . or . nnew < 0 ) return nold = size ( arr ) if ( nnew == nold ) return if ( nnew == 0 ) then deallocate ( arr ) return end if allocate ( tmp ( nnew )) if ( nnew > nold ) then tmp ( 1 : nold ) = arr ( 1 : nold ) else tmp ( 1 : nnew ) = arr ( 1 : nnew ) end if call move_alloc ( tmp , arr ) return end subroutine util_resize_arr_char_string module subroutine util_resize_arr_DP ( arr , nnew ) !! author: David A. Minton !! !! Resizes an array component of double precision type. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. implicit none ! Arguments real ( DP ), dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size ! Internals real ( DP ), dimension (:), allocatable :: tmp !! Temporary storage array in case the input array is already allocated integer ( I4B ) :: nold !! Old size if (. not . allocated ( arr ) . or . nnew < 0 ) return nold = size ( arr ) if ( nnew == nold ) return if ( nnew == 0 ) then deallocate ( arr ) return end if allocate ( tmp ( nnew )) if ( nnew > nold ) then tmp ( 1 : nold ) = arr ( 1 : nold ) else tmp ( 1 : nnew ) = arr ( 1 : nnew ) end if call move_alloc ( tmp , arr ) return end subroutine util_resize_arr_DP module subroutine util_resize_arr_DPvec ( arr , nnew ) !! author: David A. Minton !! !! Resizes an array component of double precision vectors of size (NDIM, n). Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. implicit none ! Arguments real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size ! Internals real ( DP ), dimension (:,:), allocatable :: tmp !! Temporary storage array in case the input array is already allocated integer ( I4B ) :: nold !! Old size if (. not . allocated ( arr ) . or . nnew < 0 ) return nold = size ( arr , dim = 2 ) if ( nnew == nold ) return if ( nnew == 0 ) then deallocate ( arr ) return end if allocate ( tmp ( NDIM , nnew )) if ( nnew > nold ) then tmp (:, 1 : nold ) = arr (:, 1 : nold ) else tmp (:, 1 : nnew ) = arr (:, 1 : nnew ) end if call move_alloc ( tmp , arr ) return end subroutine util_resize_arr_DPvec module subroutine util_resize_arr_I4B ( arr , nnew ) !! author: David A. Minton !! !! Resizes an array component of integer type. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. implicit none ! Arguments integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size ! Internals integer ( I4B ), dimension (:), allocatable :: tmp !! Temporary storage array in case the input array is already allocated integer ( I4B ) :: nold !! Old size if (. not . allocated ( arr ) . or . nnew < 0 ) return nold = size ( arr ) if ( nnew == nold ) return if ( nnew == 0 ) then deallocate ( arr ) return end if allocate ( tmp ( nnew )) if ( nnew > nold ) then tmp ( 1 : nold ) = arr ( 1 : nold ) else tmp ( 1 : nnew ) = arr ( 1 : nnew ) end if call move_alloc ( tmp , arr ) return end subroutine util_resize_arr_I4B module subroutine util_resize_arr_logical ( arr , nnew ) !! author: David A. Minton !! !! Resizes an array component of logical type. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. implicit none ! Arguments logical , dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size ! Internals logical , dimension (:), allocatable :: tmp !! Temporary storage array in case the input array is already allocated integer ( I4B ) :: nold !! Old size if (. not . allocated ( arr ) . or . nnew < 0 ) return nold = size ( arr ) if ( nnew == nold ) return if ( nnew == 0 ) then deallocate ( arr ) return end if allocate ( tmp ( nnew )) if ( nnew > nold ) then tmp ( 1 : nold ) = arr ( 1 : nold ) else tmp ( 1 : nnew ) = arr ( 1 : nnew ) end if call move_alloc ( tmp , arr ) return end subroutine util_resize_arr_logical module subroutine util_resize_body ( self , nnew ) !! author: David A. Minton !! !! Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object integer ( I4B ), intent ( in ) :: nnew !! New size neded call util_resize ( self % name , nnew ) call util_resize ( self % id , nnew ) call util_resize ( self % status , nnew ) call util_resize ( self % ldiscard , nnew ) call util_resize ( self % lmask , nnew ) call util_resize ( self % mu , nnew ) call util_resize ( self % xh , nnew ) call util_resize ( self % vh , nnew ) call util_resize ( self % xb , nnew ) call util_resize ( self % vb , nnew ) call util_resize ( self % ah , nnew ) call util_resize ( self % aobl , nnew ) call util_resize ( self % atide , nnew ) call util_resize ( self % agr , nnew ) call util_resize ( self % ir3h , nnew ) call util_resize ( self % a , nnew ) call util_resize ( self % e , nnew ) call util_resize ( self % inc , nnew ) call util_resize ( self % capom , nnew ) call util_resize ( self % omega , nnew ) call util_resize ( self % capm , nnew ) self % nbody = count ( self % status ( 1 : nnew ) /= INACTIVE ) return end subroutine util_resize_body module subroutine util_resize_encounter ( self , nnew ) !! author: David A. Minton !! !! Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small. !! Note: The reason to extend it by a factor of 2 is for performance. When there are many enounters per step, resizing every time you want to add an !! encounter takes significant computational effort. Resizing by a factor of 2 is a tradeoff between performance (fewer resize calls) and memory managment !! Memory usage grows by a factor of 2 each time it fills up, but no more. implicit none ! Arguments class ( swiftest_encounter ), intent ( inout ) :: self !! Swiftest encounter list integer ( I4B ), intent ( in ) :: nnew !! New size of list needed ! Internals class ( swiftest_encounter ), allocatable :: enc_temp integer ( I4B ) :: nold logical :: lmalloc lmalloc = allocated ( self % status ) if ( lmalloc ) then nold = size ( self % status ) else nold = 0 end if if ( nnew > nold ) then if ( lmalloc ) allocate ( enc_temp , source = self ) call self % setup ( 2 * nnew ) if ( lmalloc ) then call self % copy ( enc_temp ) deallocate ( enc_temp ) end if else self % status ( nnew + 1 : nold ) = INACTIVE end if self % nenc = nnew return end subroutine util_resize_encounter module subroutine util_resize_pl ( self , nnew ) !! author: David A. Minton !! !! Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object integer ( I4B ), intent ( in ) :: nnew !! New size neded call util_resize_body ( self , nnew ) call util_resize ( self % mass , nnew ) call util_resize ( self % Gmass , nnew ) call util_resize ( self % rhill , nnew ) call util_resize ( self % radius , nnew ) call util_resize ( self % xbeg , nnew ) call util_resize ( self % xend , nnew ) call util_resize ( self % vbeg , nnew ) call util_resize ( self % density , nnew ) call util_resize ( self % Ip , nnew ) call util_resize ( self % rot , nnew ) call util_resize ( self % k2 , nnew ) call util_resize ( self % Q , nnew ) call util_resize ( self % tlag , nnew ) call self % eucl_index () return end subroutine util_resize_pl module subroutine util_resize_tp ( self , nnew ) !! author: David A. Minton !! !! Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest massive body object integer ( I4B ), intent ( in ) :: nnew !! New size neded call util_resize_body ( self , nnew ) call util_resize ( self % isperi , nnew ) call util_resize ( self % peri , nnew ) call util_resize ( self % atp , nnew ) return end subroutine util_resize_tp end submodule s_util_resize","tags":"","loc":"sourcefile/util_resize.f90.html"},{"title":"util_copy.f90 – swiftest","text":"This file depends on sourcefile~~util_copy.f90~~EfferentGraph sourcefile~util_copy.f90 util_copy.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_copy.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_copy Source Code util_copy.f90 Source Code submodule ( swiftest_classes ) s_util_copy use swiftest contains module subroutine util_copy_encounter ( self , source ) !! author: David A. Minton !! !! Copies elements from the source encounter list into self. implicit none ! Arguments class ( swiftest_encounter ), intent ( inout ) :: self !! Encounter list class ( swiftest_encounter ), intent ( in ) :: source !! Source object to copy into associate ( n => source % nenc ) self % nenc = n self % lvdotr ( 1 : n ) = source % lvdotr ( 1 : n ) self % status ( 1 : n ) = source % status ( 1 : n ) self % index1 ( 1 : n ) = source % index1 ( 1 : n ) self % index2 ( 1 : n ) = source % index2 ( 1 : n ) self % x1 (:, 1 : n ) = source % x1 (:, 1 : n ) self % x2 (:, 1 : n ) = source % x2 (:, 1 : n ) self % v1 (:, 1 : n ) = source % v1 (:, 1 : n ) self % v2 (:, 1 : n ) = source % v2 (:, 1 : n ) end associate return end subroutine util_copy_encounter end submodule s_util_copy","tags":"","loc":"sourcefile/util_copy.f90.html"},{"title":"util_minimize_bfgs.f90 – swiftest","text":"This file depends on sourcefile~~util_minimize_bfgs.f90~~EfferentGraph sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_minimize_bfgs Source Code util_minimize_bfgs.f90 Source Code submodule ( swiftest_classes ) s_util_minimize_bfgs use swiftest contains module function util_minimize_bfgs ( f , N , x0 , eps , lerr ) result ( x1 ) !! author: David A. Minton !! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - !! This function implements the Broyden-Fletcher-Goldfarb-Shanno method to determine the minimum of a function of N variables. !! It recieves as input: !!   f%eval(x) : lambda function object containing the objective function as the eval metho !!   N    :  Number of variables of function f !!   x0   :  Initial starting value of x !!   eps  :  Accuracy of 1 - dimensional minimization at each step !! The outputs include !!   lerr :  Returns .true. if it could not find the minimum !! Returns !!   x1   :  Final minimum (all 0 if none found) !!   0 = No miniumum found !! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - use , intrinsic :: ieee_exceptions implicit none ! Arguments integer ( I4B ), intent ( in ) :: N class ( lambda_obj ), intent ( inout ) :: f real ( DP ), dimension (:), intent ( in ) :: x0 real ( DP ), intent ( in ) :: eps logical , intent ( out ) :: lerr ! Result real ( DP ), dimension (:), allocatable :: x1 ! Internals integer ( I4B ) :: i , j , k , l , conv , num integer ( I4B ), parameter :: MAXLOOP = 1000 !! Maximum number of loops before method is determined to have failed real ( DP ), parameter :: graddelta = 1e-4_DP !! Delta x for gradient calculations real ( DP ), dimension ( N ) :: S !! Direction vectors real ( DP ), dimension ( N , N ) :: H !! Approximated inverse Hessian matrix real ( DP ), dimension ( N ) :: grad1 !! gradient of f real ( DP ), dimension ( N ) :: grad0 !! old value of gradient real ( DP ) :: astar !! 1D minimized value real ( DP ), dimension ( N ) :: y , P real ( DP ), dimension ( N , N ) :: PP , PyH , HyP real ( DP ) :: yHy , Py type ( ieee_status_type ) :: original_fpe_status logical , dimension (:), allocatable :: fpe_flag call ieee_get_status ( original_fpe_status ) ! Save the original floating point exception status call ieee_set_flag ( ieee_all , . false .) ! Set all flags to quiet allocate ( fpe_flag ( size ( ieee_usual ))) lerr = . false . allocate ( x1 , source = x0 ) ! Initialize approximate Hessian with the identity matrix (i.e. begin with method of steepest descent) ! Get initial gradient and initialize arrays for updated values of gradient and x H (:,:) = reshape ([(( 0._DP , i = 1 , j - 1 ), 1._DP , ( 0._DP , i = j + 1 , N ), j = 1 , N )], [ N , N ]) grad0 = gradf ( f , N , x0 (:), graddelta , lerr ) if ( lerr ) then call ieee_set_status ( original_fpe_status ) return end if grad1 (:) = grad0 (:) do i = 1 , MAXLOOP !check for convergence conv = count ( abs ( grad1 (:)) > eps ) if ( conv == 0 ) then !write(*,*) \"BFGS converged on gradient after \",i,\" iterations\" exit end if S (:) = - matmul ( H (:,:), grad1 (:)) astar = minimize1D ( f , x1 , S , N , graddelta , lerr ) if ( lerr ) then !write(*,*) \"Exiting BFGS with error in minimize1D step\" exit end if ! Get new x values P (:) = astar * S (:) x1 (:) = x1 (:) + P (:) ! Calculate new gradient grad0 (:) = grad1 (:) grad1 = gradf ( f , N , x1 , graddelta , lerr ) y (:) = grad1 (:) - grad0 (:) Py = sum ( P (:) * y (:)) ! set up factors for H matrix update yHy = 0._DP do k = 1 , N do j = 1 , N yHy = yHy + y ( j ) * H ( j , k ) * y ( k ) end do end do ! prevent divide by zero (convergence) if ( abs ( Py ) < tiny ( Py )) then !write(*,*) \"BFGS Converged on tiny Py after \",i,\" iterations\" exit end if ! set up update PyH (:,:) = 0._DP HyP (:,:) = 0._DP do k = 1 , N do j = 1 , N PP ( j , k ) = P ( j ) * P ( k ) do l = 1 , N PyH ( j , k ) = PyH ( j , k ) + P ( j ) * y ( l ) * H ( l , k ) HyP ( j , k ) = HyP ( j , k ) + P ( k ) * y ( l ) * H ( j , l ) end do end do end do ! update H matrix H (:,:) = H (:,:) + (( 1._DP - yHy / Py ) * PP (:,:) - PyH (:,:) - HyP (:,:)) / Py ! Normalize to prevent it from blowing up if it takes many iterations to find a solution H (:,:) = H (:,:) / norm2 ( H (:,:)) ! Stop everything if there are any exceptions to allow the routine to fail gracefully call ieee_get_flag ( ieee_usual , fpe_flag ) if ( any ( fpe_flag )) exit if ( i == MAXLOOP ) then lerr = . true . !write(*,*) \"BFGS ran out of loops!\" end if end do call ieee_get_flag ( ieee_usual , fpe_flag ) lerr = lerr . or . any ( fpe_flag ) !if (any(fpe_flag)) write(*,*) 'BFGS did not converge due to fpe' !if (lerr) write(*,*) \"BFGS did not converge!\" call ieee_set_status ( original_fpe_status ) return contains function gradf ( f , N , x1 , dx , lerr ) result ( grad ) !! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - !! Purpose:  Estimates the gradient of a function using a central difference !! approximation !! Inputs: !!   f%eval(x) : lambda function object containing the objective function as the eval metho !!   N    :  number of variables N !!   x1   :  x value array !!   dx   :  step size to use when calculating derivatives !! Outputs: !!   lerr : .true. if an error occurred. Otherwise returns .false. !! Returns !!   grad :  N sized array containing estimated gradient of f at x1 !! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - implicit none ! Arguments integer ( I4B ), intent ( in ) :: N class ( lambda_obj ), intent ( inout ) :: f real ( DP ), dimension (:), intent ( in ) :: x1 real ( DP ), intent ( in ) :: dx logical , intent ( out ) :: lerr ! Result real ( DP ), dimension ( N ) :: grad ! Internals integer ( I4B ) :: i , j real ( DP ), dimension ( N ) :: xp , xm real ( DP ) :: fp , fm logical :: lerrp , lerrm do i = 1 , N do j = 1 , N if ( j == i ) then xp ( j ) = x1 ( j ) + dx xm ( j ) = x1 ( j ) - dx else xp ( j ) = x1 ( j ) xm ( j ) = x1 ( j ) end if end do select type ( f ) class is ( lambda_obj_err ) fp = f % eval ( xp ) lerrp = f % lerr fm = f % eval ( xm ) lerrm = f % lerr lerr = lerrp . or . lerrm class is ( lambda_obj ) fp = f % eval ( xp ) fm = f % eval ( xm ) lerr = . false . end select grad ( i ) = ( fp - fm ) / ( 2 * dx ) if ( lerr ) return end do return end function gradf function minimize1D ( f , x0 , S , N , eps , lerr ) result ( astar ) !! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - !! This program find the minimum of a function of N variables in a single direction !! S using in sequence: !!    1.  A Bracketing method !!    2.  The golden section method !!    3.  A quadratic polynomial fit !! Inputs !!   f%eval(x) : lambda function object containing the objective function as the eval metho !!   x0   :  Array of size N of initial x values !!   S    :  Array of size N that determines the direction of minimization !!   N    :  Number of variables of function f !!   eps  :  Accuracy of 1 - dimensional minimization at each step !! Output !!   lerr : .true. if an error occurred. Otherwise returns .false. !! Returns !!   astar      :  Final minimum along direction S !! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - implicit none ! Arguments integer ( I4B ), intent ( in ) :: N class ( lambda_obj ), intent ( inout ) :: f real ( DP ), dimension (:), intent ( in ) :: x0 , S real ( DP ), intent ( in ) :: eps logical , intent ( out ) :: lerr ! Result real ( DP ) :: astar ! Internals integer ( I4B ) :: num = 0 real ( DP ), parameter :: step = 0.7_DP !! Bracketing method step size real ( DP ), parameter :: gam = 1.2_DP !! Bracketing method expansion parameter real ( DP ), parameter :: greduce = 0.2_DP !! Golden section method reduction factor real ( DP ), parameter :: greduce2 = 0.1_DP ! Secondary golden section method reduction factor real ( DP ) :: alo , ahi !! High and low values for 1 - D minimization routines real ( DP ), parameter :: a0 = epsilon ( 1.0_DP ) !! Initial guess of alpha alo = a0 call bracket ( f , x0 , S , N , gam , step , alo , ahi , lerr ) if ( lerr ) then !write(*,*) \"BFGS bracketing step failed!\" return end if if ( abs ( alo - ahi ) < eps ) then astar = alo lerr = . false . return end if call golden ( f , x0 , S , N , greduce , alo , ahi , lerr ) if ( lerr ) then !write(*,*) \"BFGS golden section step failed!\" return end if if ( abs ( alo - ahi ) < eps ) then astar = alo lerr = . false . return end if call quadfit ( f , x0 , S , N , eps , alo , ahi , lerr ) if ( lerr ) then !write(*,*) \"BFGS quadfit failed!\" return end if if ( abs ( alo - ahi ) < eps ) then astar = alo lerr = . false . return end if ! Quadratic fit method won't converge, so finish off with another golden section call golden ( f , x0 , S , N , greduce2 , alo , ahi , lerr ) if (. not . lerr ) astar = ( alo + ahi ) / 2.0_DP return end function minimize1D function n2one ( f , x0 , S , N , a , lerr ) result ( fnew ) implicit none ! Arguments integer ( I4B ), intent ( in ) :: N class ( lambda_obj ), intent ( inout ) :: f real ( DP ), dimension (:), intent ( in ) :: x0 , S real ( DP ), intent ( in ) :: a logical , intent ( out ) :: lerr ! Return real ( DP ) :: fnew ! Internals real ( DP ), dimension ( N ) :: xnew integer ( I4B ) :: i xnew (:) = x0 (:) + a * S (:) fnew = f % eval ( xnew (:)) select type ( f ) class is ( lambda_obj_err ) lerr = f % lerr class is ( lambda_obj ) lerr = . false . end select return end function n2one ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - subroutine bracket ( f , x0 , S , N , gam , step , lo , hi , lerr ) ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - !! This subroutine brackets the minimum.  It recieves as input: !!   f%eval(x) : lambda function object containing the objective function as the eval metho !!   x0   :  Array of size N of initial x values !!   S    :  Array of size N that determines the direction of minimization !!   gam  :  expansion parameter !!   step :  step size !!   lo   :  initial guess of lo bracket value !! The outputs include !!   lo   :  lo bracket !!   hi   :  hi bracket !!   lerr : .true. if an error occurred. Otherwise returns .false. !! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - implicit none ! Arguments integer ( I4B ), intent ( in ) :: N class ( lambda_obj ), intent ( inout ) :: f real ( DP ), dimension (:), intent ( in ) :: x0 , S real ( DP ), intent ( in ) :: gam , step real ( DP ), intent ( inout ) :: lo real ( DP ), intent ( out ) :: hi logical , intent ( out ) :: lerr ! Internals real ( DP ) :: a0 , a1 , a2 , atmp , da real ( DP ) :: f0 , f1 , f2 integer ( I4B ) :: i , j integer ( I4B ), parameter :: MAXLOOP = 100 ! maximum number of loops before method is determined to have failed real ( DP ), parameter :: eps = epsilon ( lo ) ! small number precision to test floating point equality ! set up initial bracket points a0 = lo da = step a1 = a0 + da a2 = a0 + 2 * da f0 = n2one ( f , x0 , S , N , a0 , lerr ) if ( lerr ) return f1 = n2one ( f , x0 , S , N , a1 , lerr ) if ( lerr ) return f2 = n2one ( f , x0 , S , N , a2 , lerr ) if ( lerr ) return ! loop over bracket method until either min is bracketed method fails do i = 1 , MAXLOOP if (( f0 > f1 ) . and . ( f1 < f2 )) then ! Minimum was found lo = a0 hi = a2 return else if (( f0 >= f1 ) . and . ( f1 > f2 )) then ! Function appears to decrease da = da * gam atmp = a2 + da a0 = a1 a1 = a2 a2 = atmp f0 = f1 f1 = f2 f2 = n2one ( f , x0 , S , N , a2 , lerr ) else if (( f0 < f1 ) . and . ( f1 <= f2 )) then ! Function appears to increase da = da * gam atmp = a0 - da a2 = a1 a1 = a0 a0 = atmp f2 = f1 f0 = n2one ( f , x0 , S , N , a0 , lerr ) else if (( f0 < f1 ) . and . ( f1 > f2 )) then ! We are at a peak. Pick the direction that descends the fastest da = da * gam if ( f2 > f0 ) then ! LHS is lower than RHS atmp = a2 + da a0 = a1 a1 = a2 a2 = atmp f0 = f1 f1 = f2 f2 = n2one ( f , x0 , S , N , a2 , lerr ) else ! RHS is lower than LHS atmp = a0 - da a2 = a1 a1 = a0 a0 = atmp f2 = f1 f1 = f2 f0 = n2one ( f , x0 , S , N , a0 , lerr ) end if else if (( f0 > f1 ) . and . ( abs ( f2 - f1 ) <= eps )) then ! Decrasging but RHS equal da = da * gam atmp = a2 + da a2 = atmp f2 = n2one ( f , x0 , S , N , a2 , lerr ) else if (( abs ( f0 - f1 ) < eps ) . and . ( f1 < f2 )) then ! Increasing but LHS equal da = da * gam atmp = a0 - da a0 = atmp f0 = n2one ( f , x0 , S , N , a0 , lerr ) else ! all values equal. Expand in either direction and try again a0 = a0 - da a2 = a2 + da f0 = n2one ( f , x0 , S , N , a0 , lerr ) if ( lerr ) exit ! An error occurred while evaluating the function f2 = n2one ( f , x0 , S , N , a2 , lerr ) end if if ( lerr ) exit ! An error occurred while evaluating the function end do lerr = . true . return ! no minimum found end subroutine bracket ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - subroutine golden ( f , x0 , S , N , eps , lo , hi , lerr ) ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - !! This function uses the golden section method to reduce the starting interval lo, hi by some amount sigma. !! It recieves as input: !!   f%eval(x) : lambda function object containing the objective function as the eval metho !!   x0   :  Array of size N of initial x values !!   S    :  Array of size N that determines the direction of minimization !!   gam  :  expansion parameter !!   eps  :  reduction interval in range (0 < sigma < 1) such that: !!             hi(new) - lo(new) = eps * (hi(old) - lo(old)) !!   lo   :  initial guess of lo bracket value !! The outputs include !!   lo   :  lo bracket !!   hi   :  hi bracket !!   lerr : .true. if an error occurred. Otherwise returns .false. !! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - implicit none ! Arguments integer ( I4B ), intent ( in ) :: N class ( lambda_obj ), intent ( inout ) :: f real ( DP ), dimension (:), intent ( in ) :: x0 , S real ( DP ), intent ( in ) :: eps real ( DP ), intent ( inout ) :: lo real ( DP ), intent ( out ) :: hi logical , intent ( out ) :: lerr ! Internals real ( DP ), parameter :: tau = 0.5_DP * ( sqrt ( 5.0_DP ) - 1.0_DP ) ! Golden section constant integer ( I4B ), parameter :: MAXLOOP = 40 ! maximum number of loops before method is determined to have failed (unlikely, but could occur if no minimum exists between lo and hi) real ( DP ) :: i0 ! Initial interval value real ( DP ) :: a1 , a2 real ( DP ) :: f1 , f2 integer ( I4B ) :: i , j i0 = hi - lo a1 = hi - tau * i0 a2 = lo + tau * i0 f1 = n2one ( f , x0 , S , N , a1 , lerr ) if ( lerr ) return f2 = n2one ( f , x0 , S , N , a2 , lerr ) if ( lerr ) return do i = 1 , MAXLOOP if ( abs (( hi - lo ) / i0 ) <= eps ) return ! interval reduced to input amount if ( f2 > f1 ) then hi = a2 a2 = a1 f2 = f1 a1 = hi - tau * ( hi - lo ) f1 = n2one ( f , x0 , S , N , a1 , lerr ) else lo = a1 a1 = a2 f2 = f1 a2 = hi - ( 1.0_DP - tau ) * ( hi - lo ) f2 = n2one ( f , x0 , S , N , a2 , lerr ) end if if ( lerr ) exit end do lerr = . true . return ! search took too many iterations - no minimum found end subroutine golden ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - subroutine quadfit ( f , x0 , S , N , eps , lo , hi , lerr ) ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - !! This function uses a quadratic polynomial fit to locate the minimum of a function !! to some accuracy eps.  It recieves as input: !!   f%eval(x) : lambda function object containing the objective function as the eval metho !!   lo    :  low bracket value !!   hi    :  high bracket value !!   eps   :  desired accuracy of final minimum location !! The outputs include !!   lo   :  final minimum location !!   hi   :  final minimum location !! Notes: Uses the ieee_exceptions intrinsic module to allow for graceful failure due to floating point exceptions, which won't terminate the run. !! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - implicit none ! Arguments integer ( I4B ), intent ( in ) :: N class ( lambda_obj ), intent ( inout ) :: f real ( DP ), dimension (:), intent ( in ) :: x0 , S real ( DP ), intent ( in ) :: eps real ( DP ), intent ( inout ) :: lo real ( DP ), intent ( out ) :: hi logical , intent ( out ) :: lerr ! Internals integer ( I4B ), parameter :: MAXLOOP = 20 ! maximum number of loops before method is determined to have failed. real ( DP ) :: a1 , a2 , a3 , astar ! three points for the polynomial fit and polynomial minimum real ( DP ) :: f1 , f2 , f3 , fstar ! three function values for the polynomial and polynomial minimum real ( DP ), dimension ( 3 ) :: row_1 , row_2 , row_3 , rhs , soln ! matrix for 3 equation solver (gaussian elimination) real ( DP ), dimension ( 3 , 3 ) :: lhs real ( DP ) :: d1 , d2 , d3 , aold , denom , errval integer ( I4B ) :: i lerr = . false . ! Get initial a1, a2, a3 values a1 = lo a2 = lo + 0.5_DP * ( hi - lo ) a3 = hi aold = a1 astar = a2 f1 = n2one ( f , x0 , S , N , a1 , lerr ) if ( lerr ) return f2 = n2one ( f , x0 , S , N , a2 , lerr ) if ( lerr ) return f3 = n2one ( f , x0 , S , N , a3 , lerr ) if ( lerr ) return do i = 1 , MAXLOOP ! check to see if convergence is reached and exit errval = abs (( astar - aold ) / astar ) call ieee_get_flag ( ieee_usual , fpe_flag ) if ( any ( fpe_flag )) then !write(*,*) 'quadfit fpe' !write(*,*) 'aold : ',aold !write(*,*) 'astar: ',astar lerr = . true . exit end if if ( errval < eps ) then lo = astar hi = astar exit end if ! Set up system for gaussian elimination equation solver row_1 = [ 1.0_DP , a1 , a1 ** 2 ] row_2 = [ 1.0_DP , a2 , a2 ** 2 ] row_3 = [ 1.0_DP , a3 , a3 ** 2 ] rhs = [ f1 , f2 , f3 ] lhs ( 1 , :) = row_1 lhs ( 2 , :) = row_2 lhs ( 3 , :) = row_3 ! Solve system of equations soln (:) = util_solve_linear_system ( lhs , rhs , 3 , lerr ) call ieee_set_flag ( ieee_all , . false .) ! Set all flags back to quiet call ieee_set_halting_mode ( ieee_divide_by_zero , . false .) if ( lerr ) then !write(*,*) 'quadfit fpe:' !write(*,*) 'util_solve_linear_system failed' exit end if aold = astar if ( soln ( 2 ) == soln ( 3 )) then ! Handles the case where they are both 0. 0/0 is an unhandled exception astar = - 0.5_DP else astar = - soln ( 2 ) / ( 2 * soln ( 3 )) end if call ieee_get_flag ( ieee_usual , fpe_flag ) if ( any ( fpe_flag )) then !write(*,*) 'quadfit fpe' !write(*,*) 'soln(2:3): ',soln(2:3) !write(*,*) 'a1, a2, a3' !write(*,*) a1, a2, a3 !write(*,*) 'f1, f2, f3' !write(*,*) f1, f2, f3 lerr = . true . exit end if fstar = n2one ( f , x0 , S , N , astar , lerr ) if ( lerr ) exit ! keep the three closest a values to astar and discard the fourth d1 = abs ( a1 - astar ) d2 = abs ( a2 - astar ) d3 = abs ( a3 - astar ) if ( d1 > d2 ) then if ( d1 > d3 ) then f1 = fstar a1 = astar else if ( d3 > d2 ) then f3 = fstar a3 = astar end if else if ( d2 > d3 ) then f2 = fstar a2 = astar else if ( d3 > d1 ) then f3 = fstar a3 = astar end if end if end do if ( lerr ) return lo = a1 hi = a3 return end subroutine quadfit end function util_minimize_bfgs end submodule s_util_minimize_bfgs","tags":"","loc":"sourcefile/util_minimize_bfgs.f90.html"},{"title":"util_append.f90 – swiftest","text":"This file depends on sourcefile~~util_append.f90~~EfferentGraph sourcefile~util_append.f90 util_append.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_append.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_append Source Code util_append.f90 Source Code submodule ( swiftest_classes ) s_util_append use swiftest contains module subroutine util_append_arr_char_string ( arr , source , nold , nsrc , lsource_mask ) !! author: David A. Minton !! !! Append a single array of character string type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. implicit none ! Arguments character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array character ( len = STRMAX ), dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to if (. not . allocated ( source )) return if (. not . allocated ( arr )) then allocate ( arr ( nold + nsrc )) else call util_resize ( arr , nold + nsrc ) end if arr ( nold + 1 : nold + nsrc ) = pack ( source ( 1 : nsrc ), lsource_mask ( 1 : nsrc )) return end subroutine util_append_arr_char_string module subroutine util_append_arr_DP ( arr , source , nold , nsrc , lsource_mask ) !! author: David A. Minton !! !! Append a single array of double precision type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. implicit none ! Arguments real ( DP ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array real ( DP ), dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to if (. not . allocated ( source )) return if (. not . allocated ( arr )) then allocate ( arr ( nold + nsrc )) else call util_resize ( arr , nold + nsrc ) end if arr ( nold + 1 : nold + nsrc ) = pack ( source ( 1 : nsrc ), lsource_mask ( 1 : nsrc )) return end subroutine util_append_arr_DP module subroutine util_append_arr_DPvec ( arr , source , nold , nsrc , lsource_mask ) !! author: David A. Minton !! !! Append a single array of double precision vector type of size (NDIM, n) onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. implicit none ! Arguments real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: arr !! Destination array real ( DP ), dimension (:,:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to if (. not . allocated ( source )) return if (. not . allocated ( arr )) then allocate ( arr ( NDIM , nold + nsrc )) else call util_resize ( arr , nold + nsrc ) end if arr ( 1 , nold + 1 : nold + nsrc ) = pack ( source ( 1 , 1 : nsrc ), lsource_mask ( 1 : nsrc )) arr ( 2 , nold + 1 : nold + nsrc ) = pack ( source ( 2 , 1 : nsrc ), lsource_mask ( 1 : nsrc )) arr ( 3 , nold + 1 : nold + nsrc ) = pack ( source ( 3 , 1 : nsrc ), lsource_mask ( 1 : nsrc )) return end subroutine util_append_arr_DPvec module subroutine util_append_arr_I4B ( arr , source , nold , nsrc , lsource_mask ) !! author: David A. Minton !! !! Append a single array of integer(I4B) onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. implicit none ! Arguments integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array integer ( I4B ), dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to if (. not . allocated ( source )) return if (. not . allocated ( arr )) then allocate ( arr ( nold + nsrc )) else call util_resize ( arr , nold + nsrc ) end if arr ( nold + 1 : nold + nsrc ) = pack ( source ( 1 : nsrc ), lsource_mask ( 1 : nsrc )) return end subroutine util_append_arr_I4B module subroutine util_append_arr_logical ( arr , source , nold , nsrc , lsource_mask ) !! author: David A. Minton !! !! Append a single array of logical type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. implicit none ! Arguments logical , dimension (:), allocatable , intent ( inout ) :: arr !! Destination array logical , dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to if (. not . allocated ( source )) return if (. not . allocated ( arr )) then allocate ( arr ( nold + nsrc )) else call util_resize ( arr , nold + nsrc ) end if arr ( nold + 1 : nold + nsrc ) = pack ( source ( 1 : nsrc ), lsource_mask ( 1 : nsrc )) return end subroutine util_append_arr_logical module subroutine util_append_body ( self , source , lsource_mask ) !! author: David A. Minton !! !! Append components from one Swiftest body object to another. !! This method will automatically resize the destination body if it is too small implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to associate ( nold => self % nbody , nsrc => source % nbody ) call util_append ( self % name , source % name , nold , nsrc , lsource_mask ) call util_append ( self % id , source % id , nold , nsrc , lsource_mask ) call util_append ( self % status , source % status , nold , nsrc , lsource_mask ) call util_append ( self % ldiscard , source % ldiscard , nold , nsrc , lsource_mask ) call util_append ( self % lmask , source % lmask , nold , nsrc , lsource_mask ) call util_append ( self % mu , source % mu , nold , nsrc , lsource_mask ) call util_append ( self % xh , source % xh , nold , nsrc , lsource_mask ) call util_append ( self % vh , source % vh , nold , nsrc , lsource_mask ) call util_append ( self % xb , source % xb , nold , nsrc , lsource_mask ) call util_append ( self % vb , source % vb , nold , nsrc , lsource_mask ) call util_append ( self % ah , source % ah , nold , nsrc , lsource_mask ) call util_append ( self % aobl , source % aobl , nold , nsrc , lsource_mask ) call util_append ( self % atide , source % atide , nold , nsrc , lsource_mask ) call util_append ( self % agr , source % agr , nold , nsrc , lsource_mask ) call util_append ( self % ir3h , source % ir3h , nold , nsrc , lsource_mask ) call util_append ( self % a , source % a , nold , nsrc , lsource_mask ) call util_append ( self % e , source % e , nold , nsrc , lsource_mask ) call util_append ( self % inc , source % inc , nold , nsrc , lsource_mask ) call util_append ( self % capom , source % capom , nold , nsrc , lsource_mask ) call util_append ( self % omega , source % omega , nold , nsrc , lsource_mask ) call util_append ( self % capm , source % capm , nold , nsrc , lsource_mask ) end associate self % nbody = count ( self % status (:) /= INACTIVE ) return end subroutine util_append_body module subroutine util_append_pl ( self , source , lsource_mask ) !! author: David A. Minton !! !! Append components from one Swiftest body object to another. !! This method will automatically resize the destination body if it is too small implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to select type ( source ) class is ( swiftest_pl ) associate ( nold => self % nbody , nsrc => source % nbody ) call util_append ( self % mass , source % mass , nold , nsrc , lsource_mask ) call util_append ( self % Gmass , source % Gmass , nold , nsrc , lsource_mask ) call util_append ( self % rhill , source % rhill , nold , nsrc , lsource_mask ) call util_append ( self % radius , source % radius , nold , nsrc , lsource_mask ) call util_append ( self % xbeg , source % xbeg , nold , nsrc , lsource_mask ) call util_append ( self % xend , source % xend , nold , nsrc , lsource_mask ) call util_append ( self % vbeg , source % vbeg , nold , nsrc , lsource_mask ) call util_append ( self % density , source % density , nold , nsrc , lsource_mask ) call util_append ( self % Ip , source % Ip , nold , nsrc , lsource_mask ) call util_append ( self % rot , source % rot , nold , nsrc , lsource_mask ) call util_append ( self % k2 , source % k2 , nold , nsrc , lsource_mask ) call util_append ( self % Q , source % Q , nold , nsrc , lsource_mask ) call util_append ( self % tlag , source % tlag , nold , nsrc , lsource_mask ) call util_append_body ( self , source , lsource_mask ) end associate call self % eucl_index () class default write ( * , * ) \"Invalid object passed to the append method. Source must be of class swiftest_pl or its descendents\" call util_exit ( FAILURE ) end select return end subroutine util_append_pl module subroutine util_append_tp ( self , source , lsource_mask ) !! author: David A. Minton !! !! Append components from one Swiftest body object to another. !! This method will automatically resize the destination body if it is too small implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to select type ( source ) class is ( swiftest_tp ) associate ( nold => self % nbody , nsrc => source % nbody ) call util_append ( self % isperi , source % isperi , nold , nsrc , lsource_mask ) call util_append ( self % peri , source % peri , nold , nsrc , lsource_mask ) call util_append ( self % atp , source % atp , nold , nsrc , lsource_mask ) call util_append_body ( self , source , lsource_mask ) end associate class default write ( * , * ) \"Invalid object passed to the append method. Source must be of class swiftest_tp or its descendents\" call util_exit ( FAILURE ) end select return end subroutine util_append_tp end submodule s_util_append","tags":"","loc":"sourcefile/util_append.f90.html"},{"title":"util_get_energy_momentum.f90 – swiftest","text":"This file depends on sourcefile~~util_get_energy_momentum.f90~~EfferentGraph sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_get_energy_momentum Source Code util_get_energy_momentum.f90 Source Code submodule ( swiftest_classes ) s_util_get_energy_momentum use swiftest contains module subroutine util_get_energy_momentum_system ( self , param ) !! author: David A. Minton !! !! Compute total system angular momentum vector and kinetic, potential and total system energy !! !! Adapted from David E. Kaufmann Swifter routine symba_energy_eucl.f90 !! !! Adapted from Martin Duncan's Swift routine anal_energy.f implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i , j integer ( I8B ) :: k real ( DP ) :: oblpot , kecb , kespincb real ( DP ), dimension ( self % pl % nbody ) :: irh , kepl , kespinpl , pecb real ( DP ), dimension ( self % pl % nbody ) :: Lplorbitx , Lplorbity , Lplorbitz real ( DP ), dimension ( self % pl % nbody ) :: Lplspinx , Lplspiny , Lplspinz real ( DP ), dimension ( self % pl % nplpl ) :: pepl real ( DP ), dimension ( NDIM ) :: Lcborbit , Lcbspin logical , dimension ( self % pl % nplpl ) :: lstatpl logical , dimension ( self % pl % nbody ) :: lstatus associate ( system => self , pl => self % pl , npl => self % pl % nbody , cb => self % cb ) system % Lorbit (:) = 0.0_DP system % Lspin (:) = 0.0_DP system % ke_orbit = 0.0_DP system % ke_spin = 0.0_DP kepl (:) = 0.0_DP Lplorbitx (:) = 0.0_DP Lplorbity (:) = 0.0_DP Lplorbitz (:) = 0.0_DP Lplspinx (:) = 0.0_DP Lplspiny (:) = 0.0_DP Lplspinz (:) = 0.0_DP lstatus ( 1 : npl ) = pl % status ( 1 : npl ) /= INACTIVE kecb = cb % mass * dot_product ( cb % vb (:), cb % vb (:)) Lcborbit (:) = cb % mass * cb % xb (:) . cross . cb % vb (:) do concurrent ( i = 1 : npl , lstatus ( i )) block ! We use a block construct to prevent generating temporary arrays for local variables real ( DP ) :: v2 , hx , hy , hz v2 = dot_product ( pl % vb (:, i ), pl % vb (:, i )) hx = pl % xb ( 2 , i ) * pl % vb ( 3 , i ) - pl % xb ( 3 , i ) * pl % vb ( 2 , i ) hy = pl % xb ( 3 , i ) * pl % vb ( 1 , i ) - pl % xb ( 1 , i ) * pl % vb ( 3 , i ) hz = pl % xb ( 1 , i ) * pl % vb ( 2 , i ) - pl % xb ( 2 , i ) * pl % vb ( 1 , i ) ! Angular momentum from orbit Lplorbitx ( i ) = pl % mass ( i ) * hx Lplorbity ( i ) = pl % mass ( i ) * hy Lplorbitz ( i ) = pl % mass ( i ) * hz ! Kinetic energy from orbit and spin kepl ( i ) = pl % mass ( i ) * v2 end block end do if ( param % lrotation ) then kespincb = cb % mass * cb % Ip ( 3 ) * cb % radius ** 2 * dot_product ( cb % rot (:), cb % rot (:)) ! For simplicity, we always assume that the rotation pole is the 3rd principal axis Lcbspin (:) = cb % Ip ( 3 ) * cb % mass * cb % radius ** 2 * cb % rot (:) do concurrent ( i = 1 : npl , lstatus ( i )) block real ( DP ) :: rot2 , hsx , hsy , hsz rot2 = dot_product ( pl % rot (:, i ), pl % rot (:, i )) ! For simplicity, we always assume that the rotation pole is the 3rd principal axis hsx = pl % Ip ( 3 , i ) * pl % radius ( i ) ** 2 * pl % rot ( 1 , i ) hsy = pl % Ip ( 3 , i ) * pl % radius ( i ) ** 2 * pl % rot ( 2 , i ) hsz = pl % Ip ( 3 , i ) * pl % radius ( i ) ** 2 * pl % rot ( 3 , i ) ! Angular momentum from spin Lplspinx ( i ) = pl % mass ( i ) * hsx Lplspiny ( i ) = pl % mass ( i ) * hsy Lplspinz ( i ) = pl % mass ( i ) * hsz kespinpl ( i ) = pl % mass ( i ) * pl % Ip ( 3 , i ) * pl % radius ( i ) ** 2 * rot2 end block end do else kespincb = 0.0_DP kespinpl (:) = 0.0_DP end if ! Do the central body potential energy component first associate ( px => pl % xb ( 1 ,:), py => pl % xb ( 2 ,:), pz => pl % xb ( 3 ,:)) do concurrent ( i = 1 : npl , lstatus ( i )) pecb ( i ) = - cb % Gmass * pl % mass ( i ) / sqrt ( px ( i ) ** 2 + py ( i ) ** 2 + pz ( i ) ** 2 ) end do end associate ! Do the potential energy between pairs of massive bodies associate ( indi => pl % k_plpl ( 1 , :), indj => pl % k_plpl ( 2 , :)) do concurrent ( k = 1 : pl % nplpl ) lstatpl ( k ) = ( lstatus ( indi ( k )) . and . lstatus ( indj ( k ))) end do do concurrent ( k = 1 : pl % nplpl , lstatpl ( k )) pepl ( k ) = - pl % Gmass ( indi ( k )) * pl % mass ( indj ( k )) / norm2 ( pl % xb (:, indi ( k )) - pl % xb (:, indj ( k ))) end do end associate system % pe = sum ( pepl (:), lstatpl (:)) + sum ( pecb ( 1 : npl ), lstatus ( 1 : npl )) system % ke_orbit = 0.5_DP * ( kecb + sum ( kepl ( 1 : npl ), lstatus (:))) if ( param % lrotation ) system % ke_spin = 0.5_DP * ( kespincb + sum ( kespinpl ( 1 : npl ), lstatus (:))) ! Potential energy from the oblateness term if ( param % loblatecb ) then do concurrent ( i = 1 : npl , lstatus ( i )) irh ( i ) = 1.0_DP / norm2 ( pl % xh (:, i )) end do call obl_pot ( npl , cb % Gmass , pl % mass , cb % j2rp2 , cb % j4rp4 , pl % xh , irh , oblpot ) system % pe = system % pe + oblpot end if system % Lorbit ( 1 ) = Lcborbit ( 1 ) + sum ( Lplorbitx ( 1 : npl ), lstatus ( 1 : npl )) system % Lorbit ( 2 ) = Lcborbit ( 2 ) + sum ( Lplorbity ( 1 : npl ), lstatus ( 1 : npl )) system % Lorbit ( 3 ) = Lcborbit ( 3 ) + sum ( Lplorbitz ( 1 : npl ), lstatus ( 1 : npl )) if ( param % lrotation ) then system % Lspin ( 1 ) = Lcbspin ( 1 ) + sum ( Lplspinx ( 1 : npl ), lstatus ( 1 : npl )) system % Lspin ( 2 ) = Lcbspin ( 2 ) + sum ( Lplspiny ( 1 : npl ), lstatus ( 1 : npl )) system % Lspin ( 3 ) = Lcbspin ( 3 ) + sum ( Lplspinz ( 1 : npl ), lstatus ( 1 : npl )) end if system % te = system % ke_orbit + system % ke_spin + system % pe end associate return end subroutine util_get_energy_momentum_system end submodule s_util_get_energy_momentum","tags":"","loc":"sourcefile/util_get_energy_momentum.f90.html"},{"title":"gr.f90 – swiftest","text":"This file depends on sourcefile~~gr.f90~~EfferentGraph sourcefile~gr.f90 gr.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~gr.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_gr Source Code gr.f90 Source Code submodule ( swiftest_classes ) s_gr use swiftest contains module pure subroutine gr_kick_getaccb_ns_body ( self , system , param ) !! author: David A. Minton !! !! Add relativistic correction acceleration for non-symplectic integrators. !! Based on Quinn et al. (1991) eq. 5 !! !! Reference: !!    Quinn, T.R., Tremaine, S., Duncan, M., 1991. A three million year integration of the earth’s orbit. !!       AJ 101, 2287–2305. https://doi.org/10.1086/115850 !! !! Adapted from David A. Minton's Swifter routine routine gr_kick_getaccb_ns.f90 implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest generic body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals real ( DP ) :: rmag , rdotv , vmag2 integer ( I4B ) :: i associate ( n => self % nbody , cb => system % cb , inv_c2 => param % inv_c2 ) if ( n == 0 ) return do i = 1 , n rmag = norm2 ( self % xh (:, i )) vmag2 = dot_product ( self % vh (:, i ), self % vh (:, i )) rdotv = dot_product ( self % xh (:, i ), self % vh (:, i )) self % agr (:, i ) = self % mu * inv_c2 / rmag ** 3 * (( 4 * self % mu ( i ) / rmag - vmag2 ) * self % xh (:, i ) + 4 * rdotv * self % vh (:, i )) end do select type ( self ) class is ( swiftest_pl ) do i = 1 , NDIM cb % agr ( i ) = - sum ( self % Gmass ( 1 : n ) * self % agr ( 1 : n , i ) / cb % Gmass ) end do end select end associate return end subroutine gr_kick_getaccb_ns_body module subroutine gr_kick_getacch ( mu , x , lmask , n , inv_c2 , agr ) !! author: David A. Minton !! !! Compute relativisitic accelerations of massive bodies !!    Based on Saha & Tremaine (1994) Eq. 28 !! !! Adapted from David A. Minton's Swifter routine routine gr_whm_kick_getacch.f90 implicit none ! Arguments real ( DP ), dimension (:), intent ( in ) :: mu !! Gravitational constant real ( DP ), dimension (:,:), intent ( in ) :: x !! Position vectors logical , dimension (:), intent ( in ) :: lmask !! Logical mask indicating which bodies to compute integer ( I4B ), intent ( in ) :: n !! Total number of bodies real ( DP ), intent ( in ) :: inv_c2 !! Inverse speed of light squared: 1 / c**2 real ( DP ), dimension (:,:), intent ( out ) :: agr !! Accelerations ! Internals integer ( I4B ) :: i real ( DP ) :: beta , rjmag4 agr (:,:) = 0.0_DP do concurrent ( i = 1 : n , lmask ( i )) rjmag4 = ( dot_product ( x (:, i ), x (:, i ))) ** 2 beta = - mu ( i ) ** 2 * inv_c2 agr (:, i ) = 2 * beta * x (:, i ) / rjmag4 end do return end subroutine gr_kick_getacch module pure subroutine gr_p4_pos_kick ( param , x , v , dt ) !! author: David A. Minton !! !! Position kick due to p**4 term in the post-Newtonian correction !!    Based on Saha & Tremaine (1994) Eq. 28 !! !! Reference: !!    Saha, P., Tremaine, S., 1994. Long-term planetary integration with individual time steps. !!       AJ 108, 1962–1969. https://doi.org/10.1086/117210 !! !! Adapted from David A. Minton's Swifter routine gr_whm_p4.f90 implicit none ! Arguments class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), dimension (:), intent ( inout ) :: x !! Position vector real ( DP ), dimension (:), intent ( in ) :: v !! Velocity vector real ( DP ), intent ( in ) :: dt !! Step size ! Internals real ( DP ), dimension ( NDIM ) :: dr real ( DP ) :: vmag2 vmag2 = dot_product ( v (:), v (:)) dr (:) = - 2 * param % inv_c2 * vmag2 * v (:) x (:) = x (:) + dr (:) * dt return end subroutine gr_p4_pos_kick module pure subroutine gr_pseudovel2vel ( param , mu , xh , pv , vh ) !! author: David A. Minton !! !! Converts the relativistic pseudovelocity back into a veliocentric velocity !!    Based on Saha & Tremaine (1994) Eq. 32 !! !! Reference: !!    Saha, P., Tremaine, S., 1994. Long-term planetary integration with individual time steps. !!       AJ 108, 1962–1969. https://doi.org/10.1086/117210 !! !! Adapted from David A. Minton's Swifter routine gr_pseudovel2vel.f90 implicit none ! Arguments class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: mu !! G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real ( DP ), dimension (:), intent ( in ) :: xh !! Heliocentric position vector real ( DP ), dimension (:), intent ( in ) :: pv !! Pseudovelocity velocity vector - see Saha & Tremain (1994), eq. (32) real ( DP ), dimension (:), intent ( out ) :: vh !! Heliocentric velocity vector ! Internals real ( DP ) :: vmag2 , rmag , grterm associate ( inv_c2 => param % inv_c2 ) vmag2 = dot_product ( pv (:), pv (:)) rmag = norm2 ( xh (:)) grterm = 1.0_DP - inv_c2 * ( 0.5_DP * vmag2 + 3 * mu / rmag ) vh (:) = pv (:) * grterm end associate return end subroutine gr_pseudovel2vel module pure subroutine gr_pv2vh_body ( self , param ) !! author: David A. Minton !! !! Wrapper function that converts from pseudovelocity to heliocentric velocity for swiftest bodies implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i real ( DP ), dimension (:,:), allocatable :: vh !! Temporary holder of pseudovelocity for in-place conversion associate ( n => self % nbody ) if ( n == 0 ) return allocate ( vh , mold = self % vh ) do i = 1 , n call gr_pseudovel2vel ( param , self % mu ( i ), self % xh (:, i ), self % vh (:, i ), vh (:, i )) end do call move_alloc ( vh , self % vh ) end associate return end subroutine gr_pv2vh_body module pure subroutine gr_vel2pseudovel ( param , mu , xh , vh , pv ) !! author: David A. Minton !! !! Converts the heliocentric velocity into a pseudovelocity with relativistic corrections. !! Uses Newton-Raphson method with direct inversion of the Jacobian (yeah, it's slow, but !! this is only done once per run). !! !! Reference: !!    Saha, P., Tremaine, S., 1994. Long-term planetary integration with individual time steps. !!       AJ 108, 1962–1969. https://doi.org/10.1086/117210 !! !! Adapted from David A. Minton's Swifter routine gr_vel2pseudovel.f90 implicit none ! Arguments class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: mu !! G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real ( DP ), dimension (:), intent ( in ) :: xh !! Heliocentric position vector real ( DP ), dimension (:), intent ( in ) :: vh !! Heliocentric velocity vector real ( DP ), dimension (:), intent ( out ) :: pv !! Pseudovelocity vector - see Saha & Tremain (1994), eq. (32) ! Internals real ( DP ) :: v2 , G , pv2 , rterm , det real ( DP ), dimension ( NDIM , NDIM ) :: J , Jinv real ( DP ), dimension ( NDIM ) :: F integer ( I4B ) :: n , i , k integer ( I4B ), parameter :: MAXITER = 50 real ( DP ), parameter :: TOL = 1.0e-12_DP associate ( inv_c2 => param % inv_c2 ) pv ( 1 : NDIM ) = vh ( 1 : NDIM ) ! Initial guess rterm = 3 * mu / norm2 ( xh (:)) v2 = dot_product ( vh (:), vh (:)) do n = 1 , MAXITER pv2 = dot_product ( pv (:), pv (:)) G = 1.0_DP - inv_c2 * ( 0.5_DP * pv2 + rterm ) F (:) = pv (:) * G - vh (:) if ( abs ( sum ( F ) / v2 ) < TOL ) exit ! Root found ! Calculate the Jacobian do k = 1 , NDIM do i = 1 , NDIM if ( i == k ) then J ( i , k ) = G - inv_c2 * pv ( k ) else J ( i , k ) = - inv_c2 * pv ( k ) end if end do end do ! Inverse of the Jacobian det = J ( 1 , 1 ) * ( J ( 3 , 3 ) * J ( 2 , 2 ) - J ( 3 , 2 ) * J ( 2 , 3 )) det = det - J ( 2 , 1 ) * ( J ( 3 , 3 ) * J ( 1 , 2 ) - J ( 3 , 2 ) * J ( 1 , 3 )) det = det + J ( 3 , 1 ) * ( J ( 2 , 3 ) * J ( 1 , 2 ) - J ( 2 , 2 ) * J ( 1 , 3 )) Jinv ( 1 , 1 ) = J ( 3 , 3 ) * J ( 2 , 2 ) - J ( 3 , 2 ) * J ( 2 , 3 ) Jinv ( 1 , 2 ) = - ( J ( 3 , 3 ) * J ( 1 , 2 ) - J ( 3 , 2 ) * J ( 1 , 3 )) Jinv ( 1 , 3 ) = J ( 2 , 3 ) * J ( 1 , 2 ) - J ( 2 , 2 ) * J ( 1 , 3 ) Jinv ( 2 , 1 ) = - ( J ( 3 , 3 ) * J ( 2 , 1 ) - J ( 3 , 1 ) * J ( 2 , 3 )) Jinv ( 2 , 2 ) = J ( 3 , 3 ) * J ( 1 , 1 ) - J ( 3 , 1 ) * J ( 1 , 3 ) Jinv ( 2 , 3 ) = - ( J ( 2 , 3 ) * J ( 1 , 1 ) - J ( 2 , 1 ) * J ( 1 , 3 )) Jinv ( 3 , 1 ) = J ( 3 , 2 ) * J ( 2 , 1 ) - J ( 3 , 1 ) * J ( 2 , 2 ) Jinv ( 3 , 2 ) = - ( J ( 3 , 2 ) * J ( 1 , 1 ) - J ( 3 , 1 ) * J ( 1 , 2 )) Jinv ( 3 , 3 ) = J ( 2 , 2 ) * J ( 1 , 1 ) - J ( 2 , 1 ) * J ( 1 , 2 ) Jinv = Jinv * det do i = 1 , NDIM pv ( i ) = pv ( i ) - dot_product ( Jinv ( i ,:), F (:)) end do end do end associate return end subroutine gr_vel2pseudovel module pure subroutine gr_vh2pv_body ( self , param ) !! author: David A. Minton !! !! Wrapper function that converts from heliocentric velocity to pseudovelocity for Swiftest bodies implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i real ( DP ), dimension (:,:), allocatable :: pv !! Temporary holder of pseudovelocity for in-place conversion associate ( n => self % nbody ) if ( n == 0 ) return allocate ( pv , mold = self % vh ) do i = 1 , n call gr_vel2pseudovel ( param , self % mu ( i ), self % xh (:, i ), self % vh (:, i ), pv (:, i )) end do call move_alloc ( pv , self % vh ) end associate return end subroutine gr_vh2pv_body end submodule s_gr","tags":"","loc":"sourcefile/gr.f90.html"},{"title":"discard.f90 – swiftest","text":"This file depends on sourcefile~~discard.f90~~EfferentGraph sourcefile~discard.f90 discard.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~discard.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_discard Source Code discard.f90 Source Code submodule ( swiftest_classes ) s_discard use swiftest contains module subroutine discard_system ( self , param ) !! author: David A. Minton !! !! Calls the discard methods for each body class and then the write method if any discards were detected !! implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals logical :: lany_discards , lpl_discards , ltp_discards , lpl_check , ltp_check lpl_check = allocated ( self % pl_discards ) ltp_check = allocated ( self % tp_discards ) associate ( system => self , tp => self % tp , pl => self % pl , tp_discards => self % tp_discards , pl_discards => self % pl_discards ) lpl_discards = . false . ltp_discards = . false . if ( lpl_check ) then call pl % discard ( system , param ) lpl_discards = ( pl_discards % nbody > 0 ) end if if ( ltp_check ) then call tp % discard ( system , param ) ltp_discards = ( tp_discards % nbody > 0 ) end if if ( lpl_discards . or . ltp_discards ) call system % write_discard ( param ) if ( lpl_discards . and . param % lenergy ) call self % conservation_report ( param , lterminal = . true .) if ( lpl_check ) call pl_discards % setup ( 0 , param ) if ( ltp_check ) call tp_discards % setup ( 0 , param ) end associate return end subroutine discard_system module subroutine discard_pl ( self , system , param ) !! author: David A. Minton !! !!  Placeholder method for discarding massive bodies. This method does nothing except to ensure that the discard flag is set to false. !!  This method is intended to be overridden by more advanced integrators. implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameter if ( self % nbody == 0 ) return self % ldiscard (:) = . false . return end subroutine discard_pl module subroutine discard_tp ( self , system , param ) !! author: David A. Minton !! !! Check to see if particles should be discarded based on their positions relative to the massive bodies !! !! Adapted from David E. Kaufmann's Swifter routine: discard.f90 !! Adapted from Hal Levison's Swift routine discard. implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameter ! Internals logical , dimension (:), allocatable :: ldiscard associate ( tp => self , ntp => self % nbody , cb => system % cb , pl => system % pl , npl => system % pl % nbody ) if (( ntp == 0 ) . or . ( npl == 0 )) return if (( param % rmin >= 0.0_DP ) . or . ( param % rmax >= 0.0_DP ) . or . & ( param % rmaxu >= 0.0_DP ) . or . (( param % qmin >= 0.0_DP ) . and . ( param % qmin_coord == \"BARY\" ))) then call pl % h2b ( cb ) call tp % h2b ( cb ) end if if (( param % rmin >= 0.0_DP ) . or . ( param % rmax >= 0.0_DP ) . or . ( param % rmaxu >= 0.0_DP )) call discard_cb_tp ( tp , system , param ) if ( param % qmin >= 0.0_DP ) call discard_peri_tp ( tp , system , param ) if ( param % lclose ) call discard_pl_tp ( tp , system , param ) if ( any ( tp % ldiscard )) then allocate ( ldiscard , source = tp % ldiscard ) call tp % spill ( system % tp_discards , ldiscard , ldestructive = . true .) end if end associate return end subroutine discard_tp subroutine discard_cb_tp ( tp , system , param ) !! author: David A. Minton !! !!  Check to see if test particles should be discarded based on their positions relative to the Sun !!        or because they are unbound from the system !! !! Adapted from David E. Kaufmann's Swifter routine: discard_sun.f90 !! Adapted from Hal Levison's Swift routine discard_sun.f implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: tp !! Swiftest test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i real ( DP ) :: energy , vb2 , rb2 , rh2 , rmin2 , rmax2 , rmaxu2 associate ( ntp => tp % nbody , cb => system % cb , t => param % t , Gmtot => system % Gmtot ) rmin2 = max ( param % rmin * param % rmin , cb % radius * cb % radius ) rmax2 = param % rmax ** 2 rmaxu2 = param % rmaxu ** 2 do i = 1 , ntp if ( tp % status ( i ) == ACTIVE ) then rh2 = dot_product ( tp % xh (:, i ), tp % xh (:, i )) if (( param % rmax >= 0.0_DP ) . and . ( rh2 > rmax2 )) then tp % status ( i ) = DISCARDED_RMAX write ( * , * ) \"Particle \" , tp % id ( i ), \" too far from sun at t = \" , t tp % ldiscard ( i ) = . true . tp % lmask ( i ) = . false . else if (( param % rmin >= 0.0_DP ) . and . ( rh2 < rmin2 )) then tp % status ( i ) = DISCARDED_RMIN write ( * , * ) \"Particle \" , tp % id ( i ), \" too close to sun at t = \" , t tp % ldiscard ( i ) = . true . tp % lmask ( i ) = . false . else if ( param % rmaxu >= 0.0_DP ) then rb2 = dot_product ( tp % xb (:, i ), tp % xb (:, i )) vb2 = dot_product ( tp % vb (:, i ), tp % vb (:, i )) energy = 0.5_DP * vb2 - Gmtot / sqrt ( rb2 ) if (( energy > 0.0_DP ) . and . ( rb2 > rmaxu2 )) then tp % status ( i ) = DISCARDED_RMAXU write ( * , * ) \"Particle \" , tp % id ( i ), \" is unbound and too far from barycenter at t = \" , t tp % ldiscard ( i ) = . true . tp % lmask ( i ) = . false . end if end if end if end do end associate return end subroutine discard_cb_tp subroutine discard_peri_tp ( tp , system , param ) !! author: David A. Minton !! !! Check to see if a test particle should be discarded because its perihelion distance becomes too small !! !! Adapted from David E. Kaufmann's Swifter routine: discard_peri.f90 !! Adapted from Hal Levison's Swift routine discard_peri.f implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: tp !! Swiftest test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameterss ! Internals logical , save :: lfirst = . true . integer ( I4B ) :: i , j , ih real ( DP ) :: r2 real ( DP ), dimension ( NDIM ) :: dx associate ( cb => system % cb , ntp => tp % nbody , pl => system % pl , npl => system % pl % nbody , t => param % t ) call tp % get_peri ( system , param ) do i = 1 , ntp if ( tp % status ( i ) == ACTIVE ) then if ( tp % isperi ( i ) == 0 ) then ih = 1 do j = 1 , npl dx (:) = tp % xh (:, i ) - pl % xh (:, j ) r2 = dot_product ( dx (:), dx (:)) if ( r2 <= ( pl % rhill ( j )) ** 2 ) ih = 0 end do if ( ih == 1 ) then if (( tp % atp ( i ) >= param % qmin_alo ) . and . & ( tp % atp ( i ) <= param % qmin_ahi ) . and . & ( tp % peri ( i ) <= param % qmin )) then tp % status ( i ) = DISCARDED_PERI write ( * , * ) \"Particle \" , tp % id ( i ), \" perihelion distance too small at t = \" , t tp % ldiscard ( i ) = . true . end if end if end if end if end do end associate return end subroutine discard_peri_tp subroutine discard_pl_tp ( tp , system , param ) !! author: David A. Minton !! !! Check to see if test particles should be discarded based on their positions relative to the massive bodies !! !! Adapted from David E. Kaufmann's Swifter routine: discard_pl.f90 !! Adapted from Hal Levison's Swift routine discard_pl.f implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: tp !! Swiftest test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i , j , isp real ( DP ) :: r2min , radius real ( DP ), dimension ( NDIM ) :: dx , dv associate ( ntp => tp % nbody , pl => system % pl , npl => system % pl % nbody , t => param % t , dt => param % dt ) do i = 1 , ntp if ( tp % status ( i ) == ACTIVE ) then do j = 1 , npl dx (:) = tp % xh (:, i ) - pl % xh (:, j ) dv (:) = tp % vh (:, i ) - pl % vh (:, j ) radius = pl % radius ( j ) call discard_pl_close ( dx (:), dv (:), dt , radius ** 2 , isp , r2min ) if ( isp /= 0 ) then tp % status ( i ) = DISCARDED_PLR tp % lmask ( i ) = . false . pl % ldiscard ( j ) = . true . write ( * , * ) \"Particle \" , tp % id ( i ), \" too close to massive body \" , pl % id ( j ), \" at t = \" , t tp % ldiscard ( i ) = . true . exit end if end do end if end do end associate return end subroutine discard_pl_tp subroutine discard_pl_close ( dx , dv , dt , r2crit , iflag , r2min ) !! author: David A. Minton !! !!  Check to see if a test particle and massive body are having, or will have within the next time step, an encounter such !!          that the separation distance r is less than some critical radius rcrit (or r**2 < rcrit**2 = r2crit) !! !! Adapted from David E. Kaufmann's Swifter routine: discard_pl_close.f90 !! Adapted from Hal Levison's Swift routine discard_pl_close.f implicit none ! Arguments real ( DP ), dimension (:), intent ( in ) :: dx , dv real ( DP ), intent ( in ) :: dt , r2crit integer ( I4B ), intent ( out ) :: iflag real ( DP ), intent ( out ) :: r2min ! Internals real ( DP ) :: r2 , v2 , vdotr , tmin r2 = dot_product ( dx (:), dx (:)) if ( r2 <= r2crit ) then iflag = 1 else vdotr = dot_product ( dx (:), dv (:)) if ( vdotr > 0.0_DP ) then iflag = 0 else v2 = dot_product ( dv (:), dv (:)) tmin = - vdotr / v2 if ( tmin < dt ) then r2min = r2 - vdotr * vdotr / v2 else r2min = r2 + 2 * vdotr * dt + v2 * dt ** 2 end if r2min = min ( r2min , r2 ) if ( r2min <= r2crit ) then iflag = 1 else iflag = 0 end if end if end if return end subroutine discard_pl_close end submodule s_discard","tags":"","loc":"sourcefile/discard.f90.html"},{"title":"helio_step.f90 – swiftest","text":"This file depends on sourcefile~~helio_step.f90~~EfferentGraph sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~helio_step.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_helio_step Source Code helio_step.f90 Source Code submodule ( helio_classes ) s_helio_step use swiftest contains module subroutine helio_step_system ( self , param , t , dt ) !! author: David A. Minton !! !! Step massive bodies and and active test particles ahead in heliocentric coordinates. !! !! Currently there's no difference between this and the WHM system stepper, so this is just !! a wrapper function to keep the method calls consistent for inherited types. !! !! Adapted from Hal Levison's Swift routine step_kdk.f !! Adapted from David E. Kaufmann's Swifter routine helio_step.f90 implicit none ! Arguments class ( helio_nbody_system ), intent ( inout ) :: self !! Helio nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize call whm_step_system ( self , param , t , dt ) return end subroutine helio_step_system module subroutine helio_step_pl ( self , system , param , t , dt ) !! author: David A. Minton !! !! Step massive bodies ahead Democratic Heliocentric method !! !! Adapted from David E. Kaufmann's Swifter helio_step_pl.f90 !! Adapted from Hal Levison's Swift routine helio_step_pl.f implicit none ! Arguments class ( helio_pl ), intent ( inout ) :: self !! Helio massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nboody system class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Stepsize ! Internals real ( DP ) :: dth !! Half step size if ( self % nbody == 0 ) return associate ( pl => self ) select type ( cb => system % cb ) class is ( helio_cb ) dth = 0.5_DP * dt if ( pl % lfirst ) then call pl % vh2vb ( cb ) pl % lfirst = . false . end if call pl % lindrift ( cb , dth , lbeg = . true .) call pl % kick ( system , param , t , dth , lbeg = . true .) if ( param % lgr ) call pl % gr_pos_kick ( param , dth ) call pl % drift ( system , param , dt ) call pl % kick ( system , param , t + dt , dth , lbeg = . false .) if ( param % lgr ) call pl % gr_pos_kick ( param , dth ) call pl % lindrift ( cb , dth , lbeg = . false .) call pl % vb2vh ( cb ) end select end associate return end subroutine helio_step_pl module subroutine helio_step_tp ( self , system , param , t , dt ) !! author: David A. Minton !! !! Step active test particles ahead using Democratic Heliocentric method !! !! Adapted from David E. Kaufmann's Swifter routine helio_step_tp.f90 !! Adapted from Hal Levison's Swift routine helio_step_tp.f implicit none ! Arguments class ( helio_tp ), intent ( inout ) :: self !! Helio test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nboody system class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Stepsize ! Internals real ( DP ) :: dth !! Half step size if ( self % nbody == 0 ) return associate ( tp => self ) select type ( cb => system % cb ) class is ( helio_cb ) dth = 0.5_DP * dt if ( tp % lfirst ) then call tp % vh2vb ( vbcb = - cb % ptbeg ) tp % lfirst = . false . end if call tp % lindrift ( cb , dth , lbeg = . true .) call tp % kick ( system , param , t , dth , lbeg = . true .) if ( param % lgr ) call tp % gr_pos_kick ( param , dth ) call tp % drift ( system , param , dt ) call tp % kick ( system , param , t + dt , dth , lbeg = . false .) if ( param % lgr ) call tp % gr_pos_kick ( param , dth ) call tp % lindrift ( cb , dth , lbeg = . false .) call tp % vb2vh ( vbcb = - cb % ptend ) end select end associate return end subroutine helio_step_tp end submodule s_helio_step","tags":"","loc":"sourcefile/helio_step.f90.html"},{"title":"helio_gr.f90 – swiftest","text":"This file depends on sourcefile~~helio_gr.f90~~EfferentGraph sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~helio_gr.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_helio_gr Source Code helio_gr.f90 Source Code submodule ( helio_classes ) s_helio_gr use swiftest contains module subroutine helio_gr_kick_getacch_pl ( self , param ) !! author: David A. Minton !! !! Compute relativisitic accelerations of massive bodies !!    Based on Saha & Tremaine (1994) Eq. 28 !! !! Adapted from David A. Minton's Swifter routine routine gr_whm_kick_getacch.f90 implicit none ! Arguments class ( helio_pl ), intent ( inout ) :: self !! Helio massive body particle data structure class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i real ( DP ), dimension ( NDIM ) :: suma real ( DP ), dimension (:, :), allocatable :: aj real ( DP ) :: beta , rjmag4 if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) call gr_kick_getacch ( pl % mu , pl % xh , pl % lmask , npl , param % inv_c2 , pl % agr ) pl % ah (:, 1 : npl ) = pl % ah (:, 1 : npl ) + pl % agr (:, 1 : npl ) end associate return end subroutine helio_gr_kick_getacch_pl module subroutine helio_gr_kick_getacch_tp ( self , param ) !! author: David A. Minton !! !! Compute relativisitic accelerations of test particles !!    Based on Saha & Tremaine (1994) Eq. 28 !! !! Adapted from David A. Minton's Swifter routine routine gr_helio_kick_getacch.f90 implicit none ! Arguments class ( helio_tp ), intent ( inout ) :: self !! Helio massive body particle data structure class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i real ( DP ) :: rjmag4 , beta if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) call gr_kick_getacch ( tp % mu , tp % xh , tp % lmask , ntp , param % inv_c2 , tp % agr ) tp % ah (:, 1 : ntp ) = tp % ah (:, 1 : ntp ) + tp % agr (:, 1 : ntp ) end associate return end subroutine helio_gr_kick_getacch_tp module pure subroutine helio_gr_p4_pl ( self , param , dt ) !! author: David A. Minton !! !! Position kick to massive bodies due to p**4 term in the post-Newtonian correction !!    Based on Saha & Tremaine (1994) Eq. 28 !! !! Adapted from David A. Minton's Swifter routine routine gr_helio_p4.f90 implicit none ! Arguments class ( helio_pl ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Step size ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) do concurrent ( i = 1 : npl , pl % lmask ( i )) call gr_p4_pos_kick ( param , pl % xh (:, i ), pl % vb (:, i ), dt ) end do end associate return end subroutine helio_gr_p4_pl module pure subroutine helio_gr_p4_tp ( self , param , dt ) !! author: David A. Minton !! !! Position kick to test particles due to p**4 term in the post-Newtonian correction !!    Based on Saha & Tremaine (1994) Eq. 28 !! !! Adapted from David A. Minton's Swifter routine routine gr_helio_p4.f90 implicit none ! Arguments class ( helio_tp ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Step size ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) do concurrent ( i = 1 : ntp , tp % lmask ( i )) call gr_p4_pos_kick ( param , tp % xh (:, i ), tp % vb (:, i ), dt ) end do end associate return end subroutine helio_gr_p4_tp end submodule s_helio_gr","tags":"","loc":"sourcefile/helio_gr.f90.html"},{"title":"helio_kick.f90 – swiftest","text":"This file depends on sourcefile~~helio_kick.f90~~EfferentGraph sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~helio_kick.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_helio_kick Source Code helio_kick.f90 Source Code submodule ( helio_classes ) s_helio_kick use swiftest contains module subroutine helio_kick_getacch_pl ( self , system , param , t , lbeg ) !! author: David A. Minton !! !! Compute heliocentric accelerations of massive bodies !! !! Adapted from David E. Kaufmann's Swifter routine helio_kick_getacch.f90 !! Adapted from Hal Levison's Swift routine helio_kick_getacch.f implicit none ! Arguments class ( helio_pl ), intent ( inout ) :: self !! Helio massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step if ( self % nbody == 0 ) return associate ( cb => system % cb , pl => self , npl => self % nbody ) call pl % accel_int () if ( param % loblatecb ) then call pl % accel_obl ( system ) if ( lbeg ) then cb % aoblbeg = cb % aobl else cb % aoblend = cb % aobl end if if ( param % ltides ) then call pl % accel_tides ( system ) if ( lbeg ) then cb % atidebeg = cb % atide else cb % atideend = cb % atide end if end if end if if ( param % lextra_force ) call pl % accel_user ( system , param , t , lbeg ) if ( param % lgr ) call pl % accel_gr ( param ) end associate return end subroutine helio_kick_getacch_pl module subroutine helio_kick_getacch_tp ( self , system , param , t , lbeg ) !! author: David A. Minton !! !! Compute heliocentric accelerations of test particles !! !! Adapted from David E. Kaufmann's Swifter routine helio_kick_getacch_tp.f90 !! Adapted from Hal Levison's Swift routine helio_kick_getacch_tp.f implicit none ! Arguments class ( helio_tp ), intent ( inout ) :: self !! Helio test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step if ( self % nbody == 0 ) return associate ( tp => self , cb => system % cb , pl => system % pl , npl => system % pl % nbody ) system % lbeg = lbeg if ( system % lbeg ) then call tp % accel_int ( pl % Gmass (:), pl % xbeg (:,:), npl ) else call tp % accel_int ( pl % Gmass (:), pl % xend (:,:), npl ) end if if ( param % loblatecb ) call tp % accel_obl ( system ) if ( param % lextra_force ) call tp % accel_user ( system , param , t , lbeg ) if ( param % lgr ) call tp % accel_gr ( param ) end associate return end subroutine helio_kick_getacch_tp module subroutine helio_kick_vb_pl ( self , system , param , t , dt , lbeg ) !! author: David A. Minton !! !! Kick barycentric velocities of bodies !! !! Adapted from Martin Duncan and Hal Levison's Swift routine kickvh.f !! Adapted from David E. Kaufmann's Swifter routine helio_kick_vb.f90 implicit none ! Arguments class ( helio_pl ), intent ( inout ) :: self !! Swiftest generic body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Logical flag indicating whether this is the beginning of the half step or not. ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) pl % ah (:,:) = 0.0_DP call pl % accel ( system , param , t , lbeg ) if ( lbeg ) then call pl % set_beg_end ( xbeg = pl % xh ) else call pl % set_beg_end ( xend = pl % xh ) end if do concurrent ( i = 1 : npl , pl % lmask ( i )) pl % vb (:, i ) = pl % vb (:, i ) + pl % ah (:, i ) * dt end do end associate return end subroutine helio_kick_vb_pl module subroutine helio_kick_vb_tp ( self , system , param , t , dt , lbeg ) !! author: David A. Minton !! !! Kick barycentric velocities of bodies !! !! Adapted from Martin Duncan and Hal Levison's Swift routine kickvh_tp.f !! Adapted from David E. Kaufmann's Swifter routine helio_kick_vb_tp.f90 implicit none ! Arguments class ( helio_tp ), intent ( inout ) :: self !! Swiftest generic body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Logical flag indicating whether this is the beginning of the half step or not. ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) tp % ah (:,:) = 0.0_DP call tp % accel ( system , param , t , lbeg ) do concurrent ( i = 1 : ntp , tp % lmask ( i )) tp % vb (:, i ) = tp % vb (:, i ) + tp % ah (:, i ) * dt end do end associate return end subroutine helio_kick_vb_tp end submodule s_helio_kick","tags":"","loc":"sourcefile/helio_kick.f90.html"},{"title":"helio_coord.f90 – swiftest","text":"This file depends on sourcefile~~helio_coord.f90~~EfferentGraph sourcefile~helio_coord.f90 helio_coord.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~helio_coord.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_coord.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_helio_coord Source Code helio_coord.f90 Source Code submodule ( helio_classes ) s_helio_coord use swiftest contains module subroutine helio_coord_vb2vh_pl ( self , cb ) !! author: David A. Minton !! !! Convert massive bodies from barycentric to heliocentric coordinates (velocity only) !! !! Adapted from David E. Kaufmann's Swifter routine coord_vb2vh.f90 !! Adapted from Hal Levison's Swift routine coord_vb2vh.f implicit none ! Arguments class ( helio_pl ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) do i = 1 , NDIM cb % vb ( i ) = - sum ( pl % Gmass ( 1 : npl ) * pl % vb ( i , 1 : npl )) / cb % Gmass pl % vh ( i , 1 : npl ) = pl % vb ( i , 1 : npl ) - cb % vb ( i ) end do end associate return end subroutine helio_coord_vb2vh_pl module subroutine helio_coord_vb2vh_tp ( self , vbcb ) !! author: David A. Minton !! !! Convert test particles from barycentric to heliocentric coordinates (velocity only) !! !! Adapted from David E. Kaufmann's Swifter routine coord_vb2vh_tp.f90 !! Adapted from Hal Levison's Swift routine coord_vb2h_tp.f implicit none ! Arguments class ( helio_tp ), intent ( inout ) :: self !! Helio massive body object real ( DP ), dimension (:), intent ( in ) :: vbcb !! Barycentric velocity of the central body if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) where ( tp % lmask ( 1 : ntp )) tp % vh ( 1 , 1 : ntp ) = tp % vb ( 1 , 1 : ntp ) - vbcb ( 1 ) tp % vh ( 2 , 1 : ntp ) = tp % vb ( 2 , 1 : ntp ) - vbcb ( 2 ) tp % vh ( 3 , 1 : ntp ) = tp % vb ( 3 , 1 : ntp ) - vbcb ( 3 ) end where end associate return end subroutine helio_coord_vb2vh_tp module subroutine helio_coord_vh2vb_pl ( self , cb ) !! author: David A. Minton !! !! Convert massive bodies from heliocentric to barycentric coordinates (velocity only) !! !! Adapted from David E. Kaufmann's Swifter routine coord_vh2vb.f90 !! Adapted from Hal Levison's Swift routine coord_vh2b.f implicit none ! Arguments class ( helio_pl ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object ! Internals integer ( I4B ) :: i real ( DP ) :: Gmtot if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) Gmtot = cb % Gmass + sum ( pl % Gmass ( 1 : npl )) do i = 1 , NDIM cb % vb ( i ) = - sum ( pl % Gmass ( 1 : npl ) * pl % vh ( i , 1 : npl )) / Gmtot pl % vb ( i , 1 : npl ) = pl % vh ( i , 1 : npl ) + cb % vb ( i ) end do end associate return end subroutine helio_coord_vh2vb_pl module subroutine helio_coord_vh2vb_tp ( self , vbcb ) !! author: David A. Minton !! !! Convert test particles from heliocentric to barycentric coordinates (velocity only) !! !! Adapted from David E. Kaufmann's Swifter routine coord_vh2vb_tp.f90 !! Adapted from Hal Levison's Swift routine coord_vh2b_tp.f implicit none ! Arguments class ( helio_tp ), intent ( inout ) :: self !! Helio massive body object real ( DP ), dimension (:), intent ( in ) :: vbcb !! Barycentric velocity of the central body if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) where ( tp % lmask ( 1 : ntp )) tp % vb ( 1 , 1 : ntp ) = tp % vh ( 1 , 1 : ntp ) + vbcb ( 1 ) tp % vb ( 2 , 1 : ntp ) = tp % vh ( 2 , 1 : ntp ) + vbcb ( 2 ) tp % vb ( 3 , 1 : ntp ) = tp % vh ( 3 , 1 : ntp ) + vbcb ( 3 ) end where end associate return end subroutine helio_coord_vh2vb_tp end submodule s_helio_coord","tags":"","loc":"sourcefile/helio_coord.f90.html"},{"title":"helio_drift.f90 – swiftest","text":"This file depends on sourcefile~~helio_drift.f90~~EfferentGraph sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~helio_drift.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_helio_drift Source Code helio_drift.f90 Source Code submodule ( helio_classes ) s_helio_drift use swiftest contains module subroutine helio_drift_body ( self , system , param , dt ) !! author: David A. Minton !! !! Loop through bodies and call Danby drift routine on democratic heliocentric coordinates !! !! Adapted from David E. Kaufmann's Swifter routine helio_drift.f90 !! Adapted from Hal Levison's Swift routine drift.f implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize ! Internals integer ( I4B ) :: i !! Loop counter real ( DP ) :: rmag , vmag2 , energy integer ( I4B ), dimension (:), allocatable :: iflag !! Vectorized error code flag real ( DP ), dimension (:), allocatable :: dtp , mu if ( self % nbody == 0 ) return associate ( n => self % nbody ) allocate ( iflag ( n )) iflag (:) = 0 allocate ( mu ( n )) mu (:) = system % cb % Gmass call drift_all ( mu , self % xh , self % vb , self % nbody , param , dt , self % lmask , iflag ) if ( any ( iflag ( 1 : n ) /= 0 )) then where ( iflag ( 1 : n ) /= 0 ) self % status ( 1 : n ) = DISCARDED_DRIFTERR do i = 1 , n if ( iflag ( i ) /= 0 ) write ( * , * ) \" Body \" , self % id ( i ), \" lost due to error in Danby drift\" end do end if end associate return end subroutine helio_drift_body module subroutine helio_drift_pl ( self , system , param , dt ) !! author: David A. Minton !! !! Wrapper function used to call the body drift routine from a helio_pl structure implicit none ! Arguments class ( helio_pl ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize call helio_drift_body ( self , system , param , dt ) return end subroutine helio_drift_pl module subroutine helio_drift_tp ( self , system , param , dt ) !! author: David A. Minton !! !! Wrapper function used to call the body drift routine from a helio_pl structure implicit none ! Arguments class ( helio_tp ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize call helio_drift_body ( self , system , param , dt ) return end subroutine helio_drift_tp module subroutine helio_drift_linear_pl ( self , cb , dt , lbeg ) !! author: David A. Minton !! !! Perform linear drift of massive bodies due to barycentric momentum of Sun !! !! Adapted from David E. Kaufmann's Swifter routine helio_lindrift.f90 !! Adapted from Hal Levison's Swift routine helio_lindrift.f implicit none ! Arguments class ( helio_pl ), intent ( inout ) :: self !! Helio massive body object class ( helio_cb ), intent ( inout ) :: cb !! Helio central body real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Argument that determines whether or not this is the beginning or end of the step ! Internals real ( DP ), dimension ( NDIM ) :: pt !! negative barycentric velocity of the central body integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) if ( npl == 0 ) return pt ( 1 ) = sum ( pl % Gmass ( 1 : npl ) * pl % vb ( 1 , 1 : npl ), self % lmask ( 1 : npl )) pt ( 2 ) = sum ( pl % Gmass ( 1 : npl ) * pl % vb ( 2 , 1 : npl ), self % lmask ( 1 : npl )) pt ( 3 ) = sum ( pl % Gmass ( 1 : npl ) * pl % vb ( 3 , 1 : npl ), self % lmask ( 1 : npl )) pt (:) = pt (:) / cb % Gmass do concurrent ( i = 1 : npl , self % lmask ( i )) pl % xh (:, i ) = pl % xh (:, i ) + pt (:) * dt end do if ( lbeg ) then cb % ptbeg = pt (:) else cb % ptend = pt (:) end if end associate return end subroutine helio_drift_linear_pl module subroutine helio_drift_linear_tp ( self , cb , dt , lbeg ) !! author: David A. Minton !! !! Perform linear drift of test particles due to barycentric momentum of Sun !! New vectorized version included !! !! Adapted from David E. Kaufmann's Swifter routine helio_lindrift_tp.f90 !! Adapted from Hal Levison's Swift routine helio_lindrift_tp.f implicit none ! Arguments class ( helio_tp ), intent ( inout ) :: self !! Helio test particleb object class ( helio_cb ), intent ( in ) :: cb !! Helio central body real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Argument that determines whether or not this is the beginning or end of the step ! Internals real ( DP ), dimension ( NDIM ) :: pt !! negative barycentric velocity of the central body if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) if ( ntp == 0 ) return if ( lbeg ) then pt (:) = cb % ptbeg else pt (:) = cb % ptend end if where ( self % lmask ( 1 : ntp )) tp % xh ( 1 , 1 : ntp ) = tp % xh ( 1 , 1 : ntp ) + pt ( 1 ) * dt tp % xh ( 2 , 1 : ntp ) = tp % xh ( 2 , 1 : ntp ) + pt ( 2 ) * dt tp % xh ( 3 , 1 : ntp ) = tp % xh ( 3 , 1 : ntp ) + pt ( 3 ) * dt end where end associate return end subroutine helio_drift_linear_tp end submodule s_helio_drift","tags":"","loc":"sourcefile/helio_drift.f90.html"},{"title":"io.f90 – swiftest","text":"This file depends on sourcefile~~io.f90~~EfferentGraph sourcefile~io.f90 io.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~io.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_io Source Code io.f90 Source Code submodule ( swiftest_classes ) s_io use swiftest contains module subroutine io_conservation_report ( self , param , lterminal ) !! author: The Purdue Swiftest Team -  David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Reports the current state of energy, mass, and angular momentum conservation in a run implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Input colleciton of user-defined parameters logical , intent ( in ) :: lterminal !! Indicates whether to output information to the terminal screen ! Internals real ( DP ), dimension ( NDIM ) :: Ltot_now , Lorbit_now , Lspin_now real ( DP ), dimension ( NDIM ), save :: Ltot_last , Lorbit_last , Lspin_last real ( DP ), save :: ke_orbit_last , ke_spin_last , pe_last , Eorbit_last real ( DP ) :: ke_orbit_now , ke_spin_now , pe_now , Eorbit_now real ( DP ) :: Eorbit_error , Etotal_error , Ecoll_error real ( DP ) :: Mtot_now , Merror real ( DP ) :: Lmag_now , Lerror character ( len =* ), parameter :: EGYFMT = '(ES23.16,10(\",\",ES23.16,:))' ! Format code for all simulation output character ( len =* ), parameter :: EGYHEADER = '(\"t,Eorbit,Ecollisions,Lx,Ly,Lz,Mtot\")' integer ( I4B ), parameter :: EGYIU = 72 character ( len =* ), parameter :: EGYTERMFMT = '(\"  DL/L0 = \", ES12.5 & \"; DEcollisions/|E0| = \", ES12.5, & \"; D(Eorbit+Ecollisions)/|E0| = \", ES12.5, & \"; DM/M0 = \", ES12.5)' associate ( system => self , pl => self % pl , cb => self % cb , npl => self % pl % nbody , Ecollisions => self % Ecollisions , Lescape => self % Lescape , Mescape => self % Mescape , & Euntracked => self % Euntracked , Eorbit_orig => param % Eorbit_orig , Mtot_orig => param % Mtot_orig , & Ltot_orig => param % Ltot_orig (:), Lmag_orig => param % Lmag_orig , Lorbit_orig => param % Lorbit_orig (:), Lspin_orig => param % Lspin_orig (:), & lfirst => param % lfirstenergy ) if ( param % energy_out /= \"\" ) then if ( lfirst . and . ( param % out_stat /= \"OLD\" )) then open ( unit = EGYIU , file = param % energy_out , form = \"formatted\" , status = \"replace\" , action = \"write\" ) else open ( unit = EGYIU , file = param % energy_out , form = \"formatted\" , status = \"old\" , action = \"write\" , position = \"append\" ) write ( EGYIU , EGYHEADER ) end if end if call pl % h2b ( cb ) call system % get_energy_and_momentum ( param ) ke_orbit_now = system % ke_orbit ke_spin_now = system % ke_spin pe_now = system % pe Lorbit_now = system % Lorbit Lspin_now = system % Lspin Eorbit_now = ke_orbit_now + ke_spin_now + pe_now Ltot_now (:) = Lorbit_now (:) + Lspin_now (:) + Lescape (:) Mtot_now = cb % mass + sum ( pl % mass ( 1 : npl )) + system % Mescape if ( lfirst ) then Eorbit_orig = Eorbit_now Mtot_orig = Mtot_now Lorbit_orig (:) = Lorbit_now (:) Lspin_orig (:) = Lspin_now (:) Ltot_orig (:) = Ltot_now (:) Lmag_orig = norm2 ( Ltot_orig (:)) lfirst = . false . end if if ( param % energy_out /= \"\" ) then write ( EGYIU , EGYFMT ) param % t , Eorbit_now , Ecollisions , Ltot_now , Mtot_now close ( EGYIU ) end if if (. not . lfirst . and . lterminal ) then Lmag_now = norm2 ( Ltot_now ) Lerror = norm2 ( Ltot_now - Ltot_orig ) / Lmag_orig Eorbit_error = ( Eorbit_now - Eorbit_orig ) / abs ( Eorbit_orig ) Ecoll_error = Ecollisions / abs ( Eorbit_orig ) Etotal_error = ( Eorbit_now - Ecollisions - Eorbit_orig - Euntracked ) / abs ( Eorbit_orig ) Merror = ( Mtot_now - Mtot_orig ) / Mtot_orig write ( * , egytermfmt ) Lerror , Ecoll_error , Etotal_error , Merror if ( Ecoll_error > 0.0_DP ) then write ( * , * ) 'Something has gone wrong! Collisional energy should not be positive!' write ( * , * ) 'dke_orbit: ' ,( ke_orbit_now - ke_orbit_last ) / abs ( Eorbit_orig ) write ( * , * ) 'dke_spin : ' ,( ke_spin_now - ke_spin_last ) / abs ( Eorbit_orig ) write ( * , * ) 'dpe      : ' ,( pe_now - pe_last ) / abs ( Eorbit_orig ) write ( * , * ) end if end if ke_orbit_last = ke_orbit_now ke_spin_last = ke_spin_now pe_last = pe_now Eorbit_last = Eorbit_now Lorbit_last (:) = Lorbit_now (:) Lspin_last (:) = Lspin_now (:) Ltot_last (:) = Ltot_now (:) end associate return end subroutine io_conservation_report module subroutine io_dump_param ( self , param_file_name ) !! author: David A. Minton !! !! Dump integration parameters to file !! !! Adapted from David E. Kaufmann's Swifter routine io_dump_param.f90 !! Adapted from Martin Duncan's Swift routine io_dump_param.f implicit none ! Arguments class ( swiftest_parameters ), intent ( in ) :: self !! Output collection of parameters character ( len =* ), intent ( in ) :: param_file_name !! Parameter input file name (i.e. param.in) ! Internals integer ( I4B ), parameter :: LUN = 7 !! Unit number of output file integer ( I4B ) :: ierr !! Error code character ( STRMAX ) :: error_message !! Error message in UDIO procedure open ( unit = LUN , file = param_file_name , status = 'replace' , form = 'FORMATTED' , iostat = ierr ) if ( ierr /= 0 ) then write ( * , * ) 'Swiftest error.' write ( * , * ) '   Could not open dump file: ' , trim ( adjustl ( param_file_name )) call util_exit ( FAILURE ) end if !! todo: Currently this procedure does not work in user-defined derived-type input mode !!    due to compiler incompatabilities !write(LUN,'(DT)') param call self % writer ( LUN , iotype = \"none\" , v_list = [ 0 ], iostat = ierr , iomsg = error_message ) if ( ierr /= 0 ) then write ( * , * ) trim ( adjustl ( error_message )) call util_exit ( FAILURE ) end if close ( LUN ) return end subroutine io_dump_param module subroutine io_dump_swiftest ( self , param ) !! author: David A. Minton !! !! Dump massive body data to files !! !! Adapted from David E. Kaufmann's Swifter routine: io_dump_pl.f90 and io_dump_tp.f90 !! Adapted from Hal Levison's Swift routine io_dump_pl.f and io_dump_tp.f implicit none ! Arguments class ( swiftest_base ), intent ( inout ) :: self !! Swiftest base object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: ierr !! Error code integer ( I4B ), parameter :: LUN = 7 !! Unit number for dump file integer ( I4B ) :: iu = LUN character ( len = :), allocatable :: dump_file_name select type ( self ) class is ( swiftest_cb ) dump_file_name = trim ( adjustl ( param % incbfile )) class is ( swiftest_pl ) dump_file_name = trim ( adjustl ( param % inplfile )) class is ( swiftest_tp ) dump_file_name = trim ( adjustl ( param % intpfile )) end select open ( unit = iu , file = dump_file_name , form = \"UNFORMATTED\" , status = 'replace' , iostat = ierr ) if ( ierr /= 0 ) then write ( * , * ) \"Swiftest error:\" write ( * , * ) \"   Unable to open binary dump file \" // dump_file_name call util_exit ( FAILURE ) end if call self % write_frame ( iu , param ) close ( LUN ) return end subroutine io_dump_swiftest module subroutine io_dump_system ( self , param ) !! author: David A. Minton !! !! Dumps the state of the system to files in case the simulation is interrupted. !! As a safety mechanism, there are two dump files that are written in alternating order !! so that if a dump file gets corrupted during writing, the user can restart from the older one. implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals class ( swiftest_parameters ), allocatable :: dump_param !! Local parameters variable used to parameters change input file names !! to dump file-specific values without changing the user-defined values integer ( I4B ), save :: idx = 1 !! Index of current dump file. Output flips between 2 files for extra security !! in case the program halts during writing character ( len = :), allocatable :: param_file_name real ( DP ) :: deltawall , wallperstep , tfrac integer ( I8B ) :: clock_count , count_rate , count_max character ( * ), parameter :: statusfmt = '(\"Time = \", ES12.5, \"; fraction done = \", F6.3, \"; Number of active pl, tp = \", I5, \", \", I5)' character ( len =* ), parameter :: walltimefmt = '(\"      Wall time (s): \", es12.5, \"; Wall time/step in this interval (s):  \", es12.5)' logical , save :: lfirst = . true . real ( DP ), save :: start , finish if ( lfirst ) then call system_clock ( clock_count , count_rate , count_max ) start = clock_count / ( count_rate * 1.0_DP ) finish = start lfirst = . false . else allocate ( dump_param , source = param ) param_file_name = trim ( adjustl ( DUMP_PARAM_FILE ( idx ))) dump_param % incbfile = trim ( adjustl ( DUMP_CB_FILE ( idx ))) dump_param % inplfile = trim ( adjustl ( DUMP_PL_FILE ( idx ))) dump_param % intpfile = trim ( adjustl ( DUMP_TP_FILE ( idx ))) dump_param % out_form = XV dump_param % out_stat = 'APPEND' dump_param % T0 = param % t call dump_param % dump ( param_file_name ) call self % cb % dump ( dump_param ) if ( self % pl % nbody > 0 ) call self % pl % dump ( dump_param ) if ( self % tp % nbody > 0 ) call self % tp % dump ( dump_param ) idx = idx + 1 if ( idx > NDUMPFILES ) idx = 1 tfrac = ( param % t - param % t0 ) / ( param % tstop - param % t0 ) call system_clock ( clock_count , count_rate , count_max ) deltawall = clock_count / ( count_rate * 1.0_DP ) - finish wallperstep = deltawall / param % istep_dump finish = clock_count / ( count_rate * 1.0_DP ) write ( * , statusfmt ) param % t , tfrac , self % pl % nbody , self % tp % nbody write ( * , walltimefmt ) finish - start , wallperstep if ( param % lenergy ) call self % conservation_report ( param , lterminal = . true .) end if return end subroutine io_dump_system module function io_get_args ( integrator , param_file_name ) result ( ierr ) !! author: David A. Minton !! !! Reads in the name of the parameter file from command line arguments. implicit none ! Arguments integer ( I4B ) :: integrator !! Symbolic code of the requested integrator character ( len = :), allocatable :: param_file_name !! Name of the input parameters file ! Result integer ( I4B ) :: ierr !! I/O error code ! Internals character ( len = STRMAX ) :: arg1 , arg2 integer :: narg , ierr_arg1 , ierr_arg2 character ( len =* ), parameter :: linefmt = '(A)' ierr = - 1 ! Default is to fail narg = command_argument_count () ! if ( narg == 2 ) then call get_command_argument ( 1 , arg1 , status = ierr_arg1 ) call get_command_argument ( 2 , arg2 , status = ierr_arg2 ) if (( ierr_arg1 == 0 ) . and . ( ierr_arg2 == 0 )) then ierr = 0 call io_toupper ( arg1 ) select case ( arg1 ) case ( 'BS' ) integrator = BS case ( 'HELIO' ) integrator = HELIO case ( 'RA15' ) integrator = RA15 case ( 'TU4' ) integrator = TU4 case ( 'WHM' ) integrator = WHM case ( 'RMVS' ) integrator = RMVS case ( 'SYMBA' ) integrator = SYMBA case ( 'RINGMOONS' ) integrator = RINGMOONS case default integrator = UNKNOWN_INTEGRATOR write ( * , * ) trim ( adjustl ( arg1 )) // ' is not a valid integrator.' ierr = - 1 end select param_file_name = trim ( adjustl ( arg2 )) end if else call get_command_argument ( 1 , arg1 , status = ierr_arg1 ) if ( ierr_arg1 == 0 ) then if ( arg1 == '-v' . or . arg1 == '--version' ) then call util_version () else if ( arg1 == '-h' . or . arg1 == '--help' ) then call util_exit ( HELP ) end if end if end if if ( ierr /= 0 ) call util_exit ( USAGE ) return end function io_get_args module function io_get_token ( buffer , ifirst , ilast , ierr ) result ( token ) !! author: David A. Minton !! !! Retrieves a character token from an input string. Here a token is defined as any set of contiguous non-blank characters not !! beginning with or containing \"!\". If \"!\" is present, any remaining part of the buffer including the \"!\" is ignored !! !! Adapted from David E. Kaufmann's Swifter routine io_get_token.f90 implicit none ! Arguments character ( len =* ), intent ( in ) :: buffer !! Input string buffer integer ( I4B ), intent ( inout ) :: ifirst !! Index of the buffer at which to start the search for a token integer ( I4B ), intent ( out ) :: ilast !! Index of the buffer at the end of the returned token integer ( I4B ), intent ( out ) :: ierr !! Error code ! Result character ( len = :), allocatable :: token !! Returned token string ! Internals integer ( I4B ) :: i , ilength ilength = len ( buffer ) if ( ifirst > ilength ) then ilast = ifirst ierr = - 1 !! Bad input token = '' return end if do i = ifirst , ilength if ( buffer ( i : i ) /= ' ' ) exit end do if (( i > ilength ) . or . ( buffer ( i : i ) == '!' )) then ifirst = i ilast = i ierr = - 2 !! No valid token token = '' return end if ifirst = i do i = ifirst , ilength if (( buffer ( i : i ) == ' ' ) . or . ( buffer ( i : i ) == '!' )) exit end do ilast = i - 1 ierr = 0 token = buffer ( ifirst : ilast ) return end function io_get_token module subroutine io_param_reader ( self , unit , iotype , v_list , iostat , iomsg ) !! author: The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Read in parameters for the integration !! Currently this procedure does not work in user-defined derived-type input mode !!    e.g. read(unit,'(DT)') param !! as the newline characters are ignored in the input file when compiled in ifort. !! !! Adapted from David E. Kaufmann's Swifter routine io_init_param.f90 !! Adapted from Martin Duncan's Swift routine io_init_param.f implicit none ! Arguments class ( swiftest_parameters ), intent ( inout ) :: self !! Collection of parameters integer , intent ( in ) :: unit !! File unit number character ( len =* ), intent ( in ) :: iotype !! Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. !!    If you do not include a char-literal-constant, the iotype argument contains only DT. integer , intent ( in ) :: v_list (:) !! The first element passes the integrator code to the reader integer , intent ( out ) :: iostat !! IO status code character ( len =* ), intent ( inout ) :: iomsg !! Message to pass if iostat /= 0 ! Internals logical :: t0_set = . false . !! Is the initial time set in the input file? logical :: tstop_set = . false . !! Is the final time set in the input file? logical :: dt_set = . false . !! Is the step size set in the input file? integer ( I4B ) :: ilength , ifirst , ilast , i !! Variables used to parse input file character ( STRMAX ) :: line !! Line of the input file character ( len = :), allocatable :: line_trim , param_name , param_value !! Strings used to parse the param file character ( * ), parameter :: linefmt = '(A)' !! Format code for simple text string ! Parse the file line by line, extracting tokens then matching them up with known parameters if possible associate ( param => self ) do read ( unit = unit , fmt = linefmt , iostat = iostat , end = 1 ) line line_trim = trim ( adjustl ( line )) ilength = len ( line_trim ) if (( ilength /= 0 )) then ifirst = 1 ! Read the pair of tokens. The first one is the parameter name, the second is the value. param_name = io_get_token ( line_trim , ifirst , ilast , iostat ) if ( param_name == '' ) cycle ! No parameter name (usually because this line is commented out) call io_toupper ( param_name ) ifirst = ilast + 1 param_value = io_get_token ( line_trim , ifirst , ilast , iostat ) select case ( param_name ) case ( \"T0\" ) read ( param_value , * ) param % t0 t0_set = . true . case ( \"TSTOP\" ) read ( param_value , * ) param % tstop tstop_set = . true . case ( \"DT\" ) read ( param_value , * ) param % dt dt_set = . true . case ( \"CB_IN\" ) param % incbfile = param_value case ( \"PL_IN\" ) param % inplfile = param_value case ( \"TP_IN\" ) param % intpfile = param_value case ( \"IN_TYPE\" ) call io_toupper ( param_value ) param % in_type = param_value case ( \"ISTEP_OUT\" ) read ( param_value , * ) param % istep_out case ( \"BIN_OUT\" ) param % outfile = param_value case ( \"OUT_TYPE\" ) call io_toupper ( param_value ) param % out_type = param_value case ( \"OUT_FORM\" ) call io_toupper ( param_value ) param % out_form = param_value case ( \"OUT_STAT\" ) call io_toupper ( param_value ) param % out_stat = param_value case ( \"ISTEP_DUMP\" ) read ( param_value , * ) param % istep_dump case ( \"CHK_CLOSE\" ) call io_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % lclose = . true . case ( \"CHK_RMIN\" ) read ( param_value , * ) param % rmin case ( \"CHK_RMAX\" ) read ( param_value , * ) param % rmax case ( \"CHK_EJECT\" ) read ( param_value , * ) param % rmaxu case ( \"CHK_QMIN\" ) read ( param_value , * ) param % qmin case ( \"CHK_QMIN_COORD\" ) call io_toupper ( param_value ) param % qmin_coord = param_value case ( \"CHK_QMIN_RANGE\" ) read ( param_value , * ) param % qmin_alo ifirst = ilast + 1 param_value = io_get_token ( line , ifirst , ilast , iostat ) read ( param_value , * ) param % qmin_ahi case ( \"ENC_OUT\" ) param % enc_out = param_value case ( \"DISCARD_OUT\" ) param % discard_out = param_value case ( \"ENERGY_OUT\" ) param % energy_out = param_value case ( \"EXTRA_FORCE\" ) call io_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % lextra_force = . true . case ( \"BIG_DISCARD\" ) call io_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % lbig_discard = . true . case ( \"RHILL_PRESENT\" ) call io_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % lrhill_present = . true . case ( \"MU2KG\" ) read ( param_value , * ) param % MU2KG case ( \"TU2S\" ) read ( param_value , * ) param % TU2S case ( \"DU2M\" ) read ( param_value , * ) param % DU2M case ( \"ENERGY\" ) call io_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % lenergy = . true . case ( \"GR\" ) call io_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % lgr = . true . case ( \"ROTATION\" ) call io_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % lrotation = . true . case ( \"TIDES\" ) call io_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % ltides = . true . case ( \"FIRSTKICK\" ) call io_toupper ( param_value ) if ( param_value == \"NO\" . or . param_value == 'F' ) param % lfirstkick = . false . case ( \"FIRSTENERGY\" ) call io_toupper ( param_value ) if ( param_value == \"NO\" . or . param_value == 'F' ) param % lfirstenergy = . false . case ( \"EORBIT_ORIG\" ) read ( param_value , * ) param % Eorbit_orig case ( \"MTOT_ORIG\" ) read ( param_value , * ) param % Mtot_orig case ( \"LTOT_ORIG\" ) read ( param_value , * ) param % Ltot_orig ( 1 ) do i = 2 , NDIM ifirst = ilast + 1 param_value = io_get_token ( line , ifirst , ilast , iostat ) read ( param_value , * ) param % Ltot_orig ( i ) end do param % Lmag_orig = norm2 ( param % Ltot_orig (:)) case ( \"LORBIT_ORIG\" ) read ( param_value , * ) param % Lorbit_orig ( 1 ) do i = 2 , NDIM ifirst = ilast + 1 param_value = io_get_token ( line , ifirst , ilast , iostat ) read ( param_value , * ) param % Lorbit_orig ( i ) end do case ( \"LSPIN_ORIG\" ) read ( param_value , * ) param % Lspin_orig ( 1 ) do i = 2 , NDIM ifirst = ilast + 1 param_value = io_get_token ( line , ifirst , ilast , iostat ) read ( param_value , * ) param % Lspin_orig ( i ) end do case ( \"LESCAPE\" ) read ( param_value , * ) param % Lescape ( 1 ) do i = 2 , NDIM ifirst = ilast + 1 param_value = io_get_token ( line , ifirst , ilast , iostat ) read ( param_value , * ) param % Lescape ( i ) end do case ( \"MESCAPE\" ) read ( param_value , * ) param % Mescape case ( \"ECOLLISIONS\" ) read ( param_value , * ) param % Ecollisions case ( \"EUNTRACKED\" ) read ( param_value , * ) param % Euntracked case ( \"NPLMAX\" , \"NTPMAX\" , \"GMTINY\" , \"PARTICLE_OUT\" , \"FRAGMENTATION\" , \"SEED\" , \"YARKOVSKY\" , \"YORP\" ) ! Ignore SyMBA-specific, not-yet-implemented, or obsolete input parameters case default write ( iomsg , * ) \"Unknown parameter -> \" , param_name iostat = - 1 return end select end if end do 1 continue iostat = 0 !! Do basic sanity checks on the input values if ((. not . t0_set ) . or . (. not . tstop_set ) . or . (. not . dt_set )) then write ( iomsg , * ) 'Valid simulation time not set' iostat = - 1 return end if if ( param % dt <= 0.0_DP ) then write ( iomsg , * ) 'Invalid timestep: ' iostat = - 1 return end if if ( param % inplfile == \"\" ) then write ( iomsg , * ) 'No valid massive body file in input file' iostat = - 1 return end if if (( param % in_type /= REAL8_TYPE ) . and . ( param % in_type /= \"ASCII\" )) then write ( iomsg , * ) 'Invalid input file type:' , trim ( adjustl ( param % in_type )) iostat = - 1 return end if if (( param % istep_out <= 0 ) . and . ( param % istep_dump <= 0 )) then write ( iomsg , * ) 'Invalid istep' iostat = - 1 return end if if (( param % istep_out > 0 ) . and . ( param % outfile == \"\" )) then write ( iomsg , * ) 'Invalid outfile' iostat = - 1 return end if param % lrestart = ( param % out_stat == \"APPEND\" ) if ( param % outfile /= \"\" ) then if (( param % out_type /= REAL4_TYPE ) . and . ( param % out_type /= REAL8_TYPE ) . and . & ( param % out_type /= SWIFTER_REAL4_TYPE ) . and . ( param % out_type /= SWIFTER_REAL8_TYPE )) then write ( iomsg , * ) 'Invalid out_type: ' , trim ( adjustl ( param % out_type )) iostat = - 1 return end if if (( param % out_form /= \"EL\" ) . and . ( param % out_form /= \"XV\" )) then write ( iomsg , * ) 'Invalid out_form: ' , trim ( adjustl ( param % out_form )) iostat = - 1 return end if if (( param % out_stat /= \"NEW\" ) . and . ( param % out_stat /= \"REPLACE\" ) . and . ( param % out_stat /= \"APPEND\" ) . and . ( param % out_stat /= \"UNKNOWN\" )) then write ( iomsg , * ) 'Invalid out_stat: ' , trim ( adjustl ( param % out_stat )) iostat = - 1 return end if end if if ( param % qmin > 0.0_DP ) then if (( param % qmin_coord /= \"HELIO\" ) . and . ( param % qmin_coord /= \"BARY\" )) then write ( iomsg , * ) 'Invalid qmin_coord: ' , trim ( adjustl ( param % qmin_coord )) iostat = - 1 return end if if (( param % qmin_alo <= 0.0_DP ) . or . ( param % qmin_ahi <= 0.0_DP )) then write ( iomsg , * ) 'Invalid qmin vals' iostat = - 1 return end if end if if ( param % ltides . and . . not . param % lrotation ) then write ( iomsg , * ) 'Tides require rotation to be turned on' iostat = - 1 return end if write ( * , * ) \"T0             = \" , param % t0 write ( * , * ) \"TSTOP          = \" , param % tstop write ( * , * ) \"DT             = \" , param % dt write ( * , * ) \"CB_IN          = \" , trim ( adjustl ( param % incbfile )) write ( * , * ) \"PL_IN          = \" , trim ( adjustl ( param % inplfile )) write ( * , * ) \"TP_IN          = \" , trim ( adjustl ( param % intpfile )) write ( * , * ) \"IN_TYPE        = \" , trim ( adjustl ( param % in_type )) write ( * , * ) \"ISTEP_OUT      = \" , param % istep_out write ( * , * ) \"BIN_OUT        = \" , trim ( adjustl ( param % outfile )) write ( * , * ) \"OUT_TYPE       = \" , trim ( adjustl ( param % out_type )) write ( * , * ) \"OUT_FORM       = \" , trim ( adjustl ( param % out_form )) write ( * , * ) \"OUT_STAT       = \" , trim ( adjustl ( param % out_stat )) write ( * , * ) \"ISTEP_DUMP     = \" , param % istep_dump write ( * , * ) \"CHK_CLOSE      = \" , param % lclose write ( * , * ) \"CHK_RMIN       = \" , param % rmin write ( * , * ) \"CHK_RMAX       = \" , param % rmax write ( * , * ) \"CHK_EJECT      = \" , param % rmaxu write ( * , * ) \"CHK_QMIN       = \" , param % qmin write ( * , * ) \"CHK_QMIN_COORD = \" , trim ( adjustl ( param % qmin_coord )) write ( * , * ) \"CHK_QMIN_RANGE = \" , param % qmin_alo , param % qmin_ahi write ( * , * ) \"EXTRA_FORCE    = \" , param % lextra_force write ( * , * ) \"RHILL_PRESENT  = \" , param % lrhill_present write ( * , * ) \"ROTATION      = \" , param % lrotation write ( * , * ) \"TIDES         = \" , param % ltides write ( * , * ) \"ENERGY         = \" , param % lenergy write ( * , * ) \"MU2KG          = \" , param % MU2KG write ( * , * ) \"TU2S           = \" , param % TU2S write ( * , * ) \"DU2M           = \" , param % DU2M if ( trim ( adjustl ( param % enc_out )) /= \"\" ) then write ( * , * ) \"ENC_OUT        = \" , trim ( adjustl ( param % enc_out )) else write ( * , * ) \"! ENC_OUT not set: Encounters will not be recorded to file\" end if if ( trim ( adjustl ( param % discard_out )) /= \"\" ) then write ( * , * ) \"DISCARD_OUT    = \" , trim ( adjustl ( param % discard_out )) write ( * , * ) \"BIG_DISCARD    = \" , param % lbig_discard else write ( * , * ) \"! DISCARD_OUT not set: Discards will not be recorded to file\" write ( * , * ) \"! BIG_DISCARD    = \" , param % lbig_discard end if if (( param % MU2KG < 0.0_DP ) . or . ( param % TU2S < 0.0_DP ) . or . ( param % DU2M < 0.0_DP )) then write ( iomsg , * ) 'Invalid unit conversion factor' iostat = - 1 return end if ! Calculate the G for the system units param % GU = GC / ( param % DU2M ** 3 / ( param % MU2KG * param % TU2S ** 2 )) ! Calculate the inverse speed of light in the system units param % inv_c2 = einsteinC * param % TU2S / param % DU2M param % inv_c2 = ( param % inv_c2 ) ** ( - 2 ) associate ( integrator => v_list ( 1 )) if ( integrator == RMVS ) then if (. not . param % lclose ) then write ( iomsg , * ) 'This integrator requires CHK_CLOSE to be enabled.' iostat = - 1 return end if end if ! Determine if the GR flag is set correctly for this integrator select case ( integrator ) case ( WHM , RMVS , HELIO , SYMBA ) write ( * , * ) \"GR             = \" , param % lgr case default if ( param % lgr ) write ( iomsg , * ) 'GR is not yet implemented for this integrator. This parameter will be ignored.' param % lgr = . false . end select end associate iostat = 0 end associate return end subroutine io_param_reader module subroutine io_param_writer ( self , unit , iotype , v_list , iostat , iomsg ) !! author: David A. Minton !! !! Dump integration parameters to file !! !! Adapted from David E. Kaufmann's Swifter routine io_dump_param.f90 !! Adapted from Martin Duncan's Swift routine io_dump_param.f implicit none ! Arguments class ( swiftest_parameters ), intent ( in ) :: self !! Collection of parameters integer , intent ( in ) :: unit !! File unit number character ( len =* ), intent ( in ) :: iotype !! Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. !!    If you do not include a char-literal-constant, the iotype argument contains only DT. integer , intent ( in ) :: v_list (:) !! Not used in this procedure integer , intent ( out ) :: iostat !! IO status code character ( len =* ), intent ( inout ) :: iomsg !! Message to pass if iostat /= 0 ! Internals character ( * ), parameter :: Ifmt = '(I0)' !! Format label for integer values character ( * ), parameter :: Rfmt = '(ES25.17)' !! Format label for real values character ( * ), parameter :: Rarrfmt = '(3(ES25.17,1X))' !! Format label for real values character ( * ), parameter :: Lfmt = '(L1)' !! Format label for logical values character ( len =* ), parameter :: Afmt = '(A25,1X,64(:,A25,1X))' character ( 256 ) :: param_name , param_value type character_array character ( 25 ) :: value end type character_array type ( character_array ), dimension (:), allocatable :: param_array integer ( I4B ) :: i associate ( param => self ) write ( param_name , Afmt ) \"T0\" ; write ( param_value , Rfmt ) param % t0 ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"TSTOP\" ; write ( param_value , Rfmt ) param % tstop ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"DT\" ; write ( param_value , Rfmt ) param % dt ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"PL_IN\" ; write ( param_value , Afmt ) trim ( adjustl ( param % inplfile )); write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"TP_in\" ; write ( param_value , Afmt ) trim ( adjustl ( param % intpfile )); write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"IN_TYPE\" ; write ( param_value , Afmt ) trim ( adjustl ( param % in_type )); write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) if ( param % istep_out > 0 ) then write ( param_name , Afmt ) \"ISTEP_OUT\" ; write ( param_value , Ifmt ) param % istep_out ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"BIN_OUT\" ; write ( param_value , Afmt ) trim ( adjustl ( param % outfile )); write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"OUT_TYPE\" ; write ( param_value , Afmt ) trim ( adjustl ( param % out_type )); write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"OUT_FORM\" ; write ( param_value , Afmt ) trim ( adjustl ( param % out_form )); write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"OUT_STAT\" ; write ( param_value , Afmt ) \"APPEND\" ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) end if write ( param_name , Afmt ) \"ENC_OUT\" ; write ( param_value , Afmt ) trim ( adjustl ( param % enc_out )); write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) if ( param % istep_dump > 0 ) then write ( param_name , Afmt ) \"ISTEP_DUMP\" ; write ( param_value , Ifmt ) param % istep_dump ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) end if write ( param_name , Afmt ) \"CHK_RMIN\" ; write ( param_value , Rfmt ) param % rmin ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"CHK_RMAX\" ; write ( param_value , Rfmt ) param % rmax ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"CHK_EJECT\" ; write ( param_value , Rfmt ) param % rmaxu ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"CHK_QMIN\" ; write ( param_value , Rfmt ) param % qmin ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) if ( param % qmin >= 0.0_DP ) then write ( param_name , Afmt ) \"CHK_QMIN_COORD\" ; write ( param_value , Afmt ) trim ( adjustl ( param % qmin_coord )); write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) allocate ( param_array ( 2 )) write ( param_array ( 1 )% value , Rfmt ) param % qmin_alo write ( param_array ( 2 )% value , Rfmt ) param % qmin_ahi write ( param_name , Afmt ) \"CHK_QMIN_RANGE\" ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_array ( 1 )% value ), adjustl ( param_array ( 2 )% value ) end if write ( param_name , Afmt ) \"MU2KG\" ; write ( param_value , Rfmt ) param % MU2KG ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"TU2S\" ; write ( param_value , Rfmt ) param % TU2S ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"DU2M\" ; write ( param_value , Rfmt ) param % DU2M ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"RHILL_PRESENT\" ; write ( param_value , Lfmt ) param % lrhill_present ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"EXTRA_FORCE\" ; write ( param_value , Lfmt ) param % lextra_force ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"BIG_DISCARD\" ; write ( param_value , Lfmt ) param % lbig_discard ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"CHK_CLOSE\" ; write ( param_value , Lfmt ) param % lclose ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"ENERGY\" ; write ( param_value , Lfmt ) param % lenergy ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"GR\" ; write ( param_value , Lfmt ) param % lgr ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"ROTATION\" ; write ( param_value , Lfmt ) param % lrotation ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"TIDES\" ; write ( param_value , Lfmt ) param % ltides ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) if ( param % lenergy ) then write ( param_name , Afmt ) \"FIRSTENERGY\" ; write ( param_value , Lfmt ) param % lfirstenergy ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"EORBIT_ORIG\" ; write ( param_value , Rfmt ) param % Eorbit_orig ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"MTOT_ORIG\" ; write ( param_value , Rfmt ) param % Mtot_orig ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( unit , '(\"LTOT_ORIG  \",3(1X,ES25.17))' ) param % Ltot_orig (:) write ( unit , '(\"LORBIT_ORIG\",3(1X,ES25.17))' ) param % Lorbit_orig (:) write ( unit , '(\"LSPIN_ORIG \",3(1X,ES25.17))' ) param % Lspin_orig (:) write ( unit , '(\"LESCAPE \",3(1X,ES25.17))' ) param % Lescape (:) write ( param_name , Afmt ) \"MESCAPE\" ; write ( param_value , Rfmt ) param % Mescape ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"ECOLLISIONS\" ; write ( param_value , Rfmt ) param % Ecollisions ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"EUNTRACKED\" ; write ( param_value , Rfmt ) param % Euntracked ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) end if write ( param_name , Afmt ) \"FIRSTKICK\" ; write ( param_value , Lfmt ) param % lfirstkick ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) iostat = 0 iomsg = \"UDIO not implemented\" end associate return end subroutine io_param_writer module subroutine io_read_body_in ( self , param ) !! author: The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Read in either test particle or massive body data !! !! Adapted from David E. Kaufmann's Swifter routine swiftest_init_pl.f90 and swiftest_init_tp.f90 !! Adapted from Martin Duncan's Swift routine swiftest_init_pl.f and swiftest_init_tp.f implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals integer ( I4B ), parameter :: LUN = 7 !! Unit number of input file integer ( I4B ) :: iu = LUN integer ( I4B ) :: i , ierr , nbody logical :: is_ascii , is_pl character ( len = :), allocatable :: infile real ( DP ) :: t real ( QP ) :: val ! Select the appropriate polymorphic class (test particle or massive body) select type ( self ) class is ( swiftest_pl ) infile = param % inplfile is_pl = . true . class is ( swiftest_tp ) infile = param % intpfile is_pl = . false . end select ierr = 0 is_ascii = ( param % in_type == 'ASCII' ) select case ( param % in_type ) case ( ASCII_TYPE ) open ( unit = iu , file = infile , status = 'old' , form = 'FORMATTED' , iostat = ierr ) read ( iu , * , iostat = ierr ) nbody call self % setup ( nbody , param ) if ( nbody > 0 ) then do i = 1 , nbody select type ( self ) class is ( swiftest_pl ) if ( param % lrhill_present ) then read ( iu , * , iostat = ierr , err = 100 ) self % id ( i ), val , self % rhill ( i ) else read ( iu , * , iostat = ierr , err = 100 ) self % id ( i ), val end if self % Gmass ( i ) = real ( val , kind = DP ) self % mass ( i ) = real ( val / param % GU , kind = DP ) if ( param % lclose ) read ( iu , * , iostat = ierr , err = 100 ) self % radius ( i ) class is ( swiftest_tp ) read ( iu , * , iostat = ierr , err = 100 ) self % id ( i ) end select read ( iu , * , iostat = ierr , err = 100 ) self % xh ( 1 , i ), self % xh ( 2 , i ), self % xh ( 3 , i ) read ( iu , * , iostat = ierr , err = 100 ) self % vh ( 1 , i ), self % vh ( 2 , i ), self % vh ( 3 , i ) select type ( self ) class is ( swiftest_pl ) if ( param % lrotation ) then read ( iu , * , iostat = ierr , err = 100 ) self % Ip ( 1 , i ), self % Ip ( 2 , i ), self % Ip ( 3 , i ) read ( iu , * , iostat = ierr , err = 100 ) self % rot ( 1 , i ), self % rot ( 2 , i ), self % rot ( 3 , i ) end if if ( param % ltides ) then read ( iu , * , iostat = ierr , err = 100 ) self % k2 ( i ) read ( iu , * , iostat = ierr , err = 100 ) self % Q ( i ) end if end select self % status ( i ) = ACTIVE self % lmask ( i ) = . true . end do end if case ( REAL4_TYPE , REAL8_TYPE ) !, SWIFTER_REAL4_TYPE, SWIFTER_REAL8_TYPE) open ( unit = iu , file = infile , status = 'old' , form = 'UNFORMATTED' , iostat = ierr ) read ( iu , iostat = ierr , err = 100 ) nbody call self % setup ( nbody , param ) if ( nbody > 0 ) then call self % read_frame ( iu , param , XV , ierr ) self % status (:) = ACTIVE self % lmask (:) = . true . end if case default write ( * , * ) trim ( adjustl ( param % in_type )) // ' is an unrecognized file type' ierr = - 1 end select close ( iu ) 100 if ( ierr /= 0 ) then write ( * , * ) 'Error reading in initial conditions from ' , trim ( adjustl ( infile )) call util_exit ( FAILURE ) end if return end subroutine io_read_body_in module subroutine io_read_cb_in ( self , param ) !! author: David A. Minton !! !! Reads in central body data !! !! Adapted from David E. Kaufmann's Swifter routine swiftest_init_pl.f90 !! Adapted from Martin Duncan's Swift routine swiftest_init_pl.f implicit none ! Arguments class ( swiftest_cb ), intent ( inout ) :: self class ( swiftest_parameters ), intent ( inout ) :: param ! Internals integer ( I4B ), parameter :: LUN = 7 !! Unit number of input file integer ( I4B ) :: iu = LUN integer ( I4B ) :: ierr logical :: is_ascii real ( DP ) :: t real ( QP ) :: val ierr = 0 is_ascii = ( param % in_type == 'ASCII' ) if ( is_ascii ) then open ( unit = iu , file = param % incbfile , status = 'old' , form = 'FORMATTED' , iostat = ierr ) read ( iu , * , iostat = ierr ) self % id read ( iu , * , iostat = ierr ) val self % Gmass = real ( val , kind = DP ) self % mass = real ( val / param % GU , kind = DP ) read ( iu , * , iostat = ierr ) self % radius read ( iu , * , iostat = ierr ) self % j2rp2 read ( iu , * , iostat = ierr ) self % j4rp4 if ( param % lrotation ) then read ( iu , * , iostat = ierr ) self % Ip ( 1 ), self % Ip ( 2 ), self % Ip ( 3 ) read ( iu , * , iostat = ierr ) self % rot ( 1 ), self % rot ( 2 ), self % rot ( 3 ) end if else open ( unit = iu , file = param % incbfile , status = 'old' , form = 'UNFORMATTED' , iostat = ierr ) call self % read_frame ( iu , param , XV , ierr ) end if close ( iu ) if ( ierr /= 0 ) then write ( * , * ) 'Error opening massive body initial conditions file ' , trim ( adjustl ( param % incbfile )) call util_exit ( FAILURE ) end if if ( self % j2rp2 /= 0.0_DP ) param % loblatecb = . true . return end subroutine io_read_cb_in function io_read_encounter ( t , name1 , name2 , mass1 , mass2 , radius1 , radius2 , & xh1 , xh2 , vh1 , vh2 , enc_out , out_type ) result ( ierr ) !! author: David A. Minton !! !! Read close encounter data from input binary files !!     Other than time t, there is no direct file input from this function !!     Function returns read error status (0 = OK, nonzero = ERROR) !! Adapted from David E. Kaufmann's Swifter routine: io_read_encounter.f90 implicit none ! Arguments integer ( I4B ), intent ( out ) :: name1 , name2 real ( DP ), intent ( out ) :: t , mass1 , mass2 , radius1 , radius2 real ( DP ), dimension (:), intent ( out ) :: xh1 , xh2 , vh1 , vh2 character ( * ), intent ( in ) :: enc_out , out_type ! Result integer ( I4B ) :: ierr ! Internals logical , save :: lfirst = . true . integer ( I4B ), parameter :: lun = 30 integer ( I4B ), save :: iu = lun if ( lfirst ) then open ( unit = iu , file = enc_out , status = 'OLD' , form = 'UNFORMATTED' , iostat = ierr ) if ( ierr /= 0 ) then write ( * , * ) \"Swiftest Error:\" write ( * , * ) \"   unable to open binary encounter file\" call util_exit ( FAILURE ) end if lfirst = . false . end if read ( iu , iostat = ierr ) t if ( ierr /= 0 ) then close ( unit = iu , iostat = ierr ) return end if read ( iu , iostat = ierr ) name1 , xh1 ( 1 ), xh1 ( 2 ), xh1 ( 3 ), vh1 ( 1 ), vh1 ( 2 ), vh1 ( 3 ), mass1 , radius1 if ( ierr /= 0 ) then close ( unit = iu , iostat = ierr ) return end if read ( iu , iostat = ierr ) name2 , xh2 ( 2 ), xh2 ( 2 ), xh2 ( 3 ), vh2 ( 2 ), vh2 ( 2 ), vh2 ( 3 ), mass2 , radius2 if ( ierr /= 0 ) then close ( unit = iu , iostat = ierr ) return end if return end function io_read_encounter module subroutine io_read_frame_body ( self , iu , param , form , ierr ) !! author: David A. Minton !! !! Reads a frame of output of either test particle or massive body data from a binary output file !! !! Adapted from David E. Kaufmann's Swifter routine  io_read_frame.f90 !! Adapted from Hal Levison's Swift routine io_read_frame.F implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest particle object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters character ( * ), intent ( in ) :: form !! Input format code (\"XV\" or \"EL\") integer ( I4B ), intent ( out ) :: ierr !! Error code associate ( n => self % nbody ) read ( iu , iostat = ierr , err = 100 ) self % id (:) !read(iu, iostat=ierr, err=100) self%name(1:n) select case ( form ) case ( EL ) if (. not . allocated ( self % a )) allocate ( self % a ( n )) if (. not . allocated ( self % e )) allocate ( self % e ( n )) if (. not . allocated ( self % inc )) allocate ( self % inc ( n )) if (. not . allocated ( self % capom )) allocate ( self % capom ( n )) if (. not . allocated ( self % omega )) allocate ( self % omega ( n )) if (. not . allocated ( self % capm )) allocate ( self % capm ( n )) read ( iu , iostat = ierr , err = 100 ) self % a (:) read ( iu , iostat = ierr , err = 100 ) self % e (:) read ( iu , iostat = ierr , err = 100 ) self % inc (:) read ( iu , iostat = ierr , err = 100 ) self % capom (:) read ( iu , iostat = ierr , err = 100 ) self % omega (:) read ( iu , iostat = ierr , err = 100 ) self % capm (:) case ( XV ) read ( iu , iostat = ierr , err = 100 ) self % xh ( 1 , :) read ( iu , iostat = ierr , err = 100 ) self % xh ( 2 , :) read ( iu , iostat = ierr , err = 100 ) self % xh ( 3 , :) read ( iu , iostat = ierr , err = 100 ) self % vh ( 1 , :) read ( iu , iostat = ierr , err = 100 ) self % vh ( 2 , :) read ( iu , iostat = ierr , err = 100 ) self % vh ( 3 , :) end select select type ( pl => self ) class is ( swiftest_pl ) ! Additional output if the passed polymorphic object is a massive body read ( iu , iostat = ierr , err = 100 ) pl % Gmass (:) pl % mass (:) = pl % Gmass (:) / param % GU if ( param % lrhill_present ) read ( iu , iostat = ierr , err = 100 ) pl % rhill (:) if ( param % lclose ) read ( iu , iostat = ierr , err = 100 ) pl % radius (:) if ( param % lrotation ) then read ( iu , iostat = ierr , err = 100 ) pl % rot ( 1 , :) read ( iu , iostat = ierr , err = 100 ) pl % rot ( 2 , :) read ( iu , iostat = ierr , err = 100 ) pl % rot ( 3 , :) read ( iu , iostat = ierr , err = 100 ) pl % Ip ( 1 , :) read ( iu , iostat = ierr , err = 100 ) pl % Ip ( 2 , :) read ( iu , iostat = ierr , err = 100 ) pl % Ip ( 3 , :) end if if ( param % ltides ) then read ( iu , iostat = ierr , err = 100 ) pl % k2 ( 1 : n ) read ( iu , iostat = ierr , err = 100 ) pl % Q ( 1 : n ) end if end select end associate 100 if ( ierr /= 0 ) then write ( * , * ) 'Error reading Swiftest body data' call util_exit ( FAILURE ) end if return end subroutine io_read_frame_body module subroutine io_read_frame_cb ( self , iu , param , form , ierr ) !! author: David A. Minton !! !! Reads a frame of output of central body data to the binary output file !! !! Adapted from David E. Kaufmann's Swifter routine  io_read_frame.f90 !! Adapted from Hal Levison's Swift routine io_read_frame.F implicit none ! Arguments class ( swiftest_cb ), intent ( inout ) :: self !! Swiftest central body object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters character ( * ), intent ( in ) :: form !! Input format code (\"XV\" or \"EL\") integer ( I4B ), intent ( out ) :: ierr !! Error cod read ( iu , iostat = ierr , err = 100 ) self % id !read(iu, iostat=ierr, err=100) self%name read ( iu , iostat = ierr , err = 100 ) self % Gmass self % mass = self % Gmass / param % GU read ( iu , iostat = ierr , err = 100 ) self % radius read ( iu , iostat = ierr , err = 100 ) self % j2rp2 read ( iu , iostat = ierr , err = 100 ) self % j4rp4 if ( param % lrotation ) then read ( iu , iostat = ierr , err = 100 ) self % Ip (:) read ( iu , iostat = ierr , err = 100 ) self % rot (:) end if if ( param % ltides ) then read ( iu , iostat = ierr , err = 100 ) self % k2 read ( iu , iostat = ierr , err = 100 ) self % Q end if 100 if ( ierr /= 0 ) then write ( * , * ) 'Error reading central body data' call util_exit ( FAILURE ) end if return end subroutine io_read_frame_cb module subroutine io_read_frame_system ( self , iu , param , form , ierr ) !! author: The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Read a frame (header plus records for each massive body and active test particle) from a output binary file implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters character ( * ), intent ( in ) :: form !! Input format code (\"XV\" or \"EL\") integer ( I4B ), intent ( out ) :: ierr !! Error code ! Internals logical , save :: lfirst = . true . iu = BINUNIT if ( lfirst ) then open ( unit = iu , file = param % outfile , status = 'OLD' , form = 'UNFORMATTED' , iostat = ierr ) lfirst = . false . if ( ierr /= 0 ) then write ( * , * ) \"Swiftest error:\" write ( * , * ) \"   Binary output file already exists or cannot be accessed\" return end if end if ierr = io_read_hdr ( iu , param % t , self % pl % nbody , self % tp % nbody , param % out_form , param % out_type ) if ( ierr /= 0 ) then write ( * , * ) \"Swiftest error:\" write ( * , * ) \"   Binary output file already exists or cannot be accessed\" return end if call self % cb % read_frame ( iu , param , form , ierr ) if ( ierr /= 0 ) return call self % pl % read_frame ( iu , param , form , ierr ) if ( ierr /= 0 ) return call self % tp % read_frame ( iu , param , form , ierr ) return end subroutine io_read_frame_system function io_read_hdr ( iu , t , npl , ntp , out_form , out_type ) result ( ierr ) !! author: David A. Minton !! !! Read frame header from input binary files !!     Function returns read error status (0 = OK, nonzero = ERROR) !! Adapted from David E. Kaufmann's Swifter routine: io_read_hdr.f90 !! Adapted from Hal Levison's Swift routine io_read_hdr.f implicit none ! Arguments integer ( I4B ), intent ( in ) :: iu integer ( I4B ), intent ( out ) :: npl , ntp character ( * ), intent ( out ) :: out_form real ( DP ), intent ( out ) :: t character ( * ), intent ( in ) :: out_type ! Result integer ( I4B ) :: ierr ! Internals real ( SP ) :: ttmp select case ( out_type ) case ( REAL4_TYPE , SWIFTER_REAL4_TYPE ) read ( iu , iostat = ierr ) ttmp , npl , ntp , out_form if ( ierr /= 0 ) return t = ttmp case ( REAL8_TYPE , SWIFTER_REAL8_TYPE ) read ( iu , iostat = ierr ) t read ( iu , iostat = ierr ) npl read ( iu , iostat = ierr ) ntp read ( iu , iostat = ierr ) out_form case default write ( * , * ) trim ( adjustl ( out_type )) // ' is an unrecognized file type' ierr = - 1 end select return end function io_read_hdr module subroutine io_read_param_in ( self , param_file_name ) !! author: David A. Minton !! !! Read in parameters for the integration !! !! Adapted from David E. Kaufmann's Swifter routine io_init_param.f90 !! Adapted from Martin Duncan's Swift routine io_init_param.f implicit none ! Arguments class ( swiftest_parameters ), intent ( inout ) :: self !! Current run configuration parameters character ( len =* ), intent ( in ) :: param_file_name !! Parameter input file name (i.e. param.in) ! Internals integer ( I4B ), parameter :: LUN = 7 !! Unit number of input file integer ( I4B ) :: ierr = 0 !! Input error code character ( STRMAX ) :: error_message !! Error message in UDIO procedure ! Read in name of parameter file write ( * , * ) 'Parameter input file is ' , trim ( adjustl ( param_file_name )) write ( * , * ) ' ' 100 format ( A ) open ( unit = LUN , file = param_file_name , status = 'old' , iostat = ierr ) if ( ierr /= 0 ) then write ( * , * ) 'Swiftest error: ' , ierr write ( * , * ) '   Unable to open file ' , trim ( adjustl ( param_file_name )) call util_exit ( FAILURE ) end if !! todo: Currently this procedure does not work in user-defined derived-type input mode !!    as the newline characters are ignored in the input file when compiled in ifort. !read(LUN,'(DT)', iostat= ierr, iomsg = error_message) param call self % reader ( LUN , iotype = \"none\" , v_list = [ self % integrator ], iostat = ierr , iomsg = error_message ) if ( ierr /= 0 ) then write ( * , * ) 'Swiftest error reading ' , trim ( adjustl ( param_file_name )) write ( * , * ) ierr , trim ( adjustl ( error_message )) call util_exit ( FAILURE ) end if return end subroutine io_read_param_in module subroutine io_toupper ( string ) !! author: David A. Minton !! !! Convert string to uppercase !! !! Adapted from David E. Kaufmann's Swifter routine: util_toupper.f90 implicit none ! Arguments character ( * ), intent ( inout ) :: string !! String to make upper case ! Internals integer ( I4B ) :: i , length , idx length = len ( string ) do i = 1 , length idx = iachar ( string ( i : i )) if (( idx >= lowercase_begin ) . and . ( idx <= lowercase_end )) then idx = idx + uppercase_offset string ( i : i ) = achar ( idx ) end if end do return end subroutine io_toupper module subroutine io_write_discard ( self , param ) !! author: David A. Minton !! !! Write out information about discarded test particle !! !! Adapted from David E. Kaufmann's Swifter routine  io_discard_write.f90 !! Adapted from Hal Levison's Swift routine io_discard_write.f implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ), parameter :: LUN = 40 integer ( I4B ) :: i , ierr logical , save :: lfirst = . true . real ( DP ), dimension (:,:), allocatable :: vh character ( * ), parameter :: HDRFMT = '(E23.16, 1X, I8, 1X, L1)' character ( * ), parameter :: NAMEFMT = '(A, 2(1X, I8))' character ( * ), parameter :: VECFMT = '(3(E23.16, 1X))' character ( * ), parameter :: NPLFMT = '(I8)' character ( * ), parameter :: PLNAMEFMT = '(I8, 2(1X, E23.16))' class ( swiftest_body ), allocatable :: pltemp associate ( tp_discards => self % tp_discards , nsp => self % tp_discards % nbody , pl => self % pl , npl => self % pl % nbody ) if ( nsp == 0 ) return select case ( param % out_stat ) case ( 'APPEND' ) open ( unit = LUN , file = param % discard_out , status = 'OLD' , position = 'APPEND' , form = 'FORMATTED' , iostat = ierr ) case ( 'NEW' , 'REPLACE' , 'UNKNOWN' ) open ( unit = LUN , file = param % discard_out , status = param % out_stat , form = 'FORMATTED' , iostat = ierr ) case default write ( * , * ) 'Invalid status code for OUT_STAT: ' , trim ( adjustl ( param % out_stat )) call util_exit ( FAILURE ) end select lfirst = . false . if ( param % lgr ) call tp_discards % pv2v ( param ) write ( LUN , HDRFMT ) param % t , nsp , param % lbig_discard do i = 1 , nsp write ( LUN , NAMEFMT ) SUB , tp_discards % id ( i ), tp_discards % status ( i ) write ( LUN , VECFMT ) tp_discards % xh ( 1 , i ), tp_discards % xh ( 2 , i ), tp_discards % xh ( 3 , i ) write ( LUN , VECFMT ) tp_discards % vh ( 1 , i ), tp_discards % vh ( 2 , i ), tp_discards % vh ( 3 , i ) end do if ( param % lbig_discard ) then if ( param % lgr ) then allocate ( pltemp , source = pl ) call pltemp % pv2v ( param ) allocate ( vh , source = pltemp % vh ) deallocate ( pltemp ) else allocate ( vh , source = pl % vh ) end if write ( LUN , NPLFMT ) npl do i = 1 , npl write ( LUN , PLNAMEFMT ) pl % id ( i ), pl % Gmass ( i ), pl % radius ( i ) write ( LUN , VECFMT ) pl % xh ( 1 , i ), pl % xh ( 2 , i ), pl % xh ( 3 , i ) write ( LUN , VECFMT ) vh ( 1 , i ), vh ( 2 , i ), vh ( 3 , i ) end do deallocate ( vh ) end if close ( LUN ) end associate return end subroutine io_write_discard module subroutine io_write_encounter ( t , name1 , name2 , mass1 , mass2 , radius1 , radius2 , & xh1 , xh2 , vh1 , vh2 , enc_out , out_type ) !! author: David A. Minton !! !! Write close encounter data to output binary files !!  There is no direct file output from this subroutine !! !! Adapted from David E. Kaufmann's Swifter routine: io_write_encounter.f90 !! Adapted from Hal Levison's Swift routine io_write_encounter.f implicit none ! Arguments integer ( I4B ), intent ( in ) :: name1 , name2 real ( DP ), intent ( in ) :: t , mass1 , mass2 , radius1 , radius2 real ( DP ), dimension (:), intent ( in ) :: xh1 , xh2 , vh1 , vh2 character ( * ), intent ( in ) :: enc_out , out_type ! Internals logical , save :: lfirst = . true . integer ( I4B ), parameter :: lun = 30 integer ( I4B ) :: ierr integer ( I4B ), save :: iu = lun open ( unit = iu , file = enc_out , status = 'OLD' , position = 'APPEND' , form = 'UNFORMATTED' , iostat = ierr ) if (( ierr /= 0 ) . and . lfirst ) then open ( unit = iu , file = enc_out , status = 'NEW' , form = 'UNFORMATTED' , iostat = ierr ) end if if ( ierr /= 0 ) then write ( * , * ) \"Swiftest Error:\" write ( * , * ) \"   Unable to open binary encounter file\" call util_exit ( FAILURE ) end if lfirst = . false . write ( iu , iostat = ierr ) t if ( ierr < 0 ) then write ( * , * ) \"Swiftest Error:\" write ( * , * ) \"   Unable to write binary file record\" call util_exit ( FAILURE ) end if write ( iu ) name1 , xh1 ( 1 ), xh1 ( 2 ), xh1 ( 3 ), vh1 ( 1 ), vh1 ( 2 ), mass1 , radius1 write ( iu ) name2 , xh2 ( 1 ), xh2 ( 2 ), xh2 ( 3 ), vh2 ( 1 ), vh2 ( 2 ), mass2 , radius2 close ( unit = iu , iostat = ierr ) if ( ierr /= 0 ) then write ( * , * ) \"Swiftest Error:\" write ( * , * ) \"   Unable to close binary encounter file\" call util_exit ( FAILURE ) end if return end subroutine io_write_encounter module subroutine io_write_frame_body ( self , iu , param ) !! author: David A. Minton !! !! Write a frame of output of either test particle or massive body data to the binary output file !!    Note: If outputting to orbital elements, but sure that the conversion is done prior to calling this method !! !! Adapted from David E. Kaufmann's Swifter routine  io_write_frame.f90 !! Adapted from Hal Levison's Swift routine io_write_frame.F implicit none ! Arguments class ( swiftest_body ), intent ( in ) :: self !! Swiftest particle object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters associate ( n => self % nbody ) if ( n == 0 ) return write ( iu ) self % id ( 1 : n ) !write(iu) self%name(1:n) select case ( param % out_form ) case ( EL ) write ( iu ) self % a ( 1 : n ) write ( iu ) self % e ( 1 : n ) write ( iu ) self % inc ( 1 : n ) write ( iu ) self % capom ( 1 : n ) write ( iu ) self % omega ( 1 : n ) write ( iu ) self % capm ( 1 : n ) case ( XV ) write ( iu ) self % xh ( 1 , 1 : n ) write ( iu ) self % xh ( 2 , 1 : n ) write ( iu ) self % xh ( 3 , 1 : n ) write ( iu ) self % vh ( 1 , 1 : n ) write ( iu ) self % vh ( 2 , 1 : n ) write ( iu ) self % vh ( 3 , 1 : n ) end select select type ( pl => self ) class is ( swiftest_pl ) ! Additional output if the passed polymorphic object is a massive body write ( iu ) pl % Gmass ( 1 : n ) if ( param % lrhill_present ) write ( iu ) pl % rhill ( 1 : n ) if ( param % lclose ) write ( iu ) pl % radius ( 1 : n ) if ( param % lrotation ) then write ( iu ) pl % Ip ( 1 , 1 : n ) write ( iu ) pl % Ip ( 2 , 1 : n ) write ( iu ) pl % Ip ( 3 , 1 : n ) write ( iu ) pl % rot ( 1 , 1 : n ) write ( iu ) pl % rot ( 2 , 1 : n ) write ( iu ) pl % rot ( 3 , 1 : n ) end if if ( param % ltides ) then write ( iu ) pl % k2 ( 1 : n ) write ( iu ) pl % Q ( 1 : n ) end if end select end associate return end subroutine io_write_frame_body module subroutine io_write_frame_cb ( self , iu , param ) !! author: David A. Minton !! !! Write a frame of output of central body data to the binary output file !! !! Adapted from David E. Kaufmann's Swifter routine  io_write_frame.f90 !! Adapted from Hal Levison's Swift routine io_write_frame.F implicit none ! Arguments class ( swiftest_cb ), intent ( in ) :: self !! Swiftest central body object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters associate ( cb => self ) !write(iu) cb%name write ( iu ) cb % id write ( iu ) cb % Gmass write ( iu ) cb % radius write ( iu ) cb % j2rp2 write ( iu ) cb % j4rp4 if ( param % lrotation ) then write ( iu ) cb % Ip ( 1 ) write ( iu ) cb % Ip ( 2 ) write ( iu ) cb % Ip ( 3 ) write ( iu ) cb % rot ( 1 ) write ( iu ) cb % rot ( 2 ) write ( iu ) cb % rot ( 3 ) end if if ( param % ltides ) then write ( iu ) cb % k2 write ( iu ) cb % Q end if end associate return end subroutine io_write_frame_cb module subroutine io_write_frame_system ( self , iu , param ) !! author: The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Write a frame (header plus records for each massive body and active test particle) to output binary file !! There is no direct file output from this subroutine !! !! Adapted from David E. Kaufmann's Swifter routine  io_write_frame.f90 !! Adapted from Hal Levison's Swift routine io_write_frame.F implicit none ! Arguments class ( swiftest_nbody_system ), intent ( in ) :: self !! Swiftest system object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals logical , save :: lfirst = . true . !! Flag to determine if this is the first call of this method integer ( I4B ) :: ierr !! I/O error code class ( swiftest_cb ), allocatable :: cb !! Temporary local version of pl structure used for non-destructive conversions class ( swiftest_pl ), allocatable :: pl !! Temporary local version of pl structure used for non-destructive conversions class ( swiftest_tp ), allocatable :: tp !! Temporary local version of pl structure used for non-destructive conversions allocate ( cb , source = self % cb ) allocate ( pl , source = self % pl ) allocate ( tp , source = self % tp ) iu = BINUNIT if ( lfirst ) then select case ( param % out_stat ) case ( 'APPEND' ) open ( unit = iu , file = param % outfile , status = 'OLD' , position = 'APPEND' , form = 'UNFORMATTED' , iostat = ierr ) case ( 'NEW' , 'REPLACE' , 'UNKNOWN' ) open ( unit = iu , file = param % outfile , status = param % out_stat , form = 'UNFORMATTED' , iostat = ierr ) case default write ( * , * ) 'Invalid status code for OUT_STAT: ' , trim ( adjustl ( param % out_stat )) call util_exit ( FAILURE ) end select if ( ierr /= 0 ) then write ( * , * ) \"Swiftest error: io_write_frame_system - first\" , ierr write ( * , * ) \"   Binary output file \" // trim ( adjustl ( param % outfile )) // \" already exists or cannot be accessed\" write ( * , * ) \"   OUT_STAT: \" // trim ( adjustl ( param % out_stat )) call util_exit ( FAILURE ) end if lfirst = . false . else open ( unit = iu , file = param % outfile , status = 'OLD' , position = 'APPEND' , form = 'UNFORMATTED' , iostat = ierr ) if ( ierr /= 0 ) then write ( * , * ) \"Swiftest error: io_write_frame_system\" write ( * , * ) \"   Unable to open binary output file for APPEND\" call util_exit ( FAILURE ) end if end if call io_write_hdr ( iu , param % t , pl % nbody , tp % nbody , param % out_form , param % out_type ) if ( param % lgr ) then call pl % pv2v ( param ) call tp % pv2v ( param ) end if if ( param % out_form == EL ) then ! Do an orbital element conversion prior to writing out the frame, as we have access to the central body here call pl % xv2el ( cb ) call tp % xv2el ( cb ) end if ! Write out each data type frame call cb % write_frame ( iu , param ) call pl % write_frame ( iu , param ) call tp % write_frame ( iu , param ) deallocate ( cb , pl , tp ) close ( iu ) return end subroutine io_write_frame_system subroutine io_write_hdr ( iu , t , npl , ntp , out_form , out_type ) !! author: The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Write frame header to output binary file !! !! Adapted from David Adapted from David E. Kaufmann's Swifter routine io_write_hdr.f90 !! Adapted from Hal Levison's Swift routine io_write_hdr.F implicit none ! Arguments integer ( I4B ), intent ( in ) :: iu !! Output file unit number real ( DP ), intent ( in ) :: t !! Current time of simulation integer ( I4B ), intent ( in ) :: npl !! Number of massive bodies integer ( I4B ), intent ( in ) :: ntp !! Number of test particles character ( * ), intent ( in ) :: out_form !! Output format type (\"EL\" or  \"XV\") character ( * ), intent ( in ) :: out_type !! Output file format type (REAL4, REAL8 - see swiftest module for symbolic name definitions) ! Internals integer ( I4B ) :: ierr !! Error code select case ( out_type ) case ( REAL4_TYPE , SWIFTER_REAL4_TYPE ) write ( iu , iostat = ierr ) real ( t , kind = SP ) if ( ierr /= 0 ) then write ( * , * ) \"Swiftest error:\" write ( * , * ) \"   Unable to write binary file header\" call util_exit ( FAILURE ) end if case ( REAL8_TYPE , SWIFTER_REAL8_TYPE ) write ( iu , iostat = ierr ) t if ( ierr /= 0 ) then write ( * , * ) \"Swiftest error:\" write ( * , * ) \"   Unable to write binary file header\" call util_exit ( FAILURE ) end if end select write ( iu , iostat = ierr ) npl write ( iu , iostat = ierr ) ntp write ( iu , iostat = ierr ) out_form return end subroutine io_write_hdr end submodule s_io","tags":"","loc":"sourcefile/io.f90.html"},{"title":"setup.f90 – swiftest","text":"This file depends on sourcefile~~setup.f90~~EfferentGraph sourcefile~setup.f90 setup.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~setup.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_setup Source Code setup.f90 Source Code submodule ( swiftest_classes ) s_setup use swiftest contains module subroutine setup_construct_system ( system , param ) !! author: David A. Minton !! !! Constructor for a Swiftest nbody system. Creates the nbody system object based on the user-input integrator !! implicit none ! Arguments class ( swiftest_nbody_system ), allocatable , intent ( inout ) :: system !! Swiftest system object class ( swiftest_parameters ), intent ( in ) :: param !! Swiftest parameters select case ( param % integrator ) case ( BS ) write ( * , * ) 'Bulirsch-Stoer integrator not yet enabled' case ( HELIO ) allocate ( helio_nbody_system :: system ) select type ( system ) class is ( helio_nbody_system ) allocate ( helio_cb :: system % cb ) allocate ( helio_pl :: system % pl ) allocate ( helio_tp :: system % tp ) allocate ( helio_tp :: system % tp_discards ) end select case ( RA15 ) write ( * , * ) 'Radau integrator not yet enabled' case ( TU4 ) write ( * , * ) 'TU4 integrator not yet enabled' case ( WHM ) allocate ( whm_nbody_system :: system ) select type ( system ) class is ( whm_nbody_system ) allocate ( whm_cb :: system % cb ) allocate ( whm_pl :: system % pl ) allocate ( whm_tp :: system % tp ) allocate ( whm_tp :: system % tp_discards ) end select case ( RMVS ) allocate ( rmvs_nbody_system :: system ) select type ( system ) class is ( rmvs_nbody_system ) allocate ( rmvs_cb :: system % cb ) allocate ( rmvs_pl :: system % pl ) allocate ( rmvs_tp :: system % tp ) allocate ( rmvs_tp :: system % tp_discards ) end select case ( SYMBA ) allocate ( symba_nbody_system :: system ) select type ( system ) class is ( symba_nbody_system ) allocate ( symba_cb :: system % cb ) allocate ( symba_pl :: system % pl ) allocate ( symba_tp :: system % tp ) allocate ( symba_tp :: system % tp_discards ) allocate ( symba_merger :: system % pl_adds ) allocate ( symba_merger :: system % pl_discards ) allocate ( symba_plplenc :: system % plplenc_list ) allocate ( symba_pltpenc :: system % pltpenc_list ) end select case ( RINGMOONS ) write ( * , * ) 'RINGMOONS-SyMBA integrator not yet enabled' case default write ( * , * ) 'Unkown integrator' , param % integrator call util_exit ( FAILURE ) end select return end subroutine setup_construct_system module subroutine setup_encounter ( self , n ) !! author: David A. Minton !! !! A constructor that sets the number of encounters and allocates and initializes all arrays !! implicit none ! Arguments class ( swiftest_encounter ), intent ( inout ) :: self !! Swiftest encounter structure integer ( I4B ), intent ( in ) :: n !! Number of encounters to allocate space for self % nenc = n if ( n == 0 ) return if ( allocated ( self % lvdotr )) deallocate ( self % lvdotr ) if ( allocated ( self % status )) deallocate ( self % status ) if ( allocated ( self % index1 )) deallocate ( self % index1 ) if ( allocated ( self % index2 )) deallocate ( self % index2 ) if ( allocated ( self % x1 )) deallocate ( self % x1 ) if ( allocated ( self % x2 )) deallocate ( self % x2 ) if ( allocated ( self % v1 )) deallocate ( self % v1 ) if ( allocated ( self % v2 )) deallocate ( self % v2 ) allocate ( self % lvdotr ( n )) allocate ( self % status ( n )) allocate ( self % index1 ( n )) allocate ( self % index2 ( n )) allocate ( self % x1 ( NDIM , n )) allocate ( self % x2 ( NDIM , n )) allocate ( self % v1 ( NDIM , n )) allocate ( self % v2 ( NDIM , n )) self % lvdotr (:) = . false . self % status (:) = INACTIVE self % index1 (:) = 0 self % index2 (:) = 0 self % x1 (:,:) = 0.0_DP self % x2 (:,:) = 0.0_DP self % v1 (:,:) = 0.0_DP self % v2 (:,:) = 0.0_DP return end subroutine setup_encounter module subroutine setup_initialize_system ( self , param ) !! author: David A. Minton !! !! Wrapper method to initialize a basic Swiftest nbody system from files !! implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters call self % cb % initialize ( param ) call self % pl % initialize ( param ) call self % tp % initialize ( param ) call self % validate_ids ( param ) call self % set_msys () call self % pl % set_mu ( self % cb ) call self % tp % set_mu ( self % cb ) call self % pl % eucl_index () if (. not . param % lrhill_present ) call self % pl % set_rhill ( self % cb ) return end subroutine setup_initialize_system module subroutine setup_body ( self , n , param ) !! author: David A. Minton !! !! Constructor for base Swiftest particle class. Allocates space for all particles and !! initializes all components with a value. !! Note: Timing tests indicate that (NDIM, n) is more efficient than (NDIM, n) implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest generic body object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameter self % nbody = n if ( n <= 0 ) return self % lfirst = . true . if ( allocated ( self % id )) deallocate ( self % id ) if ( allocated ( self % name )) deallocate ( self % name ) if ( allocated ( self % status )) deallocate ( self % status ) if ( allocated ( self % ldiscard )) deallocate ( self % ldiscard ) if ( allocated ( self % xh )) deallocate ( self % xh ) if ( allocated ( self % vh )) deallocate ( self % vh ) if ( allocated ( self % xb )) deallocate ( self % xb ) if ( allocated ( self % vb )) deallocate ( self % vb ) if ( allocated ( self % ah )) deallocate ( self % ah ) if ( allocated ( self % ir3h )) deallocate ( self % ir3h ) if ( allocated ( self % mu )) deallocate ( self % mu ) if ( allocated ( self % lmask )) deallocate ( self % lmask ) allocate ( self % id ( n )) allocate ( self % name ( n )) allocate ( self % status ( n )) allocate ( self % ldiscard ( n )) allocate ( self % xh ( NDIM , n )) allocate ( self % vh ( NDIM , n )) allocate ( self % xb ( NDIM , n )) allocate ( self % vb ( NDIM , n )) allocate ( self % ah ( NDIM , n )) allocate ( self % ir3h ( n )) allocate ( self % mu ( n )) allocate ( self % lmask ( n )) self % id (:) = 0 self % name (:) = \"UNNAMED\" self % status (:) = INACTIVE self % lmask (:) = . false . self % ldiscard (:) = . false . self % xh (:,:) = 0.0_DP self % vh (:,:) = 0.0_DP self % xb (:,:) = 0.0_DP self % vb (:,:) = 0.0_DP self % ah (:,:) = 0.0_DP self % ir3h (:) = 0.0_DP self % mu (:) = 0.0_DP if ( param % loblatecb ) then if ( allocated ( self % aobl )) deallocate ( self % aobl ) allocate ( self % aobl ( NDIM , n )) self % aobl (:,:) = 0.0_DP end if if ( param % ltides ) then if ( allocated ( self % atide )) deallocate ( self % lmask ) allocate ( self % atide ( NDIM , n )) self % atide (:,:) = 0.0_DP end if if ( param % lgr ) then if ( allocated ( self % agr )) deallocate ( self % lmask ) allocate ( self % agr ( NDIM , n )) self % agr (:,:) = 0.0_DP end if return end subroutine setup_body module subroutine setup_pl ( self , n , param ) !! author: David A. Minton !! !! Constructor for base Swiftest massive body class. Allocates space for all particles and !! initializes all components with a value. implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameter !> Call allocation method for parent class !> The parent class here is the abstract swiftest_body class, so we can't use the type-bound procedure call setup_body ( self , n , param ) if ( n <= 0 ) return if ( allocated ( self % mass )) deallocate ( self % mass ) if ( allocated ( self % Gmass )) deallocate ( self % Gmass ) if ( allocated ( self % rhill )) deallocate ( self % rhill ) allocate ( self % mass ( n )) allocate ( self % Gmass ( n )) allocate ( self % rhill ( n )) self % mass (:) = 0.0_DP self % Gmass (:) = 0.0_DP self % rhill (:) = 0.0_DP self % nplpl = 0 if ( param % lclose ) then if ( allocated ( self % radius )) deallocate ( self % radius ) if ( allocated ( self % density )) deallocate ( self % density ) allocate ( self % radius ( n )) allocate ( self % density ( n )) self % radius (:) = 0.0_DP self % density (:) = 1.0_DP end if if ( param % lrotation ) then if ( allocated ( self % rot )) deallocate ( self % rhill ) if ( allocated ( self % Ip )) deallocate ( self % rhill ) allocate ( self % rot ( NDIM , n )) allocate ( self % Ip ( NDIM , n )) self % rot (:,:) = 0.0_DP self % Ip (:,:) = 0.0_DP end if if ( param % ltides ) then if ( allocated ( self % k2 )) deallocate ( self % rhill ) if ( allocated ( self % Q )) deallocate ( self % rhill ) if ( allocated ( self % tlag )) deallocate ( self % rhill ) allocate ( self % k2 ( n )) allocate ( self % Q ( n )) allocate ( self % tlag ( n )) self % k2 (:) = 0.0_DP self % Q (:) = 0.0_DP self % tlag (:) = 0.0_DP end if return end subroutine setup_pl module subroutine setup_tp ( self , n , param ) !! author: David A. Minton !! !! Constructor for base Swiftest test particle particle class. Allocates space for !! all particles and initializes all components with a value. implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameter !> Call allocation method for parent class !> The parent class here is the abstract swiftest_body class, so we can't use the type-bound procedure call setup_body ( self , n , param ) if ( n <= 0 ) return if ( allocated ( self % isperi )) deallocate ( self % isperi ) if ( allocated ( self % peri )) deallocate ( self % peri ) if ( allocated ( self % atp )) deallocate ( self % atp ) allocate ( self % isperi ( n )) allocate ( self % peri ( n )) allocate ( self % atp ( n )) self % isperi (:) = 0 self % peri (:) = 0.0_DP self % atp (:) = 0.0_DP return end subroutine setup_tp end submodule s_setup","tags":"","loc":"sourcefile/setup.f90.html"},{"title":"eucl.f90 – swiftest","text":"This file depends on sourcefile~~eucl.f90~~EfferentGraph sourcefile~eucl.f90 eucl.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~eucl.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~eucl.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_eucl Source Code eucl.f90 Source Code submodule ( swiftest_classes ) s_eucl use swiftest contains module subroutine eucl_dist_index_plpl ( self ) !! author: Jacob R. Elliott and David A. Minton !! !! Turns i,j indices into k index for use in the Euclidean distance matrix !! !! Reference: !! !!    Mélodie Angeletti, Jean-Marie Bonny, Jonas Koko. Parallel Euclidean distance matrix computation on big datasets *. !!       2019. hal-0204751 implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body objec ! Internals integer ( I8B ) :: i , j , counter , npl npl = int ( self % nbody , kind = I8B ) associate ( nplpl => self % nplpl ) nplpl = ( npl * ( npl - 1 ) / 2 ) ! number of entries in a strict lower triangle, nplm x npl, minus first column if ( allocated ( self % k_plpl )) deallocate ( self % k_plpl ) ! Reset the index array if it's been set previously allocate ( self % k_plpl ( 2 , nplpl )) do i = 1 , npl counter = ( i - 1_I8B ) * npl - i * ( i - 1_I8B ) / 2_I8B + 1_I8B do j = i + 1_I8B , npl self % k_plpl ( 1 , counter ) = i self % k_plpl ( 2 , counter ) = j counter = counter + 1_I8B end do end do end associate return end subroutine eucl_dist_index_plpl end submodule s_eucl","tags":"","loc":"sourcefile/eucl.f90.html"},{"title":"user_getacch.f90 – swiftest","text":"This file depends on sourcefile~~user_getacch.f90~~EfferentGraph sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~user_getacch.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_user_kick_getacch Source Code user_getacch.f90 Source Code submodule ( swiftest_classes ) s_user_kick_getacch use swiftest contains module subroutine user_kick_getacch_body ( self , system , param , t , lbeg ) !! author: David A. Minton !! !! Add user-supplied heliocentric accelerations to planets. !! !! Adapted from David E. Kaufmann's Swifter routine whm_user_kick_getacch.f90 implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody_system_object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters user parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the ste return end subroutine user_kick_getacch_body end submodule s_user_kick_getacch","tags":"","loc":"sourcefile/user_getacch.f90.html"},{"title":"drift.f90 – swiftest","text":"This file depends on sourcefile~~drift.f90~~EfferentGraph sourcefile~drift.f90 drift.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~drift.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules drift_implementation Source Code drift.f90 Source Code submodule ( swiftest_classes ) drift_implementation use swiftest !> Integration control parameters: real ( DP ), parameter :: E2MAX = 0.36_DP real ( DP ), parameter :: DM2MAX = 0.16_DP real ( DP ), parameter :: E2DM2MAX = 0.0016_DP real ( DP ), parameter :: DANBYB = 1.0E-13_DP integer ( I2B ), parameter :: NLAG1 = 50 integer ( I2B ), parameter :: NLAG2 = 40 contains module subroutine drift_body ( self , system , param , dt ) !! author: David A. Minton !! !! Loop bodies and call Danby drift routine on the heliocentric position and velocities. !! !! Adapted from Hal Levison's Swift routine drift_tp.f !! Adapted from David E. Kaufmann's Swifter routine whm_drift_tp.f90 implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize ! Internals integer ( I4B ) :: i integer ( I4B ), dimension (:), allocatable :: iflag associate ( n => self % nbody ) allocate ( iflag ( n )) iflag (:) = 0 call drift_all ( self % mu , self % xh , self % vh , self % nbody , param , dt , self % lmask , iflag ) if ( any ( iflag ( 1 : n ) /= 0 )) then where ( iflag ( 1 : n ) /= 0 ) self % status ( 1 : n ) = DISCARDED_DRIFTERR do i = 1 , n if ( iflag ( i ) /= 0 ) write ( * , * ) \" Body \" , self % id ( i ), \" lost due to error in Danby drift\" end do end if end associate return end subroutine drift_body module pure subroutine drift_all ( mu , x , v , n , param , dt , mask , iflag ) !! author: David A. Minton !! !! Loop bodies and call Danby drift routine on all bodies for the given position and velocity vector. !! !! Adapted from Hal Levison's Swift routine drift_tp.f !! Adapted from David E. Kaufmann's Swifter routine whm_drift_tp.f9 implicit none ! Arguments real ( DP ), dimension (:), intent ( in ) :: mu !! Vector of gravitational constants real ( DP ), dimension (:,:), intent ( inout ) :: x , v !! Position and velocity vectors integer ( I4B ), intent ( in ) :: n !! number of bodies class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize logical , dimension (:), intent ( in ) :: mask !! Logical mask of size self%nbody that determines which bodies to drift. integer ( I4B ), dimension (:), intent ( out ) :: iflag !! Vector of error flags. 0 means no problem ! Internals integer ( I4B ) :: i real ( DP ) :: energy , vmag2 , rmag !! Variables used in GR calculation real ( DP ), dimension (:), allocatable :: dtp if ( n == 0 ) return allocate ( dtp ( n )) if ( param % lgr ) then do concurrent ( i = 1 : n , mask ( i )) rmag = norm2 ( x (:, i )) vmag2 = dot_product ( v (:, i ), v (:, i )) energy = 0.5_DP * vmag2 - mu ( i ) / rmag dtp ( i ) = dt * ( 1.0_DP + 3 * param % inv_c2 * energy ) end do else where ( mask ( 1 : n )) dtp ( 1 : n ) = dt end if do concurrent ( i = 1 : n , mask ( i )) call drift_one ( mu ( i ), x ( 1 , i ), x ( 2 , i ), x ( 3 , i ), v ( 1 , i ), v ( 2 , i ), v ( 3 , i ), dtp ( i ), iflag ( i )) end do return end subroutine drift_all module pure elemental subroutine drift_one ( mu , px , py , pz , vx , vy , vz , dt , iflag ) !! author: The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Perform Danby drift for one body, redoing drift with smaller substeps if original accuracy is insufficient !! !! Adapted from David E. Kaufmann's Swifter routine routine drift_one.f90 !! Adapted from Hal Levison and Martin Duncan's Swift routine drift_one.f implicit none ! Arguments real ( DP ), intent ( in ) :: mu !! G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body to drift real ( DP ), intent ( inout ) :: px , py , pz , vx , vy , vz !! Position and velocity of body to drift real ( DP ), intent ( in ) :: dt !! Step size integer ( I4B ), intent ( out ) :: iflag !! iflag : error status flag for Danby drift (0 = OK, nonzero = ERROR) ! Internals integer ( I4B ) :: i real ( DP ) :: dttmp real ( DP ), dimension ( NDIM ) :: x , v x = [ px , py , pz ] v = [ vx , vy , vz ] call drift_dan ( mu , x (:), v (:), dt , iflag ) if ( iflag /= 0 ) then dttmp = 0.1_DP * dt do i = 1 , 10 call drift_dan ( mu , x (:), v (:), dttmp , iflag ) if ( iflag /= 0 ) exit end do end if px = x ( 1 ); py = x ( 2 ); pz = x ( 3 ) vx = v ( 1 ); vy = v ( 2 ); vz = v ( 3 ) return end subroutine drift_one pure subroutine drift_dan ( mu , x0 , v0 , dt0 , iflag ) !! author: David A. Minton !! !! Perform Kepler drift, solving Kepler's equation in appropriate variables !! !! Adapted from David E. Kaufmann's Swifter routine: drift_dan.f90 !! Adapted from Hal Levison and Martin Duncan's Swift routine drift_dan.f implicit none integer ( I4B ), intent ( out ) :: iflag real ( DP ), intent ( in ) :: mu , dt0 real ( DP ), dimension (:), intent ( inout ) :: x0 , v0 real ( DP ) :: dt , f , g , fdot , gdot , c1 , c2 , c3 , u , alpha , fp , r0 real ( DP ) :: v0s , a , asq , en , dm , ec , es , esq , xkep , fchk , s , c real ( DP ), dimension ( NDIM ) :: x , v ! Executable code iflag = 0 dt = dt0 r0 = sqrt ( dot_product ( x0 (:), x0 (:))) v0s = dot_product ( v0 (:), v0 (:)) u = dot_product ( x0 (:), v0 (:)) alpha = 2 * mu / r0 - v0s if ( alpha > 0.0_DP ) then a = mu / alpha asq = a ** 2 en = sqrt ( mu / ( a * asq )) ec = 1.0_DP - r0 / a es = u / ( en * asq ) esq = ec ** 2 + es ** 2 dm = dt * en - int ( dt * en / TWOPI , kind = I4B ) * TWOPI dt = dm / en if (( esq < E2MAX ) . and . ( dm ** 2 < DM2MAX ) . and . ( esq * dm ** 2 < E2DM2MAX )) then call drift_kepmd ( dm , es , ec , xkep , s , c ) fchk = ( xkep - ec * s + es * ( 1.0_DP - c ) - dm ) ! DEK - original code compared fchk*fchk with DANBYB, but i think it should ! DEK - be compared with DANBYB*DANBYB, and i changed it accordingly - please ! DEK - check with hal and/or martin about this if ( fchk ** 2 > DANBYB ** 2 ) then iflag = 1 return end if fp = 1.0_DP - ec * c + es * s f = a / r0 * ( c - 1.0_DP ) + 1.0_DP g = dt + ( s - xkep ) / en fdot = - ( a / ( r0 * fp )) * en * s gdot = ( c - 1.0_DP ) / fp + 1.0_DP x (:) = x0 (:) * f + v0 (:) * g v (:) = x0 (:) * fdot + v0 (:) * gdot x0 (:) = x (:) v0 (:) = v (:) iflag = 0 return end if end if call drift_kepu ( dt , r0 , mu , alpha , u , fp , c1 , c2 , c3 , iflag ) if ( iflag == 0 ) then f = 1.0_DP - mu / r0 * c2 g = dt - mu * c3 fdot = - mu / ( fp * r0 ) * c1 gdot = 1.0_DP - mu / fp * c2 x (:) = x0 (:) * f + v0 (:) * g v (:) = x0 (:) * fdot + v0 (:) * gdot x0 (:) = x (:) v0 (:) = v (:) end if return end subroutine drift_dan pure subroutine drift_kepmd ( dm , es , ec , x , s , c ) !! author: David A. Minton !! !! Solve Kepler's equation in difference form for an ellipse for small input dm and eccentricity !!    Original disclaimer: built for speed, does not check how well the original equation is solved !!    Can do that in calling routine by checking how close (x - ec*s + es*(1.0 - c) - dm) is to zero !! !! Adapted from David E. Kaufmann's Swifter routine: drift_kepmd.f90 !! Adapted from Martin Duncan's Swift routine drift_kepmd.f implicit none real ( DP ), intent ( in ) :: dm , es , ec real ( DP ), intent ( out ) :: x , s , c real ( DP ), parameter :: a0 = 3991680 0.0_DP , a1 = 665280 0.0_DP , a2 = 33264 0.0_DP , a3 = 792 0.0_DP , a4 = 11 0.0_DP real ( DP ) :: dx , fac1 , fac2 , q , y , f , fp , fpp , fppp ! executable code fac1 = 1.0_DP / ( 1.0_DP - ec ) q = fac1 * dm fac2 = es ** 2 * fac1 - ec / 3.0_DP x = q * ( 1.0_DP - 0.5_DP * fac1 * q * ( es - q * fac2 )) y = x ** 2 s = x * ( a0 - y * ( a1 - y * ( a2 - y * ( a3 - y * ( a4 - y ))))) / a0 c = sqrt ( 1.0_DP - s ** 2 ) f = x - ec * s + es * ( 1.0_DP - c ) - dm fp = 1.0_DP - ec * c + es * s fpp = ec * s + es * c fppp = ec * c - es * s dx = - f / fp dx = - f / ( fp + dx * fpp / 2.0_DP ) dx = - f / ( fp + dx * fpp / 2.0_DP + dx ** 2 * fppp / 6.0_DP ) x = x + dx y = x ** 2 s = x * ( a0 - y * ( a1 - y * ( a2 - y * ( a3 - y * ( a4 - y ))))) / a0 c = sqrt ( 1.0_DP - s ** 2 ) return end subroutine drift_kepmd pure subroutine drift_kepu ( dt , r0 , mu , alpha , u , fp , c1 , c2 , c3 , iflag ) !! author: David A. Minton !! !! Solve Kepler's equation in universal variables !! !! Adapted from David E. Kaufmann's Swifter routine: drift_kepu.f90 !! Adapted from Hal Levison's Swift routine drift_kepu.f implicit none integer ( I4B ), intent ( out ) :: iflag real ( DP ), intent ( in ) :: dt , r0 , mu , alpha , u real ( DP ), intent ( out ) :: fp , c1 , c2 , c3 real ( DP ) :: s , st , fo , fn ! executable code call drift_kepu_guess ( dt , r0 , mu , alpha , u , s ) st = s call drift_kepu_new ( s , dt , r0 , mu , alpha , u , fp , c1 , c2 , c3 , iflag ) if ( iflag /= 0 ) then call drift_kepu_fchk ( dt , r0 , mu , alpha , u , st , fo ) call drift_kepu_fchk ( dt , r0 , mu , alpha , u , s , fn ) if ( abs ( fo ) < abs ( fn )) s = st call drift_kepu_lag ( s , dt , r0 , mu , alpha , u , fp , c1 , c2 , c3 , iflag ) end if return end subroutine drift_kepu pure subroutine drift_kepu_fchk ( dt , r0 , mu , alpha , u , s , f ) !! author: David A. Minton !! !! Computes the value of f, the function whose root we are trying to find in universal variables !! !! Adapted from David E. Kaufmann's Swifter routine: drift_kepu_fchk.f90 !! Adapted from Martin Duncan's Swift routine drift_kepu_fchk.f implicit none real ( DP ), intent ( in ) :: dt , r0 , mu , alpha , u , s real ( DP ), intent ( out ) :: f real ( DP ) :: x , c0 , c1 , c2 , c3 x = s ** 2 * alpha call drift_kepu_stumpff ( x , c0 , c1 , c2 , c3 ) c1 = c1 * s c2 = c2 * s ** 2 c3 = c3 * s ** 3 f = r0 * c1 + u * c2 + mu * c3 - dt return end subroutine drift_kepu_fchk pure subroutine drift_kepu_guess ( dt , r0 , mu , alpha , u , s ) !! author: David A. Minton !! !! Compute initial guess for solving Kepler's equation using universal variables !! !! Adapted from David E. Kaufmann's Swifter routine: drift_kepu_guess.f90 !! Adapted from Hal Levison and Martin Duncan's Swift routine drift_kepu_guess.f implicit none real ( DP ), intent ( in ) :: dt , r0 , mu , alpha , u real ( DP ), intent ( out ) :: s integer ( I4B ) :: iflag real ( DP ), parameter :: thresh = 0.4_DP , danbyk = 0.85_DP real ( DP ) :: y , sy , cy , sigma , es , x , a , en , ec , e if ( alpha > 0.0_DP ) then if ( dt / r0 <= thresh ) then s = dt / r0 - ( dt ** 2 * u ) / ( 2 * r0 ** 3 ) else a = mu / alpha en = sqrt ( mu / a ** 3 ) ec = 1.0_DP - r0 / a es = u / ( en * a ** 2 ) e = sqrt ( ec ** 2 + es ** 2 ) y = en * dt - es call orbel_scget ( y , sy , cy ) sigma = sign ( 1.0_DP , es * cy + ec * sy ) x = y + sigma * danbyk * e s = x / sqrt ( alpha ) end if else call drift_kepu_p3solve ( dt , r0 , mu , alpha , u , s , iflag ) if ( iflag /= 0 ) s = dt / r0 end if return end subroutine drift_kepu_guess pure subroutine drift_kepu_lag ( s , dt , r0 , mu , alpha , u , fp , c1 , c2 , c3 , iflag ) !! author: David A. Minton !! !! Solve Kepler's equation in universal variables using Laguerre's method !!      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 178 - 180. !! !! Adapted from David E. Kaufmann's Swifter routine: drift_kepu_lag.f90 !! Adapted from Hal Levison's Swift routine drift_kepu_lag.f implicit none integer ( I4B ), intent ( out ) :: iflag real ( DP ), intent ( in ) :: dt , r0 , mu , alpha , u real ( DP ), intent ( inout ) :: s real ( DP ), intent ( out ) :: fp , c1 , c2 , c3 integer ( I4B ) :: nc , ncmax real ( DP ) :: ln , x , fpp , ds , c0 , f , fdt if ( alpha < 0.0_DP ) then ncmax = NLAG2 else ncmax = NLAG1 end if ln = 5.0_DP do nc = 0 , ncmax x = s * s * alpha call drift_kepu_stumpff ( x , c0 , c1 , c2 , c3 ) c1 = c1 * s c2 = c2 * s ** 2 c3 = c3 * s ** 3 f = r0 * c1 + u * c2 + mu * c3 - dt fp = r0 * c0 + u * c1 + mu * c2 fpp = ( - r0 * alpha + mu ) * c1 + u * c0 ds = - ln * f / ( fp + sign ( 1.0_DP , fp ) * sqrt ( abs (( ln - 1.0_DP ) ** 2 * fp ** 2 - ( ln - 1.0_DP ) * ln * f * fpp ))) s = s + ds fdt = f / dt if ( fdt ** 2 < DANBYB ** 2 ) then iflag = 0 return end if end do iflag = 2 return end subroutine drift_kepu_lag pure subroutine drift_kepu_new ( s , dt , r0 , mu , alpha , u , fp , c1 , c2 , c3 , iflag ) !! author: David A. Minton !! !! Solve Kepler's equation in universal variables using Newton's method !!      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 174 - 175. !! !! Adapted from David E. Kaufmann's Swifter routine: drift_kepu_new.f90 !! Adapted from Hal Levison's Swift routine drift_kepu_new.f implicit none integer ( I4B ), intent ( out ) :: iflag real ( DP ), intent ( in ) :: dt , r0 , mu , alpha , u real ( DP ), intent ( inout ) :: s real ( DP ), intent ( out ) :: fp , c1 , c2 , c3 integer ( I4B ) :: nc real ( DP ) :: x , c0 , ds , f , fpp , fppp , fdt do nc = 0 , 6 x = s ** 2 * alpha call drift_kepu_stumpff ( x , c0 , c1 , c2 , c3 ) c1 = c1 * s c2 = c2 * s ** 2 c3 = c3 * s ** 3 f = r0 * c1 + u * c2 + mu * c3 - dt fp = r0 * c0 + u * c1 + mu * c2 fpp = ( - r0 * alpha + mu ) * c1 + u * c0 fppp = ( - r0 * alpha + mu ) * c0 - u * alpha * c1 ds = - f / fp ds = - f / ( fp + ds * fpp / 2.0_DP ) ds = - f / ( fp + ds * fpp / 2.0_DP + ds ** 2 * fppp / 6.0_DP ) s = s + ds fdt = f / dt if ( fdt ** 2 < DANBYB ** 2 ) then iflag = 0 return end if end do iflag = 1 return end subroutine drift_kepu_new pure subroutine drift_kepu_p3solve ( dt , r0 , mu , alpha , u , s , iflag ) !! author: David A. Minton !! !! Computes real root of cubic involved in setting initial guess for solving Kepler's equation in universal variables !!      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 177 - 178. !! !! Adapted from David E. Kaufmann's Swifter routine: drift_kepu_p3solve.f90 !! Adapted from Martin Duncan's Swift routine drift_kepu_p3solve.f implicit none integer ( I4B ), intent ( out ) :: iflag real ( DP ), intent ( in ) :: dt , r0 , mu , alpha , u real ( DP ), intent ( out ) :: s real ( DP ) :: denom , a0 , a1 , a2 , q , r , sq2 , sq , p1 , p2 denom = ( mu - alpha * r0 ) / 6.0_DP a2 = 0.5_DP * u / denom a1 = r0 / denom a0 = - dt / denom q = ( a1 - a2 ** 2 / 3.0_DP ) / 3.0_DP r = ( a1 * a2 - 3 * a0 ) / 6.0_DP - a2 ** 3 / 2 7.0_DP sq2 = q ** 3 + r ** 2 if ( sq2 >= 0.0_DP ) then sq = sqrt ( sq2 ) if (( r + sq ) <= 0.0_DP ) then p1 = - ( - ( r + sq )) ** ( 1.0_DP / 3.0_DP ) else p1 = ( r + sq ) ** ( 1.0_DP / 3.0_DP ) end if if (( r - sq ) <= 0.0_DP ) then p2 = - ( - ( r - sq )) ** ( 1.0_DP / 3.0_DP ) else p2 = ( r - sq ) ** ( 1.0_DP / 3.0_DP ) end if iflag = 0 s = p1 + p2 - a2 / 3.0_DP else iflag = 1 s = 0.0_DP end if return end subroutine drift_kepu_p3solve pure subroutine drift_kepu_stumpff ( x , c0 , c1 , c2 , c3 ) !! author: David A. Minton !! !! Compute Stumpff functions needed for Kepler drift in universal variables !!      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 171 - 172. !! !! Adapted from David E. Kaufmann's Swifter routine: drift_kepu_stumpff.f90 !! Adapted from Hal Levison's Swift routine drift_kepu_stumpff.f implicit none real ( DP ), intent ( inout ) :: x real ( DP ), intent ( out ) :: c0 , c1 , c2 , c3 integer ( I4B ) :: i , n real ( DP ) :: xm n = 0 xm = 0.1_DP do while ( abs ( x ) >= xm ) n = n + 1 x = x / 4.0_DP end do c2 = ( 1.0_DP - x * ( 1.0_DP - x * ( 1.0_DP - x * ( 1.0_DP - x * ( 1.0_DP - x * & ( 1.0_DP - x / 18 2.0_DP ) / 13 2.0_DP ) / 9 0.0_DP ) / 5 6.0_DP ) / & 3 0.0_DP ) / 1 2.0_DP ) / 2.0_DP c3 = ( 1.0_DP - x * ( 1.0_DP - x * ( 1.0_DP - x * ( 1.0_DP - x * ( 1.0_DP - x * & ( 1.0_DP - x / 21 0.0_DP ) / 15 6.0_DP ) / 11 0.0_DP ) / 7 2.0_DP ) / & 4 2.0_DP ) / 2 0.0_DP ) / 6.0_DP c1 = 1.0_DP - x * c3 c0 = 1.0_DP - x * c2 if ( n /= 0 ) then do i = n , 1 , - 1 c3 = ( c2 + c0 * c3 ) / 4.0_DP c2 = c1 ** 2 / 2.0_DP c1 = c0 * c1 c0 = 2 * c0 ** 2 - 1.0_DP x = x * 4 end do end if return end subroutine drift_kepu_stumpff end submodule drift_implementation","tags":"","loc":"sourcefile/drift.f90.html"},{"title":"symba_util.f90 – swiftest","text":"This file depends on sourcefile~~symba_util.f90~~EfferentGraph sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_util.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_symba_util Source Code symba_util.f90 Source Code submodule ( symba_classes ) s_symba_util use swiftest contains module subroutine symba_util_append_arr_info ( arr , source , nold , nsrc , lsource_mask ) !! author: David A. Minton !! !! Append a single array of particle information type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. implicit none ! Arguments type ( symba_particle_info ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array type ( symba_particle_info ), dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to if (. not . allocated ( source )) return if (. not . allocated ( arr )) then allocate ( arr ( nold + nsrc )) else call util_resize ( arr , nold + nsrc ) end if arr ( nold + 1 : nold + nsrc ) = pack ( source ( 1 : nsrc ), lsource_mask ( 1 : nsrc )) return end subroutine symba_util_append_arr_info module subroutine symba_util_append_arr_kin ( arr , source , nold , nsrc , lsource_mask ) !! author: David A. Minton !! !! Append a single array of kinship type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. implicit none ! Arguments type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array type ( symba_kinship ), dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to if (. not . allocated ( source )) return if (. not . allocated ( arr )) then allocate ( arr ( nold + nsrc )) else call util_resize ( arr , nold + nsrc ) end if arr ( nold + 1 : nold + nsrc ) = pack ( source ( 1 : nsrc ), lsource_mask ( 1 : nsrc )) return end subroutine symba_util_append_arr_kin module subroutine symba_util_append_pl ( self , source , lsource_mask ) !! author: David A. Minton !! !! Append components from one massive body object to another. !! This method will automatically resize the destination body if it is too small implicit none !! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to select type ( source ) class is ( symba_pl ) associate ( nold => self % nbody , nsrc => source % nbody ) call util_append ( self % lcollision , source % lcollision , nold , nsrc , lsource_mask ) call util_append ( self % lencounter , source % lencounter , nold , nsrc , lsource_mask ) call util_append ( self % lmtiny , source % lmtiny , nold , nsrc , lsource_mask ) call util_append ( self % nplenc , source % nplenc , nold , nsrc , lsource_mask ) call util_append ( self % ntpenc , source % ntpenc , nold , nsrc , lsource_mask ) call util_append ( self % levelg , source % levelg , nold , nsrc , lsource_mask ) call util_append ( self % levelm , source % levelm , nold , nsrc , lsource_mask ) call util_append ( self % isperi , source % isperi , nold , nsrc , lsource_mask ) call util_append ( self % peri , source % peri , nold , nsrc , lsource_mask ) call util_append ( self % atp , source % atp , nold , nsrc , lsource_mask ) call util_append ( self % kin , source % kin , nold , nsrc , lsource_mask ) call util_append ( self % info , source % info , nold , nsrc , lsource_mask ) call util_append_pl ( self , source , lsource_mask ) ! Note: helio_pl does not have its own append method, so we skip back to the base class end associate class default write ( * , * ) \"Invalid object passed to the append method. Source must be of class symba_pl or its descendents!\" call util_exit ( FAILURE ) end select return end subroutine symba_util_append_pl module subroutine symba_util_append_merger ( self , source , lsource_mask ) !! author: David A. Minton !! !! Append components from one massive body object to another. !! This method will automatically resize the destination body if it is too small implicit none ! Arguments class ( symba_merger ), intent ( inout ) :: self !! SyMBA massive body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to ! Internals integer ( I4B ), dimension (:), allocatable :: ncomp_tmp !! Temporary placeholder for ncomp incase we are appending a symba_pl object to a symba_merger integer ( I4B ) :: nold , nsrc nold = self % nbody nsrc = source % nbody select type ( source ) class is ( symba_merger ) call util_append ( self % ncomp , source % ncomp , nold , nsrc , lsource_mask ) call symba_util_append_pl ( self , source , lsource_mask ) class is ( symba_pl ) allocate ( ncomp_tmp , mold = source % id ) ncomp_tmp (:) = 0 call util_append ( self % ncomp , ncomp_tmp , nold , nsrc , lsource_mask ) call symba_util_append_pl ( self , source , lsource_mask ) class default write ( * , * ) \"Invalid object passed to the append method. Source must be of class symba_pl or its descendents!\" call util_exit ( FAILURE ) end select ! Save the number of appended bodies self % ncomp ( nold + 1 : nold + nsrc ) = nsrc return end subroutine symba_util_append_merger module subroutine symba_util_append_tp ( self , source , lsource_mask ) !! author: David A. Minton !! !! Append components from test particle object to another. !! This method will automatically resize the destination body if it is too small implicit none !! Arguments class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to select type ( source ) class is ( symba_tp ) associate ( nold => self % nbody , nsrc => source % nbody ) call util_append ( self % nplenc , source % nplenc , nold , nsrc , lsource_mask ) call util_append ( self % levelg , source % levelg , nold , nsrc , lsource_mask ) call util_append ( self % levelm , source % levelm , nold , nsrc , lsource_mask ) call util_append ( self % info , source % info , nold , nsrc , lsource_mask ) call util_append_tp ( self , source , lsource_mask ) ! Note: helio_tp does not have its own append method, so we skip back to the base class end associate class default write ( * , * ) \"Invalid object passed to the append method. Source must be of class symba_tp or its descendents!\" call util_exit ( FAILURE ) end select return end subroutine symba_util_append_tp module subroutine symba_util_fill_arr_info ( keeps , inserts , lfill_list ) !! author: David A. Minton !! !! Performs a fill operation on a single array of particle origin information types !! This is the inverse of a spill operation implicit none ! Arguments type ( symba_particle_info ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep type ( symba_particle_info ), dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps if (. not . allocated ( keeps ) . or . . not . allocated ( inserts )) return keeps (:) = unpack ( keeps (:), . not . lfill_list (:), keeps (:)) keeps (:) = unpack ( inserts (:), lfill_list (:), keeps (:)) return end subroutine symba_util_fill_arr_info module subroutine symba_util_fill_arr_kin ( keeps , inserts , lfill_list ) !! author: David A. Minton !! !! Performs a fill operation on a single array of particle kinship types !! This is the inverse of a spill operation implicit none ! Arguments type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep type ( symba_kinship ), dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps if (. not . allocated ( keeps ) . or . . not . allocated ( inserts )) return keeps (:) = unpack ( keeps (:), . not . lfill_list (:), keeps (:)) keeps (:) = unpack ( inserts (:), lfill_list (:), keeps (:)) return end subroutine symba_util_fill_arr_kin module subroutine symba_util_fill_pl ( self , inserts , lfill_list ) !! author: David A. Minton !! !! Insert new SyMBA test particle structure into an old one. !! This is the inverse of a fill operation. !! implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA masive body object class ( swiftest_body ), intent ( in ) :: inserts !! Inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps associate ( keeps => self ) select type ( inserts ) class is ( symba_pl ) call util_fill ( keeps % lcollision , inserts % lcollision , lfill_list ) call util_fill ( keeps % lencounter , inserts % lencounter , lfill_list ) call util_fill ( keeps % lmtiny , inserts % lmtiny , lfill_list ) call util_fill ( keeps % nplenc , inserts % nplenc , lfill_list ) call util_fill ( keeps % ntpenc , inserts % ntpenc , lfill_list ) call util_fill ( keeps % levelg , inserts % levelg , lfill_list ) call util_fill ( keeps % levelm , inserts % levelm , lfill_list ) call util_fill ( keeps % isperi , inserts % isperi , lfill_list ) call util_fill ( keeps % peri , inserts % peri , lfill_list ) call util_fill ( keeps % atp , inserts % atp , lfill_list ) call util_fill ( keeps % kin , inserts % kin , lfill_list ) call util_fill ( keeps % info , inserts % info , lfill_list ) call util_fill_pl ( keeps , inserts , lfill_list ) ! Note: helio_pl does not have its own fill method, so we skip back to the base class class default write ( * , * ) \"Invalid object passed to the fill method. Source must be of class symba_pl or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine symba_util_fill_pl module subroutine symba_util_fill_tp ( self , inserts , lfill_list ) !! author: David A. Minton !! !! Insert new SyMBA test particle structure into an old one. !! This is the inverse of a fill operation. !! implicit none ! Arguments class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object class ( swiftest_body ), intent ( in ) :: inserts !! Inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps associate ( keeps => self ) select type ( inserts ) class is ( symba_tp ) call util_fill ( keeps % nplenc , inserts % nplenc , lfill_list ) call util_fill ( keeps % levelg , inserts % levelg , lfill_list ) call util_fill ( keeps % levelm , inserts % levelm , lfill_list ) call util_fill ( keeps % info , inserts % info , lfill_list ) call util_fill_tp ( keeps , inserts , lfill_list ) ! Note: helio_tp does not have its own fill method, so we skip back to the base class class default write ( * , * ) \"Invalid object passed to the fill method. Source must be of class symba_tp or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine symba_util_fill_tp module subroutine symba_util_peri_pl ( self , system , param ) !! author: David A. Minton !! !! Determine system pericenter passages for planets in SyMBA !! !! Adapted from David E. Kaufmann's Swifter routine: symba_peri.f90 !! Adapted from Hal Levison's Swift routine util_mass_peri.f implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i real ( DP ) :: vdotr , e associate ( pl => self , npl => self % nbody ) if ( pl % lfirst ) then if ( param % qmin_coord == \"HELIO\" ) then do i = 1 , npl if ( pl % status ( i ) == ACTIVE ) then vdotr = dot_product ( pl % xh (:, i ), pl % vh (:, i )) if ( vdotr > 0.0_DP ) then pl % isperi ( i ) = 1 else pl % isperi ( i ) = - 1 end if end if end do else do i = 1 , npl if ( pl % status ( i ) == ACTIVE ) then vdotr = dot_product ( pl % xb (:, i ), pl % vb (:, i )) if ( vdotr > 0.0_DP ) then pl % isperi ( i ) = 1 else pl % isperi ( i ) = - 1 end if end if end do end if else if ( param % qmin_coord == \"HELIO\" ) then do i = 1 , npl if ( pl % status ( i ) == ACTIVE ) then vdotr = dot_product ( pl % xh (:, i ), pl % vh (:, i )) if ( pl % isperi ( i ) == - 1 ) then if ( vdotr >= 0.0_DP ) then pl % isperi ( i ) = 0 CALL orbel_xv2aeq ( pl % mu ( i ), pl % xh (:, i ), pl % vh (:, i ), pl % atp ( i ), e , pl % peri ( i )) end if else if ( vdotr > 0.0_DP ) then pl % isperi ( i ) = 1 else pl % isperi ( i ) = - 1 end if end if end if end do else do i = 1 , npl if ( pl % status ( i ) == ACTIVE ) then vdotr = dot_product ( pl % xb (:, i ), pl % vb (:, i )) if ( pl % isperi ( i ) == - 1 ) then if ( vdotr >= 0.0_DP ) then pl % isperi ( i ) = 0 CALL orbel_xv2aeq ( system % Gmtot , pl % xb (:, i ), pl % vb (:, i ), pl % atp ( i ), e , pl % peri ( i )) end if else if ( vdotr > 0.0_DP ) then pl % isperi ( i ) = 1 else pl % isperi ( i ) = - 1 end if end if end if end do end if end if end associate return end subroutine symba_util_peri_pl module subroutine symba_util_rearray_pl ( self , system , param ) !! Author: the Purdue Swiftest Team -  David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Clean up the massive body structures to remove discarded bodies and add new bodies implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object class ( symba_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( symba_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals class ( symba_pl ), allocatable :: tmp !! The discarded body list. integer ( I4B ) :: i logical , dimension (:), allocatable :: lmask associate ( pl => self , pl_adds => system % pl_adds ) allocate ( tmp , mold = pl ) ! Remove the discards and destroy the list, as the system already tracks pl_discards elsewhere allocate ( lmask , source = pl % ldiscard (:)) lmask (:) = lmask (:) . or . pl % status (:) == INACTIVE call pl % spill ( tmp , lspill_list = lmask , ldestructive = . true .) call tmp % setup ( 0 , param ) deallocate ( tmp ) ! Deallocate any temporary variables if ( allocated ( pl % xbeg )) deallocate ( pl % xbeg ) if ( allocated ( pl % xend )) deallocate ( pl % xend ) ! Add in any new bodies if ( pl_adds % nbody > 0 ) then call pl % append ( pl_adds , lsource_mask = [(. true ., i = 1 , pl_adds % nbody )]) call symba_io_dump_particle_info ( system , param , plidx = [( i , i = 1 , pl % nbody )]) end if ! If there are still bodies in the system, sort by mass in descending order and re-index if ( pl % nbody > 0 ) then call pl % sort ( \"mass\" , ascending = . false .) pl % lmtiny (:) = pl % Gmass (:) > param % GMTINY pl % nplm = count ( pl % lmtiny (:)) call pl % eucl_index () end if end associate return end subroutine symba_util_rearray_pl module subroutine symba_util_resize_arr_info ( arr , nnew ) !! author: David A. Minton !! !! Resizes an array component of type character string. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. implicit none ! Arguments type ( symba_particle_info ), dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size ! Internals type ( symba_particle_info ), dimension (:), allocatable :: tmp !! Temporary storage array in case the input array is already allocated integer ( I4B ) :: nold !! Old size if (. not . allocated ( arr ) . or . nnew < 0 ) return nold = size ( arr ) if ( nnew == nold ) return if ( nnew == 0 ) then deallocate ( arr ) return end if allocate ( tmp ( nnew )) if ( nnew > nold ) then tmp ( 1 : nold ) = arr ( 1 : nold ) else tmp ( 1 : nnew ) = arr ( 1 : nnew ) end if call move_alloc ( tmp , arr ) return end subroutine symba_util_resize_arr_info module subroutine symba_util_resize_arr_kin ( arr , nnew ) !! author: David A. Minton !! !! Resizes an array component of type character string. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. implicit none ! Arguments type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size ! Internals type ( symba_kinship ), dimension (:), allocatable :: tmp !! Temporary storage array in case the input array is already allocated integer ( I4B ) :: nold !! Old size if (. not . allocated ( arr ) . or . nnew < 0 ) return nold = size ( arr ) if ( nnew == nold ) return if ( nnew == 0 ) then deallocate ( arr ) return end if allocate ( tmp ( nnew )) if ( nnew > nold ) then tmp ( 1 : nold ) = arr ( 1 : nold ) else tmp ( 1 : nnew ) = arr ( 1 : nnew ) end if call move_alloc ( tmp , arr ) return end subroutine symba_util_resize_arr_kin module subroutine symba_util_resize_merger ( self , nnew ) !! author: David A. Minton !! !! Checks the current size of a SyMBA merger list against the requested size and resizes it if it is too small. implicit none ! Arguments class ( symba_merger ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), intent ( in ) :: nnew !! New size neded call util_resize ( self % ncomp , nnew ) call symba_util_resize_pl ( self , nnew ) return end subroutine symba_util_resize_merger module subroutine symba_util_resize_pl ( self , nnew ) !! author: David A. Minton !! !! Checks the current size of a SyMBA massive body object against the requested size and resizes it if it is too small. implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), intent ( in ) :: nnew !! New size neded call util_resize ( self % lcollision , nnew ) call util_resize ( self % lencounter , nnew ) call util_resize ( self % lmtiny , nnew ) call util_resize ( self % nplenc , nnew ) call util_resize ( self % ntpenc , nnew ) call util_resize ( self % levelg , nnew ) call util_resize ( self % levelm , nnew ) call util_resize ( self % isperi , nnew ) call util_resize ( self % peri , nnew ) call util_resize ( self % atp , nnew ) call util_resize ( self % kin , nnew ) call util_resize ( self % info , nnew ) call util_resize_pl ( self , nnew ) return end subroutine symba_util_resize_pl module subroutine symba_util_resize_tp ( self , nnew ) !! author: David A. Minton !! !! Checks the current size of a test particle object against the requested size and resizes it if it is too small. implicit none ! Arguments class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object integer ( I4B ), intent ( in ) :: nnew !! New size neded call util_resize ( self % nplenc , nnew ) call util_resize ( self % levelg , nnew ) call util_resize ( self % levelm , nnew ) call util_resize ( self % info , nnew ) call util_resize_tp ( self , nnew ) return end subroutine symba_util_resize_tp module subroutine symba_util_sort_pl ( self , sortby , ascending ) !! author: David A. Minton !! !! Sort a SyMBA massive body object in-place. !! sortby is a string indicating which array component to sort. implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order ! Internals integer ( I4B ), dimension ( self % nbody ) :: ind integer ( I4B ) :: direction if ( self % nbody == 0 ) return if ( ascending ) then direction = 1 else direction = - 1 end if associate ( pl => self , npl => self % nbody ) select case ( sortby ) case ( \"nplenc\" ) call util_sort ( direction * pl % nplenc ( 1 : npl ), ind ( 1 : npl )) case ( \"ntpenc\" ) call util_sort ( direction * pl % ntpenc ( 1 : npl ), ind ( 1 : npl )) case ( \"levelg\" ) call util_sort ( direction * pl % levelg ( 1 : npl ), ind ( 1 : npl )) case ( \"levelm\" ) call util_sort ( direction * pl % levelm ( 1 : npl ), ind ( 1 : npl )) case ( \"peri\" ) call util_sort ( direction * pl % peri ( 1 : npl ), ind ( 1 : npl )) case ( \"atp\" ) call util_sort ( direction * pl % atp ( 1 : npl ), ind ( 1 : npl )) case ( \"lcollision\" , \"lencounter\" , \"lmtiny\" , \"nplm\" , \"nplplm\" , \"kin\" , \"info\" ) write ( * , * ) 'Cannot sort by ' // trim ( adjustl ( sortby )) // '. Component not sortable!' case default ! Look for components in the parent class call util_sort_pl ( pl , sortby , ascending ) return end select call pl % rearrange ( ind ) end associate return end subroutine symba_util_sort_pl module subroutine symba_util_sort_tp ( self , sortby , ascending ) !! author: David A. Minton !! !! Sort a SyMBA test particle object in-place. !! sortby is a string indicating which array component to sort. implicit none ! Arguments class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order ! Internals integer ( I4B ), dimension ( self % nbody ) :: ind integer ( I4B ) :: direction if ( self % nbody == 0 ) return if ( ascending ) then direction = 1 else direction = - 1 end if associate ( tp => self , ntp => self % nbody ) select case ( sortby ) case ( \"nplenc\" ) call util_sort ( direction * tp % nplenc ( 1 : ntp ), ind ( 1 : ntp )) case ( \"levelg\" ) call util_sort ( direction * tp % levelg ( 1 : ntp ), ind ( 1 : ntp )) case ( \"levelm\" ) call util_sort ( direction * tp % levelm ( 1 : ntp ), ind ( 1 : ntp )) case default ! Look for components in the parent class call util_sort_tp ( tp , sortby , ascending ) return end select call tp % rearrange ( ind ) end associate return end subroutine symba_util_sort_tp module subroutine symba_util_sort_rearrange_pl ( self , ind ) !! author: David A. Minton !! !! Rearrange SyMBA massive body structure in-place from an index list. !! This is a helper utility used to make polymorphic sorting work on Swiftest structures. implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) ! Internals class ( symba_pl ), allocatable :: pl_sorted !! Temporary holder for sorted body integer ( I4B ) :: i , j associate ( pl => self , npl => self % nbody ) call util_sort_rearrange_pl ( pl , ind ) allocate ( pl_sorted , source = self ) if ( allocated ( pl % lcollision )) pl % lcollision ( 1 : npl ) = pl_sorted % lcollision ( ind ( 1 : npl )) if ( allocated ( pl % lencounter )) pl % lencounter ( 1 : npl ) = pl_sorted % lencounter ( ind ( 1 : npl )) if ( allocated ( pl % lmtiny )) pl % lmtiny ( 1 : npl ) = pl_sorted % lmtiny ( ind ( 1 : npl )) if ( allocated ( pl % nplenc )) pl % nplenc ( 1 : npl ) = pl_sorted % nplenc ( ind ( 1 : npl )) if ( allocated ( pl % ntpenc )) pl % ntpenc ( 1 : npl ) = pl_sorted % ntpenc ( ind ( 1 : npl )) if ( allocated ( pl % levelg )) pl % levelg ( 1 : npl ) = pl_sorted % levelg ( ind ( 1 : npl )) if ( allocated ( pl % levelm )) pl % levelm ( 1 : npl ) = pl_sorted % levelm ( ind ( 1 : npl )) if ( allocated ( pl % isperi )) pl % isperi ( 1 : npl ) = pl_sorted % isperi ( ind ( 1 : npl )) if ( allocated ( pl % peri )) pl % peri ( 1 : npl ) = pl_sorted % peri ( ind ( 1 : npl )) if ( allocated ( pl % atp )) pl % atp ( 1 : npl ) = pl_sorted % atp ( ind ( 1 : npl )) if ( allocated ( pl % info )) pl % info ( 1 : npl ) = pl_sorted % info ( ind ( 1 : npl )) if ( allocated ( pl % kin )) then pl % kin ( 1 : npl ) = pl_sorted % kin ( ind ( 1 : npl )) do i = 1 , npl do j = 1 , pl % kin ( i )% nchild pl % kin ( i )% child ( j ) = ind ( pl % kin ( i )% child ( j )) end do end do end if deallocate ( pl_sorted ) end associate return end subroutine symba_util_sort_rearrange_pl module subroutine symba_util_sort_rearrange_tp ( self , ind ) !! author: David A. Minton !! !! Rearrange SyMBA test particle object in-place from an index list. !! This is a helper utility used to make polymorphic sorting work on Swiftest structures. implicit none ! Arguments class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) ! Internals class ( symba_tp ), allocatable :: tp_sorted !! Temporary holder for sorted body associate ( tp => self , ntp => self % nbody ) call util_sort_rearrange_tp ( tp , ind ) allocate ( tp_sorted , source = self ) if ( allocated ( tp % nplenc )) tp % nplenc ( 1 : ntp ) = tp_sorted % nplenc ( ind ( 1 : ntp )) if ( allocated ( tp % levelg )) tp % levelg ( 1 : ntp ) = tp_sorted % levelg ( ind ( 1 : ntp )) if ( allocated ( tp % levelm )) tp % levelm ( 1 : ntp ) = tp_sorted % levelm ( ind ( 1 : ntp )) if ( allocated ( tp % info )) tp % info ( 1 : ntp ) = tp_sorted % info ( ind ( 1 : ntp )) deallocate ( tp_sorted ) end associate return end subroutine symba_util_sort_rearrange_tp module subroutine symba_util_spill_arr_info ( keeps , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Performs a spill operation on a single array of particle origin information types !! This is the inverse of a spill operation implicit none ! Arguments type ( symba_particle_info ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep type ( symba_particle_info ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discardss logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not if (. not . allocated ( keeps ) . or . count ( lspill_list (:)) == 0 ) return if (. not . allocated ( discards )) allocate ( discards ( count ( lspill_list (:)))) discards (:) = pack ( keeps (:), lspill_list (:)) if ( ldestructive ) then if ( count (. not . lspill_list (:)) > 0 ) then keeps (:) = pack ( keeps (:), . not . lspill_list (:)) else deallocate ( keeps ) end if end if return end subroutine symba_util_spill_arr_info module subroutine symba_util_spill_arr_kin ( keeps , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Performs a spill operation on a single array of particle kinships !! This is the inverse of a spill operation implicit none ! Arguments type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discardss logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not if (. not . allocated ( keeps ) . or . count ( lspill_list (:)) == 0 ) return if (. not . allocated ( discards )) allocate ( discards ( count ( lspill_list (:)))) discards (:) = pack ( keeps (:), lspill_list (:)) if ( ldestructive ) then if ( count (. not . lspill_list (:)) > 0 ) then keeps (:) = pack ( keeps (:), . not . lspill_list (:)) else deallocate ( keeps ) end if end if return end subroutine symba_util_spill_arr_kin module subroutine symba_util_spill_pl ( self , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Move spilled (discarded) SyMBA massive body particle structure from active list to discard list !! Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter body by removing the discard list ! Internals integer ( I4B ) :: i ! For each component, pack the discarded bodies into the discard object and do the inverse with the keeps !> Spill all the common components associate ( keeps => self ) select type ( discards ) class is ( symba_pl ) call util_spill ( keeps % lcollision , discards % lcollision , lspill_list , ldestructive ) call util_spill ( keeps % lencounter , discards % lencounter , lspill_list , ldestructive ) call util_spill ( keeps % lmtiny , discards % lmtiny , lspill_list , ldestructive ) call util_spill ( keeps % nplenc , discards % nplenc , lspill_list , ldestructive ) call util_spill ( keeps % ntpenc , discards % ntpenc , lspill_list , ldestructive ) call util_spill ( keeps % levelg , discards % levelg , lspill_list , ldestructive ) call util_spill ( keeps % levelm , discards % levelm , lspill_list , ldestructive ) call util_spill ( keeps % isperi , discards % isperi , lspill_list , ldestructive ) call util_spill ( keeps % peri , discards % peri , lspill_list , ldestructive ) call util_spill ( keeps % atp , discards % atp , lspill_list , ldestructive ) call util_spill ( keeps % info , discards % info , lspill_list , ldestructive ) call util_spill ( keeps % kin , discards % kin , lspill_list , ldestructive ) call util_spill_pl ( keeps , discards , lspill_list , ldestructive ) class default write ( * , * ) \"Invalid object passed to the spill method. Source must be of class symba_pl or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine symba_util_spill_pl module subroutine symba_util_spill_pltpenc ( self , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Move spilled (discarded) SyMBA encounter structure from active list to discard list !! Note: Because the symba_plplenc currently does not contain any additional variable components, this method can recieve it as an input as well. implicit none ! Arguments class ( symba_pltpenc ), intent ( inout ) :: self !! SyMBA pl-tp encounter list class ( swiftest_encounter ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter body by removing the discard list ! Internals integer ( I4B ) :: i associate ( keeps => self ) select type ( discards ) class is ( symba_pltpenc ) call util_spill ( keeps % level , discards % level , lspill_list , ldestructive ) call util_spill_encounter ( keeps , discards , lspill_list , ldestructive ) class default write ( * , * ) \"Invalid object passed to the spill method. Source must be of class symba_pltpenc or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine symba_util_spill_pltpenc module subroutine symba_util_spill_tp ( self , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Move spilled (discarded) SyMBA test particle structure from active list to discard list !! Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 implicit none ! Arguments class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter body by removing the discard list ! Internals integer ( I4B ) :: i ! For each component, pack the discarded bodies into the discard object and do the inverse with the keeps !> Spill all the common components associate ( keeps => self ) select type ( discards ) class is ( symba_tp ) call util_spill ( keeps % nplenc , discards % nplenc , lspill_list , ldestructive ) call util_spill ( keeps % levelg , discards % levelg , lspill_list , ldestructive ) call util_spill ( keeps % levelm , discards % levelm , lspill_list , ldestructive ) call util_spill ( keeps % info , discards % info , lspill_list , ldestructive ) call util_spill_tp ( keeps , discards , lspill_list , ldestructive ) class default write ( * , * ) \"Invalid object passed to the spill method. Source must be of class symba_tp or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine symba_util_spill_tp end submodule s_symba_util","tags":"","loc":"sourcefile/symba_util.f90.html"},{"title":"symba_collision.f90 – swiftest","text":"This file depends on sourcefile~~symba_collision.f90~~EfferentGraph sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_collision.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_symba_collision Source Code symba_collision.f90 Source Code submodule ( symba_classes ) s_symba_collision use swiftest contains module subroutine symba_collision_check_pltpenc ( self , system , param , t , dt , irec ) !! author: David A. Minton !! !! Check for merger between massive bodies and test particles in SyMBA !! !! Adapted from David E. Kaufmann's Swifter routine symba_merge.f90 and symba_merge_tp.f90 !! !! Adapted from Hal Levison's Swift routine symba5_merge.f implicit none ! Arguments class ( symba_pltpenc ), intent ( inout ) :: self !! SyMBA pl-tp encounter list object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! current time real ( DP ), intent ( in ) :: dt !! step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level ! Internals logical , dimension (:), allocatable :: lcollision , lmask real ( DP ), dimension ( NDIM ) :: xr , vr integer ( I4B ) :: k real ( DP ) :: rlim , Gmtot logical :: isplpl if ( self % nenc == 0 ) return select type ( self ) class is ( symba_plplenc ) isplpl = . true . class default isplpl = . false . end select select type ( pl => system % pl ) class is ( symba_pl ) select type ( tp => system % tp ) class is ( symba_tp ) associate ( nenc => self % nenc , ind1 => self % index1 , ind2 => self % index2 ) allocate ( lmask ( nenc )) lmask (:) = (( self % status ( 1 : nenc ) == ACTIVE ) . and . ( pl % levelg ( ind1 ( 1 : nenc )) >= irec )) if ( isplpl ) then lmask (:) = lmask (:) . and . ( pl % levelg ( ind2 ( 1 : nenc )) >= irec ) else lmask (:) = lmask (:) . and . ( tp % levelg ( ind2 ( 1 : nenc )) >= irec ) end if if (. not . any ( lmask (:))) return allocate ( lcollision ( nenc )) lcollision (:) = . false . if ( isplpl ) then do concurrent ( k = 1 : nenc , lmask ( k )) xr (:) = pl % xh (:, ind1 ( k )) - pl % xh (:, ind2 ( k )) vr (:) = pl % vb (:, ind1 ( k )) - pl % vb (:, ind2 ( k )) rlim = pl % radius ( ind1 ( k )) + pl % radius ( ind2 ( k )) Gmtot = pl % Gmass ( ind1 ( k )) + pl % Gmass ( ind2 ( k )) lcollision ( k ) = symba_collision_check_one ( xr ( 1 ), xr ( 2 ), xr ( 3 ), vr ( 1 ), vr ( 2 ), vr ( 3 ), Gmtot , rlim , dt , self % lvdotr ( k )) end do else do concurrent ( k = 1 : nenc , lmask ( k )) xr (:) = pl % xh (:, ind1 ( k )) - tp % xh (:, ind2 ( k )) vr (:) = pl % vb (:, ind1 ( k )) - tp % vb (:, ind2 ( k )) lcollision ( k ) = symba_collision_check_one ( xr ( 1 ), xr ( 2 ), xr ( 3 ), vr ( 1 ), vr ( 2 ), vr ( 3 ), pl % Gmass ( ind1 ( k )), pl % radius ( ind1 ( k )), dt , self % lvdotr ( k )) end do end if if ( any ( lcollision (:))) then do k = 1 , nenc if (. not . lcollision ( k )) cycle self % status ( k ) = COLLISION self % x1 (:, k ) = pl % xh (:, ind1 ( k )) self % v1 (:, k ) = pl % vb (:, ind1 ( k )) if ( isplpl ) then self % x2 (:, k ) = pl % xh (:, ind2 ( k )) self % v2 (:, k ) = pl % vb (:, ind2 ( k )) ! Check to see if either of these bodies has been involved with a collision before, and if so, make this a collisional family if ( pl % lcollision ( ind1 ( k )) . or . pl % lcollision ( ind2 ( k ))) call pl % make_family ([ ind1 ( k ), ind2 ( k )]) ! Set the collision flag for these to bodies to true in case they become involved in another collision later in the step pl % lcollision ([ ind1 ( k ), ind2 ( k )]) = . true . pl % ldiscard ([ ind1 ( k ), ind2 ( k )]) = . true . pl % status ([ ind1 ( k ), ind2 ( k )]) = COLLISION else self % x2 (:, k ) = tp % xh (:, ind2 ( k )) self % v2 (:, k ) = tp % vb (:, ind2 ( k )) tp % status ( ind2 ( k )) = DISCARDED_PLR tp % ldiscard ( ind2 ( k )) = . true . write ( * , * ) 'Test particle ' , tp % id ( ind2 ( k )), ' collided with massive body ' , pl % id ( ind1 ( k )), ' at time ' , t end if end do end if end associate end select end select return end subroutine symba_collision_check_pltpenc pure elemental function symba_collision_check_one ( xr , yr , zr , vxr , vyr , vzr , Gmtot , rlim , dt , lvdotr ) result ( lcollision ) !! author: David A. Minton !! !! Check for a merger between a single pair of particles !! !! Adapted from David E. Kaufmann's Swifter routines symba_merge_tp.f90 and symba_merge_pl.f90 !! !! Adapted from Hal Levison's Swift routine symba5_merge.f implicit none ! Arguments real ( DP ), intent ( in ) :: xr , yr , zr !! Relative position vector components real ( DP ), intent ( in ) :: vxr , vyr , vzr !! Relative velocity vector components real ( DP ), intent ( in ) :: Gmtot !! Sum of G*mass of colliding bodies real ( DP ), intent ( in ) :: rlim !! Collision limit - Typically the sum of the radii of colliding bodies real ( DP ), intent ( in ) :: dt !! Step size logical , intent ( in ) :: lvdotr !! Logical flag indicating that these two bodies are approaching in the current substep ! Result logical :: lcollision !! Logical flag indicating whether these two bodies will collide or not ! Internals real ( DP ) :: r2 , rlim2 , a , e , q , vdotr , tcr2 , dt2 r2 = xr ** 2 + yr ** 2 + zr ** 2 rlim2 = rlim ** 2 if ( r2 <= rlim2 ) then ! checks if bodies are actively colliding in this time step lcollision = . true . else ! if they are not actively colliding in  this time step, checks if they are going to collide next time step based on velocities and q lcollision = . false . vdotr = xr * vxr + yr * vyr + zr * vzr if ( lvdotr . and . ( vdotr > 0.0_DP )) then tcr2 = r2 / ( vxr ** 2 + vyr ** 2 + vzr ** 2 ) dt2 = dt ** 2 if ( tcr2 <= dt2 ) then call orbel_xv2aeq ( Gmtot , [ xr , yr , zr ], [ vxr , vyr , vzr ], a , e , q ) lcollision = ( q < rlim ) end if end if end if return end function symba_collision_check_one function symba_collision_consolidate_familes ( pl , param , idx_parent , family , x , v , mass , radius , L_spin , Ip ) result ( lflag ) !! author: David A. Minton !! !! Loops through the pl-pl collision list and groups families together by index. Outputs the indices of all family members, !! and pairs of quantities (x and v vectors, mass, radius, L_spin, and Ip) that can be used to resolve the collisional outcome. implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: pl !! SyMBA massive body object class ( symba_parameters ), intent ( in ) :: param !! Current run configuration parameters with SyMBA additions integer ( I4B ), dimension ( 2 ), intent ( inout ) :: idx_parent !! Index of the two bodies considered the \"parents\" of the collision integer ( I4B ), dimension (:), allocatable , intent ( out ) :: family !! List of indices of all bodies inovlved in the collision real ( DP ), dimension ( NDIM , 2 ), intent ( out ) :: x , v , L_spin , Ip !! Output values that represent a 2-body equivalent of a possibly 2+ body collision real ( DP ), dimension ( 2 ), intent ( out ) :: mass , radius !! Output values that represent a 2-body equivalent of a possibly 2+ body collision ! Result logical :: lflag !! Logical flag indicating whether a family was successfully created or not ! Internals type family_array integer ( I4B ), dimension (:), allocatable :: id integer ( I4B ), dimension (:), allocatable :: idx end type family_array type ( family_array ), dimension ( 2 ) :: parent_child_index_array integer ( I4B ), dimension ( 2 ) :: nchild integer ( I4B ) :: i , j , fam_size , idx_child real ( DP ), dimension ( 2 ) :: volume , density real ( DP ) :: mchild , mtot , volchild real ( DP ), dimension ( NDIM ) :: xc , vc , xcom , vcom , xchild , vchild , xcrossv nchild (:) = pl % kin ( idx_parent (:))% nchild ! If all of these bodies share a parent, but this is still a unique collision, move the last child ! out of the parent's position and make it the secondary body if ( idx_parent ( 1 ) == idx_parent ( 2 )) then if ( nchild ( 1 ) == 0 ) then ! There is only one valid body recorded in this pair (this could happen due to restructuring of the kinship relationships, though it should be rare) lflag = . false . return end if idx_parent ( 2 ) = pl % kin ( idx_parent ( 1 ))% child ( nchild ( 1 )) nchild ( 1 ) = nchild ( 1 ) - 1 nchild ( 2 ) = 0 pl % kin ( idx_parent (:))% nchild = nchild (:) pl % kin ( idx_parent ( 2 ))% parent = idx_parent ( 1 ) end if mass (:) = pl % mass ( idx_parent (:)) ! Note: This is meant to mass, not G*mass, as the collisional regime determination uses mass values that will be converted to Si radius (:) = pl % radius ( idx_parent (:)) volume (:) = ( 4.0_DP / 3.0_DP ) * PI * radius (:) ** 3 ! Group together the ids and indexes of each collisional parent and its children do j = 1 , 2 allocate ( parent_child_index_array ( j )% idx ( nchild ( j ) + 1 )) allocate ( parent_child_index_array ( j )% id ( nchild ( j ) + 1 )) associate ( idx_arr => parent_child_index_array ( j )% idx , & id_arr => parent_child_index_array ( j )% id , & ncj => nchild ( j ), & pl => pl , & plkinj => pl % kin ( idx_parent ( j ))) idx_arr ( 1 ) = idx_parent ( j ) if ( ncj > 0 ) idx_arr ( 2 : ncj + 1 ) = plkinj % child ( 1 : ncj ) id_arr (:) = pl % id ( idx_arr (:)) end associate end do ! Consolidate the groups of collsional parents with any children they may have into a single \"family\" index array fam_size = 2 + sum ( nchild (:)) allocate ( family ( fam_size )) family = [ parent_child_index_array ( 1 )% idx (:), parent_child_index_array ( 2 )% idx (:)] fam_size = count ( pl % lcollision ( family (:))) family = pack ( family (:), pl % lcollision ( family (:))) L_spin (:,:) = 0.0_DP Ip (:,:) = 0.0_DP ! Find the barycenter of each body along with its children, if it has any do j = 1 , 2 x (:, j ) = pl % xb (:, idx_parent ( j )) v (:, j ) = pl % vb (:, idx_parent ( j )) ! Assume principal axis rotation about axis corresponding to highest moment of inertia (3rd Ip) if ( param % lrotation ) then Ip (:, j ) = mass ( j ) * pl % Ip (:, idx_parent ( j )) L_spin (:, j ) = Ip ( 3 , j ) * radius ( j ) ** 2 * pl % rot (:, idx_parent ( j )) end if if ( nchild ( j ) > 0 ) then do i = 1 , nchild ( j ) ! Loop over all children and take the mass weighted mean of the properties idx_child = parent_child_index_array ( j )% idx ( i + 1 ) if (. not . pl % lcollision ( idx_child )) cycle mchild = pl % mass ( idx_child ) xchild (:) = pl % xb (:, idx_child ) vchild (:) = pl % vb (:, idx_child ) volchild = ( 4.0_DP / 3.0_DP ) * PI * pl % radius ( idx_child ) ** 3 volume ( j ) = volume ( j ) + volchild ! Get angular momentum of the child-parent pair and add that to the spin ! Add the child's spin if ( param % lrotation ) then xcom (:) = ( mass ( j ) * x (:, j ) + mchild * xchild (:)) / ( mass ( j ) + mchild ) vcom (:) = ( mass ( j ) * v (:, j ) + mchild * vchild (:)) / ( mass ( j ) + mchild ) xc (:) = x (:, j ) - xcom (:) vc (:) = v (:, j ) - vcom (:) xcrossv (:) = xc (:) . cross . vc (:) L_spin (:, j ) = L_spin (:, j ) + mass ( j ) * xcrossv (:) xc (:) = xchild (:) - xcom (:) vc (:) = vchild (:) - vcom (:) xcrossv (:) = xc (:) . cross . vc (:) L_spin (:, j ) = L_spin (:, j ) + mchild * xcrossv (:) L_spin (:, j ) = L_spin (:, j ) + mchild * pl % Ip ( 3 , idx_child ) * pl % radius ( idx_child ) ** 2 * pl % rot (:, idx_child ) Ip (:, j ) = Ip (:, j ) + mchild * pl % Ip (:, idx_child ) end if ! Merge the child and parent mass ( j ) = mass ( j ) + mchild x (:, j ) = xcom (:) v (:, j ) = vcom (:) end do end if density ( j ) = mass ( j ) / volume ( j ) radius ( j ) = (( 3 * mass ( j )) / ( density ( j ) * 4 * pi )) ** ( 1.0_DP / 3.0_DP ) if ( param % lrotation ) Ip (:, j ) = Ip (:, j ) / mass ( j ) end do lflag = . true . return end function symba_collision_consolidate_familes module subroutine symba_collision_encounter_scrub ( self , system , param ) !! author: David A. Minton !! !! Processes the pl-pl encounter list remove only those encounters that led to a collision !! implicit none ! Arguments class ( symba_plplenc ), intent ( inout ) :: self !! SyMBA pl-pl encounter list class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals logical , dimension ( self % nenc ) :: lplpl_collision logical , dimension (:), allocatable :: lplpl_unique_parent integer ( I4B ), dimension (:), pointer :: plparent integer ( I4B ), dimension (:), allocatable :: collision_idx , unique_parent_idx integer ( I4B ) :: i , index_coll , ncollisions , nunique_parent type ( symba_plplenc ) :: plplenc_noncollision select type ( pl => system % pl ) class is ( symba_pl ) associate ( plplenc_list => self , nplplenc => self % nenc , idx1 => self % index1 , idx2 => self % index2 , plparent => pl % kin % parent ) lplpl_collision (:) = plplenc_list % status ( 1 : nplplenc ) == COLLISION if ( any ( lplpl_collision )) then ! Collisions have been detected in this step. So we need to determine which of them are between unique bodies. ! Get the subset of pl-pl encounters that lead to a collision ncollisions = count ( lplpl_collision (:)) allocate ( collision_idx ( ncollisions )) collision_idx = pack ([( i , i = 1 , nplplenc )], lplpl_collision ) ! Get the subset of collisions that involve a unique pair of parents allocate ( lplpl_unique_parent ( ncollisions )) lplpl_unique_parent (:) = plparent ( idx1 ( collision_idx (:))) /= plparent ( idx2 ( collision_idx (:))) nunique_parent = count ( lplpl_unique_parent (:)) allocate ( unique_parent_idx ( nunique_parent )) unique_parent_idx = pack ( collision_idx (:), lplpl_unique_parent (:)) ! Scrub all pl-pl collisions involving unique pairs of parents, which will remove all duplicates and leave behind ! all pairs that have themselves as parents but are not part of the unique parent list. This can hapepn in rare cases ! due to restructuring of parent/child relationships when there are large numbers of multi-body collisions in a single ! step lplpl_unique_parent (:) = . true . do index_coll = 1 , ncollisions associate ( ip1 => plparent ( idx1 ( collision_idx ( index_coll ))), ip2 => plparent ( idx2 ( collision_idx ( index_coll )))) lplpl_unique_parent (:) = . not . ( any ( plparent ( idx1 ( unique_parent_idx (:))) == ip1 ) . or . & any ( plparent ( idx2 ( unique_parent_idx (:))) == ip1 ) . or . & any ( plparent ( idx1 ( unique_parent_idx (:))) == ip2 ) . or . & any ( plparent ( idx2 ( unique_parent_idx (:))) == ip2 ) ) end associate end do ! Reassemble collision index list to include only those containing the unique pairs of parents, plus all the non-unique pairs that don't ! contain a parent body on the unique parent list. ncollisions = nunique_parent + count ( lplpl_unique_parent ) collision_idx = [ unique_parent_idx (:), pack ( collision_idx (:), lplpl_unique_parent (:))] ! Create a mask that contains only the pl-pl encounters that did not result in a collision, and then discard them lplpl_collision (:) = . false . lplpl_collision ( collision_idx (:)) = . true . end if call plplenc_list % spill ( plplenc_noncollision , . not . lplpl_collision , ldestructive = . true .) ! Remove any encounters that are not collisions from the list. end associate end select return end subroutine symba_collision_encounter_scrub module subroutine symba_collision_make_family_pl ( self , idx ) !! author: Jennifer L.L. Pouplin, Carlisle A. wishard, and David A. Minton !! !! When a single body is involved in more than one collision in a single step, it becomes part of a family. !! The largest body involved in a multi-body collision is the \"parent\" and all bodies that collide with it are its \"children,\" !! including those that collide with the children. !! !! Adapted from David E. Kaufmann's Swifter routine symba_merge_pl.f90 !! !! Adapted from Hal Levison's Swift routine symba5_merge.f implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), dimension ( 2 ), intent ( in ) :: idx !! Array holding the indices of the two bodies involved in the collision ! Internals integer ( I4B ) :: i , j , index_parent , index_child , p1 , p2 integer ( I4B ) :: nchild_inherit , nchild_orig , nchild_new integer ( I4B ), dimension (:), allocatable :: temp associate ( pl => self ) p1 = pl % kin ( idx ( 1 ))% parent p2 = pl % kin ( idx ( 2 ))% parent if ( p1 == p2 ) return ! This is a collision between to children of a shared parent. We will ignore it. if ( pl % mass ( p1 ) > pl % mass ( p2 )) then index_parent = p1 index_child = p2 else index_parent = p2 index_child = p1 end if ! Expand the child array (or create it if necessary) and copy over the previous lists of children nchild_orig = pl % kin ( index_parent )% nchild nchild_inherit = pl % kin ( index_child )% nchild nchild_new = nchild_orig + nchild_inherit + 1 allocate ( temp ( nchild_new )) if ( nchild_orig > 0 ) temp ( 1 : nchild_orig ) = pl % kin ( index_parent )% child ( 1 : nchild_orig ) ! Find out if the child body has any children of its own. The new parent wil inherit these children if ( nchild_inherit > 0 ) then temp ( nchild_orig + 1 : nchild_orig + nchild_inherit ) = pl % kin ( index_child )% child ( 1 : nchild_inherit ) do i = 1 , nchild_inherit j = pl % kin ( index_child )% child ( i ) ! Set the childrens' parent to the new parent pl % kin ( j )% parent = index_parent end do end if if ( allocated ( pl % kin ( index_child )% child )) deallocate ( pl % kin ( index_child )% child ) pl % kin ( index_child )% nchild = 0 ! Add the new child to its parent pl % kin ( index_child )% parent = index_parent temp ( nchild_new ) = index_child ! Save the new child array to the parent pl % kin ( index_parent )% nchild = nchild_new call move_alloc ( from = temp , to = pl % kin ( index_parent )% child ) end associate return end subroutine symba_collision_make_family_pl module subroutine symba_collision_resolve_fragmentations ( self , system , param ) !! author: David A. Minton !! !! Process list of collisions, determine the collisional regime, and then create fragments. !! implicit none ! Arguments class ( symba_plplenc ), intent ( inout ) :: self !! SyMBA pl-pl encounter list class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( in ) :: param !! Current run configuration parameters with SyMBA additions ! Internals ! Internals integer ( I4B ), dimension (:), allocatable :: family !! List of indices of all bodies inovlved in the collision integer ( I4B ), dimension ( 2 ) :: idx_parent !! Index of the two bodies considered the \"parents\" of the collision real ( DP ), dimension ( NDIM , 2 ) :: x , v , L_spin , Ip !! Output values that represent a 2-body equivalent of a possibly 2+ body collision real ( DP ), dimension ( 2 ) :: mass , radius !! Output values that represent a 2-body equivalent of a possibly 2+ body collision logical :: lgoodcollision integer ( I4B ) :: i , status , jtarg , jproj , regime real ( DP ), dimension ( 2 ) :: radius_si , mass_si , density_si real ( DP ) :: mtiny_si , Mcb_si real ( DP ), dimension ( NDIM ) :: x1_si , v1_si , x2_si , v2_si real ( DP ) :: mlr , mslr , mtot , dentot , msys , msys_new , Qloss , impact_parameter integer ( I4B ), parameter :: NRES = 3 !! Number of collisional product results real ( DP ), dimension ( NRES ) :: mass_res associate ( plpl_collisions => self , ncollisions => self % nenc , idx1 => self % index1 , idx2 => self % index2 , cb => system % cb ) select type ( pl => system % pl ) class is ( symba_pl ) do i = 1 , ncollisions idx_parent ( 1 ) = pl % kin ( idx1 ( i ))% parent idx_parent ( 2 ) = pl % kin ( idx2 ( i ))% parent lgoodcollision = symba_collision_consolidate_familes ( pl , param , idx_parent , family , x , v , mass , radius , L_spin , Ip ) if (. not . lgoodcollision ) cycle if ( any ( pl % status ( idx_parent (:)) /= COLLISION )) cycle ! One of these two bodies has already been resolved ! Convert all quantities to SI units and determine which of the pair is the projectile vs. target before sending them ! to symba_regime if ( mass ( 1 ) > mass ( 2 )) then jtarg = 1 jproj = 2 else jtarg = 2 jproj = 1 end if mass_si (:) = ( mass (:)) * param % MU2KG !! The collective mass of the parent and its children radius_si (:) = radius (:) * param % DU2M !! The collective radius of the parent and its children x1_si (:) = plpl_collisions % x1 (:, i ) * param % DU2M !! The position of the parent from inside the step (at collision) v1_si (:) = plpl_collisions % v1 (:, i ) * param % DU2M / param % TU2S !! The velocity of the parent from inside the step (at collision) x2_si (:) = plpl_collisions % x2 (:, i ) * param % DU2M !! The position of the parent from inside the step (at collision) v2_si (:) = plpl_collisions % v2 (:, i ) * param % DU2M / param % TU2S !! The velocity of the parent from inside the step (at collision) density_si (:) = mass_si (:) / ( 4.0_DP / 3._DP * PI * radius_si (:) ** 3 ) !! The collective density of the parent and its children Mcb_si = cb % mass * param % MU2KG mtiny_si = ( param % GMTINY / param % GU ) * param % MU2KG mass_res (:) = 0.0_DP mtot = sum ( mass_si (:)) dentot = sum ( mass_si (:) * density_si (:)) / mtot !! Use the positions and velocities of the parents from indside the step (at collision) to calculate the collisional regime call fragmentation_regime ( Mcb_si , mass_si ( jtarg ), mass_si ( jproj ), radius_si ( jtarg ), radius_si ( jproj ), x1_si (:), x2_si (:),& v1_si (:), v2_si (:), density_si ( jtarg ), density_si ( jproj ), regime , mlr , mslr , mtiny_si , Qloss ) mass_res ( 1 ) = min ( max ( mlr , 0.0_DP ), mtot ) mass_res ( 2 ) = min ( max ( mslr , 0.0_DP ), mtot ) mass_res ( 3 ) = min ( max ( mtot - mlr - mslr , 0.0_DP ), mtot ) mass_res (:) = ( mass_res (:) / param % MU2KG ) Qloss = Qloss * ( param % TU2S / param % DU2M ) ** 2 / param % MU2KG select case ( regime ) case ( COLLRESOLVE_REGIME_DISRUPTION ) status = symba_fragmentation_casedisruption ( system , param , family , x , v , mass , radius , L_spin , Ip , mass_res , Qloss ) case ( COLLRESOLVE_REGIME_SUPERCATASTROPHIC ) status = symba_fragmentation_casesupercatastrophic ( system , param , family , x , v , mass , radius , L_spin , Ip , mass_res , Qloss ) case ( COLLRESOLVE_REGIME_HIT_AND_RUN ) status = symba_fragmentation_casehitandrun ( system , param , family , x , v , mass , radius , L_spin , Ip , mass_res , Qloss ) case ( COLLRESOLVE_REGIME_MERGE , COLLRESOLVE_REGIME_GRAZE_AND_MERGE ) status = symba_fragmentation_casemerge ( system , param , family , x , v , mass , radius , L_spin , Ip ) case default write ( * , * ) \"Error in symba_collision, unrecognized collision regime\" call util_exit ( FAILURE ) end select end do end select end associate return end subroutine symba_collision_resolve_fragmentations module subroutine symba_collision_resolve_mergers ( self , system , param ) !! author: David A. Minton !! !! Process list of collisions and merge colliding bodies together. !! implicit none ! Arguments class ( symba_plplenc ), intent ( inout ) :: self !! SyMBA pl-pl encounter list class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( in ) :: param !! Current run configuration parameters with SyMBA additions ! Internals integer ( I4B ), dimension (:), allocatable :: family !! List of indices of all bodies inovlved in the collision integer ( I4B ), dimension ( 2 ) :: idx_parent !! Index of the two bodies considered the \"parents\" of the collision real ( DP ), dimension ( NDIM , 2 ) :: x , v , L_spin , Ip !! Output values that represent a 2-body equivalent of a possibly 2+ body collision real ( DP ), dimension ( 2 ) :: mass , radius !! Output values that represent a 2-body equivalent of a possibly 2+ body collision logical :: lgoodcollision integer ( I4B ) :: i , status associate ( plpl_collisions => self , ncollisions => self % nenc , idx1 => self % index1 , idx2 => self % index2 ) select type ( pl => system % pl ) class is ( symba_pl ) do i = 1 , ncollisions idx_parent ( 1 ) = pl % kin ( idx1 ( i ))% parent idx_parent ( 2 ) = pl % kin ( idx2 ( i ))% parent lgoodcollision = symba_collision_consolidate_familes ( pl , param , idx_parent , family , x , v , mass , radius , L_spin , Ip ) if (. not . lgoodcollision ) cycle if ( any ( pl % status ( idx_parent (:)) /= COLLISION )) cycle ! One of these two bodies has already been resolved status = symba_fragmentation_casemerge ( system , param , family , x , v , mass , radius , L_spin , Ip ) end do end select end associate return end subroutine symba_collision_resolve_mergers end submodule s_symba_collision","tags":"","loc":"sourcefile/symba_collision.f90.html"},{"title":"symba_setup.f90 – swiftest","text":"This file depends on sourcefile~~symba_setup.f90~~EfferentGraph sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_setup.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_symba_setup Source Code symba_setup.f90 Source Code submodule ( symba_classes ) s_symba_setup use swiftest contains module subroutine symba_setup_initialize_particle_info ( system , param ) !! author: David A. Minton !! !! Initializes a new particle information data structure with initial conditions recorded implicit none ! Argumets class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( inout ) :: param !! Current run configuration parameters with SyMBA extensions ! Internals integer ( I4B ) :: i integer ( I4B ), dimension (:), allocatable :: idx select type ( cb => system % cb ) class is ( symba_cb ) cb % info % origin_type = \"Central body\" cb % info % origin_time = param % t0 cb % info % origin_xh (:) = 0.0_DP cb % info % origin_vh (:) = 0.0_DP call symba_io_dump_particle_info ( system , param , lincludecb = . true .) end select select type ( pl => system % pl ) class is ( symba_pl ) do i = 1 , pl % nbody pl % info ( i )% origin_type = \"Initial conditions\" pl % info ( i )% origin_time = param % t0 pl % info ( i )% origin_xh (:) = pl % xh (:, i ) pl % info ( i )% origin_vh (:) = pl % vh (:, i ) end do if ( pl % nbody > 0 ) then allocate ( idx ( pl % nbody )) call symba_io_dump_particle_info ( system , param , plidx = [( i , i = 1 , pl % nbody )]) deallocate ( idx ) end if end select select type ( tp => system % tp ) class is ( symba_tp ) do i = 1 , tp % nbody tp % info ( i )% origin_type = \"Initial conditions\" tp % info ( i )% origin_time = param % t0 tp % info ( i )% origin_xh (:) = tp % xh (:, i ) tp % info ( i )% origin_vh (:) = tp % vh (:, i ) end do if ( tp % nbody > 0 ) then allocate ( idx ( tp % nbody )) call symba_io_dump_particle_info ( system , param , tpidx = [( i , i = 1 , tp % nbody )]) deallocate ( idx ) end if end select return end subroutine symba_setup_initialize_particle_info module subroutine symba_setup_initialize_system ( self , param ) !! author: David A. Minton !! !! Initialize an SyMBA nbody system from files and sets up the planetocentric structures. !! This subroutine will also sort the massive bodies in descending order by mass !! implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i , j ! Call parent method associate ( system => self ) call whm_setup_initialize_system ( system , param ) call system % pltpenc_list % setup ( 0 ) call system % plplenc_list % setup ( 0 ) select type ( pl => system % pl ) class is ( symba_pl ) call pl % sort ( \"mass\" , ascending = . false .) select type ( param ) class is ( symba_parameters ) pl % lmtiny (:) = pl % Gmass (:) > param % GMTINY pl % nplm = count ( pl % lmtiny (:)) if ( param % lrestart ) then call symba_io_read_particle ( system , param ) else call symba_setup_initialize_particle_info ( system , param ) end if end select end select end associate return end subroutine symba_setup_initialize_system module subroutine symba_setup_merger ( self , n , param ) !! author: David A. Minton !! !! Allocate SyMBA test particle structure !! !! Equivalent in functionality to David E. Kaufmann's Swifter routine symba_setup.f90 implicit none ! Arguments class ( symba_merger ), intent ( inout ) :: self !! SyMBA merger list object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameter ! Internals integer ( I4B ) :: i !> Call allocation method for parent class. In this case, helio_pl does not have its own setup method so we use the base method for swiftest_pl call symba_setup_pl ( self , n , param ) if ( n <= 0 ) return if ( allocated ( self % ncomp )) deallocate ( self % ncomp ) allocate ( self % ncomp ( n )) self % ncomp (:) = 0 return end subroutine symba_setup_merger module subroutine symba_setup_pl ( self , n , param ) !! author: David A. Minton !! !! Allocate SyMBA test particle structure !! !! Equivalent in functionality to David E. Kaufmann's Swifter routine symba_setup.f90 implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameter ! Internals integer ( I4B ) :: i !> Call allocation method for parent class. In this case, helio_pl does not have its own setup method so we use the base method for swiftest_pl call setup_pl ( self , n , param ) if ( n <= 0 ) return if ( allocated ( self % lcollision )) deallocate ( self % lcollision ) if ( allocated ( self % lencounter )) deallocate ( self % lencounter ) if ( allocated ( self % lmtiny )) deallocate ( self % lmtiny ) if ( allocated ( self % nplenc )) deallocate ( self % nplenc ) if ( allocated ( self % ntpenc )) deallocate ( self % ntpenc ) if ( allocated ( self % levelg )) deallocate ( self % levelg ) if ( allocated ( self % levelm )) deallocate ( self % levelm ) if ( allocated ( self % isperi )) deallocate ( self % isperi ) if ( allocated ( self % peri )) deallocate ( self % peri ) if ( allocated ( self % atp )) deallocate ( self % atp ) if ( allocated ( self % kin )) deallocate ( self % kin ) if ( allocated ( self % info )) deallocate ( self % info ) allocate ( self % lcollision ( n )) allocate ( self % lencounter ( n )) allocate ( self % lmtiny ( n )) allocate ( self % nplenc ( n )) allocate ( self % ntpenc ( n )) allocate ( self % levelg ( n )) allocate ( self % levelm ( n )) allocate ( self % isperi ( n )) allocate ( self % peri ( n )) allocate ( self % atp ( n )) allocate ( self % kin ( n )) allocate ( self % info ( n )) self % lcollision (:) = . false . self % lencounter (:) = . false . self % lmtiny (:) = . false . self % nplenc (:) = 0 self % ntpenc (:) = 0 self % levelg (:) = - 1 self % levelm (:) = - 1 self % isperi (:) = 0 self % peri (:) = 0.0_DP self % atp (:) = 0.0_DP self % kin (:)% nchild = 0 self % kin (:)% parent = [( i , i = 1 , n )] return end subroutine symba_setup_pl module subroutine symba_setup_pltpenc ( self , n ) !! author: David A. Minton !! !! A constructor that sets the number of encounters and allocates and initializes all arrays !! implicit none ! Arguments class ( symba_pltpenc ), intent ( inout ) :: self !! SyMBA pl-tp encounter structure integer ( I4B ), intent ( in ) :: n !! Number of encounters to allocate space for call setup_encounter ( self , n ) if ( n == 0 ) return if ( allocated ( self % level )) deallocate ( self % level ) allocate ( self % level ( n )) self % level (:) = - 1 return end subroutine symba_setup_pltpenc module subroutine symba_setup_tp ( self , n , param ) !! author: David A. Minton !! !! Allocate WHM test particle structure !! !! Equivalent in functionality to David E. Kaufmann's Swifter routine whm_setup.f90 implicit none ! Arguments class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameter !> Call allocation method for parent class. In this case, helio_tp does not have its own setup method so we use the base method for swiftest_tp call setup_tp ( self , n , param ) if ( n <= 0 ) return if ( allocated ( self % nplenc )) deallocate ( self % nplenc ) if ( allocated ( self % levelg )) deallocate ( self % levelg ) if ( allocated ( self % levelm )) deallocate ( self % levelm ) if ( allocated ( self % info )) deallocate ( self % info ) allocate ( self % nplenc ( n )) allocate ( self % levelg ( n )) allocate ( self % levelm ( n )) allocate ( self % info ( n )) self % nplenc (:) = 0 self % levelg (:) = - 1 self % levelm (:) = - 1 return end subroutine symba_setup_tp end submodule s_symba_setup","tags":"","loc":"sourcefile/symba_setup.f90.html"},{"title":"symba_kick.f90 – swiftest","text":"This file depends on sourcefile~~symba_kick.f90~~EfferentGraph sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_kick.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_symba_kick Source Code symba_kick.f90 Source Code submodule ( symba_classes ) s_symba_kick use swiftest contains module subroutine symba_kick_getacch_pl ( self , system , param , t , lbeg ) !! author: David A. Minton !! !! Compute heliocentric accelerations of massive bodies !! !! Adapted from David E. Kaufmann's Swifter routine symba_kick_getacch.f90 !! Adapted from Hal Levison's Swift routine symba5_kick_getacch.f implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step ! Internals integer ( I4B ) :: k real ( DP ) :: irij3 , rji2 , rlim2 , faci , facj real ( DP ), dimension ( NDIM ) :: dx if ( self % nbody == 0 ) return select type ( system ) class is ( symba_nbody_system ) associate ( pl => self , cb => system % cb , plplenc_list => system % plplenc_list , nplplenc => system % plplenc_list % nenc ) call helio_kick_getacch_pl ( pl , system , param , t , lbeg ) ! Remove accelerations from encountering pairs do k = 1 , nplplenc associate ( i => plplenc_list % index1 ( k ), j => plplenc_list % index2 ( k )) dx (:) = pl % xh (:, j ) - pl % xh (:, i ) rji2 = dot_product ( dx (:), dx (:)) irij3 = 1.0_DP / ( rji2 * sqrt ( rji2 )) faci = pl % Gmass ( i ) * irij3 facj = pl % Gmass ( j ) * irij3 pl % ah (:, i ) = pl % ah (:, i ) - facj * dx (:) pl % ah (:, j ) = pl % ah (:, j ) + faci * dx (:) end associate end do end associate end select return end subroutine symba_kick_getacch_pl module subroutine symba_kick_getacch_tp ( self , system , param , t , lbeg ) !! author: David A. Minton !! !! Compute heliocentric accelerations of test particles !! !! Adapted from David E. Kaufmann's Swifter routine symba_kick_getacch_tp.f90 !! Adapted from Hal Levison's Swift routine symba5_kick_getacch.f implicit none ! Arguments class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step ! Internals integer ( I4B ) :: k real ( DP ) :: rji2 , fac , rlim2 real ( DP ), dimension ( NDIM ) :: dx if ( self % nbody == 0 ) return select type ( system ) class is ( symba_nbody_system ) associate ( tp => self , cb => system % cb , pl => system % pl , pltpenc_list => system % pltpenc_list , npltpenc => system % pltpenc_list % nenc ) call helio_kick_getacch_tp ( tp , system , param , t , lbeg ) ! Remove accelerations from encountering pairs do k = 1 , npltpenc associate ( i => pltpenc_list % index1 ( k ), j => pltpenc_list % index2 ( k )) if ( tp % lmask ( j )) THEN if ( lbeg ) then dx (:) = tp % xh (:, j ) - pl % xbeg (:, i ) else dx (:) = tp % xh (:, j ) - pl % xend (:, i ) end if rji2 = dot_product ( dx (:), dx (:)) fac = pl % Gmass ( i ) / ( rji2 * sqrt ( rji2 )) tp % ah (:, j ) = tp % ah (:, j ) + fac * dx (:) end IF end associate end do end associate end select return end subroutine symba_kick_getacch_tp module subroutine symba_kick_pltpenc ( self , system , dt , irec , sgn ) !! author: David A. Minton !! !! Kick barycentric velocities of massive bodies and ACTIVE test particles within SyMBA recursion. !! Note: This method works for the polymorphic symba_pltpenc and symba_plplenc types !! !! Adapted from David E. Kaufmann's Swifter routine: symba_kick.f90 !! Adapted from Hal Levison's Swift routine symba5_kick.f implicit none ! Arguments class ( symba_pltpenc ), intent ( in ) :: self !! SyMBA pl-tp encounter list object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object real ( DP ), intent ( in ) :: dt !! step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level integer ( I4B ), intent ( in ) :: sgn !! sign to be applied to acceleration ! Internals integer ( I4B ) :: k , irm1 , irecl real ( DP ) :: r , rr , ri , ris , rim1 , r2 , ir3 , fac , faci , facj real ( DP ), dimension ( NDIM ) :: dx logical :: isplpl , lgoodlevel if ( self % nenc == 0 ) return select type ( self ) class is ( symba_plplenc ) isplpl = . true . class is ( symba_pltpenc ) isplpl = . false . end select select type ( pl => system % pl ) class is ( symba_pl ) select type ( tp => system % tp ) class is ( symba_tp ) associate ( ind1 => self % index1 , ind2 => self % index2 ) if ( pl % nbody > 0 ) pl % lmask (:) = pl % status (:) /= INACTIVE if ( tp % nbody > 0 ) tp % lmask (:) = tp % status (:) /= INACTIVE irm1 = irec - 1 if ( sgn < 0 ) then irecl = irec - 1 else irecl = irec end if do k = 1 , self % nenc if ( isplpl ) then pl % ah (:, ind1 ( k )) = 0.0_DP pl % ah (:, ind2 ( k )) = 0.0_DP else tp % ah (:, ind2 ( k )) = 0.0_DP end if if ( isplpl ) then lgoodlevel = ( pl % levelg ( ind1 ( k )) >= irm1 ) . and . ( pl % levelg ( ind2 ( k )) >= irm1 ) else lgoodlevel = ( pl % levelg ( ind1 ( k )) >= irm1 ) . and . ( tp % levelg ( ind2 ( k )) >= irm1 ) end if if (( self % status ( k ) /= INACTIVE ) . and . lgoodlevel ) then if ( isplpl ) then ri = (( pl % rhill ( ind1 ( k )) + pl % rhill ( ind2 ( k ))) ** 2 ) * ( RHSCALE ** 2 ) * ( RSHELL ** ( 2 * irecl )) rim1 = ri * ( RSHELL ** 2 ) dx (:) = pl % xh (:, ind2 ( k )) - pl % xh (:, ind1 ( k )) else ri = (( pl % rhill ( ind1 ( k ))) ** 2 ) * ( RHSCALE ** 2 ) * ( RSHELL ** ( 2 * irecl )) rim1 = ri * ( RSHELL ** 2 ) dx (:) = tp % xh (:, ind2 ( k )) - pl % xh (:, ind1 ( k )) end if r2 = dot_product ( dx (:), dx (:)) if ( r2 < rim1 ) then fac = 0.0_DP else if ( r2 < ri ) then ris = sqrt ( ri ) r = sqrt ( r2 ) rr = ( ris - r ) / ( ris * ( 1.0_DP - RSHELL )) fac = ( r2 ** ( - 1.5_DP )) * ( 1.0_DP - 3 * ( rr ** 2 ) + 2 * ( rr ** 3 )) else ir3 = 1.0_DP / ( r2 * sqrt ( r2 )) fac = ir3 end if faci = fac * pl % Gmass ( ind1 ( k )) if ( isplpl ) then facj = fac * pl % Gmass ( ind2 ( k )) pl % ah (:, ind1 ( k )) = pl % ah (:, ind1 ( k )) + facj * dx (:) pl % ah (:, ind2 ( k )) = pl % ah (:, ind2 ( k )) - faci * dx (:) else tp % ah (:, ind2 ( k )) = tp % ah (:, ind2 ( k )) - faci * dx (:) end if end if end do if ( isplpl ) then do k = 1 , self % nenc pl % vb (:, ind1 ( k )) = pl % vb (:, ind1 ( k )) + sgn * dt * pl % ah (:, ind1 ( k )) pl % vb (:, ind2 ( k )) = pl % vb (:, ind2 ( k )) + sgn * dt * pl % ah (:, ind2 ( k )) pl % ah (:, ind1 ( k )) = 0.0_DP pl % ah (:, ind1 ( k )) = 0.0_DP end do else do k = 1 , self % nenc tp % vb (:, ind2 ( k )) = tp % vb (:, ind2 ( k )) + sgn * dt * tp % ah (:, ind2 ( k )) tp % ah (:, ind2 ( k )) = 0.0_DP end do end if end associate end select end select return end subroutine symba_kick_pltpenc end submodule s_symba_kick","tags":"","loc":"sourcefile/symba_kick.f90.html"},{"title":"symba_fragmentation.f90 – swiftest","text":"This file depends on sourcefile~~symba_fragmentation.f90~~EfferentGraph sourcefile~symba_fragmentation.f90 symba_fragmentation.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_fragmentation.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_fragmentation.f90->sourcefile~swiftest.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_symba_fragmentation Source Code symba_fragmentation.f90 Source Code submodule ( symba_classes ) s_symba_fragmentation use swiftest integer ( I4B ), parameter :: NFRAG_DISRUPT = 12 integer ( I4B ), parameter :: NFRAG_SUPERCAT = 20 contains module function symba_fragmentation_casedisruption ( system , param , family , x , v , mass , radius , L_spin , Ip , mass_res , Qloss ) result ( status ) !! author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Create the fragments resulting from a non-catastrophic disruption collision !! implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( in ) :: param !! Current run configuration parameters with SyMBA additions integer ( I4B ), dimension (:), intent ( in ) :: family !! List of indices of all bodies inovlved in the collision real ( DP ), dimension (:,:), intent ( inout ) :: x , v , L_spin , Ip !! Input values that represent a 2-body equivalent of a possibly 2+ body collision real ( DP ), dimension (:), intent ( inout ) :: mass , radius !! Input values that represent a 2-body equivalent of a possibly 2+ body collision real ( DP ), dimension (:), intent ( inout ) :: mass_res !! The distribution of fragment mass obtained by the regime calculation real ( DP ), intent ( inout ) :: Qloss !! Energy lost during collision ! Result integer ( I4B ) :: status !! Status flag assigned to this outcome ! Internals integer ( I4B ) :: i , istart , nfrag , ibiggest , nfamily , nstart , nend real ( DP ) :: mtot , avg_dens real ( DP ), dimension ( NDIM ) :: xcom , vcom , Ip_new real ( DP ), dimension ( 2 ) :: vol real ( DP ), dimension (:, :), allocatable :: vb_frag , xb_frag , rot_frag , Ip_frag real ( DP ), dimension (:), allocatable :: m_frag , rad_frag integer ( I4B ), dimension (:), allocatable :: id_frag logical :: lfailure ! Collisional fragments will be uniformly distributed around the pre-impact barycenter nfrag = NFRAG_DISRUPT allocate ( m_frag ( nfrag )) allocate ( rad_frag ( nfrag )) allocate ( xb_frag ( NDIM , nfrag )) allocate ( vb_frag ( NDIM , nfrag )) allocate ( rot_frag ( NDIM , nfrag )) allocate ( Ip_frag ( NDIM , nfrag )) allocate ( id_frag ( nfrag )) mtot = sum ( mass (:)) xcom (:) = ( mass ( 1 ) * x (:, 1 ) + mass ( 2 ) * x (:, 2 )) / mtot vcom (:) = ( mass ( 1 ) * v (:, 1 ) + mass ( 2 ) * v (:, 2 )) / mtot ! Get mass weighted mean of Ip and average density Ip_new (:) = ( mass ( 1 ) * Ip (:, 1 ) + mass ( 2 ) * Ip (:, 2 )) / mtot vol (:) = 4._DP / 3._DP * PI * radius (:) ** 3 avg_dens = mtot / sum ( vol (:)) ! Distribute the mass among fragments, with a branch to check for the size of the second largest fragment m_frag ( 1 ) = mass_res ( 1 ) if ( mass_res ( 2 ) > mass_res ( 1 ) / 3._DP ) then m_frag ( 2 ) = mass_res ( 2 ) istart = 3 else istart = 2 end if ! Distribute remaining mass among the remaining bodies do i = istart , nfrag m_frag ( i ) = ( mtot - sum ( m_frag ( 1 : istart - 1 ))) / ( nfrag - istart + 1 ) end do ! Distribute any residual mass if there is any and set the radius m_frag ( nfrag ) = m_frag ( nfrag ) + ( mtot - sum ( m_frag (:))) rad_frag (:) = ( 3 * m_frag (:) / ( 4 * PI * avg_dens )) ** ( 1.0_DP / 3.0_DP ) id_frag (:) = [( i , i = system % maxid + 1 , system % maxid + nfrag )] do i = 1 , nfrag Ip_frag (:, i ) = Ip_new (:) end do call fragmentation_initialize ( system , param , family , x , v , L_spin , Ip , mass , radius , & nfrag , Ip_frag , m_frag , rad_frag , xb_frag , vb_frag , rot_frag , Qloss , lfailure ) if ( lfailure ) then write ( * , * ) 'No fragment solution found, so treat as a pure hit-and-run' status = ACTIVE nfrag = 0 else ! Populate the list of new bodies write ( * , '(\"Generating \",I2.0,\" fragments\")' ) nfrag status = DISRUPTION call symba_fragmentation_mergeaddsub ( system , param , family , id_frag , Ip_frag , m_frag , rad_frag , xb_frag , vb_frag , rot_frag , status ) end if return end function symba_fragmentation_casedisruption module function symba_fragmentation_casehitandrun ( system , param , family , x , v , mass , radius , L_spin , Ip , mass_res , Qloss ) result ( status ) !! author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Create the fragments resulting from a non-catastrophic hit-and-run collision !! implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( in ) :: param !! Current run configuration parameters with SyMBA additions integer ( I4B ), dimension (:), intent ( in ) :: family !! List of indices of all bodies inovlved in the collision real ( DP ), dimension (:,:), intent ( inout ) :: x , v , L_spin , Ip !! Input values that represent a 2-body equivalent of a possibly 2+ body collision real ( DP ), dimension (:), intent ( inout ) :: mass , radius !! Input values that represent a 2-body equivalent of a possibly 2+ body collision real ( DP ), dimension (:), intent ( inout ) :: mass_res !! The distribution of fragment mass obtained by the regime calculation real ( DP ), intent ( inout ) :: Qloss !! Energy lost during collision ! Result integer ( I4B ) :: status !! Status flag assigned to this outcome ! Internals integer ( I4B ) :: i , nfrag , jproj , jtarg , idstart , ibiggest , nfamily real ( DP ) :: mtot , avg_dens real ( DP ), dimension ( NDIM ) :: xcom , vcom real ( DP ), dimension ( 2 ) :: vol real ( DP ), dimension (:, :), allocatable :: vb_frag , xb_frag , rot_frag , Ip_frag real ( DP ), dimension (:), allocatable :: m_frag , rad_frag integer ( I4B ), dimension (:), allocatable :: id_frag logical :: lpure logical , dimension ( system % pl % nbody ) :: lmask mtot = sum ( mass (:)) xcom (:) = ( mass ( 1 ) * x (:, 1 ) + mass ( 2 ) * x (:, 2 )) / mtot vcom (:) = ( mass ( 1 ) * v (:, 1 ) + mass ( 2 ) * v (:, 2 )) / mtot lpure = . false . ! The largest body will stay untouched if ( mass ( 1 ) > mass ( 2 )) then jtarg = 1 jproj = 2 else jtarg = 2 jproj = 1 end if if ( mass_res ( 2 ) > 0.9_DP * mass ( jproj )) then ! Pure hit and run, so we'll just keep the two bodies untouched write ( * , * ) 'Pure hit and run. No new fragments generated.' nfrag = 0 lpure = . true . else ! Imperfect hit and run, so we'll keep the largest body and destroy the other nfrag = NFRAG_DISRUPT - 1 lpure = . false . allocate ( m_frag ( nfrag )) allocate ( id_frag ( nfrag )) allocate ( rad_frag ( nfrag )) allocate ( xb_frag ( NDIM , nfrag )) allocate ( vb_frag ( NDIM , nfrag )) allocate ( rot_frag ( NDIM , nfrag )) allocate ( Ip_frag ( NDIM , nfrag )) m_frag ( 1 ) = mass ( jtarg ) ibiggest = maxloc ( system % pl % Gmass ( family (:)), dim = 1 ) id_frag ( 1 ) = system % pl % id ( ibiggest ) rad_frag ( 1 ) = radius ( jtarg ) xb_frag (:, 1 ) = x (:, jtarg ) vb_frag (:, 1 ) = v (:, jtarg ) Ip_frag (:, 1 ) = Ip (:, jtarg ) ! Get mass weighted mean of Ip and average density vol (:) = 4._DP / 3._DP * pi * radius (:) ** 3 avg_dens = mass ( jproj ) / vol ( jproj ) m_frag ( 2 : nfrag ) = ( mtot - m_frag ( 1 )) / ( nfrag - 1 ) rad_frag ( 2 : nfrag ) = ( 3 * m_frag ( 2 : nfrag ) / ( 4 * PI * avg_dens )) ** ( 1.0_DP / 3.0_DP ) m_frag ( nfrag ) = m_frag ( nfrag ) + ( mtot - sum ( m_frag (:))) id_frag ( 2 : nfrag ) = [( i , i = system % maxid + 1 , system % maxid + nfrag - 1 )] do i = 1 , nfrag Ip_frag (:, i ) = Ip (:, jproj ) end do ! Put the fragments on the circle surrounding the center of mass of the system call fragmentation_initialize ( system , param , family , x , v , L_spin , Ip , mass , radius , & nfrag , Ip_frag , m_frag , rad_frag , xb_frag , vb_frag , rot_frag , Qloss , lpure ) if ( lpure ) then write ( * , * ) 'Should have been a pure hit and run instead' nfrag = 0 else write ( * , '(\"Generating \",I2.0,\" fragments\")' ) nfrag end if end if if ( lpure ) then status = ACTIVE else status = HIT_AND_RUN call symba_fragmentation_mergeaddsub ( system , param , family , id_frag , Ip_frag , m_frag , rad_frag , xb_frag , vb_frag , rot_frag , status ) end if return end function symba_fragmentation_casehitandrun module function symba_fragmentation_casemerge ( system , param , family , x , v , mass , radius , L_spin , Ip ) result ( status ) !! author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Merge planets. !! !! Adapted from David E. Kaufmann's Swifter routines symba_merge_pl.f90 and symba_discard_merge_pl.f90 !! !! Adapted from Hal Levison's Swift routines symba5_merge.f and discard_mass_merge.f implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( in ) :: param !! Current run configuration parameters with SyMBA additions integer ( I4B ), dimension (:), intent ( in ) :: family !! List of indices of all bodies inovlved in the collision real ( DP ), dimension (:,:), intent ( in ) :: x , v , L_spin , Ip !! Input values that represent a 2-body equivalent of a possibly 2+ body collision real ( DP ), dimension (:), intent ( in ) :: mass , radius !! Input values that represent a 2-body equivalent of a possibly 2+ body collision ! Result integer ( I4B ) :: status !! Status flag assigned to this outcome ! Internals integer ( I4B ) :: i , j , ibiggest , nfamily real ( DP ) :: volume_new , pe real ( DP ), dimension ( NDIM ) :: xc , vc , xcrossv real ( DP ), dimension ( 2 ) :: vol real ( DP ), dimension ( NDIM ) :: L_orb_old , L_spin_old real ( DP ), dimension ( NDIM ) :: L_spin_new logical , dimension ( system % pl % nbody ) :: lmask real ( DP ), dimension ( NDIM , 1 ) :: vb_frag , xb_frag , rot_frag , Ip_frag real ( DP ), dimension ( 1 ) :: m_frag , rad_frag integer ( I4B ), dimension ( 1 ) :: id_frag select type ( pl => system % pl ) class is ( symba_pl ) write ( * , '(\"Merging bodies \",99(I8,\",\",:))' ) pl % id ( family (:)) ibiggest = maxloc ( pl % Gmass ( family (:)), dim = 1 ) id_frag ( 1 ) = pl % id ( family ( ibiggest )) m_frag ( 1 ) = sum ( mass (:)) ! Merged body is created at the barycenter of the original bodies xb_frag (:, 1 ) = ( mass ( 1 ) * x (:, 1 ) + mass ( 2 ) * x (:, 2 )) / m_frag ( 1 ) vb_frag (:, 1 ) = ( mass ( 1 ) * v (:, 1 ) + mass ( 2 ) * v (:, 2 )) / m_frag ( 1 ) ! Get mass weighted mean of Ip and vol (:) = 4._DP / 3._DP * PI * radius (:) ** 3 volume_new = sum ( vol (:)) rad_frag ( 1 ) = ( 3 * volume_new / ( 4 * PI )) ** ( 1._DP / 3._DP ) L_orb_old (:) = 0.0_DP ! Compute orbital angular momentum of pre-impact system do i = 1 , 2 xc (:) = x (:, i ) - xb_frag (:, 1 ) vc (:) = v (:, i ) - vb_frag (:, 1 ) xcrossv (:) = xc (:) . cross . vc (:) L_orb_old (:) = L_orb_old (:) + mass ( i ) * xcrossv (:) end do if ( param % lrotation ) then Ip_frag (:, 1 ) = ( mass ( 1 ) * Ip (:, 1 ) + mass ( 2 ) * Ip (:, 2 )) / m_frag ( 1 ) L_spin_old (:) = L_spin (:, 1 ) + L_spin (:, 2 ) ! Conserve angular momentum by putting pre-impact orbital momentum into spin of the new body L_spin_new (:) = L_orb_old (:) + L_spin_old (:) ! Assume prinicpal axis rotation on 3rd Ip axis rot_frag (:, 1 ) = L_spin_new (:) / ( Ip_frag ( 3 , 1 ) * m_frag ( 1 ) * rad_frag ( 1 ) ** 2 ) else ! If spin is not enabled, we will consider the lost pre-collision angular momentum as \"escaped\" and add it to our bookkeeping variable system % Lescape (:) = system % Lescape (:) + L_orb_old (:) end if ! Keep track of the component of potential energy due to the pre-impact family for book-keeping nfamily = size ( family (:)) pe = 0.0_DP do j = 1 , nfamily do i = j + 1 , nfamily pe = pe - pl % mass ( i ) * pl % mass ( j ) / norm2 ( pl % xb (:, i ) - pl % xb (:, j )) end do end do system % Ecollisions = system % Ecollisions + pe system % Euntracked = system % Euntracked - pe status = MERGED call symba_fragmentation_mergeaddsub ( system , param , family , id_frag , Ip_frag , m_frag , rad_frag , xb_frag , vb_frag , rot_frag , status ) end select return end function symba_fragmentation_casemerge module function symba_fragmentation_casesupercatastrophic ( system , param , family , x , v , mass , radius , L_spin , Ip , mass_res , Qloss ) result ( status ) !! author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Create the fragments resulting from a supercatastrophic collision !! implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( in ) :: param !! Current run configuration parameters with SyMBA additions integer ( I4B ), dimension (:), intent ( in ) :: family !! List of indices of all bodies inovlved in the collision real ( DP ), dimension (:,:), intent ( inout ) :: x , v , L_spin , Ip !! Input values that represent a 2-body equivalent of a possibly 2+ body collision real ( DP ), dimension (:), intent ( inout ) :: mass , radius !! Input values that represent a 2-body equivalent of a possibly 2+ body collision real ( DP ), dimension (:), intent ( inout ) :: mass_res !! The distribution of fragment mass obtained by the regime calculation real ( DP ), intent ( inout ) :: Qloss !! Energy lost during collision ! Result integer ( I4B ) :: status !! Status flag assigned to this outcome ! Internals integer ( I4B ) :: i , nfrag , ibiggest , nfamily , nstart , nend real ( DP ) :: mtot , avg_dens , min_frag_mass real ( DP ), dimension ( NDIM ) :: xcom , vcom real ( DP ), dimension ( 2 ) :: vol real ( DP ), dimension ( NDIM ) :: Ip_new real ( DP ), dimension (:, :), allocatable :: vb_frag , xb_frag , rot_frag , Ip_frag real ( DP ), dimension (:), allocatable :: m_frag , rad_frag integer ( I4B ), dimension (:), allocatable :: id_frag logical :: lfailure logical , dimension ( system % pl % nbody ) :: lmask ! Collisional fragments will be uniformly distributed around the pre-impact barycenter nfrag = NFRAG_SUPERCAT allocate ( m_frag ( nfrag )) allocate ( rad_frag ( nfrag )) allocate ( id_frag ( nfrag )) allocate ( xb_frag ( NDIM , nfrag )) allocate ( vb_frag ( NDIM , nfrag )) allocate ( rot_frag ( NDIM , nfrag )) allocate ( Ip_frag ( NDIM , nfrag )) mtot = sum ( mass (:)) xcom (:) = ( mass ( 1 ) * x (:, 1 ) + mass ( 2 ) * x (:, 2 )) / mtot vcom (:) = ( mass ( 1 ) * v (:, 1 ) + mass ( 2 ) * v (:, 2 )) / mtot ! Get mass weighted mean of Ip and average density Ip_new (:) = ( mass ( 1 ) * Ip (:, 1 ) + mass ( 2 ) * Ip (:, 2 )) / mtot vol (:) = 4._DP / 3._DP * pi * radius (:) ** 3 avg_dens = mtot / sum ( vol (:)) ! If we are adding the first and largest fragment (lr), check to see if its mass is SMALLER than an equal distribution of ! mass between all fragments. If so, we will just distribute the mass equally between the fragments min_frag_mass = mtot / nfrag if ( mass_res ( 1 ) < min_frag_mass ) then m_frag (:) = min_frag_mass else m_frag ( 1 ) = mass_res ( 1 ) m_frag ( 2 : nfrag ) = ( mtot - mass_res ( 1 )) / ( nfrag - 1 ) end if ! Distribute any residual mass if there is any and set the radius m_frag ( nfrag ) = m_frag ( nfrag ) + ( mtot - sum ( m_frag (:))) rad_frag (:) = ( 3 * m_frag (:) / ( 4 * PI * avg_dens )) ** ( 1.0_DP / 3.0_DP ) id_frag (:) = [( i , i = system % maxid + 1 , system % maxid + nfrag )] do i = 1 , nfrag Ip_frag (:, i ) = Ip_new (:) end do call fragmentation_initialize ( system , param , family , x , v , L_spin , Ip , mass , radius , & nfrag , Ip_frag , m_frag , rad_frag , xb_frag , vb_frag , rot_frag , Qloss , lfailure ) if ( lfailure ) then write ( * , * ) 'No fragment solution found, so treat as a pure hit-and-run' status = ACTIVE nfrag = 0 else ! Populate the list of new bodies write ( * , '(\"Generating \",I2.0,\" fragments\")' ) nfrag status = SUPERCATASTROPHIC call symba_fragmentation_mergeaddsub ( system , param , family , id_frag , Ip_frag , m_frag , rad_frag , xb_frag , vb_frag , rot_frag , status ) end if return end function symba_fragmentation_casesupercatastrophic subroutine symba_fragmentation_mergeaddsub ( system , param , family , id_frag , Ip_frag , m_frag , rad_frag , xb_frag , vb_frag , rot_frag , status ) !! author:  David A. Minton !! !! Fills the pl_discards and pl_adds with removed and added bodies !! implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( in ) :: param !! Current run configuration parameters with SyMBA additions integer ( I4B ), dimension (:), intent ( in ) :: family !! List of indices of all bodies inovlved in the collision integer ( I4B ), dimension (:), intent ( in ) :: id_frag !! List of fragment ids real ( DP ), dimension (:), intent ( in ) :: m_frag , rad_frag !! Distribution of fragment mass and radii real ( DP ), dimension (:,:), intent ( in ) :: Ip_frag !! Fragment rotational inertia vectors real ( DP ), dimension (:,:), intent ( in ) :: xb_frag , vb_frag , rot_frag !! Fragment barycentric position, barycentric velocity, and rotation vectors integer ( I4B ), intent ( in ) :: status !! Status flag to assign to adds ! Internals integer ( I4B ) :: i , ibiggest , nstart , nend , nfamily , nfrag logical , dimension ( system % pl % nbody ) :: lmask class ( symba_pl ), allocatable :: plnew select type ( pl => system % pl ) class is ( symba_pl ) select type ( pl_discards => system % pl_discards ) class is ( symba_merger ) associate ( pl_adds => system % pl_adds , cb => system % cb ) ! Add the family bodies to the subtraction list nfamily = size ( family (:)) nfrag = size ( m_frag (:)) lmask (:) = . false . lmask ( family (:)) = . true . pl % status ( family (:)) = MERGED nstart = pl_discards % nbody + 1 nend = pl_discards % nbody + nfamily call pl_discards % append ( pl , lmask ) pl % ldiscard ( family (:)) = . true . pl % lcollision ( family (:)) = . true . ! Record how many bodies were subtracted in this event pl_discards % ncomp ( nstart : nend ) = nfamily ! Setup new bodies allocate ( plnew , mold = pl ) call plnew % setup ( nfrag , param ) ibiggest = maxloc ( pl % Gmass ( family (:)), dim = 1 ) plnew % id (:) = id_frag (:) system % maxid = system % maxid + nfrag plnew % status (:) = ACTIVE plnew % lcollision (:) = . false . plnew % ldiscard (:) = . false . plnew % xb (:,:) = xb_frag (:, :) plnew % vb (:,:) = vb_frag (:, :) do i = 1 , nfrag plnew % xh (:, i ) = xb_frag (:, i ) - cb % xb (:) plnew % vh (:, i ) = vb_frag (:, i ) - cb % vb (:) end do plnew % mass (:) = m_frag (:) plnew % Gmass (:) = param % GU * m_frag (:) plnew % radius (:) = rad_frag (:) plnew % density (:) = m_frag (:) / rad_frag (:) select case ( status ) case ( DISRUPTION ) plnew % info (:)% origin_type = \"Disruption\" case ( SUPERCATASTROPHIC ) plnew % info (:)% origin_type = \"Supercatastrophic\" case ( HIT_AND_RUN ) plnew % info (:)% origin_type = \"Hit and run fragment\" case ( MERGED ) plnew % info ( 1 ) = pl % info ( ibiggest ) end select if ( status /= MERGED ) then plnew % info (:)% origin_time = param % t do i = 1 , nfrag plnew % info ( i )% origin_xh (:) = plnew % xh (:, i ) plnew % info ( i )% origin_vh (:) = plnew % vh (:, i ) end do end if if ( param % lrotation ) then plnew % Ip (:,:) = Ip_frag (:,:) plnew % rot (:,:) = rot_frag (:,:) end if if ( param % ltides ) then plnew % Q = pl % Q ( ibiggest ) plnew % k2 = pl % k2 ( ibiggest ) plnew % tlag = pl % tlag ( ibiggest ) end if call plnew % set_mu ( cb ) pl % lmtiny (:) = pl % Gmass (:) > param % GMTINY ! Append the new merged body to the list and record how many we made nstart = pl_adds % nbody + 1 nend = pl_adds % nbody + plnew % nbody call pl_adds % append ( plnew , lsource_mask = [(. true ., i = 1 , plnew % nbody )]) pl_adds % ncomp ( nstart : nend ) = plnew % nbody call plnew % setup ( 0 , param ) deallocate ( plnew ) end associate end select end select return end subroutine symba_fragmentation_mergeaddsub end submodule s_symba_fragmentation","tags":"","loc":"sourcefile/symba_fragmentation.f90.html"},{"title":"symba_encounter_check.f90 – swiftest","text":"This file depends on sourcefile~~symba_encounter_check.f90~~EfferentGraph sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_encounter_check.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_symba_encounter_check Source Code symba_encounter_check.f90 Source Code submodule ( symba_classes ) s_symba_encounter_check use swiftest contains module function symba_encounter_check_pl ( self , system , dt , irec ) result ( lany_encounter ) !! author: David A. Minton !! !! Check for an encounter between massive bodies. !! implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA test particle object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object real ( DP ), intent ( in ) :: dt !! step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level ! Result logical :: lany_encounter !! Returns true if there is at least one close encounter ! Internals integer ( I8B ) :: k integer ( I4B ) :: nenc real ( DP ), dimension ( NDIM ) :: xr , vr logical , dimension (:), allocatable :: lencounter , loc_lvdotr if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody , nplpl => self % nplpl ) allocate ( lencounter ( nplpl ), loc_lvdotr ( nplpl )) lencounter (:) = . false . do k = 1 , nplpl associate ( i => pl % k_plpl ( 1 , k ), j => pl % k_plpl ( 2 , k )) xr (:) = pl % xh (:, j ) - pl % xh (:, i ) vr (:) = pl % vh (:, j ) - pl % vh (:, i ) call symba_encounter_check_one ( xr ( 1 ), xr ( 2 ), xr ( 3 ), vr ( 1 ), vr ( 2 ), vr ( 3 ), pl % rhill ( i ), pl % rhill ( j ), dt , irec , lencounter ( k ), loc_lvdotr ( k )) end associate end do nenc = count ( lencounter (:)) lany_encounter = nenc > 0 if ( lany_encounter ) then associate ( plplenc_list => system % plplenc_list ) call plplenc_list % resize ( nenc ) plplenc_list % lvdotr ( 1 : nenc ) = pack ( loc_lvdotr (:), lencounter (:)) plplenc_list % index1 ( 1 : nenc ) = pack ( pl % k_plpl ( 1 ,:), lencounter (:)) plplenc_list % index2 ( 1 : nenc ) = pack ( pl % k_plpl ( 2 ,:), lencounter (:)) do k = 1 , nenc plplenc_list % status ( k ) = ACTIVE plplenc_list % level ( k ) = irec pl % lencounter ( plplenc_list % index1 ( k )) = . true . pl % lencounter ( plplenc_list % index2 ( k )) = . true . end do end associate end if end associate return end function symba_encounter_check_pl module function symba_encounter_check_pltpenc ( self , system , dt , irec ) result ( lany_encounter ) !! author: David A. Minton !! !! Check for an encounter between test particles and massive bodies in the pltpenc list. !! Note: This method works for the polymorphic symba_pltpenc and symba_plplenc types. !! !! Adapted from portions of David E. Kaufmann's Swifter routine: symba_step_recur.f90 implicit none ! Arguments class ( symba_pltpenc ), intent ( inout ) :: self !! SyMBA pl-pl encounter list object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object real ( DP ), intent ( in ) :: dt !! step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level logical :: lany_encounter !! Returns true if there is at least one close encounter ! Internals integer ( I4B ) :: k real ( DP ), dimension ( NDIM ) :: xr , vr logical :: lencounter , isplpl real ( DP ) :: rlim2 , rji2 logical , dimension (:), allocatable :: lencmask lany_encounter = . false . if ( self % nenc == 0 ) return select type ( self ) class is ( symba_plplenc ) isplpl = . true . class is ( symba_pltpenc ) isplpl = . false . end select select type ( pl => system % pl ) class is ( symba_pl ) select type ( tp => system % tp ) class is ( symba_tp ) allocate ( lencmask ( self % nenc )) lencmask (:) = ( self % status ( 1 : self % nenc ) == ACTIVE ) . and . ( self % level ( 1 : self % nenc ) == irec - 1 ) if (. not . any ( lencmask (:))) return associate ( ind1 => self % index1 , ind2 => self % index2 ) do concurrent ( k = 1 : self % nenc , lencmask ( k )) if ( isplpl ) then xr (:) = pl % xh (:, ind2 ( k )) - pl % xh (:, ind1 ( k )) vr (:) = pl % vb (:, ind2 ( k )) - pl % vb (:, ind1 ( k )) call symba_encounter_check_one ( xr ( 1 ), xr ( 2 ), xr ( 3 ), vr ( 1 ), vr ( 2 ), vr ( 3 ), pl % rhill ( ind1 ( k )), pl % rhill ( ind2 ( k )), dt , irec , lencounter , self % lvdotr ( k )) else xr (:) = tp % xh (:, ind2 ( k )) - pl % xh (:, ind1 ( k )) vr (:) = tp % vb (:, ind2 ( k )) - pl % vb (:, ind1 ( k )) call symba_encounter_check_one ( xr ( 1 ), xr ( 2 ), xr ( 3 ), vr ( 1 ), vr ( 2 ), vr ( 3 ), pl % rhill ( ind1 ( k )), 0.0_DP , dt , irec , lencounter , self % lvdotr ( k )) end if if ( lencounter ) then if ( isplpl ) then rlim2 = ( pl % radius ( ind1 ( k )) + pl % radius ( ind2 ( k ))) ** 2 else rlim2 = ( pl % radius ( ind1 ( k ))) ** 2 end if rji2 = dot_product ( xr (:), xr (:)) ! Check to see if these are physically overlapping bodies first, which we should ignore if ( rji2 > rlim2 ) then lany_encounter = . true . pl % levelg ( ind1 ( k )) = irec pl % levelm ( ind1 ( k )) = MAX ( irec , pl % levelm ( ind1 ( k ))) if ( isplpl ) then pl % levelg ( ind2 ( k )) = irec pl % levelm ( ind2 ( k )) = MAX ( irec , pl % levelm ( ind2 ( k ))) else tp % levelg ( ind2 ( k )) = irec tp % levelm ( ind2 ( k )) = MAX ( irec , tp % levelm ( ind2 ( k ))) end if self % level ( k ) = irec end if end if end do end associate end select end select return end function symba_encounter_check_pltpenc module function symba_encounter_check_tp ( self , system , dt , irec ) result ( lany_encounter ) !! author: David A. Minton !! !! Check for an encounter between test particles and massive bodies. !! implicit none ! Arguments class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object real ( DP ), intent ( in ) :: dt !! step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level ! Result logical :: lany_encounter !! Returns true if there is at least one close encounter ! Internals real ( DP ) :: r2crit , vdotr , r2 , v2 , tmin , r2min , term2 integer ( I4B ) :: i , j , k , nenc real ( DP ), dimension ( NDIM ) :: xr , vr logical , dimension (:,:), allocatable :: lencounter , loc_lvdotr if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody , pl => system % pl , npl => system % pl % nbody ) allocate ( lencounter ( ntp , npl ), loc_lvdotr ( ntp , npl )) lencounter (:,:) = . false . do j = 1 , npl do i = 1 , ntp xr (:) = tp % xh (:, i ) - pl % xh (:, j ) vr (:) = tp % vh (:, i ) - pl % vh (:, j ) call symba_encounter_check_one ( xr ( 1 ), xr ( 2 ), xr ( 3 ), vr ( 1 ), vr ( 2 ), vr ( 3 ), pl % rhill ( j ), 0.0_DP , dt , irec , lencounter ( i , j ), loc_lvdotr ( i , j )) end do end do nenc = count ( lencounter (:,:)) lany_encounter = nenc > 0 if ( lany_encounter ) then associate ( pltpenc_list => system % pltpenc_list ) call pltpenc_list % resize ( nenc ) pltpenc_list % status ( 1 : nenc ) = ACTIVE pltpenc_list % level ( 1 : nenc ) = irec pltpenc_list % lvdotr ( 1 : nenc ) = pack ( loc_lvdotr (:,:), lencounter (:,:)) pltpenc_list % index1 ( 1 : nenc ) = pack ( spread ([( i , i = 1 , npl )], dim = 1 , ncopies = ntp ), lencounter (:,:)) pltpenc_list % index2 ( 1 : nenc ) = pack ( spread ([( i , i = 1 , ntp )], dim = 2 , ncopies = npl ), lencounter (:,:)) select type ( pl ) class is ( symba_pl ) pl % lencounter (:) = . false . do k = 1 , nenc pl % lencounter ( pltpenc_list % index1 ( k )) = . true . end do end select end associate end if end associate return end function symba_encounter_check_tp module pure elemental subroutine symba_encounter_check_one ( xr , yr , zr , vxr , vyr , vzr , rhill1 , rhill2 , dt , irec , lencounter , lvdotr ) !! author: David A. Minton !! !! Check for an encounter. !! !! Adapted from David E. Kaufmann's Swifter routine: symba_chk.f90 !! Adapted from Hal Levison's Swift routine symba5_chk.f implicit none ! Arguments real ( DP ), intent ( in ) :: xr , yr , zr , vxr , vyr , vzr real ( DP ), intent ( in ) :: rhill1 , rhill2 , dt integer ( I4B ), intent ( in ) :: irec logical , intent ( out ) :: lencounter , lvdotr ! Internals real ( DP ) :: r2 , v2 , rcrit , r2crit , vdotr rcrit = ( rhill1 + rhill2 ) * RHSCALE * ( RSHELL ** ( irec )) r2crit = rcrit ** 2 r2 = xr ** 2 + yr ** 2 + zr ** 2 v2 = vxr ** 2 + vyr ** 2 + vzr ** 2 vdotr = xr * vxr + yr * vyr + zr * vzr lencounter = rmvs_chk_ind ( r2 , v2 , vdotr , dt , r2crit ) lvdotr = ( vdotr < 0.0_DP ) return end subroutine symba_encounter_check_one end submodule s_symba_encounter_check","tags":"","loc":"sourcefile/symba_encounter_check.f90.html"},{"title":"symba_io.f90 – swiftest","text":"This file depends on sourcefile~~symba_io.f90~~EfferentGraph sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_io.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_symba_io Source Code symba_io.f90 Source Code submodule ( symba_classes ) s_symba_io use swiftest contains module subroutine symba_io_dump_particle_info ( system , param , lincludecb , tpidx , plidx ) !! author: David A. Minton !! !! Dumps the particle information data to a file. !! Pass a list of array indices for test particles (tpidx) and/or massive bodies (plidx) to append implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( in ) :: param !! Current run configuration parameters with SyMBA extensions logical , optional , intent ( in ) :: lincludecb !! Set to true to include the central body (default is false) integer ( I4B ), dimension (:), optional , intent ( in ) :: tpidx !! Array of test particle indices to append to the particle file integer ( I4B ), dimension (:), optional , intent ( in ) :: plidx !! Array of massive body indices to append to the particle file ! Internals logical , save :: lfirst = . true . integer ( I4B ), parameter :: LUN = 22 integer ( I4B ) :: i , ierr if ( lfirst ) then select case ( param % out_stat ) case ( 'APPEND' ) open ( unit = LUN , file = param % particle_out , status = 'OLD' , position = 'APPEND' , form = 'UNFORMATTED' , iostat = ierr ) case ( 'NEW' , 'UNKNOWN' , 'REPLACE' ) open ( unit = LUN , file = param % particle_out , status = param % out_stat , form = 'UNFORMATTED' , iostat = ierr ) case default write ( * , * ) 'Invalid status code' , trim ( adjustl ( param % out_stat )) call util_exit ( FAILURE ) end select if ( ierr /= 0 ) then write ( * , * ) \"Swiftest error:\" write ( * , * ) \"   particle output file already exists or cannot be accessed\" call util_exit ( FAILURE ) end if lfirst = . false . else open ( unit = LUN , file = param % particle_out , status = 'OLD' , position = 'APPEND' , form = 'UNFORMATTED' , iostat = ierr ) if ( ierr /= 0 ) then write ( * , * ) \"Swiftest error:\" write ( * , * ) \"   unable to open binary output file for APPEND\" call util_exit ( FAILURE ) end if end if if ( present ( lincludecb )) then if ( lincludecb ) then select type ( cb => system % cb ) class is ( symba_cb ) write ( LUN ) cb % id write ( LUN ) cb % info end select end if end if if ( present ( plidx ) . and . ( system % pl % nbody > 0 )) then select type ( pl => system % pl ) class is ( symba_pl ) do i = 1 , size ( plidx ) write ( LUN ) pl % id ( plidx ( i )) write ( LUN ) pl % info ( plidx ( i )) end do end select end if if ( present ( tpidx ) . and . ( system % tp % nbody > 0 )) then select type ( tp => system % tp ) class is ( symba_tp ) do i = 1 , size ( tpidx ) write ( LUN ) tp % id ( tpidx ( i )) write ( LUN ) tp % info ( tpidx ( i )) end do end select end if close ( unit = LUN , iostat = ierr ) if ( ierr /= 0 ) then write ( * , * ) \"Swiftest error:\" write ( * , * ) \"   unable to close particle output file\" call util_exit ( FAILURE ) end if return end subroutine symba_io_dump_particle_info module subroutine symba_io_param_reader ( self , unit , iotype , v_list , iostat , iomsg ) !! author: The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Read in parameters specific to the SyMBA integrator, then calls the base io_param_reader. !! !! Adapted from David E. Kaufmann's Swifter routine io_init_param.f90 !! Adapted from Martin Duncan's Swift routine io_init_param.f implicit none ! Arguments class ( symba_parameters ), intent ( inout ) :: self !! Collection of parameters integer , intent ( in ) :: unit !! File unit number character ( len =* ), intent ( in ) :: iotype !! Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. !!    If you do not include a char-literal-constant, the iotype argument contains only DT. integer , intent ( in ) :: v_list (:) !! The first element passes the integrator code to the reader integer , intent ( out ) :: iostat !! IO status code character ( len =* ), intent ( inout ) :: iomsg !! Message to pass if iostat /= 0 ! internals integer ( I4B ) :: ilength , ifirst , ilast !! Variables used to parse input file character ( STRMAX ) :: line !! Line of the input file character ( len = :), allocatable :: line_trim , param_name , param_value !! Strings used to parse the param file integer ( I4B ) :: nseeds , nseeds_from_file , i logical :: seed_set = . false . !! Is the random seed set in the input file? character ( len =* ), parameter :: linefmt = '(A)' associate ( param => self ) call io_param_reader ( param , unit , iotype , v_list , iostat , iomsg ) call random_seed ( size = nseeds ) if ( allocated ( param % seed )) deallocate ( param % seed ) allocate ( param % seed ( nseeds )) rewind ( unit ) do read ( unit = unit , fmt = linefmt , iostat = iostat , end = 1 ) line line_trim = trim ( adjustl ( line )) ilength = len ( line_trim ) if (( ilength /= 0 )) then ifirst = 1 ! Read the pair of tokens. The first one is the parameter name, the second is the value. param_name = io_get_token ( line_trim , ifirst , ilast , iostat ) if ( param_name == '' ) cycle ! No parameter name (usually because this line is commented out) call io_toupper ( param_name ) ifirst = ilast + 1 param_value = io_get_token ( line_trim , ifirst , ilast , iostat ) select case ( param_name ) case ( \"PARTICLE_OUT\" ) param % particle_out = param_value case ( \"FRAGMENTATION\" ) call io_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == \"T\" ) self % lfragmentation = . true . case ( \"GMTINY\" ) read ( param_value , * ) param % Gmtiny case ( \"SEED\" ) read ( param_value , * ) nseeds_from_file ! Because the number of seeds can vary between compilers/systems, we need to make sure we can handle cases in which the input file has a different ! number of seeds than the current system. If the number of seeds in the file is smaller than required, we will use them as a source to fill in the missing elements. ! If the number of seeds in the file is larger than required, we will truncate the seed array. if ( nseeds_from_file > nseeds ) then nseeds = nseeds_from_file deallocate ( param % seed ) allocate ( param % seed ( nseeds )) do i = 1 , nseeds ifirst = ilast + 1 param_value = io_get_token ( line , ifirst , ilast , iostat ) read ( param_value , * ) param % seed ( i ) end do else ! Seed array in file is too small do i = 1 , nseeds_from_file ifirst = ilast + 1 param_value = io_get_token ( line , ifirst , ilast , iostat ) read ( param_value , * ) param % seed ( i ) end do param % seed ( nseeds_from_file + 1 : nseeds ) = [( param % seed ( 1 ) - param % seed ( nseeds_from_file ) + i , i = nseeds_from_file + 1 , nseeds )] end if seed_set = . true . end select end if end do 1 continue write ( * , * ) \"FRAGMENTATION = \" , param % lfragmentation if ( param % lfragmentation ) then if ( seed_set ) then call random_seed ( put = param % seed ) else call random_seed ( get = param % seed ) end if write ( * , * ) \"SEED: N,VAL    = \" , size ( param % seed ), param % seed (:) end if if ( self % Gmtiny < 0.0_DP ) then write ( iomsg , * ) \"GMTINY invalid or not set: \" , self % Gmtiny iostat = - 1 return else write ( * , * ) \"GMTINY          = \" , self % Gmtiny end if if (. not . self % lclose ) then write ( iomsg , * ) 'This integrator requires CHK_CLOSE to be enabled.' iostat = - 1 return end if end associate iostat = 0 return end subroutine symba_io_param_reader module subroutine symba_io_param_writer ( self , unit , iotype , v_list , iostat , iomsg ) !! author: David A. Minton !! !! Dump integration parameters specific to SyMBA to file and then call the base io_param_writer method. !! !! Adapted from David E. Kaufmann's Swifter routine io_dump_param.f90 !! Adapted from Martin Duncan's Swift routine io_dump_param.f implicit none ! Arguments class ( symba_parameters ), intent ( in ) :: self !! Collection of SyMBA parameters integer , intent ( in ) :: unit !! File unit number character ( len =* ), intent ( in ) :: iotype !! Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. !!    If you do not include a char-literal-constant, the iotype argument contains only DT. integer , intent ( in ) :: v_list (:) !! Not used in this procedure integer , intent ( out ) :: iostat !! IO status code character ( len =* ), intent ( inout ) :: iomsg !! Message to pass if iostat /= 0 ! Internals character ( * ), parameter :: Ifmt = '(I0)' !! Format label for integer values character ( * ), parameter :: Rfmt = '(ES25.17)' !! Format label for real values character ( * ), parameter :: Rarrfmt = '(3(ES25.17,1X))' !! Format label for real values character ( * ), parameter :: Lfmt = '(L1)' !! Format label for logical values character ( len =* ), parameter :: Afmt = '(A25,1X,64(:,A25,1X))' character ( 256 ) :: param_name , param_value type character_array character ( 25 ) :: value end type character_array type ( character_array ), dimension (:), allocatable :: param_array integer ( I4B ) :: i associate ( param => self ) call io_param_writer ( param , unit , iotype , v_list , iostat , iomsg ) ! Special handling is required for writing the random number seed array as its size is not known until runtime ! For the \"SEED\" parameter line, the first value will be the size of the seed array and the rest will be the seed array elements write ( param_name , Afmt ) \"PARTICLE_OUT\" ; write ( param_value , Afmt ) trim ( adjustl ( param % particle_out )); write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"GMTINY\" ; write ( param_value , Rfmt ) param % Gmtiny ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) write ( param_name , Afmt ) \"FRAGMENTATION\" ; write ( param_value , Lfmt ) param % lfragmentation ; write ( unit , Afmt ) adjustl ( param_name ), adjustl ( param_value ) if ( param % lfragmentation ) then write ( param_name , Afmt ) \"SEED\" if ( allocated ( param_array )) deallocate ( param_array ) allocate ( param_array ( 0 : size ( param % seed ))) write ( param_array ( 0 )% value , Ifmt ) size ( param % seed ) do i = 1 , size ( param % seed ) write ( param_array ( i )% value , Ifmt ) param % seed ( i ) end do write ( unit , Afmt , advance = 'no' ) adjustl ( param_name ), adjustl ( param_array ( 0 )% value ) do i = 1 , size ( param % seed ) if ( i < size ( param % seed )) then write ( unit , Afmt , advance = 'no' ) adjustl ( param_array ( i )% value ) else write ( unit , Afmt ) adjustl ( param_array ( i )% value ) end if end do end if iostat = 0 end associate return end subroutine symba_io_param_writer module subroutine symba_io_read_particle ( system , param ) !! author: David A. Minton !! !! Reads an old particle information file for a restartd run implicit none class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system file class ( symba_parameters ), intent ( inout ) :: param !! Current run configuration parameters with SyMBA extensions ! Internals integer ( I4B ), parameter :: LUN = 22 integer ( I4B ) :: i , ierr , id , idx logical :: lmatch type ( symba_particle_info ) :: tmpinfo open ( unit = LUN , file = param % particle_out , status = 'OLD' , form = 'UNFORMATTED' , iostat = ierr ) if ( ierr /= 0 ) then write ( * , * ) \"Swiftest error:\" write ( * , * ) \"   unable to open binary particle file for reading\" call util_exit ( FAILURE ) end if select type ( cb => system % cb ) class is ( symba_cb ) select type ( pl => system % pl ) class is ( symba_pl ) select type ( tp => system % tp ) class is ( symba_tp ) do lmatch = . false . read ( LUN , iostat = ierr ) id if ( ierr /= 0 ) exit if ( idx == cb % id ) then read ( LUN ) cb % info lmatch = . true . else if ( pl % nbody > 0 ) then idx = findloc ( pl % id (:), id , dim = 1 ) if ( idx /= 0 ) then read ( LUN ) pl % info ( idx ) lmatch = . true . end if end if if (. not . lmatch . and . tp % nbody > 0 ) then idx = findloc ( tp % id (:), id , dim = 1 ) if ( idx /= 0 ) then read ( LUN ) tp % info ( idx ) lmatch = . true . end if end if end if if (. not . lmatch ) then write ( * , * ) 'Particle id ' , id , ' not found. Skipping' read ( LUN ) tmpinfo end if end do close ( unit = LUN , iostat = ierr ) end select end select end select if ( ierr /= 0 ) then write ( * , * ) \"Swiftest error:\" write ( * , * ) \"   unable to close particle output file\" call util_exit ( FAILURE ) end if return end subroutine symba_io_read_particle module subroutine symba_io_write_discard ( self , param ) implicit none class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ), parameter :: LUN = 40 integer ( I4B ) :: iadd , isub , j , ierr , nsub , nadd logical , save :: lfirst = . true . real ( DP ), dimension (:,:), allocatable :: vh character ( * ), parameter :: HDRFMT = '(E23.16, 1X, I8, 1X, L1)' character ( * ), parameter :: NAMEFMT = '(A, 2(1X, I8))' character ( * ), parameter :: VECFMT = '(3(E23.16, 1X))' character ( * ), parameter :: NPLFMT = '(I8)' character ( * ), parameter :: PLNAMEFMT = '(I8, 2(1X, E23.16))' class ( swiftest_body ), allocatable :: pltemp associate ( pl => self % pl , npl => self % pl % nbody , pl_adds => self % pl_adds ) if ( self % tp_discards % nbody > 0 ) call io_write_discard ( self , param ) select type ( pl_discards => self % pl_discards ) class is ( symba_merger ) if ( pl_discards % nbody == 0 ) return select case ( param % out_stat ) case ( 'APPEND' ) open ( unit = LUN , file = param % discard_out , status = 'OLD' , position = 'APPEND' , form = 'FORMATTED' , iostat = ierr ) case ( 'NEW' , 'REPLACE' , 'UNKNOWN' ) open ( unit = LUN , file = param % discard_out , status = param % out_stat , form = 'FORMATTED' , iostat = ierr ) case default write ( * , * ) 'Invalid status code for OUT_STAT: ' , trim ( adjustl ( param % out_stat )) call util_exit ( FAILURE ) end select lfirst = . false . if ( param % lgr ) then call pl_discards % pv2v ( param ) call pl_adds % pv2v ( param ) end if write ( LUN , HDRFMT ) param % t , pl_discards % nbody , param % lbig_discard iadd = 1 isub = 1 do while ( iadd <= pl_adds % nbody ) nadd = pl_adds % ncomp ( iadd ) nsub = pl_discards % ncomp ( isub ) do j = 1 , nadd if ( iadd <= pl_adds % nbody ) then write ( LUN , NAMEFMT ) ADD , pl_adds % id ( iadd ), pl_adds % status ( iadd ) write ( LUN , VECFMT ) pl_adds % xh ( 1 , iadd ), pl_adds % xh ( 2 , iadd ), pl_adds % xh ( 3 , iadd ) write ( LUN , VECFMT ) pl_adds % vh ( 1 , iadd ), pl_adds % vh ( 2 , iadd ), pl_adds % vh ( 3 , iadd ) else exit end if iadd = iadd + 1 end do do j = 1 , nsub if ( isub <= pl_discards % nbody ) then write ( LUN , NAMEFMT ) SUB , pl_discards % id ( isub ), pl_discards % status ( isub ) write ( LUN , VECFMT ) pl_discards % xh ( 1 , isub ), pl_discards % xh ( 2 , isub ), pl_discards % xh ( 3 , isub ) write ( LUN , VECFMT ) pl_discards % vh ( 1 , isub ), pl_discards % vh ( 2 , isub ), pl_discards % vh ( 3 , isub ) else exit end if isub = isub + 1 end do end do close ( LUN ) end select end associate return end subroutine symba_io_write_discard end submodule s_symba_io","tags":"","loc":"sourcefile/symba_io.f90.html"},{"title":"symba_discard.f90 – swiftest","text":"This file depends on sourcefile~~symba_discard.f90~~EfferentGraph sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_discard.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_symba_discard Source Code symba_discard.f90 Source Code submodule ( symba_classes ) s_symba_discard use swiftest contains subroutine symba_discard_cb_pl ( pl , system , param ) !! author: David A. Minton !! !! Check to see if planets should be discarded based on their positions relative to the central body. !! If a body gets flagged here when it has also been previously flagged for a collision with another massive body, !! its collisional status will be revoked. Discards due to colliding with or escaping the central body take precedence !! over pl-pl collisions !! !! Adapted from David E. Kaufmann's Swifter routine: symba_discard_sun.f90 !! Adapted from Hal Levison's Swift routine discard_massive5.f implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: pl !! SyMBA massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i , j real ( DP ) :: energy , vb2 , rb2 , rh2 , rmin2 , rmax2 , rmaxu2 associate ( npl => pl % nbody , cb => system % cb ) call system % set_msys () rmin2 = param % rmin ** 2 rmax2 = param % rmax ** 2 rmaxu2 = param % rmaxu ** 2 do i = 1 , npl if ( pl % status ( i ) == ACTIVE ) then rh2 = dot_product ( pl % xh (:, i ), pl % xh (:, i )) if (( param % rmax >= 0.0_DP ) . and . ( rh2 > rmax2 )) then pl % ldiscard ( i ) = . true . pl % lcollision ( i ) = . false . pl % status ( i ) = DISCARDED_RMAX write ( * , * ) \"Massive body \" , pl % id ( i ), \" too far from the central body at t = \" , param % t else if (( param % rmin >= 0.0_DP ) . and . ( rh2 < rmin2 )) then pl % ldiscard ( i ) = . true . pl % lcollision ( i ) = . false . pl % status ( i ) = DISCARDED_RMIN write ( * , * ) \"Massive body \" , pl % id ( i ), \" too close to the central body at t = \" , param % t else if ( param % rmaxu >= 0.0_DP ) then rb2 = dot_product ( pl % xb (:, i ), pl % xb (:, i )) vb2 = dot_product ( pl % vb (:, i ), pl % vb (:, i )) energy = 0.5_DP * vb2 - system % Gmtot / sqrt ( rb2 ) if (( energy > 0.0_DP ) . and . ( rb2 > rmaxu2 )) then pl % ldiscard ( i ) = . true . pl % lcollision ( i ) = . false . pl % status ( i ) = DISCARDED_RMAXU write ( * , * ) \"Massive body \" , pl % id ( i ), \" is unbound and too far from barycenter at t = \" , param % t end if end if end if end do end associate return end subroutine symba_discard_cb_pl subroutine symba_discard_conserve_mtm ( pl , system , param , ipl , lescape_body ) !! author: David A. Minton !! !! Conserves system momentum when a body is lost from the system or collides with central body implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: pl class ( symba_nbody_system ), intent ( inout ) :: system class ( symba_parameters ), intent ( inout ) :: param integer ( I4B ), intent ( in ) :: ipl logical , intent ( in ) :: lescape_body ! Internals real ( DP ), dimension ( NDIM ) :: Lpl , Ltot , Lcb , xcom , vcom real ( DP ) :: pe , ke_orbit , ke_spin integer ( I4B ) :: i , oldstat select type ( cb => system % cb ) class is ( symba_cb ) ! Add the potential and kinetic energy of the lost body to the records pe = - cb % mass * pl % mass ( ipl ) / norm2 ( pl % xb (:, ipl ) - cb % xb (:)) ke_orbit = 0.5_DP * pl % mass ( ipl ) * dot_product ( pl % vb (:, ipl ), pl % vb (:, ipl )) if ( param % lrotation ) then ke_spin = 0.5_DP * pl % mass ( ipl ) * pl % radius ( ipl ) ** 2 * pl % Ip ( 3 , ipl ) * dot_product ( pl % rot (:, ipl ), pl % rot (:, ipl )) else ke_spin = 0.0_DP end if ! Add the pre-collision ke of the central body to the records ! Add planet mass to central body accumulator if ( lescape_body ) then system % Mescape = system % Mescape + pl % mass ( ipl ) do i = 1 , pl % nbody if ( i == ipl ) cycle pe = pe - pl % mass ( i ) * pl % mass ( ipl ) / norm2 ( pl % xb (:, ipl ) - pl % xb (:, i )) end do Ltot (:) = 0.0_DP do i = 1 , pl % nbody Lpl (:) = pL % mass ( i ) * pl % xb (:, i ) . cross . pl % vb (:, i ) Ltot (:) = Ltot (:) + Lpl (:) end do Ltot (:) = Ltot (:) + cb % mass * cb % xb (:) . cross . cb % vb (:) call pl % b2h ( cb ) oldstat = pl % status ( ipl ) pl % status ( ipl ) = INACTIVE call pl % h2b ( cb ) pl % status ( ipl ) = oldstat do i = 1 , pl % nbody if ( i == ipl ) cycle Lpl (:) = pl % mass ( i ) * pl % xb (:, i ) . cross . pl % vb (:, i ) Ltot (:) = Ltot (:) - Lpl (:) end do Ltot (:) = Ltot (:) - cb % mass * cb % xb (:) . cross . cb % vb (:) system % Lescape (:) = system % Lescape (:) + Ltot (:) if ( param % lrotation ) system % Lescape (:) = system % Lescape + pl % mass ( ipl ) * pl % radius ( ipl ) ** 2 * pl % Ip ( 3 , ipl ) * pl % rot (:, ipl ) else xcom (:) = ( pl % mass ( ipl ) * pl % xb (:, ipl ) + cb % mass * cb % xb (:)) / ( cb % mass + pl % mass ( ipl )) vcom (:) = ( pl % mass ( ipl ) * pl % vb (:, ipl ) + cb % mass * cb % vb (:)) / ( cb % mass + pl % mass ( ipl )) Lpl (:) = ( pl % xb (:, ipl ) - xcom (:)) . cross . pL % vb (:, ipl ) - vcom (:) if ( param % lrotation ) Lpl (:) = pl % mass ( ipl ) * ( Lpl (:) + pl % radius ( ipl ) ** 2 * pl % Ip ( 3 , ipl ) * pl % rot (:, ipl )) Lcb (:) = cb % mass * ( cb % xb (:) - xcom (:)) . cross . ( cb % vb (:) - vcom (:)) ke_orbit = ke_orbit + 0.5_DP * cb % mass * dot_product ( cb % vb (:), cb % vb (:)) if ( param % lrotation ) ke_spin = ke_spin + 0.5_DP * cb % mass * cb % radius ** 2 * cb % Ip ( 3 ) * dot_product ( cb % rot (:), cb % rot (:)) ! Update mass of central body to be consistent with its total mass cb % dM = cb % dM + pl % mass ( ipl ) cb % dR = cb % dR + 1.0_DP / 3.0_DP * ( pl % radius ( ipl ) / cb % radius ) ** 3 - 2.0_DP / 9.0_DP * ( pl % radius ( ipl ) / cb % radius ) ** 6 cb % mass = cb % M0 + cb % dM cb % Gmass = param % GU * cb % mass cb % radius = cb % R0 + cb % dR param % rmin = cb % radius ! Add planet angular momentum to central body accumulator cb % dL (:) = Lpl (:) + Lcb (:) + cb % dL (:) ! Update rotation of central body to by consistent with its angular momentum if ( param % lrotation ) then cb % rot (:) = ( cb % L0 (:) + cb % dL (:)) / ( cb % Ip ( 3 ) * cb % mass * cb % radius ** 2 ) ke_spin = ke_spin - 0.5_DP * cb % mass * cb % radius ** 2 * cb % Ip ( 3 ) * dot_product ( cb % rot (:), cb % rot (:)) end if cb % xb (:) = xcom (:) cb % vb (:) = vcom (:) ke_orbit = ke_orbit - 0.5_DP * cb % mass * dot_product ( cb % vb (:), cb % vb (:)) end if call pl % b2h ( cb ) ! We must do this for proper book-keeping, since we can no longer track this body's contribution to energy directly if ( lescape_body ) then system % Ecollisions = system % Ecollisions + ke_orbit + ke_spin + pe system % Euntracked = system % Euntracked - ( ke_orbit + ke_spin + pe ) else system % Ecollisions = system % Ecollisions + pe system % Euntracked = system % Euntracked - pe end if end select return end subroutine symba_discard_conserve_mtm subroutine symba_discard_nonplpl ( pl , system , param ) !! author: David A. Minton !! !! Check to see if planets should be discarded based on their positions or because they are unbound !s !! !! Adapted from David E. Kaufmann's Swifter routine: symba_discard_pl.f90 !! Adapted from Hal Levison's Swift routine discard_massive5.f implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: pl !! SyMBA test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! First check for collisions with the central body associate ( npl => pl % nbody , cb => system % cb ) if ( npl == 0 ) return if (( param % rmin >= 0.0_DP ) . or . ( param % rmax >= 0.0_DP ) . or . & ( param % rmaxu >= 0.0_DP ) . or . (( param % qmin >= 0.0_DP ) . and . ( param % qmin_coord == \"BARY\" ))) then call pl % h2b ( cb ) end if if (( param % rmin >= 0.0_DP ) . or . ( param % rmax >= 0.0_DP ) . or . ( param % rmaxu >= 0.0_DP )) then call symba_discard_cb_pl ( pl , system , param ) end if if ( param % qmin >= 0.0_DP . and . npl > 0 ) call symba_discard_peri_pl ( pl , system , param ) end associate return end subroutine symba_discard_nonplpl subroutine symba_discard_nonplpl_conservation ( pl , system , param ) !! author: David A. Minton !! !! If there are any bodies that are removed due to either colliding with the central body or escaping the systme, !! we need to track the conserved quantities with the system bookkeeping terms. implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: pl !! SyMBA test particle object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i , ndiscard , dstat logical :: lescape logical , dimension ( pl % nbody ) :: discard_l_pl integer ( I4B ), dimension (:), allocatable :: discard_index_list associate ( npl => pl % nbody ) discard_l_pl ( 1 : npl ) = pl % ldiscard ( 1 : npl ) . and . . not . pl % lcollision ( 1 : npl ) ! These are bodies that are discarded but not flagged as pl-pl collision ndiscard = count ( discard_l_pl (:)) allocate ( discard_index_list ( ndiscard )) discard_index_list (:) = pack ([( i , i = 1 , npl )], discard_l_pl ( 1 : npl )) do i = 1 , ndiscard dstat = pl % status ( discard_index_list ( i )) if (( dstat == DISCARDED_RMIN ) . or . ( dstat == DISCARDED_PERI )) then lescape = . false . else if (( dstat == DISCARDED_RMAX ) . or . ( dstat == DISCARDED_RMAXU )) then lescape = . true . else cycle end if ! Conserve all the quantities call symba_discard_conserve_mtm ( pl , system , param , discard_index_list ( i ), lescape ) end do end associate return end subroutine symba_discard_nonplpl_conservation subroutine symba_discard_peri_pl ( pl , system , param ) !! author: David A. Minton !! !! Check to see if a test particle should be discarded because its perihelion distance becomes too small !! !! Adapted from David E. Kaufmann's Swifter routine: symba_discard_peri_pl.f90 !! Adapted from Hal Levison's Swift routine discard_mass_peri.f implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: pl !! SyMBA massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals logical , save :: lfirst = . true . logical :: lfirst_orig integer ( I4B ) :: i lfirst_orig = pl % lfirst pl % lfirst = lfirst if ( lfirst ) then call pl % get_peri ( system , param ) lfirst = . false . else call pl % get_peri ( system , param ) do i = 1 , pl % nbody if ( pl % status ( i ) == ACTIVE ) then if (( pl % isperi ( i ) == 0 ) . and . ( pl % nplenc ( i ) == 0 )) then if (( pl % atp ( i ) >= param % qmin_alo ) . and . ( pl % atp ( i ) <= param % qmin_ahi ) . and . ( pl % peri ( i ) <= param % qmin )) then pl % ldiscard ( i ) = . true . pl % lcollision ( i ) = . false . pl % status ( i ) = DISCARDED_PERI write ( * , * ) \"Particle \" , pl % id ( i ), \" perihelion distance too small at t = \" , param % t end if end if end if end do end if pl % lfirst = lfirst_orig return end subroutine symba_discard_peri_pl module subroutine symba_discard_pl ( self , system , param ) !! author: David A. Minton !! !! Call the various flavors of discards for massive bodies in SyMBA runs, including discards due to colling with the central body, !! escaping the system, or colliding with each other. implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals real ( DP ) :: Eorbit_before , Eorbit_after select type ( system ) class is ( symba_nbody_system ) select type ( param ) class is ( symba_parameters ) associate ( pl => self , plplenc_list => system % plplenc_list ) call pl % h2b ( system % cb ) ! First deal with the non pl-pl collisions call symba_discard_nonplpl ( self , system , param ) ! Scrub the pl-pl encounter list of any encounters that did not lead to a collision call plplenc_list % scrub_non_collision ( system , param ) if (( plplenc_list % nenc > 0 ) . and . any ( pl % lcollision (:))) then write ( * , * ) \"Collision between massive bodies detected at time t = \" , param % t if ( param % lfragmentation ) then call plplenc_list % resolve_fragmentations ( system , param ) else call plplenc_list % resolve_mergers ( system , param ) end if end if if ( any ( pl % ldiscard (:))) then if ( param % lenergy ) then call system % get_energy_and_momentum ( param ) Eorbit_before = system % te end if call symba_discard_nonplpl_conservation ( self , system , param ) call pl % rearray ( system , param ) if ( param % lenergy ) then call system % get_energy_and_momentum ( param ) Eorbit_after = system % te system % Ecollisions = Eorbit_after - Eorbit_before end if end if end associate end select end select return end subroutine symba_discard_pl end submodule s_symba_discard","tags":"","loc":"sourcefile/symba_discard.f90.html"},{"title":"symba_step.f90 – swiftest","text":"This file depends on sourcefile~~symba_step.f90~~EfferentGraph sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_step.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_symba_step Source Code symba_step.f90 Source Code submodule ( symba_classes ) s_symba_step use swiftest contains module subroutine symba_step_system ( self , param , t , dt ) !! author: David A. Minton !! !! Step planets and active test particles ahead in democratic heliocentric coordinates, descending the recursive !!   branch if necessary to handle possible close encounters !! !! Adapted from David E. Kaufmann's Swifter routine: symba_step.f90 !! Adapted from Hal Levison's Swift routine symba5_step_pl.f implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize ! Internals logical :: lencounter call self % reset () select type ( pl => self % pl ) class is ( symba_pl ) select type ( tp => self % tp ) class is ( symba_tp ) lencounter = pl % encounter_check ( self , dt , 0 ) . or . tp % encounter_check ( self , dt , 0 ) if ( lencounter ) then tp % lfirst = pl % lfirst call self % interp ( param , t , dt ) pl % lfirst = . true . tp % lfirst = . true . else call helio_step_system ( self , param , t , dt ) end if end select end select return end subroutine symba_step_system module subroutine symba_step_interp_system ( self , param , t , dt ) !! author: David A. Minton !! !! Step planets and active test particles ahead in democratic heliocentric coordinates, calling the recursive !!         subroutine to descend to the appropriate level to handle close encounters !! !! Adapted from David E. Kaufmann's Swifter routine: symba_step_interp.f90 !! Adapted from Hal Levison's Swift routine symba5_step_interp.f implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize ! Internals real ( DP ) :: dth !! Half step size dth = 0.5_DP * dt associate ( system => self ) select type ( pl => system % pl ) class is ( symba_pl ) select type ( tp => system % tp ) class is ( symba_tp ) select type ( cb => system % cb ) class is ( symba_cb ) system % irec = - 1 call pl % vh2vb ( cb ) call pl % lindrift ( cb , dth , lbeg = . true .) call pl % kick ( system , param , t , dth , lbeg = . true .) call pl % drift ( system , param , dt ) call tp % vh2vb ( vbcb = - cb % ptbeg ) call tp % lindrift ( cb , dth , lbeg = . true .) call tp % kick ( system , param , t , dth , lbeg = . true .) call tp % drift ( system , param , dt ) call system % recursive_step ( param , t , 0 ) call pl % kick ( system , param , t , dth , lbeg = . false .) call pl % vb2vh ( cb ) call pl % lindrift ( cb , dth , lbeg = . false .) call tp % kick ( system , param , t , dth , lbeg = . false .) call tp % vb2vh ( vbcb = - cb % ptend ) call tp % lindrift ( cb , dth , lbeg = . false .) end select end select end select end associate return end subroutine symba_step_interp_system module subroutine symba_step_set_recur_levels_system ( self , ireci ) !! author: David A. Minton !! !! Resets pl, tp,and encounter structures at the start of a new step !! !! Adapted from David E. Kaufmann's Swifter routine: symba_step_recur.f90 !! Adapted from Hal Levison's Swift routine symba5_step_recur.f implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object integer ( I4B ), intent ( in ) :: ireci !! Input recursion level ! Internals integer ( I4B ) :: k , irecp associate ( system => self , plplenc_list => self % plplenc_list , pltpenc_list => self % pltpenc_list ) select type ( pl => self % pl ) class is ( symba_pl ) select type ( tp => self % tp ) class is ( symba_tp ) irecp = ireci + 1 if ( plplenc_list % nenc > 0 ) then do k = 1 , plplenc_list % nenc associate ( i => plplenc_list % index1 ( k ), j => plplenc_list % index2 ( k )) if ( pl % levelg ( i ) == irecp ) pl % levelg ( i ) = ireci if ( pl % levelg ( j ) == irecp ) pl % levelg ( j ) = ireci end associate end do where ( plplenc_list % level ( 1 : plplenc_list % nenc ) == irecp ) plplenc_list % level ( 1 : plplenc_list % nenc ) = ireci end if if ( pltpenc_list % nenc > 0 ) then do k = 1 , pltpenc_list % nenc associate ( i => pltpenc_list % index1 ( k ), j => pltpenc_list % index2 ( k )) if ( pl % levelg ( i ) == irecp ) pl % levelg ( i ) = ireci if ( tp % levelg ( j ) == irecp ) tp % levelg ( j ) = ireci end associate end do where ( pltpenc_list % level ( 1 : pltpenc_list % nenc ) == irecp ) pltpenc_list % level ( 1 : pltpenc_list % nenc ) = ireci end if system % irec = ireci end select end select end associate return end subroutine symba_step_set_recur_levels_system module recursive subroutine symba_step_recur_system ( self , param , t , ireci ) !! author: David A. Minton !! !! Step interacting planets and active test particles ahead in democratic heliocentric coordinates at the current !!         recursion level, if applicable, and descend to the next deeper level if necessarys !! !! Adapted from David E. Kaufmann's Swifter routine: symba_step_recur.f90 !! Adapted from Hal Levison's Swift routine symba5_step_recur.f implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), value :: t integer ( I4B ), value :: ireci !! input recursion level ! Internals integer ( I4B ) :: i , j , irecp , nloops real ( DP ) :: dtl , dth real ( DP ), dimension ( NDIM ) :: xr , vr logical :: lencounter associate ( system => self , plplenc_list => self % plplenc_list , pltpenc_list => self % pltpenc_list ) select type ( pl => self % pl ) class is ( symba_pl ) select type ( tp => self % tp ) class is ( symba_tp ) system % irec = ireci dtl = param % dt / ( NTENC ** ireci ) dth = 0.5_DP * dtl IF ( dtl / param % dt < VSMALL ) THEN write ( * , * ) \"SWIFTEST Warning:\" write ( * , * ) \"   In symba_step_recur_system, local time step is too small\" write ( * , * ) \"   Roundoff error will be important!\" call util_exit ( FAILURE ) END IF irecp = ireci + 1 if ( ireci == 0 ) then nloops = 1 else nloops = NTENC end if do j = 1 , nloops lencounter = plplenc_list % encounter_check ( system , dtl , irecp ) . or . pltpenc_list % encounter_check ( system , dtl , irecp ) call plplenc_list % kick ( system , dth , irecp , 1 ) call pltpenc_list % kick ( system , dth , irecp , 1 ) if ( ireci /= 0 ) then call plplenc_list % kick ( system , dth , irecp , - 1 ) call pltpenc_list % kick ( system , dth , irecp , - 1 ) end if call pl % drift ( system , param , dtl ) call tp % drift ( system , param , dtl ) if ( lencounter ) call system % recursive_step ( param , t + dth , irecp ) system % irec = ireci call plplenc_list % kick ( system , dth , irecp , 1 ) call pltpenc_list % kick ( system , dth , irecp , 1 ) if ( ireci /= 0 ) then call plplenc_list % kick ( system , dth , irecp , - 1 ) call pltpenc_list % kick ( system , dth , irecp , - 1 ) end if if ( param % lclose ) then call plplenc_list % collision_check ( system , param , t + dtl , dtl , ireci ) call pltpenc_list % collision_check ( system , param , t + dtl , dtl , ireci ) end if call self % set_recur_levels ( ireci ) end do end select end select end associate return end subroutine symba_step_recur_system module subroutine symba_step_reset_system ( self ) !! author: David A. Minton !! !! Resets pl, tp,and encounter structures at the start of a new step !! !! Adapted from David E. Kaufmann's Swifter routine: symba_step.f90 !! Adapted from Hal Levison's Swift routine symba5_step.f implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object ! Internals integer ( I4B ) :: i associate ( system => self , pltpenc_list => self % pltpenc_list , plplenc_list => self % plplenc_list , pl_adds => self % pl_adds , pl_discards => self % pl_discards ) select type ( pl => system % pl ) class is ( symba_pl ) select type ( tp => system % tp ) class is ( symba_tp ) if ( pl % nbody > 0 ) then pl % lcollision (:) = . false . pl % kin (:)% parent = [( i , i = 1 , pl % nbody )] pl % kin (:)% nchild = 0 do i = 1 , pl % nbody if ( allocated ( pl % kin ( i )% child )) deallocate ( pl % kin ( i )% child ) end do pl % nplenc (:) = 0 pl % ntpenc (:) = 0 pl % levelg (:) = 0 pl % levelm (:) = 0 pl % lencounter = . false . pl % lcollision = . false . plplenc_list % nenc = 0 end if if ( tp % nbody > 0 ) then tp % nplenc (:) = 0 tp % levelg (:) = 0 tp % levelm (:) = 0 pltpenc_list % nenc = 0 end if call pl_adds % resize ( 0 ) call pl_discards % resize ( 0 ) end select end select end associate return end subroutine symba_step_reset_system end submodule s_symba_step","tags":"","loc":"sourcefile/symba_step.f90.html"},{"title":"symba_drift.f90 – swiftest","text":"This file depends on sourcefile~~symba_drift.f90~~EfferentGraph sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_drift.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_symba_drift Source Code symba_drift.f90 Source Code submodule ( symba_classes ) s_symba_drift use swiftest contains module subroutine symba_drift_pl ( self , system , param , dt ) !! author: David A. Minton !! !! Wrapper function used to call the body drift routine from a symba_pl structure implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize if ( self % nbody == 0 ) return select type ( system ) class is ( symba_nbody_system ) self % lmask (:) = self % status (:) /= INACTIVE . and . self % levelg (:) == system % irec call helio_drift_body ( self , system , param , dt ) self % lmask (:) = self % status (:) /= INACTIVE end select return end subroutine symba_drift_pl module subroutine symba_drift_tp ( self , system , param , dt ) !! author: David A. Minton !! !! Wrapper function used to call the body drift routine from a symba_pl structure implicit none ! Arguments class ( symba_tp ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize if ( self % nbody == 0 ) return select type ( system ) class is ( symba_nbody_system ) self % lmask (:) = self % status (:) /= INACTIVE . and . self % levelg (:) == system % irec call helio_drift_body ( self , system , param , dt ) self % lmask (:) = self % status (:) /= INACTIVE end select return end subroutine symba_drift_tp end submodule s_symba_drift","tags":"","loc":"sourcefile/symba_drift.f90.html"},{"title":"swiftest_driver.f90 – swiftest","text":"This file depends on sourcefile~~swiftest_driver.f90~~EfferentGraph sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs swiftest_driver Source Code swiftest_driver.f90 Source Code program swiftest_driver !! author: David A. Minton !! !! Driver program for the Swiftest integrators. Unlike the earlier Swift and Swifter drivers, in Swiftest all integrators !!    are run from this single program. !! !! Adapted from Swifter by David E. Kaufmann's Swifter driver programs swifter_[bs,helio,ra15,rmvs,symba,tu4,whm].f90 !! Adapted from Hal Levison and Martin Duncan's Swift driver programs use swiftest implicit none class ( swiftest_nbody_system ), allocatable :: nbody_system !! Polymorphic object containing the nbody system to be integrated class ( swiftest_parameters ), allocatable :: param !! Run configuration parameters integer ( I4B ) :: integrator !! Integrator type code (see swiftest_globals for symbolic names) character ( len = :), allocatable :: param_file_name !! Name of the file containing user-defined parameters integer ( I4B ) :: ierr !! I/O error code integer ( I8B ) :: iloop !! Loop counter integer ( I8B ) :: idump !! Dump cadence counter integer ( I8B ) :: iout !! Output cadence counter integer ( I8B ) :: nloops !! Number of steps to take in the simulation integer ( I4B ) :: iu !! Unit number of binary file ierr = io_get_args ( integrator , param_file_name ) if ( ierr /= 0 ) then write ( * , * ) 'Error reading in arguments from the command line' call util_exit ( FAILURE ) end if !> Read in the user-defined parameters file and the initial conditions of the system select case ( integrator ) case ( symba ) allocate ( symba_parameters :: param ) case default allocate ( swiftest_parameters :: param ) end select param % integrator = integrator call setup_construct_system ( nbody_system , param ) call param % read_from_file ( param_file_name ) associate ( t => param % t , & t0 => param % t0 , & dt => param % dt , & tstop => param % tstop , & istep_out => param % istep_out , & istep_dump => param % istep_dump ) call nbody_system % initialize ( param ) t = t0 iloop = 0 iout = istep_out idump = istep_dump nloops = ceiling ( tstop / dt , kind = I8B ) if ( istep_out > 0 ) call nbody_system % write_frame ( iu , param ) call nbody_system % dump ( param ) !> Define the maximum number of threads nthreads = 1 ! In the *serial* case !$ nthreads = omp_get_max_threads() ! In the *parallel* case !$ write(*,'(a)')   ' OpenMP parameters:' !$ write(*,'(a)')   ' ------------------' !$ write(*,'(a,i3,/)') ' Number of threads  = ', nthreads write ( * , * ) \" *************** Main Loop *************** \" do iloop = 1 , nloops !> Step the system forward in time call nbody_system % step ( param , t , dt ) t = t0 + iloop * dt !> Evaluate any discards or collisional outcomes call nbody_system % discard ( param ) !> If the loop counter is at the output cadence value, append the data file with a single frame if ( istep_out > 0 ) then iout = iout - 1 if ( iout == 0 ) then call nbody_system % write_frame ( iu , param ) iout = istep_out end if end if !> If the loop counter is at the dump cadence value, dump the state of the system to a file in case it needs to be restarted if ( istep_dump > 0 ) then idump = idump - 1 if ( idump == 0 ) then call nbody_system % dump ( param ) idump = istep_dump end if end if end do end associate call util_exit ( SUCCESS ) stop end program swiftest_driver","tags":"","loc":"sourcefile/swiftest_driver.f90.html"},{"title":"rmvs_classes.f90 – swiftest","text":"This file depends on sourcefile~~rmvs_classes.f90~~EfferentGraph sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~rmvs_classes.f90~~AfferentGraph sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_step.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_util.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_kick.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_setup.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_discard.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90 orbel.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~util_resize.f90 util_resize.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_setup.f90->sourcefile~symba_classes.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~gr.f90 gr.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~util_coord.f90 util_coord.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_collision.f90->sourcefile~symba_classes.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~eucl.f90 eucl.f90 sourcefile~eucl.f90->sourcefile~swiftest.f90 sourcefile~obl.f90 obl.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~helio_coord.f90 helio_coord.f90 sourcefile~helio_coord.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~symba_classes.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~drift.f90 drift.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~util_set.f90 util_set.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~setup.f90 setup.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~fragmentation.f90 fragmentation.f90 sourcefile~fragmentation.f90->sourcefile~swiftest.f90 sourcefile~util_solve.f90 util_solve.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~util_spill.f90 util_spill.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_discard.f90->sourcefile~symba_classes.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_drift.f90->sourcefile~symba_classes.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~symba_fragmentation.f90 symba_fragmentation.f90 sourcefile~symba_fragmentation.f90->sourcefile~symba_classes.f90 sourcefile~symba_fragmentation.f90->sourcefile~swiftest.f90 sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_encounter_check.f90->sourcefile~symba_classes.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_io.f90->sourcefile~symba_classes.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~util_sort.f90 util_sort.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~util_fill.f90 util_fill.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~kick.f90 kick.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~symba_classes.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_util.f90->sourcefile~symba_classes.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~util_copy.f90 util_copy.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~util_append.f90 util_append.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules rmvs_classes Source Code rmvs_classes.f90 Source Code module rmvs_classes !! author: David A. Minton !! !! Definition of classes and methods specific to the Regularized Mixed Variable Symplectic (RMVS) integrator !! Partially adapted from David E. Kaufmann's Swifter module: module_rmvs.f90 use swiftest_globals use whm_classes , only : whm_cb , whm_pl , whm_tp , whm_nbody_system implicit none public integer ( I4B ), private , parameter :: NTENC = 10 integer ( I4B ), private , parameter :: NTPHENC = 3 integer ( I4B ), private , parameter :: NTPENC = NTENC * NTPHENC real ( DP ), private , parameter :: RHSCALE = 3.5_DP real ( DP ), private , parameter :: RHPSCALE = 1.0_DP real ( DP ), private , parameter :: FACQDT = 2.0_DP !******************************************************************************************************************************** !  rmvs_nbody_system class definitions and method interfaces !******************************************************************************************************************************** type , extends ( whm_nbody_system ) :: rmvs_nbody_system !> In the RMVS integrator, only test particles are discarded logical :: lplanetocentric = . false . !! Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations real ( DP ) :: rts !! fraction of Hill's sphere radius to use as radius of encounter region real ( DP ), dimension (:,:), allocatable :: vbeg !! Planet velocities at beginning ot step contains !> Replace the abstract procedures with concrete ones procedure :: initialize => rmvs_setup_initialize_system !! Performs RMVS-specific initilization steps, including generating the close encounter planetocentric structures procedure :: step => rmvs_step_system !! Advance the RMVS nbody system forward in time by one step end type rmvs_nbody_system type , private :: rmvs_interp real ( DP ), dimension (:, :), allocatable :: x !! interpolated heliocentric planet position for outer encounter real ( DP ), dimension (:, :), allocatable :: v !! interpolated heliocentric planet velocity for outer encounter real ( DP ), dimension (:, :), allocatable :: aobl !! Encountering planet's oblateness acceleration value real ( DP ), dimension (:, :), allocatable :: atide !! Encountering planet's tidal acceleration value end type rmvs_interp !******************************************************************************************************************************** ! rmvs_cb class definitions and method interfaces !******************************************************************************************************************************* !> RMVS central body particle class type , extends ( whm_cb ) :: rmvs_cb type ( rmvs_interp ), dimension (:), allocatable :: outer !! interpolated heliocentric central body position for outer encounters type ( rmvs_interp ), dimension (:), allocatable :: inner !! interpolated heliocentric central body position for inner encounters logical :: lplanetocentric = . false . !! Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations end type rmvs_cb !******************************************************************************************************************************** !  rmvs_tp class definitions and method interfaces !******************************************************************************************************************************* !! RMVS test particle class type , extends ( whm_tp ) :: rmvs_tp !! Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the !!    component list, such as rmvs_setup_tp and rmvs_util_spill_tp ! encounter steps) logical , dimension (:), allocatable :: lperi !! planetocentric pericenter passage flag (persistent for a full rmvs time step) over a full RMVS time step) integer ( I4B ), dimension (:), allocatable :: plperP !! index of planet associated with pericenter distance peri (persistent over a full RMVS time step) integer ( I4B ), dimension (:), allocatable :: plencP !! index of planet that test particle is encountering (not persistent for a full RMVS time step) ! The following are used to correctly set the oblateness values of the acceleration during an inner encounter with a planet type ( rmvs_cb ) :: cb_heliocentric !! Copy of original central body object passed to close encounter (used for oblateness acceleration during planetocentric encoountters) real ( DP ), dimension (:,:), allocatable :: xheliocentric !! original heliocentric position (used for oblateness calculation during close encounters) integer ( I4B ) :: index !!  inner substep number within current set integer ( I4B ) :: ipleP !!  index value of encountering planet logical :: lplanetocentric = . false . !! Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations contains procedure :: discard => rmvs_discard_tp !! Check to see if test particles should be discarded based on pericenter passage distances with respect to planets encountered procedure :: encounter_check => rmvs_encounter_check_tp !! Checks if any test particles are undergoing a close encounter with a massive body procedure :: accel => rmvs_kick_getacch_tp !! Calculates either the standard or modified version of the acceleration depending if the !!    if the test particle is undergoing a close encounter or not procedure :: setup => rmvs_setup_tp !! Constructor method - Allocates space for the input number of bodiess procedure :: append => rmvs_util_append_tp !! Appends elements from one structure to another procedure :: fill => rmvs_util_fill_tp !! \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure :: resize => rmvs_util_resize_tp !! Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure :: sort => rmvs_util_sort_tp !! Sorts body arrays by a sortable componen procedure :: rearrange => rmvs_util_sort_rearrange_tp !! Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure :: spill => rmvs_util_spill_tp !! \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) end type rmvs_tp !******************************************************************************************************************************** !                                    rmvs_pl class definitions and method interfaces !******************************************************************************************************************************* !> RMVS massive body particle class type , extends ( whm_pl ) :: rmvs_pl integer ( I4B ), dimension (:), allocatable :: nenc !! number of test particles encountering planet this full rmvs time step integer ( I4B ), dimension (:), allocatable :: tpenc1P !! index of first test particle encountering planet integer ( I4B ), dimension (:), allocatable :: plind !! Connects the planetocentric indices back to the heliocentric planet list type ( rmvs_interp ), dimension (:), allocatable :: outer !! interpolated heliocentric central body position for outer encounters type ( rmvs_interp ), dimension (:), allocatable :: inner !! interpolated heliocentric central body position for inner encounters class ( rmvs_nbody_system ), dimension (:), allocatable :: planetocentric !! Planetocentric version of the massive body objects (one for each massive body) logical :: lplanetocentric = . false . !! Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations contains procedure :: setup => rmvs_setup_pl !! Constructor method - Allocates space for the input number of bodiess procedure :: append => rmvs_util_append_pl !! Appends elements from one structure to another procedure :: fill => rmvs_util_fill_pl !! \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure :: resize => rmvs_util_resize_pl !! Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure :: sort => rmvs_util_sort_pl !! Sorts body arrays by a sortable componen procedure :: rearrange => rmvs_util_sort_rearrange_pl !! Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure :: spill => rmvs_util_spill_pl !! \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) end type rmvs_pl interface module elemental function rmvs_chk_ind ( r2 , v2 , vdotr , dt , r2crit ) result ( lflag ) implicit none real ( DP ), intent ( in ) :: r2 , v2 , vdotr , dt , r2crit logical :: lflag end function rmvs_chk_ind module subroutine rmvs_discard_tp ( self , system , param ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine rmvs_discard_tp module function rmvs_encounter_check_tp ( self , system , dt ) result ( lencounter ) implicit none class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object class ( rmvs_nbody_system ), intent ( inout ) :: system !! RMVS nbody system object real ( DP ), intent ( in ) :: dt !! step size logical :: lencounter !! Returns true if there is at least one close encounter end function rmvs_encounter_check_tp module subroutine rmvs_kick_getacch_tp ( self , system , param , t , lbeg ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest central body particle data structuree class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step end subroutine rmvs_kick_getacch_tp module subroutine rmvs_setup_pl ( self , n , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine rmvs_setup_pl module subroutine rmvs_setup_initialize_system ( self , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( rmvs_nbody_system ), intent ( inout ) :: self !! RMVS system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine rmvs_setup_initialize_system module subroutine rmvs_setup_tp ( self , n , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parametere end subroutine rmvs_setup_tp module subroutine rmvs_util_append_pl ( self , source , lsource_mask ) use swiftest_classes , only : swiftest_body implicit none class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine rmvs_util_append_pl module subroutine rmvs_util_append_tp ( self , source , lsource_mask ) use swiftest_classes , only : swiftest_body implicit none class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine rmvs_util_append_tp module subroutine rmvs_util_fill_pl ( self , inserts , lfill_list ) use swiftest_classes , only : swiftest_body implicit none class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object class ( swiftest_body ), intent ( in ) :: inserts !! Inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine rmvs_util_fill_pl module subroutine rmvs_util_fill_tp ( self , inserts , lfill_list ) use swiftest_classes , only : swiftest_body implicit none class ( rmvs_tp ), intent ( inout ) :: self !! RMVS massive body object class ( swiftest_body ), intent ( in ) :: inserts !!  Inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine rmvs_util_fill_tp module subroutine rmvs_util_resize_pl ( self , nnew ) implicit none class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object integer ( I4B ), intent ( in ) :: nnew !! New size neded end subroutine rmvs_util_resize_pl module subroutine rmvs_util_resize_tp ( self , nnew ) implicit none class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object integer ( I4B ), intent ( in ) :: nnew !! New size neded end subroutine rmvs_util_resize_tp module subroutine rmvs_util_sort_pl ( self , sortby , ascending ) implicit none class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order end subroutine rmvs_util_sort_pl module subroutine rmvs_util_sort_tp ( self , sortby , ascending ) implicit none class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order end subroutine rmvs_util_sort_tp module subroutine rmvs_util_sort_rearrange_pl ( self , ind ) implicit none class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) end subroutine rmvs_util_sort_rearrange_pl module subroutine rmvs_util_sort_rearrange_tp ( self , ind ) implicit none class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) end subroutine rmvs_util_sort_rearrange_tp module subroutine rmvs_util_spill_pl ( self , discards , lspill_list , ldestructive ) use swiftest_classes , only : swiftest_body implicit none class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine rmvs_util_spill_pl module subroutine rmvs_util_spill_tp ( self , discards , lspill_list , ldestructive ) use swiftest_classes , only : swiftest_body implicit none class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine rmvs_util_spill_tp module subroutine rmvs_step_system ( self , param , t , dt ) use swiftest_classes , only : swiftest_parameters implicit none class ( rmvs_nbody_system ), intent ( inout ) :: self !! RMVS nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize end subroutine rmvs_step_system end interface end module rmvs_classes","tags":"","loc":"sourcefile/rmvs_classes.f90.html"},{"title":"swiftest_globals.f90 – swiftest","text":"Files dependent on this one sourcefile~~swiftest_globals.f90~~AfferentGraph sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_gr.f90->sourcefile~whm_classes.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~operator_cross.f90->sourcefile~swiftest_operators.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_step.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_util.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~swiftest_classes.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90 orbel.f90 sourcefile~orbel.f90->sourcefile~swiftest_classes.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_step.f90->sourcefile~helio_classes.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_kick.f90->sourcefile~helio_classes.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~util_resize.f90 util_resize.f90 sourcefile~util_resize.f90->sourcefile~swiftest_classes.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~swiftest_classes.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_setup.f90->sourcefile~symba_classes.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_step.f90->sourcefile~whm_classes.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_setup.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~gr.f90 gr.f90 sourcefile~gr.f90->sourcefile~swiftest_classes.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~util_coord.f90 util_coord.f90 sourcefile~util_coord.f90->sourcefile~swiftest_classes.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~eucl.f90 eucl.f90 sourcefile~eucl.f90->sourcefile~swiftest_classes.f90 sourcefile~eucl.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~swiftest_classes.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~obl.f90 obl.f90 sourcefile~obl.f90->sourcefile~swiftest_classes.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_collision.f90->sourcefile~symba_classes.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~helio_coord.f90 helio_coord.f90 sourcefile~helio_coord.f90->sourcefile~helio_classes.f90 sourcefile~helio_coord.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~symba_classes.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_setup.f90->sourcefile~whm_classes.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest_classes.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~drift.f90 drift.f90 sourcefile~drift.f90->sourcefile~swiftest_classes.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_coord.f90->sourcefile~whm_classes.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~user_getacch.f90->sourcefile~swiftest_classes.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~util_set.f90 util_set.f90 sourcefile~util_set.f90->sourcefile~swiftest_classes.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~swiftest_classes.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_discard.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~setup.f90 setup.f90 sourcefile~setup.f90->sourcefile~swiftest_classes.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~fragmentation.f90 fragmentation.f90 sourcefile~fragmentation.f90->sourcefile~swiftest_classes.f90 sourcefile~fragmentation.f90->sourcefile~swiftest.f90 sourcefile~util_solve.f90 util_solve.f90 sourcefile~util_solve.f90->sourcefile~swiftest_classes.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~util_spill.f90 util_spill.f90 sourcefile~util_spill.f90->sourcefile~swiftest_classes.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_discard.f90->sourcefile~symba_classes.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_drift.f90->sourcefile~symba_classes.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~swiftest_classes.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~symba_fragmentation.f90 symba_fragmentation.f90 sourcefile~symba_fragmentation.f90->sourcefile~symba_classes.f90 sourcefile~symba_fragmentation.f90->sourcefile~swiftest.f90 sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_encounter_check.f90->sourcefile~symba_classes.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~helio_classes.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~util_rescale.f90->sourcefile~swiftest_classes.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~swiftest_classes.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_io.f90->sourcefile~symba_classes.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest_classes.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_kick.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest_classes.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~util_sort.f90 util_sort.f90 sourcefile~util_sort.f90->sourcefile~swiftest_classes.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~util_fill.f90 util_fill.f90 sourcefile~util_fill.f90->sourcefile~swiftest_classes.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~kick.f90 kick.f90 sourcefile~kick.f90->sourcefile~swiftest_classes.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~symba_classes.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_gr.f90->sourcefile~helio_classes.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_drift.f90->sourcefile~whm_classes.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_util.f90->sourcefile~symba_classes.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest_classes.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~util_copy.f90 util_copy.f90 sourcefile~util_copy.f90->sourcefile~swiftest_classes.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~operator_mag.f90 operator_mag.f90 sourcefile~operator_mag.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_util.f90->sourcefile~whm_classes.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_kick.f90->sourcefile~whm_classes.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~util_append.f90 util_append.f90 sourcefile~util_append.f90->sourcefile~swiftest_classes.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules swiftest_globals Source Code swiftest_globals.f90 Source Code module swiftest_globals !! author: David A. Minton !! graph: false !! !! Basic parameters, definitions, and global type definitions used throughout the Swiftest project !! Adapted from David E. Kaufmann's Swifter routine: swiftest_globals.f90 and module_swifter.f90 use , intrinsic :: iso_fortran_env ! Use the intrinsic kind definitions implicit none public integer , parameter :: I8B = int64 !! Symbolic name for kind types of 8-byte integers integer , parameter :: I4B = int32 !! Symbolic name for kind types of 4-byte integers integer , parameter :: I2B = int16 !! Symbolic name for kind types of 2-byte integers integer , parameter :: I1B = int8 !! Symbolic name for kind types of 1-byte integers integer , parameter :: SP = real32 !! Symbolic name for kind types of single-precision reals integer , parameter :: DP = real64 !! Symbolic name for kind types of double-precision reals integer , parameter :: QP = real128 !! Symbolic name for kind types of quad-precision reals real ( DP ), parameter :: PIBY2 = 1.570796326794896619231321691639751442099_DP !! Definition of /(\\pi / 2 real ( DP ), parameter :: PI = 3.141592653589793238462643383279502884197_DP !! Definition of /(\\pi real ( DP ), parameter :: PI3BY2 = 4.712388980384689857693965074919254326296_DP !! Definition of /(3 \\pi / 2 real ( DP ), parameter :: TWOPI = 6.283185307179586476925286766559005768394_DP !! Definition of 2 \\pi real ( DP ), parameter :: THIRD = 0.333333333333333333333333333333333333333_DP !! Definition of 1 / 3 real ( DP ), parameter :: DEGRAD = 18 0.0_DP / PI !! Definition of conversion factor from degrees to radians integer ( I4B ), parameter :: LOWERCASE_BEGIN = iachar ( 'a' ) !! ASCII character set parameter for lower to upper conversion - start of lowercase integer ( I4B ), parameter :: LOWERCASE_END = iachar ( 'z' ) !! ASCII character set parameter for lower to upper conversion - end of lowercase integer ( I4B ), parameter :: UPPERCASE_OFFSET = iachar ( 'A' ) - iachar ( 'a' ) !! ASCII character set parameter for lower to upper conversion - offset between upper and lower real ( SP ), parameter :: VERSION_NUMBER = 0.1_SP !! swiftest version !> Symbolic name for integrator types integer ( I4B ), parameter :: UNKNOWN_INTEGRATOR = 1 integer ( I4B ), parameter :: BS = 2 integer ( I4B ), parameter :: HELIO = 3 integer ( I4B ), parameter :: RA15 = 4 integer ( I4B ), parameter :: TU4 = 5 integer ( I4B ), parameter :: WHM = 6 integer ( I4B ), parameter :: RMVS = 7 integer ( I4B ), parameter :: SYMBA = 8 integer ( I4B ), parameter :: RINGMOONS = 9 integer ( I4B ), parameter :: STRMAX = 128 !! Maximum size of character strings character ( * ), parameter :: ASCII_TYPE = 'ASCII' !! Symbolic name for ASCII file type character ( * ), parameter :: REAL4_TYPE = 'REAL4' !! Symbolic name for binary file type REAL4 character ( * ), parameter :: REAL8_TYPE = 'REAL8' !! Symbolic name for binary file type REAL8 character ( * ), parameter :: SWIFTER_REAL4_TYPE = 'SWIFTER4' !! Symbolic name for binary file type for the old style Swifter REAL4 character ( * ), parameter :: SWIFTER_REAL8_TYPE = 'SWIFTER8' !! Symbolic name for binary file type for the old style Swifter REAL8 character ( * ), parameter :: EL = 'EL' !! Symbolic name for binary output file contents for orbital element type character ( * ), parameter :: XV = 'XV' !! Symbolic name for binary output file contents for cartesian position and velocity type ! OpenMP Parameters integer ( I4B ) :: nthreads = 1 !! Number of OpenMP threads integer ( I4B ), parameter :: NTHERSHOLD = 1000 !! Threshold value for OpenMP loop parallelization integer ( I4B ), parameter :: SUCCESS = 0 !! Symbolic name for function return/flag code for success integer ( I4B ), parameter :: FAILURE = - 1 !! Symbolic name for function return/flag code for failure integer ( I4B ), parameter :: USAGE = - 2 !! Symbolic name for function return/flag code for printing the usage message integer ( I4B ), parameter :: HELP = - 3 !! Symbolic name for function return/flag code for printing the usage message character ( * ), parameter :: SUCCESS_MSG = '(/, \"Normal termination of Swiftest (version \", f3.1, \")\")' character ( * ), parameter :: FAIL_MSG = '(/, \"Terminating Swiftest (version \", f3.1, \") due to error!!\")' character ( * ), parameter :: USAGE_MSG = '(\"Usage: swiftest [bs|helio|ra15|rmvs|symba|tu4|whm] <paramfile>\")' character ( * ), parameter :: HELP_MSG = USAGE_MSG integer ( I4B ), parameter :: ELLIPSE = - 1 !! Symbolic names for orbit types - ellipse integer ( I4B ), parameter :: PARABOLA = 0 !! Symbolic names for orbit types - parabola integer ( I4B ), parameter :: HYPERBOLA = 1 !! Symbolic names for orbit types - hyperbola !> Symbolic names for body/particle status codes: integer ( I4B ), parameter :: ACTIVE = 0 integer ( I4B ), parameter :: INACTIVE = 1 integer ( I4B ), parameter :: DISCARDED_RMAX = - 1 integer ( I4B ), parameter :: DISCARDED_RMIN = - 2 integer ( I4B ), parameter :: DISCARDED_RMAXU = - 3 integer ( I4B ), parameter :: DISCARDED_PERI = - 4 integer ( I4B ), parameter :: DISCARDED_PLR = - 5 integer ( I4B ), parameter :: DISCARDED_PLQ = - 6 integer ( I4B ), parameter :: DISCARDED_DRIFTERR = - 7 integer ( I4B ), parameter :: MERGED = - 8 integer ( I4B ), parameter :: DISRUPTION = - 9 integer ( I4B ), parameter :: SUPERCATASTROPHIC = - 10 integer ( I4B ), parameter :: GRAZE_AND_MERGE = - 11 integer ( I4B ), parameter :: HIT_AND_RUN = - 12 integer ( I4B ), parameter :: COLLISION = - 13 !>Symbolic names for collisional outcomes from collresolve_resolve: integer ( I4B ), parameter :: COLLRESOLVE_REGIME_MERGE = 1 integer ( I4B ), parameter :: COLLRESOLVE_REGIME_DISRUPTION = 2 integer ( I4B ), parameter :: COLLRESOLVE_REGIME_SUPERCATASTROPHIC = 3 integer ( I4B ), parameter :: COLLRESOLVE_REGIME_GRAZE_AND_MERGE = 4 integer ( I4B ), parameter :: COLLRESOLVE_REGIME_HIT_AND_RUN = 5 !> String labels for body/particle addition/subtraction in discard file character ( * ), parameter :: ADD = '+1' character ( * ), parameter :: SUB = '-1' !> Standard file names integer ( I4B ), parameter :: NDUMPFILES = 2 character ( * ), dimension ( 2 ), parameter :: DUMP_CB_FILE = [ 'dump_cb1.bin' , 'dump_cb2.bin' ] character ( * ), dimension ( 2 ), parameter :: DUMP_PL_FILE = [ 'dump_pl1.bin' , 'dump_pl2.bin' ] character ( * ), dimension ( 2 ), parameter :: DUMP_TP_FILE = [ 'dump_tp1.bin' , 'dump_tp2.bin' ] character ( * ), dimension ( 2 ), parameter :: DUMP_PARAM_FILE = [ 'dump_param1.dat' , 'dump_param2.dat' ] !> Default file names that can be changed by the user in the parameters file character ( * ), parameter :: ENC_OUTFILE = 'encounter.out' character ( * ), parameter :: DISCARD_FILE = 'discard.out' character ( * ), parameter :: ENERGY_FILE = 'energy.out' character ( * ), parameter :: CB_INFILE = 'cb.in' character ( * ), parameter :: PL_INFILE = 'pl.in' character ( * ), parameter :: TP_INFILE = 'tp.in' character ( * ), parameter :: BIN_OUTFILE = 'bin.dat' integer ( I4B ), parameter :: BINUNIT = 20 !! File unit number for the binary output file !> Miscellaneous constants: integer ( I4B ), parameter :: NDIM = 3 !! Number of dimensions in our reality integer ( I4B ), parameter :: NDIM2 = 2 * NDIM !! 2x the number of dimensions real ( DP ), parameter :: VSMALL = 2 * epsilon ( 1._DP ) !! Very small number used to prevent floating underflow real ( DP ), parameter :: GC = 6.6743E-11_DP !! Universal gravitational constant in SI units real ( DP ), parameter :: einsteinC = 29979245 8.0_DP !! Speed of light in SI units end module swiftest_globals","tags":"","loc":"sourcefile/swiftest_globals.f90.html"},{"title":"swiftest_operators.f90 – swiftest","text":"This file depends on sourcefile~~swiftest_operators.f90~~EfferentGraph sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~swiftest_operators.f90~~AfferentGraph sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~operator_cross.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~operator_mag.f90 operator_mag.f90 sourcefile~operator_mag.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90 orbel.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~util_resize.f90 util_resize.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~gr.f90 gr.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~util_coord.f90 util_coord.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~eucl.f90 eucl.f90 sourcefile~eucl.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~obl.f90 obl.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~helio_coord.f90 helio_coord.f90 sourcefile~helio_coord.f90->sourcefile~swiftest.f90 sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~drift.f90 drift.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~util_set.f90 util_set.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~setup.f90 setup.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~fragmentation.f90 fragmentation.f90 sourcefile~fragmentation.f90->sourcefile~swiftest.f90 sourcefile~util_solve.f90 util_solve.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~util_spill.f90 util_spill.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~symba_fragmentation.f90 symba_fragmentation.f90 sourcefile~symba_fragmentation.f90->sourcefile~swiftest.f90 sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~util_sort.f90 util_sort.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~util_fill.f90 util_fill.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~kick.f90 kick.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~util_copy.f90 util_copy.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~util_append.f90 util_append.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules swiftest_operators Source Code swiftest_operators.f90 Source Code module swiftest_operators !! author: David A. Minton !! !! Custom operators, including !!   A .cross. B = Cross product of A(1:3) and B(1:3) !! !! Each operator can also do element-wise computation on arrays of the form .mag. A(1:3, 1:n) use swiftest_globals implicit none public !******************************************************************************************************************************** ! Interfaces for .cross. operator !******************************************************************************************************************************** interface operator (. cross .) module pure function operator_cross_sp ( A , B ) result ( C ) implicit none real ( SP ), dimension (:), intent ( in ) :: A , B real ( SP ), dimension ( 3 ) :: C end function operator_cross_sp module pure function operator_cross_dp ( A , B ) result ( C ) implicit none real ( DP ), dimension (:), intent ( in ) :: A , B real ( DP ), dimension ( 3 ) :: C end function operator_cross_dp module pure function operator_cross_qp ( A , B ) result ( C ) implicit none real ( QP ), dimension (:), intent ( in ) :: A , B real ( QP ), dimension ( 3 ) :: C end function operator_cross_qp module pure function operator_cross_i1b ( A , B ) result ( C ) implicit none integer ( I1B ), dimension (:), intent ( in ) :: A , B integer ( I1B ), dimension ( 3 ) :: C end function operator_cross_i1b module pure function operator_cross_i2b ( A , B ) result ( C ) implicit none integer ( I2B ), dimension (:), intent ( in ) :: A , B integer ( I2B ), dimension ( 3 ) :: C end function operator_cross_i2b module pure function operator_cross_i4b ( A , B ) result ( C ) implicit none integer ( I4B ), dimension (:), intent ( in ) :: A , B integer ( I4B ), dimension ( 3 ) :: C end function operator_cross_i4b module pure function operator_cross_i8b ( A , B ) result ( C ) implicit none integer ( I8B ), dimension (:), intent ( in ) :: A , B integer ( I8B ), dimension ( 3 ) :: C end function operator_cross_i8b module pure function operator_cross_el_sp ( A , B ) result ( C ) implicit none real ( SP ), dimension (:,:), intent ( in ) :: A , B real ( SP ), dimension (:,:), allocatable :: C end function operator_cross_el_sp module pure function operator_cross_el_dp ( A , B ) result ( C ) implicit none real ( DP ), dimension (:,:), intent ( in ) :: A , B real ( DP ), dimension (:,:), allocatable :: C end function operator_cross_el_dp module pure function operator_cross_el_qp ( A , B ) result ( C ) implicit none real ( QP ), dimension (:,:), intent ( in ) :: A , B real ( QP ), dimension (:,:), allocatable :: C end function operator_cross_el_qp module pure function operator_cross_el_i1b ( A , B ) result ( C ) implicit none integer ( I1B ), dimension (:,:), intent ( in ) :: A , B integer ( I1B ), dimension (:,:), allocatable :: C end function operator_cross_el_i1b module pure function operator_cross_el_i2b ( A , B ) result ( C ) implicit none integer ( I2B ), dimension (:,:), intent ( in ) :: A , B integer ( I2B ), dimension (:,:), allocatable :: C end function operator_cross_el_i2b module pure function operator_cross_el_i4b ( A , B ) result ( C ) implicit none integer ( I4B ), dimension (:,:), intent ( in ) :: A , B integer ( I4B ), dimension (:,:), allocatable :: C end function operator_cross_el_i4b module pure function operator_cross_el_i8b ( A , B ) result ( C ) implicit none integer ( I8B ), dimension (:,:), intent ( in ) :: A , B integer ( I8B ), dimension (:,:), allocatable :: C end function operator_cross_el_i8b end interface !******************************************************************************************************************************** ! Interfaces for .mag. operator !******************************************************************************************************************************** interface operator (. mag .) module pure function operator_mag_sp ( A ) result ( B ) implicit none real ( SP ), dimension (:), intent ( in ) :: A real ( SP ) :: B end function operator_mag_sp module pure function operator_mag_dp ( A ) result ( B ) implicit none real ( DP ), dimension (:), intent ( in ) :: A real ( DP ) :: B end function operator_mag_dp module pure function operator_mag_qp ( A ) result ( B ) implicit none real ( QP ), dimension (:), intent ( in ) :: A real ( QP ) :: B end function operator_mag_qp module pure function operator_mag_el_sp ( A ) result ( B ) implicit none real ( SP ), dimension (:,:), intent ( in ) :: A real ( SP ), dimension (:), allocatable :: B end function operator_mag_el_sp module pure function operator_mag_el_dp ( A ) result ( B ) implicit none real ( DP ), dimension (:,:), intent ( in ) :: A real ( DP ), dimension (:), allocatable :: B end function operator_mag_el_dp module pure function operator_mag_el_qp ( A ) result ( B ) implicit none real ( QP ), dimension (:,:), intent ( in ) :: A real ( QP ), dimension (:), allocatable :: B end function operator_mag_el_qp end interface end module swiftest_operators","tags":"","loc":"sourcefile/swiftest_operators.f90.html"},{"title":"helio_classes.f90 – swiftest","text":"This file depends on sourcefile~~helio_classes.f90~~EfferentGraph sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~helio_classes.f90~~AfferentGraph sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~helio_coord.f90 helio_coord.f90 sourcefile~helio_coord.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_coord.f90->sourcefile~swiftest.f90 sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_gr.f90->sourcefile~helio_classes.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~helio_classes.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_step.f90->sourcefile~helio_classes.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_kick.f90->sourcefile~helio_classes.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90 orbel.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~util_resize.f90 util_resize.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_setup.f90->sourcefile~symba_classes.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~gr.f90 gr.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~util_coord.f90 util_coord.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_collision.f90->sourcefile~symba_classes.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~eucl.f90 eucl.f90 sourcefile~eucl.f90->sourcefile~swiftest.f90 sourcefile~obl.f90 obl.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~symba_classes.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~drift.f90 drift.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~util_set.f90 util_set.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~setup.f90 setup.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~fragmentation.f90 fragmentation.f90 sourcefile~fragmentation.f90->sourcefile~swiftest.f90 sourcefile~util_solve.f90 util_solve.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~util_spill.f90 util_spill.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_discard.f90->sourcefile~symba_classes.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_drift.f90->sourcefile~symba_classes.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~symba_fragmentation.f90 symba_fragmentation.f90 sourcefile~symba_fragmentation.f90->sourcefile~symba_classes.f90 sourcefile~symba_fragmentation.f90->sourcefile~swiftest.f90 sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_encounter_check.f90->sourcefile~symba_classes.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_io.f90->sourcefile~symba_classes.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~util_sort.f90 util_sort.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~util_fill.f90 util_fill.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~kick.f90 kick.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~symba_classes.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_util.f90->sourcefile~symba_classes.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~util_copy.f90 util_copy.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~util_append.f90 util_append.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules helio_classes Source Code helio_classes.f90 Source Code module helio_classes !! author: The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Definition of classes and methods specific to the Democratic Heliocentric Method !! Adapted from David E. Kaufmann's Swifter routine: helio.f90 use swiftest_globals use swiftest_classes , only : swiftest_cb , swiftest_pl , swiftest_tp , swiftest_nbody_system use whm_classes , only : whm_nbody_system implicit none public !******************************************************************************************************************************** !  helio_nbody_system class definitions and method interfaces !******************************************************************************************************************************** type , extends ( whm_nbody_system ) :: helio_nbody_system contains procedure :: step => helio_step_system !! Advance the Helio nbody system forward in time by one step end type helio_nbody_system !******************************************************************************************************************************** ! helio_cb class definitions and method interfaces !******************************************************************************************************************************* !> Helio central body particle class type , extends ( swiftest_cb ) :: helio_cb real ( DP ), dimension ( NDIM ) :: ptbeg !! negative barycentric velocity of the central body at the beginning of time step real ( DP ), dimension ( NDIM ) :: ptend !! negative barycentric velocity of the central body at the end of time step contains end type helio_cb !******************************************************************************************************************************** !                                    helio_pl class definitions and method interfaces !******************************************************************************************************************************* !! Helio massive body particle class type , extends ( swiftest_pl ) :: helio_pl contains procedure :: vh2vb => helio_coord_vh2vb_pl !! Convert massive bodies from heliocentric to barycentric coordinates (velocity only) procedure :: vb2vh => helio_coord_vb2vh_pl !! Convert massive bodies from barycentric to heliocentric coordinates (velocity only) procedure :: drift => helio_drift_pl !! Method for Danby drift in Democratic Heliocentric coordinates procedure :: lindrift => helio_drift_linear_pl !! Method for linear drift of massive bodies due to barycentric momentum of Sun procedure :: accel_gr => helio_gr_kick_getacch_pl !! Acceleration term arising from the post-Newtonian correction procedure :: gr_pos_kick => helio_gr_p4_pl !! Position kick due to p**4 term in the post-Newtonian correction procedure :: accel => helio_kick_getacch_pl !! Compute heliocentric accelerations of massive bodies procedure :: kick => helio_kick_vb_pl !! Kicks the barycentric velocities procedure :: step => helio_step_pl !! Steps the body forward one stepsize end type helio_pl !******************************************************************************************************************************** !                                    helio_tp class definitions and method interfaces !******************************************************************************************************************************* !! Helio test particle class type , extends ( swiftest_tp ) :: helio_tp contains procedure :: vh2vb => helio_coord_vh2vb_tp !! Convert test particles from heliocentric to barycentric coordinates (velocity only) procedure :: vb2vh => helio_coord_vb2vh_tp !! Convert test particles from barycentric to heliocentric coordinates (velocity only) procedure :: lindrift => helio_drift_linear_tp !! Method for linear drift of massive bodies due to barycentric momentum of Sun procedure :: drift => helio_drift_tp !! Method for Danby drift in Democratic Heliocentric coordinates procedure :: accel_gr => helio_gr_kick_getacch_tp !! Acceleration term arising from the post-Newtonian correction procedure :: gr_pos_kick => helio_gr_p4_tp !! Position kick due to p**4 term in the post-Newtonian correction procedure :: accel => helio_kick_getacch_tp !! Compute heliocentric accelerations of massive bodies procedure :: kick => helio_kick_vb_tp !! Kicks the barycentric velocities procedure :: step => helio_step_tp !! Steps the body forward one stepsize end type helio_tp interface module subroutine helio_coord_vb2vh_pl ( self , cb ) use swiftest_classes , only : swiftest_cb implicit none class ( helio_pl ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine helio_coord_vb2vh_pl module subroutine helio_coord_vb2vh_tp ( self , vbcb ) implicit none class ( helio_tp ), intent ( inout ) :: self !! Helio massive body object real ( DP ), dimension (:), intent ( in ) :: vbcb !! Barycentric velocity of the central body end subroutine helio_coord_vb2vh_tp module subroutine helio_coord_vh2vb_pl ( self , cb ) use swiftest_classes , only : swiftest_cb implicit none class ( helio_pl ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine helio_coord_vh2vb_pl module subroutine helio_coord_vh2vb_tp ( self , vbcb ) implicit none class ( helio_tp ), intent ( inout ) :: self !! Helio massive body object real ( DP ), dimension (:), intent ( in ) :: vbcb !! Barycentric velocity of the central body end subroutine helio_coord_vh2vb_tp module subroutine helio_drift_body ( self , system , param , dt ) use swiftest_classes , only : swiftest_body , swiftest_nbody_system , swiftest_parameters implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize end subroutine helio_drift_body module subroutine helio_drift_pl ( self , system , param , dt ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( helio_pl ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize end subroutine helio_drift_pl module subroutine helio_drift_tp ( self , system , param , dt ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( helio_tp ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize end subroutine helio_drift_tp module subroutine helio_drift_linear_pl ( self , cb , dt , lbeg ) implicit none class ( helio_pl ), intent ( inout ) :: self !! Helio massive body object class ( helio_cb ), intent ( inout ) :: cb !! Helio central body real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Argument that determines whether or not this is the beginning or end of the step end subroutine helio_drift_linear_pl module subroutine helio_drift_linear_tp ( self , cb , dt , lbeg ) implicit none class ( helio_tp ), intent ( inout ) :: self !! Helio test particle object class ( helio_cb ), intent ( in ) :: cb !! Helio central body real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Argument that determines whether or not this is the beginning or end of the step end subroutine helio_drift_linear_tp module subroutine helio_gr_kick_getacch_pl ( self , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( helio_pl ), intent ( inout ) :: self !! Helio massive body particle data structure class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine helio_gr_kick_getacch_pl module subroutine helio_gr_kick_getacch_tp ( self , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( helio_tp ), intent ( inout ) :: self !! Helio massive body particle data structure class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine helio_gr_kick_getacch_tp module pure subroutine helio_gr_p4_pl ( self , param , dt ) use swiftest_classes , only : swiftest_parameters implicit none class ( helio_pl ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Step size end subroutine helio_gr_p4_pl module pure subroutine helio_gr_p4_tp ( self , param , dt ) use swiftest_classes , only : swiftest_parameters implicit none class ( helio_tp ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Step size end subroutine helio_gr_p4_tp module subroutine helio_kick_getacch_pl ( self , system , param , t , lbeg ) use swiftest_classes , only : swiftest_parameters , swiftest_nbody_system implicit none class ( helio_pl ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step end subroutine helio_kick_getacch_pl module subroutine helio_kick_getacch_tp ( self , system , param , t , lbeg ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( helio_tp ), intent ( inout ) :: self !! Helio test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step end subroutine helio_kick_getacch_tp module subroutine helio_kick_vb_pl ( self , system , param , t , dt , lbeg ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( helio_pl ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Logical flag indicating whether this is the beginning of the half step or not. end subroutine helio_kick_vb_pl module subroutine helio_kick_vb_tp ( self , system , param , t , dt , lbeg ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( helio_tp ), intent ( inout ) :: self !! Helio test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Logical flag indicating whether this is the beginning of the half step or not. end subroutine helio_kick_vb_tp module subroutine helio_step_pl ( self , system , param , t , dt ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( helio_pl ), intent ( inout ) :: self !! Helio massive body particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nboody system class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Stepsize end subroutine helio_step_pl module subroutine helio_step_system ( self , param , t , dt ) use swiftest_classes , only : swiftest_parameters implicit none class ( helio_nbody_system ), intent ( inout ) :: self !! Helio nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize end subroutine helio_step_system module subroutine helio_step_tp ( self , system , param , t , dt ) use swiftest_classes , only : swiftest_cb , swiftest_parameters , swiftest_nbody_system implicit none class ( helio_tp ), intent ( inout ) :: self !! Helio test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Stepsizee end subroutine helio_step_tp end interface end module helio_classes","tags":"","loc":"sourcefile/helio_classes.f90.html"},{"title":"whm_classes.f90 – swiftest","text":"This file depends on sourcefile~~whm_classes.f90~~EfferentGraph sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~whm_classes.f90~~AfferentGraph sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_gr.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_setup.f90->sourcefile~whm_classes.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_drift.f90->sourcefile~whm_classes.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_coord.f90->sourcefile~whm_classes.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_util.f90->sourcefile~whm_classes.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_step.f90->sourcefile~whm_classes.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_kick.f90->sourcefile~whm_classes.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_step.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_util.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90 orbel.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_step.f90->sourcefile~helio_classes.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_kick.f90->sourcefile~helio_classes.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~util_resize.f90 util_resize.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90->sourcefile~symba_classes.f90 sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_setup.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~gr.f90 gr.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~util_coord.f90 util_coord.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~eucl.f90 eucl.f90 sourcefile~eucl.f90->sourcefile~swiftest.f90 sourcefile~obl.f90 obl.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~helio_coord.f90 helio_coord.f90 sourcefile~helio_coord.f90->sourcefile~helio_classes.f90 sourcefile~helio_coord.f90->sourcefile~swiftest.f90 sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~symba_collision.f90->sourcefile~symba_classes.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90->sourcefile~symba_classes.f90 sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~drift.f90 drift.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~util_set.f90 util_set.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_discard.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~setup.f90 setup.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~fragmentation.f90 fragmentation.f90 sourcefile~fragmentation.f90->sourcefile~swiftest.f90 sourcefile~util_solve.f90 util_solve.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~util_spill.f90 util_spill.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~symba_discard.f90->sourcefile~symba_classes.f90 sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~symba_drift.f90->sourcefile~symba_classes.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~helio_classes.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~symba_fragmentation.f90 symba_fragmentation.f90 sourcefile~symba_fragmentation.f90->sourcefile~swiftest.f90 sourcefile~symba_fragmentation.f90->sourcefile~symba_classes.f90 sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~symba_encounter_check.f90->sourcefile~symba_classes.f90 sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~symba_io.f90->sourcefile~symba_classes.f90 sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_kick.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~util_sort.f90 util_sort.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~util_fill.f90 util_fill.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~kick.f90 kick.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_gr.f90->sourcefile~helio_classes.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90->sourcefile~symba_classes.f90 sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~symba_util.f90->sourcefile~symba_classes.f90 sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~util_copy.f90 util_copy.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~util_append.f90 util_append.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules whm_classes Source Code whm_classes.f90 Source Code module whm_classes !! author: David A. Minton !! !! Definition of classes and methods specific to the Democratic Heliocentric Method !! Partially adapted from David E. Kaufmann's Swifter module: module_whm.f90 use swiftest_globals use swiftest_classes , only : swiftest_cb , swiftest_pl , swiftest_tp , swiftest_nbody_system implicit none public !******************************************************************************************************************************** ! whm_cb class definitions and method interfaces !******************************************************************************************************************************* !> Swiftest central body particle class type , extends ( swiftest_cb ) :: whm_cb contains end type whm_cb !******************************************************************************************************************************** !                                    whm_pl class definitions and method interfaces !******************************************************************************************************************************* !> WHM massive body particle class type , extends ( swiftest_pl ) :: whm_pl real ( DP ), dimension (:), allocatable :: eta !! Jacobi mass real ( DP ), dimension (:,:), allocatable :: xj !! Jacobi position real ( DP ), dimension (:,:), allocatable :: vj !! Jacobi velocity real ( DP ), dimension (:), allocatable :: muj !! Jacobi mu: GMcb * eta(i) / eta(i - 1) real ( DP ), dimension (:), allocatable :: ir3j !! Third term of heliocentric acceleration !! Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the !!    component list, such as whm_setup_pl and whm_util_spill_pl contains procedure :: h2j => whm_coord_h2j_pl !! Convert position and velcoity vectors from heliocentric to Jacobi coordinates procedure :: j2h => whm_coord_j2h_pl !! Convert position and velcoity vectors from Jacobi to helliocentric coordinates procedure :: vh2vj => whm_coord_vh2vj_pl !! Convert velocity vectors from heliocentric to Jacobi coordinates procedure :: drift => whm_drift_pl !! Loop through massive bodies and call Danby drift routine to jacobi coordinates procedure :: accel_gr => whm_gr_kick_getacch_pl !! Acceleration term arising from the post-Newtonian correction procedure :: gr_pos_kick => whm_gr_p4_pl !! Position kick due to p**4 term in the post-Newtonian correction procedure :: accel => whm_kick_getacch_pl !! Compute heliocentric accelerations of massive bodies procedure :: kick => whm_kick_vh_pl !! Kick heliocentric velocities of massive bodies procedure :: append => whm_util_append_pl !! Appends elements from one structure to another procedure :: fill => whm_util_fill_pl !! \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure :: resize => whm_util_resize_pl !! Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure :: set_ir3 => whm_util_set_ir3j !! Sets both the heliocentric and jacobi inverse radius terms (1/rj**3 and 1/rh**3) procedure :: set_mu => whm_util_set_mu_eta_pl !! Sets the Jacobi mass value for all massive bodies. procedure :: sort => whm_util_sort_pl !! Sort a WHM massive body object in-place. procedure :: rearrange => whm_util_sort_rearrange_pl !! Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure :: spill => whm_util_spill_pl !!\"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure :: setup => whm_setup_pl !! Constructor method - Allocates space for the input number of bodiess procedure :: step => whm_step_pl !! Steps the body forward one stepsize end type whm_pl !******************************************************************************************************************************** !  whm_tp class definitions and method interfaces !******************************************************************************************************************************* !! WHM test particle class type , extends ( swiftest_tp ) :: whm_tp !! Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the !!    component list, such as whm_util_spill_tp contains procedure :: accel_gr => whm_gr_kick_getacch_tp !! Acceleration term arising from the post-Newtonian correction procedure :: gr_pos_kick => whm_gr_p4_tp !! Position kick due to p**4 term in the post-Newtonian correction procedure :: accel => whm_kick_getacch_tp !! Compute heliocentric accelerations of test particles procedure :: kick => whm_kick_vh_tp !! Kick heliocentric velocities of test particles procedure :: step => whm_step_tp !! Steps the particle forward one stepsize end type whm_tp !******************************************************************************************************************************** !  whm_nbody_system class definitions and method interfaces !******************************************************************************************************************************** !> An abstract class for the WHM integrator nbody system type , extends ( swiftest_nbody_system ) :: whm_nbody_system contains !> Replace the abstract procedures with concrete ones procedure :: initialize => whm_setup_initialize_system !! Performs WHM-specific initilization steps, like calculating the Jacobi masses procedure :: step => whm_step_system !! Advance the WHM nbody system forward in time by one step end type whm_nbody_system interface module subroutine whm_coord_h2j_pl ( self , cb ) use swiftest_classes , only : swiftest_cb implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body particle data structuree end subroutine whm_coord_h2j_pl module subroutine whm_coord_j2h_pl ( self , cb ) use swiftest_classes , only : swiftest_cb implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body particle data structuree end subroutine whm_coord_j2h_pl module subroutine whm_coord_vh2vj_pl ( self , cb ) use swiftest_classes , only : swiftest_cb implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body particle data structuree end subroutine whm_coord_vh2vj_pl module subroutine whm_drift_pl ( self , system , param , dt ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! WHM nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize end subroutine whm_drift_pl !> Get heliocentric accelration of massive bodies module subroutine whm_kick_getacch_pl ( self , system , param , t , lbeg ) use swiftest_classes , only : swiftest_cb , swiftest_parameters implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! WHM nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step end subroutine whm_kick_getacch_pl !> Get heliocentric accelration of the test particle module subroutine whm_kick_getacch_tp ( self , system , param , t , lbeg ) use swiftest_classes , only : swiftest_cb , swiftest_parameters implicit none class ( whm_tp ), intent ( inout ) :: self !! WHM test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! WHM nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step end subroutine whm_kick_getacch_tp module subroutine whm_kick_vh_pl ( self , system , param , t , dt , lbeg ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Logical flag indicating whether this is the beginning of the half step or not. end subroutine whm_kick_vh_pl module subroutine whm_kick_vh_tp ( self , system , param , t , dt , lbeg ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( whm_tp ), intent ( inout ) :: self !! WHM test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Logical flag indicating whether this is the beginning of the half step or not. end subroutine whm_kick_vh_tp module subroutine whm_gr_kick_getacch_pl ( self , param ) use swiftest_classes , only : swiftest_cb , swiftest_parameters implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine whm_gr_kick_getacch_pl module subroutine whm_gr_kick_getacch_tp ( self , param ) use swiftest_classes , only : swiftest_cb , swiftest_parameters implicit none class ( whm_tp ), intent ( inout ) :: self !! WHM test particle data structure class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine whm_gr_kick_getacch_tp module pure subroutine whm_gr_p4_pl ( self , param , dt ) use swiftest_classes , only : swiftest_parameters implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Step size end subroutine whm_gr_p4_pl module pure subroutine whm_gr_p4_tp ( self , param , dt ) use swiftest_classes , only : swiftest_parameters implicit none class ( whm_tp ), intent ( inout ) :: self !! WHM test particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Step size end subroutine whm_gr_p4_tp !> Reads WHM massive body object in from file module subroutine whm_setup_pl ( self , n , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body objectobject integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine whm_setup_pl module subroutine whm_setup_initialize_system ( self , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( whm_nbody_system ), intent ( inout ) :: self !! WHM nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine whm_setup_initialize_system module subroutine whm_step_pl ( self , system , param , t , dt ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize end subroutine whm_step_pl module subroutine whm_step_system ( self , param , t , dt ) use swiftest_classes , only : swiftest_parameters implicit none class ( whm_nbody_system ), intent ( inout ) :: self !! WHM system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize end subroutine whm_step_system module subroutine whm_step_tp ( self , system , param , t , dt ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( whm_tp ), intent ( inout ) :: self !! WHM test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Stepsize end subroutine whm_step_tp module subroutine whm_util_append_pl ( self , source , lsource_mask ) use swiftest_classes , only : swiftest_body implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine whm_util_append_pl module subroutine whm_util_spill_pl ( self , discards , lspill_list , ldestructive ) use swiftest_classes , only : swiftest_body implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine whm_util_spill_pl module subroutine whm_util_fill_pl ( self , inserts , lfill_list ) use swiftest_classes , only : swiftest_body implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_body ), intent ( in ) :: inserts !! inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine whm_util_fill_pl module subroutine whm_util_resize_pl ( self , nnew ) implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object integer ( I4B ), intent ( in ) :: nnew !! New size neded end subroutine whm_util_resize_pl module subroutine whm_util_set_ir3j ( self ) implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object end subroutine whm_util_set_ir3j module subroutine whm_util_set_mu_eta_pl ( self , cb ) use swiftest_classes , only : swiftest_cb implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine whm_util_set_mu_eta_pl module subroutine whm_util_sort_pl ( self , sortby , ascending ) implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order end subroutine whm_util_sort_pl module subroutine whm_util_sort_rearrange_pl ( self , ind ) implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) end subroutine whm_util_sort_rearrange_pl end interface end module whm_classes","tags":"","loc":"sourcefile/whm_classes.f90.html"},{"title":"symba_classes.f90 – swiftest","text":"This file depends on sourcefile~~symba_classes.f90~~EfferentGraph sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~symba_classes.f90~~AfferentGraph sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_discard.f90->sourcefile~symba_classes.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~symba_fragmentation.f90 symba_fragmentation.f90 sourcefile~symba_fragmentation.f90->sourcefile~symba_classes.f90 sourcefile~symba_fragmentation.f90->sourcefile~swiftest.f90 sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_encounter_check.f90->sourcefile~symba_classes.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~symba_classes.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_drift.f90->sourcefile~symba_classes.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_io.f90->sourcefile~symba_classes.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_util.f90->sourcefile~symba_classes.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_setup.f90->sourcefile~symba_classes.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_collision.f90->sourcefile~symba_classes.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90 orbel.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~util_resize.f90 util_resize.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~gr.f90 gr.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~util_coord.f90 util_coord.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~eucl.f90 eucl.f90 sourcefile~eucl.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~obl.f90 obl.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~helio_coord.f90 helio_coord.f90 sourcefile~helio_coord.f90->sourcefile~swiftest.f90 sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~drift.f90 drift.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~util_set.f90 util_set.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~setup.f90 setup.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~fragmentation.f90 fragmentation.f90 sourcefile~fragmentation.f90->sourcefile~swiftest.f90 sourcefile~util_solve.f90 util_solve.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~util_spill.f90 util_spill.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~util_sort.f90 util_sort.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~util_fill.f90 util_fill.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~kick.f90 kick.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~util_copy.f90 util_copy.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~util_append.f90 util_append.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules symba_classes Source Code symba_classes.f90 Source Code module symba_classes !! author: The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Definition of classes and methods specific to the Democratic SyMBAcentric Method !! Adapted from David E. Kaufmann's Swifter routine: helio.f90 use swiftest_globals use swiftest_classes , only : swiftest_parameters , swiftest_base , swiftest_encounter use helio_classes , only : helio_cb , helio_pl , helio_tp , helio_nbody_system use rmvs_classes , only : rmvs_chk_ind implicit none public integer ( I4B ), private , parameter :: NENMAX = 32767 integer ( I4B ), private , parameter :: NTENC = 3 real ( DP ), private , parameter :: RHSCALE = 6.5_DP real ( DP ), private , parameter :: RSHELL = 0.48075_DP character ( * ), parameter :: PARTICLE_OUTFILE = 'particle.dat' integer ( I4B ), parameter :: PARTICLEUNIT = 44 !! File unit number for the binary particle info output file type , extends ( swiftest_parameters ) :: symba_parameters character ( STRMAX ) :: particle_out = PARTICLE_OUTFILE !! Name of output particle information file real ( DP ) :: GMTINY = - 1.0_DP !! Smallest mass that is fully gravitating integer ( I4B ), dimension (:), allocatable :: seed !! Random seeds logical :: lfragmentation = . false . !! Do fragmentation modeling instead of simple merger. contains procedure :: reader => symba_io_param_reader procedure :: writer => symba_io_param_writer end type symba_parameters !******************************************************************************************************************************** !                                    symba_particle_info class definitions and method interfaces !******************************************************************************************************************************* !> Class definition for the particle origin information object. This object is used to track time, location, and collisional regime !> of fragments produced in collisional events. type :: symba_particle_info sequence character ( len = 32 ) :: origin_type !! String containing a description of the origin of the particle (e.g. Initial Conditions, Supercatastrophic, Disruption, etc.) real ( DP ) :: origin_time !! The time of the particle's formation real ( DP ), dimension ( NDIM ) :: origin_xh !! The heliocentric distance vector at the time of the particle's formation real ( DP ), dimension ( NDIM ) :: origin_vh !! The heliocentric velocity vector at the time of the particle's formation end type symba_particle_info !******************************************************************************************************************************** !                                    symba_kinship class definitions and method interfaces !******************************************************************************************************************************* !> Class definition for the kinship relationships used in bookkeeping multiple collisions bodies in a single time step. type symba_kinship integer ( I4B ) :: parent !! Index of parent particle integer ( I4B ) :: nchild !! number of children in merger list integer ( I4B ), dimension (:), allocatable :: child !! Index of children particles end type symba_kinship !******************************************************************************************************************************** ! symba_cb class definitions and method interfaces !******************************************************************************************************************************* !> SyMBA central body particle class type , extends ( helio_cb ) :: symba_cb real ( DP ) :: M0 = 0.0_DP !! Initial mass of the central body real ( DP ) :: dM = 0.0_DP !! Change in mass of the central body real ( DP ) :: R0 = 0.0_DP !! Initial radius of the central body real ( DP ) :: dR = 0.0_DP !! Change in the radius of the central body type ( symba_particle_info ) :: info contains end type symba_cb !******************************************************************************************************************************** !                                    symba_pl class definitions and method interfaces !******************************************************************************************************************************* !> SyMBA massive body class type , extends ( helio_pl ) :: symba_pl logical , dimension (:), allocatable :: lcollision !! flag indicating whether body has merged with another this time step logical , dimension (:), allocatable :: lencounter !! flag indicating whether body is part of an encounter this time step logical , dimension (:), allocatable :: lmtiny !! flag indicating whether this body is below the GMTINY cutoff value integer ( I4B ) :: nplm !! number of bodies above the GMTINY limit integer ( I8B ) :: nplplm !! Number of body (all massive)-body (only those above GMTINY) comparisons in the flattened upper triangular matrix integer ( I4B ), dimension (:), allocatable :: nplenc !! number of encounters with other planets this time step integer ( I4B ), dimension (:), allocatable :: ntpenc !! number of encounters with test particles this time step integer ( I4B ), dimension (:), allocatable :: levelg !! level at which this body should be moved integer ( I4B ), dimension (:), allocatable :: levelm !! deepest encounter level achieved this time step integer ( I4B ), dimension (:), allocatable :: isperi !! perihelion passage flag real ( DP ), dimension (:), allocatable :: peri !! perihelion distance real ( DP ), dimension (:), allocatable :: atp !! semimajor axis following perihelion passage type ( symba_kinship ), dimension (:), allocatable :: kin !! Array of merger relationship structures that can account for multiple pairwise mergers in a single step type ( symba_particle_info ), dimension (:), allocatable :: info contains procedure :: make_family => symba_collision_make_family_pl !! When a single body is involved in more than one collision in a single step, it becomes part of a family procedure :: discard => symba_discard_pl !! Process massive body discards procedure :: drift => symba_drift_pl !! Method for Danby drift in Democratic Heliocentric coordinates. Sets the mask to the current recursion level procedure :: encounter_check => symba_encounter_check_pl !! Checks if massive bodies are going through close encounters with each other procedure :: accel => symba_kick_getacch_pl !! Compute heliocentric accelerations of massive bodies procedure :: setup => symba_setup_pl !! Constructor method - Allocates space for the input number of bodies procedure :: append => symba_util_append_pl !! Appends elements from one structure to another procedure :: fill => symba_util_fill_pl !! \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure :: get_peri => symba_util_peri_pl !! Determine system pericenter passages for massive bodies procedure :: rearray => symba_util_rearray_pl !! Clean up the massive body structures to remove discarded bodies and add new bodies procedure :: resize => symba_util_resize_pl !! Checks the current size of a SyMBA massive body against the requested size and resizes it if it is too small. procedure :: sort => symba_util_sort_pl !! Sorts body arrays by a sortable componen procedure :: rearrange => symba_util_sort_rearrange_pl !! Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure :: spill => symba_util_spill_pl !! \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) end type symba_pl type , extends ( symba_pl ) :: symba_merger integer ( I4B ), dimension (:), allocatable :: ncomp contains procedure :: append => symba_util_append_merger !! Appends elements from one structure to another procedure :: resize => symba_util_resize_merger !! Checks the current size of a SyMBA merger list against the requested size and resizes it if it is too small. procedure :: setup => symba_setup_merger !! Constructor method - Allocates space for the input number of bodies end type symba_merger !******************************************************************************************************************************** !                                    symba_tp class definitions and method interfaces !******************************************************************************************************************************* !> SyMBA test particle class type , extends ( helio_tp ) :: symba_tp integer ( I4B ), dimension (:), allocatable :: nplenc !! number of encounters with planets this time step integer ( I4B ), dimension (:), allocatable :: levelg !! level at which this particle should be moved integer ( I4B ), dimension (:), allocatable :: levelm !! deepest encounter level achieved this time step type ( symba_particle_info ), dimension (:), allocatable :: info contains procedure :: drift => symba_drift_tp !! Method for Danby drift in Democratic Heliocentric coordinates. Sets the mask to the current recursion level procedure :: encounter_check => symba_encounter_check_tp !! Checks if any test particles are undergoing a close encounter with a massive body procedure :: accel => symba_kick_getacch_tp !! Compute heliocentric accelerations of test particles procedure :: setup => symba_setup_tp !! Constructor method - Allocates space for the input number of bodies procedure :: append => symba_util_append_tp !! Appends elements from one structure to another procedure :: fill => symba_util_fill_tp !! \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure :: resize => symba_util_resize_tp !! Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure :: sort => symba_util_sort_tp !! Sorts body arrays by a sortable componen procedure :: rearrange => symba_util_sort_rearrange_tp !! Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure :: spill => symba_util_spill_tp !! \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) end type symba_tp !******************************************************************************************************************************** !                                    symba_pltpenc class definitions and method interfaces !******************************************************************************************************************************* !> SyMBA class for tracking pl-tp close encounters in a step type , extends ( swiftest_encounter ) :: symba_pltpenc integer ( I4B ), dimension (:), allocatable :: level !! encounter recursion level contains procedure :: collision_check => symba_collision_check_pltpenc !! Checks if a test particle is going to collide with a massive body procedure :: encounter_check => symba_encounter_check_pltpenc !! Checks if massive bodies are going through close encounters with each other procedure :: kick => symba_kick_pltpenc !! Kick barycentric velocities of active test particles within SyMBA recursion procedure :: setup => symba_setup_pltpenc !! A constructor that sets the number of encounters and allocates and initializes all arrays procedure :: spill => symba_util_spill_pltpenc !! \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) end type symba_pltpenc !******************************************************************************************************************************** !                                    symba_plplenc class definitions and method interfaces !******************************************************************************************************************************* !> SyMBA class for tracking pl-pl close encounters in a step type , extends ( symba_pltpenc ) :: symba_plplenc contains procedure :: scrub_non_collision => symba_collision_encounter_scrub !! Processes the pl-pl encounter list remove only those encounters that led to a collision procedure :: resolve_fragmentations => symba_collision_resolve_fragmentations !! Process list of collisions, determine the collisional regime, and then create fragments procedure :: resolve_mergers => symba_collision_resolve_mergers !! Process list of collisions and merge colliding bodies together end type symba_plplenc !******************************************************************************************************************************** !  symba_nbody_system class definitions and method interfaces !******************************************************************************************************************************** type , extends ( helio_nbody_system ) :: symba_nbody_system class ( symba_merger ), allocatable :: pl_adds !! List of added bodies in mergers or collisions class ( symba_pltpenc ), allocatable :: pltpenc_list !! List of massive body-test particle encounters in a single step class ( symba_plplenc ), allocatable :: plplenc_list !! List of massive body-massive body encounters in a single step integer ( I4B ) :: irec !! System recursion level contains procedure :: write_discard => symba_io_write_discard !! Write out information about discarded and merged planets and test particles in SyMBA procedure :: initialize => symba_setup_initialize_system !! Performs SyMBA-specific initilization steps procedure :: step => symba_step_system !! Advance the SyMBA nbody system forward in time by one step procedure :: interp => symba_step_interp_system !! Perform an interpolation step on the SymBA nbody system procedure :: set_recur_levels => symba_step_set_recur_levels_system !! Sets recursion levels of bodies and encounter lists to the current system level procedure :: recursive_step => symba_step_recur_system !! Step interacting planets and active test particles ahead in democratic heliocentric coordinates at the current recursion level, if applicable, and descend to the next deeper level if necessary procedure :: reset => symba_step_reset_system !! Resets pl, tp,and encounter structures at the start of a new step end type symba_nbody_system interface module subroutine symba_collision_check_pltpenc ( self , system , param , t , dt , irec ) use swiftest_classes , only : swiftest_parameters implicit none class ( symba_pltpenc ), intent ( inout ) :: self !! SyMBA pl-tp encounter list object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! current time real ( DP ), intent ( in ) :: dt !! step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level end subroutine symba_collision_check_pltpenc module subroutine symba_collision_encounter_scrub ( self , system , param ) implicit none class ( symba_plplenc ), intent ( inout ) :: self !! SyMBA pl-pl encounter list class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameterss end subroutine module subroutine symba_collision_make_family_pl ( self , idx ) implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), dimension ( 2 ), intent ( in ) :: idx !! Array holding the indices of the two bodies involved in the collision end subroutine symba_collision_make_family_pl module subroutine symba_collision_resolve_fragmentations ( self , system , param ) implicit none class ( symba_plplenc ), intent ( inout ) :: self !! SyMBA pl-pl encounter list class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( in ) :: param !! Current run configuration parameters with SyMBA additions end subroutine symba_collision_resolve_fragmentations module subroutine symba_collision_resolve_mergers ( self , system , param ) implicit none class ( symba_plplenc ), intent ( inout ) :: self !! SyMBA pl-pl encounter list class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( in ) :: param !! Current run configuration parameters with SyMBA additions end subroutine symba_collision_resolve_mergers module subroutine symba_discard_pl ( self , system , param ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine symba_discard_pl module subroutine symba_drift_pl ( self , system , param , dt ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( symba_pl ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize end subroutine symba_drift_pl module subroutine symba_drift_tp ( self , system , param , dt ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( symba_tp ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize end subroutine symba_drift_tp module pure elemental subroutine symba_encounter_check_one ( xr , yr , zr , vxr , vyr , vzr , rhill1 , rhill2 , dt , irec , lencounter , lvdotr ) implicit none real ( DP ), intent ( in ) :: xr , yr , zr , vxr , vyr , vzr real ( DP ), intent ( in ) :: rhill1 , rhill2 , dt integer ( I4B ), intent ( in ) :: irec logical , intent ( out ) :: lencounter , lvdotr end subroutine symba_encounter_check_one module function symba_encounter_check_pl ( self , system , dt , irec ) result ( lany_encounter ) implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA test particle object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object real ( DP ), intent ( in ) :: dt !! step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level logical :: lany_encounter !! Returns true if there is at least one close encounter end function symba_encounter_check_pl module function symba_encounter_check_pltpenc ( self , system , dt , irec ) result ( lany_encounter ) implicit none class ( symba_pltpenc ), intent ( inout ) :: self !! SyMBA pl-pl encounter list object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object real ( DP ), intent ( in ) :: dt !! step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level logical :: lany_encounter !! Returns true if there is at least one close encounter end function symba_encounter_check_pltpenc module function symba_encounter_check_tp ( self , system , dt , irec ) result ( lany_encounter ) implicit none class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object real ( DP ), intent ( in ) :: dt !! step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level logical :: lany_encounter !! Returns true if there is at least one close encounter end function symba_encounter_check_tp module function symba_fragmentation_casedisruption ( system , param , family , x , v , mass , radius , L_spin , Ip , mass_res , Qloss ) result ( status ) implicit none class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( in ) :: param !! Current run configuration parameters with SyMBA additions integer ( I4B ), dimension (:), intent ( in ) :: family !! List of indices of all bodies inovlved in the collision real ( DP ), dimension (:,:), intent ( inout ) :: x , v , L_spin , Ip !! Input values that represent a 2-body equivalent of a possibly 2+ body collision real ( DP ), dimension (:), intent ( inout ) :: mass , radius !! Input values that represent a 2-body equivalent of a possibly 2+ body collision real ( DP ), dimension (:), intent ( inout ) :: mass_res !! The distribution of fragment mass obtained by the regime calculation real ( DP ), intent ( inout ) :: Qloss !! Energy lost during collisionn integer ( I4B ) :: status !! Status flag assigned to this outcome end function symba_fragmentation_casedisruption module function symba_fragmentation_casehitandrun ( system , param , family , x , v , mass , radius , L_spin , Ip , mass_res , Qloss ) result ( status ) implicit none class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( in ) :: param !! Current run configuration parameters with SyMBA additions integer ( I4B ), dimension (:), intent ( in ) :: family !! List of indices of all bodies inovlved in the collision real ( DP ), dimension (:,:), intent ( inout ) :: x , v , L_spin , Ip !! Input values that represent a 2-body equivalent of a possibly 2+ body collision real ( DP ), dimension (:), intent ( inout ) :: mass , radius !! Input values that represent a 2-body equivalent of a possibly 2+ body collision real ( DP ), dimension (:), intent ( inout ) :: mass_res !! The distribution of fragment mass obtained by the regime calculation real ( DP ), intent ( inout ) :: Qloss !! Energy lost during collision integer ( I4B ) :: status !! Status flag assigned to this outcome end function symba_fragmentation_casehitandrun module function symba_fragmentation_casemerge ( system , param , family , x , v , mass , radius , L_spin , Ip ) result ( status ) implicit none class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( in ) :: param !! Current run configuration parameters with SyMBA additions integer ( I4B ), dimension (:), intent ( in ) :: family !! List of indices of all bodies inovlved in the collision real ( DP ), dimension (:,:), intent ( in ) :: x , v , L_spin , Ip !! Input values that represent a 2-body equivalent of a possibly 2+ body collision real ( DP ), dimension (:), intent ( in ) :: mass , radius !! Input values that represent a 2-body equivalent of a possibly 2+ body collisio integer ( I4B ) :: status !! Status flag assigned to this outcome end function symba_fragmentation_casemerge module function symba_fragmentation_casesupercatastrophic ( system , param , family , x , v , mass , radius , L_spin , Ip , mass_res , Qloss ) result ( status ) implicit none class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( in ) :: param !! Current run configuration parameters with SyMBA additions integer ( I4B ), dimension (:), intent ( in ) :: family !! List of indices of all bodies inovlved in the collision real ( DP ), dimension (:,:), intent ( inout ) :: x , v , L_spin , Ip !! Input values that represent a 2-body equivalent of a possibly 2+ body collision real ( DP ), dimension (:), intent ( inout ) :: mass , radius !! Input values that represent a 2-body equivalent of a possibly 2+ body collision real ( DP ), dimension (:), intent ( inout ) :: mass_res !! The distribution of fragment mass obtained by the regime calculation real ( DP ), intent ( inout ) :: Qloss !! Energy lost during collision integer ( I4B ) :: status !! Status flag assigned to this outcome end function symba_fragmentation_casesupercatastrophic module subroutine symba_io_write_discard ( self , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine symba_io_write_discard module subroutine symba_io_dump_particle_info ( system , param , lincludecb , tpidx , plidx ) implicit none class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( in ) :: param !! Current run configuration parameters with SyMBA extensions logical , optional , intent ( in ) :: lincludecb !! Set to true to include the central body (default is false) integer ( I4B ), dimension (:), optional , intent ( in ) :: tpidx !! Array of test particle indices to append to the particle file integer ( I4B ), dimension (:), optional , intent ( in ) :: plidx !! Array of massive body indices to append to the particle file end subroutine symba_io_dump_particle_info module subroutine symba_io_param_reader ( self , unit , iotype , v_list , iostat , iomsg ) implicit none class ( symba_parameters ), intent ( inout ) :: self !! Current run configuration parameters with SyMBA additionss integer , intent ( in ) :: unit !! File unit number character ( len =* ), intent ( in ) :: iotype !! Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. !!    If you do not include a char-literal-constant, the iotype argument contains only DT. integer , intent ( in ) :: v_list (:) !! The first element passes the integrator code to the reader integer , intent ( out ) :: iostat !! IO status code character ( len =* ), intent ( inout ) :: iomsg !! Message to pass if iostat /= 0 end subroutine symba_io_param_reader module subroutine symba_io_param_writer ( self , unit , iotype , v_list , iostat , iomsg ) implicit none class ( symba_parameters ), intent ( in ) :: self !! Current run configuration parameters with SyMBA additions integer , intent ( in ) :: unit !! File unit number character ( len =* ), intent ( in ) :: iotype !! Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. !!    If you do not include a char-literal-constant, the iotype argument contains only DT. integer , intent ( in ) :: v_list (:) !! Not used in this procedure integer , intent ( out ) :: iostat !! IO status code character ( len =* ), intent ( inout ) :: iomsg !! Message to pass if iostat /= 0 end subroutine symba_io_param_writer module subroutine symba_io_read_particle ( system , param ) implicit none class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system file class ( symba_parameters ), intent ( inout ) :: param !! Current run configuration parameters with SyMBA extensions end subroutine symba_io_read_particle module subroutine symba_kick_getacch_pl ( self , system , param , t , lbeg ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step end subroutine symba_kick_getacch_pl module subroutine symba_kick_getacch_tp ( self , system , param , t , lbeg ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step end subroutine symba_kick_getacch_tp module subroutine symba_kick_pltpenc ( self , system , dt , irec , sgn ) implicit none class ( symba_pltpenc ), intent ( in ) :: self !! SyMBA pl-tp encounter list object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object real ( DP ), intent ( in ) :: dt !! step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level integer ( I4B ), intent ( in ) :: sgn !! sign to be applied to acceleration end subroutine symba_kick_pltpenc module subroutine symba_setup_initialize_particle_info ( system , param ) implicit none class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( inout ) :: param !! Current run configuration parameters with SyMBA extensions end subroutine symba_setup_initialize_particle_info module subroutine symba_setup_initialize_system ( self , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine symba_setup_initialize_system module subroutine symba_setup_merger ( self , n , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( symba_merger ), intent ( inout ) :: self !! SyMBA merger list object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine symba_setup_merger module subroutine symba_setup_pl ( self , n , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine symba_setup_pl module subroutine symba_setup_pltpenc ( self , n ) implicit none class ( symba_pltpenc ), intent ( inout ) :: self !! SyMBA pl-tp encounter structure integer ( I4B ), intent ( in ) :: n !! Number of encounters to allocate space for end subroutine symba_setup_pltpenc module subroutine symba_setup_tp ( self , n , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameter end subroutine symba_setup_tp module subroutine symba_step_system ( self , param , t , dt ) use swiftest_classes , only : swiftest_parameters implicit none class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize end subroutine symba_step_system module subroutine symba_step_interp_system ( self , param , t , dt ) use swiftest_classes , only : swiftest_parameters implicit none class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize end subroutine symba_step_interp_system module subroutine symba_step_set_recur_levels_system ( self , ireci ) implicit none class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system objec integer ( I4B ), intent ( in ) :: ireci !! Input recursion level end subroutine symba_step_set_recur_levels_system module recursive subroutine symba_step_recur_system ( self , param , t , ireci ) use swiftest_classes , only : swiftest_parameters implicit none class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), value :: t integer ( I4B ), value :: ireci !! input recursion level end subroutine symba_step_recur_system module subroutine symba_step_reset_system ( self ) implicit none class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object end subroutine symba_step_reset_system end interface interface util_append module subroutine symba_util_append_arr_info ( arr , source , nold , nsrc , lsource_mask ) implicit none type ( symba_particle_info ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array type ( symba_particle_info ), dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine symba_util_append_arr_info module subroutine symba_util_append_arr_kin ( arr , source , nold , nsrc , lsource_mask ) implicit none type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array type ( symba_kinship ), dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine symba_util_append_arr_kin end interface interface module subroutine symba_util_append_merger ( self , source , lsource_mask ) use swiftest_classes , only : swiftest_body implicit none class ( symba_merger ), intent ( inout ) :: self !! SyMBA massive body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine symba_util_append_merger module subroutine symba_util_append_pl ( self , source , lsource_mask ) use swiftest_classes , only : swiftest_body implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine symba_util_append_pl module subroutine symba_util_append_tp ( self , source , lsource_mask ) use swiftest_classes , only : swiftest_body implicit none class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine symba_util_append_tp end interface interface util_fill module subroutine symba_util_fill_arr_info ( keeps , inserts , lfill_list ) implicit none type ( symba_particle_info ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep type ( symba_particle_info ), dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine symba_util_fill_arr_info module subroutine symba_util_fill_arr_kin ( keeps , inserts , lfill_list ) implicit none type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep type ( symba_kinship ), dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine symba_util_fill_arr_kin end interface interface module subroutine symba_util_fill_pl ( self , inserts , lfill_list ) use swiftest_classes , only : swiftest_body implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object class ( swiftest_body ), intent ( in ) :: inserts !! Inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine symba_util_fill_pl module subroutine symba_util_fill_tp ( self , inserts , lfill_list ) use swiftest_classes , only : swiftest_body implicit none class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object class ( swiftest_body ), intent ( in ) :: inserts !! Inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine symba_util_fill_tp module subroutine symba_util_peri_pl ( self , system , param ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine symba_util_peri_pl module subroutine symba_util_rearray_pl ( self , system , param ) implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( in ) :: param !! Current run configuration parameters with SyMBA additions end subroutine symba_util_rearray_pl end interface interface util_resize module subroutine symba_util_resize_arr_info ( arr , nnew ) implicit none type ( symba_particle_info ), dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size end subroutine symba_util_resize_arr_info module subroutine symba_util_resize_arr_kin ( arr , nnew ) implicit none type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size end subroutine symba_util_resize_arr_kin end interface interface module subroutine symba_util_resize_merger ( self , nnew ) implicit none class ( symba_merger ), intent ( inout ) :: self !! SyMBA merger list object integer ( I4B ), intent ( in ) :: nnew !! New size neded end subroutine symba_util_resize_merger module subroutine symba_util_resize_pl ( self , nnew ) implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), intent ( in ) :: nnew !! New size neded end subroutine symba_util_resize_pl module subroutine symba_util_resize_tp ( self , nnew ) implicit none class ( symba_tp ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), intent ( in ) :: nnew !! New size neded end subroutine symba_util_resize_tp module subroutine symba_util_sort_pl ( self , sortby , ascending ) implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order end subroutine symba_util_sort_pl module subroutine symba_util_sort_tp ( self , sortby , ascending ) implicit none class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order end subroutine symba_util_sort_tp module subroutine symba_util_sort_rearrange_pl ( self , ind ) implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) end subroutine symba_util_sort_rearrange_pl module subroutine symba_util_sort_rearrange_tp ( self , ind ) implicit none class ( symba_tp ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) end subroutine symba_util_sort_rearrange_tp end interface interface util_spill module subroutine symba_util_spill_arr_info ( keeps , discards , lspill_list , ldestructive ) implicit none type ( symba_particle_info ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep type ( symba_particle_info ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discardss logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine symba_util_spill_arr_info module subroutine symba_util_spill_arr_kin ( keeps , discards , lspill_list , ldestructive ) implicit none type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discardss logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine symba_util_spill_arr_kin end interface interface module subroutine symba_util_spill_pl ( self , discards , lspill_list , ldestructive ) use swiftest_classes , only : swiftest_body implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine symba_util_spill_pl module subroutine symba_util_spill_pltpenc ( self , discards , lspill_list , ldestructive ) use swiftest_classes , only : swiftest_encounter implicit none class ( symba_pltpenc ), intent ( inout ) :: self !! SyMBA pl-tp encounter list class ( swiftest_encounter ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter body by removing the discard list end subroutine symba_util_spill_pltpenc module subroutine symba_util_spill_tp ( self , discards , lspill_list , ldestructive ) use swiftest_classes , only : swiftest_body implicit none class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine symba_util_spill_tp end interface end module symba_classes","tags":"","loc":"sourcefile/symba_classes.f90.html"},{"title":"swiftest.f90 – swiftest","text":"This file depends on sourcefile~~swiftest.f90~~EfferentGraph sourcefile~swiftest.f90 swiftest.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~swiftest.f90~~AfferentGraph sourcefile~swiftest.f90 swiftest.f90 sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90 orbel.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~util_resize.f90 util_resize.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~gr.f90 gr.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~util_coord.f90 util_coord.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~eucl.f90 eucl.f90 sourcefile~eucl.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~obl.f90 obl.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~helio_coord.f90 helio_coord.f90 sourcefile~helio_coord.f90->sourcefile~swiftest.f90 sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~drift.f90 drift.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~util_set.f90 util_set.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~setup.f90 setup.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~fragmentation.f90 fragmentation.f90 sourcefile~fragmentation.f90->sourcefile~swiftest.f90 sourcefile~util_solve.f90 util_solve.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~util_spill.f90 util_spill.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~symba_fragmentation.f90 symba_fragmentation.f90 sourcefile~symba_fragmentation.f90->sourcefile~swiftest.f90 sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~util_sort.f90 util_sort.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~util_fill.f90 util_fill.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~kick.f90 kick.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~util_copy.f90 util_copy.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~util_append.f90 util_append.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules swiftest Source Code swiftest.f90 Source Code module swiftest !! author: David A. Minton !! graph: false !! !! This module serves to combine all of the Swiftest project modules under a single umbrella so that they can be accessed from individual submodule implementations with a simple \"use swiftest\" line. use swiftest_globals use swiftest_operators use swiftest_classes use whm_classes use rmvs_classes use helio_classes use symba_classes use lambda_function !use advisor_annotate !$ use omp_lib implicit none public end module swiftest","tags":"","loc":"sourcefile/swiftest.f90.html"},{"title":"swiftest_classes.f90 – swiftest","text":"This file depends on sourcefile~~swiftest_classes.f90~~EfferentGraph sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~swiftest_classes.f90~~AfferentGraph sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90 orbel.f90 sourcefile~orbel.f90->sourcefile~swiftest_classes.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~swiftest_classes.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~util_resize.f90 util_resize.f90 sourcefile~util_resize.f90->sourcefile~swiftest_classes.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~gr.f90 gr.f90 sourcefile~gr.f90->sourcefile~swiftest_classes.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~util_coord.f90 util_coord.f90 sourcefile~util_coord.f90->sourcefile~swiftest_classes.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~eucl.f90 eucl.f90 sourcefile~eucl.f90->sourcefile~swiftest_classes.f90 sourcefile~eucl.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~swiftest_classes.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~obl.f90 obl.f90 sourcefile~obl.f90->sourcefile~swiftest_classes.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest_classes.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~drift.f90 drift.f90 sourcefile~drift.f90->sourcefile~swiftest_classes.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~user_getacch.f90->sourcefile~swiftest_classes.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~util_set.f90 util_set.f90 sourcefile~util_set.f90->sourcefile~swiftest_classes.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~swiftest_classes.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~setup.f90 setup.f90 sourcefile~setup.f90->sourcefile~swiftest_classes.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~fragmentation.f90 fragmentation.f90 sourcefile~fragmentation.f90->sourcefile~swiftest_classes.f90 sourcefile~fragmentation.f90->sourcefile~swiftest.f90 sourcefile~util_solve.f90 util_solve.f90 sourcefile~util_solve.f90->sourcefile~swiftest_classes.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~util_spill.f90 util_spill.f90 sourcefile~util_spill.f90->sourcefile~swiftest_classes.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~swiftest_classes.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~util_rescale.f90->sourcefile~swiftest_classes.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~swiftest_classes.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest_classes.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest_classes.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~util_sort.f90 util_sort.f90 sourcefile~util_sort.f90->sourcefile~swiftest_classes.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~util_fill.f90 util_fill.f90 sourcefile~util_fill.f90->sourcefile~swiftest_classes.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~kick.f90 kick.f90 sourcefile~kick.f90->sourcefile~swiftest_classes.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest_classes.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~util_copy.f90 util_copy.f90 sourcefile~util_copy.f90->sourcefile~swiftest_classes.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~util_append.f90 util_append.f90 sourcefile~util_append.f90->sourcefile~swiftest_classes.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~whm_gr.f90->sourcefile~whm_classes.f90 sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_step.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90->sourcefile~rmvs_classes.f90 sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_step.f90->sourcefile~helio_classes.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~rmvs_classes.f90 sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_kick.f90->sourcefile~helio_classes.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90->sourcefile~symba_classes.f90 sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_setup.f90->sourcefile~rmvs_classes.f90 sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90->sourcefile~whm_classes.f90 sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~symba_collision.f90->sourcefile~symba_classes.f90 sourcefile~helio_coord.f90 helio_coord.f90 sourcefile~helio_coord.f90->sourcefile~helio_classes.f90 sourcefile~helio_coord.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90->sourcefile~symba_classes.f90 sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~whm_setup.f90->sourcefile~whm_classes.f90 sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~symba_discard.f90->sourcefile~symba_classes.f90 sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~symba_drift.f90->sourcefile~symba_classes.f90 sourcefile~symba_fragmentation.f90 symba_fragmentation.f90 sourcefile~symba_fragmentation.f90->sourcefile~swiftest.f90 sourcefile~symba_fragmentation.f90->sourcefile~symba_classes.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~helio_classes.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~symba_encounter_check.f90->sourcefile~symba_classes.f90 sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~symba_io.f90->sourcefile~symba_classes.f90 sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90->sourcefile~rmvs_classes.f90 sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_gr.f90->sourcefile~helio_classes.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90->sourcefile~symba_classes.f90 sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~whm_drift.f90->sourcefile~whm_classes.f90 sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~symba_util.f90->sourcefile~symba_classes.f90 sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~whm_util.f90->sourcefile~whm_classes.f90 sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~whm_kick.f90->sourcefile~whm_classes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules swiftest_classes Source Code swiftest_classes.f90 Source Code module swiftest_classes !! author: The Purdue Swiftest Team -  David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Definition of data and structures generic to all integrators. !! Adapted from David E. Kaufmann's Swifter routine: module_swifter.f90 use swiftest_globals implicit none public !******************************************************************************************************************************** ! swiftest_parameters class definitions !******************************************************************************************************************************** !> User defined parameters that are read in from the parameters input file. !>    Each paramter is initialized to a default values. type :: swiftest_parameters integer ( I4B ) :: integrator = UNKNOWN_INTEGRATOR !! Symbolic name of the nbody integrator  used integer ( I4B ) :: nplmax = - 1 !! Maximum allowed number of massive bodies integer ( I4B ) :: ntpmax = - 1 !! Maximum allowed number of test particles real ( DP ) :: t0 = - 1.0_DP !! Integration start time real ( DP ) :: t = - 1.0_DP !! Integration current time real ( DP ) :: tstop = - 1.0_DP !! Integration stop time real ( DP ) :: dt = - 1.0_DP !! Time step character ( STRMAX ) :: incbfile = CB_INFILE !! Name of input file for the central body character ( STRMAX ) :: inplfile = PL_INFILE !! Name of input file for massive bodies character ( STRMAX ) :: intpfile = TP_INFILE !! Name of input file for test particles character ( STRMAX ) :: in_type = ASCII_TYPE !! Format of input data files integer ( I4B ) :: istep_out = - 1 !! Number of time steps between binary outputs character ( STRMAX ) :: outfile = BIN_OUTFILE !! Name of output binary file character ( STRMAX ) :: out_type = REAL8_TYPE !! Binary format of output file character ( STRMAX ) :: out_form = XV !! Data to write to output file character ( STRMAX ) :: out_stat = 'NEW' !! Open status for output binary file integer ( I4B ) :: istep_dump = - 1 !! Number of time steps between dumps real ( DP ) :: rmin = - 1.0_DP !! Minimum heliocentric radius for test particle real ( DP ) :: rmax = - 1.0_DP !! Maximum heliocentric radius for test particle real ( DP ) :: rmaxu = - 1.0_DP !! Maximum unbound heliocentric radius for test particle real ( DP ) :: qmin = - 1.0_DP !! Minimum pericenter distance for test particle character ( STRMAX ) :: qmin_coord = 'HELIO' !! Coordinate frame to use for qmin real ( DP ) :: qmin_alo = - 1.0_DP !! Minimum semimajor axis for qmin real ( DP ) :: qmin_ahi = - 1.0_DP !! Maximum semimajor axis for qmin character ( STRMAX ) :: enc_out = \"\" !! Name of output file for encounters character ( STRMAX ) :: discard_out = \"\" !! Name of output file for discards real ( QP ) :: MU2KG = - 1.0_QP !! Converts mass units to grams real ( QP ) :: TU2S = - 1.0_QP !! Converts time units to seconds real ( QP ) :: DU2M = - 1.0_QP !! Converts distance unit to centimeters real ( DP ) :: GU = - 1.0_DP !! Universal gravitational constant in the system units real ( DP ) :: inv_c2 = - 1.0_DP !! Inverse speed of light squared in the system units character ( STRMAX ) :: energy_out = \"\" !! Name of output energy and momentum report file ! Logical flags to turn on or off various features of the code logical :: lrhill_present = . false . !! Hill radii are given as an input rather than calculated by the code (can be used to inflate close encounter regions manually) logical :: lextra_force = . false . !! User defined force function turned on logical :: lbig_discard = . false . !! Save big bodies on every discard logical :: lclose = . false . !! Turn on close encounters logical :: lenergy = . false . !! Track the total energy of the system logical :: loblatecb = . false . !! Calculate acceleration from oblate central body (automatically turns true if nonzero J2 is input) logical :: lrotation = . false . !! Include rotation states of big bodies logical :: ltides = . false . !! Include tidal dissipation ! Initial values to pass to the energy report subroutine (usually only used in the case of a restart, otherwise these will be updated with initial conditions values) real ( DP ) :: Eorbit_orig = 0.0_DP !! Initial orbital energy real ( DP ) :: Mtot_orig = 0.0_DP !! Initial system mass real ( DP ) :: Lmag_orig = 0.0_DP !! Initial total angular momentum magnitude real ( DP ), dimension ( NDIM ) :: Ltot_orig = 0.0_DP !! Initial total angular momentum vector real ( DP ), dimension ( NDIM ) :: Lorbit_orig = 0.0_DP !! Initial orbital angular momentum real ( DP ), dimension ( NDIM ) :: Lspin_orig = 0.0_DP !! Initial spin angular momentum vector real ( DP ), dimension ( NDIM ) :: Ltot = 0.0_DP !! System angular momentum vector real ( DP ), dimension ( NDIM ) :: Lescape = 0.0_DP !! Angular momentum of bodies that escaped the system (used for bookeeping) real ( DP ) :: Mescape = 0.0_DP !! Mass of bodies that escaped the system (used for bookeeping) real ( DP ) :: Ecollisions = 0.0_DP !! Energy lost from system due to collisions real ( DP ) :: Euntracked = 0.0_DP !! Energy gained from system due to escaped bodies logical :: lfirstenergy = . true . !! This is the first time computing energe logical :: lfirstkick = . true . !! Initiate the first kick in a symplectic step logical :: lrestart = . false . !! Indicates whether or not this is a restarted run ! Future features not implemented or in development logical :: lgr = . false . !! Turn on GR logical :: lyarkovsky = . false . !! Turn on Yarkovsky effect logical :: lyorp = . false . !! Turn on YORP effect contains procedure :: reader => io_param_reader procedure :: writer => io_param_writer procedure :: dump => io_dump_param procedure :: read_from_file => io_read_param_in end type swiftest_parameters !******************************************************************************************************************************** ! swiftest_base class definitions and methods !******************************************************************************************************************************** type , abstract :: swiftest_base !! An superclass for a generic Swiftest object logical :: lintegrate = . false . !! Flag indicating that this object should be integrated in the current step contains !! The minimal methods that all systems must have procedure :: dump => io_dump_swiftest procedure ( abstract_initialize ), deferred :: initialize procedure ( abstract_read_frame ), deferred :: read_frame procedure ( abstract_write_frame ), deferred :: write_frame end type swiftest_base !******************************************************************************************************************************** ! swiftest_cb class definitions and methods !******************************************************************************************************************************** !> A concrete lass for the central body in a Swiftest simulation type , abstract , extends ( swiftest_base ) :: swiftest_cb character ( len = STRMAX ) :: name !! Non-unique name integer ( I4B ) :: id = 0 !! External identifier (unique) real ( DP ) :: mass = 0.0_DP !! Central body mass (units MU) real ( DP ) :: Gmass = 0.0_DP !! Central mass gravitational term G * mass (units GU * MU) real ( DP ) :: radius = 0.0_DP !! Central body radius (units DU) real ( DP ) :: density = 1.0_DP !! Central body mass density - calculated internally (units MU / DU**3) real ( DP ) :: j2rp2 = 0.0_DP !! J2*R&#94;2 term for central body real ( DP ) :: j4rp4 = 0.0_DP !! J4*R&#94;2 term for central body real ( DP ), dimension ( NDIM ) :: aobl = 0.0_DP !! Barycentric acceleration due to central body oblatenes real ( DP ), dimension ( NDIM ) :: atide = 0.0_DP !! Barycentric acceleration due to central body oblatenes real ( DP ), dimension ( NDIM ) :: aoblbeg = 0.0_DP !! Barycentric acceleration due to central body oblatenes at beginning of step real ( DP ), dimension ( NDIM ) :: aoblend = 0.0_DP !! Barycentric acceleration due to central body oblatenes at end of step real ( DP ), dimension ( NDIM ) :: atidebeg = 0.0_DP !! Barycentric acceleration due to central body oblatenes at beginning of step real ( DP ), dimension ( NDIM ) :: atideend = 0.0_DP !! Barycentric acceleration due to central body oblatenes at end of step real ( DP ), dimension ( NDIM ) :: xb = 0.0_DP !! Barycentric position (units DU) real ( DP ), dimension ( NDIM ) :: vb = 0.0_DP !! Barycentric velocity (units DU / TU) real ( DP ), dimension ( NDIM ) :: agr = 0.0_DP !! Acceleration due to post-Newtonian correction real ( DP ), dimension ( NDIM ) :: Ip = 0.0_DP !! Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real ( DP ), dimension ( NDIM ) :: rot = 0.0_DP !! Body rotation vector in inertial coordinate frame (units rad / TU) real ( DP ) :: k2 = 0.0_DP !! Tidal Love number real ( DP ) :: Q = 0.0_DP !! Tidal quality factor real ( DP ) :: tlag = 0.0_DP !! Tidal phase lag angle real ( DP ), dimension ( NDIM ) :: L0 = 0.0_DP !! Initial angular momentum of the central body real ( DP ), dimension ( NDIM ) :: dL = 0.0_DP !! Change in angular momentum of the central body contains procedure :: initialize => io_read_cb_in !! I/O routine for reading in central body data procedure :: read_frame => io_read_frame_cb !! I/O routine for reading out a single frame of time-series data for the central body procedure :: write_frame => io_write_frame_cb !! I/O routine for writing out a single frame of time-series data for the central body end type swiftest_cb !******************************************************************************************************************************** ! swiftest_body definitions and methods !******************************************************************************************************************************** !> An abstract class for a generic collection of Swiftest bodies type , abstract , extends ( swiftest_base ) :: swiftest_body !! Superclass that defines the generic elements of a Swiftest particle logical :: lfirst = . true . !! Run the current step as a first integer ( I4B ) :: nbody = 0 !! Number of bodies character ( len = STRMAX ), dimension (:), allocatable :: name !! Non-unique name integer ( I4B ), dimension (:), allocatable :: id !! External identifier (unique) integer ( I4B ), dimension (:), allocatable :: status !! An integrator-specific status indicator logical , dimension (:), allocatable :: ldiscard !! Body should be discarded logical , dimension (:), allocatable :: lmask !! Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real ( DP ), dimension (:), allocatable :: mu !! G * (Mcb + [m]) real ( DP ), dimension (:,:), allocatable :: xh !! Heliocentric position real ( DP ), dimension (:,:), allocatable :: vh !! Heliocentric velocity real ( DP ), dimension (:,:), allocatable :: xb !! Barycentric position real ( DP ), dimension (:,:), allocatable :: vb !! Barycentric velocity real ( DP ), dimension (:,:), allocatable :: ah !! Total heliocentric acceleration real ( DP ), dimension (:,:), allocatable :: aobl !! Barycentric accelerations of bodies due to central body oblatenes real ( DP ), dimension (:,:), allocatable :: atide !! Tanngential component of acceleration of bodies due to tides real ( DP ), dimension (:,:), allocatable :: agr !! Acceleration due to post-Newtonian correction real ( DP ), dimension (:), allocatable :: ir3h !! Inverse heliocentric radius term (1/rh**3) real ( DP ), dimension (:), allocatable :: a !! Semimajor axis (pericentric distance for a parabolic orbit) real ( DP ), dimension (:), allocatable :: e !! Eccentricity real ( DP ), dimension (:), allocatable :: inc !! Inclination real ( DP ), dimension (:), allocatable :: capom !! Longitude of ascending node real ( DP ), dimension (:), allocatable :: omega !! Argument of pericenter real ( DP ), dimension (:), allocatable :: capm !! Mean anomaly !! Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the !!    component list, such as setup_body and util_spill contains procedure ( abstract_discard_body ), deferred :: discard procedure ( abstract_kick_body ), deferred :: kick procedure ( abstract_set_mu ), deferred :: set_mu procedure ( abstract_step_body ), deferred :: step procedure ( abstract_accel ), deferred :: accel ! These are concrete because the implementation is the same for all types of particles procedure :: drift => drift_body !! Loop through bodies and call Danby drift routine on heliocentric variables procedure :: v2pv => gr_vh2pv_body !! Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure :: pv2v => gr_pv2vh_body !! Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure :: initialize => io_read_body_in !! Read in body initial conditions from a file procedure :: read_frame => io_read_frame_body !! I/O routine for writing out a single frame of time-series data for the central body procedure :: write_frame => io_write_frame_body !! I/O routine for writing out a single frame of time-series data for the central body procedure :: accel_obl => obl_acc_body !! Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure :: el2xv => orbel_el2xv_vec !! Convert orbital elements to position and velocity vectors procedure :: xv2el => orbel_xv2el_vec !! Convert position and velocity vectors to orbital  elements procedure :: setup => setup_body !! A constructor that sets the number of bodies and allocates all allocatable arrays procedure :: accel_user => user_kick_getacch_body !! Add user-supplied heliocentric accelerations to planets procedure :: append => util_append_body !! Appends elements from one structure to another procedure :: fill => util_fill_body !! \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure :: resize => util_resize_body !! Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure :: set_ir3 => util_set_ir3h !! Sets the inverse heliocentric radius term (1/rh**3) procedure :: sort => util_sort_body !! Sorts body arrays by a sortable componen procedure :: rearrange => util_sort_rearrange_body !! Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure :: spill => util_spill_body !! \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) end type swiftest_body !******************************************************************************************************************************** ! swiftest_pl definitions and methods !******************************************************************************************************************************** !> An abstract class for a generic collection of Swiftest massive bodies type , abstract , extends ( swiftest_body ) :: swiftest_pl !! Superclass that defines the generic elements of a Swiftest particle real ( DP ), dimension (:), allocatable :: mass !! Body mass (units MU) real ( DP ), dimension (:), allocatable :: Gmass !! Mass gravitational term G * mass (units GU * MU) real ( DP ), dimension (:), allocatable :: rhill !! Body mass (units MU) real ( DP ), dimension (:), allocatable :: radius !! Body radius (units DU) real ( DP ), dimension (:,:), allocatable :: xbeg !! Position at beginning of step real ( DP ), dimension (:,:), allocatable :: xend !! Position at end of step real ( DP ), dimension (:,:), allocatable :: vbeg !! Velocity at beginning of step real ( DP ), dimension (:), allocatable :: density !! Body mass density - calculated internally (units MU / DU**3) real ( DP ), dimension (:,:), allocatable :: Ip !! Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real ( DP ), dimension (:,:), allocatable :: rot !! Body rotation vector in inertial coordinate frame (units rad / TU) real ( DP ), dimension (:), allocatable :: k2 !! Tidal Love number real ( DP ), dimension (:), allocatable :: Q !! Tidal quality factor real ( DP ), dimension (:), allocatable :: tlag !! Tidal phase lag integer ( I4B ), dimension (:,:), allocatable :: k_plpl !! Index array used to convert flattened the body-body comparison upper triangular matrix integer ( I8B ) :: nplpl !! Number of body-body comparisons in the flattened upper triangular matrix !! Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the !!    component list, such as setup_pl and util_spill_pl contains ! Massive body-specific concrete methods ! These are concrete because they are the same implemenation for all integrators procedure :: discard => discard_pl !! Placeholder method for discarding massive bodies procedure :: eucl_index => eucl_dist_index_plpl !! Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix procedure :: accel_int => kick_getacch_int_pl !! Compute direct cross (third) term heliocentric accelerations of massive bodies procedure :: accel_obl => obl_acc_pl !! Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure :: setup => setup_pl !! A base constructor that sets the number of bodies and allocates and initializes all arrays procedure :: accel_tides => tides_kick_getacch_pl !! Compute the accelerations of bodies due to tidal interactions with the central body procedure :: append => util_append_pl !! Appends elements from one structure to another procedure :: h2b => util_coord_h2b_pl !! Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) procedure :: b2h => util_coord_b2h_pl !! Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) procedure :: fill => util_fill_pl !! \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure :: resize => util_resize_pl !! Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure :: set_beg_end => util_set_beg_end_pl !! Sets the beginning and ending positions and velocities of planets. procedure :: set_mu => util_set_mu_pl !! Method used to construct the vectorized form of the central body mass procedure :: set_rhill => util_set_rhill !! Calculates the Hill's radii for each body procedure :: sort => util_sort_pl !! Sorts body arrays by a sortable component procedure :: rearrange => util_sort_rearrange_pl !! Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure :: spill => util_spill_pl !! \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) end type swiftest_pl !******************************************************************************************************************************** ! swiftest_tp definitions and methods !******************************************************************************************************************************** !> An abstract class for a generic collection of Swiftest test particles type , abstract , extends ( swiftest_body ) :: swiftest_tp !! Superclass that defines the generic elements of a Swiftest test particle integer ( I4B ), dimension (:), allocatable :: isperi !! Perihelion passage flag real ( DP ), dimension (:), allocatable :: peri !! Perihelion distance real ( DP ), dimension (:), allocatable :: atp !! Semimajor axis following perihelion passage !! Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the !!    component list, such as setup_tp and util_spill_tp contains ! Test particle-specific concrete methods ! These are concrete because they are the same implemenation for all integrators procedure :: discard => discard_tp !! Check to see if test particles should be discarded based on their positions relative to the massive bodies procedure :: accel_int => kick_getacch_int_tp !! Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies procedure :: accel_obl => obl_acc_tp !! Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure :: setup => setup_tp !! A base constructor that sets the number of bodies and procedure :: append => util_append_tp !! Appends elements from one structure to another procedure :: h2b => util_coord_h2b_tp !! Convert test particles from heliocentric to barycentric coordinates (position and velocity) procedure :: b2h => util_coord_b2h_tp !! Convert test particles from barycentric to heliocentric coordinates (position and velocity) procedure :: fill => util_fill_tp !! \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure :: get_peri => util_peri_tp !! Determine system pericenter passages for test particles procedure :: resize => util_resize_tp !! Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure :: set_mu => util_set_mu_tp !! Method used to construct the vectorized form of the central body mass procedure :: sort => util_sort_tp !! Sorts body arrays by a sortable component procedure :: rearrange => util_sort_rearrange_tp !! Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure :: spill => util_spill_tp !! \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) end type swiftest_tp !******************************************************************************************************************************** ! swiftest_nbody_system class definitions and methods !******************************************************************************************************************************** !> An abstract class for a basic Swiftest nbody system type , abstract , extends ( swiftest_base ) :: swiftest_nbody_system !!  This superclass contains a minimial system of a set of test particles (tp), massive bodies (pl), and a central body (cb) class ( swiftest_cb ), allocatable :: cb !! Central body data structure class ( swiftest_pl ), allocatable :: pl !! Massive body data structure class ( swiftest_tp ), allocatable :: tp !! Test particle data structure class ( swiftest_tp ), allocatable :: tp_discards !! Discarded test particle data structure class ( swiftest_pl ), allocatable :: pl_discards !! Discarded massive body particle data structure real ( DP ) :: Gmtot = 0.0_DP !! Total system mass - used for barycentric coordinate conversion real ( DP ) :: ke_orbit = 0.0_DP !! System orbital kinetic energy real ( DP ) :: ke_spin = 0.0_DP !! System spin kinetic energy real ( DP ) :: pe = 0.0_DP !! System potential energy real ( DP ) :: te = 0.0_DP !! System total energy real ( DP ), dimension ( NDIM ) :: Lorbit = 0.0_DP !! System orbital angular momentum vector real ( DP ), dimension ( NDIM ) :: Lspin = 0.0_DP !! System spin angular momentum vector real ( DP ), dimension ( NDIM ) :: Lescape = 0.0_DP !! Angular momentum of bodies that escaped the system (used for bookeeping) real ( DP ) :: Mescape = 0.0_DP !! Mass of bodies that escaped the system (used for bookeeping) real ( DP ) :: Ecollisions = 0.0_DP !! Energy lost from system due to collisions real ( DP ) :: Euntracked = 0.0_DP !! Energy gained from system due to escaped bodies logical :: lbeg !! True if this is the beginning of a step. This is used so that test particle steps can be calculated !!    separately from massive bodies.  Massive body variables are saved at half steps, and passed to !!    the test particles integer ( I4B ) :: maxid = - 1 !! The current maximum particle id number contains !> Each integrator will have its own version of the step procedure ( abstract_step_system ), deferred :: step ! Concrete classes that are common to the basic integrator (only test particles considered for discard) procedure :: discard => discard_system !! Perform a discard step on the system procedure :: conservation_report => io_conservation_report !! Compute energy and momentum and print out the change with time procedure :: dump => io_dump_system !! Dump the state of the system to a file procedure :: read_frame => io_read_frame_system !! Read in a frame of input data from file procedure :: write_discard => io_write_discard !! Write out information about discarded test particles procedure :: write_frame => io_write_frame_system !! Append a frame of output data to file procedure :: initialize => setup_initialize_system !! Initialize the system from input files procedure :: step_spin => tides_step_spin_system !! Steps the spins of the massive & central bodies due to tides. procedure :: set_msys => util_set_msys !! Sets the value of msys from the masses of system bodies. procedure :: get_energy_and_momentum => util_get_energy_momentum_system !! Calculates the total system energy and momentum procedure :: rescale => util_rescale_system !! Rescales the system into a new set of units procedure :: validate_ids => util_valid_id_system !! Validate the numerical ids passed to the system and save the maximum value end type swiftest_nbody_system type :: swiftest_encounter integer ( I4B ) :: nenc !! Total number of encounters logical , dimension (:), allocatable :: lvdotr !! relative vdotr flag integer ( I4B ), dimension (:), allocatable :: status !! status of the interaction integer ( I4B ), dimension (:), allocatable :: index1 !! position of the first body in the encounter integer ( I4B ), dimension (:), allocatable :: index2 !! position of the second body in the encounter real ( DP ), dimension (:,:), allocatable :: x1 !! the position of body 1 in the encounter real ( DP ), dimension (:,:), allocatable :: x2 !! the position of body 2 in the encounter real ( DP ), dimension (:,:), allocatable :: v1 !! the velocity of body 1 in the encounter real ( DP ), dimension (:,:), allocatable :: v2 !! the velocity of body 2 in the encounter contains procedure :: setup => setup_encounter !! A constructor that sets the number of encounters and allocates and initializes all arrays procedure :: copy => util_copy_encounter !! Copies elements from the source encounter list into self. procedure :: spill => util_spill_encounter !! \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure :: resize => util_resize_encounter !! Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small. end type swiftest_encounter abstract interface subroutine abstract_discard_body ( self , system , param ) import swiftest_body , swiftest_nbody_system , swiftest_parameters class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine abstract_discard_body subroutine abstract_accel ( self , system , param , t , lbeg ) import swiftest_body , swiftest_nbody_system , swiftest_parameters , DP class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time logical , intent ( in ) :: lbeg !! Optional argument that determines whether or not this is the beginning or end of the step end subroutine abstract_accel subroutine abstract_initialize ( self , param ) import swiftest_base , swiftest_parameters class ( swiftest_base ), intent ( inout ) :: self !! Swiftest base object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine abstract_initialize subroutine abstract_kick_body ( self , system , param , t , dt , lbeg ) import swiftest_body , swiftest_nbody_system , swiftest_parameters , DP implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest generic body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system objec class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Logical flag indicating whether this is the beginning of the half step or not. end subroutine abstract_kick_body subroutine abstract_read_frame ( self , iu , param , form , ierr ) import DP , I4B , swiftest_base , swiftest_parameters class ( swiftest_base ), intent ( inout ) :: self !! Swiftest base object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters character ( * ), intent ( in ) :: form !! Input format code (\"XV\" or \"EL\") integer ( I4B ), intent ( out ) :: ierr !! Error code end subroutine abstract_read_frame subroutine abstract_set_mu ( self , cb ) import swiftest_body , swiftest_cb class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine abstract_set_mu subroutine abstract_step_body ( self , system , param , t , dt ) import DP , swiftest_body , swiftest_nbody_system , swiftest_parameters implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize end subroutine abstract_step_body subroutine abstract_step_system ( self , param , t , dt ) import DP , swiftest_nbody_system , swiftest_parameters implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize end subroutine abstract_step_system subroutine abstract_write_frame ( self , iu , param ) import DP , I4B , swiftest_base , swiftest_parameters class ( swiftest_base ), intent ( in ) :: self !! Swiftest base object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine abstract_write_frame end interface interface module subroutine discard_pl ( self , system , param ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameter end subroutine discard_pl module subroutine discard_system ( self , param ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine discard_system module subroutine discard_tp ( self , system , param ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine discard_tp module pure subroutine drift_all ( mu , x , v , n , param , dt , mask , iflag ) implicit none real ( DP ), dimension (:), intent ( in ) :: mu !! Vector of gravitational constants real ( DP ), dimension (:,:), intent ( inout ) :: x , v !! Position and velocity vectors integer ( I4B ), intent ( in ) :: n !! number of bodies class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize logical , dimension (:), intent ( in ) :: mask !! Logical mask of size self%nbody that determines which bodies to drift. integer ( I4B ), dimension (:), intent ( out ) :: iflag !! Vector of error flags. 0 means no problem end subroutine drift_all module subroutine drift_body ( self , system , param , dt ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize end subroutine drift_body module pure elemental subroutine drift_one ( mu , px , py , pz , vx , vy , vz , dt , iflag ) implicit none real ( DP ), intent ( in ) :: mu !! G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body to drift real ( DP ), intent ( inout ) :: px , py , pz , vx , vy , vz !! Position and velocity of body to drift real ( DP ), intent ( in ) :: dt !! Step size integer ( I4B ), intent ( out ) :: iflag !! iflag : error status flag for Danby drift (0 = OK, nonzero = ERROR) end subroutine drift_one module subroutine eucl_dist_index_plpl ( self ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object end subroutine module subroutine fragmentation_initialize ( system , param , family , x , v , L_spin , Ip , mass , radius , & nfrag , Ip_frag , m_frag , rad_frag , xb_frag , vb_frag , rot_frag , Qloss , lfailure ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters integer ( I4B ), dimension (:), intent ( in ) :: family !! Index of bodies involved in the collision real ( DP ), dimension (:,:), intent ( inout ) :: x , v , L_spin , Ip !! Two-body equivalent position, vector, spin momentum, and rotational inertia values for the collision real ( DP ), dimension (:), intent ( inout ) :: mass , radius !! Two-body equivalent mass and radii for the bodies in the collision integer ( I4B ), intent ( inout ) :: nfrag !! Number of fragments to generate real ( DP ), dimension (:), allocatable , intent ( inout ) :: m_frag , rad_frag !! Distribution of fragment mass and radii real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: Ip_frag !! Fragment rotational inertia vectors real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: xb_frag , vb_frag , rot_frag !! Fragment barycentric position, barycentric velocity, and rotation vectors real ( DP ), intent ( inout ) :: Qloss !! Energy lost during the collision logical , intent ( out ) :: lfailure !! Answers the question: Should this have been a merger instead? end subroutine fragmentation_initialize module subroutine fragmentation_regime ( Mcb , m1 , m2 , rad1 , rad2 , xh1 , xh2 , vb1 , vb2 , den1 , den2 , regime , Mlr , Mslr , mtiny , Qloss ) implicit none integer ( I4B ), intent ( out ) :: regime real ( DP ), intent ( out ) :: Mlr , Mslr real ( DP ), intent ( in ) :: Mcb , m1 , m2 , rad1 , rad2 , den1 , den2 , mtiny real ( DP ), dimension (:), intent ( in ) :: xh1 , xh2 , vb1 , vb2 real ( DP ), intent ( out ) :: Qloss !! Energy lost during the collision end subroutine fragmentation_regime module pure subroutine gr_kick_getaccb_ns_body ( self , system , param ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest generic body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine gr_kick_getaccb_ns_body module subroutine gr_kick_getacch ( mu , x , lmask , n , inv_c2 , agr ) implicit none real ( DP ), dimension (:), intent ( in ) :: mu !! Gravitational constant real ( DP ), dimension (:,:), intent ( in ) :: x !! Position vectors logical , dimension (:), intent ( in ) :: lmask !! Logical mask indicating which bodies to compute integer ( I4B ), intent ( in ) :: n !! Total number of bodies real ( DP ), intent ( in ) :: inv_c2 !! Inverse speed of light squared: 1 / c**2 real ( DP ), dimension (:,:), intent ( out ) :: agr !! Accelerations end subroutine gr_kick_getacch module pure subroutine gr_p4_pos_kick ( param , x , v , dt ) implicit none class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), dimension (:), intent ( inout ) :: x !! Position vector real ( DP ), dimension (:), intent ( in ) :: v !! Velocity vector real ( DP ), intent ( in ) :: dt !! Step size end subroutine gr_p4_pos_kick module pure subroutine gr_pseudovel2vel ( param , mu , xh , pv , vh ) implicit none class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: mu !! G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real ( DP ), dimension (:), intent ( in ) :: xh !! Heliocentric position vector real ( DP ), dimension (:), intent ( in ) :: pv !! Pseudovelocity velocity vector - see Saha & Tremain (1994), eq. (32) real ( DP ), dimension (:), intent ( out ) :: vh !! Heliocentric velocity vector end subroutine gr_pseudovel2vel module pure subroutine gr_pv2vh_body ( self , param ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine gr_pv2vh_body module pure subroutine gr_vel2pseudovel ( param , mu , xh , vh , pv ) implicit none class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: mu !! G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real ( DP ), dimension (:), intent ( in ) :: xh !! Heliocentric position vector real ( DP ), dimension (:), intent ( in ) :: vh !! Heliocentric velocity vector real ( DP ), dimension (:), intent ( out ) :: pv !! Pseudovelocity vector - see Saha & Tremain (1994), eq. (32) end subroutine gr_vel2pseudovel module pure subroutine gr_vh2pv_body ( self , param ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine gr_vh2pv_body module subroutine io_conservation_report ( self , param , lterminal ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Input colleciton of user-defined parameters logical , intent ( in ) :: lterminal !! Indicates whether to output information to the terminal screen end subroutine io_conservation_report module subroutine io_dump_param ( self , param_file_name ) implicit none class ( swiftest_parameters ), intent ( in ) :: self !! Output collection of parameters character ( len =* ), intent ( in ) :: param_file_name !! Parameter input file name (i.e. param.in) end subroutine io_dump_param module subroutine io_dump_swiftest ( self , param ) implicit none class ( swiftest_base ), intent ( inout ) :: self !! Swiftest base object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine io_dump_swiftest module subroutine io_dump_system ( self , param ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine io_dump_system module function io_get_args ( integrator , param_file_name ) result ( ierr ) implicit none integer ( I4B ) :: integrator !! Symbolic code of the requested integrator character ( len = :), allocatable :: param_file_name !! Name of the input parameters file integer ( I4B ) :: ierr !! I/O error code end function io_get_args module function io_get_token ( buffer , ifirst , ilast , ierr ) result ( token ) implicit none character ( len =* ), intent ( in ) :: buffer !! Input string buffer integer ( I4B ), intent ( inout ) :: ifirst !! Index of the buffer at which to start the search for a token integer ( I4B ), intent ( out ) :: ilast !! Index of the buffer at the end of the returned token integer ( I4B ), intent ( out ) :: ierr !! Error code character ( len = :), allocatable :: token !! Returned token string end function io_get_token module subroutine io_param_reader ( self , unit , iotype , v_list , iostat , iomsg ) implicit none class ( swiftest_parameters ), intent ( inout ) :: self !! Collection of parameters integer ( I4B ), intent ( in ) :: unit !! File unit number character ( len =* ), intent ( in ) :: iotype !! Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. !!    If you do not include a char-literal-constant, the iotype argument contains only DT. integer ( I4B ), intent ( in ) :: v_list (:) !! The first element passes the integrator code to the reader integer ( I4B ), intent ( out ) :: iostat !! IO status code character ( len =* ), intent ( inout ) :: iomsg !! Message to pass if iostat /= 0 end subroutine io_param_reader module subroutine io_param_writer ( self , unit , iotype , v_list , iostat , iomsg ) implicit none class ( swiftest_parameters ), intent ( in ) :: self !! Collection of parameters integer ( I4B ), intent ( in ) :: unit !! File unit number character ( len =* ), intent ( in ) :: iotype !! Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. !!    If you do not include a char-literal-constant, the iotype argument contains only DT. integer ( I4B ), intent ( in ) :: v_list (:) !! Not used in this procedure integer ( I4B ), intent ( out ) :: iostat !! IO status code character ( len =* ), intent ( inout ) :: iomsg !! Message to pass if iostat /= 0 end subroutine io_param_writer module subroutine io_read_body_in ( self , param ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine io_read_body_in module subroutine io_read_cb_in ( self , param ) implicit none class ( swiftest_cb ), intent ( inout ) :: self !! Swiftest central body object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine io_read_cb_in module subroutine io_read_param_in ( self , param_file_name ) implicit none class ( swiftest_parameters ), intent ( inout ) :: self !! Current run configuration parameters character ( len =* ), intent ( in ) :: param_file_name !! Parameter input file name (i.e. param.in) end subroutine io_read_param_in module subroutine io_read_frame_body ( self , iu , param , form , ierr ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters character ( * ), intent ( in ) :: form !! Input format code (\"XV\" or \"EL\") integer ( I4B ), intent ( out ) :: ierr !! Error code end subroutine io_read_frame_body module subroutine io_read_frame_cb ( self , iu , param , form , ierr ) implicit none class ( swiftest_cb ), intent ( inout ) :: self !! Swiftest central body object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters character ( * ), intent ( in ) :: form !! Input format code (\"XV\" or \"EL\") integer ( I4B ), intent ( out ) :: ierr !! Error code end subroutine io_read_frame_cb module subroutine io_read_frame_system ( self , iu , param , form , ierr ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters character ( * ), intent ( in ) :: form !! Input format code (\"XV\" or \"EL\") integer ( I4B ), intent ( out ) :: ierr !! Error code end subroutine io_read_frame_system module subroutine io_write_discard ( self , param ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine io_write_discard module subroutine io_toupper ( string ) implicit none character ( * ), intent ( inout ) :: string !! String to make upper case end subroutine io_toupper module subroutine io_write_encounter ( t , name1 , name2 , mass1 , mass2 , radius1 , radius2 , & xh1 , xh2 , vh1 , vh2 , enc_out , out_type ) implicit none integer ( I4B ), intent ( in ) :: name1 , name2 real ( DP ), intent ( in ) :: t , mass1 , mass2 , radius1 , radius2 real ( DP ), dimension (:), intent ( in ) :: xh1 , xh2 , vh1 , vh2 character ( * ), intent ( in ) :: enc_out , out_type end subroutine io_write_encounter module subroutine io_write_frame_body ( self , iu , param ) implicit none class ( swiftest_body ), intent ( in ) :: self !! Swiftest body object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine io_write_frame_body module subroutine io_write_frame_cb ( self , iu , param ) implicit none class ( swiftest_cb ), intent ( in ) :: self !! Swiftest central body object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine io_write_frame_cb module subroutine io_write_frame_system ( self , iu , param ) implicit none class ( swiftest_nbody_system ), intent ( in ) :: self !! Swiftest system object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine io_write_frame_system module pure subroutine kick_getacch_int_pl ( self ) implicit none class ( swiftest_pl ), intent ( inout ) :: self end subroutine kick_getacch_int_pl module pure subroutine kick_getacch_int_tp ( self , GMpl , xhp , npl ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle real ( DP ), dimension (:), intent ( in ) :: GMpl !! Massive body masses real ( DP ), dimension (:,:), intent ( in ) :: xhp !! Massive body position vectors integer ( I4B ), intent ( in ) :: npl !! Number of active massive bodies end subroutine kick_getacch_int_tp module subroutine obl_acc_body ( self , system ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object end subroutine obl_acc_body module subroutine obl_acc_pl ( self , system ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object end subroutine obl_acc_pl module subroutine obl_acc_tp ( self , system ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object end subroutine obl_acc_tp module subroutine obl_pot ( npl , Mcb , Mpl , j2rp2 , j4rp4 , xh , irh , oblpot ) implicit none integer ( I4B ), intent ( in ) :: npl real ( DP ), intent ( in ) :: Mcb real ( DP ), dimension (:), intent ( in ) :: Mpl real ( DP ), intent ( in ) :: j2rp2 , j4rp4 real ( DP ), dimension (:), intent ( in ) :: irh real ( DP ), dimension (:, :), intent ( in ) :: xh real ( DP ), intent ( out ) :: oblpot end subroutine obl_pot module subroutine orbel_el2xv_vec ( self , cb ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine orbel_el2xv_vec module pure subroutine orbel_scget ( angle , sx , cx ) implicit none real ( DP ), intent ( in ) :: angle real ( DP ), intent ( out ) :: sx , cx end subroutine orbel_scget module pure subroutine orbel_xv2aeq ( mu , x , v , a , e , q ) implicit none real ( DP ), intent ( in ) :: mu !! Gravitational constant real ( DP ), dimension (:), intent ( in ) :: x !! Position vector real ( DP ), dimension (:), intent ( in ) :: v !! Velocity vector real ( DP ), intent ( out ) :: a !! semimajor axis real ( DP ), intent ( out ) :: e !! eccentricity real ( DP ), intent ( out ) :: q !! periapsis end subroutine orbel_xv2aeq module pure subroutine orbel_xv2aqt ( mu , x , v , a , q , capm , tperi ) implicit none real ( DP ), intent ( in ) :: mu !! Gravitational constant real ( DP ), dimension (:), intent ( in ) :: x !! Position vector real ( DP ), dimension (:), intent ( in ) :: v !! Velocity vector real ( DP ), intent ( out ) :: a !! semimajor axis real ( DP ), intent ( out ) :: q !! periapsis real ( DP ), intent ( out ) :: capm !! mean anomaly real ( DP ), intent ( out ) :: tperi !! time of pericenter passage end subroutine orbel_xv2aqt module subroutine orbel_xv2el_vec ( self , cb ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine orbel_xv2el_vec module subroutine setup_body ( self , n , param ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine setup_body module subroutine setup_construct_system ( system , param ) implicit none class ( swiftest_nbody_system ), allocatable , intent ( inout ) :: system !! Swiftest system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine setup_construct_system module subroutine setup_encounter ( self , n ) implicit none class ( swiftest_encounter ), intent ( inout ) :: self !! Swiftest encounter structure integer ( I4B ), intent ( in ) :: n !! Number of encounters to allocate space for end subroutine setup_encounter module subroutine setup_initialize_system ( self , param ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine setup_initialize_system module subroutine setup_pl ( self , n , param ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine setup_pl module subroutine setup_tp ( self , n , param ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parametersr end subroutine setup_tp module subroutine tides_kick_getacch_pl ( self , system ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object end subroutine tides_kick_getacch_pl module subroutine tides_step_spin_system ( self , param , t , dt ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize end subroutine tides_step_spin_system module subroutine user_kick_getacch_body ( self , system , param , t , lbeg ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody_system_object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Optional argument that determines whether or not this is the beginning or end of the step end subroutine user_kick_getacch_body end interface interface util_append module subroutine util_append_arr_char_string ( arr , source , nold , nsrc , lsource_mask ) implicit none character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array character ( len = STRMAX ), dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine util_append_arr_char_string module subroutine util_append_arr_DP ( arr , source , nold , nsrc , lsource_mask ) implicit none real ( DP ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array real ( DP ), dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine util_append_arr_DP module subroutine util_append_arr_DPvec ( arr , source , nold , nsrc , lsource_mask ) implicit none real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: arr !! Destination array real ( DP ), dimension (:,:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine util_append_arr_DPvec module subroutine util_append_arr_I4B ( arr , source , nold , nsrc , lsource_mask ) implicit none integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array integer ( I4B ), dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine util_append_arr_I4B module subroutine util_append_arr_logical ( arr , source , nold , nsrc , lsource_mask ) implicit none logical , dimension (:), allocatable , intent ( inout ) :: arr !! Destination array logical , dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine util_append_arr_logical end interface interface module subroutine util_append_body ( self , source , lsource_mask ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine util_append_body module subroutine util_append_pl ( self , source , lsource_mask ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine util_append_pl module subroutine util_append_tp ( self , source , lsource_mask ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine util_append_tp module subroutine util_coord_b2h_pl ( self , cb ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine util_coord_b2h_pl module subroutine util_coord_b2h_tp ( self , cb ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_cb ), intent ( in ) :: cb !! Swiftest central body object end subroutine util_coord_b2h_tp module subroutine util_coord_h2b_pl ( self , cb ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine util_coord_h2b_pl module subroutine util_coord_h2b_tp ( self , cb ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_cb ), intent ( in ) :: cb !! Swiftest central body object end subroutine util_coord_h2b_tp module subroutine util_copy_encounter ( self , source ) implicit none class ( swiftest_encounter ), intent ( inout ) :: self !! Encounter list class ( swiftest_encounter ), intent ( in ) :: source !! Source object to copy into end subroutine util_copy_encounter module subroutine util_exit ( code ) implicit none integer ( I4B ), intent ( in ) :: code !! Failure exit code end subroutine util_exit module subroutine util_fill_body ( self , inserts , lfill_list ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_body ), intent ( in ) :: inserts !! Swiftest body object to be inserted logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine util_fill_body module subroutine util_fill_pl ( self , inserts , lfill_list ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_body ), intent ( in ) :: inserts !! Swiftest body object to be inserted logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine util_fill_pl module subroutine util_fill_tp ( self , inserts , lfill_list ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_body ), intent ( in ) :: inserts !! Swiftest body object to be inserted logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine util_fill_tp end interface interface util_fill module subroutine util_fill_arr_char_string ( keeps , inserts , lfill_list ) implicit none character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep character ( len = STRMAX ), dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine util_fill_arr_char_string module subroutine util_fill_arr_DP ( keeps , inserts , lfill_list ) implicit none real ( DP ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep real ( DP ), dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine util_fill_arr_DP module subroutine util_fill_arr_DPvec ( keeps , inserts , lfill_list ) implicit none real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: keeps !! Array of values to keep real ( DP ), dimension (:,:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine util_fill_arr_DPvec module subroutine util_fill_arr_I4B ( keeps , inserts , lfill_list ) implicit none integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep integer ( I4B ), dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine util_fill_arr_I4B module subroutine util_fill_arr_logical ( keeps , inserts , lfill_list ) implicit none logical , dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep logical , dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine util_fill_arr_logical end interface interface module subroutine util_rescale_system ( self , param , mscale , dscale , tscale ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters. Returns with new values of the scale vactors and GU real ( DP ), intent ( in ) :: mscale , dscale , tscale !! Scale factors for mass, distance, and time units, respectively. end subroutine util_rescale_system module function util_minimize_bfgs ( f , N , x0 , eps , lerr ) result ( x1 ) use lambda_function implicit none integer ( I4B ), intent ( in ) :: N class ( lambda_obj ), intent ( inout ) :: f real ( DP ), dimension (:), intent ( in ) :: x0 real ( DP ), intent ( in ) :: eps logical , intent ( out ) :: lerr real ( DP ), dimension (:), allocatable :: x1 end function util_minimize_bfgs module subroutine util_peri_tp ( self , system , param ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine util_peri_tp end interface interface util_resize module subroutine util_resize_arr_char_string ( arr , nnew ) implicit none character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size end subroutine util_resize_arr_char_string module subroutine util_resize_arr_DP ( arr , nnew ) implicit none real ( DP ), dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size end subroutine util_resize_arr_DP module subroutine util_resize_arr_DPvec ( arr , nnew ) implicit none real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size end subroutine util_resize_arr_DPvec module subroutine util_resize_arr_I4B ( arr , nnew ) implicit none integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size end subroutine util_resize_arr_I4B module subroutine util_resize_arr_logical ( arr , nnew ) implicit none logical , dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size end subroutine util_resize_arr_logical end interface interface module subroutine util_resize_body ( self , nnew ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object integer ( I4B ), intent ( in ) :: nnew !! New size neded end subroutine util_resize_body module subroutine util_resize_encounter ( self , nnew ) implicit none class ( swiftest_encounter ), intent ( inout ) :: self !! Swiftest encounter list integer ( I4B ), intent ( in ) :: nnew !! New size of list needed end subroutine util_resize_encounter module subroutine util_resize_pl ( self , nnew ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object integer ( I4B ), intent ( in ) :: nnew !! New size neded end subroutine util_resize_pl module subroutine util_resize_tp ( self , nnew ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object integer ( I4B ), intent ( in ) :: nnew !! New size neded end subroutine util_resize_tp module subroutine util_get_energy_momentum_system ( self , param ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine util_get_energy_momentum_system module subroutine util_set_beg_end_pl ( self , xbeg , xend , vbeg ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object real ( DP ), dimension (:,:), intent ( in ), optional :: xbeg !! Position vectors at beginning of step real ( DP ), dimension (:,:), intent ( in ), optional :: xend !! Positions vectors at end of step real ( DP ), dimension (:,:), intent ( in ), optional :: vbeg !! vbeg is an unused variable to keep this method forward compatible with RMVS end subroutine util_set_beg_end_pl module subroutine util_set_ir3h ( self ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object end subroutine util_set_ir3h module subroutine util_set_msys ( self ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object end subroutine util_set_msys module subroutine util_set_mu_pl ( self , cb ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine util_set_mu_pl module subroutine util_set_mu_tp ( self , cb ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine util_set_mu_tp module subroutine util_set_rhill ( self , cb ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine util_set_rhill module subroutine util_set_rhill_approximate ( self , cb ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine util_set_rhill_approximate end interface interface util_solve_linear_system module function util_solve_linear_system_d ( A , b , n , lerr ) result ( x ) implicit none integer ( I4B ), intent ( in ) :: n real ( DP ), dimension (:,:), intent ( in ) :: A real ( DP ), dimension (:), intent ( in ) :: b logical , intent ( out ) :: lerr real ( DP ), dimension ( n ) :: x end function util_solve_linear_system_d module function util_solve_linear_system_q ( A , b , n , lerr ) result ( x ) implicit none integer ( I4B ), intent ( in ) :: n real ( QP ), dimension (:,:), intent ( in ) :: A real ( QP ), dimension (:), intent ( in ) :: b logical , intent ( out ) :: lerr real ( QP ), dimension ( n ) :: x end function util_solve_linear_system_q end interface interface module function util_solve_rkf45 ( f , y0in , t1 , dt0 , tol ) result ( y1 ) use lambda_function implicit none class ( lambda_obj ), intent ( inout ) :: f !! lambda function object that has been initialized to be a function of derivatives. The object will return with components lastarg and lasteval set real ( DP ), dimension (:), intent ( in ) :: y0in !! Initial value at t=0 real ( DP ), intent ( in ) :: t1 !! Final time real ( DP ), intent ( in ) :: dt0 !! Initial step size guess real ( DP ), intent ( in ) :: tol !! Tolerance on solution real ( DP ), dimension (:), allocatable :: y1 !! Final result end function util_solve_rkf45 end interface interface util_sort module subroutine util_sort_i4b ( arr ) implicit none integer ( I4B ), dimension (:), intent ( inout ) :: arr end subroutine util_sort_i4b module subroutine util_sort_index_i4b ( arr , ind ) implicit none integer ( I4B ), dimension (:), intent ( in ) :: arr integer ( I4B ), dimension (:), intent ( out ) :: ind end subroutine util_sort_index_i4b module subroutine util_sort_sp ( arr ) implicit none real ( SP ), dimension (:), intent ( inout ) :: arr end subroutine util_sort_sp module subroutine util_sort_index_sp ( arr , ind ) implicit none real ( SP ), dimension (:), intent ( in ) :: arr integer ( I4B ), dimension (:), intent ( out ) :: ind end subroutine util_sort_index_sp module subroutine util_sort_dp ( arr ) implicit none real ( DP ), dimension (:), intent ( inout ) :: arr end subroutine util_sort_dp module subroutine util_sort_index_dp ( arr , ind ) implicit none real ( DP ), dimension (:), intent ( in ) :: arr integer ( I4B ), dimension (:), intent ( out ) :: ind end subroutine util_sort_index_dp end interface util_sort interface module subroutine util_sort_rearrange_body ( self , ind ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) end subroutine util_sort_rearrange_body module subroutine util_sort_rearrange_pl ( self , ind ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) end subroutine util_sort_rearrange_pl module subroutine util_sort_rearrange_tp ( self , ind ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) end subroutine util_sort_rearrange_tp module subroutine util_sort_body ( self , sortby , ascending ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order end subroutine util_sort_body module subroutine util_sort_pl ( self , sortby , ascending ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order end subroutine util_sort_pl module subroutine util_sort_tp ( self , sortby , ascending ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order end subroutine util_sort_tp end interface interface util_spill module subroutine util_spill_arr_char_string ( keeps , discards , lspill_list , ldestructive ) implicit none character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discardss logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine util_spill_arr_char_string module subroutine util_spill_arr_DP ( keeps , discards , lspill_list , ldestructive ) implicit none real ( DP ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep real ( DP ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine util_spill_arr_DP module subroutine util_spill_arr_DPvec ( keeps , discards , lspill_list , ldestructive ) implicit none real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: keeps !! Array of values to keep real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: discards !! Array discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine util_spill_arr_DPvec module subroutine util_spill_arr_I4B ( keeps , discards , lspill_list , ldestructive ) implicit none integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discardss logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine util_spill_arr_I4B module subroutine util_spill_arr_logical ( keeps , discards , lspill_list , ldestructive ) implicit none logical , dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep logical , dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discardss logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine util_spill_arr_logical end interface interface module subroutine util_spill_body ( self , discards , lspill_list , ldestructive ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine util_spill_body module subroutine util_spill_encounter ( self , discards , lspill_list , ldestructive ) implicit none class ( swiftest_encounter ), intent ( inout ) :: self !! Swiftest encounter list class ( swiftest_encounter ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter body by removing the discard list end subroutine util_spill_encounter module subroutine util_spill_pl ( self , discards , lspill_list , ldestructive ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine util_spill_pl module subroutine util_spill_tp ( self , discards , lspill_list , ldestructive ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine util_spill_tp module subroutine util_valid_id_system ( self , param ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine util_valid_id_system module subroutine util_version () implicit none end subroutine util_version end interface end module swiftest_classes","tags":"","loc":"sourcefile/swiftest_classes.f90.html"},{"title":"lambda_function.f90 – swiftest","text":"This file depends on sourcefile~~lambda_function.f90~~EfferentGraph sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~lambda_function.f90~~AfferentGraph sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90 orbel.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~util_resize.f90 util_resize.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~gr.f90 gr.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~util_coord.f90 util_coord.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~eucl.f90 eucl.f90 sourcefile~eucl.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~obl.f90 obl.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~helio_coord.f90 helio_coord.f90 sourcefile~helio_coord.f90->sourcefile~swiftest.f90 sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~drift.f90 drift.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~util_set.f90 util_set.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~setup.f90 setup.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~fragmentation.f90 fragmentation.f90 sourcefile~fragmentation.f90->sourcefile~swiftest.f90 sourcefile~util_solve.f90 util_solve.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~util_spill.f90 util_spill.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~symba_fragmentation.f90 symba_fragmentation.f90 sourcefile~symba_fragmentation.f90->sourcefile~swiftest.f90 sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~util_sort.f90 util_sort.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~util_fill.f90 util_fill.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~kick.f90 kick.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~util_copy.f90 util_copy.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~util_append.f90 util_append.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules lambda_function Source Code lambda_function.f90 Source Code module lambda_function !! author: David A. Minton !! !! Defines a class that can enable objects that behave like lambda functions. !! !! To use this class, define a type of either lambda_obj or lambda_obj_err, or extend the lambda_obj class as necessary, such that an interface that matches the function you wish to lambdafy. !! Once defined, the lambda object can evaluate itself by calling the type-bound procedure eval. e.g. f%eval(x) (or f%eval(x, lerr), f%eval(x, [argument list], etc)) !! !! ******************************************************************************************************************************************************************************************** !! Example - Defining a lambda function f(x,rval,ival) where rval and ival are a real and integer argument, respectively. This implementation uses an abstract interface, though this is not !! strictly necessary unless you want to bind more than one function with the same interface. !! ******************************************************************************************************************************************************************************************** !! !! module lambda_new !!    use swiftest ! This will bring in the lambda_function module !!    ! Define types in a module !! !!    type, extends(lambda_obj) :: lambda_obj_ri_args !!       procedure(abstract_lambda_ri_args), pointer, nopass :: lambdaptr_ri_args => null() !!       real(DP)                                            :: rval     !! Real parameter !!       integer(I4B)                                        :: ival     !! Integer paramete !!    contains !!       generic           :: init => lambda_ri_args_init !!       procedure         :: eval => lambda_ri_args_eval !!       procedure, nopass :: lambda_ri_args_init !!       final             :: lambda_ri_args_destroy !!    end type !!    interface lambda_obj !!       module procedure lambda_ri_args_init !!    end interface !! !!    abstract interface !!       function abstract_lambda_ri_args(x, rval, ival) result(y) !!          !Template for the lambda function !!          import DP, I4B !!          real(DP), dimension(:), intent(in) :: x        !! Dependent variable !!          real(DP),               intent(in) :: rval     !! Real parameter !!          integer(I4B),           intent(in) :: ival     !! Integer parameter !!          real(DP)                           :: y        !! Real result !!       end function !!    end interface !! !! contains !!    type(lambda_obj_ri_args) function lambda_ri_args_init(lambda, rval, ival) !!       !! Initializes the lambda function parameters (can be used as a structure constructor) !!       implicit none !!       procedure(abstract_lambda_ri_args)  :: lambda !! The lambda function that will be passed !!       real(DP),     intent(in)            :: rval     !! Real parameter !!       integer(I4B), intent(in)            :: ival     !! Integer parameter !! !!       ! Assign the procedure passed to this function to the procedure pointer !!       lambda_ri_args_init%lambdaptr_ri_args => lambda !! !!       ! Assign the argument values !!       lambda_ri_args_init%rval = rval !!       lambda_ri_args_init%ival = ival !!       return !!    end function lambda_ri_args_init !! !!    function lambda_ri_args_eval(self, x) result(y) !!       !! Defines the evaluation method, allowing the lambda function to be called with a single argument !!       implicit none !!       class(lambda_obj_ri_args),      intent(inout) :: self !!       real(DP), dimension(:),         intent(in) :: x !!       real(DP)                                   :: y !! !!      if (associated(self%lambdaptr_ri_args)) then !!         y = self%lambdaptr_ri_args(x, self%rval, self%ival) !!          self%lastval = y !!          if (allocated(self%lastarg)) deallocate(self%lastarg) !!          allocate(self%lastarg, source=x) !!       else !!          error stop \"Lambda function was not initialized\" !!       end if !!    end function lambda_ri_args_eval !! !!    subroutine lambda_ri_args_destroy(self) !!       !! Finalizer method. Use this as a template for cleaning up the object upon destruction, such as nullifying pointers !!       implicit none !!       type(lambda_obj_ri_args) :: self !!       if (associated(self%lambdaptr_ri_args)) nullify(self%lambdaptr_ri_args) !!    end subroutine lambda_ri_args_destroy !! !!    function example_function(x, rval, ival) result(y) !!       !This is the actual function you are going to use as the lambda function. Its interface must match the abstract interface previously defined !!       implicit none !!       ! Arguments !!       real(DP), dimension(:), intent(in) :: x !!       real(DP),               intent(in) :: rval !!       integer(I4B),           intent(in) :: ival !!       ! Result !!       real(DP)                           :: y !!       ! Internals !!       integer(I4B) :: i, n !!       n = size(x) !!       y = 42._DP * ival !!       do i = 1, n !!          y = y + x(i)**2 !!       end do !!       return !!    end function example_function !! end module lambda_new !! !! program usage !!    use swiftest !!    use lambda_new !!    implicit none !!    type(lambda_obj_ri_args) :: f !!    real(DP) :: sigma_par !!    integer(I4B) :: iwonky, i,j !!    real(DP), dimension(12) :: xarr !! !!    sigma_par = 3.14_DP !!    iwonky = 13 !! !!    f = lambda_obj(example_function, sigma_par, iwonky) !!    do i = 1, 10 !!       xarr(:) = [(j * 0.25_DP / i, j=1, 12)] !!       write(*,*) i,f%eval(xarr) !!    end do !! end program usage !! ******************************************************************************************************************************************************************************************** use swiftest_globals implicit none public type :: lambda_obj !! Base class for an lambda function object. This object takes no additional arguments other than the dependent variable x, an array of real numbers procedure ( lambda0 ), pointer , nopass :: lambdaptr => null () real ( DP ) :: lastval real ( DP ), dimension (:), allocatable :: lastarg contains generic :: init => lambda_init_0 procedure :: eval => lambda_eval_0 procedure , nopass :: lambda_init_0 final :: lambda_destroy end type type , extends ( lambda_obj ) :: lambda_obj_err !! Extended class for an lambda function object. This object takes allows for the return of a logical error flag during evaluation of the function. procedure ( lambda0err ), pointer , nopass :: lambdaptr_err => null () logical :: lerr contains generic :: init => lambda_init_0_err procedure :: eval => lambda_eval_0_err procedure , nopass :: lambda_init_0_err end type type , extends ( lambda_obj ) :: lambda_obj_tvar !! Base class for an lambda function object. This object takes no additional arguments other than the dependent variable x, an array of real numbers procedure ( lambda0tvar ), pointer , nopass :: lambdaptr_tvar => null () contains generic :: init => lambda_init_tvar procedure :: evalt => lambda_eval_tvar procedure , nopass :: lambda_init_tvar end type interface lambda_obj module procedure lambda_init_0 module procedure lambda_init_0_err module procedure lambda_init_tvar end interface abstract interface function lambda0 ( x ) result ( y ) ! Template for a 0 argument function import DP real ( DP ), dimension (:), intent ( in ) :: x real ( DP ) :: y end function function lambda0err ( x , lerr ) result ( y ) ! Template for a 0 argument function that returns an error value import DP real ( DP ), dimension (:), intent ( in ) :: x logical , intent ( out ) :: lerr real ( DP ) :: y end function function lambda0tvar ( x , t ) result ( y ) ! Template for a 0 argument function that returns an error value import DP real ( DP ), dimension (:), intent ( in ) :: x real ( DP ), intent ( in ) :: t real ( DP ), dimension (:), allocatable :: y end function end interface contains type ( lambda_obj ) function lambda_init_0 ( lambda ) implicit none ! Arguments procedure ( lambda0 ) :: lambda lambda_init_0 % lambdaptr => lambda return end function lambda_init_0 type ( lambda_obj_err ) function lambda_init_0_err ( lambda , lerr ) implicit none ! Arguments procedure ( lambda0err ) :: lambda logical , intent ( in ) :: lerr lambda_init_0_err % lambdaptr_err => lambda lambda_init_0_err % lerr = lerr return end function lambda_init_0_err type ( lambda_obj_tvar ) function lambda_init_tvar ( lambda , t ) implicit none ! Arguments procedure ( lambda0tvar ) :: lambda real ( DP ), intent ( in ) :: t lambda_init_tvar % lambdaptr_tvar => lambda return end function lambda_init_tvar function lambda_eval_0 ( self , x ) result ( y ) implicit none ! Arguments class ( lambda_obj ), intent ( inout ) :: self real ( DP ), dimension (:), intent ( in ) :: x ! Result real ( DP ) :: y if ( associated ( self % lambdaptr )) then y = self % lambdaptr ( x ) self % lastval = y if ( allocated ( self % lastarg )) deallocate ( self % lastarg ) allocate ( self % lastarg , source = x ) else error stop \"Lambda function was not initialized\" end if end function lambda_eval_0 function lambda_eval_0_err ( self , x ) result ( y ) implicit none ! Arguments class ( lambda_obj_err ), intent ( inout ) :: self real ( DP ), dimension (:), intent ( in ) :: x ! Result real ( DP ) :: y if ( associated ( self % lambdaptr_err )) then y = self % lambdaptr_err ( x , self % lerr ) self % lastval = y if ( allocated ( self % lastarg )) deallocate ( self % lastarg ) allocate ( self % lastarg , source = x ) else error stop \"Lambda function was not initialized\" end if end function lambda_eval_0_err function lambda_eval_tvar ( self , x , t ) result ( y ) implicit none ! Arguments class ( lambda_obj_tvar ), intent ( inout ) :: self real ( DP ), dimension (:), intent ( in ) :: x real ( DP ), intent ( in ) :: t ! Result real ( DP ), dimension (:), allocatable :: y if ( associated ( self % lambdaptr_tvar )) then y = self % lambdaptr_tvar ( x , t ) else error stop \"Lambda function was not initialized\" end if end function lambda_eval_tvar subroutine lambda_destroy ( self ) implicit none type ( lambda_obj ) :: self if ( associated ( self % lambdaptr )) nullify ( self % lambdaptr ) end subroutine lambda_destroy end module lambda_function","tags":"","loc":"sourcefile/lambda_function.f90.html"},{"title":"fragmentation.f90 – swiftest","text":"This file depends on sourcefile~~fragmentation.f90~~EfferentGraph sourcefile~fragmentation.f90 fragmentation.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~fragmentation.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~fragmentation.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_fragmentation Source Code fragmentation.f90 Source Code submodule ( swiftest_classes ) s_fragmentation use swiftest contains module subroutine fragmentation_initialize ( system , param , family , x , v , L_spin , Ip , mass , radius , & nfrag , Ip_frag , m_frag , rad_frag , xb_frag , vb_frag , rot_frag , Qloss , lfailure ) !! Author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Initialize the position and velocity of fragments to conserve energy and momentum. use , intrinsic :: ieee_exceptions implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters integer ( I4B ), dimension (:), intent ( in ) :: family !! Index of bodies involved in the collision real ( DP ), dimension (:,:), intent ( inout ) :: x , v , L_spin , Ip !! Two-body equivalent position, vector, spin momentum, and rotational inertia values for the collision real ( DP ), dimension (:), intent ( inout ) :: mass , radius !! Two-body equivalent mass and radii for the bodies in the collision integer ( I4B ), intent ( inout ) :: nfrag !! Number of fragments to generate real ( DP ), dimension (:), allocatable , intent ( inout ) :: m_frag , rad_frag !! Distribution of fragment mass and radii real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: Ip_frag !! Fragment rotational inertia vectors real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: xb_frag , vb_frag , rot_frag !! Fragment barycentric position, barycentric velocity, and rotation vectors real ( DP ), intent ( inout ) :: Qloss !! Energy lost during the collision logical , intent ( out ) :: lfailure !! Answers the question: Should this have been a merger instead? ! Internals real ( DP ) :: mscale , dscale , vscale , tscale , Lscale , Escale ! Scale factors that reduce quantities to O(~1) in the collisional system real ( DP ) :: mtot real ( DP ), dimension ( NDIM ) :: xcom , vcom integer ( I4B ) :: ii , npl_new logical , dimension (:), allocatable :: lexclude real ( DP ), dimension ( NDIM , 2 ) :: rot , L_orb real ( DP ), dimension (:,:), allocatable :: x_frag , v_frag , v_r_unit , v_t_unit , v_h_unit real ( DP ), dimension (:), allocatable :: rmag , rotmag , v_r_mag , v_t_mag real ( DP ), dimension ( NDIM ) :: Ltot_before real ( DP ), dimension ( NDIM ) :: Ltot_after real ( DP ) :: Etot_before , ke_orbit_before , ke_spin_before , pe_before , Lmag_before real ( DP ) :: Etot_after , ke_orbit_after , ke_spin_after , pe_after , Lmag_after , dEtot , dLmag real ( DP ), dimension ( NDIM ) :: L_frag_tot , L_frag_orb real ( DP ) :: ke_frag_budget , ke_frag_orbit , ke_radial , ke_frag_spin , ke_avg_deficit , ke_avg_deficit_old real ( DP ), dimension ( NDIM ) :: x_col_unit , y_col_unit , z_col_unit character ( len =* ), parameter :: fmtlabel = \"(A14,10(ES11.4,1X,:))\" integer ( I4B ) :: try , subtry integer ( I4B ), parameter :: NFRAG_MIN = 7 !! The minimum allowable number of fragments (set to 6 because that's how many unknowns are needed in the tangential velocity calculation) real ( DP ) :: r_max_start , r_max_start_old , r_max , f_spin real ( DP ), parameter :: Ltol = 10 * epsilon ( 1.0_DP ) real ( DP ), parameter :: Etol = 1e-9_DP integer ( I4B ), parameter :: MAXTRY = 3000 integer ( I4B ), parameter :: TANTRY = 3 logical , dimension ( size ( IEEE_ALL )) :: fpe_halting_modes , fpe_quiet_modes class ( swiftest_nbody_system ), allocatable :: tmpsys class ( swiftest_parameters ), allocatable :: tmpparam if ( nfrag < NFRAG_MIN ) then write ( * , * ) \"symba_frag_pos needs at least \" , NFRAG_MIN , \" fragments, but only \" , nfrag , \" were given.\" lfailure = . true . return end if call ieee_get_halting_mode ( IEEE_ALL , fpe_halting_modes ) ! Save the current halting modes so we can turn them off temporarily fpe_quiet_modes (:) = . false . call ieee_set_halting_mode ( IEEE_ALL , fpe_quiet_modes ) f_spin = 0.05_DP allocate ( x_frag , source = xb_frag ) allocate ( v_frag , source = vb_frag ) associate ( pl => system % pl , npl => system % pl % nbody ) npl_new = npl + nfrag allocate ( lexclude ( npl_new )) lexclude ( 1 : npl ) = pl % status ( 1 : npl ) == INACTIVE lexclude ( npl + 1 : npl_new ) = . true . end associate call set_scale_factors () call define_coordinate_system () call construct_temporary_system () ! Calculate the initial energy of the system without the collisional family call calculate_system_energy ( linclude_fragments = . false .) r_max_start = norm2 ( x (:, 2 ) - x (:, 1 )) try = 1 lfailure = . false . ke_avg_deficit = 0.0_DP do while ( try < MAXTRY ) lfailure = . false . ke_avg_deficit_old = ke_avg_deficit ke_avg_deficit = 0.0_DP subtry = 1 do ! Initialize the fragments with 0 velocity and spin so we can divide up the balance between the tangential, radial, and spin components while conserving momentum xb_frag (:,:) = 0.0_DP vb_frag (:,:) = 0.0_DP rot_frag (:,:) = 0.0_DP v_t_mag (:) = 0.0_DP v_r_mag (:) = 0.0_DP call set_fragment_position_vectors () call calculate_system_energy ( linclude_fragments = . true .) ke_frag_budget = - dEtot - Qloss call set_fragment_tan_vel ( lfailure ) ke_avg_deficit = ke_avg_deficit - ke_radial subtry = subtry + 1 if (. not . lfailure . or . subtry == TANTRY ) exit !write(*,*) 'Trying new arrangement' end do ke_avg_deficit = ke_avg_deficit / subtry !if (lfailure) write(*,*) 'Failed to find tangential velocities' if (. not . lfailure ) then call calculate_system_energy ( linclude_fragments = . true .) ke_radial = - dEtot - Qloss call set_fragment_radial_velocities ( lfailure ) !   if (lfailure) write(*,*) 'Failed to find radial velocities' if (. not . lfailure ) then call calculate_system_energy ( linclude_fragments = . true .) ! write(*,*) 'Qloss : ',Qloss ! write(*,*) '-dEtot: ',-dEtot ! write(*,*) 'delta : ',abs((dEtot + Qloss)) if (( abs ( dEtot + Qloss ) > Etol ) . or . ( dEtot > 0.0_DP )) then !write(*,*) 'Failed due to high energy error: ',dEtot, abs(dEtot + Qloss) / Etol lfailure = . true . else if ( abs ( dLmag ) / Lmag_before > Ltol ) then !write(*,*) 'Failed due to high angular momentum error: ', dLmag / Lmag_before lfailure = . true . end if end if end if if (. not . lfailure ) exit call restructure_failed_fragments () try = try + 1 end do call restore_scale_factors () call calculate_system_energy ( linclude_fragments = . true .) ! write(*,        \"(' -------------------------------------------------------------------------------------')\") ! write(*,        \"('  Final diagnostic')\") ! write(*,        \"(' -------------------------------------------------------------------------------------')\") ! if (lfailure) then !    write(*,*) \"symba_frag_pos failed after: \",try,\" tries\" !    do ii = 1, nfrag !       vb_frag(:, ii) = vcom(:) !    end do ! else !    write(*,*) \"symba_frag_pos succeeded after: \",try,\" tries\" !    write(*,        \"(' dL_tot should be very small' )\") !    write(*,fmtlabel) ' dL_tot      |', dLmag / Lmag_before !    write(*,        \"(' dE_tot should be negative and equal to Qloss' )\") !    write(*,fmtlabel) ' dE_tot      |', dEtot / abs(Etot_before) !    write(*,fmtlabel) ' Qloss       |', -Qloss / abs(Etot_before) !    write(*,fmtlabel) ' dE - Qloss  |', (Etot_after - Etot_before + Qloss) / abs(Etot_before) ! end if ! write(*,        \"(' -------------------------------------------------------------------------------------')\") call ieee_set_halting_mode ( IEEE_ALL , fpe_halting_modes ) ! Save the current halting modes so we can turn them off temporarily return contains ! Because of the complexity of this procedure, we have chosen to break it up into a series of nested subroutines. subroutine set_scale_factors () !! author: David A. Minton !! !! Scales dimenional quantities to ~O(1) with respect to the collisional system. This scaling makes it easier for the non-linear minimization !! to converge on a solution implicit none integer ( I4B ) :: i ! Find the center of mass of the collisional system mtot = sum ( mass (:)) xcom (:) = ( mass ( 1 ) * x (:, 1 ) + mass ( 2 ) * x (:, 2 )) / mtot vcom (:) = ( mass ( 1 ) * v (:, 1 ) + mass ( 2 ) * v (:, 2 )) / mtot ! Set scale factors dscale = sum ( radius (:)) mscale = mtot vscale = ( mass ( 1 ) * norm2 ( v (:, 1 ) - vcom (:)) + mass ( 2 ) * norm2 ( v (:, 2 ) - vcom (:))) / mtot tscale = dscale / vscale Lscale = mscale * dscale * vscale Escale = mscale * vscale ** 2 xcom (:) = xcom (:) / dscale vcom (:) = vcom (:) / vscale mtot = mtot / mscale mass = mass / mscale radius = radius / dscale x = x / dscale v = v / vscale L_spin = L_spin / Lscale do i = 1 , 2 rot (:, i ) = L_spin (:, i ) / ( mass ( i ) * radius ( i ) ** 2 * Ip ( 3 , i )) end do m_frag = m_frag / mscale rad_frag = rad_frag / dscale Qloss = Qloss / Escale return end subroutine set_scale_factors subroutine restore_scale_factors () !! author: David A. Minton !! !! Restores dimenional quantities back to the system units implicit none integer ( I4B ) :: i call ieee_set_halting_mode ( IEEE_ALL ,. false .) ! Restore scale factors xcom (:) = xcom (:) * dscale vcom (:) = vcom (:) * vscale mtot = mtot * mscale mass = mass * mscale radius = radius * dscale x = x * dscale v = v * vscale L_spin = L_spin * Lscale do i = 1 , 2 rot (:, i ) = L_spin (:, i ) * ( mass ( i ) * radius ( i ) ** 2 * Ip ( 3 , i )) end do m_frag = m_frag * mscale rad_frag = rad_frag * dscale rot_frag = rot_frag / tscale x_frag = x_frag * dscale v_frag = v_frag * vscale Qloss = Qloss * Escale do i = 1 , nfrag xb_frag (:, i ) = x_frag (:, i ) + xcom (:) vb_frag (:, i ) = v_frag (:, i ) + vcom (:) end do Etot_before = Etot_before * Escale pe_before = pe_before * Escale ke_spin_before = ke_spin_before * Escale ke_orbit_before = ke_orbit_before * Escale Ltot_before = Ltot_before * Lscale Lmag_before = Lmag_before * Lscale Etot_after = Etot_after * Escale pe_after = pe_after * Escale ke_spin_after = ke_spin_after * Escale ke_orbit_after = ke_orbit_after * Escale Ltot_after = Ltot_after * Lscale Lmag_after = Lmag_after * Lscale dLmag = norm2 ( Ltot_after (:) - Ltot_before (:)) dEtot = Etot_after - Etot_before call tmpsys % rescale ( tmpparam , mscale ** ( - 1 ), dscale ** ( - 1 ), tscale ** ( - 1 )) mscale = 1.0_DP dscale = 1.0_DP vscale = 1.0_DP tscale = 1.0_DP Lscale = 1.0_DP Escale = 1.0_DP return end subroutine restore_scale_factors subroutine define_coordinate_system () !! author: David A. Minton !! !! Defines the collisional coordinate system, including the unit vectors of both the system and individual fragments. implicit none integer ( I4B ) :: i real ( DP ), dimension ( NDIM ) :: x_cross_v , xc , vc , delta_r , delta_v real ( DP ) :: r_col_norm , v_col_norm allocate ( rmag ( nfrag )) allocate ( rotmag ( nfrag )) allocate ( v_r_mag ( nfrag )) allocate ( v_t_mag ( nfrag )) allocate ( v_r_unit ( NDIM , nfrag )) allocate ( v_t_unit ( NDIM , nfrag )) allocate ( v_h_unit ( NDIM , nfrag )) rmag (:) = 0.0_DP rotmag (:) = 0.0_DP v_r_mag (:) = 0.0_DP v_t_mag (:) = 0.0_DP v_r_unit (:,:) = 0.0_DP v_t_unit (:,:) = 0.0_DP v_h_unit (:,:) = 0.0_DP L_orb (:, :) = 0.0_DP ! Compute orbital angular momentum of pre-impact system do i = 1 , 2 xc (:) = x (:, i ) - xcom (:) vc (:) = v (:, i ) - vcom (:) x_cross_v (:) = xc (:) . cross . vc (:) L_orb (:, i ) = mass ( i ) * x_cross_v (:) end do ! Compute orbital angular momentum of pre-impact system. This will be the normal vector to the collision fragment plane L_frag_tot (:) = L_spin (:, 1 ) + L_spin (:, 2 ) + L_orb (:, 1 ) + L_orb (:, 2 ) delta_v (:) = v (:, 2 ) - v (:, 1 ) v_col_norm = norm2 ( delta_v (:)) delta_r (:) = x (:, 2 ) - x (:, 1 ) r_col_norm = norm2 ( delta_r (:)) ! We will initialize fragments on a plane defined by the pre-impact system, with the z-axis aligned with the angular momentum vector ! and the y-axis aligned with the pre-impact distance vector. y_col_unit (:) = delta_r (:) / r_col_norm z_col_unit (:) = L_frag_tot (:) / norm2 ( L_frag_tot ) ! The cross product of the y- by z-axis will give us the x-axis x_col_unit (:) = y_col_unit (:) . cross . z_col_unit (:) return end subroutine define_coordinate_system subroutine construct_temporary_system () !! Author: David A. Minton !! !! Constructs a temporary internal system consisting of active bodies and additional fragments. This internal temporary system is used to calculate system energy with and without fragments !! and optionally including fragments. implicit none ! Internals logical , dimension (:), allocatable :: lexclude_tmp associate ( pl => system % pl , npl => system % pl % nbody , cb => system % cb ) if ( size ( lexclude ) /= npl + nfrag ) then allocate ( lexclude_tmp ( npl_new )) lexclude_tmp ( 1 : npl ) = lexclude ( 1 : npl ) call move_alloc ( lexclude_tmp , lexclude ) end if where ( pl % status ( 1 : npl ) == INACTIVE ) ! Safety check in case one of the included bodies has been previously deactivated lexclude ( 1 : npl ) = . true . elsewhere lexclude ( 1 : npl ) = . false . end where lexclude ( npl + 1 : npl_new ) = . true . if ( allocated ( tmpparam )) deallocate ( tmpparam ) allocate ( tmpparam , source = param ) call setup_construct_system ( tmpsys , param ) call tmpsys % tp % setup ( 0 , param ) deallocate ( tmpsys % cb ) allocate ( tmpsys % cb , source = cb ) call tmpsys % pl % setup ( npl + nfrag , tmpparam ) call tmpsys % pl % fill ( pl , . not . lexclude ) call tmpsys % rescale ( tmpparam , mscale , dscale , tscale ) end associate return end subroutine construct_temporary_system subroutine add_fragments_to_tmpsys () !! Author: David A. Minton !! !! Adds fragments to the temporary system pl object implicit none ! Internals integer ( I4B ) :: i associate ( pl => system % pl , npl => system % pl % nbody ) tmpsys % pl % mass ( npl + 1 : npl_new ) = m_frag ( 1 : nfrag ) tmpsys % pl % Gmass ( npl + 1 : npl_new ) = m_frag ( 1 : nfrag ) * tmpparam % GU tmpsys % pl % radius ( npl + 1 : npl_new ) = rad_frag ( 1 : nfrag ) do concurrent ( i = 1 : nfrag ) tmpsys % pl % xb (:, npl + i ) = xb_frag (:, i ) tmpsys % pl % vb (:, npl + i ) = vb_frag (:, i ) tmpsys % pl % xh (:, npl + i ) = xb_frag (:, i ) - tmpsys % cb % xb (:) tmpsys % pl % vh (:, npl + i ) = vb_frag (:, i ) - tmpsys % cb % vb (:) end do if ( tmpparam % lrotation ) then tmpsys % pl % Ip (:, npl + 1 : npl_new ) = Ip_frag (:, 1 : nfrag ) tmpsys % pl % rot (:, npl + 1 : npl_new ) = rot_frag (:, 1 : nfrag ) end if ! Disable the collisional family for subsequent energy calculations and coordinate shifts lexclude ( family (:)) = . true . lexclude ( npl + 1 : npl_new ) = . false . where ( lexclude (:)) tmpsys % pl % status (:) = INACTIVE elsewhere tmpsys % pl % status (:) = ACTIVE end where end associate return end subroutine add_fragments_to_tmpsys subroutine calculate_system_energy ( linclude_fragments ) !! Author: David A. Minton !! !! Calculates total system energy, including all bodies in the pl list that do not have a corresponding value of the lexclude array that is true !! and optionally including fragments. implicit none ! Arguments logical , intent ( in ) :: linclude_fragments ! Internals integer ( I4B ) :: i , nplm logical , dimension (:), allocatable :: lexclude_tmp logical :: lk_plpl ! Because we're making a copy of symba_pl with the excludes/fragments appended, we need to deallocate the ! big k_plpl array and recreate it when we're done, otherwise we run the risk of blowing up the memory by ! allocating two of these ginormous arrays simulteouously. This is not particularly efficient, but as this ! subroutine should be called relatively infrequently, it shouldn't matter too much. ! Build the internal planet list out of the non-excluded bodies and optionally with fragments appended. This ! will get passed to the energy calculation subroutine so that energy is computed exactly the same way is it ! is in the main program. This will temporarily expand the planet list in a temporary system object called tmpsys to feed it into symba_energy associate ( pl => system % pl , npl => system % pl % nbody , cb => system % cb ) where ( lexclude ( 1 : npl_new )) tmpsys % pl % status ( 1 : npl_new ) = INACTIVE elsewhere tmpsys % pl % status ( 1 : npl_new ) = ACTIVE end where select type ( plwksp => tmpsys % pl ) class is ( symba_pl ) select type ( param ) class is ( symba_parameters ) plwksp % nplm = count ( plwksp % Gmass > param % Gmtiny / mscale ) end select end select lk_plpl = allocated ( pl % k_plpl ) if ( lk_plpl ) deallocate ( pl % k_plpl ) call tmpsys % pl % eucl_index () call tmpsys % get_energy_and_momentum ( param ) ! Restore the big array deallocate ( tmpsys % pl % k_plpl ) select type ( pl ) class is ( symba_pl ) select type ( param ) class is ( symba_parameters ) pl % nplm = count ( pl % Gmass > param % Gmtiny ) end select end select if ( lk_plpl ) call pl % eucl_index () ! Calculate the current fragment energy and momentum balances if ( linclude_fragments ) then Ltot_after (:) = tmpsys % Lorbit (:) + tmpsys % Lspin (:) Lmag_after = norm2 ( Ltot_after (:)) ke_orbit_after = tmpsys % ke_orbit ke_spin_after = tmpsys % ke_spin pe_after = tmpsys % pe Etot_after = ke_orbit_after + ke_spin_after + pe_after dEtot = Etot_after - Etot_before dLmag = norm2 ( Ltot_after (:) - Ltot_before (:)) else Ltot_before (:) = tmpsys % Lorbit (:) + tmpsys % Lspin (:) Lmag_before = norm2 ( Ltot_before (:)) ke_orbit_before = tmpsys % ke_orbit ke_spin_before = tmpsys % ke_spin pe_before = tmpsys % pe Etot_before = ke_orbit_before + ke_spin_before + pe_before end if end associate return end subroutine calculate_system_energy subroutine shift_vector_to_origin ( m_frag , vec_frag ) !! Author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Adjusts the position or velocity of the fragments as needed to align them with the origin implicit none ! Arguments real ( DP ), dimension (:), intent ( in ) :: m_frag !! Fragment masses real ( DP ), dimension (:,:), intent ( inout ) :: vec_frag !! Fragment positions or velocities in the center of mass frame ! Internals real ( DP ), dimension ( NDIM ) :: mvec_frag , COM_offset integer ( I4B ) :: i mvec_frag (:) = 0.0_DP do i = 1 , nfrag mvec_frag = mvec_frag (:) + vec_frag (:, i ) * m_frag ( i ) end do COM_offset (:) = - mvec_frag (:) / mtot do i = 1 , nfrag vec_frag (:, i ) = vec_frag (:, i ) + COM_offset (:) end do return end subroutine shift_vector_to_origin subroutine set_fragment_position_vectors () !! Author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Initializes the orbits of the fragments around the center of mass. The fragments are initially placed on a plane defined by the !! pre-impact angular momentum. They are distributed on an ellipse surrounding the center of mass. !! The initial positions do not conserve energy or momentum, so these need to be adjusted later. implicit none real ( DP ) :: dis , rad real ( DP ), dimension ( NDIM ) :: L_sigma logical , dimension (:), allocatable :: loverlap integer ( I4B ) :: i , j allocate ( loverlap ( nfrag )) ! Place the fragments into a region that is big enough that we should usually not have overlapping bodies ! An overlapping bodies will collide in the next time step, so it's not a major problem if they do (it just slows the run down) r_max = r_max_start rad = sum ( radius (:)) ! We will treat the first two fragments of the list as special cases. They get initialized the maximum distances apart along the original impactor distance vector. ! This is done because in a regular disruption, the first body is the largest, the second the second largest, and the rest are smaller equal-mass fragments. call random_number ( x_frag (:, 3 : nfrag )) loverlap (:) = . true . do while ( any ( loverlap ( 3 : nfrag ))) x_frag (:, 1 ) = x (:, 1 ) - xcom (:) x_frag (:, 2 ) = x (:, 2 ) - xcom (:) r_max = r_max + 0.1_DP * rad do i = 3 , nfrag if ( loverlap ( i )) then call random_number ( x_frag (:, i )) x_frag (:, i ) = 2 * ( x_frag (:, i ) - 0.5_DP ) * r_max end if end do loverlap (:) = . false . do j = 1 , nfrag do i = j + 1 , nfrag dis = norm2 ( x_frag (:, j ) - x_frag (:, i )) loverlap ( i ) = loverlap ( i ) . or . ( dis <= ( rad_frag ( i ) + rad_frag ( j ))) end do end do end do call shift_vector_to_origin ( m_frag , x_frag ) do i = 1 , nfrag rmag ( i ) = norm2 ( x_frag (:, i )) v_r_unit (:, i ) = x_frag (:, i ) / rmag ( i ) call random_number ( L_sigma (:)) ! Randomize the tangential velocity direction. This helps to ensure that the tangential velocity doesn't completely line up with the angular momentum vector, ! otherwise we can get an ill-conditioned system v_h_unit (:, i ) = z_col_unit (:) + 2e-1_DP * ( L_sigma (:) - 0.5_DP ) v_h_unit (:, i ) = v_h_unit (:, i ) / norm2 ( v_h_unit (:, i )) v_t_unit (:, i ) = v_h_unit (:, i ) . cross . v_r_unit (:, i ) xb_frag (:, i ) = x_frag (:, i ) + xcom (:) end do call add_fragments_to_tmpsys () xcom (:) = 0.0_DP do i = 1 , nfrag xcom (:) = xcom (:) + m_frag ( i ) * xb_frag (:, i ) end do xcom (:) = xcom (:) / mtot return end subroutine set_fragment_position_vectors subroutine set_fragment_tan_vel ( lerr ) !! Author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Adjusts the tangential velocities and spins of a collection of fragments such that they conserve angular momentum without blowing the fragment kinetic energy budget. !! This procedure works in several stages, with a goal to solve the angular and linear momentum constraints on the fragments, while still leaving a positive balance of !! our fragment kinetic energy (ke_frag_budget) that we can put into the radial velocity distribution. !! !! The first thing we'll try to do is solve for the tangential velocities of the first 6 fragments, using angular and linear momentum as constraints and an initial !! tangential velocity distribution for the remaining bodies (if there are any) that distributes their angular momentum equally between them. !! If that doesn't work and we blow our kinetic energy budget, we will attempt to find a tangential velocity distribution that minimizes the kinetic energy while !! conserving momentum. !! !! A failure will trigger a restructuring of the fragments so we will try new values of the radial position distribution. implicit none ! Arguments logical , intent ( out ) :: lerr ! Internals integer ( I4B ) :: i real ( DP ), parameter :: TOL = 1e-4_DP real ( DP ), dimension (:), allocatable :: v_t_initial real ( DP ), dimension ( nfrag ) :: kefrag type ( lambda_obj ) :: spinfunc type ( lambda_obj_err ) :: objective_function real ( DP ), dimension ( NDIM ) :: L_frag_spin , L_remainder , Li , rot_L , rot_ke lerr = . false . if ( ke_frag_budget < 0.0_DP ) then write ( * , * ) 'Negative ke_frag_budget: ' , ke_frag_budget r_max_start = r_max_start / 2 lerr = . true . return end if allocate ( v_t_initial , mold = v_t_mag ) L_frag_spin (:) = 0.0_DP ke_frag_spin = 0.0_DP ! Start the first two bodies with the same rotation as the original two impactors, then distribute the remaining angular momentum among the rest do i = 1 , 2 rot_frag (:, i ) = rot (:, i ) L_frag_spin (:) = L_frag_spin (:) + m_frag ( i ) * rad_frag ( i ) ** 2 * Ip_frag ( 3 , i ) * rot_frag (:, i ) end do L_frag_orb (:) = L_frag_tot (:) - L_frag_spin (:) L_frag_spin (:) = 0.0_DP do i = 1 , nfrag ! Convert a fraction (f_spin) of either the remaining angular momentum or kinetic energy budget into spin, whichever gives the smaller rotation so as not to blow any budgets rot_ke (:) = sqrt ( 2 * f_spin * ke_frag_budget / ( nfrag * m_frag ( i ) * rad_frag ( i ) ** 2 * Ip_frag ( 3 , i ))) * L_frag_orb (:) / norm2 ( L_frag_orb (:)) rot_L (:) = f_spin * L_frag_orb (:) / ( nfrag * m_frag ( i ) * rad_frag ( i ) ** 2 * Ip_frag ( 3 , i )) if ( norm2 ( rot_ke ) < norm2 ( rot_L )) then rot_frag (:, i ) = rot_frag (:, i ) + rot_ke (:) else rot_frag (:, i ) = rot_frag (:, i ) + rot_L (:) end if L_frag_spin (:) = L_frag_spin (:) + m_frag ( i ) * rad_frag ( i ) ** 2 * Ip_frag ( 3 , i ) * rot_frag (:, i ) ke_frag_spin = ke_frag_spin + m_frag ( i ) * Ip_frag ( 3 , i ) * rad_frag ( i ) ** 2 * dot_product ( rot_frag (:, i ), rot_frag (:, i )) end do ke_frag_spin = 0.5_DP * ke_frag_spin ! Convert a fraction of the pre-impact angular momentum into fragment spin angular momentum L_frag_orb (:) = L_frag_tot (:) - L_frag_spin (:) L_remainder (:) = L_frag_orb (:) ! Next we will solve for the tangential component of the velocities that both conserves linear momentum and uses the remaining angular momentum not used in spin. ! This will be done using a linear solver that solves for the tangential velocities of the first 6 fragments, constrained by the linear and angular momentum vectors, ! which is embedded in a non-linear minimizer that will adjust the tangential velocities of the remaining i>6 fragments to minimize kinetic energy for a given momentum solution ! The initial conditions fed to the minimizer for the fragments will be the remaining angular momentum distributed between the fragments. do i = 1 , nfrag v_t_initial ( i ) = norm2 ( L_remainder (:)) / (( nfrag - i + 1 ) * m_frag ( i ) * norm2 ( x_frag (:, i ))) Li (:) = m_frag ( i ) * x_frag (:, i ) . cross . v_t_initial ( i ) * v_t_unit (:, i ) L_remainder (:) = L_remainder (:) - Li (:) end do ! Find the local kinetic energy minimum for the system that conserves linear and angular momentum objective_function = lambda_obj ( tangential_objective_function , lerr ) v_t_mag ( 7 : nfrag ) = util_minimize_bfgs ( objective_function , nfrag - 6 , v_t_initial ( 7 : nfrag ), TOL , lerr ) ! Now that the KE-minimized values of the i>6 fragments are found, calculate the momentum-conserving solution for tangential velociteis v_t_initial ( 7 : nfrag ) = v_t_mag ( 7 : nfrag ) v_t_mag ( 1 : nfrag ) = solve_fragment_tan_vel ( v_t_mag_input = v_t_initial ( 7 : nfrag ), lerr = lerr ) ! Perform one final shift of the radial velocity vectors to align with the center of mass of the collisional system (the origin) vb_frag (:, 1 : nfrag ) = vmag_to_vb ( v_r_mag ( 1 : nfrag ), v_r_unit (:, 1 : nfrag ), v_t_mag ( 1 : nfrag ), v_t_unit (:, 1 : nfrag ), m_frag ( 1 : nfrag ), vcom (:)) call add_fragments_to_tmpsys () ! Now do a kinetic energy budget check to make sure we are still within the budget. kefrag = 0.0_DP do concurrent ( i = 1 : nfrag ) v_frag (:, i ) = vb_frag (:, i ) - vcom (:) kefrag ( i ) = m_frag ( i ) * dot_product ( vb_frag (:, i ), vb_frag (:, i )) end do ke_frag_orbit = 0.5_DP * sum ( kefrag (:)) ke_radial = ke_frag_budget - ke_frag_orbit - ke_frag_spin ! If we are over the energy budget, flag this as a failure so we can try again lerr = ( ke_radial < 0.0_DP ) ! write(*,*) 'Tangential' ! write(*,*) 'Failure? ',lerr ! write(*,*) 'ke_frag_budget: ',ke_frag_budget ! write(*,*) 'ke_frag_spin  : ',ke_frag_spin ! write(*,*) 'ke_tangential : ',ke_frag_orbit ! write(*,*) 'ke_remainder  : ',ke_radial return end subroutine set_fragment_tan_vel function tangential_objective_function ( v_t_mag_input , lerr ) result ( fval ) !! Author: David A. Minton !! !! Objective function for evaluating how close our fragment velocities get to minimizing KE error from our required value implicit none ! Arguments real ( DP ), dimension (:), intent ( in ) :: v_t_mag_input !! Unknown tangential component of velocity vector set previously by angular momentum constraint logical , intent ( out ) :: lerr !! Error flag ! Result real ( DP ) :: fval ! Internals integer ( I4B ) :: i real ( DP ), dimension ( NDIM , nfrag ) :: v_shift real ( DP ), dimension ( nfrag ) :: v_t_new , kearr real ( DP ) :: keo lerr = . false . v_t_new (:) = solve_fragment_tan_vel ( v_t_mag_input = v_t_mag_input (:), lerr = lerr ) v_shift (:,:) = vmag_to_vb ( v_r_mag , v_r_unit , v_t_new , v_t_unit , m_frag , vcom ) kearr = 0.0_DP do concurrent ( i = 1 : nfrag ) kearr ( i ) = m_frag ( i ) * dot_product ( v_shift (:, i ), v_shift (:, i )) end do keo = 0.5_DP * sum ( kearr (:)) fval = keo lerr = . false . return end function tangential_objective_function function solve_fragment_tan_vel ( lerr , v_t_mag_input ) result ( v_t_mag_output ) !! Author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Adjusts the positions, velocities, and spins of a collection of fragments such that they conserve angular momentum implicit none ! Arguments logical , intent ( out ) :: lerr !! Error flag real ( DP ), dimension (:), optional , intent ( in ) :: v_t_mag_input !! Unknown tangential velocities for fragments 7:nfrag ! Internals integer ( I4B ) :: i ! Result real ( DP ), dimension (:), allocatable :: v_t_mag_output real ( DP ), dimension ( 2 * NDIM , 2 * NDIM ) :: A ! LHS of linear equation used to solve for momentum constraint in Gauss elimination code real ( DP ), dimension ( 2 * NDIM ) :: b ! RHS of linear equation used to solve for momentum constraint in Gauss elimination code real ( DP ), dimension ( NDIM ) :: L_lin_others , L_orb_others , L , vtmp v_frag (:,:) = 0.0_DP lerr = . false . ! We have 6 constraint equations (2 vector constraints in 3 dimensions each) ! The first 3 are that the linear momentum of the fragments is zero with respect to the collisional barycenter ! The second 3 are that the sum of the angular momentum of the fragments is conserved from the pre-impact state L_lin_others (:) = 0.0_DP L_orb_others (:) = 0.0_DP do i = 1 , nfrag if ( i <= 2 * NDIM ) then ! The tangential velocities of the first set of bodies will be the unknowns we will solve for to satisfy the constraints A ( 1 : 3 , i ) = m_frag ( i ) * v_t_unit (:, i ) L (:) = v_r_unit (:, i ) . cross . v_t_unit (:, i ) A ( 4 : 6 , i ) = m_frag ( i ) * rmag ( i ) * L (:) else if ( present ( v_t_mag_input )) then vtmp (:) = v_t_mag_input ( i - 6 ) * v_t_unit (:, i ) L_lin_others (:) = L_lin_others (:) + m_frag ( i ) * vtmp (:) L (:) = x_frag (:, i ) . cross . vtmp (:) L_orb_others (:) = L_orb_others (:) + m_frag ( i ) * L (:) end if end do b ( 1 : 3 ) = - L_lin_others (:) b ( 4 : 6 ) = L_frag_orb (:) - L_orb_others (:) allocate ( v_t_mag_output ( nfrag )) v_t_mag_output ( 1 : 6 ) = util_solve_linear_system ( A , b , 6 , lerr ) if ( present ( v_t_mag_input )) v_t_mag_output ( 7 : nfrag ) = v_t_mag_input (:) return end function solve_fragment_tan_vel subroutine set_fragment_radial_velocities ( lerr ) !! Author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! !! Adjust the fragment velocities to set the fragment orbital kinetic energy. This will minimize the difference between the fragment kinetic energy and the energy budget implicit none ! Arguments logical , intent ( out ) :: lerr ! Internals real ( DP ), parameter :: TOL = 1e-10_DP integer ( I4B ) :: i , j real ( DP ), dimension (:), allocatable :: v_r_initial , v_r_sigma real ( DP ), dimension (:,:), allocatable :: v_r real ( DP ), dimension ( nfrag ) :: kearr , kespinarr type ( lambda_obj ) :: objective_function ! Set the \"target\" ke_orbit_after (the value of the orbital kinetic energy that the fragments ought to have) allocate ( v_r_initial , source = v_r_mag ) ! Initialize radial velocity magnitudes with a random value that is approximately 10% of that found by distributing the kinetic energy equally allocate ( v_r_sigma , source = v_r_mag ) call random_number ( v_r_sigma ( 1 : nfrag )) v_r_sigma ( 1 : nfrag ) = sqrt ( 1.0_DP + 2 * ( v_r_sigma ( 1 : nfrag ) - 0.5_DP ) * 1e-4_DP ) v_r_initial ( 1 : nfrag ) = v_r_sigma ( 1 : nfrag ) * sqrt ( abs ( 2 * ke_radial ) / ( m_frag ( 1 : nfrag ) * nfrag )) ! Initialize the lambda function using a structure constructor that calls the init method ! Minimize the ke objective function using the BFGS optimizer objective_function = lambda_obj ( radial_objective_function ) v_r_mag = util_minimize_bfgs ( objective_function , nfrag , v_r_initial , TOL , lerr ) ! Shift the radial velocity vectors to align with the center of mass of the collisional system (the origin) vb_frag (:, 1 : nfrag ) = vmag_to_vb ( v_r_mag ( 1 : nfrag ), v_r_unit (:, 1 : nfrag ), v_t_mag ( 1 : nfrag ), v_t_unit (:, 1 : nfrag ), m_frag ( 1 : nfrag ), vcom (:)) do i = 1 , nfrag v_frag (:, i ) = vb_frag (:, i ) - vcom (:) end do call add_fragments_to_tmpsys () do concurrent ( i = 1 : nfrag ) kearr ( i ) = m_frag ( i ) * dot_product ( vb_frag (:, i ), vb_frag (:, i )) kespinarr ( i ) = m_frag ( i ) * Ip_frag ( 3 , i ) * rad_frag ( i ) ** 2 * dot_product ( rot_frag (:, i ), rot_frag (:, i )) end do ke_frag_orbit = 0.5_DP * sum ( kearr (:)) ke_frag_spin = 0.5_DP * sum ( kespinarr (:)) ! write(*,*) 'Radial' ! write(*,*) 'Failure? ',lerr ! write(*,*) 'ke_frag_budget: ',ke_frag_budget ! write(*,*) 'ke_frag_spin  : ',ke_frag_spin ! write(*,*) 'ke_frag_orbit : ',ke_frag_orbit ! write(*,*) 'ke_remainder  : ',ke_frag_budget - (ke_frag_orbit + ke_frag_spin) lerr = . false . return end subroutine set_fragment_radial_velocities function radial_objective_function ( v_r_mag_input ) result ( fval ) !! Author: David A. Minton !! !! Objective function for evaluating how close our fragment velocities get to minimizing KE error from our required value implicit none ! Arguments real ( DP ), dimension (:), intent ( in ) :: v_r_mag_input !! Unknown radial component of fragment velocity vector ! Result real ( DP ) :: fval !! The objective function result, which is the square of the difference between the calculated fragment kinetic energy and our target !! Minimizing this brings us closer to our objective ! Internals integer ( I4B ) :: i real ( DP ), dimension (:,:), allocatable :: v_shift real ( DP ), dimension ( nfrag ) :: kearr real ( DP ) :: keo allocate ( v_shift , mold = vb_frag ) v_shift (:,:) = vmag_to_vb ( v_r_mag_input , v_r_unit , v_t_mag , v_t_unit , m_frag , vcom ) do concurrent ( i = 1 : nfrag ) kearr ( i ) = m_frag ( i ) * ( Ip_frag ( 3 , i ) * rad_frag ( i ) ** 2 * dot_product ( rot_frag (:, i ), rot_frag (:, i )) + dot_product ( v_shift (:, i ), v_shift (:, i ))) end do keo = 2 * ke_frag_budget - sum ( kearr (:)) ! The following ensures that fval = 0 is a local minimum, which is what the BFGS method is searching for fval = ( keo / ( 2 * ke_radial )) ** 2 return end function radial_objective_function function vmag_to_vb ( v_r_mag , v_r_unit , v_t_mag , v_t_unit , m_frag , vcom ) result ( vb ) !! Author: David A. Minton !! !! Converts radial and tangential velocity magnitudes into barycentric velocity implicit none ! Arguments real ( DP ), dimension (:), intent ( in ) :: v_r_mag !! Unknown radial component of fragment velocity vector real ( DP ), dimension (:), intent ( in ) :: v_t_mag !! Tangential component of velocity vector set previously by angular momentum constraint real ( DP ), dimension (:,:), intent ( in ) :: v_r_unit , v_t_unit !! Radial and tangential unit vectors for each fragment real ( DP ), dimension (:), intent ( in ) :: m_frag !! Fragment masses real ( DP ), dimension (:), intent ( in ) :: vcom !! Barycentric velocity of collisional system center of mass ! Result real ( DP ), dimension (:,:), allocatable :: vb ! Internals integer ( I4B ) :: i allocate ( vb , mold = v_r_unit ) ! Make sure the velocity magnitude stays positive do i = 1 , nfrag vb (:, i ) = abs ( v_r_mag ( i )) * v_r_unit (:, i ) end do ! In order to keep satisfying the kinetic energy constraint, we must shift the origin of the radial component of the velocities to the center of mass call shift_vector_to_origin ( m_frag , vb ) do i = 1 , nfrag vb (:, i ) = vb (:, i ) + v_t_mag ( i ) * v_t_unit (:, i ) + vcom (:) end do return end function vmag_to_vb subroutine restructure_failed_fragments () !! Author: David A. Minton !! !! We failed to find a set of positions and velocities that satisfy all the constraints, and so we will alter the fragments and try again. implicit none integer ( I4B ) :: i real ( DP ), dimension (:), allocatable :: m_frag_new , rad_frag_new real ( DP ), dimension (:,:), allocatable :: xb_frag_new , vb_frag_new , Ip_frag_new , rot_frag_new real ( DP ) :: delta_r , delta_r_max real ( DP ), parameter :: ke_avg_deficit_target = 0.0_DP ! Introduce a bit of noise in the radius determination so we don't just flip flop between similar failed positions call random_number ( delta_r_max ) delta_r_max = sum ( radius (:)) * ( 1.0_DP + 2e-1_DP * ( delta_r_max - 0.5_DP )) if ( try > 2 ) then ! Linearly interpolate the last two failed solution ke deficits to find a new distance value to try delta_r = ( r_max_start - r_max_start_old ) * ( ke_avg_deficit_target - ke_avg_deficit_old ) / ( ke_avg_deficit - ke_avg_deficit_old ) if ( abs ( delta_r ) > delta_r_max ) delta_r = sign ( delta_r_max , delta_r ) else delta_r = delta_r_max end if r_max_start_old = r_max_start r_max_start = r_max_start + delta_r ! The larger lever arm can help if the problem is in the angular momentum step if ( f_spin > epsilon ( 1.0_DP )) then f_spin = f_spin / 2 else f_spin = 0.0_DP end if return end subroutine restructure_failed_fragments end subroutine fragmentation_initialize module subroutine fragmentation_regime ( Mcb , m1 , m2 , rad1 , rad2 , xh1 , xh2 , vb1 , vb2 , den1 , den2 , regime , Mlr , Mslr , mtiny , Qloss ) !! Author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Determine the collisional regime of two colliding bodies. !! Current version requires all values to be converted to SI units prior to calling the function !!       References: !!       Kokubo, E., Genda, H., 2010. Formation of Terrestrial Planets from Protoplanets Under a Realistic Accretion !!          Condition. ApJL 714, L21. https://doi.org/10.1088/2041-8205/714/1/L21 !!       Leinhardt, Z.M., Stewart, S.T., 2012. Collisions between Gravity-dominated Bodies. I. Outcome Regimes and Scaling !!          Laws 745, 79. https://doi.org/10.1088/0004-637X/745/1/79 !!       Mustill, A.J., Davies, M.B., Johansen, A., 2018. The dynamical evolution of transiting planetary systems including !!          a realistic collision prescription. Mon Not R Astron Soc 478, 2896–2908. https://doi.org/10.1093/mnras/sty1273 !!       Rufu, R., Aharonson, O., 2019. Impact Dynamics of Moons Within a Planetary Potential. J. Geophys. Res. Planets 124, !!          1008–1019. https://doi.org/10.1029/2018JE005798 !!       Stewart, S.T., Leinhardt, Z.M., 2012. Collisions between Gravity-dominated Bodies. II. The Diversity of Impact !!          Outcomes during the End Stage of Planet Formation. ApJ 751, 32. https://doi.org/10.1088/0004-637X/751/1/32 !! implicit none ! Arguments integer ( I4B ), intent ( out ) :: regime real ( DP ), intent ( out ) :: Mlr , Mslr real ( DP ), intent ( in ) :: Mcb , m1 , m2 , rad1 , rad2 , den1 , den2 , mtiny real ( DP ), dimension (:), intent ( in ) :: xh1 , xh2 , vb1 , vb2 real ( DP ), intent ( out ) :: Qloss !! The residual energy after the collision ! Constants integer ( I4B ), parameter :: N1 = 1 !number of objects with mass equal to the largest remnant from LS12 integer ( I4B ), parameter :: N2 = 2 !number of objects with mass larger than second largest remnant from LS12 real ( DP ), parameter :: DENSITY1 = 100 0.0_DP !standard density parameter from LS12 [kg/m3] real ( DP ), parameter :: MU_BAR = 0.37_DP !0.385#0.37#0.3333# 3.978 # 1/3 material parameter for hydrodynamic planet-size bodies (LS12) real ( DP ), parameter :: BETA = 2.85_DP !slope of sfd for remnants from LS12 2.85 real ( DP ), parameter :: C1 = 2.43_DP !! Kokubo & Genda (2010) eq. (3) real ( DP ), parameter :: C2 = - 0.0408_DP !! Kokubo & Genda (2010) eq. (3) real ( DP ), parameter :: C3 = 1.86_DP !! Kokubo & Genda (2010) eq. (3) real ( DP ), parameter :: C4 = 1.08_DP !! Kokubo & Genda (2010) eq. (3) real ( DP ), parameter :: CRUFU = 2.0_DP - 3 * MU_BAR ! central potential variable from Rufu and Aharonson (2019) real ( DP ), parameter :: SUPERCAT_QRATIO = 1.8_DP ! See Section 4.1 of LS12 ! Internals real ( DP ) :: a1 , alpha , aint , b , bcrit , c_star , egy , zeta , l , lint , mu , phi , theta real ( DP ) :: Qr , Qrd_pstar , Qr_erosion , Qr_supercat real ( DP ) :: Vhr , Verosion , Vescp , Vhill , Vimp , Vsupercat real ( DP ) :: Mint , Mtot real ( DP ) :: Rp , rhill real ( DP ) :: Mresidual real ( DP ) :: U_binding Vimp = norm2 ( vb2 (:) - vb1 (:)) b = calc_b ( xh2 , vb2 , xh1 , vb1 ) l = ( rad1 + rad2 ) * ( 1 - b ) egy = 0.5_DP * dot_product ( vb1 , vb1 ) - GC * Mcb / norm2 ( xh1 ) a1 = - GC * Mcb / 2.0_DP / egy Mtot = m1 + m2 mu = ( m1 * m2 ) / Mtot if ( l < 2 * rad2 ) then !calculate Mint phi = 2 * acos (( l - rad2 ) / rad2 ) aint = rad2 ** 2 * ( PI - ( phi - sin ( phi )) / 2.0_DP ) lint = 2 * sqrt ( rad2 ** 2 - ( rad2 - l / 2.0_DP ) ** 2 ) Mint = aint * lint ![kg] alpha = ( l ** 2 ) * ( 3 * rad2 - l ) / ( 4 * ( rad2 ** 3 )) else alpha = 1.0_DP Mint = m2 end if Rp = ( 3 * ( m1 / den1 + alpha * m2 / den2 ) / ( 4 * PI )) ** ( 1.0_DP / 3.0_DP ) ! (Mustill et al. 2018) c_star = calc_c_star ( Rp ) !calculate Vescp Vescp = sqrt ( 2 * GC * Mtot / Rp ) !Mustill et al. 2018 eq 6 !calculate rhill rhill = a1 * ( m1 / 3.0_DP / ( Mcb + m1 )) ** ( 1.0_DP / 3.0_DP ) !calculate Vhill if (( rad2 + rad1 ) < rhill ) then Vhill = sqrt ( 2 * GC * m1 * (( rhill ** 2 - rhill * ( rad1 + rad2 )) / & ( rhill ** 2 - 0.5_DP * ( rad1 + rad2 ) ** 2 )) / ( rad1 + rad2 )) else Vhill = Vescp end if !calculate Qr_pstar Qrd_pstar = calc_Qrd_pstar ( m1 , m2 , alpha , c_star ) * ( Vhill / Vescp ) ** CRUFU !Rufu and Aharaonson eq (3) !calculate Verosion Qr_erosion = 2 * ( 1.0_DP - m1 / Mtot ) * Qrd_pstar Verosion = ( 2 * Qr_erosion * Mtot / mu ) ** ( 1.0_DP / 2.0_DP ) Qr = mu * ( Vimp ** 2 ) / Mtot / 2.0_DP !calculate mass largest remnant Mlr Mlr = ( 1.0_DP - Qr / Qrd_pstar / 2.0_DP ) * Mtot ! [kg] # LS12 eq (5) !calculate Vsupercat Qr_supercat = SUPERCAT_QRATIO * Qrd_pstar ! See LS12 Section 4.1 Vsupercat = sqrt ( 2 * Qr_supercat * Mtot / mu ) !calculate Vhr zeta = ( m1 - m2 ) / Mtot theta = 1.0_DP - b Vhr = Vescp * ( C1 * zeta ** 2 * theta ** ( 2.5_DP ) + C2 * zeta ** 2 + C3 * theta ** ( 2.5_DP ) + C4 ) ! Kokubo & Genda (2010) eq. (3) bcrit = rad1 / ( rad1 + rad2 ) Qloss = 0.0_DP U_binding = ( 3.0_DP * Mtot ) / ( 5.0_DP * Rp ) ! LS12 eq. 27 if (( m1 < mtiny ). or .( m2 < mtiny )) then regime = COLLRESOLVE_REGIME_MERGE !perfect merging regime Mlr = Mtot Mslr = 0.0_DP Qloss = 0.0_DP write ( * , * ) \"FORCE MERGE\" else if ( Vimp < Vescp ) then regime = COLLRESOLVE_REGIME_MERGE !perfect merging regime Mlr = Mtot Mslr = 0.0_DP Qloss = 0.0_DP else if ( Vimp < Verosion ) then if ( b < bcrit ) then regime = COLLRESOLVE_REGIME_MERGE !partial accretion regime\" Mlr = Mtot Mslr = 0.0_DP Qloss = 0.0_DP else if (( b > bcrit ) . and . ( Vimp < Vhr )) then regime = COLLRESOLVE_REGIME_MERGE ! graze and merge Mlr = Mtot Mslr = 0.0_DP Qloss = 0.0_DP else Mlr = m1 Mslr = calc_Qrd_rev ( m2 , m1 , Mint , den1 , den2 , Vimp , c_star ) regime = COLLRESOLVE_REGIME_HIT_AND_RUN !hit and run Qloss = ( c_star + 1.0_DP ) * U_binding ! Qr end if else if ( Vimp > Verosion . and . Vimp < Vsupercat ) then if ( m2 < 0.001_DP * m1 ) then regime = COLLRESOLVE_REGIME_MERGE !cratering regime\" Mlr = Mtot Mslr = 0.0_DP Qloss = 0.0_DP else Mslr = Mtot * ( 3.0_DP - BETA ) * ( 1.0_DP - N1 * Mlr / Mtot ) / ( N2 * BETA ) ! LS12 eq (37) regime = COLLRESOLVE_REGIME_DISRUPTION !disruption Qloss = ( c_star + 1.0_DP ) * U_binding ! Qr - Qr_erosion end if else if ( Vimp > Vsupercat ) then Mlr = Mtot * 0.1_DP * ( Qr / ( Qrd_pstar * SUPERCAT_QRATIO )) ** ( - 1.5_DP ) !LS12 eq (44) Mslr = Mtot * ( 3.0_DP - BETA ) * ( 1.0_DP - N1 * Mlr / Mtot ) / ( N2 * BETA ) !LS12 eq (37) regime = COLLRESOLVE_REGIME_SUPERCATASTROPHIC ! supercatastrophic Qloss = ( c_star + 1.0_DP ) * U_binding ! Qr - Qr_supercat else write ( * , * ) \"Error no regime found in symba_regime\" end if end if Mresidual = Mtot - Mlr - Mslr if ( Mresidual < 0.0_DP ) then ! prevents final masses from going negative Mlr = Mlr + Mresidual end if return ! Internal functions contains function calc_Qrd_pstar ( Mtarg , Mp , alpha , c_star ) result ( Qrd_pstar ) !! author: Jennifer L.L. Pouplin and Carlisle A. Wishard !! !! Calculates the corrected Q* for oblique impacts. See Eq. (15) of LS12. !!       Reference: !!       Leinhardt, Z.M., Stewart, S.T., 2012. Collisions between Gravity-dominated Bodies. I. Outcome Regimes and Scaling !!          Laws 745, 79. https://doi.org/10.1088/0004-637X/745/1/79 !! implicit none ! Arguments real ( DP ), intent ( in ) :: Mtarg , Mp , alpha , c_star ! Result real ( DP ) :: Qrd_pstar ! Internals real ( DP ) :: Qrd_star1 , mu_alpha , mu , Qrd_star ! calc mu, mu_alpha mu = ( Mtarg * Mp ) / ( Mtarg + Mp ) ! [kg] mu_alpha = ( Mtarg * alpha * Mp ) / ( Mtarg + alpha * Mp ) ! [kg] ! calc Qrd_star1 Qrd_star1 = ( c_star * 4 * PI * DENSITY1 * GC * Rp ** 2 ) / 5.0_DP ! calc Qrd_star Qrd_star = Qrd_star1 * ((( Mp / Mtarg + 1.0_DP ) ** 2 ) / ( 4 * Mp / Mtarg )) ** ( 2.0_DP / ( 3.0_DP * MU_BAR ) - 1.0_DP ) !(eq 23) ! calc Qrd_pstar, v_pstar Qrd_pstar = (( mu / mu_alpha ) ** ( 2.0_DP - 3.0_DP * MU_BAR / 2.0_DP )) * Qrd_star ! (eq 15) return end function calc_Qrd_pstar function calc_Qrd_rev ( Mp , Mtarg , Mint , den1 , den2 , Vimp , c_star ) result ( Mslr ) !! author: Jennifer L.L. Pouplin and Carlisle A. Wishard !! !! Calculates mass of second largest fragment. !! implicit none ! Arguments real ( DP ), intent ( in ) :: Mp , Mtarg , Mint , den1 , den2 , Vimp , c_star ! Result real ( DP ) :: Mslr ! Internals real ( DP ) :: mtot_rev , mu_rev , gamma_rev , Qrd_star1 , Qrd_star , mu_alpha_rev real ( DP ) :: Qrd_pstar , Rc1 , Qr_rev , Qrd_pstar_rev , Qr_supercat_rev ! calc Mslr, Rc1, mu, gammalr mtot_rev = Mint + Mp Rc1 = ( 3 * ( Mint / den1 + Mp / den2 ) / ( 4 * PI )) ** ( 1.0_DP / 3.0_DP ) ! [m] Mustill et al 2018 mu_rev = ( Mint * Mp ) / mtot_rev ! [kg] eq 49 LS12 mu_alpha_rev = ( Mtarg * alpha * Mp ) / ( Mtarg + alpha * Mp ) gamma_rev = Mint / Mp ! eq 50 LS12 !calc Qr_rev Qr_rev = mu_rev * ( Vimp ** 2 ) / ( 2 * mtot_rev ) ! calc Qrd_star1, v_star1 Qrd_star1 = ( c_star * 4 * PI * mtot_rev * GC ) / Rc1 / 5.0_DP ! calc Qrd_pstar_rev Qrd_star = Qrd_star1 * ((( gamma_rev + 1.0_DP ) ** 2 ) / ( 4 * gamma_rev )) ** ( 2.0_DP / ( 3.0_DP * MU_BAR ) - 1.0_DP ) !(eq 52) Qrd_pstar = Qrd_star * (( mu_rev / mu_alpha_rev ) ** ( 2.0_DP - 3.0_DP * MU_BAR / 2.0_DP )) Qrd_pstar_rev = Qrd_pstar * ( Vhill / Vescp ) ** CRUFU !Rufu and Aharaonson eq (3) !calc Qr_supercat_rev Qr_supercat_rev = 1.8_DP * Qrd_pstar_rev if ( Qr_rev > Qr_supercat_rev ) then Mslr = mtot_rev * ( 0.1_DP * (( Qr_rev / ( Qrd_pstar_rev * 1.8_DP )) ** ( - 1.5_DP ))) !eq (44) else if ( Qr_rev < Qrd_pstar_rev ) then Mslr = Mp else Mslr = ( 1.0_DP - Qr_rev / Qrd_pstar_rev / 2.0_DP ) * ( mtot_rev ) ! [kg] #(eq 5) end if if ( Mslr > Mp ) Mslr = Mp !check conservation of mass return end function calc_Qrd_rev function calc_b ( proj_pos , proj_vel , targ_pos , targ_vel ) result ( sintheta ) !! author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Calculates the impact factor b = sin(theta), where theta is the angle between the relative velocity !! and distance vectors of the target and projectile bodies. See Fig. 2 of Leinhardt and Stewart (2012) !! implicit none !! Arguments real ( DP ), dimension (:), intent ( in ) :: proj_pos , proj_vel , targ_pos , targ_vel !! Result real ( DP ) :: sintheta !! Internals real ( DP ), dimension ( NDIM ) :: imp_vel , distance , x_cross_v imp_vel (:) = proj_vel (:) - targ_vel (:) distance (:) = proj_pos (:) - targ_pos (:) x_cross_v (:) = distance (:) . cross . imp_vel (:) sintheta = norm2 ( x_cross_v (:)) / norm2 ( distance (:)) / norm2 ( imp_vel (:)) return end function calc_b function calc_c_star ( Rc1 ) result ( c_star ) !! author: David A. Minton !! !! Calculates c_star as a function of impact equivalent radius. It inteRpolates between 5 for ~1 km sized bodies to !! 1.8 for ~10000 km sized bodies. See LS12 Fig. 4 for details. !! implicit none !! Arguments real ( DP ), intent ( in ) :: Rc1 !! Result real ( DP ) :: c_star !! Internals real ( DP ), parameter :: loR = 1.0e3_DP ! Lower bound of inteRpolation size (m) real ( DP ), parameter :: hiR = 1.0e7_DP ! Upper bound of inteRpolation size (m) real ( DP ), parameter :: loval = 5.0_DP ! Value of C* at lower bound real ( DP ), parameter :: hival = 1.9_DP ! Value of C* at upper bound if ( Rc1 < loR ) then c_star = loval else if ( Rc1 < hiR ) then c_star = loval + ( hival - loval ) * log ( Rc1 / loR ) / log ( hiR / loR ) else c_star = hival end if return end function calc_c_star end subroutine fragmentation_regime end submodule s_fragmentation","tags":"","loc":"sourcefile/fragmentation.f90.html"},{"title":"rmvs_discard.f90 – swiftest","text":"This file depends on sourcefile~~rmvs_discard.f90~~EfferentGraph sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~rmvs_discard.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_rmvs_discard Source Code rmvs_discard.f90 Source Code submodule ( rmvs_classes ) s_rmvs_discard use swiftest contains module subroutine rmvs_discard_tp ( self , system , param ) !! author: David A. Minton !! !! Check to see if test particles should be discarded based on pericenter passage distances with respect to planets encountered !! !! Adapted from Hal Levison's Swift routine discard_pl.f !! Adapted from Hal Levison's Swift routine rmvs_discard_pl.f90 implicit none ! Arguments class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody , pl => system % pl , t => param % t ) do i = 1 , ntp associate ( iplperP => tp % plperP ( i )) if (( tp % status ( i ) == ACTIVE ) . and . ( tp % lperi ( i ))) then if (( tp % peri ( i ) < pl % radius ( iplperP ))) then tp % status ( i ) = DISCARDED_PLQ write ( * , * ) \"Particle \" , tp % id ( i ), \" q with respect to Planet \" , pl % id ( iplperP ), \" is too small at t = \" , t tp % ldiscard ( i ) = . true . tp % lmask ( i ) = . false . end if end if end associate end do ! Call the base method that this overrides call discard_tp ( tp , system , param ) end associate end subroutine rmvs_discard_tp end submodule s_rmvs_discard","tags":"","loc":"sourcefile/rmvs_discard.f90.html"},{"title":"rmvs_util.f90 – swiftest","text":"This file depends on sourcefile~~rmvs_util.f90~~EfferentGraph sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~rmvs_util.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_rmvs_util Source Code rmvs_util.f90 Source Code submodule ( rmvs_classes ) s_rmvs_util use swiftest contains module subroutine rmvs_util_append_pl ( self , source , lsource_mask ) !! author: David A. Minton !! !! Append components from one massive body object to another. !! This method will automatically resize the destination body if it is too small implicit none !! Arguments class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to select type ( source ) class is ( rmvs_pl ) associate ( nold => self % nbody , nsrc => source % nbody ) call util_append ( self % nenc , source % nenc , nold , nsrc , lsource_mask ) call util_append ( self % tpenc1P , source % tpenc1P , nold , nsrc , lsource_mask ) call util_append ( self % plind , source % plind , nold , nsrc , lsource_mask ) ! The following are not implemented as RMVS doesn't make use of fill operations on pl type ! So they are here as a placeholder in case someone wants to extend the RMVS class for some reason !call util_append(self%outer, source%outer, nold, nsrc, lsource_mask) !call util_append(self%inner, source%inner, nold, nsrc, lsource_mask) !call util_append(self%planetocentric, source%planetocentric, nold, nsrc, lsource_mask) call whm_util_append_pl ( self , source , lsource_mask ) end associate class default write ( * , * ) \"Invalid object passed to the append method. Source must be of class rmvs_pl or its descendents!\" call util_exit ( FAILURE ) end select return end subroutine rmvs_util_append_pl module subroutine rmvs_util_append_tp ( self , source , lsource_mask ) !! author: David A. Minton !! !! Append components from test particle object to another. !! This method will automatically resize the destination body if it is too small implicit none !! Arguments class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to select type ( source ) class is ( rmvs_tp ) associate ( nold => self % nbody , nsrc => source % nbody ) call util_append ( self % lperi , source % lperi , nold , nsrc , lsource_mask ) call util_append ( self % plperP , source % plperP , nold , nsrc , lsource_mask ) call util_append ( self % plencP , source % plencP , nold , nsrc , lsource_mask ) call util_append_tp ( self , source , lsource_mask ) ! Note: whm_tp does not have its own append method, so we skip back to the base class end associate class default write ( * , * ) \"Invalid object passed to the append method. Source must be of class rmvs_tp or its descendents!\" call util_exit ( FAILURE ) end select return end subroutine rmvs_util_append_tp module subroutine rmvs_util_fill_pl ( self , inserts , lfill_list ) !! author: David A. Minton !! !! Insert new RMVS massive body structure into an old one. !! This is the inverse of a fill operation. !! implicit none ! Arguments class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object class ( swiftest_body ), intent ( in ) :: inserts !! Inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps ! Internals integer ( I4B ) :: i associate ( keeps => self ) select type ( inserts ) class is ( rmvs_pl ) call util_fill ( keeps % nenc , inserts % nenc , lfill_list ) call util_fill ( keeps % tpenc1P , inserts % tpenc1P , lfill_list ) call util_fill ( keeps % plind , inserts % plind , lfill_list ) ! The following are not implemented as RMVS doesn't make use of fill operations on pl type ! So they are here as a placeholder in case someone wants to extend the RMVS class for some reason !call util_fill(keeps%outer, inserts%outer, lfill_list) !call util_fill(keeps%inner, inserts%inner, lfill_list) !call util_fill(keeps%planetocentric, inserts%planetocentric, lfill_list) call whm_util_fill_pl ( keeps , inserts , lfill_list ) class default write ( * , * ) \"Invalid object passed to the fill method. Source must be of class rmvs_pl or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine rmvs_util_fill_pl module subroutine rmvs_util_fill_tp ( self , inserts , lfill_list ) !! author: David A. Minton !! !! Insert new RMVS test particle structure into an old one. !! This is the inverse of a fill operation. !! implicit none ! Arguments class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object class ( swiftest_body ), intent ( in ) :: inserts !! Inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps associate ( keeps => self ) select type ( inserts ) class is ( rmvs_tp ) call util_fill ( keeps % lperi , inserts % lperi , lfill_list ) call util_fill ( keeps % plperP , inserts % plperP , lfill_list ) call util_fill ( keeps % plencP , inserts % plencP , lfill_list ) call util_fill_tp ( keeps , inserts , lfill_list ) ! Note: whm_tp does not have its own fill method, so we skip back to the base class class default write ( * , * ) \"Invalid object passed to the fill method. Source must be of class rmvs_tp or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine rmvs_util_fill_tp module subroutine rmvs_util_resize_pl ( self , nnew ) !! author: David A. Minton !! !! Checks the current size of a massive body object against the requested size and resizes it if it is too small. implicit none ! Arguments class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object integer ( I4B ), intent ( in ) :: nnew !! New size neded call util_resize ( self % nenc , nnew ) call util_resize ( self % tpenc1P , nnew ) call util_resize ( self % plind , nnew ) ! The following are not implemented as RMVS doesn't make use of resize operations on pl type ! So they are here as a placeholder in case someone wants to extend the RMVS class for some reason !call util_resize(self%outer, nnew) !call util_resize(self%inner, nnew) !call util_resize(self%planetocentric, nnew) call whm_util_resize_pl ( self , nnew ) return end subroutine rmvs_util_resize_pl module subroutine rmvs_util_resize_tp ( self , nnew ) !! author: David A. Minton !! !! Checks the current size of a test particle object against the requested size and resizes it if it is too small. implicit none ! Arguments class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object integer ( I4B ), intent ( in ) :: nnew !! New size neded call util_resize ( self % lperi , nnew ) call util_resize ( self % plperP , nnew ) call util_resize ( self % plencP , nnew ) call util_resize ( self % xheliocentric , nnew ) call util_resize_tp ( self , nnew ) return end subroutine rmvs_util_resize_tp module subroutine rmvs_util_sort_pl ( self , sortby , ascending ) !! author: David A. Minton !! !! Sort a RMVS massive body object in-place. !! sortby is a string indicating which array component to sort. implicit none ! Arguments class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order ! Internals integer ( I4B ), dimension ( self % nbody ) :: ind integer ( I4B ) :: direction if ( ascending ) then direction = 1 else direction = - 1 end if associate ( pl => self , npl => self % nbody ) select case ( sortby ) case ( \"nenc\" ) call util_sort ( direction * pl % nenc ( 1 : npl ), ind ( 1 : npl )) case ( \"tpenc1P\" ) call util_sort ( direction * pl % tpenc1P ( 1 : npl ), ind ( 1 : npl )) case ( \"plind\" ) call util_sort ( direction * pl % plind ( 1 : npl ), ind ( 1 : npl )) case ( \"outer\" , \"inner\" , \"planetocentric\" , \"lplanetocentric\" ) write ( * , * ) 'Cannot sort by ' // trim ( adjustl ( sortby )) // '. Component not sortable!' case default ! Look for components in the parent class call whm_util_sort_pl ( pl , sortby , ascending ) return end select call pl % rearrange ( ind ) end associate return end subroutine rmvs_util_sort_pl module subroutine rmvs_util_sort_tp ( self , sortby , ascending ) !! author: David A. Minton !! !! Sort a RMVS test particle object in-place. !! sortby is a string indicating which array component to sort. implicit none ! Arguments class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order ! Internals integer ( I4B ), dimension ( self % nbody ) :: ind integer ( I4B ) :: direction if ( ascending ) then direction = 1 else direction = - 1 end if associate ( tp => self , ntp => self % nbody ) select case ( sortby ) case ( \"plperP\" ) call util_sort ( direction * tp % plperP ( 1 : ntp ), ind ( 1 : ntp )) case ( \"plencP\" ) call util_sort ( direction * tp % plencP ( 1 : ntp ), ind ( 1 : ntp )) case ( \"lperi\" , \"cb_heliocentric\" , \"xheliocentric\" , \"index\" , \"ipleP\" , \"lplanetocentric\" ) write ( * , * ) 'Cannot sort by ' // trim ( adjustl ( sortby )) // '. Component not sortable!' case default ! Look for components in the parent class (*NOTE whm_tp does not need its own sort method, so we go straight to the swiftest_tp method) call util_sort_tp ( tp , sortby , ascending ) return end select call tp % rearrange ( ind ) end associate return end subroutine rmvs_util_sort_tp module subroutine rmvs_util_sort_rearrange_pl ( self , ind ) !! author: David A. Minton !! !! Rearrange RMVS massive body structure in-place from an index list. !! This is a helper utility used to make polymorphic sorting work on Swiftest structures. implicit none ! Arguments class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) ! Internals class ( rmvs_pl ), allocatable :: pl_sorted !! Temporary holder for sorted body integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) call util_sort_rearrange_pl ( pl , ind ) allocate ( pl_sorted , source = self ) if ( allocated ( pl % nenc )) pl % nenc ( 1 : npl ) = pl_sorted % nenc ( ind ( 1 : npl )) if ( allocated ( pl % tpenc1P )) pl % tpenc1P ( 1 : npl ) = pl_sorted % tpenc1P ( ind ( 1 : npl )) if ( allocated ( pl % plind )) pl % plind ( 1 : npl ) = pl_sorted % plind ( ind ( 1 : npl )) deallocate ( pl_sorted ) end associate return end subroutine rmvs_util_sort_rearrange_pl module subroutine rmvs_util_sort_rearrange_tp ( self , ind ) !! author: David A. Minton !! !! Rearrange RMVS test particle object in-place from an index list. !! This is a helper utility used to make polymorphic sorting work on Swiftest structures. implicit none ! Arguments class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) ! Internals class ( rmvs_tp ), allocatable :: tp_sorted !! Temporary holder for sorted body if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) call util_sort_rearrange_tp ( tp , ind ) allocate ( tp_sorted , source = self ) if ( allocated ( tp % lperi )) tp % lperi ( 1 : ntp ) = tp_sorted % lperi ( ind ( 1 : ntp )) if ( allocated ( tp % plperP )) tp % plperP ( 1 : ntp ) = tp_sorted % plperP ( ind ( 1 : ntp )) if ( allocated ( tp % plencP )) tp % plencP ( 1 : ntp ) = tp_sorted % plencP ( ind ( 1 : ntp )) if ( allocated ( tp % xheliocentric )) tp % xheliocentric (:, 1 : ntp ) = tp_sorted % xheliocentric (:, ind ( 1 : ntp )) deallocate ( tp_sorted ) end associate return end subroutine rmvs_util_sort_rearrange_tp module subroutine rmvs_util_spill_pl ( self , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Move spilled (discarded) RMVS test particle structure from active list to discard list !! !! Adapted from David E. Kaufmann's Swifter routine discard_discard_spill.f90 implicit none ! Arguments class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body body object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not ! Internals integer ( I4B ) :: i associate ( keeps => self ) select type ( discards ) class is ( rmvs_pl ) call util_spill ( keeps % nenc , discards % nenc , lspill_list , ldestructive ) call util_spill ( keeps % tpenc1P , discards % tpenc1P , lspill_list , ldestructive ) call util_spill ( keeps % plind , discards % plind , lspill_list , ldestructive ) call whm_util_spill_pl ( keeps , discards , lspill_list , ldestructive ) class default write ( * , * ) \"Invalid object passed to the spill method. Source must be of class rmvs_pl or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine rmvs_util_spill_pl module subroutine rmvs_util_spill_tp ( self , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Move spilled (discarded) RMVS test particle structure from active list to discard list !! !! Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 implicit none ! Arguments class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not ! Internals integer ( I4B ) :: i associate ( keeps => self ) select type ( discards ) class is ( rmvs_tp ) call util_spill ( keeps % lperi , discards % lperi , lspill_list , ldestructive ) call util_spill ( keeps % plperP , discards % plperP , lspill_list , ldestructive ) call util_spill ( keeps % plencP , discards % plencP , lspill_list , ldestructive ) call util_spill_tp ( keeps , discards , lspill_list , ldestructive ) class default write ( * , * ) \"Invalid object passed to the spill method. Source must be of class rmvs_tp or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine rmvs_util_spill_tp end submodule s_rmvs_util","tags":"","loc":"sourcefile/rmvs_util.f90.html"},{"title":"rmvs_kick.f90 – swiftest","text":"This file depends on sourcefile~~rmvs_kick.f90~~EfferentGraph sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~rmvs_kick.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_rmvs_kick Source Code rmvs_kick.f90 Source Code submodule ( rmvs_classes ) s_rmvs_kick use swiftest contains module subroutine rmvs_kick_getacch_tp ( self , system , param , t , lbeg ) !! author: David A. Minton !! !! Compute the oblateness acceleration in the inner encounter region with planets !! !! Performs a similar task as David E. Kaufmann's Swifter routine rmvs_kick_getacch_tp.f90, but !! uses object polymorphism, and so is not directly adapted. implicit none ! Arguments class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest central body particle data structuree class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step ! Internals class ( swiftest_parameters ), allocatable :: param_planetocen real ( DP ), dimension (:, :), allocatable :: xh_original real ( DP ) :: GMcb_original integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody , ipleP => self % ipleP , inner_index => self % index ) select type ( system ) class is ( rmvs_nbody_system ) if ( system % lplanetocentric ) then ! This is a close encounter step, so any accelerations requiring heliocentric position values ! must be handeled outside the normal WHM method call select type ( pl => system % pl ) class is ( rmvs_pl ) select type ( cb => system % cb ) class is ( rmvs_cb ) associate ( xpc => pl % xh , xpct => self % xh , apct => self % ah , system_planetocen => system ) system_planetocen % lbeg = lbeg ! Save the original heliocentric position for later allocate ( xh_original , source = tp % xh ) ! Temporarily turn off the heliocentric-dependent acceleration terms during an inner encounter using a copy of the parameter list with all of the heliocentric-specific acceleration terms turned off allocate ( param_planetocen , source = param ) param_planetocen % loblatecb = . false . param_planetocen % lextra_force = . false . param_planetocen % lgr = . false . ! Compute the planetocentric values of acceleration call whm_kick_getacch_tp ( tp , system_planetocen , param_planetocen , t , lbeg ) ! Now compute any heliocentric values of acceleration if ( tp % lfirst ) then do concurrent ( i = 1 : ntp , tp % lmask ( i )) tp % xheliocentric (:, i ) = tp % xh (:, i ) + cb % inner ( inner_index - 1 )% x (:, 1 ) end do else do concurrent ( i = 1 : ntp , tp % lmask ( i )) tp % xheliocentric (:, i ) = tp % xh (:, i ) + cb % inner ( inner_index )% x (:, 1 ) end do end if ! Swap the planetocentric and heliocentric position vectors and central body masses tp % xh (:,:) = tp % xheliocentric (:,:) GMcb_original = cb % Gmass cb % Gmass = tp % cb_heliocentric % Gmass ! If the heliocentric-specifc acceleration terms are requested, compute those now if ( param % loblatecb ) call tp % accel_obl ( system_planetocen ) if ( param % lextra_force ) call tp % accel_user ( system_planetocen , param , t , lbeg ) if ( param % lgr ) call tp % accel_gr ( param ) ! Put everything back the way we found it tp % xh (:,:) = xh_original (:,:) cb % Gmass = GMcb_original end associate end select end select else ! Not a close encounter, so just proceded with the standard WHM method call whm_kick_getacch_tp ( tp , system , param , t , lbeg ) end if end select end associate return end subroutine rmvs_kick_getacch_tp end submodule s_rmvs_kick","tags":"","loc":"sourcefile/rmvs_kick.f90.html"},{"title":"rmvs_setup.f90 – swiftest","text":"This file depends on sourcefile~~rmvs_setup.f90~~EfferentGraph sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~rmvs_setup.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_rmvs_setup Source Code rmvs_setup.f90 Source Code submodule ( rmvs_classes ) s_rmvs_setup use swiftest contains module subroutine rmvs_setup_pl ( self , n , param ) !! author: David A. Minton !! !! Allocate RMVS test particle structure !! !! Equivalent in functionality to David E. Kaufmann's Swifter routine rmvs_setup.f90 implicit none ! Arguments class ( rmvs_pl ), intent ( inout ) :: self !! RMVS test particle object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameter ! Internals integer ( I4B ) :: i , j !> Call allocation method for parent class associate ( pl => self ) call whm_setup_pl ( pl , n , param ) if ( n <= 0 ) return allocate ( pl % outer ( 0 : NTENC )) allocate ( pl % inner ( 0 : NTPHENC )) if (. not . pl % lplanetocentric ) then allocate ( pl % nenc ( n )) pl % nenc (:) = 0 ! Set up inner and outer planet interpolation vector storage containers do i = 0 , NTENC allocate ( pl % outer ( i )% x ( NDIM , n )) allocate ( pl % outer ( i )% v ( NDIM , n )) pl % outer ( i )% x (:,:) = 0.0_DP pl % outer ( i )% v (:,:) = 0.0_DP end do do i = 0 , NTPHENC allocate ( pl % inner ( i )% x ( NDIM , n )) allocate ( pl % inner ( i )% v ( NDIM , n )) pl % inner ( i )% x (:,:) = 0.0_DP pl % inner ( i )% v (:,:) = 0.0_DP end do if ( param % loblatecb ) then do i = 0 , NTPHENC allocate ( pl % inner ( i )% aobl ( NDIM , n )) pl % inner ( i )% aobl (:,:) = 0.0_DP end do end if if ( param % ltides ) then do i = 0 , NTPHENC allocate ( pl % inner ( i )% atide ( NDIM , n )) pl % inner ( i )% atide (:,:) = 0.0_DP end do end if end if end associate return end subroutine rmvs_setup_pl module subroutine rmvs_setup_initialize_system ( self , param ) !! author: David A. Minton !! !! Initialize an RMVS nbody system from files and sets up the planetocentric structures. !! !! We currently rearrange the pl order to keep it consistent with the way Swifter does it !! In Swifter, the central body occupies the first position in the pl list, and during !! encounters, the encountering planet is skipped in loops. In Swiftest, we instantiate an !! RMVS nbody system object attached to each pl to store planetocentric versions of the system !! to use during close encounters. implicit none ! Arguments class ( rmvs_nbody_system ), intent ( inout ) :: self !! RMVS system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i , j ! Call parent method call whm_setup_initialize_system ( self , param ) ! Set up the pl-tp planetocentric encounter structures for pl and cb. The planetocentric tp structures are ! generated as necessary during close encounter steps. select type ( pl => self % pl ) class is ( rmvs_pl ) select type ( cb => self % cb ) class is ( rmvs_cb ) select type ( tp => self % tp ) class is ( rmvs_tp ) tp % cb_heliocentric = cb pl % lplanetocentric = . false . tp % lplanetocentric = . false . cb % lplanetocentric = . false . associate ( npl => pl % nbody ) allocate ( pl % planetocentric ( npl )) pl % planetocentric (:)% lplanetocentric = . true . do i = 1 , npl allocate ( pl % planetocentric ( i )% cb , source = cb ) allocate ( rmvs_pl :: pl % planetocentric ( i )% pl ) select type ( cbenci => pl % planetocentric ( i )% cb ) class is ( rmvs_cb ) select type ( plenci => pl % planetocentric ( i )% pl ) class is ( rmvs_pl ) cbenci % lplanetocentric = . true . plenci % lplanetocentric = . true . call plenci % setup ( npl , param ) plenci % status (:) = ACTIVE plenci % lmask (:) = . true . ! plind stores the heliocentric index value of a planetocentric planet ! e.g. Consider an encounter with planet 3. ! Then the following will be the values of plind: ! pl%planetocentric(3)%pl%plind(1) = 0 (central body - never used) ! pl%planetocentric(3)%pl%plind(2) = 1 ! pl%planetocentric(3)%pl%plind(3) = 2 ! pl%planetocentric(3)%pl%plind(4) = 4 ! pl%planetocentric(3)%pl%plind(5) = 5 ! etc. allocate ( plenci % plind ( npl )) plenci % plind ( 1 : npl ) = [( j , j = 1 , npl )] plenci % plind ( 2 : npl ) = pack ( plenci % plind ( 1 : npl ), plenci % plind ( 1 : npl ) /= i ) plenci % plind ( 1 ) = 0 plenci % Gmass ( 1 ) = cb % Gmass plenci % Gmass ( 2 : npl ) = pl % Gmass ( plenci % plind ( 2 : npl )) cbenci % Gmass = pl % Gmass ( i ) end select end select end do end associate end select end select end select return end subroutine rmvs_setup_initialize_system module subroutine rmvs_setup_tp ( self , n , param ) !! author: David A. Minton !! !! Allocate WHM test particle structure !! !! Equivalent in functionality to David E. Kaufmann's Swifter routine whm_setup.f90 implicit none ! Arguments class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameter !> Call allocation method for parent class. In this case, whm does not have its own setup method, so we use the base method for swiftest_tp call setup_tp ( self , n , param ) if ( n <= 0 ) return if ( allocated ( self % lperi )) deallocate ( self % lperi ) if ( allocated ( self % plperP )) deallocate ( self % plperP ) if ( allocated ( self % plencP )) deallocate ( self % plencP ) allocate ( self % lperi ( n )) allocate ( self % plperP ( n )) allocate ( self % plencP ( n )) if ( self % lplanetocentric ) then if ( allocated ( self % xheliocentric )) deallocate ( self % xheliocentric ) allocate ( self % xheliocentric ( NDIM , n )) end if self % lperi (:) = . false . return end subroutine rmvs_setup_tp end submodule s_rmvs_setup","tags":"","loc":"sourcefile/rmvs_setup.f90.html"},{"title":"rmvs_step.f90 – swiftest","text":"This file depends on sourcefile~~rmvs_step.f90~~EfferentGraph sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~rmvs_step.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_rmvs_step Source Code rmvs_step.f90 Source Code submodule ( rmvs_classes ) s_rmvs_step use swiftest contains module subroutine rmvs_step_system ( self , param , t , dt ) !! author: David A. Minton !! !! Step massive bodies and and active test particles ahead in heliocentric coordinates !! !! Adapted from Hal Levison's Swift routine rmvs3_step.f !! Adapted from David E. Kaufmann's Swifter routine rmvs_step.f90 implicit none ! Arguments class ( rmvs_nbody_system ), intent ( inout ) :: self !! RMVS nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Current stepsiz ! Internals logical :: lencounter , lfirstpl , lfirsttp real ( DP ) :: rts real ( DP ), dimension (:,:), allocatable :: xbeg , xend , vbeg integer ( I4B ) :: i select type ( cb => self % cb ) class is ( rmvs_cb ) select type ( pl => self % pl ) class is ( rmvs_pl ) select type ( tp => self % tp ) class is ( rmvs_tp ) associate ( system => self , ntp => tp % nbody , npl => pl % nbody ) allocate ( xbeg , source = pl % xh ) allocate ( vbeg , source = pl % vh ) call pl % set_beg_end ( xbeg = xbeg , vbeg = vbeg ) ! ****** Check for close encounters ***** ! system % rts = RHSCALE lencounter = tp % encounter_check ( system , dt ) if ( lencounter ) then lfirstpl = pl % lfirst pl % outer ( 0 )% x (:,:) = xbeg (:,:) pl % outer ( 0 )% v (:,:) = vbeg (:,:) call pl % step ( system , param , t , dt ) pl % outer ( NTENC )% x (:,:) = pl % xh (:,:) pl % outer ( NTENC )% v (:,:) = pl % vh (:,:) call rmvs_interp_out ( cb , pl , dt ) call rmvs_step_out ( cb , pl , tp , system , param , t , dt ) tp % lmask ( 1 : ntp ) = . not . tp % lmask ( 1 : ntp ) call pl % set_beg_end ( xbeg = xbeg , xend = xend ) tp % lfirst = . true . call tp % step ( system , param , t , dt ) tp % lmask ( 1 : ntp ) = . true . pl % lfirst = lfirstpl tp % lfirst = . true . if ( param % ltides ) call system % step_spin ( param , t , dt ) else call whm_step_system ( system , param , t , dt ) end if end associate end select end select end select return end subroutine rmvs_step_system subroutine rmvs_interp_out ( cb , pl , dt ) !! author: David A. Minton !! !! Interpolate planet positions between two Keplerian orbits in outer encounter region !! !! Adapted from David E. Kaufmann's Swifter routine rmvs_interp_out.f90 !! !! Adapted from Hal Levison's Swift routine rmvs3_interp.f implicit none ! Arguments class ( rmvs_cb ), intent ( inout ) :: cb !! RMVS central body object class ( rmvs_pl ), intent ( inout ) :: pl !! RMVS massive body object real ( DP ), intent ( in ) :: dt !! Step size ! Internals integer ( I4B ) :: i , outer_index real ( DP ) :: frac , dntenc real ( DP ), dimension (:,:), allocatable :: xtmp , vtmp real ( DP ), dimension (:), allocatable :: GMcb , dto integer ( I4B ), dimension (:), allocatable :: iflag dntenc = real ( NTENC , kind = DP ) associate ( npl => pl % nbody ) allocate ( xtmp , mold = pl % xh ) allocate ( vtmp , mold = pl % vh ) allocate ( GMcb ( npl )) allocate ( dto ( npl )) allocate ( iflag ( npl )) dto (:) = dt / dntenc GMcb (:) = cb % Gmass xtmp (:,:) = pl % outer ( 0 )% x (:, :) vtmp (:,:) = pl % outer ( 0 )% v (:, :) do outer_index = 1 , NTENC - 1 call drift_one ( GMcb ( 1 : npl ), xtmp ( 1 , 1 : npl ), xtmp ( 2 , 1 : npl ), xtmp ( 3 , 1 : npl ), & vtmp ( 1 , 1 : npl ), vtmp ( 2 , 1 : npl ), vtmp ( 3 , 1 : npl ), & dto ( 1 : npl ), iflag ( 1 : npl )) if ( any ( iflag ( 1 : npl ) /= 0 )) then do i = 1 , npl if ( iflag ( i ) /= 0 ) then write ( * , * ) \" Planet \" , pl % id ( i ), \" is lost!!!!!!!!!!\" write ( * , * ) GMcb ( i ), dto ( i ) write ( * , * ) xtmp (:, i ) write ( * , * ) vtmp (:, i ) write ( * , * ) \" STOPPING \" call util_exit ( FAILURE ) end if end do end if frac = 1.0_DP - outer_index / dntenc pl % outer ( outer_index )% x (:, :) = frac * xtmp (:,:) pl % outer ( outer_index )% v (:, :) = frac * vtmp (:,:) end do xtmp (:,:) = pl % outer ( NTENC )% x (:, :) vtmp (:,:) = pl % outer ( NTENC )% v (:, :) do outer_index = NTENC - 1 , 1 , - 1 call drift_one ( GMcb ( 1 : npl ), xtmp ( 1 , 1 : npl ), xtmp ( 2 , 1 : npl ), xtmp ( 3 , 1 : npl ), & vtmp ( 1 , 1 : npl ), vtmp ( 2 , 1 : npl ), vtmp ( 3 , 1 : npl ), & - dto ( 1 : npl ), iflag ( 1 : npl )) if ( any ( iflag ( 1 : npl ) /= 0 )) then do i = 1 , npl if ( iflag ( i ) /= 0 ) then write ( * , * ) \" Planet \" , pl % id ( i ), \" is lost!!!!!!!!!!\" write ( * , * ) GMcb ( i ), - dto ( i ) write ( * , * ) xtmp (:, i ) write ( * , * ) vtmp (:, i ) write ( * , * ) \" STOPPING \" call util_exit ( FAILURE ) end if end do end if frac = outer_index / dntenc pl % outer ( outer_index )% x (:, :) = pl % outer ( outer_index )% x (:, :) + frac * xtmp (:,:) pl % outer ( outer_index )% v (:, :) = pl % outer ( outer_index )% v (:, :) + frac * vtmp (:,:) end do end associate return end subroutine rmvs_interp_out subroutine rmvs_step_out ( cb , pl , tp , system , param , t , dt ) !! author: David A. Minton !! !! Step ACTIVE test particles ahead in the outer encounter region, setting up and calling the inner region !!    integration if necessar !! !! Adapted from Hal Levison's Swift routines rmvs3_step_out.f and rmvs3_step_out2.f !! Adapted from David E. Kaufmann's Swifter routines rmvs_step_out.f90 and rmvs_step_out2.f90 implicit none ! Arguments class ( rmvs_cb ), intent ( inout ) :: cb !! RMVS central body object class ( rmvs_pl ), intent ( inout ) :: pl !! RMVS massive body object class ( rmvs_tp ), intent ( inout ) :: tp !! RMVS test particle object class ( rmvs_nbody_system ), intent ( inout ) :: system !! RMVS nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Current stepsiz ! Internals integer ( I4B ) :: outer_index , j , k real ( DP ) :: dto , outer_time , rts logical :: lencounter , lfirsttp associate ( npl => pl % nbody , ntp => tp % nbody ) dto = dt / NTENC where ( tp % plencP (:) == 0 ) tp % lmask (:) = . false . elsewhere tp % lperi (:) = . false . end where do outer_index = 1 , NTENC outer_time = t + ( outer_index - 1 ) * dto call pl % set_beg_end ( xbeg = pl % outer ( outer_index - 1 )% x (:, :), & vbeg = pl % outer ( outer_index - 1 )% v (:, :), & xend = pl % outer ( outer_index )% x (:, :)) system % rts = RHPSCALE lencounter = tp % encounter_check ( system , dto ) if ( lencounter ) then ! Interpolate planets in inner encounter region call rmvs_interp_in ( cb , pl , system , param , dto , outer_index ) ! Step through the inner region call rmvs_step_in ( cb , pl , tp , param , outer_time , dto ) lfirsttp = tp % lfirst tp % lfirst = . true . call tp % step ( system , param , outer_time , dto ) tp % lfirst = lfirsttp else call tp % step ( system , param , outer_time , dto ) end if do j = 1 , npl if ( pl % nenc ( j ) == 0 ) cycle tp % lfirst = . true . where (( tp % plencP (:) == j ) . and . (. not . tp % lmask (:))) tp % lmask (:) = . true . end where end do end do end associate return end subroutine rmvs_step_out subroutine rmvs_interp_in ( cb , pl , system , param , dt , outer_index ) !! author: David A. Minton !! !! Interpolate planet positions between two Keplerian orbits in inner encounter regio !! !! Adapted from David E. Kaufmann's Swifter routine rmvs_interp_in.f90 !! !! Adapted from Hal Levison's Swift routine rmvs3_interp.f implicit none ! Arguments class ( rmvs_cb ), intent ( inout ) :: cb !! RMVS cenral body object class ( rmvs_pl ), intent ( inout ) :: pl !! RMVS massive body object class ( rmvs_nbody_system ), intent ( inout ) :: system !! RMVS nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Swiftest parameters file real ( DP ), intent ( in ) :: dt !! Step size integer ( I4B ), intent ( in ) :: outer_index !! Outer substep number within current set ! Internals integer ( I4B ) :: i , inner_index real ( DP ) :: frac , dntphenc real ( DP ), dimension (:,:), allocatable :: xtmp , vtmp , xh_original real ( DP ), dimension (:), allocatable :: GMcb , dti integer ( I4B ), dimension (:), allocatable :: iflag associate ( npl => system % pl % nbody ) dntphenc = real ( NTPHENC , kind = DP ) ! Set the endpoints of the inner region from the outer region values in the current outer step index pl % inner ( 0 )% x (:,:) = pl % outer ( outer_index - 1 )% x (:, :) pl % inner ( 0 )% v (:,:) = pl % outer ( outer_index - 1 )% v (:, :) pl % inner ( NTPHENC )% x (:,:) = pl % outer ( outer_index )% x (:, :) pl % inner ( NTPHENC )% v (:,:) = pl % outer ( outer_index )% v (:, :) allocate ( xtmp , mold = pl % xh ) allocate ( vtmp , mold = pl % vh ) allocate ( GMcb ( npl )) allocate ( dti ( npl )) allocate ( iflag ( npl )) dti (:) = dt / dntphenc GMcb (:) = cb % Gmass xtmp (:, :) = pl % inner ( 0 )% x (:, :) vtmp (:, :) = pl % inner ( 0 )% v (:, :) if (( param % loblatecb ) . or . ( param % ltides )) then allocate ( xh_original , source = pl % xh ) pl % xh (:, :) = xtmp (:, :) ! Temporarily replace heliocentric position with inner substep values to calculate the oblateness terms end if if ( param % loblatecb ) then call pl % accel_obl ( system ) pl % inner ( 0 )% aobl (:, :) = pl % aobl (:, :) ! Save the oblateness acceleration on the planet for this substep end if if ( param % ltides ) then call pl % accel_tides ( system ) pl % inner ( 0 )% atide (:, :) = pl % atide (:, :) ! Save the oblateness acceleration on the planet for this substep end if do inner_index = 1 , NTPHENC - 1 call drift_one ( GMcb ( 1 : npl ), xtmp ( 1 , 1 : npl ), xtmp ( 2 , 1 : npl ), xtmp ( 3 , 1 : npl ), & vtmp ( 1 , 1 : npl ), vtmp ( 2 , 1 : npl ), vtmp ( 3 , 1 : npl ), & dti ( 1 : npl ), iflag ( 1 : npl )) if ( any ( iflag ( 1 : npl ) /= 0 )) then do i = 1 , npl if ( iflag ( i ) /= 0 ) then write ( * , * ) \" Planet \" , pl % id ( i ), \" is lost!!!!!!!!!!\" write ( * , * ) GMcb ( i ), dti ( i ) write ( * , * ) xtmp (:, i ) write ( * , * ) vtmp (:, i ) write ( * , * ) \" STOPPING \" call util_exit ( failure ) end if end do end if frac = 1.0_DP - inner_index / dntphenc pl % inner ( inner_index )% x (:, :) = frac * xtmp (:,:) pl % inner ( inner_index )% v (:, :) = frac * vtmp (:,:) end do xtmp (:,:) = pl % inner ( NTPHENC )% x (:, :) vtmp (:,:) = pl % inner ( NTPHENC )% v (:, :) do inner_index = NTPHENC - 1 , 1 , - 1 call drift_one ( GMcb ( 1 : npl ), xtmp ( 1 , 1 : npl ), xtmp ( 2 , 1 : npl ), xtmp ( 3 , 1 : npl ), & vtmp ( 1 , 1 : npl ), vtmp ( 2 , 1 : npl ), vtmp ( 3 , 1 : npl ), & - dti ( 1 : npl ), iflag ( 1 : npl )) if ( any ( iflag ( 1 : npl ) /= 0 )) then do i = 1 , npl if ( iflag ( i ) /= 0 ) then write ( * , * ) \" Planet \" , pl % id ( i ), \" is lost!!!!!!!!!!\" write ( * , * ) GMcb ( i ), - dti ( i ) write ( * , * ) xtmp (:, i ) write ( * , * ) vtmp (:, i ) write ( * , * ) \" STOPPING \" call util_exit ( failure ) end if end do end if frac = inner_index / dntphenc pl % inner ( inner_index )% x (:, :) = pl % inner ( inner_index )% x (:, :) + frac * xtmp (:, :) pl % inner ( inner_index )% v (:, :) = pl % inner ( inner_index )% v (:, :) + frac * vtmp (:, :) if ( param % loblatecb ) then pl % xh (:,:) = pl % inner ( inner_index )% x (:, :) call pl % accel_obl ( system ) pl % inner ( inner_index )% aobl (:, :) = pl % aobl (:, :) end if if ( param % ltides ) then call pl % accel_tides ( system ) pl % inner ( inner_index )% atide (:, :) = pl % atide (:, :) end if end do if ( param % loblatecb ) then ! Calculate the final value of oblateness accelerations at the final inner substep pl % xh (:,:) = pl % inner ( NTPHENC )% x (:, :) call pl % accel_obl ( system ) pl % inner ( NTPHENC )% aobl (:, :) = pl % aobl (:, :) end if if ( param % ltides ) then call pl % accel_tides ( system ) pl % inner ( NTPHENC )% atide (:, :) = pl % atide (:, :) end if ! Put the planet positions back into place if ( allocated ( xh_original )) call move_alloc ( xh_original , pl % xh ) end associate return end subroutine rmvs_interp_in subroutine rmvs_step_in ( cb , pl , tp , param , outer_time , dto ) !! author: David A. Minton !! !! Step active test particles ahead in the inner encounter region !! !! Adapted from Hal Levison's Swift routine rmvs3_step_in.f !! Adapted from David E. Kaufmann's Swifter routine rmvs_step_in.f90 implicit none ! Arguments class ( rmvs_cb ), intent ( inout ) :: cb !! RMVS central body object class ( rmvs_pl ), intent ( inout ) :: pl !! RMVS massive body object class ( rmvs_tp ), intent ( inout ) :: tp !! RMVS test particle object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: outer_time !! Current time real ( DP ), intent ( in ) :: dto !! Outer step size ! Internals logical :: lfirsttp integer ( I4B ) :: i , j , ipleP real ( DP ) :: dti , inner_time associate ( npl => pl % nbody ) dti = dto / NTPHENC call rmvs_make_planetocentric ( param , cb , pl , tp ) do i = 1 , npl if ( pl % nenc ( i ) == 0 ) cycle select type ( planetocen_system => pl % planetocentric ( i )) class is ( rmvs_nbody_system ) select type ( cbenci => planetocen_system % cb ) class is ( rmvs_cb ) select type ( plenci => planetocen_system % pl ) class is ( rmvs_pl ) select type ( tpenci => planetocen_system % tp ) class is ( rmvs_tp ) associate ( inner_index => tpenci % index ) ! There are inner encounters with this planet...switch to planetocentric coordinates to proceed tpenci % lfirst = . true . inner_time = outer_time call rmvs_peri_tp ( tpenci , pl , inner_time , dti , . true ., 0 , i , param ) ! now step the encountering test particles fully through the inner encounter lfirsttp = . true . do inner_index = 1 , NTPHENC ! Integrate over the encounter region, using the \"substitute\" planetocentric systems at each level plenci % xh (:,:) = plenci % inner ( inner_index - 1 )% x (:,:) call plenci % set_beg_end ( xbeg = plenci % inner ( inner_index - 1 )% x , & xend = plenci % inner ( inner_index )% x ) if ( param % loblatecb ) then cbenci % aoblbeg = cbenci % inner ( inner_index - 1 )% aobl (:, 1 ) cbenci % aoblend = cbenci % inner ( inner_index )% aobl (:, 1 ) end if if ( param % ltides ) then cbenci % atidebeg = cbenci % inner ( inner_index - 1 )% atide (:, 1 ) cbenci % atideend = cbenci % inner ( inner_index )% atide (:, 1 ) end if call tpenci % step ( planetocen_system , param , inner_time , dti ) do j = 1 , pl % nenc ( i ) tpenci % xheliocentric (:, j ) = tpenci % xh (:, j ) + pl % inner ( inner_index )% x (:, i ) end do inner_time = outer_time + j * dti call rmvs_peri_tp ( tpenci , pl , inner_time , dti , . false ., inner_index , i , param ) end do tpenci % lmask (:) = . false . end associate end select end select end select end select end do call rmvs_end_planetocentric ( pl , tp ) end associate return end subroutine rmvs_step_in subroutine rmvs_make_planetocentric ( param , cb , pl , tp ) !! author: David A. Minton !! !! When encounters are detected, this method will call the interpolation methods for the planets and !! creates a Swiftest test particle structure for each planet's encountering test particles to simplify the !! planetocentric calculations. This subroutine is not based on an existing one from Swift and Swifter !! implicit none ! Arguments class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration paramete class ( rmvs_cb ), intent ( inout ) :: cb !! RMVS central body object class ( rmvs_pl ), intent ( inout ) :: pl !! RMVS massive body object class ( rmvs_tp ), intent ( inout ) :: tp !! RMVS test particle object ! Internals integer ( I4B ) :: i , j , inner_index , ipc2hc logical , dimension (:), allocatable :: encmask associate ( npl => pl % nbody , ntp => tp % nbody ) do i = 1 , npl if ( pl % nenc ( i ) == 0 ) cycle ! There are inner encounters with this planet if ( allocated ( encmask )) deallocate ( encmask ) allocate ( encmask ( ntp )) encmask (:) = tp % plencP (:) == i allocate ( rmvs_tp :: pl % planetocentric ( i )% tp ) ! Create encountering test particle structure select type ( cbenci => pl % planetocentric ( i )% cb ) class is ( rmvs_cb ) select type ( plenci => pl % planetocentric ( i )% pl ) class is ( rmvs_pl ) select type ( tpenci => pl % planetocentric ( i )% tp ) class is ( rmvs_tp ) tpenci % lplanetocentric = . true . call tpenci % setup ( pl % nenc ( i ), param ) tpenci % cb_heliocentric = cb tpenci % ipleP = i tpenci % lmask (:) = . true . tpenci % status (:) = ACTIVE ! Grab all the encountering test particles and convert them to a planetocentric frame tpenci % id (:) = pack ( tp % id (:), encmask (:)) do j = 1 , NDIM tpenci % xheliocentric ( j , :) = pack ( tp % xh ( j ,:), encmask (:)) tpenci % xh ( j , :) = tpenci % xheliocentric ( j , :) - pl % inner ( 0 )% x ( j , i ) tpenci % vh ( j , :) = pack ( tp % vh ( j ,:), encmask (:)) - pl % inner ( 0 )% v ( j , i ) end do tpenci % lperi (:) = pack ( tp % lperi (:), encmask (:)) tpenci % plperP (:) = pack ( tp % plperP (:), encmask (:)) ! Make sure that the test particles get the planetocentric value of mu allocate ( cbenci % inner ( 0 : NTPHENC )) do inner_index = 0 , NTPHENC allocate ( plenci % inner ( inner_index )% x , mold = pl % inner ( inner_index )% x ) allocate ( plenci % inner ( inner_index )% v , mold = pl % inner ( inner_index )% x ) allocate ( cbenci % inner ( inner_index )% x ( NDIM , 1 )) allocate ( cbenci % inner ( inner_index )% v ( NDIM , 1 )) cbenci % inner ( inner_index )% x (:, 1 ) = pl % inner ( inner_index )% x (:, i ) cbenci % inner ( inner_index )% v (:, 1 ) = pl % inner ( inner_index )% v (:, i ) plenci % inner ( inner_index )% x (:, 1 ) = - cbenci % inner ( inner_index )% x (:, 1 ) plenci % inner ( inner_index )% v (:, 1 ) = - cbenci % inner ( inner_index )% v (:, 1 ) if ( param % loblatecb ) then allocate ( plenci % inner ( inner_index )% aobl , mold = pl % inner ( inner_index )% aobl ) allocate ( cbenci % inner ( inner_index )% aobl ( NDIM , 1 )) cbenci % inner ( inner_index )% aobl (:, 1 ) = pl % inner ( inner_index )% aobl (:, i ) end if if ( param % ltides ) then allocate ( plenci % inner ( inner_index )% atide , mold = pl % inner ( inner_index )% atide ) allocate ( cbenci % inner ( inner_index )% atide ( NDIM , 1 )) cbenci % inner ( inner_index )% atide (:, 1 ) = pl % inner ( inner_index )% atide (:, i ) end if do j = 2 , npl ipc2hc = plenci % plind ( j ) plenci % inner ( inner_index )% x (:, j ) = pl % inner ( inner_index )% x (:, ipc2hc ) - cbenci % inner ( inner_index )% x (:, 1 ) plenci % inner ( inner_index )% v (:, j ) = pl % inner ( inner_index )% v (:, ipc2hc ) - cbenci % inner ( inner_index )% v (:, 1 ) end do end do call tpenci % set_mu ( cbenci ) end select end select end select end do end associate return end subroutine rmvs_make_planetocentric subroutine rmvs_peri_tp ( tp , pl , t , dt , lfirst , inner_index , ipleP , param ) !! author: David A. Minton !! !! Determine planetocentric pericenter passages for test particles in close encounters with a planet !! !! Adapted from Hal Levison's Swift routine Adapted from Hal Levison's Swift routine util_peri.f !! Adapted from David E. Kaufmann's Swifter routine rmvs_peri.f90 implicit none ! Arguments class ( rmvs_tp ), intent ( inout ) :: tp !! RMVS test particle object (planetocentric) class ( rmvs_pl ), intent ( inout ) :: pl !! RMVS massive body object (heliocentric) real ( DP ), intent ( in ) :: t !! current time real ( DP ), intent ( in ) :: dt !! step size logical , intent ( in ) :: lfirst !! Logical flag indicating whether current invocation is the first integer ( I4B ), intent ( in ) :: inner_index !! Outer substep number within current set integer ( I4B ), intent ( in ) :: ipleP !!  index of RMVS planet being closely encountered class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i , id1 , id2 real ( DP ) :: r2 , mu , rhill2 , vdotr , a , peri , capm , tperi , rpl real ( DP ), dimension ( NDIM ) :: xh1 , xh2 , vh1 , vh2 rhill2 = pl % rhill ( ipleP ) ** 2 mu = pl % Gmass ( ipleP ) associate ( nenc => tp % nbody , xpc => tp % xh , vpc => tp % vh ) if ( lfirst ) then do i = 1 , nenc if ( tp % lmask ( i )) then vdotr = dot_product ( xpc (:, i ), vpc (:, i )) if ( vdotr > 0.0_DP ) then tp % isperi ( i ) = 1 else tp % isperi ( i ) = - 1 end if end if end do else do i = 1 , nenc if ( tp % lmask ( i )) then vdotr = dot_product ( xpc (:, i ), vpc (:, i )) if ( tp % isperi ( i ) == - 1 ) then if ( vdotr >= 0.0_DP ) then tp % isperi ( i ) = 0 call orbel_xv2aqt ( mu , xpc (:, i ), vpc (:, i ), a , peri , capm , tperi ) r2 = dot_product ( xpc (:, i ), xpc (:, i )) if (( abs ( tperi ) > FACQDT * dt ) . or . ( r2 > rhill2 )) peri = sqrt ( r2 ) if ( param % enc_out /= \"\" ) then id1 = pl % id ( ipleP ) rpl = pl % radius ( ipleP ) xh1 (:) = pl % inner ( inner_index )% x (:, ipleP ) vh1 (:) = pl % inner ( inner_index )% v (:, ipleP ) id2 = tp % id ( i ) xh2 (:) = xpc (:, i ) + xh1 (:) vh2 (:) = xpc (:, i ) + vh1 (:) call io_write_encounter ( t , id1 , id2 , mu , 0.0_DP , rpl , 0.0_DP , xh1 (:), xh2 (:), vh1 (:), vh2 (:), & param % enc_out , param % out_type ) end if if ( tp % lperi ( i )) then if ( peri < tp % peri ( i )) then tp % peri ( i ) = peri tp % plperP ( i ) = ipleP end if else tp % lperi ( i ) = . true . tp % peri ( i ) = peri tp % plperP ( i ) = ipleP end if end if else if ( vdotr > 0.0_DP ) then tp % isperi ( i ) = 1 else tp % isperi ( i ) = - 1 end if end if end if end do end if end associate return end subroutine rmvs_peri_tp subroutine rmvs_end_planetocentric ( pl , tp ) !! author: David A. Minton !! !! Deallocates all of the encountering particle data structures for next time !! implicit none ! Arguments class ( rmvs_pl ), intent ( inout ) :: pl !! RMVS massive body object class ( rmvs_tp ), intent ( inout ) :: tp !! RMVS test particle objec ! Internals integer ( I4B ) :: i , j , inner_index integer ( I4B ), dimension (:), allocatable :: tpind logical , dimension (:), allocatable :: encmask associate ( npl => pl % nbody , ntp => tp % nbody ) do i = 1 , npl if ( pl % nenc ( i ) == 0 ) cycle select type ( cbenci => pl % planetocentric ( i )% cb ) class is ( rmvs_cb ) select type ( plenci => pl % planetocentric ( i )% pl ) class is ( rmvs_pl ) select type ( tpenci => pl % planetocentric ( i )% tp ) class is ( rmvs_tp ) if ( allocated ( tpind )) deallocate ( tpind ) allocate ( tpind ( pl % nenc ( i ))) ! Index array of encountering test particles if ( allocated ( encmask )) deallocate ( encmask ) allocate ( encmask ( ntp )) encmask (:) = tp % plencP (:) == i tpind (:) = pack ([( j , j = 1 , ntp )], encmask (:)) ! Copy the results of the integration back over and shift back to heliocentric reference tp % status ( tpind ( 1 : pl % nenc ( i ))) = tpenci % status ( 1 : pl % nenc ( i )) tp % lmask ( tpind ( 1 : pl % nenc ( i ))) = tpenci % lmask ( 1 : pl % nenc ( i )) do j = 1 , NDIM tp % xh ( j , tpind ( 1 : pl % nenc ( i ))) = tpenci % xh ( j , 1 : pl % nenc ( i )) + pl % inner ( NTPHENC )% x ( j , i ) tp % vh ( j , tpind ( 1 : pl % nenc ( i ))) = tpenci % vh ( j , 1 : pl % nenc ( i )) + pl % inner ( NTPHENC )% v ( j , i ) end do tp % lperi ( tpind ( 1 : pl % nenc ( i ))) = tpenci % lperi ( 1 : pl % nenc ( i )) tp % plperP ( tpind ( 1 : pl % nenc ( i ))) = tpenci % plperP ( 1 : pl % nenc ( i )) deallocate ( pl % planetocentric ( i )% tp ) deallocate ( cbenci % inner ) do inner_index = 0 , NTPHENC deallocate ( plenci % inner ( inner_index )% x ) deallocate ( plenci % inner ( inner_index )% v ) if ( allocated ( plenci % inner ( inner_index )% aobl )) deallocate ( plenci % inner ( inner_index )% aobl ) if ( allocated ( plenci % inner ( inner_index )% atide )) deallocate ( plenci % inner ( inner_index )% atide ) end do end select end select end select end do end associate return end subroutine rmvs_end_planetocentric end submodule s_rmvs_step","tags":"","loc":"sourcefile/rmvs_step.f90.html"},{"title":"rmvs_encounter_check.f90 – swiftest","text":"This file depends on sourcefile~~rmvs_encounter_check.f90~~EfferentGraph sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_rmvs_chk Source Code rmvs_encounter_check.f90 Source Code submodule ( rmvs_classes ) s_rmvs_chk use swiftest contains module function rmvs_encounter_check_tp ( self , system , dt ) result ( lencounter ) !! author: David A. Minton !! !! Determine whether a test particle and planet are having or will have an encounter within the next time step !! !! Adapted from David E. Kaufmann's Swifter routine: rmvs_chk.f90 !! Adapted from Hal Levison's Swift routine rmvs3_chk.f implicit none ! Arguments class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object class ( rmvs_nbody_system ), intent ( inout ) :: system !! RMVS nbody system object real ( DP ), intent ( in ) :: dt !! step size ! Result logical :: lencounter !! Returns true if there is at least one close encounter ! Internals integer ( I4B ) :: i , j real ( DP ) :: r2 , v2 , vdotr real ( DP ), dimension ( NDIM ) :: xr , vr real ( DP ), dimension ( system % pl % nbody ) :: r2crit logical :: lflag if ( self % nbody == 0 ) return select type ( pl => system % pl ) class is ( rmvs_pl ) associate ( tp => self , ntp => self % nbody , npl => pl % nbody , rts => system % rts ) r2crit (:) = ( rts * pl % rhill (:)) ** 2 tp % plencP (:) = 0 do j = 1 , npl do i = 1 , ntp if ((. not . tp % lmask ( i )). or .( tp % plencP ( i ) /= 0 )) cycle xr (:) = tp % xh (:, i ) - pl % xbeg (:, j ) vr (:) = tp % vh (:, i ) - pl % vbeg (:, j ) r2 = dot_product ( xr (:), xr (:)) v2 = dot_product ( vr (:), vr (:)) vdotr = dot_product ( vr (:), xr (:)) lflag = rmvs_chk_ind ( r2 , v2 , vdotr , dt , r2crit ( j )) if ( lflag ) tp % plencP ( i ) = j end do pl % nenc ( j ) = count ( tp % plencP (:) == j ) end do lencounter = any ( pl % nenc (:) > 0 ) end associate end select return end function rmvs_encounter_check_tp module elemental function rmvs_chk_ind ( r2 , v2 , vdotr , dt , r2crit ) result ( lflag ) !! author: David A. Minton !! !! Determine whether a test particle and planet are having or will have an encounter within the next time step !! !! Adapted from David E. Kaufmann's Swifter routine: rmvs_chk_ind.f90 !! Adapted from Hal Levison's Swift routine rmvs_chk_ind.f implicit none ! Arguments real ( DP ), intent ( in ) :: r2 , v2 , vdotr , dt , r2crit logical :: lflag ! Internals real ( DP ) :: tmin , r2min lflag = . false . if ( r2 < r2crit ) then lflag = . true . else if ( vdotr < 0.0_DP ) then tmin = - vdotr / v2 if ( tmin < dt ) then r2min = r2 - vdotr ** 2 / v2 else r2min = r2 + 2 * vdotr * dt + v2 * dt ** 2 end if r2min = min ( r2min , r2 ) lflag = ( r2min <= r2crit ) end if end if return end function rmvs_chk_ind end submodule s_rmvs_chk","tags":"","loc":"sourcefile/rmvs_encounter_check.f90.html"},{"title":"tides_derivs_func – swiftest ","text":"type, extends(lambda_obj_tvar) :: tides_derivs_func Base class for an lambda function object. This object takes no additional arguments other than the dependent variable x, an array of real numbers Inherits type~~tides_derivs_func~~InheritsGraph type~tides_derivs_func tides_derivs_func lambda_obj_tvar lambda_obj_tvar type~tides_derivs_func->lambda_obj_tvar Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lambdaptr_tides_deriv xbeg xend dt Type-Bound Procedures init evalt tides_derivs_init Components Type Visibility Attributes Name Initial procedure( tidederiv ), public, pointer, nopass :: lambdaptr_tides_deriv real(kind=DP), public, dimension(:,:), allocatable :: xbeg real(kind=DP), public, dimension(:,:), allocatable :: xend real(kind=DP), public :: dt Type-Bound Procedures generic, public :: init => tides_derivs_init function tides_derivs_init (lambda, dt, xbeg, xend) result(f) Arguments Type Intent Optional Attributes Name procedure( tidederiv ) :: lambda real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), dimension(:,:) :: xbeg real(kind=DP), intent(in), dimension(:,:) :: xend Return Value type( tides_derivs_func ) procedure, public :: evalt => tides_derivs_eval function tides_derivs_eval (self, x, t) result(y) Arguments Type Intent Optional Attributes Name class( tides_derivs_func ), intent(inout) :: self real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in) :: t Return Value real(kind=DP),\n  dimension(:), allocatable procedure, public, nopass :: tides_derivs_init function tides_derivs_init (lambda, dt, xbeg, xend) result(f) Arguments Type Intent Optional Attributes Name procedure( tidederiv ) :: lambda real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), dimension(:,:) :: xbeg real(kind=DP), intent(in), dimension(:,:) :: xend Return Value type( tides_derivs_func )","tags":"","loc":"type/tides_derivs_func.html"},{"title":"rmvs_nbody_system – swiftest ","text":"type, public, extends( whm_nbody_system ) :: rmvs_nbody_system Inherits type~~rmvs_nbody_system~~InheritsGraph type~rmvs_nbody_system rmvs_nbody_system type~whm_nbody_system whm_nbody_system type~rmvs_nbody_system->type~whm_nbody_system type~swiftest_nbody_system swiftest_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~swiftest_cb swiftest_cb type~swiftest_nbody_system->type~swiftest_cb cb type~swiftest_base swiftest_base type~swiftest_nbody_system->type~swiftest_base type~swiftest_tp swiftest_tp type~swiftest_nbody_system->type~swiftest_tp tp, tp_discards type~swiftest_pl swiftest_pl type~swiftest_nbody_system->type~swiftest_pl pl, pl_discards type~swiftest_cb->type~swiftest_base type~swiftest_body swiftest_body type~swiftest_tp->type~swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~rmvs_nbody_system~~InheritedByGraph type~rmvs_nbody_system rmvs_nbody_system type~rmvs_pl rmvs_pl type~rmvs_pl->type~rmvs_nbody_system planetocentric Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate cb pl tp tp_discards pl_discards Gmtot ke_orbit ke_spin pe te Lorbit Lspin Lescape Mescape Ecollisions Euntracked lbeg maxid lplanetocentric rts vbeg Type-Bound Procedures discard conservation_report dump read_frame write_discard write_frame step_spin set_msys get_energy_and_momentum rescale validate_ids initialize step Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step class( swiftest_cb ), public, allocatable :: cb Central body data structure class( swiftest_pl ), public, allocatable :: pl Massive body data structure class( swiftest_tp ), public, allocatable :: tp Test particle data structure class( swiftest_tp ), public, allocatable :: tp_discards Discarded test particle data structure class( swiftest_pl ), public, allocatable :: pl_discards Discarded massive body particle data structure real(kind=DP), public :: Gmtot = 0.0_DP Total system mass - used for barycentric coordinate conversion real(kind=DP), public :: ke_orbit = 0.0_DP System orbital kinetic energy real(kind=DP), public :: ke_spin = 0.0_DP System spin kinetic energy real(kind=DP), public :: pe = 0.0_DP System potential energy real(kind=DP), public :: te = 0.0_DP System total energy real(kind=DP), public, dimension(NDIM) :: Lorbit = 0.0_DP System orbital angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lspin = 0.0_DP System spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lescape = 0.0_DP Angular momentum of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Mescape = 0.0_DP Mass of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Ecollisions = 0.0_DP Energy lost from system due to collisions real(kind=DP), public :: Euntracked = 0.0_DP Energy gained from system due to escaped bodies logical, public :: lbeg True if this is the beginning of a step. This is used so that test particle steps can be calculated \n    separately from massive bodies.  Massive body variables are saved at half steps, and passed to \n    the test particles integer(kind=I4B), public :: maxid = -1 The current maximum particle id number logical, public :: lplanetocentric = .false. In the RMVS integrator, only test particles are discarded\n Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations real(kind=DP), public :: rts fraction of Hill's sphere radius to use as radius of encounter region real(kind=DP), public, dimension(:,:), allocatable :: vbeg Planet velocities at beginning ot step Type-Bound Procedures procedure, public :: discard => discard_system Perform a discard step on the system interface public module subroutine discard_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: conservation_report => io_conservation_report Compute energy and momentum and print out the change with time interface public module subroutine io_conservation_report(self, param, lterminal) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Input colleciton of user-defined parameters logical, intent(in) :: lterminal Indicates whether to output information to the terminal screen procedure, public :: dump => io_dump_system Dump the state of the system to a file interface public module subroutine io_dump_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_system Read in a frame of input data from file interface public module subroutine io_read_frame_system(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_discard => io_write_discard Write out information about discarded test particles interface public module subroutine io_write_discard(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_frame => io_write_frame_system Append a frame of output data to file interface public module subroutine io_write_frame_system(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: step_spin => tides_step_spin_system Steps the spins of the massive & central bodies due to tides. interface public module subroutine tides_step_spin_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure, public :: set_msys => util_set_msys Sets the value of msys from the masses of system bodies. interface public module subroutine util_set_msys(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object procedure, public :: get_energy_and_momentum => util_get_energy_momentum_system Calculates the total system energy and momentum interface public module subroutine util_get_energy_momentum_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: rescale => util_rescale_system Rescales the system into a new set of units interface public module subroutine util_rescale_system(self, param, mscale, dscale, tscale) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters. Returns with new values of the scale vactors and GU real(kind=DP), intent(in) :: mscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: dscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: tscale Scale factors for mass, distance, and time units, respectively. procedure, public :: validate_ids => util_valid_id_system Validate the numerical ids passed to the system and save the maximum value interface public module subroutine util_valid_id_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: initialize => rmvs_setup_initialize_system Replace the abstract procedures with concrete ones\n Performs RMVS-specific initilization steps, including generating the close encounter planetocentric structures interface public module subroutine rmvs_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_nbody_system ), intent(inout) :: self RMVS system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters procedure, public :: step => rmvs_step_system Advance the RMVS nbody system forward in time by one step interface public module subroutine rmvs_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_nbody_system ), intent(inout) :: self RMVS nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"type/rmvs_nbody_system.html"},{"title":"rmvs_interp – swiftest ","text":"type, private :: rmvs_interp Inherited by type~~rmvs_interp~~InheritedByGraph type~rmvs_interp rmvs_interp type~rmvs_pl rmvs_pl type~rmvs_pl->type~rmvs_interp outer, inner type~rmvs_cb rmvs_cb type~rmvs_cb->type~rmvs_interp outer, inner type~rmvs_tp rmvs_tp type~rmvs_tp->type~rmvs_cb cb_heliocentric Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables x v aobl atide Components Type Visibility Attributes Name Initial real(kind=DP), public, dimension(:, :), allocatable :: x interpolated heliocentric planet position for outer encounter real(kind=DP), public, dimension(:, :), allocatable :: v interpolated heliocentric planet velocity for outer encounter real(kind=DP), public, dimension(:, :), allocatable :: aobl Encountering planet's oblateness acceleration value real(kind=DP), public, dimension(:, :), allocatable :: atide Encountering planet's tidal acceleration value","tags":"","loc":"type/rmvs_interp.html"},{"title":"rmvs_cb – swiftest ","text":"type, public, extends( whm_cb ) :: rmvs_cb RMVS central body particle class Inherits type~~rmvs_cb~~InheritsGraph type~rmvs_cb rmvs_cb type~whm_cb whm_cb type~rmvs_cb->type~whm_cb type~rmvs_interp rmvs_interp type~rmvs_cb->type~rmvs_interp outer, inner type~swiftest_cb swiftest_cb type~whm_cb->type~swiftest_cb type~swiftest_base swiftest_base type~swiftest_cb->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~rmvs_cb~~InheritedByGraph type~rmvs_cb rmvs_cb type~rmvs_tp rmvs_tp type~rmvs_tp->type~rmvs_cb cb_heliocentric Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate name id mass Gmass radius density j2rp2 j4rp4 aobl atide aoblbeg aoblend atidebeg atideend xb vb agr Ip rot k2 Q tlag L0 dL outer inner lplanetocentric Type-Bound Procedures dump initialize read_frame write_frame Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step character(len=STRMAX), public :: name Non-unique name integer(kind=I4B), public :: id = 0 External identifier (unique) real(kind=DP), public :: mass = 0.0_DP Central body mass (units MU) real(kind=DP), public :: Gmass = 0.0_DP Central mass gravitational term G * mass (units GU * MU) real(kind=DP), public :: radius = 0.0_DP Central body radius (units DU) real(kind=DP), public :: density = 1.0_DP Central body mass density - calculated internally (units MU / DU**3) real(kind=DP), public :: j2rp2 = 0.0_DP J2*R&#94;2 term for central body real(kind=DP), public :: j4rp4 = 0.0_DP J4*R&#94;2 term for central body real(kind=DP), public, dimension(NDIM) :: aobl = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: atide = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: aoblbeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: aoblend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: atidebeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: atideend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: xb = 0.0_DP Barycentric position (units DU) real(kind=DP), public, dimension(NDIM) :: vb = 0.0_DP Barycentric velocity (units DU / TU) real(kind=DP), public, dimension(NDIM) :: agr = 0.0_DP Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(NDIM) :: Ip = 0.0_DP Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(NDIM) :: rot = 0.0_DP Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public :: k2 = 0.0_DP Tidal Love number real(kind=DP), public :: Q = 0.0_DP Tidal quality factor real(kind=DP), public :: tlag = 0.0_DP Tidal phase lag angle real(kind=DP), public, dimension(NDIM) :: L0 = 0.0_DP Initial angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: dL = 0.0_DP Change in angular momentum of the central body type( rmvs_interp ), public, dimension(:), allocatable :: outer interpolated heliocentric central body position for outer encounters type( rmvs_interp ), public, dimension(:), allocatable :: inner interpolated heliocentric central body position for inner encounters logical, public :: lplanetocentric = .false. Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations Type-Bound Procedures procedure, public :: dump => io_dump_swiftest interface public module subroutine io_dump_swiftest(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: initialize => io_read_cb_in I/O routine for reading in central body data interface public module subroutine io_read_cb_in(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_cb I/O routine for reading out a single frame of time-series data for the central body interface public module subroutine io_read_frame_cb(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_frame => io_write_frame_cb I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_cb(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"type/rmvs_cb.html"},{"title":"rmvs_tp – swiftest ","text":"type, public, extends( whm_tp ) :: rmvs_tp Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the\n    component list, such as rmvs_setup_tp and rmvs_util_spill_tp Inherits type~~rmvs_tp~~InheritsGraph type~rmvs_tp rmvs_tp type~rmvs_cb rmvs_cb type~rmvs_tp->type~rmvs_cb cb_heliocentric type~whm_tp whm_tp type~rmvs_tp->type~whm_tp type~whm_cb whm_cb type~rmvs_cb->type~whm_cb type~rmvs_interp rmvs_interp type~rmvs_cb->type~rmvs_interp outer, inner type~swiftest_tp swiftest_tp type~whm_tp->type~swiftest_tp type~swiftest_cb swiftest_cb type~whm_cb->type~swiftest_cb type~swiftest_body swiftest_body type~swiftest_tp->type~swiftest_body type~swiftest_base swiftest_base type~swiftest_cb->type~swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate lfirst nbody name id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm isperi peri atp lperi plperP plencP cb_heliocentric xheliocentric index ipleP lplanetocentric Type-Bound Procedures dump drift v2pv pv2v initialize read_frame write_frame el2xv xv2el accel_user set_ir3 accel_int accel_obl h2b b2h get_peri set_mu accel_gr gr_pos_kick kick step discard encounter_check accel setup append fill resize sort rearrange spill Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill integer(kind=I4B), public, dimension(:), allocatable :: isperi Perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri Perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp Semimajor axis following perihelion passage\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_tp and util_spill_tp logical, public, dimension(:), allocatable :: lperi planetocentric pericenter passage flag (persistent for a full rmvs time step) over a full RMVS time step) integer(kind=I4B), public, dimension(:), allocatable :: plperP index of planet associated with pericenter distance peri (persistent over a full RMVS time step) integer(kind=I4B), public, dimension(:), allocatable :: plencP index of planet that test particle is encountering (not persistent for a full RMVS time step) type( rmvs_cb ), public :: cb_heliocentric Copy of original central body object passed to close encounter (used for oblateness acceleration during planetocentric encoountters) real(kind=DP), public, dimension(:,:), allocatable :: xheliocentric original heliocentric position (used for oblateness calculation during close encounters) integer(kind=I4B), public :: index inner substep number within current set integer(kind=I4B), public :: ipleP index value of encountering planet logical, public :: lplanetocentric = .false. Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations Type-Bound Procedures procedure, public :: dump => io_dump_swiftest interface public module subroutine io_dump_swiftest(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables interface public module subroutine drift_body(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file interface public module subroutine io_read_body_in(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_read_frame_body(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object procedure, public :: accel_int => kick_getacch_int_tp Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies interface public pure module subroutine kick_getacch_int_tp(self, GMpl, xhp, npl) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle real(kind=DP), intent(in), dimension(:) :: GMpl Massive body masses real(kind=DP), intent(in), dimension(:,:) :: xhp Massive body position vectors integer(kind=I4B), intent(in) :: npl Number of active massive bodies procedure, public :: accel_obl => obl_acc_tp Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_tp(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: h2b => util_coord_h2b_tp Convert test particles from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_tp Convert test particles from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: get_peri => util_peri_tp Determine system pericenter passages for test particles interface public module subroutine util_peri_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: set_mu => util_set_mu_tp Method used to construct the vectorized form of the central body mass interface public module subroutine util_set_mu_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_gr => whm_gr_kick_getacch_tp Acceleration term arising from the post-Newtonian correction interface public module subroutine whm_gr_kick_getacch_tp(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: gr_pos_kick => whm_gr_p4_tp Position kick due to p**4 term in the post-Newtonian correction interface public pure module subroutine whm_gr_p4_tp(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size procedure, public :: kick => whm_kick_vh_tp Kick heliocentric velocities of test particles interface public module subroutine whm_kick_vh_tp(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure, public :: step => whm_step_tp Steps the particle forward one stepsize interface public module subroutine whm_step_tp(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize procedure, public :: discard => rmvs_discard_tp Check to see if test particles should be discarded based on pericenter passage distances with respect to planets encountered interface public module subroutine rmvs_discard_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters procedure, public :: encounter_check => rmvs_encounter_check_tp Checks if any test particles are undergoing a close encounter with a massive body interface public module function rmvs_encounter_check_tp(self, system, dt) result(lencounter) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class( rmvs_nbody_system ), intent(inout) :: system RMVS nbody system object real(kind=DP), intent(in) :: dt step size Return Value logical Returns true if there is at least one close encounter procedure, public :: accel => rmvs_kick_getacch_tp Calculates either the standard or modified version of the acceleration depending if the\n    if the test particle is undergoing a close encounter or not interface public module subroutine rmvs_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest central body particle data structuree class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step procedure, public :: setup => rmvs_setup_tp Constructor method - Allocates space for the input number of bodiess interface public module subroutine rmvs_setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parametere procedure, public :: append => rmvs_util_append_tp Appends elements from one structure to another interface public module subroutine rmvs_util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: fill => rmvs_util_fill_tp \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine rmvs_util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: resize => rmvs_util_resize_tp Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. interface public module subroutine rmvs_util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: sort => rmvs_util_sort_tp Sorts body arrays by a sortable componen interface public module subroutine rmvs_util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => rmvs_util_sort_rearrange_tp Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine rmvs_util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => rmvs_util_spill_tp \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine rmvs_util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"type/rmvs_tp.html"},{"title":"rmvs_pl – swiftest ","text":"type, public, extends( whm_pl ) :: rmvs_pl RMVS massive body particle class Inherits type~~rmvs_pl~~InheritsGraph type~rmvs_pl rmvs_pl type~rmvs_nbody_system rmvs_nbody_system type~rmvs_pl->type~rmvs_nbody_system planetocentric type~rmvs_interp rmvs_interp type~rmvs_pl->type~rmvs_interp outer, inner type~whm_pl whm_pl type~rmvs_pl->type~whm_pl type~whm_nbody_system whm_nbody_system type~rmvs_nbody_system->type~whm_nbody_system type~swiftest_pl swiftest_pl type~whm_pl->type~swiftest_pl type~swiftest_nbody_system swiftest_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~swiftest_body swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base type~swiftest_nbody_system->type~swiftest_pl pl, pl_discards type~swiftest_cb swiftest_cb type~swiftest_nbody_system->type~swiftest_cb cb type~swiftest_nbody_system->type~swiftest_base type~swiftest_tp swiftest_tp type~swiftest_nbody_system->type~swiftest_tp tp, tp_discards type~swiftest_cb->type~swiftest_base type~swiftest_tp->type~swiftest_body Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate lfirst nbody name id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm mass Gmass rhill radius xbeg xend vbeg density Ip rot k2 Q tlag k_plpl nplpl eta xj vj muj ir3j nenc tpenc1P plind outer inner planetocentric lplanetocentric Type-Bound Procedures dump v2pv pv2v initialize read_frame write_frame el2xv xv2el accel_user discard eucl_index accel_int accel_obl accel_tides h2b b2h set_beg_end set_rhill h2j j2h vh2vj drift accel_gr gr_pos_kick accel kick set_ir3 set_mu step setup append fill resize sort rearrange spill Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl real(kind=DP), public, dimension(:), allocatable :: eta Jacobi mass real(kind=DP), public, dimension(:,:), allocatable :: xj Jacobi position real(kind=DP), public, dimension(:,:), allocatable :: vj Jacobi velocity real(kind=DP), public, dimension(:), allocatable :: muj Jacobi mu: GMcb * eta(i) / eta(i - 1) real(kind=DP), public, dimension(:), allocatable :: ir3j Third term of heliocentric acceleration\n Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the\n    component list, such as whm_setup_pl and whm_util_spill_pl integer(kind=I4B), public, dimension(:), allocatable :: nenc number of test particles encountering planet this full rmvs time step integer(kind=I4B), public, dimension(:), allocatable :: tpenc1P index of first test particle encountering planet integer(kind=I4B), public, dimension(:), allocatable :: plind Connects the planetocentric indices back to the heliocentric planet list type( rmvs_interp ), public, dimension(:), allocatable :: outer interpolated heliocentric central body position for outer encounters type( rmvs_interp ), public, dimension(:), allocatable :: inner interpolated heliocentric central body position for inner encounters class( rmvs_nbody_system ), public, dimension(:), allocatable :: planetocentric Planetocentric version of the massive body objects (one for each massive body) logical, public :: lplanetocentric = .false. Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations Type-Bound Procedures procedure, public :: dump => io_dump_swiftest interface public module subroutine io_dump_swiftest(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file interface public module subroutine io_read_body_in(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_read_frame_body(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: discard => discard_pl Placeholder method for discarding massive bodies interface public module subroutine discard_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameter procedure, public :: eucl_index => eucl_dist_index_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix interface public module subroutine eucl_dist_index_plpl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies interface public pure module subroutine kick_getacch_int_pl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body interface public module subroutine tides_kick_getacch_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. interface public module subroutine util_set_beg_end_pl(self, xbeg, xend, vbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object real(kind=DP), intent(in), optional dimension(:,:) :: xbeg Position vectors at beginning of step real(kind=DP), intent(in), optional dimension(:,:) :: xend Positions vectors at end of step real(kind=DP), intent(in), optional dimension(:,:) :: vbeg vbeg is an unused variable to keep this method forward compatible with RMVS procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body interface public module subroutine util_set_rhill(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: h2j => whm_coord_h2j_pl Convert position and velcoity vectors from heliocentric to Jacobi coordinates interface public module subroutine whm_coord_h2j_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree procedure, public :: j2h => whm_coord_j2h_pl Convert position and velcoity vectors from Jacobi to helliocentric coordinates interface public module subroutine whm_coord_j2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree procedure, public :: vh2vj => whm_coord_vh2vj_pl Convert velocity vectors from heliocentric to Jacobi coordinates interface public module subroutine whm_coord_vh2vj_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree procedure, public :: drift => whm_drift_pl Loop through massive bodies and call Danby drift routine to jacobi coordinates interface public module subroutine whm_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: accel_gr => whm_gr_kick_getacch_pl Acceleration term arising from the post-Newtonian correction interface public module subroutine whm_gr_kick_getacch_pl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: gr_pos_kick => whm_gr_p4_pl Position kick due to p**4 term in the post-Newtonian correction interface public pure module subroutine whm_gr_p4_pl(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size procedure, public :: accel => whm_kick_getacch_pl Compute heliocentric accelerations of massive bodies interface public module subroutine whm_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Get heliocentric accelration of massive bodies Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step procedure, public :: kick => whm_kick_vh_pl Kick heliocentric velocities of massive bodies interface public module subroutine whm_kick_vh_pl(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure, public :: set_ir3 => whm_util_set_ir3j Sets both the heliocentric and jacobi inverse radius terms (1/rj 3 and 1/rh 3) interface public module subroutine whm_util_set_ir3j(self) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object procedure, public :: set_mu => whm_util_set_mu_eta_pl Sets the Jacobi mass value for all massive bodies. interface public module subroutine whm_util_set_mu_eta_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: step => whm_step_pl Steps the body forward one stepsize interface public module subroutine whm_step_pl(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure, public :: setup => rmvs_setup_pl Constructor method - Allocates space for the input number of bodiess interface public module subroutine rmvs_setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: append => rmvs_util_append_pl Appends elements from one structure to another interface public module subroutine rmvs_util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: fill => rmvs_util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine rmvs_util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: resize => rmvs_util_resize_pl Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. interface public module subroutine rmvs_util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: sort => rmvs_util_sort_pl Sorts body arrays by a sortable componen interface public module subroutine rmvs_util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => rmvs_util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine rmvs_util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => rmvs_util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine rmvs_util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"type/rmvs_pl.html"},{"title":"helio_nbody_system – swiftest ","text":"type, public, extends( whm_nbody_system ) :: helio_nbody_system Inherits type~~helio_nbody_system~~InheritsGraph type~helio_nbody_system helio_nbody_system type~whm_nbody_system whm_nbody_system type~helio_nbody_system->type~whm_nbody_system type~swiftest_nbody_system swiftest_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~swiftest_cb swiftest_cb type~swiftest_nbody_system->type~swiftest_cb cb type~swiftest_base swiftest_base type~swiftest_nbody_system->type~swiftest_base type~swiftest_tp swiftest_tp type~swiftest_nbody_system->type~swiftest_tp tp, tp_discards type~swiftest_pl swiftest_pl type~swiftest_nbody_system->type~swiftest_pl pl, pl_discards type~swiftest_cb->type~swiftest_base type~swiftest_body swiftest_body type~swiftest_tp->type~swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~helio_nbody_system~~InheritedByGraph type~helio_nbody_system helio_nbody_system type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~helio_nbody_system Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate cb pl tp tp_discards pl_discards Gmtot ke_orbit ke_spin pe te Lorbit Lspin Lescape Mescape Ecollisions Euntracked lbeg maxid Type-Bound Procedures discard conservation_report dump read_frame write_discard write_frame step_spin set_msys get_energy_and_momentum rescale validate_ids initialize step Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step class( swiftest_cb ), public, allocatable :: cb Central body data structure class( swiftest_pl ), public, allocatable :: pl Massive body data structure class( swiftest_tp ), public, allocatable :: tp Test particle data structure class( swiftest_tp ), public, allocatable :: tp_discards Discarded test particle data structure class( swiftest_pl ), public, allocatable :: pl_discards Discarded massive body particle data structure real(kind=DP), public :: Gmtot = 0.0_DP Total system mass - used for barycentric coordinate conversion real(kind=DP), public :: ke_orbit = 0.0_DP System orbital kinetic energy real(kind=DP), public :: ke_spin = 0.0_DP System spin kinetic energy real(kind=DP), public :: pe = 0.0_DP System potential energy real(kind=DP), public :: te = 0.0_DP System total energy real(kind=DP), public, dimension(NDIM) :: Lorbit = 0.0_DP System orbital angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lspin = 0.0_DP System spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lescape = 0.0_DP Angular momentum of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Mescape = 0.0_DP Mass of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Ecollisions = 0.0_DP Energy lost from system due to collisions real(kind=DP), public :: Euntracked = 0.0_DP Energy gained from system due to escaped bodies logical, public :: lbeg True if this is the beginning of a step. This is used so that test particle steps can be calculated \n    separately from massive bodies.  Massive body variables are saved at half steps, and passed to \n    the test particles integer(kind=I4B), public :: maxid = -1 The current maximum particle id number Type-Bound Procedures procedure, public :: discard => discard_system Perform a discard step on the system interface public module subroutine discard_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: conservation_report => io_conservation_report Compute energy and momentum and print out the change with time interface public module subroutine io_conservation_report(self, param, lterminal) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Input colleciton of user-defined parameters logical, intent(in) :: lterminal Indicates whether to output information to the terminal screen procedure, public :: dump => io_dump_system Dump the state of the system to a file interface public module subroutine io_dump_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_system Read in a frame of input data from file interface public module subroutine io_read_frame_system(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_discard => io_write_discard Write out information about discarded test particles interface public module subroutine io_write_discard(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_frame => io_write_frame_system Append a frame of output data to file interface public module subroutine io_write_frame_system(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: step_spin => tides_step_spin_system Steps the spins of the massive & central bodies due to tides. interface public module subroutine tides_step_spin_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure, public :: set_msys => util_set_msys Sets the value of msys from the masses of system bodies. interface public module subroutine util_set_msys(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object procedure, public :: get_energy_and_momentum => util_get_energy_momentum_system Calculates the total system energy and momentum interface public module subroutine util_get_energy_momentum_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: rescale => util_rescale_system Rescales the system into a new set of units interface public module subroutine util_rescale_system(self, param, mscale, dscale, tscale) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters. Returns with new values of the scale vactors and GU real(kind=DP), intent(in) :: mscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: dscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: tscale Scale factors for mass, distance, and time units, respectively. procedure, public :: validate_ids => util_valid_id_system Validate the numerical ids passed to the system and save the maximum value interface public module subroutine util_valid_id_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: initialize => whm_setup_initialize_system Replace the abstract procedures with concrete ones\n Performs WHM-specific initilization steps, like calculating the Jacobi masses interface public module subroutine whm_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_nbody_system ), intent(inout) :: self WHM nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters procedure, public :: step => helio_step_system Advance the Helio nbody system forward in time by one step interface public module subroutine helio_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_nbody_system ), intent(inout) :: self Helio nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"type/helio_nbody_system.html"},{"title":"helio_cb – swiftest ","text":"type, public, extends( swiftest_cb ) :: helio_cb Helio central body particle class Inherits type~~helio_cb~~InheritsGraph type~helio_cb helio_cb type~swiftest_cb swiftest_cb type~helio_cb->type~swiftest_cb type~swiftest_base swiftest_base type~swiftest_cb->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~helio_cb~~InheritedByGraph type~helio_cb helio_cb type~symba_cb symba_cb type~symba_cb->type~helio_cb Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate name id mass Gmass radius density j2rp2 j4rp4 aobl atide aoblbeg aoblend atidebeg atideend xb vb agr Ip rot k2 Q tlag L0 dL ptbeg ptend Type-Bound Procedures dump initialize read_frame write_frame Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step character(len=STRMAX), public :: name Non-unique name integer(kind=I4B), public :: id = 0 External identifier (unique) real(kind=DP), public :: mass = 0.0_DP Central body mass (units MU) real(kind=DP), public :: Gmass = 0.0_DP Central mass gravitational term G * mass (units GU * MU) real(kind=DP), public :: radius = 0.0_DP Central body radius (units DU) real(kind=DP), public :: density = 1.0_DP Central body mass density - calculated internally (units MU / DU**3) real(kind=DP), public :: j2rp2 = 0.0_DP J2*R&#94;2 term for central body real(kind=DP), public :: j4rp4 = 0.0_DP J4*R&#94;2 term for central body real(kind=DP), public, dimension(NDIM) :: aobl = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: atide = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: aoblbeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: aoblend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: atidebeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: atideend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: xb = 0.0_DP Barycentric position (units DU) real(kind=DP), public, dimension(NDIM) :: vb = 0.0_DP Barycentric velocity (units DU / TU) real(kind=DP), public, dimension(NDIM) :: agr = 0.0_DP Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(NDIM) :: Ip = 0.0_DP Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(NDIM) :: rot = 0.0_DP Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public :: k2 = 0.0_DP Tidal Love number real(kind=DP), public :: Q = 0.0_DP Tidal quality factor real(kind=DP), public :: tlag = 0.0_DP Tidal phase lag angle real(kind=DP), public, dimension(NDIM) :: L0 = 0.0_DP Initial angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: dL = 0.0_DP Change in angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: ptbeg negative barycentric velocity of the central body at the beginning of time step real(kind=DP), public, dimension(NDIM) :: ptend negative barycentric velocity of the central body at the end of time step Type-Bound Procedures procedure, public :: dump => io_dump_swiftest interface public module subroutine io_dump_swiftest(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: initialize => io_read_cb_in I/O routine for reading in central body data interface public module subroutine io_read_cb_in(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_cb I/O routine for reading out a single frame of time-series data for the central body interface public module subroutine io_read_frame_cb(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_frame => io_write_frame_cb I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_cb(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"type/helio_cb.html"},{"title":"helio_pl – swiftest ","text":"type, public, extends( swiftest_pl ) :: helio_pl Inherits type~~helio_pl~~InheritsGraph type~helio_pl helio_pl type~swiftest_pl swiftest_pl type~helio_pl->type~swiftest_pl type~swiftest_body swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~helio_pl~~InheritedByGraph type~helio_pl helio_pl type~symba_pl symba_pl type~symba_pl->type~helio_pl type~symba_merger symba_merger type~symba_merger->type~symba_pl type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~symba_merger pl_adds Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate lfirst nbody name id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm mass Gmass rhill radius xbeg xend vbeg density Ip rot k2 Q tlag k_plpl nplpl Type-Bound Procedures dump v2pv pv2v initialize read_frame write_frame el2xv xv2el accel_user set_ir3 discard eucl_index accel_int accel_obl setup accel_tides append h2b b2h fill resize set_beg_end set_mu set_rhill sort rearrange spill vh2vb vb2vh drift lindrift accel_gr gr_pos_kick accel kick step Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl Type-Bound Procedures procedure, public :: dump => io_dump_swiftest interface public module subroutine io_dump_swiftest(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file interface public module subroutine io_read_body_in(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_read_frame_body(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object procedure, public :: discard => discard_pl Placeholder method for discarding massive bodies interface public module subroutine discard_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameter procedure, public :: eucl_index => eucl_dist_index_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix interface public module subroutine eucl_dist_index_plpl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies interface public pure module subroutine kick_getacch_int_pl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: setup => setup_pl A base constructor that sets the number of bodies and allocates and initializes all arrays interface public module subroutine setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body interface public module subroutine tides_kick_getacch_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: append => util_append_pl Appends elements from one structure to another interface public module subroutine util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: fill => util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: resize => util_resize_pl Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. interface public module subroutine util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. interface public module subroutine util_set_beg_end_pl(self, xbeg, xend, vbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object real(kind=DP), intent(in), optional dimension(:,:) :: xbeg Position vectors at beginning of step real(kind=DP), intent(in), optional dimension(:,:) :: xend Positions vectors at end of step real(kind=DP), intent(in), optional dimension(:,:) :: vbeg vbeg is an unused variable to keep this method forward compatible with RMVS procedure, public :: set_mu => util_set_mu_pl Method used to construct the vectorized form of the central body mass interface public module subroutine util_set_mu_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body interface public module subroutine util_set_rhill(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: sort => util_sort_pl Sorts body arrays by a sortable component interface public module subroutine util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not procedure, public :: vh2vb => helio_coord_vh2vb_pl Convert massive bodies from heliocentric to barycentric coordinates (velocity only) interface public module subroutine helio_coord_vh2vb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: vb2vh => helio_coord_vb2vh_pl Convert massive bodies from barycentric to heliocentric coordinates (velocity only) interface public module subroutine helio_coord_vb2vh_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: drift => helio_drift_pl Method for Danby drift in Democratic Heliocentric coordinates interface public module subroutine helio_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: lindrift => helio_drift_linear_pl Method for linear drift of massive bodies due to barycentric momentum of Sun interface public module subroutine helio_drift_linear_pl(self, cb, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( helio_cb ), intent(inout) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step procedure, public :: accel_gr => helio_gr_kick_getacch_pl Acceleration term arising from the post-Newtonian correction interface public module subroutine helio_gr_kick_getacch_pl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: gr_pos_kick => helio_gr_p4_pl Position kick due to p**4 term in the post-Newtonian correction interface public pure module subroutine helio_gr_p4_pl(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size procedure, public :: accel => helio_kick_getacch_pl Compute heliocentric accelerations of massive bodies interface public module subroutine helio_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step procedure, public :: kick => helio_kick_vb_pl Kicks the barycentric velocities interface public module subroutine helio_kick_vb_pl(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure, public :: step => helio_step_pl Steps the body forward one stepsize interface public module subroutine helio_step_pl(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nboody system class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"type/helio_pl.html"},{"title":"helio_tp – swiftest ","text":"type, public, extends( swiftest_tp ) :: helio_tp Inherits type~~helio_tp~~InheritsGraph type~helio_tp helio_tp type~swiftest_tp swiftest_tp type~helio_tp->type~swiftest_tp type~swiftest_body swiftest_body type~swiftest_tp->type~swiftest_body type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~helio_tp~~InheritedByGraph type~helio_tp helio_tp type~symba_tp symba_tp type~symba_tp->type~helio_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate lfirst nbody name id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm isperi peri atp Type-Bound Procedures dump v2pv pv2v initialize read_frame write_frame el2xv xv2el accel_user set_ir3 discard accel_int accel_obl setup append h2b b2h fill get_peri resize set_mu sort rearrange spill vh2vb vb2vh lindrift drift accel_gr gr_pos_kick accel kick step Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill integer(kind=I4B), public, dimension(:), allocatable :: isperi Perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri Perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp Semimajor axis following perihelion passage\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_tp and util_spill_tp Type-Bound Procedures procedure, public :: dump => io_dump_swiftest interface public module subroutine io_dump_swiftest(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file interface public module subroutine io_read_body_in(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_read_frame_body(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object procedure, public :: discard => discard_tp Check to see if test particles should be discarded based on their positions relative to the massive bodies interface public module subroutine discard_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: accel_int => kick_getacch_int_tp Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies interface public pure module subroutine kick_getacch_int_tp(self, GMpl, xhp, npl) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle real(kind=DP), intent(in), dimension(:) :: GMpl Massive body masses real(kind=DP), intent(in), dimension(:,:) :: xhp Massive body position vectors integer(kind=I4B), intent(in) :: npl Number of active massive bodies procedure, public :: accel_obl => obl_acc_tp Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_tp(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: setup => setup_tp A base constructor that sets the number of bodies and interface public module subroutine setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parametersr procedure, public :: append => util_append_tp Appends elements from one structure to another interface public module subroutine util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: h2b => util_coord_h2b_tp Convert test particles from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_tp Convert test particles from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: fill => util_fill_tp \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: get_peri => util_peri_tp Determine system pericenter passages for test particles interface public module subroutine util_peri_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: resize => util_resize_tp Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. interface public module subroutine util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: set_mu => util_set_mu_tp Method used to construct the vectorized form of the central body mass interface public module subroutine util_set_mu_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: sort => util_sort_tp Sorts body arrays by a sortable component interface public module subroutine util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => util_sort_rearrange_tp Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => util_spill_tp \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not procedure, public :: vh2vb => helio_coord_vh2vb_tp Convert test particles from heliocentric to barycentric coordinates (velocity only) interface public module subroutine helio_coord_vh2vb_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body procedure, public :: vb2vh => helio_coord_vb2vh_tp Convert test particles from barycentric to heliocentric coordinates (velocity only) interface public module subroutine helio_coord_vb2vh_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body procedure, public :: lindrift => helio_drift_linear_tp Method for linear drift of massive bodies due to barycentric momentum of Sun interface public module subroutine helio_drift_linear_tp(self, cb, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( helio_cb ), intent(in) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step procedure, public :: drift => helio_drift_tp Method for Danby drift in Democratic Heliocentric coordinates interface public module subroutine helio_drift_tp(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: accel_gr => helio_gr_kick_getacch_tp Acceleration term arising from the post-Newtonian correction interface public module subroutine helio_gr_kick_getacch_tp(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: gr_pos_kick => helio_gr_p4_tp Position kick due to p**4 term in the post-Newtonian correction interface public pure module subroutine helio_gr_p4_tp(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size procedure, public :: accel => helio_kick_getacch_tp Compute heliocentric accelerations of massive bodies interface public module subroutine helio_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step procedure, public :: kick => helio_kick_vb_tp Kicks the barycentric velocities interface public module subroutine helio_kick_vb_tp(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure, public :: step => helio_step_tp Steps the body forward one stepsize interface public module subroutine helio_step_tp(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsizee","tags":"","loc":"type/helio_tp.html"},{"title":"whm_cb – swiftest ","text":"type, public, extends( swiftest_cb ) :: whm_cb Swiftest central body particle class Inherits type~~whm_cb~~InheritsGraph type~whm_cb whm_cb type~swiftest_cb swiftest_cb type~whm_cb->type~swiftest_cb type~swiftest_base swiftest_base type~swiftest_cb->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~whm_cb~~InheritedByGraph type~whm_cb whm_cb type~rmvs_cb rmvs_cb type~rmvs_cb->type~whm_cb type~rmvs_tp rmvs_tp type~rmvs_tp->type~rmvs_cb cb_heliocentric Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate name id mass Gmass radius density j2rp2 j4rp4 aobl atide aoblbeg aoblend atidebeg atideend xb vb agr Ip rot k2 Q tlag L0 dL Type-Bound Procedures dump initialize read_frame write_frame Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step character(len=STRMAX), public :: name Non-unique name integer(kind=I4B), public :: id = 0 External identifier (unique) real(kind=DP), public :: mass = 0.0_DP Central body mass (units MU) real(kind=DP), public :: Gmass = 0.0_DP Central mass gravitational term G * mass (units GU * MU) real(kind=DP), public :: radius = 0.0_DP Central body radius (units DU) real(kind=DP), public :: density = 1.0_DP Central body mass density - calculated internally (units MU / DU**3) real(kind=DP), public :: j2rp2 = 0.0_DP J2*R&#94;2 term for central body real(kind=DP), public :: j4rp4 = 0.0_DP J4*R&#94;2 term for central body real(kind=DP), public, dimension(NDIM) :: aobl = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: atide = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: aoblbeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: aoblend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: atidebeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: atideend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: xb = 0.0_DP Barycentric position (units DU) real(kind=DP), public, dimension(NDIM) :: vb = 0.0_DP Barycentric velocity (units DU / TU) real(kind=DP), public, dimension(NDIM) :: agr = 0.0_DP Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(NDIM) :: Ip = 0.0_DP Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(NDIM) :: rot = 0.0_DP Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public :: k2 = 0.0_DP Tidal Love number real(kind=DP), public :: Q = 0.0_DP Tidal quality factor real(kind=DP), public :: tlag = 0.0_DP Tidal phase lag angle real(kind=DP), public, dimension(NDIM) :: L0 = 0.0_DP Initial angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: dL = 0.0_DP Change in angular momentum of the central body Type-Bound Procedures procedure, public :: dump => io_dump_swiftest interface public module subroutine io_dump_swiftest(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: initialize => io_read_cb_in I/O routine for reading in central body data interface public module subroutine io_read_cb_in(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_cb I/O routine for reading out a single frame of time-series data for the central body interface public module subroutine io_read_frame_cb(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_frame => io_write_frame_cb I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_cb(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"type/whm_cb.html"},{"title":"whm_pl – swiftest ","text":"type, public, extends( swiftest_pl ) :: whm_pl WHM massive body particle class Inherits type~~whm_pl~~InheritsGraph type~whm_pl whm_pl type~swiftest_pl swiftest_pl type~whm_pl->type~swiftest_pl type~swiftest_body swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~whm_pl~~InheritedByGraph type~whm_pl whm_pl type~rmvs_pl rmvs_pl type~rmvs_pl->type~whm_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate lfirst nbody name id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm mass Gmass rhill radius xbeg xend vbeg density Ip rot k2 Q tlag k_plpl nplpl eta xj vj muj ir3j Type-Bound Procedures dump v2pv pv2v initialize read_frame write_frame el2xv xv2el accel_user discard eucl_index accel_int accel_obl accel_tides h2b b2h set_beg_end set_rhill h2j j2h vh2vj drift accel_gr gr_pos_kick accel kick append fill resize set_ir3 set_mu sort rearrange spill setup step Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl real(kind=DP), public, dimension(:), allocatable :: eta Jacobi mass real(kind=DP), public, dimension(:,:), allocatable :: xj Jacobi position real(kind=DP), public, dimension(:,:), allocatable :: vj Jacobi velocity real(kind=DP), public, dimension(:), allocatable :: muj Jacobi mu: GMcb * eta(i) / eta(i - 1) real(kind=DP), public, dimension(:), allocatable :: ir3j Third term of heliocentric acceleration\n Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the\n    component list, such as whm_setup_pl and whm_util_spill_pl Type-Bound Procedures procedure, public :: dump => io_dump_swiftest interface public module subroutine io_dump_swiftest(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file interface public module subroutine io_read_body_in(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_read_frame_body(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: discard => discard_pl Placeholder method for discarding massive bodies interface public module subroutine discard_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameter procedure, public :: eucl_index => eucl_dist_index_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix interface public module subroutine eucl_dist_index_plpl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies interface public pure module subroutine kick_getacch_int_pl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body interface public module subroutine tides_kick_getacch_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. interface public module subroutine util_set_beg_end_pl(self, xbeg, xend, vbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object real(kind=DP), intent(in), optional dimension(:,:) :: xbeg Position vectors at beginning of step real(kind=DP), intent(in), optional dimension(:,:) :: xend Positions vectors at end of step real(kind=DP), intent(in), optional dimension(:,:) :: vbeg vbeg is an unused variable to keep this method forward compatible with RMVS procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body interface public module subroutine util_set_rhill(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: h2j => whm_coord_h2j_pl Convert position and velcoity vectors from heliocentric to Jacobi coordinates interface public module subroutine whm_coord_h2j_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree procedure, public :: j2h => whm_coord_j2h_pl Convert position and velcoity vectors from Jacobi to helliocentric coordinates interface public module subroutine whm_coord_j2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree procedure, public :: vh2vj => whm_coord_vh2vj_pl Convert velocity vectors from heliocentric to Jacobi coordinates interface public module subroutine whm_coord_vh2vj_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree procedure, public :: drift => whm_drift_pl Loop through massive bodies and call Danby drift routine to jacobi coordinates interface public module subroutine whm_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: accel_gr => whm_gr_kick_getacch_pl Acceleration term arising from the post-Newtonian correction interface public module subroutine whm_gr_kick_getacch_pl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: gr_pos_kick => whm_gr_p4_pl Position kick due to p**4 term in the post-Newtonian correction interface public pure module subroutine whm_gr_p4_pl(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size procedure, public :: accel => whm_kick_getacch_pl Compute heliocentric accelerations of massive bodies interface public module subroutine whm_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Get heliocentric accelration of massive bodies Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step procedure, public :: kick => whm_kick_vh_pl Kick heliocentric velocities of massive bodies interface public module subroutine whm_kick_vh_pl(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure, public :: append => whm_util_append_pl Appends elements from one structure to another interface public module subroutine whm_util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: fill => whm_util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine whm_util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(in) :: inserts inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: resize => whm_util_resize_pl Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. interface public module subroutine whm_util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: set_ir3 => whm_util_set_ir3j Sets both the heliocentric and jacobi inverse radius terms (1/rj 3 and 1/rh 3) interface public module subroutine whm_util_set_ir3j(self) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object procedure, public :: set_mu => whm_util_set_mu_eta_pl Sets the Jacobi mass value for all massive bodies. interface public module subroutine whm_util_set_mu_eta_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: sort => whm_util_sort_pl Sort a WHM massive body object in-place. interface public module subroutine whm_util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => whm_util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine whm_util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => whm_util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine whm_util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not procedure, public :: setup => whm_setup_pl Constructor method - Allocates space for the input number of bodiess interface public module subroutine whm_setup_pl(self, n, param) Implementation → Reads WHM massive body object in from file Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body objectobject integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: step => whm_step_pl Steps the body forward one stepsize interface public module subroutine whm_step_pl(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"type/whm_pl.html"},{"title":"whm_tp – swiftest ","text":"type, public, extends( swiftest_tp ) :: whm_tp Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the\n    component list, such as whm_util_spill_tp Inherits type~~whm_tp~~InheritsGraph type~whm_tp whm_tp type~swiftest_tp swiftest_tp type~whm_tp->type~swiftest_tp type~swiftest_body swiftest_body type~swiftest_tp->type~swiftest_body type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~whm_tp~~InheritedByGraph type~whm_tp whm_tp type~rmvs_tp rmvs_tp type~rmvs_tp->type~whm_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate lfirst nbody name id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm isperi peri atp Type-Bound Procedures dump drift v2pv pv2v initialize read_frame write_frame el2xv xv2el accel_user set_ir3 discard accel_int accel_obl setup append h2b b2h fill get_peri resize set_mu sort rearrange spill accel_gr gr_pos_kick accel kick step Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill integer(kind=I4B), public, dimension(:), allocatable :: isperi Perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri Perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp Semimajor axis following perihelion passage\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_tp and util_spill_tp Type-Bound Procedures procedure, public :: dump => io_dump_swiftest interface public module subroutine io_dump_swiftest(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables interface public module subroutine drift_body(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file interface public module subroutine io_read_body_in(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_read_frame_body(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object procedure, public :: discard => discard_tp Check to see if test particles should be discarded based on their positions relative to the massive bodies interface public module subroutine discard_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: accel_int => kick_getacch_int_tp Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies interface public pure module subroutine kick_getacch_int_tp(self, GMpl, xhp, npl) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle real(kind=DP), intent(in), dimension(:) :: GMpl Massive body masses real(kind=DP), intent(in), dimension(:,:) :: xhp Massive body position vectors integer(kind=I4B), intent(in) :: npl Number of active massive bodies procedure, public :: accel_obl => obl_acc_tp Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_tp(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: setup => setup_tp A base constructor that sets the number of bodies and interface public module subroutine setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parametersr procedure, public :: append => util_append_tp Appends elements from one structure to another interface public module subroutine util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: h2b => util_coord_h2b_tp Convert test particles from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_tp Convert test particles from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: fill => util_fill_tp \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: get_peri => util_peri_tp Determine system pericenter passages for test particles interface public module subroutine util_peri_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: resize => util_resize_tp Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. interface public module subroutine util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: set_mu => util_set_mu_tp Method used to construct the vectorized form of the central body mass interface public module subroutine util_set_mu_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: sort => util_sort_tp Sorts body arrays by a sortable component interface public module subroutine util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => util_sort_rearrange_tp Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => util_spill_tp \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not procedure, public :: accel_gr => whm_gr_kick_getacch_tp Acceleration term arising from the post-Newtonian correction interface public module subroutine whm_gr_kick_getacch_tp(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: gr_pos_kick => whm_gr_p4_tp Position kick due to p**4 term in the post-Newtonian correction interface public pure module subroutine whm_gr_p4_tp(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size procedure, public :: accel => whm_kick_getacch_tp Compute heliocentric accelerations of test particles interface public module subroutine whm_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Get heliocentric accelration of the test particle Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step procedure, public :: kick => whm_kick_vh_tp Kick heliocentric velocities of test particles interface public module subroutine whm_kick_vh_tp(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure, public :: step => whm_step_tp Steps the particle forward one stepsize interface public module subroutine whm_step_tp(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"type/whm_tp.html"},{"title":"whm_nbody_system – swiftest ","text":"type, public, extends( swiftest_nbody_system ) :: whm_nbody_system An abstract class for the WHM integrator nbody system Inherits type~~whm_nbody_system~~InheritsGraph type~whm_nbody_system whm_nbody_system type~swiftest_nbody_system swiftest_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~swiftest_cb swiftest_cb type~swiftest_nbody_system->type~swiftest_cb cb type~swiftest_base swiftest_base type~swiftest_nbody_system->type~swiftest_base type~swiftest_tp swiftest_tp type~swiftest_nbody_system->type~swiftest_tp tp, tp_discards type~swiftest_pl swiftest_pl type~swiftest_nbody_system->type~swiftest_pl pl, pl_discards type~swiftest_cb->type~swiftest_base type~swiftest_body swiftest_body type~swiftest_tp->type~swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~whm_nbody_system~~InheritedByGraph type~whm_nbody_system whm_nbody_system type~rmvs_nbody_system rmvs_nbody_system type~rmvs_nbody_system->type~whm_nbody_system type~helio_nbody_system helio_nbody_system type~helio_nbody_system->type~whm_nbody_system type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~helio_nbody_system type~rmvs_pl rmvs_pl type~rmvs_pl->type~rmvs_nbody_system planetocentric Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate cb pl tp tp_discards pl_discards Gmtot ke_orbit ke_spin pe te Lorbit Lspin Lescape Mescape Ecollisions Euntracked lbeg maxid Type-Bound Procedures discard conservation_report dump read_frame write_discard write_frame step_spin set_msys get_energy_and_momentum rescale validate_ids initialize step Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step class( swiftest_cb ), public, allocatable :: cb Central body data structure class( swiftest_pl ), public, allocatable :: pl Massive body data structure class( swiftest_tp ), public, allocatable :: tp Test particle data structure class( swiftest_tp ), public, allocatable :: tp_discards Discarded test particle data structure class( swiftest_pl ), public, allocatable :: pl_discards Discarded massive body particle data structure real(kind=DP), public :: Gmtot = 0.0_DP Total system mass - used for barycentric coordinate conversion real(kind=DP), public :: ke_orbit = 0.0_DP System orbital kinetic energy real(kind=DP), public :: ke_spin = 0.0_DP System spin kinetic energy real(kind=DP), public :: pe = 0.0_DP System potential energy real(kind=DP), public :: te = 0.0_DP System total energy real(kind=DP), public, dimension(NDIM) :: Lorbit = 0.0_DP System orbital angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lspin = 0.0_DP System spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lescape = 0.0_DP Angular momentum of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Mescape = 0.0_DP Mass of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Ecollisions = 0.0_DP Energy lost from system due to collisions real(kind=DP), public :: Euntracked = 0.0_DP Energy gained from system due to escaped bodies logical, public :: lbeg True if this is the beginning of a step. This is used so that test particle steps can be calculated \n    separately from massive bodies.  Massive body variables are saved at half steps, and passed to \n    the test particles integer(kind=I4B), public :: maxid = -1 The current maximum particle id number Type-Bound Procedures procedure, public :: discard => discard_system Perform a discard step on the system interface public module subroutine discard_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: conservation_report => io_conservation_report Compute energy and momentum and print out the change with time interface public module subroutine io_conservation_report(self, param, lterminal) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Input colleciton of user-defined parameters logical, intent(in) :: lterminal Indicates whether to output information to the terminal screen procedure, public :: dump => io_dump_system Dump the state of the system to a file interface public module subroutine io_dump_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_system Read in a frame of input data from file interface public module subroutine io_read_frame_system(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_discard => io_write_discard Write out information about discarded test particles interface public module subroutine io_write_discard(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_frame => io_write_frame_system Append a frame of output data to file interface public module subroutine io_write_frame_system(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: step_spin => tides_step_spin_system Steps the spins of the massive & central bodies due to tides. interface public module subroutine tides_step_spin_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure, public :: set_msys => util_set_msys Sets the value of msys from the masses of system bodies. interface public module subroutine util_set_msys(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object procedure, public :: get_energy_and_momentum => util_get_energy_momentum_system Calculates the total system energy and momentum interface public module subroutine util_get_energy_momentum_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: rescale => util_rescale_system Rescales the system into a new set of units interface public module subroutine util_rescale_system(self, param, mscale, dscale, tscale) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters. Returns with new values of the scale vactors and GU real(kind=DP), intent(in) :: mscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: dscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: tscale Scale factors for mass, distance, and time units, respectively. procedure, public :: validate_ids => util_valid_id_system Validate the numerical ids passed to the system and save the maximum value interface public module subroutine util_valid_id_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: initialize => whm_setup_initialize_system Replace the abstract procedures with concrete ones\n Performs WHM-specific initilization steps, like calculating the Jacobi masses interface public module subroutine whm_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_nbody_system ), intent(inout) :: self WHM nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters procedure, public :: step => whm_step_system Advance the WHM nbody system forward in time by one step interface public module subroutine whm_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_nbody_system ), intent(inout) :: self WHM system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"type/whm_nbody_system.html"},{"title":"symba_parameters – swiftest ","text":"type, public, extends( swiftest_parameters ) :: symba_parameters Inherits type~~symba_parameters~~InheritsGraph type~symba_parameters symba_parameters type~swiftest_parameters swiftest_parameters type~symba_parameters->type~swiftest_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables integrator nplmax ntpmax t0 t tstop dt incbfile inplfile intpfile in_type istep_out outfile out_type out_form out_stat istep_dump rmin rmax rmaxu qmin qmin_coord qmin_alo qmin_ahi enc_out discard_out MU2KG TU2S DU2M GU inv_c2 energy_out lrhill_present lextra_force lbig_discard lclose lenergy loblatecb lrotation ltides Eorbit_orig Mtot_orig Lmag_orig Ltot_orig Lorbit_orig Lspin_orig Ltot Lescape Mescape Ecollisions Euntracked lfirstenergy lfirstkick lrestart lgr lyarkovsky lyorp particle_out GMTINY seed lfragmentation Type-Bound Procedures dump read_from_file reader writer Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: integrator = UNKNOWN_INTEGRATOR Symbolic name of the nbody integrator  used integer(kind=I4B), public :: nplmax = -1 Maximum allowed number of massive bodies integer(kind=I4B), public :: ntpmax = -1 Maximum allowed number of test particles real(kind=DP), public :: t0 = -1.0_DP Integration start time real(kind=DP), public :: t = -1.0_DP Integration current time real(kind=DP), public :: tstop = -1.0_DP Integration stop time real(kind=DP), public :: dt = -1.0_DP Time step character(len=STRMAX), public :: incbfile = CB_INFILE Name of input file for the central body character(len=STRMAX), public :: inplfile = PL_INFILE Name of input file for massive bodies character(len=STRMAX), public :: intpfile = TP_INFILE Name of input file for test particles character(len=STRMAX), public :: in_type = ASCII_TYPE Format of input data files integer(kind=I4B), public :: istep_out = -1 Number of time steps between binary outputs character(len=STRMAX), public :: outfile = BIN_OUTFILE Name of output binary file character(len=STRMAX), public :: out_type = REAL8_TYPE Binary format of output file character(len=STRMAX), public :: out_form = XV Data to write to output file character(len=STRMAX), public :: out_stat = 'NEW' Open status for output binary file integer(kind=I4B), public :: istep_dump = -1 Number of time steps between dumps real(kind=DP), public :: rmin = -1.0_DP Minimum heliocentric radius for test particle real(kind=DP), public :: rmax = -1.0_DP Maximum heliocentric radius for test particle real(kind=DP), public :: rmaxu = -1.0_DP Maximum unbound heliocentric radius for test particle real(kind=DP), public :: qmin = -1.0_DP Minimum pericenter distance for test particle character(len=STRMAX), public :: qmin_coord = 'HELIO' Coordinate frame to use for qmin real(kind=DP), public :: qmin_alo = -1.0_DP Minimum semimajor axis for qmin real(kind=DP), public :: qmin_ahi = -1.0_DP Maximum semimajor axis for qmin character(len=STRMAX), public :: enc_out = \"\" Name of output file for encounters character(len=STRMAX), public :: discard_out = \"\" Name of output file for discards real(kind=QP), public :: MU2KG = -1.0_QP Converts mass units to grams real(kind=QP), public :: TU2S = -1.0_QP Converts time units to seconds real(kind=QP), public :: DU2M = -1.0_QP Converts distance unit to centimeters real(kind=DP), public :: GU = -1.0_DP Universal gravitational constant in the system units real(kind=DP), public :: inv_c2 = -1.0_DP Inverse speed of light squared in the system units character(len=STRMAX), public :: energy_out = \"\" Name of output energy and momentum report file logical, public :: lrhill_present = .false. Hill radii are given as an input rather than calculated by the code (can be used to inflate close encounter regions manually) logical, public :: lextra_force = .false. User defined force function turned on logical, public :: lbig_discard = .false. Save big bodies on every discard logical, public :: lclose = .false. Turn on close encounters logical, public :: lenergy = .false. Track the total energy of the system logical, public :: loblatecb = .false. Calculate acceleration from oblate central body (automatically turns true if nonzero J2 is input) logical, public :: lrotation = .false. Include rotation states of big bodies logical, public :: ltides = .false. Include tidal dissipation real(kind=DP), public :: Eorbit_orig = 0.0_DP Initial orbital energy real(kind=DP), public :: Mtot_orig = 0.0_DP Initial system mass real(kind=DP), public :: Lmag_orig = 0.0_DP Initial total angular momentum magnitude real(kind=DP), public, dimension(NDIM) :: Ltot_orig = 0.0_DP Initial total angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lorbit_orig = 0.0_DP Initial orbital angular momentum real(kind=DP), public, dimension(NDIM) :: Lspin_orig = 0.0_DP Initial spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Ltot = 0.0_DP System angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lescape = 0.0_DP Angular momentum of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Mescape = 0.0_DP Mass of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Ecollisions = 0.0_DP Energy lost from system due to collisions real(kind=DP), public :: Euntracked = 0.0_DP Energy gained from system due to escaped bodies logical, public :: lfirstenergy = .true. This is the first time computing energe logical, public :: lfirstkick = .true. Initiate the first kick in a symplectic step logical, public :: lrestart = .false. Indicates whether or not this is a restarted run logical, public :: lgr = .false. Turn on GR logical, public :: lyarkovsky = .false. Turn on Yarkovsky effect logical, public :: lyorp = .false. Turn on YORP effect character(len=STRMAX), public :: particle_out = PARTICLE_OUTFILE Name of output particle information file real(kind=DP), public :: GMTINY = -1.0_DP Smallest mass that is fully gravitating integer(kind=I4B), public, dimension(:), allocatable :: seed Random seeds logical, public :: lfragmentation = .false. Do fragmentation modeling instead of simple merger. Type-Bound Procedures procedure, public :: dump => io_dump_param interface public module subroutine io_dump_param(self, param_file_name) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Output collection of parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in) procedure, public :: read_from_file => io_read_param_in interface public module subroutine io_read_param_in(self, param_file_name) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Current run configuration parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in) procedure, public :: reader => symba_io_param_reader interface public module subroutine symba_io_param_reader(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_parameters ), intent(inout) :: self Current run configuration parameters with SyMBA additionss integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) The first element passes the integrator code to the reader integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 procedure, public :: writer => symba_io_param_writer interface public module subroutine symba_io_param_writer(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_parameters ), intent(in) :: self Current run configuration parameters with SyMBA additions integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) Not used in this procedure integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0","tags":"","loc":"type/symba_parameters.html"},{"title":"symba_particle_info – swiftest ","text":"type, public :: symba_particle_info sequence Class definition for the particle origin information object. This object is used to track time, location, and collisional regime\n of fragments produced in collisional events. Inherited by type~~symba_particle_info~~InheritedByGraph type~symba_particle_info symba_particle_info type~symba_tp symba_tp type~symba_tp->type~symba_particle_info info type~symba_cb symba_cb type~symba_cb->type~symba_particle_info info type~symba_pl symba_pl type~symba_pl->type~symba_particle_info info type~symba_merger symba_merger type~symba_merger->type~symba_pl type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~symba_merger pl_adds Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables origin_type origin_time origin_xh origin_vh Components Type Visibility Attributes Name Initial character(len=32), public :: origin_type String containing a description of the origin of the particle (e.g. Initial Conditions, Supercatastrophic, Disruption, etc.) real(kind=DP), public :: origin_time The time of the particle's formation real(kind=DP), public, dimension(NDIM) :: origin_xh The heliocentric distance vector at the time of the particle's formation real(kind=DP), public, dimension(NDIM) :: origin_vh The heliocentric velocity vector at the time of the particle's formation","tags":"","loc":"type/symba_particle_info.html"},{"title":"symba_kinship – swiftest ","text":"type, public :: symba_kinship Class definition for the kinship relationships used in bookkeeping multiple collisions bodies in a single time step. Inherited by type~~symba_kinship~~InheritedByGraph type~symba_kinship symba_kinship type~symba_pl symba_pl type~symba_pl->type~symba_kinship kin type~symba_merger symba_merger type~symba_merger->type~symba_pl type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~symba_merger pl_adds Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables parent nchild child Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: parent Index of parent particle integer(kind=I4B), public :: nchild number of children in merger list integer(kind=I4B), public, dimension(:), allocatable :: child Index of children particles","tags":"","loc":"type/symba_kinship.html"},{"title":"symba_cb – swiftest ","text":"type, public, extends( helio_cb ) :: symba_cb SyMBA central body particle class Inherits type~~symba_cb~~InheritsGraph type~symba_cb symba_cb type~helio_cb helio_cb type~symba_cb->type~helio_cb type~symba_particle_info symba_particle_info type~symba_cb->type~symba_particle_info info type~swiftest_cb swiftest_cb type~helio_cb->type~swiftest_cb type~swiftest_base swiftest_base type~swiftest_cb->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate name id mass Gmass radius density j2rp2 j4rp4 aobl atide aoblbeg aoblend atidebeg atideend xb vb agr Ip rot k2 Q tlag L0 dL ptbeg ptend M0 dM R0 dR info Type-Bound Procedures dump initialize read_frame write_frame Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step character(len=STRMAX), public :: name Non-unique name integer(kind=I4B), public :: id = 0 External identifier (unique) real(kind=DP), public :: mass = 0.0_DP Central body mass (units MU) real(kind=DP), public :: Gmass = 0.0_DP Central mass gravitational term G * mass (units GU * MU) real(kind=DP), public :: radius = 0.0_DP Central body radius (units DU) real(kind=DP), public :: density = 1.0_DP Central body mass density - calculated internally (units MU / DU**3) real(kind=DP), public :: j2rp2 = 0.0_DP J2*R&#94;2 term for central body real(kind=DP), public :: j4rp4 = 0.0_DP J4*R&#94;2 term for central body real(kind=DP), public, dimension(NDIM) :: aobl = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: atide = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: aoblbeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: aoblend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: atidebeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: atideend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: xb = 0.0_DP Barycentric position (units DU) real(kind=DP), public, dimension(NDIM) :: vb = 0.0_DP Barycentric velocity (units DU / TU) real(kind=DP), public, dimension(NDIM) :: agr = 0.0_DP Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(NDIM) :: Ip = 0.0_DP Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(NDIM) :: rot = 0.0_DP Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public :: k2 = 0.0_DP Tidal Love number real(kind=DP), public :: Q = 0.0_DP Tidal quality factor real(kind=DP), public :: tlag = 0.0_DP Tidal phase lag angle real(kind=DP), public, dimension(NDIM) :: L0 = 0.0_DP Initial angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: dL = 0.0_DP Change in angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: ptbeg negative barycentric velocity of the central body at the beginning of time step real(kind=DP), public, dimension(NDIM) :: ptend negative barycentric velocity of the central body at the end of time step real(kind=DP), public :: M0 = 0.0_DP Initial mass of the central body real(kind=DP), public :: dM = 0.0_DP Change in mass of the central body real(kind=DP), public :: R0 = 0.0_DP Initial radius of the central body real(kind=DP), public :: dR = 0.0_DP Change in the radius of the central body type( symba_particle_info ), public :: info Type-Bound Procedures procedure, public :: dump => io_dump_swiftest interface public module subroutine io_dump_swiftest(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: initialize => io_read_cb_in I/O routine for reading in central body data interface public module subroutine io_read_cb_in(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_cb I/O routine for reading out a single frame of time-series data for the central body interface public module subroutine io_read_frame_cb(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_frame => io_write_frame_cb I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_cb(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"type/symba_cb.html"},{"title":"symba_pl – swiftest ","text":"type, public, extends( helio_pl ) :: symba_pl SyMBA massive body class Inherits type~~symba_pl~~InheritsGraph type~symba_pl symba_pl type~symba_kinship symba_kinship type~symba_pl->type~symba_kinship kin type~helio_pl helio_pl type~symba_pl->type~helio_pl type~symba_particle_info symba_particle_info type~symba_pl->type~symba_particle_info info type~swiftest_pl swiftest_pl type~helio_pl->type~swiftest_pl type~swiftest_body swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~symba_pl~~InheritedByGraph type~symba_pl symba_pl type~symba_merger symba_merger type~symba_merger->type~symba_pl type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~symba_merger pl_adds Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate lfirst nbody name id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm mass Gmass rhill radius xbeg xend vbeg density Ip rot k2 Q tlag k_plpl nplpl lcollision lencounter lmtiny nplm nplplm nplenc ntpenc levelg levelm isperi peri atp kin info Type-Bound Procedures dump v2pv pv2v initialize read_frame write_frame el2xv xv2el accel_user set_ir3 eucl_index accel_int accel_obl accel_tides h2b b2h set_beg_end set_mu set_rhill vh2vb vb2vh lindrift accel_gr gr_pos_kick kick step make_family discard drift encounter_check accel setup append fill get_peri rearray resize sort rearrange spill Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl logical, public, dimension(:), allocatable :: lcollision flag indicating whether body has merged with another this time step logical, public, dimension(:), allocatable :: lencounter flag indicating whether body is part of an encounter this time step logical, public, dimension(:), allocatable :: lmtiny flag indicating whether this body is below the GMTINY cutoff value integer(kind=I4B), public :: nplm number of bodies above the GMTINY limit integer(kind=I8B), public :: nplplm Number of body (all massive)-body (only those above GMTINY) comparisons in the flattened upper triangular matrix integer(kind=I4B), public, dimension(:), allocatable :: nplenc number of encounters with other planets this time step integer(kind=I4B), public, dimension(:), allocatable :: ntpenc number of encounters with test particles this time step integer(kind=I4B), public, dimension(:), allocatable :: levelg level at which this body should be moved integer(kind=I4B), public, dimension(:), allocatable :: levelm deepest encounter level achieved this time step integer(kind=I4B), public, dimension(:), allocatable :: isperi perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp semimajor axis following perihelion passage type( symba_kinship ), public, dimension(:), allocatable :: kin Array of merger relationship structures that can account for multiple pairwise mergers in a single step type( symba_particle_info ), public, dimension(:), allocatable :: info Type-Bound Procedures procedure, public :: dump => io_dump_swiftest interface public module subroutine io_dump_swiftest(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file interface public module subroutine io_read_body_in(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_read_frame_body(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object procedure, public :: eucl_index => eucl_dist_index_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix interface public module subroutine eucl_dist_index_plpl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies interface public pure module subroutine kick_getacch_int_pl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body interface public module subroutine tides_kick_getacch_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. interface public module subroutine util_set_beg_end_pl(self, xbeg, xend, vbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object real(kind=DP), intent(in), optional dimension(:,:) :: xbeg Position vectors at beginning of step real(kind=DP), intent(in), optional dimension(:,:) :: xend Positions vectors at end of step real(kind=DP), intent(in), optional dimension(:,:) :: vbeg vbeg is an unused variable to keep this method forward compatible with RMVS procedure, public :: set_mu => util_set_mu_pl Method used to construct the vectorized form of the central body mass interface public module subroutine util_set_mu_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body interface public module subroutine util_set_rhill(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: vh2vb => helio_coord_vh2vb_pl Convert massive bodies from heliocentric to barycentric coordinates (velocity only) interface public module subroutine helio_coord_vh2vb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: vb2vh => helio_coord_vb2vh_pl Convert massive bodies from barycentric to heliocentric coordinates (velocity only) interface public module subroutine helio_coord_vb2vh_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: lindrift => helio_drift_linear_pl Method for linear drift of massive bodies due to barycentric momentum of Sun interface public module subroutine helio_drift_linear_pl(self, cb, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( helio_cb ), intent(inout) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step procedure, public :: accel_gr => helio_gr_kick_getacch_pl Acceleration term arising from the post-Newtonian correction interface public module subroutine helio_gr_kick_getacch_pl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: gr_pos_kick => helio_gr_p4_pl Position kick due to p**4 term in the post-Newtonian correction interface public pure module subroutine helio_gr_p4_pl(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size procedure, public :: kick => helio_kick_vb_pl Kicks the barycentric velocities interface public module subroutine helio_kick_vb_pl(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure, public :: step => helio_step_pl Steps the body forward one stepsize interface public module subroutine helio_step_pl(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nboody system class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize procedure, public :: make_family => symba_collision_make_family_pl When a single body is involved in more than one collision in a single step, it becomes part of a family interface public module subroutine symba_collision_make_family_pl(self, idx) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(2) :: idx Array holding the indices of the two bodies involved in the collision procedure, public :: discard => symba_discard_pl Process massive body discards interface public module subroutine symba_discard_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: drift => symba_drift_pl Method for Danby drift in Democratic Heliocentric coordinates. Sets the mask to the current recursion level interface public module subroutine symba_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: encounter_check => symba_encounter_check_pl Checks if massive bodies are going through close encounters with each other interface public module function symba_encounter_check_pl(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter procedure, public :: accel => symba_kick_getacch_pl Compute heliocentric accelerations of massive bodies interface public module subroutine symba_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step procedure, public :: setup => symba_setup_pl Constructor method - Allocates space for the input number of bodies interface public module subroutine symba_setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: append => symba_util_append_pl Appends elements from one structure to another interface public module subroutine symba_util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: fill => symba_util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine symba_util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: get_peri => symba_util_peri_pl Determine system pericenter passages for massive bodies interface public module subroutine symba_util_peri_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: rearray => symba_util_rearray_pl Clean up the massive body structures to remove discarded bodies and add new bodies interface public module subroutine symba_util_rearray_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions procedure, public :: resize => symba_util_resize_pl Checks the current size of a SyMBA massive body against the requested size and resizes it if it is too small. interface public module subroutine symba_util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: sort => symba_util_sort_pl Sorts body arrays by a sortable componen interface public module subroutine symba_util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => symba_util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine symba_util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => symba_util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine symba_util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"type/symba_pl.html"},{"title":"symba_merger – swiftest ","text":"type, public, extends( symba_pl ) :: symba_merger Inherits type~~symba_merger~~InheritsGraph type~symba_merger symba_merger type~symba_pl symba_pl type~symba_merger->type~symba_pl type~symba_kinship symba_kinship type~symba_pl->type~symba_kinship kin type~helio_pl helio_pl type~symba_pl->type~helio_pl type~symba_particle_info symba_particle_info type~symba_pl->type~symba_particle_info info type~swiftest_pl swiftest_pl type~helio_pl->type~swiftest_pl type~swiftest_body swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~symba_merger~~InheritedByGraph type~symba_merger symba_merger type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~symba_merger pl_adds Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate lfirst nbody name id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm mass Gmass rhill radius xbeg xend vbeg density Ip rot k2 Q tlag k_plpl nplpl lcollision lencounter lmtiny nplm nplplm nplenc ntpenc levelg levelm isperi peri atp kin info ncomp Type-Bound Procedures dump v2pv pv2v initialize read_frame write_frame el2xv xv2el accel_user set_ir3 eucl_index accel_int accel_obl accel_tides h2b b2h set_beg_end set_mu set_rhill vh2vb vb2vh lindrift accel_gr gr_pos_kick kick step make_family discard drift encounter_check accel fill get_peri rearray sort rearrange spill append resize setup Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl logical, public, dimension(:), allocatable :: lcollision flag indicating whether body has merged with another this time step logical, public, dimension(:), allocatable :: lencounter flag indicating whether body is part of an encounter this time step logical, public, dimension(:), allocatable :: lmtiny flag indicating whether this body is below the GMTINY cutoff value integer(kind=I4B), public :: nplm number of bodies above the GMTINY limit integer(kind=I8B), public :: nplplm Number of body (all massive)-body (only those above GMTINY) comparisons in the flattened upper triangular matrix integer(kind=I4B), public, dimension(:), allocatable :: nplenc number of encounters with other planets this time step integer(kind=I4B), public, dimension(:), allocatable :: ntpenc number of encounters with test particles this time step integer(kind=I4B), public, dimension(:), allocatable :: levelg level at which this body should be moved integer(kind=I4B), public, dimension(:), allocatable :: levelm deepest encounter level achieved this time step integer(kind=I4B), public, dimension(:), allocatable :: isperi perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp semimajor axis following perihelion passage type( symba_kinship ), public, dimension(:), allocatable :: kin Array of merger relationship structures that can account for multiple pairwise mergers in a single step type( symba_particle_info ), public, dimension(:), allocatable :: info integer(kind=I4B), public, dimension(:), allocatable :: ncomp Type-Bound Procedures procedure, public :: dump => io_dump_swiftest interface public module subroutine io_dump_swiftest(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file interface public module subroutine io_read_body_in(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_read_frame_body(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object procedure, public :: eucl_index => eucl_dist_index_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix interface public module subroutine eucl_dist_index_plpl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies interface public pure module subroutine kick_getacch_int_pl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body interface public module subroutine tides_kick_getacch_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. interface public module subroutine util_set_beg_end_pl(self, xbeg, xend, vbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object real(kind=DP), intent(in), optional dimension(:,:) :: xbeg Position vectors at beginning of step real(kind=DP), intent(in), optional dimension(:,:) :: xend Positions vectors at end of step real(kind=DP), intent(in), optional dimension(:,:) :: vbeg vbeg is an unused variable to keep this method forward compatible with RMVS procedure, public :: set_mu => util_set_mu_pl Method used to construct the vectorized form of the central body mass interface public module subroutine util_set_mu_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body interface public module subroutine util_set_rhill(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: vh2vb => helio_coord_vh2vb_pl Convert massive bodies from heliocentric to barycentric coordinates (velocity only) interface public module subroutine helio_coord_vh2vb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: vb2vh => helio_coord_vb2vh_pl Convert massive bodies from barycentric to heliocentric coordinates (velocity only) interface public module subroutine helio_coord_vb2vh_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: lindrift => helio_drift_linear_pl Method for linear drift of massive bodies due to barycentric momentum of Sun interface public module subroutine helio_drift_linear_pl(self, cb, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( helio_cb ), intent(inout) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step procedure, public :: accel_gr => helio_gr_kick_getacch_pl Acceleration term arising from the post-Newtonian correction interface public module subroutine helio_gr_kick_getacch_pl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: gr_pos_kick => helio_gr_p4_pl Position kick due to p**4 term in the post-Newtonian correction interface public pure module subroutine helio_gr_p4_pl(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size procedure, public :: kick => helio_kick_vb_pl Kicks the barycentric velocities interface public module subroutine helio_kick_vb_pl(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure, public :: step => helio_step_pl Steps the body forward one stepsize interface public module subroutine helio_step_pl(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nboody system class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize procedure, public :: make_family => symba_collision_make_family_pl When a single body is involved in more than one collision in a single step, it becomes part of a family interface public module subroutine symba_collision_make_family_pl(self, idx) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(2) :: idx Array holding the indices of the two bodies involved in the collision procedure, public :: discard => symba_discard_pl Process massive body discards interface public module subroutine symba_discard_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: drift => symba_drift_pl Method for Danby drift in Democratic Heliocentric coordinates. Sets the mask to the current recursion level interface public module subroutine symba_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: encounter_check => symba_encounter_check_pl Checks if massive bodies are going through close encounters with each other interface public module function symba_encounter_check_pl(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter procedure, public :: accel => symba_kick_getacch_pl Compute heliocentric accelerations of massive bodies interface public module subroutine symba_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step procedure, public :: fill => symba_util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine symba_util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: get_peri => symba_util_peri_pl Determine system pericenter passages for massive bodies interface public module subroutine symba_util_peri_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: rearray => symba_util_rearray_pl Clean up the massive body structures to remove discarded bodies and add new bodies interface public module subroutine symba_util_rearray_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions procedure, public :: sort => symba_util_sort_pl Sorts body arrays by a sortable componen interface public module subroutine symba_util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => symba_util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine symba_util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => symba_util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine symba_util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not procedure, public :: append => symba_util_append_merger Appends elements from one structure to another interface public module subroutine symba_util_append_merger(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: resize => symba_util_resize_merger Checks the current size of a SyMBA merger list against the requested size and resizes it if it is too small. interface public module subroutine symba_util_resize_merger(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA merger list object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: setup => symba_setup_merger Constructor method - Allocates space for the input number of bodies interface public module subroutine symba_setup_merger(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA merger list object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"type/symba_merger.html"},{"title":"symba_tp – swiftest ","text":"type, public, extends( helio_tp ) :: symba_tp SyMBA test particle class Inherits type~~symba_tp~~InheritsGraph type~symba_tp symba_tp type~helio_tp helio_tp type~symba_tp->type~helio_tp type~symba_particle_info symba_particle_info type~symba_tp->type~symba_particle_info info type~swiftest_tp swiftest_tp type~helio_tp->type~swiftest_tp type~swiftest_body swiftest_body type~swiftest_tp->type~swiftest_body type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate lfirst nbody name id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm isperi peri atp nplenc levelg levelm info Type-Bound Procedures dump v2pv pv2v initialize read_frame write_frame el2xv xv2el accel_user set_ir3 discard accel_int accel_obl h2b b2h get_peri set_mu vh2vb vb2vh lindrift accel_gr gr_pos_kick kick step drift encounter_check accel setup append fill resize sort rearrange spill Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill integer(kind=I4B), public, dimension(:), allocatable :: isperi Perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri Perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp Semimajor axis following perihelion passage\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_tp and util_spill_tp integer(kind=I4B), public, dimension(:), allocatable :: nplenc number of encounters with planets this time step integer(kind=I4B), public, dimension(:), allocatable :: levelg level at which this particle should be moved integer(kind=I4B), public, dimension(:), allocatable :: levelm deepest encounter level achieved this time step type( symba_particle_info ), public, dimension(:), allocatable :: info Type-Bound Procedures procedure, public :: dump => io_dump_swiftest interface public module subroutine io_dump_swiftest(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file interface public module subroutine io_read_body_in(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_read_frame_body(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object procedure, public :: discard => discard_tp Check to see if test particles should be discarded based on their positions relative to the massive bodies interface public module subroutine discard_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: accel_int => kick_getacch_int_tp Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies interface public pure module subroutine kick_getacch_int_tp(self, GMpl, xhp, npl) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle real(kind=DP), intent(in), dimension(:) :: GMpl Massive body masses real(kind=DP), intent(in), dimension(:,:) :: xhp Massive body position vectors integer(kind=I4B), intent(in) :: npl Number of active massive bodies procedure, public :: accel_obl => obl_acc_tp Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_tp(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: h2b => util_coord_h2b_tp Convert test particles from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_tp Convert test particles from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: get_peri => util_peri_tp Determine system pericenter passages for test particles interface public module subroutine util_peri_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: set_mu => util_set_mu_tp Method used to construct the vectorized form of the central body mass interface public module subroutine util_set_mu_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: vh2vb => helio_coord_vh2vb_tp Convert test particles from heliocentric to barycentric coordinates (velocity only) interface public module subroutine helio_coord_vh2vb_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body procedure, public :: vb2vh => helio_coord_vb2vh_tp Convert test particles from barycentric to heliocentric coordinates (velocity only) interface public module subroutine helio_coord_vb2vh_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body procedure, public :: lindrift => helio_drift_linear_tp Method for linear drift of massive bodies due to barycentric momentum of Sun interface public module subroutine helio_drift_linear_tp(self, cb, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( helio_cb ), intent(in) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step procedure, public :: accel_gr => helio_gr_kick_getacch_tp Acceleration term arising from the post-Newtonian correction interface public module subroutine helio_gr_kick_getacch_tp(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: gr_pos_kick => helio_gr_p4_tp Position kick due to p**4 term in the post-Newtonian correction interface public pure module subroutine helio_gr_p4_tp(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size procedure, public :: kick => helio_kick_vb_tp Kicks the barycentric velocities interface public module subroutine helio_kick_vb_tp(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure, public :: step => helio_step_tp Steps the body forward one stepsize interface public module subroutine helio_step_tp(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsizee procedure, public :: drift => symba_drift_tp Method for Danby drift in Democratic Heliocentric coordinates. Sets the mask to the current recursion level interface public module subroutine symba_drift_tp(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: encounter_check => symba_encounter_check_tp Checks if any test particles are undergoing a close encounter with a massive body interface public module function symba_encounter_check_tp(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter procedure, public :: accel => symba_kick_getacch_tp Compute heliocentric accelerations of test particles interface public module subroutine symba_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step procedure, public :: setup => symba_setup_tp Constructor method - Allocates space for the input number of bodies interface public module subroutine symba_setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter procedure, public :: append => symba_util_append_tp Appends elements from one structure to another interface public module subroutine symba_util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: fill => symba_util_fill_tp \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine symba_util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: resize => symba_util_resize_tp Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. interface public module subroutine symba_util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: sort => symba_util_sort_tp Sorts body arrays by a sortable componen interface public module subroutine symba_util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => symba_util_sort_rearrange_tp Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine symba_util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => symba_util_spill_tp \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine symba_util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"type/symba_tp.html"},{"title":"symba_pltpenc – swiftest ","text":"type, public, extends( swiftest_encounter ) :: symba_pltpenc SyMBA class for tracking pl-tp close encounters in a step Inherits type~~symba_pltpenc~~InheritsGraph type~symba_pltpenc symba_pltpenc type~swiftest_encounter swiftest_encounter type~symba_pltpenc->type~swiftest_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~symba_pltpenc~~InheritedByGraph type~symba_pltpenc symba_pltpenc type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~symba_pltpenc pltpenc_list type~symba_plplenc symba_plplenc type~symba_nbody_system->type~symba_plplenc plplenc_list type~symba_plplenc->type~symba_pltpenc Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nenc lvdotr status index1 index2 x1 x2 v1 v2 level Type-Bound Procedures copy resize collision_check encounter_check kick setup spill Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: nenc Total number of encounters logical, public, dimension(:), allocatable :: lvdotr relative vdotr flag integer(kind=I4B), public, dimension(:), allocatable :: status status of the interaction integer(kind=I4B), public, dimension(:), allocatable :: index1 position of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: index2 position of the second body in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x1 the position of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x2 the position of body 2 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v1 the velocity of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v2 the velocity of body 2 in the encounter integer(kind=I4B), public, dimension(:), allocatable :: level encounter recursion level Type-Bound Procedures procedure, public :: copy => util_copy_encounter Copies elements from the source encounter list into self. interface public module subroutine util_copy_encounter(self, source) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Encounter list class( swiftest_encounter ), intent(in) :: source Source object to copy into procedure, public :: resize => util_resize_encounter Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small. interface public module subroutine util_resize_encounter(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list integer(kind=I4B), intent(in) :: nnew New size of list needed procedure, public :: collision_check => symba_collision_check_pltpenc Checks if a test particle is going to collide with a massive body interface public module subroutine symba_collision_check_pltpenc(self, system, param, t, dt, irec) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t current time real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level procedure, public :: encounter_check => symba_encounter_check_pltpenc Checks if massive bodies are going through close encounters with each other interface public module function symba_encounter_check_pltpenc(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-pl encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter procedure, public :: kick => symba_kick_pltpenc Kick barycentric velocities of active test particles within SyMBA recursion interface public module subroutine symba_kick_pltpenc(self, system, dt, irec, sgn) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(in) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level integer(kind=I4B), intent(in) :: sgn sign to be applied to acceleration procedure, public :: setup => symba_setup_pltpenc A constructor that sets the number of encounters and allocates and initializes all arrays interface public module subroutine symba_setup_pltpenc(self, n) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-tp encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for procedure, public :: spill => symba_util_spill_pltpenc \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine symba_util_spill_pltpenc(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-tp encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list","tags":"","loc":"type/symba_pltpenc.html"},{"title":"symba_plplenc – swiftest ","text":"type, public, extends( symba_pltpenc ) :: symba_plplenc SyMBA class for tracking pl-pl close encounters in a step Inherits type~~symba_plplenc~~InheritsGraph type~symba_plplenc symba_plplenc type~symba_pltpenc symba_pltpenc type~symba_plplenc->type~symba_pltpenc type~swiftest_encounter swiftest_encounter type~symba_pltpenc->type~swiftest_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~symba_plplenc~~InheritedByGraph type~symba_plplenc symba_plplenc type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~symba_plplenc plplenc_list Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nenc lvdotr status index1 index2 x1 x2 v1 v2 level Type-Bound Procedures copy resize collision_check encounter_check kick setup spill scrub_non_collision resolve_fragmentations resolve_mergers Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: nenc Total number of encounters logical, public, dimension(:), allocatable :: lvdotr relative vdotr flag integer(kind=I4B), public, dimension(:), allocatable :: status status of the interaction integer(kind=I4B), public, dimension(:), allocatable :: index1 position of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: index2 position of the second body in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x1 the position of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x2 the position of body 2 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v1 the velocity of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v2 the velocity of body 2 in the encounter integer(kind=I4B), public, dimension(:), allocatable :: level encounter recursion level Type-Bound Procedures procedure, public :: copy => util_copy_encounter Copies elements from the source encounter list into self. interface public module subroutine util_copy_encounter(self, source) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Encounter list class( swiftest_encounter ), intent(in) :: source Source object to copy into procedure, public :: resize => util_resize_encounter Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small. interface public module subroutine util_resize_encounter(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list integer(kind=I4B), intent(in) :: nnew New size of list needed procedure, public :: collision_check => symba_collision_check_pltpenc Checks if a test particle is going to collide with a massive body interface public module subroutine symba_collision_check_pltpenc(self, system, param, t, dt, irec) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t current time real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level procedure, public :: encounter_check => symba_encounter_check_pltpenc Checks if massive bodies are going through close encounters with each other interface public module function symba_encounter_check_pltpenc(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-pl encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter procedure, public :: kick => symba_kick_pltpenc Kick barycentric velocities of active test particles within SyMBA recursion interface public module subroutine symba_kick_pltpenc(self, system, dt, irec, sgn) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(in) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level integer(kind=I4B), intent(in) :: sgn sign to be applied to acceleration procedure, public :: setup => symba_setup_pltpenc A constructor that sets the number of encounters and allocates and initializes all arrays interface public module subroutine symba_setup_pltpenc(self, n) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-tp encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for procedure, public :: spill => symba_util_spill_pltpenc \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine symba_util_spill_pltpenc(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-tp encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list procedure, public :: scrub_non_collision => symba_collision_encounter_scrub Processes the pl-pl encounter list remove only those encounters that led to a collision interface public module subroutine symba_collision_encounter_scrub(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameterss procedure, public :: resolve_fragmentations => symba_collision_resolve_fragmentations Process list of collisions, determine the collisional regime, and then create fragments interface public module subroutine symba_collision_resolve_fragmentations(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions procedure, public :: resolve_mergers => symba_collision_resolve_mergers Process list of collisions and merge colliding bodies together interface public module subroutine symba_collision_resolve_mergers(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions","tags":"","loc":"type/symba_plplenc.html"},{"title":"symba_nbody_system – swiftest ","text":"type, public, extends( helio_nbody_system ) :: symba_nbody_system Inherits type~~symba_nbody_system~~InheritsGraph type~symba_nbody_system symba_nbody_system type~helio_nbody_system helio_nbody_system type~symba_nbody_system->type~helio_nbody_system type~symba_pltpenc symba_pltpenc type~symba_nbody_system->type~symba_pltpenc pltpenc_list type~symba_merger symba_merger type~symba_nbody_system->type~symba_merger pl_adds type~symba_plplenc symba_plplenc type~symba_nbody_system->type~symba_plplenc plplenc_list type~whm_nbody_system whm_nbody_system type~helio_nbody_system->type~whm_nbody_system type~swiftest_encounter swiftest_encounter type~symba_pltpenc->type~swiftest_encounter type~symba_pl symba_pl type~symba_merger->type~symba_pl type~symba_plplenc->type~symba_pltpenc type~swiftest_nbody_system swiftest_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~symba_kinship symba_kinship type~symba_pl->type~symba_kinship kin type~helio_pl helio_pl type~symba_pl->type~helio_pl type~symba_particle_info symba_particle_info type~symba_pl->type~symba_particle_info info type~swiftest_pl swiftest_pl type~helio_pl->type~swiftest_pl type~swiftest_cb swiftest_cb type~swiftest_nbody_system->type~swiftest_cb cb type~swiftest_base swiftest_base type~swiftest_nbody_system->type~swiftest_base type~swiftest_tp swiftest_tp type~swiftest_nbody_system->type~swiftest_tp tp, tp_discards type~swiftest_nbody_system->type~swiftest_pl pl, pl_discards type~swiftest_cb->type~swiftest_base type~swiftest_body swiftest_body type~swiftest_tp->type~swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate cb pl tp tp_discards pl_discards Gmtot ke_orbit ke_spin pe te Lorbit Lspin Lescape Mescape Ecollisions Euntracked lbeg maxid pl_adds pltpenc_list plplenc_list irec Type-Bound Procedures discard conservation_report dump read_frame write_frame step_spin set_msys get_energy_and_momentum rescale validate_ids write_discard initialize step interp set_recur_levels recursive_step reset Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step class( swiftest_cb ), public, allocatable :: cb Central body data structure class( swiftest_pl ), public, allocatable :: pl Massive body data structure class( swiftest_tp ), public, allocatable :: tp Test particle data structure class( swiftest_tp ), public, allocatable :: tp_discards Discarded test particle data structure class( swiftest_pl ), public, allocatable :: pl_discards Discarded massive body particle data structure real(kind=DP), public :: Gmtot = 0.0_DP Total system mass - used for barycentric coordinate conversion real(kind=DP), public :: ke_orbit = 0.0_DP System orbital kinetic energy real(kind=DP), public :: ke_spin = 0.0_DP System spin kinetic energy real(kind=DP), public :: pe = 0.0_DP System potential energy real(kind=DP), public :: te = 0.0_DP System total energy real(kind=DP), public, dimension(NDIM) :: Lorbit = 0.0_DP System orbital angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lspin = 0.0_DP System spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lescape = 0.0_DP Angular momentum of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Mescape = 0.0_DP Mass of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Ecollisions = 0.0_DP Energy lost from system due to collisions real(kind=DP), public :: Euntracked = 0.0_DP Energy gained from system due to escaped bodies logical, public :: lbeg True if this is the beginning of a step. This is used so that test particle steps can be calculated \n    separately from massive bodies.  Massive body variables are saved at half steps, and passed to \n    the test particles integer(kind=I4B), public :: maxid = -1 The current maximum particle id number class( symba_merger ), public, allocatable :: pl_adds List of added bodies in mergers or collisions class( symba_pltpenc ), public, allocatable :: pltpenc_list List of massive body-test particle encounters in a single step class( symba_plplenc ), public, allocatable :: plplenc_list List of massive body-massive body encounters in a single step integer(kind=I4B), public :: irec System recursion level Type-Bound Procedures procedure, public :: discard => discard_system Perform a discard step on the system interface public module subroutine discard_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: conservation_report => io_conservation_report Compute energy and momentum and print out the change with time interface public module subroutine io_conservation_report(self, param, lterminal) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Input colleciton of user-defined parameters logical, intent(in) :: lterminal Indicates whether to output information to the terminal screen procedure, public :: dump => io_dump_system Dump the state of the system to a file interface public module subroutine io_dump_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_system Read in a frame of input data from file interface public module subroutine io_read_frame_system(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_frame => io_write_frame_system Append a frame of output data to file interface public module subroutine io_write_frame_system(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: step_spin => tides_step_spin_system Steps the spins of the massive & central bodies due to tides. interface public module subroutine tides_step_spin_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure, public :: set_msys => util_set_msys Sets the value of msys from the masses of system bodies. interface public module subroutine util_set_msys(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object procedure, public :: get_energy_and_momentum => util_get_energy_momentum_system Calculates the total system energy and momentum interface public module subroutine util_get_energy_momentum_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: rescale => util_rescale_system Rescales the system into a new set of units interface public module subroutine util_rescale_system(self, param, mscale, dscale, tscale) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters. Returns with new values of the scale vactors and GU real(kind=DP), intent(in) :: mscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: dscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: tscale Scale factors for mass, distance, and time units, respectively. procedure, public :: validate_ids => util_valid_id_system Validate the numerical ids passed to the system and save the maximum value interface public module subroutine util_valid_id_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_discard => symba_io_write_discard Write out information about discarded and merged planets and test particles in SyMBA interface public module subroutine symba_io_write_discard(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: initialize => symba_setup_initialize_system Performs SyMBA-specific initilization steps interface public module subroutine symba_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: step => symba_step_system Advance the SyMBA nbody system forward in time by one step interface public module subroutine symba_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure, public :: interp => symba_step_interp_system Perform an interpolation step on the SymBA nbody system interface public module subroutine symba_step_interp_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure, public :: set_recur_levels => symba_step_set_recur_levels_system Sets recursion levels of bodies and encounter lists to the current system level interface public module subroutine symba_step_set_recur_levels_system(self, ireci) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system objec integer(kind=I4B), intent(in) :: ireci Input recursion level procedure, public :: recursive_step => symba_step_recur_system Step interacting planets and active test particles ahead in democratic heliocentric coordinates at the current recursion level, if applicable, and descend to the next deeper level if necessary interface public recursive module subroutine symba_step_recur_system(self, param, t, ireci) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), value :: t integer(kind=I4B), value :: ireci input recursion level procedure, public :: reset => symba_step_reset_system Resets pl, tp,and encounter structures at the start of a new step interface public module subroutine symba_step_reset_system(self) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object","tags":"","loc":"type/symba_nbody_system.html"},{"title":"swiftest_parameters – swiftest ","text":"type, public :: swiftest_parameters User defined parameters that are read in from the parameters input file. \n    Each paramter is initialized to a default values. Inherited by type~~swiftest_parameters~~InheritedByGraph type~swiftest_parameters swiftest_parameters type~symba_parameters symba_parameters type~symba_parameters->type~swiftest_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables integrator nplmax ntpmax t0 t tstop dt incbfile inplfile intpfile in_type istep_out outfile out_type out_form out_stat istep_dump rmin rmax rmaxu qmin qmin_coord qmin_alo qmin_ahi enc_out discard_out MU2KG TU2S DU2M GU inv_c2 energy_out lrhill_present lextra_force lbig_discard lclose lenergy loblatecb lrotation ltides Eorbit_orig Mtot_orig Lmag_orig Ltot_orig Lorbit_orig Lspin_orig Ltot Lescape Mescape Ecollisions Euntracked lfirstenergy lfirstkick lrestart lgr lyarkovsky lyorp Type-Bound Procedures reader writer dump read_from_file Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: integrator = UNKNOWN_INTEGRATOR Symbolic name of the nbody integrator  used integer(kind=I4B), public :: nplmax = -1 Maximum allowed number of massive bodies integer(kind=I4B), public :: ntpmax = -1 Maximum allowed number of test particles real(kind=DP), public :: t0 = -1.0_DP Integration start time real(kind=DP), public :: t = -1.0_DP Integration current time real(kind=DP), public :: tstop = -1.0_DP Integration stop time real(kind=DP), public :: dt = -1.0_DP Time step character(len=STRMAX), public :: incbfile = CB_INFILE Name of input file for the central body character(len=STRMAX), public :: inplfile = PL_INFILE Name of input file for massive bodies character(len=STRMAX), public :: intpfile = TP_INFILE Name of input file for test particles character(len=STRMAX), public :: in_type = ASCII_TYPE Format of input data files integer(kind=I4B), public :: istep_out = -1 Number of time steps between binary outputs character(len=STRMAX), public :: outfile = BIN_OUTFILE Name of output binary file character(len=STRMAX), public :: out_type = REAL8_TYPE Binary format of output file character(len=STRMAX), public :: out_form = XV Data to write to output file character(len=STRMAX), public :: out_stat = 'NEW' Open status for output binary file integer(kind=I4B), public :: istep_dump = -1 Number of time steps between dumps real(kind=DP), public :: rmin = -1.0_DP Minimum heliocentric radius for test particle real(kind=DP), public :: rmax = -1.0_DP Maximum heliocentric radius for test particle real(kind=DP), public :: rmaxu = -1.0_DP Maximum unbound heliocentric radius for test particle real(kind=DP), public :: qmin = -1.0_DP Minimum pericenter distance for test particle character(len=STRMAX), public :: qmin_coord = 'HELIO' Coordinate frame to use for qmin real(kind=DP), public :: qmin_alo = -1.0_DP Minimum semimajor axis for qmin real(kind=DP), public :: qmin_ahi = -1.0_DP Maximum semimajor axis for qmin character(len=STRMAX), public :: enc_out = \"\" Name of output file for encounters character(len=STRMAX), public :: discard_out = \"\" Name of output file for discards real(kind=QP), public :: MU2KG = -1.0_QP Converts mass units to grams real(kind=QP), public :: TU2S = -1.0_QP Converts time units to seconds real(kind=QP), public :: DU2M = -1.0_QP Converts distance unit to centimeters real(kind=DP), public :: GU = -1.0_DP Universal gravitational constant in the system units real(kind=DP), public :: inv_c2 = -1.0_DP Inverse speed of light squared in the system units character(len=STRMAX), public :: energy_out = \"\" Name of output energy and momentum report file logical, public :: lrhill_present = .false. Hill radii are given as an input rather than calculated by the code (can be used to inflate close encounter regions manually) logical, public :: lextra_force = .false. User defined force function turned on logical, public :: lbig_discard = .false. Save big bodies on every discard logical, public :: lclose = .false. Turn on close encounters logical, public :: lenergy = .false. Track the total energy of the system logical, public :: loblatecb = .false. Calculate acceleration from oblate central body (automatically turns true if nonzero J2 is input) logical, public :: lrotation = .false. Include rotation states of big bodies logical, public :: ltides = .false. Include tidal dissipation real(kind=DP), public :: Eorbit_orig = 0.0_DP Initial orbital energy real(kind=DP), public :: Mtot_orig = 0.0_DP Initial system mass real(kind=DP), public :: Lmag_orig = 0.0_DP Initial total angular momentum magnitude real(kind=DP), public, dimension(NDIM) :: Ltot_orig = 0.0_DP Initial total angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lorbit_orig = 0.0_DP Initial orbital angular momentum real(kind=DP), public, dimension(NDIM) :: Lspin_orig = 0.0_DP Initial spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Ltot = 0.0_DP System angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lescape = 0.0_DP Angular momentum of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Mescape = 0.0_DP Mass of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Ecollisions = 0.0_DP Energy lost from system due to collisions real(kind=DP), public :: Euntracked = 0.0_DP Energy gained from system due to escaped bodies logical, public :: lfirstenergy = .true. This is the first time computing energe logical, public :: lfirstkick = .true. Initiate the first kick in a symplectic step logical, public :: lrestart = .false. Indicates whether or not this is a restarted run logical, public :: lgr = .false. Turn on GR logical, public :: lyarkovsky = .false. Turn on Yarkovsky effect logical, public :: lyorp = .false. Turn on YORP effect Type-Bound Procedures procedure, public :: reader => io_param_reader interface public module subroutine io_param_reader(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Collection of parameters integer(kind=I4B), intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer(kind=I4B), intent(in) :: v_list (:) The first element passes the integrator code to the reader integer(kind=I4B), intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 procedure, public :: writer => io_param_writer interface public module subroutine io_param_writer(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Collection of parameters integer(kind=I4B), intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer(kind=I4B), intent(in) :: v_list (:) Not used in this procedure integer(kind=I4B), intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 procedure, public :: dump => io_dump_param interface public module subroutine io_dump_param(self, param_file_name) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Output collection of parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in) procedure, public :: read_from_file => io_read_param_in interface public module subroutine io_read_param_in(self, param_file_name) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Current run configuration parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in)","tags":"","loc":"type/swiftest_parameters.html"},{"title":"swiftest_base – swiftest ","text":"type, public, abstract :: swiftest_base An superclass for a generic Swiftest object\n The minimal methods that all systems must have Inherited by type~~swiftest_base~~InheritedByGraph type~swiftest_base swiftest_base type~swiftest_cb swiftest_cb type~swiftest_cb->type~swiftest_base type~swiftest_body swiftest_body type~swiftest_body->type~swiftest_base type~swiftest_nbody_system swiftest_nbody_system type~swiftest_nbody_system->type~swiftest_base type~swiftest_nbody_system->type~swiftest_cb cb type~swiftest_tp swiftest_tp type~swiftest_nbody_system->type~swiftest_tp tp, tp_discards type~swiftest_pl swiftest_pl type~swiftest_nbody_system->type~swiftest_pl pl, pl_discards type~swiftest_tp->type~swiftest_body type~helio_cb helio_cb type~helio_cb->type~swiftest_cb type~whm_nbody_system whm_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~whm_cb whm_cb type~whm_cb->type~swiftest_cb type~swiftest_pl->type~swiftest_body type~whm_tp whm_tp type~whm_tp->type~swiftest_tp type~helio_pl helio_pl type~helio_pl->type~swiftest_pl type~rmvs_cb rmvs_cb type~rmvs_cb->type~whm_cb type~symba_cb symba_cb type~symba_cb->type~helio_cb type~helio_tp helio_tp type~helio_tp->type~swiftest_tp type~whm_pl whm_pl type~whm_pl->type~swiftest_pl type~rmvs_nbody_system rmvs_nbody_system type~rmvs_nbody_system->type~whm_nbody_system type~helio_nbody_system helio_nbody_system type~helio_nbody_system->type~whm_nbody_system type~rmvs_tp rmvs_tp type~rmvs_tp->type~whm_tp type~rmvs_tp->type~rmvs_cb cb_heliocentric type~rmvs_pl rmvs_pl type~rmvs_pl->type~whm_pl type~rmvs_pl->type~rmvs_nbody_system planetocentric type~symba_pl symba_pl type~symba_pl->type~helio_pl type~symba_tp symba_tp type~symba_tp->type~helio_tp type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~helio_nbody_system type~symba_merger symba_merger type~symba_nbody_system->type~symba_merger pl_adds type~symba_merger->type~symba_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate Type-Bound Procedures dump initialize read_frame write_frame Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step Type-Bound Procedures procedure, public :: dump => io_dump_swiftest interface public module subroutine io_dump_swiftest(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure( abstract_initialize ), public, deferred :: initialize subroutine abstract_initialize(self, param) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure( abstract_read_frame ), public, deferred :: read_frame subroutine abstract_read_frame(self, iu, param, form, ierr) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure( abstract_write_frame ), public, deferred :: write_frame subroutine abstract_write_frame(self, iu, param) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"type/swiftest_base.html"},{"title":"swiftest_cb – swiftest ","text":"type, public, abstract, extends( swiftest_base ) :: swiftest_cb A concrete lass for the central body in a Swiftest simulation Inherits type~~swiftest_cb~~InheritsGraph type~swiftest_cb swiftest_cb type~swiftest_base swiftest_base type~swiftest_cb->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~swiftest_cb~~InheritedByGraph type~swiftest_cb swiftest_cb type~helio_cb helio_cb type~helio_cb->type~swiftest_cb type~whm_cb whm_cb type~whm_cb->type~swiftest_cb type~swiftest_nbody_system swiftest_nbody_system type~swiftest_nbody_system->type~swiftest_cb cb type~whm_nbody_system whm_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~rmvs_cb rmvs_cb type~rmvs_cb->type~whm_cb type~symba_cb symba_cb type~symba_cb->type~helio_cb type~rmvs_nbody_system rmvs_nbody_system type~rmvs_nbody_system->type~whm_nbody_system type~helio_nbody_system helio_nbody_system type~helio_nbody_system->type~whm_nbody_system type~rmvs_tp rmvs_tp type~rmvs_tp->type~rmvs_cb cb_heliocentric type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~helio_nbody_system type~rmvs_pl rmvs_pl type~rmvs_pl->type~rmvs_nbody_system planetocentric Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate name id mass Gmass radius density j2rp2 j4rp4 aobl atide aoblbeg aoblend atidebeg atideend xb vb agr Ip rot k2 Q tlag L0 dL Type-Bound Procedures dump initialize read_frame write_frame Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step character(len=STRMAX), public :: name Non-unique name integer(kind=I4B), public :: id = 0 External identifier (unique) real(kind=DP), public :: mass = 0.0_DP Central body mass (units MU) real(kind=DP), public :: Gmass = 0.0_DP Central mass gravitational term G * mass (units GU * MU) real(kind=DP), public :: radius = 0.0_DP Central body radius (units DU) real(kind=DP), public :: density = 1.0_DP Central body mass density - calculated internally (units MU / DU**3) real(kind=DP), public :: j2rp2 = 0.0_DP J2*R&#94;2 term for central body real(kind=DP), public :: j4rp4 = 0.0_DP J4*R&#94;2 term for central body real(kind=DP), public, dimension(NDIM) :: aobl = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: atide = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: aoblbeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: aoblend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: atidebeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: atideend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: xb = 0.0_DP Barycentric position (units DU) real(kind=DP), public, dimension(NDIM) :: vb = 0.0_DP Barycentric velocity (units DU / TU) real(kind=DP), public, dimension(NDIM) :: agr = 0.0_DP Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(NDIM) :: Ip = 0.0_DP Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(NDIM) :: rot = 0.0_DP Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public :: k2 = 0.0_DP Tidal Love number real(kind=DP), public :: Q = 0.0_DP Tidal quality factor real(kind=DP), public :: tlag = 0.0_DP Tidal phase lag angle real(kind=DP), public, dimension(NDIM) :: L0 = 0.0_DP Initial angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: dL = 0.0_DP Change in angular momentum of the central body Type-Bound Procedures procedure, public :: dump => io_dump_swiftest interface public module subroutine io_dump_swiftest(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: initialize => io_read_cb_in I/O routine for reading in central body data interface public module subroutine io_read_cb_in(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_cb I/O routine for reading out a single frame of time-series data for the central body interface public module subroutine io_read_frame_cb(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_frame => io_write_frame_cb I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_cb(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"type/swiftest_cb.html"},{"title":"swiftest_body – swiftest ","text":"type, public, abstract, extends( swiftest_base ) :: swiftest_body An abstract class for a generic collection of Swiftest bodies\n Superclass that defines the generic elements of a Swiftest particle Inherits type~~swiftest_body~~InheritsGraph type~swiftest_body swiftest_body type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~swiftest_body~~InheritedByGraph type~swiftest_body swiftest_body type~swiftest_tp swiftest_tp type~swiftest_tp->type~swiftest_body type~swiftest_pl swiftest_pl type~swiftest_pl->type~swiftest_body type~whm_tp whm_tp type~whm_tp->type~swiftest_tp type~swiftest_nbody_system swiftest_nbody_system type~swiftest_nbody_system->type~swiftest_tp tp, tp_discards type~swiftest_nbody_system->type~swiftest_pl pl, pl_discards type~helio_pl helio_pl type~helio_pl->type~swiftest_pl type~helio_tp helio_tp type~helio_tp->type~swiftest_tp type~whm_pl whm_pl type~whm_pl->type~swiftest_pl type~rmvs_tp rmvs_tp type~rmvs_tp->type~whm_tp type~rmvs_pl rmvs_pl type~rmvs_pl->type~whm_pl type~rmvs_nbody_system rmvs_nbody_system type~rmvs_pl->type~rmvs_nbody_system planetocentric type~symba_pl symba_pl type~symba_pl->type~helio_pl type~symba_tp symba_tp type~symba_tp->type~helio_tp type~whm_nbody_system whm_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~rmvs_nbody_system->type~whm_nbody_system type~helio_nbody_system helio_nbody_system type~helio_nbody_system->type~whm_nbody_system type~symba_merger symba_merger type~symba_merger->type~symba_pl type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~helio_nbody_system type~symba_nbody_system->type~symba_merger pl_adds Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate lfirst nbody name id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm Type-Bound Procedures dump discard kick set_mu step accel drift v2pv pv2v initialize read_frame write_frame accel_obl el2xv xv2el setup accel_user append fill resize set_ir3 sort rearrange spill Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill Type-Bound Procedures procedure, public :: dump => io_dump_swiftest interface public module subroutine io_dump_swiftest(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure( abstract_discard_body ), public, deferred :: discard subroutine abstract_discard_body(self, system, param) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure( abstract_kick_body ), public, deferred :: kick subroutine abstract_kick_body(self, system, param, t, dt, lbeg) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system objec class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure( abstract_set_mu ), public, deferred :: set_mu subroutine abstract_set_mu(self, cb) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure( abstract_step_body ), public, deferred :: step subroutine abstract_step_body(self, system, param, t, dt) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure( abstract_accel ), public, deferred :: accel subroutine abstract_accel(self, system, param, t, lbeg) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables interface public module subroutine drift_body(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file interface public module subroutine io_read_body_in(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_read_frame_body(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: accel_obl => obl_acc_body Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_body(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: setup => setup_body A constructor that sets the number of bodies and allocates all allocatable arrays interface public module subroutine setup_body(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: append => util_append_body Appends elements from one structure to another interface public module subroutine util_append_body(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: fill => util_fill_body \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine util_fill_body(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: resize => util_resize_body Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. interface public module subroutine util_resize_body(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object procedure, public :: sort => util_sort_body Sorts body arrays by a sortable componen interface public module subroutine util_sort_body(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => util_sort_rearrange_body Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine util_sort_rearrange_body(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => util_spill_body \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine util_spill_body(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"type/swiftest_body.html"},{"title":"swiftest_pl – swiftest ","text":"type, public, abstract, extends( swiftest_body ) :: swiftest_pl An abstract class for a generic collection of Swiftest massive bodies\n Superclass that defines the generic elements of a Swiftest particle Inherits type~~swiftest_pl~~InheritsGraph type~swiftest_pl swiftest_pl type~swiftest_body swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~swiftest_pl~~InheritedByGraph type~swiftest_pl swiftest_pl type~whm_pl whm_pl type~whm_pl->type~swiftest_pl type~helio_pl helio_pl type~helio_pl->type~swiftest_pl type~swiftest_nbody_system swiftest_nbody_system type~swiftest_nbody_system->type~swiftest_pl pl, pl_discards type~whm_nbody_system whm_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~rmvs_pl rmvs_pl type~rmvs_pl->type~whm_pl type~rmvs_nbody_system rmvs_nbody_system type~rmvs_pl->type~rmvs_nbody_system planetocentric type~symba_pl symba_pl type~symba_pl->type~helio_pl type~rmvs_nbody_system->type~whm_nbody_system type~helio_nbody_system helio_nbody_system type~helio_nbody_system->type~whm_nbody_system type~symba_merger symba_merger type~symba_merger->type~symba_pl type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~helio_nbody_system type~symba_nbody_system->type~symba_merger pl_adds Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate lfirst nbody name id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm mass Gmass rhill radius xbeg xend vbeg density Ip rot k2 Q tlag k_plpl nplpl Type-Bound Procedures dump kick step accel drift v2pv pv2v initialize read_frame write_frame el2xv xv2el accel_user set_ir3 discard eucl_index accel_int accel_obl setup accel_tides append h2b b2h fill resize set_beg_end set_mu set_rhill sort rearrange spill Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl Type-Bound Procedures procedure, public :: dump => io_dump_swiftest interface public module subroutine io_dump_swiftest(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure( abstract_kick_body ), public, deferred :: kick subroutine abstract_kick_body(self, system, param, t, dt, lbeg) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system objec class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure( abstract_step_body ), public, deferred :: step subroutine abstract_step_body(self, system, param, t, dt) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure( abstract_accel ), public, deferred :: accel subroutine abstract_accel(self, system, param, t, lbeg) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables interface public module subroutine drift_body(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file interface public module subroutine io_read_body_in(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_read_frame_body(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object procedure, public :: discard => discard_pl Placeholder method for discarding massive bodies interface public module subroutine discard_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameter procedure, public :: eucl_index => eucl_dist_index_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix interface public module subroutine eucl_dist_index_plpl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies interface public pure module subroutine kick_getacch_int_pl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: setup => setup_pl A base constructor that sets the number of bodies and allocates and initializes all arrays interface public module subroutine setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body interface public module subroutine tides_kick_getacch_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: append => util_append_pl Appends elements from one structure to another interface public module subroutine util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: fill => util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: resize => util_resize_pl Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. interface public module subroutine util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. interface public module subroutine util_set_beg_end_pl(self, xbeg, xend, vbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object real(kind=DP), intent(in), optional dimension(:,:) :: xbeg Position vectors at beginning of step real(kind=DP), intent(in), optional dimension(:,:) :: xend Positions vectors at end of step real(kind=DP), intent(in), optional dimension(:,:) :: vbeg vbeg is an unused variable to keep this method forward compatible with RMVS procedure, public :: set_mu => util_set_mu_pl Method used to construct the vectorized form of the central body mass interface public module subroutine util_set_mu_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body interface public module subroutine util_set_rhill(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: sort => util_sort_pl Sorts body arrays by a sortable component interface public module subroutine util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"type/swiftest_pl.html"},{"title":"swiftest_tp – swiftest ","text":"type, public, abstract, extends( swiftest_body ) :: swiftest_tp An abstract class for a generic collection of Swiftest test particles\n Superclass that defines the generic elements of a Swiftest test particle Inherits type~~swiftest_tp~~InheritsGraph type~swiftest_tp swiftest_tp type~swiftest_body swiftest_body type~swiftest_tp->type~swiftest_body type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~swiftest_tp~~InheritedByGraph type~swiftest_tp swiftest_tp type~helio_tp helio_tp type~helio_tp->type~swiftest_tp type~whm_tp whm_tp type~whm_tp->type~swiftest_tp type~swiftest_nbody_system swiftest_nbody_system type~swiftest_nbody_system->type~swiftest_tp tp, tp_discards type~rmvs_tp rmvs_tp type~rmvs_tp->type~whm_tp type~symba_tp symba_tp type~symba_tp->type~helio_tp type~whm_nbody_system whm_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~rmvs_nbody_system rmvs_nbody_system type~rmvs_nbody_system->type~whm_nbody_system type~helio_nbody_system helio_nbody_system type~helio_nbody_system->type~whm_nbody_system type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~helio_nbody_system type~rmvs_pl rmvs_pl type~rmvs_pl->type~rmvs_nbody_system planetocentric Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate lfirst nbody name id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm isperi peri atp Type-Bound Procedures dump kick step accel drift v2pv pv2v initialize read_frame write_frame el2xv xv2el accel_user set_ir3 discard accel_int accel_obl setup append h2b b2h fill get_peri resize set_mu sort rearrange spill Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill integer(kind=I4B), public, dimension(:), allocatable :: isperi Perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri Perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp Semimajor axis following perihelion passage\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_tp and util_spill_tp Type-Bound Procedures procedure, public :: dump => io_dump_swiftest interface public module subroutine io_dump_swiftest(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure( abstract_kick_body ), public, deferred :: kick subroutine abstract_kick_body(self, system, param, t, dt, lbeg) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system objec class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure( abstract_step_body ), public, deferred :: step subroutine abstract_step_body(self, system, param, t, dt) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure( abstract_accel ), public, deferred :: accel subroutine abstract_accel(self, system, param, t, lbeg) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables interface public module subroutine drift_body(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file interface public module subroutine io_read_body_in(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_read_frame_body(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object procedure, public :: discard => discard_tp Check to see if test particles should be discarded based on their positions relative to the massive bodies interface public module subroutine discard_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: accel_int => kick_getacch_int_tp Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies interface public pure module subroutine kick_getacch_int_tp(self, GMpl, xhp, npl) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle real(kind=DP), intent(in), dimension(:) :: GMpl Massive body masses real(kind=DP), intent(in), dimension(:,:) :: xhp Massive body position vectors integer(kind=I4B), intent(in) :: npl Number of active massive bodies procedure, public :: accel_obl => obl_acc_tp Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_tp(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: setup => setup_tp A base constructor that sets the number of bodies and interface public module subroutine setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parametersr procedure, public :: append => util_append_tp Appends elements from one structure to another interface public module subroutine util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: h2b => util_coord_h2b_tp Convert test particles from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_tp Convert test particles from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: fill => util_fill_tp \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: get_peri => util_peri_tp Determine system pericenter passages for test particles interface public module subroutine util_peri_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: resize => util_resize_tp Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. interface public module subroutine util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: set_mu => util_set_mu_tp Method used to construct the vectorized form of the central body mass interface public module subroutine util_set_mu_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: sort => util_sort_tp Sorts body arrays by a sortable component interface public module subroutine util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => util_sort_rearrange_tp Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => util_spill_tp \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"type/swiftest_tp.html"},{"title":"swiftest_nbody_system – swiftest ","text":"type, public, abstract, extends( swiftest_base ) :: swiftest_nbody_system An abstract class for a basic Swiftest nbody system \n  This superclass contains a minimial system of a set of test particles (tp), massive bodies (pl), and a central body (cb) Inherits type~~swiftest_nbody_system~~InheritsGraph type~swiftest_nbody_system swiftest_nbody_system type~swiftest_cb swiftest_cb type~swiftest_nbody_system->type~swiftest_cb cb type~swiftest_base swiftest_base type~swiftest_nbody_system->type~swiftest_base type~swiftest_tp swiftest_tp type~swiftest_nbody_system->type~swiftest_tp tp, tp_discards type~swiftest_pl swiftest_pl type~swiftest_nbody_system->type~swiftest_pl pl, pl_discards type~swiftest_cb->type~swiftest_base type~swiftest_body swiftest_body type~swiftest_tp->type~swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~swiftest_nbody_system~~InheritedByGraph type~swiftest_nbody_system swiftest_nbody_system type~whm_nbody_system whm_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~rmvs_nbody_system rmvs_nbody_system type~rmvs_nbody_system->type~whm_nbody_system type~helio_nbody_system helio_nbody_system type~helio_nbody_system->type~whm_nbody_system type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~helio_nbody_system type~rmvs_pl rmvs_pl type~rmvs_pl->type~rmvs_nbody_system planetocentric Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lintegrate cb pl tp tp_discards pl_discards Gmtot ke_orbit ke_spin pe te Lorbit Lspin Lescape Mescape Ecollisions Euntracked lbeg maxid Type-Bound Procedures step discard conservation_report dump read_frame write_discard write_frame initialize step_spin set_msys get_energy_and_momentum rescale validate_ids Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step class( swiftest_cb ), public, allocatable :: cb Central body data structure class( swiftest_pl ), public, allocatable :: pl Massive body data structure class( swiftest_tp ), public, allocatable :: tp Test particle data structure class( swiftest_tp ), public, allocatable :: tp_discards Discarded test particle data structure class( swiftest_pl ), public, allocatable :: pl_discards Discarded massive body particle data structure real(kind=DP), public :: Gmtot = 0.0_DP Total system mass - used for barycentric coordinate conversion real(kind=DP), public :: ke_orbit = 0.0_DP System orbital kinetic energy real(kind=DP), public :: ke_spin = 0.0_DP System spin kinetic energy real(kind=DP), public :: pe = 0.0_DP System potential energy real(kind=DP), public :: te = 0.0_DP System total energy real(kind=DP), public, dimension(NDIM) :: Lorbit = 0.0_DP System orbital angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lspin = 0.0_DP System spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lescape = 0.0_DP Angular momentum of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Mescape = 0.0_DP Mass of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Ecollisions = 0.0_DP Energy lost from system due to collisions real(kind=DP), public :: Euntracked = 0.0_DP Energy gained from system due to escaped bodies logical, public :: lbeg True if this is the beginning of a step. This is used so that test particle steps can be calculated \n    separately from massive bodies.  Massive body variables are saved at half steps, and passed to \n    the test particles integer(kind=I4B), public :: maxid = -1 The current maximum particle id number Type-Bound Procedures procedure( abstract_step_system ), public, deferred :: step Each integrator will have its own version of the step subroutine abstract_step_system(self, param, t, dt) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure, public :: discard => discard_system Perform a discard step on the system interface public module subroutine discard_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: conservation_report => io_conservation_report Compute energy and momentum and print out the change with time interface public module subroutine io_conservation_report(self, param, lterminal) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Input colleciton of user-defined parameters logical, intent(in) :: lterminal Indicates whether to output information to the terminal screen procedure, public :: dump => io_dump_system Dump the state of the system to a file interface public module subroutine io_dump_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_system Read in a frame of input data from file interface public module subroutine io_read_frame_system(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code procedure, public :: write_discard => io_write_discard Write out information about discarded test particles interface public module subroutine io_write_discard(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_frame => io_write_frame_system Append a frame of output data to file interface public module subroutine io_write_frame_system(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: initialize => setup_initialize_system Initialize the system from input files interface public module subroutine setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: step_spin => tides_step_spin_system Steps the spins of the massive & central bodies due to tides. interface public module subroutine tides_step_spin_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure, public :: set_msys => util_set_msys Sets the value of msys from the masses of system bodies. interface public module subroutine util_set_msys(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object procedure, public :: get_energy_and_momentum => util_get_energy_momentum_system Calculates the total system energy and momentum interface public module subroutine util_get_energy_momentum_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: rescale => util_rescale_system Rescales the system into a new set of units interface public module subroutine util_rescale_system(self, param, mscale, dscale, tscale) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters. Returns with new values of the scale vactors and GU real(kind=DP), intent(in) :: mscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: dscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: tscale Scale factors for mass, distance, and time units, respectively. procedure, public :: validate_ids => util_valid_id_system Validate the numerical ids passed to the system and save the maximum value interface public module subroutine util_valid_id_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"type/swiftest_nbody_system.html"},{"title":"swiftest_encounter – swiftest ","text":"type, public :: swiftest_encounter Inherited by type~~swiftest_encounter~~InheritedByGraph type~swiftest_encounter swiftest_encounter type~symba_pltpenc symba_pltpenc type~symba_pltpenc->type~swiftest_encounter type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~symba_pltpenc pltpenc_list type~symba_plplenc symba_plplenc type~symba_nbody_system->type~symba_plplenc plplenc_list type~symba_plplenc->type~symba_pltpenc Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nenc lvdotr status index1 index2 x1 x2 v1 v2 Type-Bound Procedures setup copy spill resize Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: nenc Total number of encounters logical, public, dimension(:), allocatable :: lvdotr relative vdotr flag integer(kind=I4B), public, dimension(:), allocatable :: status status of the interaction integer(kind=I4B), public, dimension(:), allocatable :: index1 position of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: index2 position of the second body in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x1 the position of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x2 the position of body 2 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v1 the velocity of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v2 the velocity of body 2 in the encounter Type-Bound Procedures procedure, public :: setup => setup_encounter A constructor that sets the number of encounters and allocates and initializes all arrays interface public module subroutine setup_encounter(self, n) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for procedure, public :: copy => util_copy_encounter Copies elements from the source encounter list into self. interface public module subroutine util_copy_encounter(self, source) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Encounter list class( swiftest_encounter ), intent(in) :: source Source object to copy into procedure, public :: spill => util_spill_encounter \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine util_spill_encounter(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list procedure, public :: resize => util_resize_encounter Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small. interface public module subroutine util_resize_encounter(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list integer(kind=I4B), intent(in) :: nnew New size of list needed","tags":"","loc":"type/swiftest_encounter.html"},{"title":"lambda_obj – swiftest ","text":"type, public :: lambda_obj Base class for an lambda function object. This object takes no additional arguments other than the dependent variable x, an array of real numbers Inherited by type~~lambda_obj~~InheritedByGraph type~lambda_obj lambda_obj type~lambda_obj_tvar lambda_obj_tvar type~lambda_obj_tvar->type~lambda_obj type~lambda_obj_err lambda_obj_err type~lambda_obj_err->type~lambda_obj Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lambdaptr lastval lastarg Constructor lambda_obj Finalization Procedures lambda_destroy Type-Bound Procedures init eval lambda_init_0 Components Type Visibility Attributes Name Initial procedure( lambda0 ), public, pointer, nopass :: lambdaptr => null() real(kind=DP), public :: lastval real(kind=DP), public, dimension(:), allocatable :: lastarg Constructor public interface lambda_obj public function lambda_init_0 (lambda) Arguments Type Intent Optional Attributes Name procedure( lambda0 ) :: lambda Return Value type( lambda_obj ) public function lambda_init_0_err (lambda, lerr) Arguments Type Intent Optional Attributes Name procedure( lambda0err ) :: lambda logical, intent(in) :: lerr Return Value type( lambda_obj_err ) public function lambda_init_tvar (lambda, t) Arguments Type Intent Optional Attributes Name procedure( lambda0tvar ) :: lambda real(kind=DP), intent(in) :: t Return Value type( lambda_obj_tvar ) Finalization Procedures final :: lambda_destroy public subroutine lambda_destroy (self) Arguments Type Intent Optional Attributes Name type( lambda_obj ) :: self Type-Bound Procedures generic, public :: init => lambda_init_0 public function lambda_init_0 (lambda) Arguments Type Intent Optional Attributes Name procedure( lambda0 ) :: lambda Return Value type( lambda_obj ) procedure, public :: eval => lambda_eval_0 public function lambda_eval_0 (self, x) result(y) Arguments Type Intent Optional Attributes Name class( lambda_obj ), intent(inout) :: self real(kind=DP), intent(in), dimension(:) :: x Return Value real(kind=DP) procedure, public, nopass :: lambda_init_0 public function lambda_init_0 (lambda) Arguments Type Intent Optional Attributes Name procedure( lambda0 ) :: lambda Return Value type( lambda_obj )","tags":"","loc":"type/lambda_obj.html"},{"title":"lambda_obj_err – swiftest ","text":"type, public, extends( lambda_obj ) :: lambda_obj_err Extended class for an lambda function object. This object takes allows for the return of a logical error flag during evaluation of the function. Inherits type~~lambda_obj_err~~InheritsGraph type~lambda_obj_err lambda_obj_err type~lambda_obj lambda_obj type~lambda_obj_err->type~lambda_obj Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lambdaptr lastval lastarg lambdaptr_err lerr Type-Bound Procedures lambda_init_0 init eval lambda_init_0_err Components Type Visibility Attributes Name Initial procedure( lambda0 ), public, pointer, nopass :: lambdaptr => null() real(kind=DP), public :: lastval real(kind=DP), public, dimension(:), allocatable :: lastarg procedure( lambda0err ), public, pointer, nopass :: lambdaptr_err => null() logical, public :: lerr Type-Bound Procedures procedure, public, nopass :: lambda_init_0 public function lambda_init_0 (lambda) Arguments Type Intent Optional Attributes Name procedure( lambda0 ) :: lambda Return Value type( lambda_obj ) generic, public :: init => lambda_init_0 , lambda_init_0_err public function lambda_init_0 (lambda) Arguments Type Intent Optional Attributes Name procedure( lambda0 ) :: lambda Return Value type( lambda_obj ) public function lambda_init_0_err (lambda, lerr) Arguments Type Intent Optional Attributes Name procedure( lambda0err ) :: lambda logical, intent(in) :: lerr Return Value type( lambda_obj_err ) procedure, public :: eval => lambda_eval_0_err public function lambda_eval_0_err (self, x) result(y) Arguments Type Intent Optional Attributes Name class( lambda_obj_err ), intent(inout) :: self real(kind=DP), intent(in), dimension(:) :: x Return Value real(kind=DP) procedure, public, nopass :: lambda_init_0_err public function lambda_init_0_err (lambda, lerr) Arguments Type Intent Optional Attributes Name procedure( lambda0err ) :: lambda logical, intent(in) :: lerr Return Value type( lambda_obj_err )","tags":"","loc":"type/lambda_obj_err.html"},{"title":"lambda_obj_tvar – swiftest ","text":"type, public, extends( lambda_obj ) :: lambda_obj_tvar Base class for an lambda function object. This object takes no additional arguments other than the dependent variable x, an array of real numbers Inherits type~~lambda_obj_tvar~~InheritsGraph type~lambda_obj_tvar lambda_obj_tvar type~lambda_obj lambda_obj type~lambda_obj_tvar->type~lambda_obj Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lambdaptr lastval lastarg lambdaptr_tvar Type-Bound Procedures eval lambda_init_0 init evalt lambda_init_tvar Components Type Visibility Attributes Name Initial procedure( lambda0 ), public, pointer, nopass :: lambdaptr => null() real(kind=DP), public :: lastval real(kind=DP), public, dimension(:), allocatable :: lastarg procedure( lambda0tvar ), public, pointer, nopass :: lambdaptr_tvar => null() Type-Bound Procedures procedure, public :: eval => lambda_eval_0 public function lambda_eval_0 (self, x) result(y) Arguments Type Intent Optional Attributes Name class( lambda_obj ), intent(inout) :: self real(kind=DP), intent(in), dimension(:) :: x Return Value real(kind=DP) procedure, public, nopass :: lambda_init_0 public function lambda_init_0 (lambda) Arguments Type Intent Optional Attributes Name procedure( lambda0 ) :: lambda Return Value type( lambda_obj ) generic, public :: init => lambda_init_0 , lambda_init_tvar public function lambda_init_0 (lambda) Arguments Type Intent Optional Attributes Name procedure( lambda0 ) :: lambda Return Value type( lambda_obj ) public function lambda_init_tvar (lambda, t) Arguments Type Intent Optional Attributes Name procedure( lambda0tvar ) :: lambda real(kind=DP), intent(in) :: t Return Value type( lambda_obj_tvar ) procedure, public :: evalt => lambda_eval_tvar public function lambda_eval_tvar (self, x, t) result(y) Arguments Type Intent Optional Attributes Name class( lambda_obj_tvar ), intent(inout) :: self real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in) :: t Return Value real(kind=DP),\n  dimension(:), allocatable procedure, public, nopass :: lambda_init_tvar public function lambda_init_tvar (lambda, t) Arguments Type Intent Optional Attributes Name procedure( lambda0tvar ) :: lambda real(kind=DP), intent(in) :: t Return Value type( lambda_obj_tvar )","tags":"","loc":"type/lambda_obj_tvar.html"},{"title":"tidederiv – swiftest","text":"abstract interface function tidederiv(x, t, dt, xbeg, xend) result(y) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), dimension(:,:) :: xbeg real(kind=DP), intent(in), dimension(:,:) :: xend Return Value real(kind=DP),\n  dimension(:),allocatable","tags":"","loc":"interface/tidederiv.html"},{"title":"abstract_discard_body – swiftest","text":"abstract interface public subroutine abstract_discard_body(self, system, param) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/abstract_discard_body.html"},{"title":"abstract_accel – swiftest","text":"abstract interface public subroutine abstract_accel(self, system, param, t, lbeg) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step","tags":"","loc":"interface/abstract_accel.html"},{"title":"abstract_initialize – swiftest","text":"abstract interface public subroutine abstract_initialize(self, param) Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/abstract_initialize.html"},{"title":"abstract_kick_body – swiftest","text":"abstract interface public subroutine abstract_kick_body(self, system, param, t, dt, lbeg) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system objec class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not.","tags":"","loc":"interface/abstract_kick_body.html"},{"title":"abstract_read_frame – swiftest","text":"abstract interface public subroutine abstract_read_frame(self, iu, param, form, ierr) Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code","tags":"","loc":"interface/abstract_read_frame.html"},{"title":"abstract_set_mu – swiftest","text":"abstract interface public subroutine abstract_set_mu(self, cb) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/abstract_set_mu.html"},{"title":"abstract_step_body – swiftest","text":"abstract interface public subroutine abstract_step_body(self, system, param, t, dt) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"interface/abstract_step_body.html"},{"title":"abstract_step_system – swiftest","text":"abstract interface public subroutine abstract_step_system(self, param, t, dt) Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"interface/abstract_step_system.html"},{"title":"abstract_write_frame – swiftest","text":"abstract interface public subroutine abstract_write_frame(self, iu, param) Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/abstract_write_frame.html"},{"title":"lambda0 – swiftest","text":"abstract interface public function lambda0(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: x Return Value real(kind=DP)","tags":"","loc":"interface/lambda0.html"},{"title":"lambda0err – swiftest","text":"abstract interface public function lambda0err(x, lerr) result(y) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: x logical, intent(out) :: lerr Return Value real(kind=DP)","tags":"","loc":"interface/lambda0err.html"},{"title":"lambda0tvar – swiftest","text":"abstract interface public function lambda0tvar(x, t) result(y) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in) :: t Return Value real(kind=DP),\n  dimension(:),allocatable","tags":"","loc":"interface/lambda0tvar.html"},{"title":"tides_spin_derivs – swiftest","text":"function tides_spin_derivs(rot_pl_cb, t, dt, xbeg, xend) result(drot) Need to add more arguments so we can pull in mass, radius, Ip, J2, etc...\n author: Jennifer L.L. Pouplin and David A. Minton function used to calculate the derivatives that are fed to the ODE solver Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: rot_pl_cb Array of rotations. The last element is the central body, and all others are massive bodies real(kind=DP), intent(in) :: t Current time, which is used to interpolate the massive body positions real(kind=DP), intent(in) :: dt Total step size real(kind=DP), intent(in), dimension(:,:) :: xbeg real(kind=DP), intent(in), dimension(:,:) :: xend Return Value real(kind=DP),\n  dimension(:,:),allocatable Contents None","tags":"","loc":"proc/tides_spin_derivs.html"},{"title":"tides_derivs_eval – swiftest","text":"function tides_derivs_eval(self, x, t) result(y) Arguments Type Intent Optional Attributes Name class( tides_derivs_func ), intent(inout) :: self real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in) :: t Return Value real(kind=DP),\n  dimension(:),allocatable Contents None","tags":"","loc":"proc/tides_derivs_eval.html"},{"title":"tides_derivs_init – swiftest","text":"function tides_derivs_init(lambda, dt, xbeg, xend) result(f) Arguments Type Intent Optional Attributes Name procedure( tidederiv ) :: lambda real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), dimension(:,:) :: xbeg real(kind=DP), intent(in), dimension(:,:) :: xend Return Value type( tides_derivs_func ) Called by proc~~tides_derivs_init~~CalledByGraph proc~tides_derivs_init tides_derivs_init interface~lambda_obj lambda_obj interface~lambda_obj->proc~tides_derivs_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/tides_derivs_init.html"},{"title":"lambda_obj – swiftest","text":"private interface lambda_obj Calls interface~~lambda_obj~~CallsGraph interface~lambda_obj lambda_obj proc~tides_derivs_init tides_derivs_init interface~lambda_obj->proc~tides_derivs_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures tides_derivs_init Module Procedures function tides_derivs_init (lambda, dt, xbeg, xend) result(f) Arguments Type Intent Optional Attributes Name procedure( tidederiv ) :: lambda real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), dimension(:,:) :: xbeg real(kind=DP), intent(in), dimension(:,:) :: xend Return Value type( tides_derivs_func )","tags":"","loc":"interface/lambda_obj.html"},{"title":"orbel_flon – swiftest","text":"pure function orbel_flon(e, icapn) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: icapn Return Value real(kind=DP) Calls proc~~orbel_flon~~CallsGraph proc~orbel_flon orbel_flon 3 3 proc~orbel_flon->3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~orbel_flon~~CalledByGraph proc~orbel_flon orbel_flon proc~orbel_fhybrid orbel_fhybrid proc~orbel_fhybrid->proc~orbel_flon proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->proc~orbel_fhybrid proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_flon.html"},{"title":"orbel_fget – swiftest","text":"pure function orbel_fget(e, capn) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: capn Return Value real(kind=DP) Calls proc~~orbel_fget~~CallsGraph proc~orbel_fget orbel_fget proc~orbel_schget orbel_schget proc~orbel_fget->proc~orbel_schget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~orbel_fget~~CalledByGraph proc~orbel_fget orbel_fget proc~orbel_fhybrid orbel_fhybrid proc~orbel_fhybrid->proc~orbel_fget proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->proc~orbel_fhybrid proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_fget.html"},{"title":"orbel_zget – swiftest","text":"pure function orbel_zget(iq) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: iq Return Value real(kind=DP) Called by proc~~orbel_zget~~CalledByGraph proc~orbel_zget orbel_zget proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->proc~orbel_zget proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_zget.html"},{"title":"orbel_esolmd – swiftest","text":"pure function orbel_esolmd(e, m) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: m Return Value real(kind=DP) Calls proc~~orbel_esolmd~~CallsGraph proc~orbel_esolmd orbel_esolmd interface~orbel_scget orbel_scget proc~orbel_esolmd->interface~orbel_scget proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~orbel_esolmd~~CalledByGraph proc~orbel_esolmd orbel_esolmd proc~orbel_ehybrid orbel_ehybrid proc~orbel_ehybrid->proc~orbel_esolmd proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->proc~orbel_ehybrid proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_esolmd.html"},{"title":"orbel_ehie – swiftest","text":"pure function orbel_ehie(e, im) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: im Return Value real(kind=DP) Calls proc~~orbel_ehie~~CallsGraph proc~orbel_ehie orbel_ehie interface~orbel_scget orbel_scget proc~orbel_ehie->interface~orbel_scget proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~orbel_ehie~~CalledByGraph proc~orbel_ehie orbel_ehie proc~orbel_ehybrid orbel_ehybrid proc~orbel_ehybrid->proc~orbel_ehie proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->proc~orbel_ehybrid proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_ehie.html"},{"title":"orbel_eget – swiftest","text":"pure function orbel_eget(e, m) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: m Return Value real(kind=DP) Calls proc~~orbel_eget~~CallsGraph proc~orbel_eget orbel_eget interface~orbel_scget orbel_scget proc~orbel_eget->interface~orbel_scget proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~orbel_eget~~CalledByGraph proc~orbel_eget orbel_eget proc~orbel_ehybrid orbel_ehybrid proc~orbel_ehybrid->proc~orbel_eget proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->proc~orbel_ehybrid proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_eget.html"},{"title":"orbel_ehybrid – swiftest","text":"pure function orbel_ehybrid(e, m) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: m Return Value real(kind=DP) Calls proc~~orbel_ehybrid~~CallsGraph proc~orbel_ehybrid orbel_ehybrid proc~orbel_esolmd orbel_esolmd proc~orbel_ehybrid->proc~orbel_esolmd proc~orbel_ehie orbel_ehie proc~orbel_ehybrid->proc~orbel_ehie proc~orbel_eget orbel_eget proc~orbel_ehybrid->proc~orbel_eget interface~orbel_scget orbel_scget proc~orbel_esolmd->interface~orbel_scget proc~orbel_ehie->interface~orbel_scget proc~orbel_eget->interface~orbel_scget proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~orbel_ehybrid~~CalledByGraph proc~orbel_ehybrid orbel_ehybrid proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->proc~orbel_ehybrid proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_ehybrid.html"},{"title":"orbel_fhybrid – swiftest","text":"pure function orbel_fhybrid(e, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: n Return Value real(kind=DP) Calls proc~~orbel_fhybrid~~CallsGraph proc~orbel_fhybrid orbel_fhybrid proc~orbel_fget orbel_fget proc~orbel_fhybrid->proc~orbel_fget proc~orbel_flon orbel_flon proc~orbel_fhybrid->proc~orbel_flon proc~orbel_schget orbel_schget proc~orbel_fget->proc~orbel_schget 3 3 proc~orbel_flon->3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~orbel_fhybrid~~CalledByGraph proc~orbel_fhybrid orbel_fhybrid proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->proc~orbel_fhybrid proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_fhybrid.html"},{"title":"orbel_el2xv – swiftest","text":"pure subroutine orbel_el2xv(mu, a, ie, inc, capom, omega, capm, x, v) Compute osculating orbital elements from relative C)rtesian position and velocity\n  All angular measures are returned in radians\n      If inclination < TINY, longitude of the ascending node is arbitrarily set to 0 If eccentricity < sqrt ( TINY ), argument of pericenter is arbitrarily set to 0 ALGORITHM : See Fitzpatrick \"Principles of Cel. Mech.\" Adapted from Martin Duncan's el2xv.f\n DATE WRITTEN:  May 11, 1992.\n REVISIONS: May 26 - now use better Kepler solver for ellipses\n  and hyperbolae called EHYBRID.F and FHYBRID.F Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: a real(kind=DP), intent(in) :: ie real(kind=DP), intent(in) :: inc real(kind=DP), intent(in) :: capom real(kind=DP), intent(in) :: omega real(kind=DP), intent(in) :: capm real(kind=DP), intent(out), dimension(:) :: x real(kind=DP), intent(out), dimension(:) :: v Calls proc~~orbel_el2xv~~CallsGraph proc~orbel_el2xv orbel_el2xv proc~orbel_fhybrid orbel_fhybrid proc~orbel_el2xv->proc~orbel_fhybrid proc~orbel_ehybrid orbel_ehybrid proc~orbel_el2xv->proc~orbel_ehybrid proc~orbel_schget orbel_schget proc~orbel_el2xv->proc~orbel_schget interface~orbel_scget orbel_scget proc~orbel_el2xv->interface~orbel_scget proc~orbel_zget orbel_zget proc~orbel_el2xv->proc~orbel_zget proc~orbel_flon orbel_flon proc~orbel_fhybrid->proc~orbel_flon proc~orbel_fget orbel_fget proc~orbel_fhybrid->proc~orbel_fget proc~orbel_esolmd orbel_esolmd proc~orbel_ehybrid->proc~orbel_esolmd proc~orbel_ehie orbel_ehie proc~orbel_ehybrid->proc~orbel_ehie proc~orbel_eget orbel_eget proc~orbel_ehybrid->proc~orbel_eget proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget proc~orbel_esolmd->interface~orbel_scget proc~orbel_ehie->interface~orbel_scget 3 3 proc~orbel_flon->3 proc~orbel_eget->interface~orbel_scget proc~orbel_fget->proc~orbel_schget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~orbel_el2xv~~CalledByGraph proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_el2xv.html"},{"title":"orbel_schget – swiftest","text":"pure subroutine orbel_schget(angle, shx, chx) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: angle real(kind=DP), intent(out) :: shx real(kind=DP), intent(out) :: chx Called by proc~~orbel_schget~~CalledByGraph proc~orbel_schget orbel_schget proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->proc~orbel_schget proc~orbel_fhybrid orbel_fhybrid proc~orbel_el2xv->proc~orbel_fhybrid proc~orbel_fget orbel_fget proc~orbel_fget->proc~orbel_schget proc~orbel_fhybrid->proc~orbel_fget proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_schget.html"},{"title":"orbel_xv2el – swiftest","text":"pure subroutine orbel_xv2el(mu, x, v, a, e, inc, capom, omega, capm) Compute osculating orbital elements from relative Cartesian position and velocity\n  All angular measures are returned in radians\n      If inclination < TINY, longitude of the ascending node is arbitrarily set to 0 If eccentricity < sqrt ( TINY ), argument of pericenter is arbitrarily set to 0 References : Danby , J . M . A . 1988 . Fundamentals of Celestial Mechanics , ( Willmann - Bell , Inc .), 201 - 206 . Fitzpatrick , P . M . 1970 . Principles of Celestial Mechanics , ( Academic Press ), 69 - 73 . Roy , A . E . 1982 . Orbital Motion , ( Adam Hilger , Ltd .), 75 - 95 Adapted from David E. Kaufmann's Swifter routine: orbel_xv2el.f90\n Adapted from Martin Duncan's Swift routine orbel_xv2el.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in), dimension(:) :: v real(kind=DP), intent(out) :: a real(kind=DP), intent(out) :: e real(kind=DP), intent(out) :: inc real(kind=DP), intent(out) :: capom real(kind=DP), intent(out) :: omega real(kind=DP), intent(out) :: capm Called by proc~~orbel_xv2el~~CalledByGraph proc~orbel_xv2el orbel_xv2el proc~orbel_xv2el_vec orbel_xv2el_vec proc~orbel_xv2el_vec->proc~orbel_xv2el interface~orbel_xv2el_vec orbel_xv2el_vec interface~orbel_xv2el_vec->proc~orbel_xv2el_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_xv2el.html"},{"title":"whm_kick_getacch_ah0 – swiftest","text":"function whm_kick_getacch_ah0(mu, xhp, n) result(ah0) Compute zeroth term heliocentric accelerations of planets Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: mu real(kind=DP), intent(in), dimension(:,:) :: xhp integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  dimension(NDIM) Called by proc~~whm_kick_getacch_ah0~~CalledByGraph proc~whm_kick_getacch_ah0 whm_kick_getacch_ah0 proc~whm_kick_getacch_pl whm_kick_getacch_pl proc~whm_kick_getacch_pl->proc~whm_kick_getacch_ah0 proc~whm_kick_getacch_tp whm_kick_getacch_tp proc~whm_kick_getacch_tp->proc~whm_kick_getacch_ah0 interface~whm_kick_getacch_pl whm_kick_getacch_pl interface~whm_kick_getacch_pl->proc~whm_kick_getacch_pl interface~whm_kick_getacch_tp whm_kick_getacch_tp interface~whm_kick_getacch_tp->proc~whm_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_kick_getacch_ah0.html"},{"title":"whm_kick_getacch_ah1 – swiftest","text":"pure subroutine whm_kick_getacch_ah1(cb, pl) Compute first term heliocentric accelerations of planets Adapted from Hal Levison's Swift routine getacch_ah1.f\n Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah1.f90 Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: cb WHM central body object class( whm_pl ), intent(inout) :: pl WHM massive body object Called by proc~~whm_kick_getacch_ah1~~CalledByGraph proc~whm_kick_getacch_ah1 whm_kick_getacch_ah1 proc~whm_kick_getacch_pl whm_kick_getacch_pl proc~whm_kick_getacch_pl->proc~whm_kick_getacch_ah1 interface~whm_kick_getacch_pl whm_kick_getacch_pl interface~whm_kick_getacch_pl->proc~whm_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_kick_getacch_ah1.html"},{"title":"whm_kick_getacch_ah2 – swiftest","text":"pure subroutine whm_kick_getacch_ah2(cb, pl) Compute second term heliocentric accelerations of planets Adapted from Hal Levison's Swift routine getacch_ah2.f\n Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah2.f90 Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: cb Swiftest central body object class( whm_pl ), intent(inout) :: pl WHM massive body object Called by proc~~whm_kick_getacch_ah2~~CalledByGraph proc~whm_kick_getacch_ah2 whm_kick_getacch_ah2 proc~whm_kick_getacch_pl whm_kick_getacch_pl proc~whm_kick_getacch_pl->proc~whm_kick_getacch_ah2 interface~whm_kick_getacch_pl whm_kick_getacch_pl interface~whm_kick_getacch_pl->proc~whm_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_kick_getacch_ah2.html"},{"title":"solve_wbs – swiftest","text":"function solve_wbs(u) result(x) Uses ieee_exceptions swiftest proc~~solve_wbs~~UsesGraph proc~solve_wbs solve_wbs ieee_exceptions ieee_exceptions proc~solve_wbs->ieee_exceptions module~swiftest swiftest proc~solve_wbs->module~swiftest module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Based on code available on Rosetta Code: https://rosettacode.org/wiki/Gaussian_elimination#Fortran Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:), allocatable :: u Return Value real(kind=QP),\n  dimension(:),allocatable Called by proc~~solve_wbs~~CalledByGraph proc~solve_wbs solve_wbs proc~util_solve_linear_system_d util_solve_linear_system_d proc~util_solve_linear_system_d->proc~solve_wbs proc~util_solve_linear_system_q util_solve_linear_system_q proc~util_solve_linear_system_q->proc~solve_wbs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/solve_wbs.html"},{"title":"ge_wpp – swiftest","text":"function ge_wpp(A, b) result(u) Uses ieee_exceptions swiftest proc~~ge_wpp~~UsesGraph proc~ge_wpp ge_wpp ieee_exceptions ieee_exceptions proc~ge_wpp->ieee_exceptions module~swiftest swiftest proc~ge_wpp->module~swiftest module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Solve  Ax=b  using Gaussian elimination then backwards substitution.\n   A being an n by n matrix.\n   x and b are n by 1 vectors. \n Based on code available on Rosetta Code: https://rosettacode.org/wiki/Gaussian_elimination#Fortran Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A real(kind=QP), intent(in), dimension(:) :: b Return Value real(kind=QP),\n  dimension(:,:),allocatable Called by proc~~ge_wpp~~CalledByGraph proc~ge_wpp ge_wpp proc~util_solve_linear_system_d util_solve_linear_system_d proc~util_solve_linear_system_d->proc~ge_wpp proc~util_solve_linear_system_q util_solve_linear_system_q proc~util_solve_linear_system_q->proc~ge_wpp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ge_wpp.html"},{"title":"discard_cb_tp – swiftest","text":"subroutine discard_cb_tp(tp, system, param) Check to see if test particles should be discarded based on their positions relative to the Sun\n        or because they are unbound from the system Adapted from David E. Kaufmann's Swifter routine: discard_sun.f90\n Adapted from Hal Levison's Swift routine discard_sun.f Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: tp Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Contents None","tags":"","loc":"proc/discard_cb_tp.html"},{"title":"discard_peri_tp – swiftest","text":"subroutine discard_peri_tp(tp, system, param) Check to see if a test particle should be discarded because its perihelion distance becomes too small Adapted from David E. Kaufmann's Swifter routine: discard_peri.f90\n Adapted from Hal Levison's Swift routine discard_peri.f Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: tp Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameterss Contents None","tags":"","loc":"proc/discard_peri_tp.html"},{"title":"discard_pl_tp – swiftest","text":"subroutine discard_pl_tp(tp, system, param) Check to see if test particles should be discarded based on their positions relative to the massive bodies Adapted from David E. Kaufmann's Swifter routine: discard_pl.f90\n Adapted from Hal Levison's Swift routine discard_pl.f Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: tp Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Contents None","tags":"","loc":"proc/discard_pl_tp.html"},{"title":"discard_pl_close – swiftest","text":"subroutine discard_pl_close(dx, dv, dt, r2crit, iflag, r2min) Check to see if a test particle and massive body are having, or will have within the next time step, an encounter such\n          that the separation distance r is less than some critical radius rcrit (or r 2 < rcrit 2 = r2crit) Adapted from David E. Kaufmann's Swifter routine: discard_pl_close.f90\n Adapted from Hal Levison's Swift routine discard_pl_close.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: dx real(kind=DP), intent(in), dimension(:) :: dv real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r2crit integer(kind=I4B), intent(out) :: iflag real(kind=DP), intent(out) :: r2min Contents None","tags":"","loc":"proc/discard_pl_close.html"},{"title":"io_read_encounter – swiftest","text":"function io_read_encounter(t, name1, name2, mass1, mass2, radius1, radius2, xh1, xh2, vh1, vh2, enc_out, out_type) result(ierr) Read close encounter data from input binary files\n     Other than time t, there is no direct file input from this function\n     Function returns read error status (0 = OK, nonzero = ERROR)\n Adapted from David E. Kaufmann's Swifter routine: io_read_encounter.f90 Arguments Type Intent Optional Attributes Name real(kind=DP), intent(out) :: t integer(kind=I4B), intent(out) :: name1 integer(kind=I4B), intent(out) :: name2 real(kind=DP), intent(out) :: mass1 real(kind=DP), intent(out) :: mass2 real(kind=DP), intent(out) :: radius1 real(kind=DP), intent(out) :: radius2 real(kind=DP), intent(out), dimension(:) :: xh1 real(kind=DP), intent(out), dimension(:) :: xh2 real(kind=DP), intent(out), dimension(:) :: vh1 real(kind=DP), intent(out), dimension(:) :: vh2 character(len=*), intent(in) :: enc_out character(len=*), intent(in) :: out_type Return Value integer(kind=I4B) Calls proc~~io_read_encounter~~CallsGraph proc~io_read_encounter io_read_encounter interface~util_exit util_exit proc~io_read_encounter->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_encounter.html"},{"title":"io_read_hdr – swiftest","text":"function io_read_hdr(iu, t, npl, ntp, out_form, out_type) result(ierr) Read frame header from input binary files\n     Function returns read error status (0 = OK, nonzero = ERROR)\n Adapted from David E. Kaufmann's Swifter routine: io_read_hdr.f90\n Adapted from Hal Levison's Swift routine io_read_hdr.f Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu real(kind=DP), intent(out) :: t integer(kind=I4B), intent(out) :: npl integer(kind=I4B), intent(out) :: ntp character(len=*), intent(out) :: out_form character(len=*), intent(in) :: out_type Return Value integer(kind=I4B) Called by proc~~io_read_hdr~~CalledByGraph proc~io_read_hdr io_read_hdr proc~io_read_frame_system io_read_frame_system proc~io_read_frame_system->proc~io_read_hdr interface~io_read_frame_system io_read_frame_system interface~io_read_frame_system->proc~io_read_frame_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_hdr.html"},{"title":"io_write_hdr – swiftest","text":"subroutine io_write_hdr(iu, t, npl, ntp, out_form, out_type) Write frame header to output binary file Adapted from David Adapted from David E. Kaufmann's Swifter routine io_write_hdr.f90\n Adapted from Hal Levison's Swift routine io_write_hdr.F Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu Output file unit number real(kind=DP), intent(in) :: t Current time of simulation integer(kind=I4B), intent(in) :: npl Number of massive bodies integer(kind=I4B), intent(in) :: ntp Number of test particles character(len=*), intent(in) :: out_form Output format type (\"EL\" or  \"XV\") character(len=*), intent(in) :: out_type Output file format type (REAL4, REAL8 - see swiftest module for symbolic name definitions) Calls proc~~io_write_hdr~~CallsGraph proc~io_write_hdr io_write_hdr interface~util_exit util_exit proc~io_write_hdr->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_write_hdr~~CalledByGraph proc~io_write_hdr io_write_hdr proc~io_write_frame_system io_write_frame_system proc~io_write_frame_system->proc~io_write_hdr interface~io_write_frame_system io_write_frame_system interface~io_write_frame_system->proc~io_write_frame_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_write_hdr.html"},{"title":"drift_dan – swiftest","text":"pure subroutine drift_dan(mu, x0, v0, dt0, iflag) Perform Kepler drift, solving Kepler's equation in appropriate variables Adapted from David E. Kaufmann's Swifter routine: drift_dan.f90\n Adapted from Hal Levison and Martin Duncan's Swift routine drift_dan.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu real(kind=DP), intent(inout), dimension(:) :: x0 real(kind=DP), intent(inout), dimension(:) :: v0 real(kind=DP), intent(in) :: dt0 integer(kind=I4B), intent(out) :: iflag Calls proc~~drift_dan~~CallsGraph proc~drift_dan drift_dan proc~drift_kepmd drift_kepmd proc~drift_dan->proc~drift_kepmd proc~drift_kepu drift_kepu proc~drift_dan->proc~drift_kepu proc~drift_kepu_fchk drift_kepu_fchk proc~drift_kepu->proc~drift_kepu_fchk proc~drift_kepu_guess drift_kepu_guess proc~drift_kepu->proc~drift_kepu_guess proc~drift_kepu_new drift_kepu_new proc~drift_kepu->proc~drift_kepu_new proc~drift_kepu_lag drift_kepu_lag proc~drift_kepu->proc~drift_kepu_lag proc~drift_kepu_stumpff drift_kepu_stumpff proc~drift_kepu_fchk->proc~drift_kepu_stumpff proc~drift_kepu_p3solve drift_kepu_p3solve proc~drift_kepu_guess->proc~drift_kepu_p3solve interface~orbel_scget orbel_scget proc~drift_kepu_guess->interface~orbel_scget proc~drift_kepu_new->proc~drift_kepu_stumpff proc~drift_kepu_lag->proc~drift_kepu_stumpff proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_dan.html"},{"title":"drift_kepmd – swiftest","text":"pure subroutine drift_kepmd(dm, es, ec, x, s, c) Solve Kepler's equation in difference form for an ellipse for small input dm and eccentricity\n    Original disclaimer: built for speed, does not check how well the original equation is solved\n    Can do that in calling routine by checking how close (x - ec s + es (1.0 - c) - dm) is to zero Adapted from David E. Kaufmann's Swifter routine: drift_kepmd.f90\n Adapted from Martin Duncan's Swift routine drift_kepmd.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dm real(kind=DP), intent(in) :: es real(kind=DP), intent(in) :: ec real(kind=DP), intent(out) :: x real(kind=DP), intent(out) :: s real(kind=DP), intent(out) :: c Called by proc~~drift_kepmd~~CalledByGraph proc~drift_kepmd drift_kepmd proc~drift_dan drift_dan proc~drift_dan->proc~drift_kepmd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_kepmd.html"},{"title":"drift_kepu – swiftest","text":"pure subroutine drift_kepu(dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Solve Kepler's equation in universal variables Adapted from David E. Kaufmann's Swifter routine: drift_kepu.f90\n Adapted from Hal Levison's Swift routine drift_kepu.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: fp real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 integer(kind=I4B), intent(out) :: iflag Calls proc~~drift_kepu~~CallsGraph proc~drift_kepu drift_kepu proc~drift_kepu_fchk drift_kepu_fchk proc~drift_kepu->proc~drift_kepu_fchk proc~drift_kepu_guess drift_kepu_guess proc~drift_kepu->proc~drift_kepu_guess proc~drift_kepu_new drift_kepu_new proc~drift_kepu->proc~drift_kepu_new proc~drift_kepu_lag drift_kepu_lag proc~drift_kepu->proc~drift_kepu_lag proc~drift_kepu_stumpff drift_kepu_stumpff proc~drift_kepu_fchk->proc~drift_kepu_stumpff proc~drift_kepu_p3solve drift_kepu_p3solve proc~drift_kepu_guess->proc~drift_kepu_p3solve interface~orbel_scget orbel_scget proc~drift_kepu_guess->interface~orbel_scget proc~drift_kepu_new->proc~drift_kepu_stumpff proc~drift_kepu_lag->proc~drift_kepu_stumpff proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~drift_kepu~~CalledByGraph proc~drift_kepu drift_kepu proc~drift_dan drift_dan proc~drift_dan->proc~drift_kepu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_kepu.html"},{"title":"drift_kepu_fchk – swiftest","text":"pure subroutine drift_kepu_fchk(dt, r0, mu, alpha, u, s, f) Computes the value of f, the function whose root we are trying to find in universal variables Adapted from David E. Kaufmann's Swifter routine: drift_kepu_fchk.f90\n Adapted from Martin Duncan's Swift routine drift_kepu_fchk.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(in) :: s real(kind=DP), intent(out) :: f Calls proc~~drift_kepu_fchk~~CallsGraph proc~drift_kepu_fchk drift_kepu_fchk proc~drift_kepu_stumpff drift_kepu_stumpff proc~drift_kepu_fchk->proc~drift_kepu_stumpff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~drift_kepu_fchk~~CalledByGraph proc~drift_kepu_fchk drift_kepu_fchk proc~drift_kepu drift_kepu proc~drift_kepu->proc~drift_kepu_fchk proc~drift_dan drift_dan proc~drift_dan->proc~drift_kepu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_kepu_fchk.html"},{"title":"drift_kepu_guess – swiftest","text":"pure subroutine drift_kepu_guess(dt, r0, mu, alpha, u, s) Compute initial guess for solving Kepler's equation using universal variables Adapted from David E. Kaufmann's Swifter routine: drift_kepu_guess.f90\n Adapted from Hal Levison and Martin Duncan's Swift routine drift_kepu_guess.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: s Calls proc~~drift_kepu_guess~~CallsGraph proc~drift_kepu_guess drift_kepu_guess proc~drift_kepu_p3solve drift_kepu_p3solve proc~drift_kepu_guess->proc~drift_kepu_p3solve interface~orbel_scget orbel_scget proc~drift_kepu_guess->interface~orbel_scget proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~drift_kepu_guess~~CalledByGraph proc~drift_kepu_guess drift_kepu_guess proc~drift_kepu drift_kepu proc~drift_kepu->proc~drift_kepu_guess proc~drift_dan drift_dan proc~drift_dan->proc~drift_kepu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_kepu_guess.html"},{"title":"drift_kepu_lag – swiftest","text":"pure subroutine drift_kepu_lag(s, dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Solve Kepler's equation in universal variables using Laguerre's method\n      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 178 - 180. Adapted from David E. Kaufmann's Swifter routine: drift_kepu_lag.f90\n Adapted from Hal Levison's Swift routine drift_kepu_lag.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout) :: s real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: fp real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 integer(kind=I4B), intent(out) :: iflag Calls proc~~drift_kepu_lag~~CallsGraph proc~drift_kepu_lag drift_kepu_lag proc~drift_kepu_stumpff drift_kepu_stumpff proc~drift_kepu_lag->proc~drift_kepu_stumpff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~drift_kepu_lag~~CalledByGraph proc~drift_kepu_lag drift_kepu_lag proc~drift_kepu drift_kepu proc~drift_kepu->proc~drift_kepu_lag proc~drift_dan drift_dan proc~drift_dan->proc~drift_kepu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_kepu_lag.html"},{"title":"drift_kepu_new – swiftest","text":"pure subroutine drift_kepu_new(s, dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Solve Kepler's equation in universal variables using Newton's method\n      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 174 - 175. Adapted from David E. Kaufmann's Swifter routine: drift_kepu_new.f90\n Adapted from Hal Levison's Swift routine drift_kepu_new.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout) :: s real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: fp real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 integer(kind=I4B), intent(out) :: iflag Calls proc~~drift_kepu_new~~CallsGraph proc~drift_kepu_new drift_kepu_new proc~drift_kepu_stumpff drift_kepu_stumpff proc~drift_kepu_new->proc~drift_kepu_stumpff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~drift_kepu_new~~CalledByGraph proc~drift_kepu_new drift_kepu_new proc~drift_kepu drift_kepu proc~drift_kepu->proc~drift_kepu_new proc~drift_dan drift_dan proc~drift_dan->proc~drift_kepu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_kepu_new.html"},{"title":"drift_kepu_p3solve – swiftest","text":"pure subroutine drift_kepu_p3solve(dt, r0, mu, alpha, u, s, iflag) Computes real root of cubic involved in setting initial guess for solving Kepler's equation in universal variables\n      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 177 - 178. Adapted from David E. Kaufmann's Swifter routine: drift_kepu_p3solve.f90\n Adapted from Martin Duncan's Swift routine drift_kepu_p3solve.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: s integer(kind=I4B), intent(out) :: iflag Called by proc~~drift_kepu_p3solve~~CalledByGraph proc~drift_kepu_p3solve drift_kepu_p3solve proc~drift_kepu_guess drift_kepu_guess proc~drift_kepu_guess->proc~drift_kepu_p3solve proc~drift_kepu drift_kepu proc~drift_kepu->proc~drift_kepu_guess proc~drift_dan drift_dan proc~drift_dan->proc~drift_kepu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_kepu_p3solve.html"},{"title":"drift_kepu_stumpff – swiftest","text":"pure subroutine drift_kepu_stumpff(x, c0, c1, c2, c3) Compute Stumpff functions needed for Kepler drift in universal variables\n      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 171 - 172. Adapted from David E. Kaufmann's Swifter routine: drift_kepu_stumpff.f90\n Adapted from Hal Levison's Swift routine drift_kepu_stumpff.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout) :: x real(kind=DP), intent(out) :: c0 real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 Called by proc~~drift_kepu_stumpff~~CalledByGraph proc~drift_kepu_stumpff drift_kepu_stumpff proc~drift_kepu_fchk drift_kepu_fchk proc~drift_kepu_fchk->proc~drift_kepu_stumpff proc~drift_kepu_new drift_kepu_new proc~drift_kepu_new->proc~drift_kepu_stumpff proc~drift_kepu_lag drift_kepu_lag proc~drift_kepu_lag->proc~drift_kepu_stumpff proc~drift_kepu drift_kepu proc~drift_kepu->proc~drift_kepu_fchk proc~drift_kepu->proc~drift_kepu_new proc~drift_kepu->proc~drift_kepu_lag proc~drift_dan drift_dan proc~drift_dan->proc~drift_kepu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_kepu_stumpff.html"},{"title":"symba_collision_check_one – swiftest","text":"pure elemental function symba_collision_check_one(xr, yr, zr, vxr, vyr, vzr, Gmtot, rlim, dt, lvdotr) result(lcollision) Check for a merger between a single pair of particles Adapted from David E. Kaufmann's Swifter routines symba_merge_tp.f90 and symba_merge_pl.f90 Adapted from Hal Levison's Swift routine symba5_merge.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: xr Relative position vector components real(kind=DP), intent(in) :: yr Relative position vector components real(kind=DP), intent(in) :: zr Relative position vector components real(kind=DP), intent(in) :: vxr Relative velocity vector components real(kind=DP), intent(in) :: vyr Relative velocity vector components real(kind=DP), intent(in) :: vzr Relative velocity vector components real(kind=DP), intent(in) :: Gmtot Sum of G*mass of colliding bodies real(kind=DP), intent(in) :: rlim Collision limit - Typically the sum of the radii of colliding bodies real(kind=DP), intent(in) :: dt Step size logical, intent(in) :: lvdotr Logical flag indicating that these two bodies are approaching in the current substep Return Value logical Logical flag indicating whether these two bodies will collide or not Calls proc~~symba_collision_check_one~~CallsGraph proc~symba_collision_check_one symba_collision_check_one orbel_xv2aeq orbel_xv2aeq proc~symba_collision_check_one->orbel_xv2aeq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_collision_check_one~~CalledByGraph proc~symba_collision_check_one symba_collision_check_one proc~symba_collision_check_pltpenc symba_collision_check_pltpenc proc~symba_collision_check_pltpenc->proc~symba_collision_check_one interface~symba_collision_check_pltpenc symba_collision_check_pltpenc interface~symba_collision_check_pltpenc->proc~symba_collision_check_pltpenc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_collision_check_one.html"},{"title":"symba_collision_consolidate_familes – swiftest","text":"function symba_collision_consolidate_familes(pl, param, idx_parent, family, x, v, mass, radius, L_spin, Ip) result(lflag) Loops through the pl-pl collision list and groups families together by index. Outputs the indices of all family members, \n and pairs of quantities (x and v vectors, mass, radius, L_spin, and Ip) that can be used to resolve the collisional outcome. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl SyMBA massive body object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(inout), dimension(2) :: idx_parent Index of the two bodies considered the \"parents\" of the collision integer(kind=I4B), intent(out), dimension(:), allocatable :: family List of indices of all bodies inovlved in the collision real(kind=DP), intent(out), dimension(NDIM,2) :: x Output values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(out), dimension(NDIM,2) :: v Output values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(out), dimension(2) :: mass Output values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(out), dimension(2) :: radius Output values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(out), dimension(NDIM,2) :: L_spin Output values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(out), dimension(NDIM,2) :: Ip Output values that represent a 2-body equivalent of a possibly 2+ body collision Return Value logical Logical flag indicating whether a family was successfully created or not Calls proc~~symba_collision_consolidate_familes~~CallsGraph proc~symba_collision_consolidate_familes symba_collision_consolidate_familes id_arr id_arr proc~symba_collision_consolidate_familes->id_arr idx_arr idx_arr proc~symba_collision_consolidate_familes->idx_arr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_collision_consolidate_familes~~CalledByGraph proc~symba_collision_consolidate_familes symba_collision_consolidate_familes proc~symba_collision_resolve_mergers symba_collision_resolve_mergers proc~symba_collision_resolve_mergers->proc~symba_collision_consolidate_familes proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations proc~symba_collision_resolve_fragmentations->proc~symba_collision_consolidate_familes interface~symba_collision_resolve_mergers symba_collision_resolve_mergers interface~symba_collision_resolve_mergers->proc~symba_collision_resolve_mergers interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_collision_consolidate_familes.html"},{"title":"symba_fragmentation_mergeaddsub – swiftest","text":"subroutine symba_fragmentation_mergeaddsub(system, param, family, id_frag, Ip_frag, m_frag, rad_frag, xb_frag, vb_frag, rot_frag, status) Fills the pl_discards and pl_adds with removed and added bodies Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(in), dimension(:) :: family List of indices of all bodies inovlved in the collision integer(kind=I4B), intent(in), dimension(:) :: id_frag List of fragment ids real(kind=DP), intent(in), dimension(:,:) :: Ip_frag Fragment rotational inertia vectors real(kind=DP), intent(in), dimension(:) :: m_frag Distribution of fragment mass and radii real(kind=DP), intent(in), dimension(:) :: rad_frag Distribution of fragment mass and radii real(kind=DP), intent(in), dimension(:,:) :: xb_frag Fragment barycentric position, barycentric velocity, and rotation vectors real(kind=DP), intent(in), dimension(:,:) :: vb_frag Fragment barycentric position, barycentric velocity, and rotation vectors real(kind=DP), intent(in), dimension(:,:) :: rot_frag Fragment barycentric position, barycentric velocity, and rotation vectors integer(kind=I4B), intent(in) :: status Status flag to assign to adds Called by proc~~symba_fragmentation_mergeaddsub~~CalledByGraph proc~symba_fragmentation_mergeaddsub symba_fragmentation_mergeaddsub proc~symba_fragmentation_casedisruption symba_fragmentation_casedisruption proc~symba_fragmentation_casedisruption->proc~symba_fragmentation_mergeaddsub proc~symba_fragmentation_casehitandrun symba_fragmentation_casehitandrun proc~symba_fragmentation_casehitandrun->proc~symba_fragmentation_mergeaddsub proc~symba_fragmentation_casesupercatastrophic symba_fragmentation_casesupercatastrophic proc~symba_fragmentation_casesupercatastrophic->proc~symba_fragmentation_mergeaddsub proc~symba_fragmentation_casemerge symba_fragmentation_casemerge proc~symba_fragmentation_casemerge->proc~symba_fragmentation_mergeaddsub interface~symba_fragmentation_casedisruption symba_fragmentation_casedisruption interface~symba_fragmentation_casedisruption->proc~symba_fragmentation_casedisruption interface~symba_fragmentation_casehitandrun symba_fragmentation_casehitandrun interface~symba_fragmentation_casehitandrun->proc~symba_fragmentation_casehitandrun interface~symba_fragmentation_casemerge symba_fragmentation_casemerge interface~symba_fragmentation_casemerge->proc~symba_fragmentation_casemerge interface~symba_fragmentation_casesupercatastrophic symba_fragmentation_casesupercatastrophic interface~symba_fragmentation_casesupercatastrophic->proc~symba_fragmentation_casesupercatastrophic proc~symba_collision_resolve_mergers symba_collision_resolve_mergers proc~symba_collision_resolve_mergers->interface~symba_fragmentation_casemerge proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations proc~symba_collision_resolve_fragmentations->interface~symba_fragmentation_casedisruption proc~symba_collision_resolve_fragmentations->interface~symba_fragmentation_casehitandrun proc~symba_collision_resolve_fragmentations->interface~symba_fragmentation_casemerge proc~symba_collision_resolve_fragmentations->interface~symba_fragmentation_casesupercatastrophic interface~symba_collision_resolve_mergers symba_collision_resolve_mergers interface~symba_collision_resolve_mergers->proc~symba_collision_resolve_mergers interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_fragmentation_mergeaddsub.html"},{"title":"symba_discard_cb_pl – swiftest","text":"subroutine symba_discard_cb_pl(pl, system, param) Check to see if planets should be discarded based on their positions relative to the central body.\n If a body gets flagged here when it has also been previously flagged for a collision with another massive body,\n its collisional status will be revoked. Discards due to colliding with or escaping the central body take precedence \n over pl-pl collisions Adapted from David E. Kaufmann's Swifter routine: symba_discard_sun.f90\n Adapted from Hal Levison's Swift routine discard_massive5.f Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl SyMBA massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Called by proc~~symba_discard_cb_pl~~CalledByGraph proc~symba_discard_cb_pl symba_discard_cb_pl proc~symba_discard_nonplpl symba_discard_nonplpl proc~symba_discard_nonplpl->proc~symba_discard_cb_pl proc~symba_discard_pl symba_discard_pl proc~symba_discard_pl->proc~symba_discard_nonplpl interface~symba_discard_pl symba_discard_pl interface~symba_discard_pl->proc~symba_discard_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_discard_cb_pl.html"},{"title":"symba_discard_conserve_mtm – swiftest","text":"subroutine symba_discard_conserve_mtm(pl, system, param, ipl, lescape_body) Conserves system momentum when a body is lost from the system or collides with central body Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl class( symba_nbody_system ), intent(inout) :: system class( symba_parameters ), intent(inout) :: param integer(kind=I4B), intent(in) :: ipl logical, intent(in) :: lescape_body Contents None","tags":"","loc":"proc/symba_discard_conserve_mtm.html"},{"title":"symba_discard_nonplpl – swiftest","text":"subroutine symba_discard_nonplpl(pl, system, param) Check to see if planets should be discarded based on their positions or because they are unbound Adapted from David E. Kaufmann's Swifter routine: symba_discard_pl.f90\n Adapted from Hal Levison's Swift routine discard_massive5.f Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl SyMBA test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~symba_discard_nonplpl~~CallsGraph proc~symba_discard_nonplpl symba_discard_nonplpl proc~symba_discard_cb_pl symba_discard_cb_pl proc~symba_discard_nonplpl->proc~symba_discard_cb_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_discard_nonplpl~~CalledByGraph proc~symba_discard_nonplpl symba_discard_nonplpl proc~symba_discard_pl symba_discard_pl proc~symba_discard_pl->proc~symba_discard_nonplpl interface~symba_discard_pl symba_discard_pl interface~symba_discard_pl->proc~symba_discard_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_discard_nonplpl.html"},{"title":"symba_discard_nonplpl_conservation – swiftest","text":"subroutine symba_discard_nonplpl_conservation(pl, system, param) If there are any bodies that are removed due to either colliding with the central body or escaping the systme,\n we need to track the conserved quantities with the system bookkeeping terms. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters Called by proc~~symba_discard_nonplpl_conservation~~CalledByGraph proc~symba_discard_nonplpl_conservation symba_discard_nonplpl_conservation proc~symba_discard_pl symba_discard_pl proc~symba_discard_pl->proc~symba_discard_nonplpl_conservation interface~symba_discard_pl symba_discard_pl interface~symba_discard_pl->proc~symba_discard_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_discard_nonplpl_conservation.html"},{"title":"symba_discard_peri_pl – swiftest","text":"subroutine symba_discard_peri_pl(pl, system, param) Check to see if a test particle should be discarded because its perihelion distance becomes too small Adapted from David E. Kaufmann's Swifter routine: symba_discard_peri_pl.f90\n Adapted from Hal Levison's Swift routine discard_mass_peri.f Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl SyMBA massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Contents None","tags":"","loc":"proc/symba_discard_peri_pl.html"},{"title":"rmvs_chk_ind – swiftest","text":"interface Calls interface~~rmvs_chk_ind~~CallsGraph interface~rmvs_chk_ind rmvs_chk_ind proc~rmvs_chk_ind rmvs_chk_ind interface~rmvs_chk_ind->proc~rmvs_chk_ind Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~rmvs_chk_ind~~CalledByGraph interface~rmvs_chk_ind rmvs_chk_ind proc~symba_encounter_check_one symba_encounter_check_one proc~symba_encounter_check_one->interface~rmvs_chk_ind proc~rmvs_encounter_check_tp rmvs_encounter_check_tp proc~rmvs_encounter_check_tp->interface~rmvs_chk_ind interface~symba_encounter_check_one symba_encounter_check_one interface~symba_encounter_check_one->proc~symba_encounter_check_one interface~rmvs_encounter_check_tp rmvs_encounter_check_tp interface~rmvs_encounter_check_tp->proc~rmvs_encounter_check_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public elemental module function rmvs_chk_ind(r2, v2, vdotr, dt, r2crit) result(lflag) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: r2 real(kind=DP), intent(in) :: v2 real(kind=DP), intent(in) :: vdotr real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r2crit Return Value logical","tags":"","loc":"interface/rmvs_chk_ind.html"},{"title":"rmvs_encounter_check_tp – swiftest","text":"interface Calls interface~~rmvs_encounter_check_tp~~CallsGraph interface~rmvs_encounter_check_tp rmvs_encounter_check_tp proc~rmvs_encounter_check_tp rmvs_encounter_check_tp interface~rmvs_encounter_check_tp->proc~rmvs_encounter_check_tp interface~rmvs_chk_ind rmvs_chk_ind proc~rmvs_encounter_check_tp->interface~rmvs_chk_ind proc~rmvs_chk_ind rmvs_chk_ind interface~rmvs_chk_ind->proc~rmvs_chk_ind Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function rmvs_encounter_check_tp(self, system, dt) result(lencounter) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class( rmvs_nbody_system ), intent(inout) :: system RMVS nbody system object real(kind=DP), intent(in) :: dt step size Return Value logical Returns true if there is at least one close encounter","tags":"","loc":"interface/rmvs_encounter_check_tp.html"},{"title":"rmvs_discard_tp – swiftest","text":"interface Calls interface~~rmvs_discard_tp~~CallsGraph interface~rmvs_discard_tp rmvs_discard_tp proc~rmvs_discard_tp rmvs_discard_tp interface~rmvs_discard_tp->proc~rmvs_discard_tp discard_tp discard_tp proc~rmvs_discard_tp->discard_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_discard_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/rmvs_discard_tp.html"},{"title":"rmvs_kick_getacch_tp – swiftest","text":"interface Calls interface~~rmvs_kick_getacch_tp~~CallsGraph interface~rmvs_kick_getacch_tp rmvs_kick_getacch_tp proc~rmvs_kick_getacch_tp rmvs_kick_getacch_tp interface~rmvs_kick_getacch_tp->proc~rmvs_kick_getacch_tp whm_kick_getacch_tp whm_kick_getacch_tp proc~rmvs_kick_getacch_tp->whm_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest central body particle data structuree class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step","tags":"","loc":"interface/rmvs_kick_getacch_tp.html"},{"title":"rmvs_setup_pl – swiftest","text":"interface Calls interface~~rmvs_setup_pl~~CallsGraph interface~rmvs_setup_pl rmvs_setup_pl proc~rmvs_setup_pl rmvs_setup_pl interface~rmvs_setup_pl->proc~rmvs_setup_pl whm_setup_pl whm_setup_pl proc~rmvs_setup_pl->whm_setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/rmvs_setup_pl.html"},{"title":"rmvs_setup_initialize_system – swiftest","text":"interface Calls interface~~rmvs_setup_initialize_system~~CallsGraph interface~rmvs_setup_initialize_system rmvs_setup_initialize_system proc~rmvs_setup_initialize_system rmvs_setup_initialize_system interface~rmvs_setup_initialize_system->proc~rmvs_setup_initialize_system whm_setup_initialize_system whm_setup_initialize_system proc~rmvs_setup_initialize_system->whm_setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_nbody_system ), intent(inout) :: self RMVS system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/rmvs_setup_initialize_system.html"},{"title":"rmvs_setup_tp – swiftest","text":"interface Calls interface~~rmvs_setup_tp~~CallsGraph interface~rmvs_setup_tp rmvs_setup_tp proc~rmvs_setup_tp rmvs_setup_tp interface~rmvs_setup_tp->proc~rmvs_setup_tp setup_tp setup_tp proc~rmvs_setup_tp->setup_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parametere","tags":"","loc":"interface/rmvs_setup_tp.html"},{"title":"rmvs_util_append_pl – swiftest","text":"interface Calls interface~~rmvs_util_append_pl~~CallsGraph interface~rmvs_util_append_pl rmvs_util_append_pl proc~rmvs_util_append_pl rmvs_util_append_pl interface~rmvs_util_append_pl->proc~rmvs_util_append_pl util_append util_append proc~rmvs_util_append_pl->util_append whm_util_append_pl whm_util_append_pl proc~rmvs_util_append_pl->whm_util_append_pl util_exit util_exit proc~rmvs_util_append_pl->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/rmvs_util_append_pl.html"},{"title":"rmvs_util_append_tp – swiftest","text":"interface Calls interface~~rmvs_util_append_tp~~CallsGraph interface~rmvs_util_append_tp rmvs_util_append_tp proc~rmvs_util_append_tp rmvs_util_append_tp interface~rmvs_util_append_tp->proc~rmvs_util_append_tp util_append util_append proc~rmvs_util_append_tp->util_append util_append_tp util_append_tp proc~rmvs_util_append_tp->util_append_tp util_exit util_exit proc~rmvs_util_append_tp->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/rmvs_util_append_tp.html"},{"title":"rmvs_util_fill_pl – swiftest","text":"interface Calls interface~~rmvs_util_fill_pl~~CallsGraph interface~rmvs_util_fill_pl rmvs_util_fill_pl proc~rmvs_util_fill_pl rmvs_util_fill_pl interface~rmvs_util_fill_pl->proc~rmvs_util_fill_pl util_fill util_fill proc~rmvs_util_fill_pl->util_fill util_exit util_exit proc~rmvs_util_fill_pl->util_exit whm_util_fill_pl whm_util_fill_pl proc~rmvs_util_fill_pl->whm_util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"interface/rmvs_util_fill_pl.html"},{"title":"rmvs_util_fill_tp – swiftest","text":"interface Calls interface~~rmvs_util_fill_tp~~CallsGraph interface~rmvs_util_fill_tp rmvs_util_fill_tp proc~rmvs_util_fill_tp rmvs_util_fill_tp interface~rmvs_util_fill_tp->proc~rmvs_util_fill_tp util_fill_tp util_fill_tp proc~rmvs_util_fill_tp->util_fill_tp util_fill util_fill proc~rmvs_util_fill_tp->util_fill util_exit util_exit proc~rmvs_util_fill_tp->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"interface/rmvs_util_fill_tp.html"},{"title":"rmvs_util_resize_pl – swiftest","text":"interface Calls interface~~rmvs_util_resize_pl~~CallsGraph interface~rmvs_util_resize_pl rmvs_util_resize_pl proc~rmvs_util_resize_pl rmvs_util_resize_pl interface~rmvs_util_resize_pl->proc~rmvs_util_resize_pl util_resize util_resize proc~rmvs_util_resize_pl->util_resize whm_util_resize_pl whm_util_resize_pl proc~rmvs_util_resize_pl->whm_util_resize_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in) :: nnew New size neded","tags":"","loc":"interface/rmvs_util_resize_pl.html"},{"title":"rmvs_util_resize_tp – swiftest","text":"interface Calls interface~~rmvs_util_resize_tp~~CallsGraph interface~rmvs_util_resize_tp rmvs_util_resize_tp proc~rmvs_util_resize_tp rmvs_util_resize_tp interface~rmvs_util_resize_tp->proc~rmvs_util_resize_tp util_resize util_resize proc~rmvs_util_resize_tp->util_resize util_resize_tp util_resize_tp proc~rmvs_util_resize_tp->util_resize_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: nnew New size neded","tags":"","loc":"interface/rmvs_util_resize_tp.html"},{"title":"rmvs_util_sort_pl – swiftest","text":"interface Calls interface~~rmvs_util_sort_pl~~CallsGraph interface~rmvs_util_sort_pl rmvs_util_sort_pl proc~rmvs_util_sort_pl rmvs_util_sort_pl interface~rmvs_util_sort_pl->proc~rmvs_util_sort_pl whm_util_sort_pl whm_util_sort_pl proc~rmvs_util_sort_pl->whm_util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order","tags":"","loc":"interface/rmvs_util_sort_pl.html"},{"title":"rmvs_util_sort_tp – swiftest","text":"interface Calls interface~~rmvs_util_sort_tp~~CallsGraph interface~rmvs_util_sort_tp rmvs_util_sort_tp proc~rmvs_util_sort_tp rmvs_util_sort_tp interface~rmvs_util_sort_tp->proc~rmvs_util_sort_tp util_sort_tp util_sort_tp proc~rmvs_util_sort_tp->util_sort_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order","tags":"","loc":"interface/rmvs_util_sort_tp.html"},{"title":"rmvs_util_sort_rearrange_pl – swiftest","text":"interface Calls interface~~rmvs_util_sort_rearrange_pl~~CallsGraph interface~rmvs_util_sort_rearrange_pl rmvs_util_sort_rearrange_pl proc~rmvs_util_sort_rearrange_pl rmvs_util_sort_rearrange_pl interface~rmvs_util_sort_rearrange_pl->proc~rmvs_util_sort_rearrange_pl util_sort_rearrange_pl util_sort_rearrange_pl proc~rmvs_util_sort_rearrange_pl->util_sort_rearrange_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order)","tags":"","loc":"interface/rmvs_util_sort_rearrange_pl.html"},{"title":"rmvs_util_sort_rearrange_tp – swiftest","text":"interface Calls interface~~rmvs_util_sort_rearrange_tp~~CallsGraph interface~rmvs_util_sort_rearrange_tp rmvs_util_sort_rearrange_tp proc~rmvs_util_sort_rearrange_tp rmvs_util_sort_rearrange_tp interface~rmvs_util_sort_rearrange_tp->proc~rmvs_util_sort_rearrange_tp util_sort_rearrange_tp util_sort_rearrange_tp proc~rmvs_util_sort_rearrange_tp->util_sort_rearrange_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order)","tags":"","loc":"interface/rmvs_util_sort_rearrange_tp.html"},{"title":"rmvs_util_spill_pl – swiftest","text":"interface Calls interface~~rmvs_util_spill_pl~~CallsGraph interface~rmvs_util_spill_pl rmvs_util_spill_pl proc~rmvs_util_spill_pl rmvs_util_spill_pl interface~rmvs_util_spill_pl->proc~rmvs_util_spill_pl util_spill util_spill proc~rmvs_util_spill_pl->util_spill util_exit util_exit proc~rmvs_util_spill_pl->util_exit whm_util_spill_pl whm_util_spill_pl proc~rmvs_util_spill_pl->whm_util_spill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"interface/rmvs_util_spill_pl.html"},{"title":"rmvs_util_spill_tp – swiftest","text":"interface Calls interface~~rmvs_util_spill_tp~~CallsGraph interface~rmvs_util_spill_tp rmvs_util_spill_tp proc~rmvs_util_spill_tp rmvs_util_spill_tp interface~rmvs_util_spill_tp->proc~rmvs_util_spill_tp util_spill_tp util_spill_tp proc~rmvs_util_spill_tp->util_spill_tp util_spill util_spill proc~rmvs_util_spill_tp->util_spill util_exit util_exit proc~rmvs_util_spill_tp->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"interface/rmvs_util_spill_tp.html"},{"title":"rmvs_step_system – swiftest","text":"interface Calls interface~~rmvs_step_system~~CallsGraph interface~rmvs_step_system rmvs_step_system proc~rmvs_step_system rmvs_step_system interface~rmvs_step_system->proc~rmvs_step_system whm_step_system whm_step_system proc~rmvs_step_system->whm_step_system proc~rmvs_step_out rmvs_step_out proc~rmvs_step_system->proc~rmvs_step_out proc~rmvs_interp_out rmvs_interp_out proc~rmvs_step_system->proc~rmvs_interp_out proc~rmvs_interp_in rmvs_interp_in proc~rmvs_step_out->proc~rmvs_interp_in proc~rmvs_step_in rmvs_step_in proc~rmvs_step_out->proc~rmvs_step_in util_exit util_exit proc~rmvs_interp_out->util_exit proc~rmvs_interp_in->util_exit proc~rmvs_end_planetocentric rmvs_end_planetocentric proc~rmvs_step_in->proc~rmvs_end_planetocentric proc~rmvs_make_planetocentric rmvs_make_planetocentric proc~rmvs_step_in->proc~rmvs_make_planetocentric proc~rmvs_peri_tp rmvs_peri_tp proc~rmvs_step_in->proc~rmvs_peri_tp xpc xpc proc~rmvs_peri_tp->xpc vpc vpc proc~rmvs_peri_tp->vpc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_nbody_system ), intent(inout) :: self RMVS nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"interface/rmvs_step_system.html"},{"title":"operator(.cross.) – swiftest","text":"public interface operator(.cross.) Contents Functions operator_cross_sp operator_cross_dp operator_cross_qp operator_cross_i1b operator_cross_i2b operator_cross_i4b operator_cross_i8b operator_cross_el_sp operator_cross_el_dp operator_cross_el_qp operator_cross_el_i1b operator_cross_el_i2b operator_cross_el_i4b operator_cross_el_i8b Functions public pure function operator_cross_sp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: A real(kind=SP), intent(in), dimension(:) :: B Return Value real(kind=SP),\n  dimension(3) public pure function operator_cross_dp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: A real(kind=DP), intent(in), dimension(:) :: B Return Value real(kind=DP),\n  dimension(3) public pure function operator_cross_qp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:) :: A real(kind=QP), intent(in), dimension(:) :: B Return Value real(kind=QP),\n  dimension(3) public pure function operator_cross_i1b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in), dimension(:) :: A integer(kind=I1B), intent(in), dimension(:) :: B Return Value integer(kind=I1B),\n  dimension(3) public pure function operator_cross_i2b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in), dimension(:) :: A integer(kind=I2B), intent(in), dimension(:) :: B Return Value integer(kind=I2B),\n  dimension(3) public pure function operator_cross_i4b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:) :: A integer(kind=I4B), intent(in), dimension(:) :: B Return Value integer(kind=I4B),\n  dimension(3) public pure function operator_cross_i8b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in), dimension(:) :: A integer(kind=I8B), intent(in), dimension(:) :: B Return Value integer(kind=I8B),\n  dimension(3) public pure function operator_cross_el_sp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:,:) :: A real(kind=SP), intent(in), dimension(:,:) :: B Return Value real(kind=SP),\n  dimension(:,:), allocatable public pure function operator_cross_el_dp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A real(kind=DP), intent(in), dimension(:,:) :: B Return Value real(kind=DP),\n  dimension(:,:), allocatable public pure function operator_cross_el_qp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A real(kind=QP), intent(in), dimension(:,:) :: B Return Value real(kind=QP),\n  dimension(:,:), allocatable public pure function operator_cross_el_i1b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in), dimension(:,:) :: A integer(kind=I1B), intent(in), dimension(:,:) :: B Return Value integer(kind=I1B),\n  dimension(:,:), allocatable public pure function operator_cross_el_i2b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in), dimension(:,:) :: A integer(kind=I2B), intent(in), dimension(:,:) :: B Return Value integer(kind=I2B),\n  dimension(:,:), allocatable public pure function operator_cross_el_i4b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:,:) :: A integer(kind=I4B), intent(in), dimension(:,:) :: B Return Value integer(kind=I4B),\n  dimension(:,:), allocatable public pure function operator_cross_el_i8b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in), dimension(:,:) :: A integer(kind=I8B), intent(in), dimension(:,:) :: B Return Value integer(kind=I8B),\n  dimension(:,:), allocatable","tags":"","loc":"interface/operator(.cross.).html"},{"title":"operator(.mag.) – swiftest","text":"public interface operator(.mag.) Contents Functions operator_mag_sp operator_mag_dp operator_mag_qp operator_mag_el_sp operator_mag_el_dp operator_mag_el_qp Functions public pure function operator_mag_sp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: A Return Value real(kind=SP) public pure function operator_mag_dp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: A Return Value real(kind=DP) public pure function operator_mag_qp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:) :: A Return Value real(kind=QP) public pure function operator_mag_el_sp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:,:) :: A Return Value real(kind=SP),\n  dimension(:), allocatable public pure function operator_mag_el_dp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A Return Value real(kind=DP),\n  dimension(:), allocatable public pure function operator_mag_el_qp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A Return Value real(kind=QP),\n  dimension(:), allocatable","tags":"","loc":"interface/operator(.mag.).html"},{"title":"helio_coord_vb2vh_pl – swiftest","text":"interface Calls interface~~helio_coord_vb2vh_pl~~CallsGraph interface~helio_coord_vb2vh_pl helio_coord_vb2vh_pl proc~helio_coord_vb2vh_pl helio_coord_vb2vh_pl interface~helio_coord_vb2vh_pl->proc~helio_coord_vb2vh_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_coord_vb2vh_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/helio_coord_vb2vh_pl.html"},{"title":"helio_coord_vb2vh_tp – swiftest","text":"interface Calls interface~~helio_coord_vb2vh_tp~~CallsGraph interface~helio_coord_vb2vh_tp helio_coord_vb2vh_tp proc~helio_coord_vb2vh_tp helio_coord_vb2vh_tp interface~helio_coord_vb2vh_tp->proc~helio_coord_vb2vh_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_coord_vb2vh_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body","tags":"","loc":"interface/helio_coord_vb2vh_tp.html"},{"title":"helio_coord_vh2vb_pl – swiftest","text":"interface Calls interface~~helio_coord_vh2vb_pl~~CallsGraph interface~helio_coord_vh2vb_pl helio_coord_vh2vb_pl proc~helio_coord_vh2vb_pl helio_coord_vh2vb_pl interface~helio_coord_vh2vb_pl->proc~helio_coord_vh2vb_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_coord_vh2vb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/helio_coord_vh2vb_pl.html"},{"title":"helio_coord_vh2vb_tp – swiftest","text":"interface Calls interface~~helio_coord_vh2vb_tp~~CallsGraph interface~helio_coord_vh2vb_tp helio_coord_vh2vb_tp proc~helio_coord_vh2vb_tp helio_coord_vh2vb_tp interface~helio_coord_vh2vb_tp->proc~helio_coord_vh2vb_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_coord_vh2vb_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body","tags":"","loc":"interface/helio_coord_vh2vb_tp.html"},{"title":"helio_drift_body – swiftest","text":"interface Calls interface~~helio_drift_body~~CallsGraph interface~helio_drift_body helio_drift_body proc~helio_drift_body helio_drift_body interface~helio_drift_body->proc~helio_drift_body drift_all drift_all proc~helio_drift_body->drift_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~helio_drift_body~~CalledByGraph interface~helio_drift_body helio_drift_body proc~helio_drift_tp helio_drift_tp proc~helio_drift_tp->interface~helio_drift_body proc~helio_drift_pl helio_drift_pl proc~helio_drift_pl->interface~helio_drift_body interface~helio_drift_tp helio_drift_tp interface~helio_drift_tp->proc~helio_drift_tp interface~helio_drift_pl helio_drift_pl interface~helio_drift_pl->proc~helio_drift_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_drift_body(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class(swiftest_body), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"interface/helio_drift_body.html"},{"title":"helio_drift_pl – swiftest","text":"interface Calls interface~~helio_drift_pl~~CallsGraph interface~helio_drift_pl helio_drift_pl proc~helio_drift_pl helio_drift_pl interface~helio_drift_pl->proc~helio_drift_pl interface~helio_drift_body helio_drift_body proc~helio_drift_pl->interface~helio_drift_body proc~helio_drift_body helio_drift_body interface~helio_drift_body->proc~helio_drift_body drift_all drift_all proc~helio_drift_body->drift_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"interface/helio_drift_pl.html"},{"title":"helio_drift_tp – swiftest","text":"interface Calls interface~~helio_drift_tp~~CallsGraph interface~helio_drift_tp helio_drift_tp proc~helio_drift_tp helio_drift_tp interface~helio_drift_tp->proc~helio_drift_tp interface~helio_drift_body helio_drift_body proc~helio_drift_tp->interface~helio_drift_body proc~helio_drift_body helio_drift_body interface~helio_drift_body->proc~helio_drift_body drift_all drift_all proc~helio_drift_body->drift_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_drift_tp(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"interface/helio_drift_tp.html"},{"title":"helio_drift_linear_pl – swiftest","text":"interface Calls interface~~helio_drift_linear_pl~~CallsGraph interface~helio_drift_linear_pl helio_drift_linear_pl proc~helio_drift_linear_pl helio_drift_linear_pl interface~helio_drift_linear_pl->proc~helio_drift_linear_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_drift_linear_pl(self, cb, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( helio_cb ), intent(inout) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step","tags":"","loc":"interface/helio_drift_linear_pl.html"},{"title":"helio_drift_linear_tp – swiftest","text":"interface Calls interface~~helio_drift_linear_tp~~CallsGraph interface~helio_drift_linear_tp helio_drift_linear_tp proc~helio_drift_linear_tp helio_drift_linear_tp interface~helio_drift_linear_tp->proc~helio_drift_linear_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_drift_linear_tp(self, cb, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( helio_cb ), intent(in) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step","tags":"","loc":"interface/helio_drift_linear_tp.html"},{"title":"helio_gr_kick_getacch_pl – swiftest","text":"interface Calls interface~~helio_gr_kick_getacch_pl~~CallsGraph interface~helio_gr_kick_getacch_pl helio_gr_kick_getacch_pl proc~helio_gr_kick_getacch_pl helio_gr_kick_getacch_pl interface~helio_gr_kick_getacch_pl->proc~helio_gr_kick_getacch_pl gr_kick_getacch gr_kick_getacch proc~helio_gr_kick_getacch_pl->gr_kick_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_gr_kick_getacch_pl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/helio_gr_kick_getacch_pl.html"},{"title":"helio_gr_kick_getacch_tp – swiftest","text":"interface Calls interface~~helio_gr_kick_getacch_tp~~CallsGraph interface~helio_gr_kick_getacch_tp helio_gr_kick_getacch_tp proc~helio_gr_kick_getacch_tp helio_gr_kick_getacch_tp interface~helio_gr_kick_getacch_tp->proc~helio_gr_kick_getacch_tp gr_kick_getacch gr_kick_getacch proc~helio_gr_kick_getacch_tp->gr_kick_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_gr_kick_getacch_tp(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/helio_gr_kick_getacch_tp.html"},{"title":"helio_gr_p4_pl – swiftest","text":"interface Calls interface~~helio_gr_p4_pl~~CallsGraph interface~helio_gr_p4_pl helio_gr_p4_pl proc~helio_gr_p4_pl helio_gr_p4_pl interface~helio_gr_p4_pl->proc~helio_gr_p4_pl gr_p4_pos_kick gr_p4_pos_kick proc~helio_gr_p4_pl->gr_p4_pos_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine helio_gr_p4_pl(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size","tags":"","loc":"interface/helio_gr_p4_pl.html"},{"title":"helio_gr_p4_tp – swiftest","text":"interface Calls interface~~helio_gr_p4_tp~~CallsGraph interface~helio_gr_p4_tp helio_gr_p4_tp proc~helio_gr_p4_tp helio_gr_p4_tp interface~helio_gr_p4_tp->proc~helio_gr_p4_tp gr_p4_pos_kick gr_p4_pos_kick proc~helio_gr_p4_tp->gr_p4_pos_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine helio_gr_p4_tp(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size","tags":"","loc":"interface/helio_gr_p4_tp.html"},{"title":"helio_kick_getacch_pl – swiftest","text":"interface Calls interface~~helio_kick_getacch_pl~~CallsGraph interface~helio_kick_getacch_pl helio_kick_getacch_pl proc~helio_kick_getacch_pl helio_kick_getacch_pl interface~helio_kick_getacch_pl->proc~helio_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step","tags":"","loc":"interface/helio_kick_getacch_pl.html"},{"title":"helio_kick_getacch_tp – swiftest","text":"interface Calls interface~~helio_kick_getacch_tp~~CallsGraph interface~helio_kick_getacch_tp helio_kick_getacch_tp proc~helio_kick_getacch_tp helio_kick_getacch_tp interface~helio_kick_getacch_tp->proc~helio_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step","tags":"","loc":"interface/helio_kick_getacch_tp.html"},{"title":"helio_kick_vb_pl – swiftest","text":"interface Calls interface~~helio_kick_vb_pl~~CallsGraph interface~helio_kick_vb_pl helio_kick_vb_pl proc~helio_kick_vb_pl helio_kick_vb_pl interface~helio_kick_vb_pl->proc~helio_kick_vb_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_kick_vb_pl(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not.","tags":"","loc":"interface/helio_kick_vb_pl.html"},{"title":"helio_kick_vb_tp – swiftest","text":"interface Calls interface~~helio_kick_vb_tp~~CallsGraph interface~helio_kick_vb_tp helio_kick_vb_tp proc~helio_kick_vb_tp helio_kick_vb_tp interface~helio_kick_vb_tp->proc~helio_kick_vb_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_kick_vb_tp(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not.","tags":"","loc":"interface/helio_kick_vb_tp.html"},{"title":"helio_step_pl – swiftest","text":"interface Calls interface~~helio_step_pl~~CallsGraph interface~helio_step_pl helio_step_pl proc~helio_step_pl helio_step_pl interface~helio_step_pl->proc~helio_step_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_step_pl(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nboody system class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"interface/helio_step_pl.html"},{"title":"helio_step_system – swiftest","text":"interface Calls interface~~helio_step_system~~CallsGraph interface~helio_step_system helio_step_system proc~helio_step_system helio_step_system interface~helio_step_system->proc~helio_step_system whm_step_system whm_step_system proc~helio_step_system->whm_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_nbody_system ), intent(inout) :: self Helio nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"interface/helio_step_system.html"},{"title":"helio_step_tp – swiftest","text":"interface Calls interface~~helio_step_tp~~CallsGraph interface~helio_step_tp helio_step_tp proc~helio_step_tp helio_step_tp interface~helio_step_tp->proc~helio_step_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_step_tp(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsizee","tags":"","loc":"interface/helio_step_tp.html"},{"title":"whm_coord_h2j_pl – swiftest","text":"interface Calls interface~~whm_coord_h2j_pl~~CallsGraph interface~whm_coord_h2j_pl whm_coord_h2j_pl proc~whm_coord_h2j_pl whm_coord_h2j_pl interface~whm_coord_h2j_pl->proc~whm_coord_h2j_pl gmpl gmpl proc~whm_coord_h2j_pl->gmpl vj vj proc~whm_coord_h2j_pl->vj xj xj proc~whm_coord_h2j_pl->xj vh vh proc~whm_coord_h2j_pl->vh eta eta proc~whm_coord_h2j_pl->eta xh xh proc~whm_coord_h2j_pl->xh Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_coord_h2j_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree","tags":"","loc":"interface/whm_coord_h2j_pl.html"},{"title":"whm_coord_j2h_pl – swiftest","text":"interface Calls interface~~whm_coord_j2h_pl~~CallsGraph interface~whm_coord_j2h_pl whm_coord_j2h_pl proc~whm_coord_j2h_pl whm_coord_j2h_pl interface~whm_coord_j2h_pl->proc~whm_coord_j2h_pl gmpl gmpl proc~whm_coord_j2h_pl->gmpl vj vj proc~whm_coord_j2h_pl->vj xj xj proc~whm_coord_j2h_pl->xj vh vh proc~whm_coord_j2h_pl->vh eta eta proc~whm_coord_j2h_pl->eta xh xh proc~whm_coord_j2h_pl->xh Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_coord_j2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree","tags":"","loc":"interface/whm_coord_j2h_pl.html"},{"title":"whm_coord_vh2vj_pl – swiftest","text":"interface Calls interface~~whm_coord_vh2vj_pl~~CallsGraph interface~whm_coord_vh2vj_pl whm_coord_vh2vj_pl proc~whm_coord_vh2vj_pl whm_coord_vh2vj_pl interface~whm_coord_vh2vj_pl->proc~whm_coord_vh2vj_pl gmpl gmpl proc~whm_coord_vh2vj_pl->gmpl vj vj proc~whm_coord_vh2vj_pl->vj vh vh proc~whm_coord_vh2vj_pl->vh eta eta proc~whm_coord_vh2vj_pl->eta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_coord_vh2vj_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree","tags":"","loc":"interface/whm_coord_vh2vj_pl.html"},{"title":"whm_drift_pl – swiftest","text":"interface Calls interface~~whm_drift_pl~~CallsGraph interface~whm_drift_pl whm_drift_pl proc~whm_drift_pl whm_drift_pl interface~whm_drift_pl->proc~whm_drift_pl drift_all drift_all proc~whm_drift_pl->drift_all util_exit util_exit proc~whm_drift_pl->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"interface/whm_drift_pl.html"},{"title":"whm_kick_getacch_pl – swiftest","text":"interface Calls interface~~whm_kick_getacch_pl~~CallsGraph interface~whm_kick_getacch_pl whm_kick_getacch_pl proc~whm_kick_getacch_pl whm_kick_getacch_pl interface~whm_kick_getacch_pl->proc~whm_kick_getacch_pl proc~whm_kick_getacch_ah2 whm_kick_getacch_ah2 proc~whm_kick_getacch_pl->proc~whm_kick_getacch_ah2 proc~whm_kick_getacch_ah0 whm_kick_getacch_ah0 proc~whm_kick_getacch_pl->proc~whm_kick_getacch_ah0 proc~whm_kick_getacch_ah1 whm_kick_getacch_ah1 proc~whm_kick_getacch_pl->proc~whm_kick_getacch_ah1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step Description Get heliocentric accelration of massive bodies","tags":"","loc":"interface/whm_kick_getacch_pl.html"},{"title":"whm_kick_getacch_tp – swiftest","text":"interface Calls interface~~whm_kick_getacch_tp~~CallsGraph interface~whm_kick_getacch_tp whm_kick_getacch_tp proc~whm_kick_getacch_tp whm_kick_getacch_tp interface~whm_kick_getacch_tp->proc~whm_kick_getacch_tp proc~whm_kick_getacch_ah0 whm_kick_getacch_ah0 proc~whm_kick_getacch_tp->proc~whm_kick_getacch_ah0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step Description Get heliocentric accelration of the test particle","tags":"","loc":"interface/whm_kick_getacch_tp.html"},{"title":"whm_kick_vh_pl – swiftest","text":"interface Calls interface~~whm_kick_vh_pl~~CallsGraph interface~whm_kick_vh_pl whm_kick_vh_pl proc~whm_kick_vh_pl whm_kick_vh_pl interface~whm_kick_vh_pl->proc~whm_kick_vh_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_kick_vh_pl(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not.","tags":"","loc":"interface/whm_kick_vh_pl.html"},{"title":"whm_kick_vh_tp – swiftest","text":"interface Calls interface~~whm_kick_vh_tp~~CallsGraph interface~whm_kick_vh_tp whm_kick_vh_tp proc~whm_kick_vh_tp whm_kick_vh_tp interface~whm_kick_vh_tp->proc~whm_kick_vh_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_kick_vh_tp(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not.","tags":"","loc":"interface/whm_kick_vh_tp.html"},{"title":"whm_gr_kick_getacch_pl – swiftest","text":"interface Calls interface~~whm_gr_kick_getacch_pl~~CallsGraph interface~whm_gr_kick_getacch_pl whm_gr_kick_getacch_pl proc~whm_gr_kick_getacch_pl whm_gr_kick_getacch_pl interface~whm_gr_kick_getacch_pl->proc~whm_gr_kick_getacch_pl gr_kick_getacch gr_kick_getacch proc~whm_gr_kick_getacch_pl->gr_kick_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_gr_kick_getacch_pl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/whm_gr_kick_getacch_pl.html"},{"title":"whm_gr_kick_getacch_tp – swiftest","text":"interface Calls interface~~whm_gr_kick_getacch_tp~~CallsGraph interface~whm_gr_kick_getacch_tp whm_gr_kick_getacch_tp proc~whm_gr_kick_getacch_tp whm_gr_kick_getacch_tp interface~whm_gr_kick_getacch_tp->proc~whm_gr_kick_getacch_tp gr_kick_getacch gr_kick_getacch proc~whm_gr_kick_getacch_tp->gr_kick_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_gr_kick_getacch_tp(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/whm_gr_kick_getacch_tp.html"},{"title":"whm_gr_p4_pl – swiftest","text":"interface Calls interface~~whm_gr_p4_pl~~CallsGraph interface~whm_gr_p4_pl whm_gr_p4_pl proc~whm_gr_p4_pl whm_gr_p4_pl interface~whm_gr_p4_pl->proc~whm_gr_p4_pl gr_p4_pos_kick gr_p4_pos_kick proc~whm_gr_p4_pl->gr_p4_pos_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine whm_gr_p4_pl(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size","tags":"","loc":"interface/whm_gr_p4_pl.html"},{"title":"whm_gr_p4_tp – swiftest","text":"interface Calls interface~~whm_gr_p4_tp~~CallsGraph interface~whm_gr_p4_tp whm_gr_p4_tp proc~whm_gr_p4_tp whm_gr_p4_tp interface~whm_gr_p4_tp->proc~whm_gr_p4_tp gr_p4_pos_kick gr_p4_pos_kick proc~whm_gr_p4_tp->gr_p4_pos_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine whm_gr_p4_tp(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size","tags":"","loc":"interface/whm_gr_p4_tp.html"},{"title":"whm_setup_pl – swiftest","text":"interface Calls interface~~whm_setup_pl~~CallsGraph interface~whm_setup_pl whm_setup_pl proc~whm_setup_pl whm_setup_pl interface~whm_setup_pl->proc~whm_setup_pl setup_pl setup_pl proc~whm_setup_pl->setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body objectobject integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameters Description Reads WHM massive body object in from file","tags":"","loc":"interface/whm_setup_pl.html"},{"title":"whm_setup_initialize_system – swiftest","text":"interface Calls interface~~whm_setup_initialize_system~~CallsGraph interface~whm_setup_initialize_system whm_setup_initialize_system proc~whm_setup_initialize_system whm_setup_initialize_system interface~whm_setup_initialize_system->proc~whm_setup_initialize_system util_set_ir3h util_set_ir3h proc~whm_setup_initialize_system->util_set_ir3h setup_initialize_system setup_initialize_system proc~whm_setup_initialize_system->setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_nbody_system ), intent(inout) :: self WHM nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/whm_setup_initialize_system.html"},{"title":"whm_step_pl – swiftest","text":"interface Calls interface~~whm_step_pl~~CallsGraph interface~whm_step_pl whm_step_pl proc~whm_step_pl whm_step_pl interface~whm_step_pl->proc~whm_step_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_step_pl(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"interface/whm_step_pl.html"},{"title":"whm_step_system – swiftest","text":"interface Calls interface~~whm_step_system~~CallsGraph interface~whm_step_system whm_step_system proc~whm_step_system whm_step_system interface~whm_step_system->proc~whm_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_nbody_system ), intent(inout) :: self WHM system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"interface/whm_step_system.html"},{"title":"whm_step_tp – swiftest","text":"interface Calls interface~~whm_step_tp~~CallsGraph interface~whm_step_tp whm_step_tp proc~whm_step_tp whm_step_tp interface~whm_step_tp->proc~whm_step_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_step_tp(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"interface/whm_step_tp.html"},{"title":"whm_util_append_pl – swiftest","text":"interface Calls interface~~whm_util_append_pl~~CallsGraph interface~whm_util_append_pl whm_util_append_pl proc~whm_util_append_pl whm_util_append_pl interface~whm_util_append_pl->proc~whm_util_append_pl util_append util_append proc~whm_util_append_pl->util_append util_exit util_exit proc~whm_util_append_pl->util_exit util_append_pl util_append_pl proc~whm_util_append_pl->util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/whm_util_append_pl.html"},{"title":"whm_util_spill_pl – swiftest","text":"interface Calls interface~~whm_util_spill_pl~~CallsGraph interface~whm_util_spill_pl whm_util_spill_pl proc~whm_util_spill_pl whm_util_spill_pl interface~whm_util_spill_pl->proc~whm_util_spill_pl util_spill util_spill proc~whm_util_spill_pl->util_spill util_exit util_exit proc~whm_util_spill_pl->util_exit util_spill_pl util_spill_pl proc~whm_util_spill_pl->util_spill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"interface/whm_util_spill_pl.html"},{"title":"whm_util_fill_pl – swiftest","text":"interface Calls interface~~whm_util_fill_pl~~CallsGraph interface~whm_util_fill_pl whm_util_fill_pl proc~whm_util_fill_pl whm_util_fill_pl interface~whm_util_fill_pl->proc~whm_util_fill_pl util_fill_pl util_fill_pl proc~whm_util_fill_pl->util_fill_pl util_fill util_fill proc~whm_util_fill_pl->util_fill util_exit util_exit proc~whm_util_fill_pl->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(in) :: inserts inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"interface/whm_util_fill_pl.html"},{"title":"whm_util_resize_pl – swiftest","text":"interface Calls interface~~whm_util_resize_pl~~CallsGraph interface~whm_util_resize_pl whm_util_resize_pl proc~whm_util_resize_pl whm_util_resize_pl interface~whm_util_resize_pl->proc~whm_util_resize_pl util_resize_pl util_resize_pl proc~whm_util_resize_pl->util_resize_pl util_resize util_resize proc~whm_util_resize_pl->util_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object integer(kind=I4B), intent(in) :: nnew New size neded","tags":"","loc":"interface/whm_util_resize_pl.html"},{"title":"whm_util_set_ir3j – swiftest","text":"interface Calls interface~~whm_util_set_ir3j~~CallsGraph interface~whm_util_set_ir3j whm_util_set_ir3j proc~whm_util_set_ir3j whm_util_set_ir3j interface~whm_util_set_ir3j->proc~whm_util_set_ir3j Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_util_set_ir3j(self) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object","tags":"","loc":"interface/whm_util_set_ir3j.html"},{"title":"whm_util_set_mu_eta_pl – swiftest","text":"interface Calls interface~~whm_util_set_mu_eta_pl~~CallsGraph interface~whm_util_set_mu_eta_pl whm_util_set_mu_eta_pl proc~whm_util_set_mu_eta_pl whm_util_set_mu_eta_pl interface~whm_util_set_mu_eta_pl->proc~whm_util_set_mu_eta_pl util_set_mu_pl util_set_mu_pl proc~whm_util_set_mu_eta_pl->util_set_mu_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_util_set_mu_eta_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/whm_util_set_mu_eta_pl.html"},{"title":"whm_util_sort_pl – swiftest","text":"interface Calls interface~~whm_util_sort_pl~~CallsGraph interface~whm_util_sort_pl whm_util_sort_pl proc~whm_util_sort_pl whm_util_sort_pl interface~whm_util_sort_pl->proc~whm_util_sort_pl util_sort_pl util_sort_pl proc~whm_util_sort_pl->util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order","tags":"","loc":"interface/whm_util_sort_pl.html"},{"title":"whm_util_sort_rearrange_pl – swiftest","text":"interface Calls interface~~whm_util_sort_rearrange_pl~~CallsGraph interface~whm_util_sort_rearrange_pl whm_util_sort_rearrange_pl proc~whm_util_sort_rearrange_pl whm_util_sort_rearrange_pl interface~whm_util_sort_rearrange_pl->proc~whm_util_sort_rearrange_pl util_sort_rearrange_pl util_sort_rearrange_pl proc~whm_util_sort_rearrange_pl->util_sort_rearrange_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order)","tags":"","loc":"interface/whm_util_sort_rearrange_pl.html"},{"title":"symba_encounter_check_pl – swiftest","text":"interface Calls interface~~symba_encounter_check_pl~~CallsGraph interface~symba_encounter_check_pl symba_encounter_check_pl proc~symba_encounter_check_pl symba_encounter_check_pl interface~symba_encounter_check_pl->proc~symba_encounter_check_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function symba_encounter_check_pl(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter","tags":"","loc":"interface/symba_encounter_check_pl.html"},{"title":"symba_encounter_check_pltpenc – swiftest","text":"interface Calls interface~~symba_encounter_check_pltpenc~~CallsGraph interface~symba_encounter_check_pltpenc symba_encounter_check_pltpenc proc~symba_encounter_check_pltpenc symba_encounter_check_pltpenc interface~symba_encounter_check_pltpenc->proc~symba_encounter_check_pltpenc ind1 ind1 proc~symba_encounter_check_pltpenc->ind1 ind2 ind2 proc~symba_encounter_check_pltpenc->ind2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function symba_encounter_check_pltpenc(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-pl encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter","tags":"","loc":"interface/symba_encounter_check_pltpenc.html"},{"title":"symba_encounter_check_tp – swiftest","text":"interface Calls interface~~symba_encounter_check_tp~~CallsGraph interface~symba_encounter_check_tp symba_encounter_check_tp proc~symba_encounter_check_tp symba_encounter_check_tp interface~symba_encounter_check_tp->proc~symba_encounter_check_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function symba_encounter_check_tp(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter","tags":"","loc":"interface/symba_encounter_check_tp.html"},{"title":"symba_fragmentation_casedisruption – swiftest","text":"interface Calls interface~~symba_fragmentation_casedisruption~~CallsGraph interface~symba_fragmentation_casedisruption symba_fragmentation_casedisruption proc~symba_fragmentation_casedisruption symba_fragmentation_casedisruption interface~symba_fragmentation_casedisruption->proc~symba_fragmentation_casedisruption proc~symba_fragmentation_mergeaddsub symba_fragmentation_mergeaddsub proc~symba_fragmentation_casedisruption->proc~symba_fragmentation_mergeaddsub fragmentation_initialize fragmentation_initialize proc~symba_fragmentation_casedisruption->fragmentation_initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~symba_fragmentation_casedisruption~~CalledByGraph interface~symba_fragmentation_casedisruption symba_fragmentation_casedisruption proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations proc~symba_collision_resolve_fragmentations->interface~symba_fragmentation_casedisruption interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function symba_fragmentation_casedisruption(system, param, family, x, v, mass, radius, L_spin, Ip, mass_res, Qloss) result(status) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(in), dimension(:) :: family List of indices of all bodies inovlved in the collision real(kind=DP), intent(inout), dimension(:,:) :: x Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: v Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: radius Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: L_spin Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: Ip Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass_res The distribution of fragment mass obtained by the regime calculation real(kind=DP), intent(inout) :: Qloss Energy lost during collisionn Return Value integer(kind=I4B) Status flag assigned to this outcome","tags":"","loc":"interface/symba_fragmentation_casedisruption.html"},{"title":"symba_fragmentation_casehitandrun – swiftest","text":"interface Calls interface~~symba_fragmentation_casehitandrun~~CallsGraph interface~symba_fragmentation_casehitandrun symba_fragmentation_casehitandrun proc~symba_fragmentation_casehitandrun symba_fragmentation_casehitandrun interface~symba_fragmentation_casehitandrun->proc~symba_fragmentation_casehitandrun proc~symba_fragmentation_mergeaddsub symba_fragmentation_mergeaddsub proc~symba_fragmentation_casehitandrun->proc~symba_fragmentation_mergeaddsub fragmentation_initialize fragmentation_initialize proc~symba_fragmentation_casehitandrun->fragmentation_initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~symba_fragmentation_casehitandrun~~CalledByGraph interface~symba_fragmentation_casehitandrun symba_fragmentation_casehitandrun proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations proc~symba_collision_resolve_fragmentations->interface~symba_fragmentation_casehitandrun interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function symba_fragmentation_casehitandrun(system, param, family, x, v, mass, radius, L_spin, Ip, mass_res, Qloss) result(status) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(in), dimension(:) :: family List of indices of all bodies inovlved in the collision real(kind=DP), intent(inout), dimension(:,:) :: x Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: v Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: radius Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: L_spin Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: Ip Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass_res The distribution of fragment mass obtained by the regime calculation real(kind=DP), intent(inout) :: Qloss Energy lost during collision Return Value integer(kind=I4B) Status flag assigned to this outcome","tags":"","loc":"interface/symba_fragmentation_casehitandrun.html"},{"title":"symba_fragmentation_casemerge – swiftest","text":"interface Calls interface~~symba_fragmentation_casemerge~~CallsGraph interface~symba_fragmentation_casemerge symba_fragmentation_casemerge proc~symba_fragmentation_casemerge symba_fragmentation_casemerge interface~symba_fragmentation_casemerge->proc~symba_fragmentation_casemerge proc~symba_fragmentation_mergeaddsub symba_fragmentation_mergeaddsub proc~symba_fragmentation_casemerge->proc~symba_fragmentation_mergeaddsub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~symba_fragmentation_casemerge~~CalledByGraph interface~symba_fragmentation_casemerge symba_fragmentation_casemerge proc~symba_collision_resolve_mergers symba_collision_resolve_mergers proc~symba_collision_resolve_mergers->interface~symba_fragmentation_casemerge proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations proc~symba_collision_resolve_fragmentations->interface~symba_fragmentation_casemerge interface~symba_collision_resolve_mergers symba_collision_resolve_mergers interface~symba_collision_resolve_mergers->proc~symba_collision_resolve_mergers interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function symba_fragmentation_casemerge(system, param, family, x, v, mass, radius, L_spin, Ip) result(status) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(in), dimension(:) :: family List of indices of all bodies inovlved in the collision real(kind=DP), intent(in), dimension(:,:) :: x Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(in), dimension(:,:) :: v Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(in), dimension(:) :: mass Input values that represent a 2-body equivalent of a possibly 2+ body collisio real(kind=DP), intent(in), dimension(:) :: radius Input values that represent a 2-body equivalent of a possibly 2+ body collisio real(kind=DP), intent(in), dimension(:,:) :: L_spin Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(in), dimension(:,:) :: Ip Input values that represent a 2-body equivalent of a possibly 2+ body collision Return Value integer(kind=I4B) Status flag assigned to this outcome","tags":"","loc":"interface/symba_fragmentation_casemerge.html"},{"title":"symba_fragmentation_casesupercatastrophic – swiftest","text":"interface Calls interface~~symba_fragmentation_casesupercatastrophic~~CallsGraph interface~symba_fragmentation_casesupercatastrophic symba_fragmentation_casesupercatastrophic proc~symba_fragmentation_casesupercatastrophic symba_fragmentation_casesupercatastrophic interface~symba_fragmentation_casesupercatastrophic->proc~symba_fragmentation_casesupercatastrophic proc~symba_fragmentation_mergeaddsub symba_fragmentation_mergeaddsub proc~symba_fragmentation_casesupercatastrophic->proc~symba_fragmentation_mergeaddsub fragmentation_initialize fragmentation_initialize proc~symba_fragmentation_casesupercatastrophic->fragmentation_initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~symba_fragmentation_casesupercatastrophic~~CalledByGraph interface~symba_fragmentation_casesupercatastrophic symba_fragmentation_casesupercatastrophic proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations proc~symba_collision_resolve_fragmentations->interface~symba_fragmentation_casesupercatastrophic interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function symba_fragmentation_casesupercatastrophic(system, param, family, x, v, mass, radius, L_spin, Ip, mass_res, Qloss) result(status) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(in), dimension(:) :: family List of indices of all bodies inovlved in the collision real(kind=DP), intent(inout), dimension(:,:) :: x Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: v Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: radius Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: L_spin Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: Ip Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass_res The distribution of fragment mass obtained by the regime calculation real(kind=DP), intent(inout) :: Qloss Energy lost during collision Return Value integer(kind=I4B) Status flag assigned to this outcome","tags":"","loc":"interface/symba_fragmentation_casesupercatastrophic.html"},{"title":"symba_collision_check_pltpenc – swiftest","text":"interface Calls interface~~symba_collision_check_pltpenc~~CallsGraph interface~symba_collision_check_pltpenc symba_collision_check_pltpenc proc~symba_collision_check_pltpenc symba_collision_check_pltpenc interface~symba_collision_check_pltpenc->proc~symba_collision_check_pltpenc ind1 ind1 proc~symba_collision_check_pltpenc->ind1 proc~symba_collision_check_one symba_collision_check_one proc~symba_collision_check_pltpenc->proc~symba_collision_check_one ind2 ind2 proc~symba_collision_check_pltpenc->ind2 orbel_xv2aeq orbel_xv2aeq proc~symba_collision_check_one->orbel_xv2aeq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_collision_check_pltpenc(self, system, param, t, dt, irec) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t current time real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level","tags":"","loc":"interface/symba_collision_check_pltpenc.html"},{"title":"symba_collision_encounter_scrub – swiftest","text":"interface Calls interface~~symba_collision_encounter_scrub~~CallsGraph interface~symba_collision_encounter_scrub symba_collision_encounter_scrub proc~symba_collision_encounter_scrub symba_collision_encounter_scrub interface~symba_collision_encounter_scrub->proc~symba_collision_encounter_scrub idx1 idx1 proc~symba_collision_encounter_scrub->idx1 idx2 idx2 proc~symba_collision_encounter_scrub->idx2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_collision_encounter_scrub(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameterss","tags":"","loc":"interface/symba_collision_encounter_scrub.html"},{"title":"symba_collision_make_family_pl – swiftest","text":"interface Calls interface~~symba_collision_make_family_pl~~CallsGraph interface~symba_collision_make_family_pl symba_collision_make_family_pl proc~symba_collision_make_family_pl symba_collision_make_family_pl interface~symba_collision_make_family_pl->proc~symba_collision_make_family_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_collision_make_family_pl(self, idx) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(2) :: idx Array holding the indices of the two bodies involved in the collision","tags":"","loc":"interface/symba_collision_make_family_pl.html"},{"title":"symba_collision_resolve_fragmentations – swiftest","text":"interface Calls interface~~symba_collision_resolve_fragmentations~~CallsGraph interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations idx1 idx1 proc~symba_collision_resolve_fragmentations->idx1 interface~symba_fragmentation_casehitandrun symba_fragmentation_casehitandrun proc~symba_collision_resolve_fragmentations->interface~symba_fragmentation_casehitandrun interface~symba_fragmentation_casemerge symba_fragmentation_casemerge proc~symba_collision_resolve_fragmentations->interface~symba_fragmentation_casemerge util_exit util_exit proc~symba_collision_resolve_fragmentations->util_exit proc~symba_collision_consolidate_familes symba_collision_consolidate_familes proc~symba_collision_resolve_fragmentations->proc~symba_collision_consolidate_familes interface~symba_fragmentation_casesupercatastrophic symba_fragmentation_casesupercatastrophic proc~symba_collision_resolve_fragmentations->interface~symba_fragmentation_casesupercatastrophic idx2 idx2 proc~symba_collision_resolve_fragmentations->idx2 interface~symba_fragmentation_casedisruption symba_fragmentation_casedisruption proc~symba_collision_resolve_fragmentations->interface~symba_fragmentation_casedisruption proc~symba_fragmentation_casehitandrun symba_fragmentation_casehitandrun interface~symba_fragmentation_casehitandrun->proc~symba_fragmentation_casehitandrun proc~symba_fragmentation_casemerge symba_fragmentation_casemerge interface~symba_fragmentation_casemerge->proc~symba_fragmentation_casemerge id_arr id_arr proc~symba_collision_consolidate_familes->id_arr idx_arr idx_arr proc~symba_collision_consolidate_familes->idx_arr proc~symba_fragmentation_casesupercatastrophic symba_fragmentation_casesupercatastrophic interface~symba_fragmentation_casesupercatastrophic->proc~symba_fragmentation_casesupercatastrophic proc~symba_fragmentation_casedisruption symba_fragmentation_casedisruption interface~symba_fragmentation_casedisruption->proc~symba_fragmentation_casedisruption proc~symba_fragmentation_mergeaddsub symba_fragmentation_mergeaddsub proc~symba_fragmentation_casehitandrun->proc~symba_fragmentation_mergeaddsub fragmentation_initialize fragmentation_initialize proc~symba_fragmentation_casehitandrun->fragmentation_initialize proc~symba_fragmentation_casesupercatastrophic->proc~symba_fragmentation_mergeaddsub proc~symba_fragmentation_casesupercatastrophic->fragmentation_initialize proc~symba_fragmentation_casedisruption->proc~symba_fragmentation_mergeaddsub proc~symba_fragmentation_casedisruption->fragmentation_initialize proc~symba_fragmentation_casemerge->proc~symba_fragmentation_mergeaddsub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_collision_resolve_fragmentations(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions","tags":"","loc":"interface/symba_collision_resolve_fragmentations.html"},{"title":"symba_collision_resolve_mergers – swiftest","text":"interface Calls interface~~symba_collision_resolve_mergers~~CallsGraph interface~symba_collision_resolve_mergers symba_collision_resolve_mergers proc~symba_collision_resolve_mergers symba_collision_resolve_mergers interface~symba_collision_resolve_mergers->proc~symba_collision_resolve_mergers idx1 idx1 proc~symba_collision_resolve_mergers->idx1 proc~symba_collision_consolidate_familes symba_collision_consolidate_familes proc~symba_collision_resolve_mergers->proc~symba_collision_consolidate_familes interface~symba_fragmentation_casemerge symba_fragmentation_casemerge proc~symba_collision_resolve_mergers->interface~symba_fragmentation_casemerge idx2 idx2 proc~symba_collision_resolve_mergers->idx2 id_arr id_arr proc~symba_collision_consolidate_familes->id_arr idx_arr idx_arr proc~symba_collision_consolidate_familes->idx_arr proc~symba_fragmentation_casemerge symba_fragmentation_casemerge interface~symba_fragmentation_casemerge->proc~symba_fragmentation_casemerge proc~symba_fragmentation_mergeaddsub symba_fragmentation_mergeaddsub proc~symba_fragmentation_casemerge->proc~symba_fragmentation_mergeaddsub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_collision_resolve_mergers(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions","tags":"","loc":"interface/symba_collision_resolve_mergers.html"},{"title":"symba_discard_pl – swiftest","text":"interface Calls interface~~symba_discard_pl~~CallsGraph interface~symba_discard_pl symba_discard_pl proc~symba_discard_pl symba_discard_pl interface~symba_discard_pl->proc~symba_discard_pl proc~symba_discard_nonplpl symba_discard_nonplpl proc~symba_discard_pl->proc~symba_discard_nonplpl proc~symba_discard_nonplpl_conservation symba_discard_nonplpl_conservation proc~symba_discard_pl->proc~symba_discard_nonplpl_conservation proc~symba_discard_cb_pl symba_discard_cb_pl proc~symba_discard_nonplpl->proc~symba_discard_cb_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_discard_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/symba_discard_pl.html"},{"title":"symba_drift_pl – swiftest","text":"interface Calls interface~~symba_drift_pl~~CallsGraph interface~symba_drift_pl symba_drift_pl proc~symba_drift_pl symba_drift_pl interface~symba_drift_pl->proc~symba_drift_pl helio_drift_body helio_drift_body proc~symba_drift_pl->helio_drift_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"interface/symba_drift_pl.html"},{"title":"symba_drift_tp – swiftest","text":"interface Calls interface~~symba_drift_tp~~CallsGraph interface~symba_drift_tp symba_drift_tp proc~symba_drift_tp symba_drift_tp interface~symba_drift_tp->proc~symba_drift_tp helio_drift_body helio_drift_body proc~symba_drift_tp->helio_drift_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_drift_tp(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"interface/symba_drift_tp.html"},{"title":"symba_encounter_check_one – swiftest","text":"interface Calls interface~~symba_encounter_check_one~~CallsGraph interface~symba_encounter_check_one symba_encounter_check_one proc~symba_encounter_check_one symba_encounter_check_one interface~symba_encounter_check_one->proc~symba_encounter_check_one interface~rmvs_chk_ind rmvs_chk_ind proc~symba_encounter_check_one->interface~rmvs_chk_ind proc~rmvs_chk_ind rmvs_chk_ind interface~rmvs_chk_ind->proc~rmvs_chk_ind Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure elemental module subroutine symba_encounter_check_one(xr, yr, zr, vxr, vyr, vzr, rhill1, rhill2, dt, irec, lencounter, lvdotr) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: xr real(kind=DP), intent(in) :: yr real(kind=DP), intent(in) :: zr real(kind=DP), intent(in) :: vxr real(kind=DP), intent(in) :: vyr real(kind=DP), intent(in) :: vzr real(kind=DP), intent(in) :: rhill1 real(kind=DP), intent(in) :: rhill2 real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: irec logical, intent(out) :: lencounter logical, intent(out) :: lvdotr","tags":"","loc":"interface/symba_encounter_check_one.html"},{"title":"symba_io_write_discard – swiftest","text":"interface Calls interface~~symba_io_write_discard~~CallsGraph interface~symba_io_write_discard symba_io_write_discard proc~symba_io_write_discard symba_io_write_discard interface~symba_io_write_discard->proc~symba_io_write_discard util_exit util_exit proc~symba_io_write_discard->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_io_write_discard(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/symba_io_write_discard.html"},{"title":"symba_io_dump_particle_info – swiftest","text":"interface Calls interface~~symba_io_dump_particle_info~~CallsGraph interface~symba_io_dump_particle_info symba_io_dump_particle_info proc~symba_io_dump_particle_info symba_io_dump_particle_info interface~symba_io_dump_particle_info->proc~symba_io_dump_particle_info util_exit util_exit proc~symba_io_dump_particle_info->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~symba_io_dump_particle_info~~CalledByGraph interface~symba_io_dump_particle_info symba_io_dump_particle_info proc~symba_setup_initialize_particle_info symba_setup_initialize_particle_info proc~symba_setup_initialize_particle_info->interface~symba_io_dump_particle_info proc~symba_util_rearray_pl symba_util_rearray_pl proc~symba_util_rearray_pl->interface~symba_io_dump_particle_info interface~symba_setup_initialize_particle_info symba_setup_initialize_particle_info interface~symba_setup_initialize_particle_info->proc~symba_setup_initialize_particle_info interface~symba_util_rearray_pl symba_util_rearray_pl interface~symba_util_rearray_pl->proc~symba_util_rearray_pl proc~symba_setup_initialize_system symba_setup_initialize_system proc~symba_setup_initialize_system->interface~symba_setup_initialize_particle_info interface~symba_setup_initialize_system symba_setup_initialize_system interface~symba_setup_initialize_system->proc~symba_setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_io_dump_particle_info(system, param, lincludecb, tpidx, plidx) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA extensions logical, intent(in), optional :: lincludecb Set to true to include the central body (default is false) integer(kind=I4B), intent(in), optional dimension(:) :: tpidx Array of test particle indices to append to the particle file integer(kind=I4B), intent(in), optional dimension(:) :: plidx Array of massive body indices to append to the particle file","tags":"","loc":"interface/symba_io_dump_particle_info.html"},{"title":"symba_io_param_reader – swiftest","text":"interface Calls interface~~symba_io_param_reader~~CallsGraph interface~symba_io_param_reader symba_io_param_reader proc~symba_io_param_reader symba_io_param_reader interface~symba_io_param_reader->proc~symba_io_param_reader io_toupper io_toupper proc~symba_io_param_reader->io_toupper io_param_reader io_param_reader proc~symba_io_param_reader->io_param_reader io_get_token io_get_token proc~symba_io_param_reader->io_get_token Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_io_param_reader(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_parameters ), intent(inout) :: self Current run configuration parameters with SyMBA additionss integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) The first element passes the integrator code to the reader integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0","tags":"","loc":"interface/symba_io_param_reader.html"},{"title":"symba_io_param_writer – swiftest","text":"interface Calls interface~~symba_io_param_writer~~CallsGraph interface~symba_io_param_writer symba_io_param_writer proc~symba_io_param_writer symba_io_param_writer interface~symba_io_param_writer->proc~symba_io_param_writer io_param_writer io_param_writer proc~symba_io_param_writer->io_param_writer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_io_param_writer(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_parameters ), intent(in) :: self Current run configuration parameters with SyMBA additions integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) Not used in this procedure integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0","tags":"","loc":"interface/symba_io_param_writer.html"},{"title":"symba_io_read_particle – swiftest","text":"interface Calls interface~~symba_io_read_particle~~CallsGraph interface~symba_io_read_particle symba_io_read_particle proc~symba_io_read_particle symba_io_read_particle interface~symba_io_read_particle->proc~symba_io_read_particle util_exit util_exit proc~symba_io_read_particle->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~symba_io_read_particle~~CalledByGraph interface~symba_io_read_particle symba_io_read_particle proc~symba_setup_initialize_system symba_setup_initialize_system proc~symba_setup_initialize_system->interface~symba_io_read_particle interface~symba_setup_initialize_system symba_setup_initialize_system interface~symba_setup_initialize_system->proc~symba_setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_io_read_particle(system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system file class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA extensions","tags":"","loc":"interface/symba_io_read_particle.html"},{"title":"symba_kick_getacch_pl – swiftest","text":"interface Calls interface~~symba_kick_getacch_pl~~CallsGraph interface~symba_kick_getacch_pl symba_kick_getacch_pl proc~symba_kick_getacch_pl symba_kick_getacch_pl interface~symba_kick_getacch_pl->proc~symba_kick_getacch_pl helio_kick_getacch_pl helio_kick_getacch_pl proc~symba_kick_getacch_pl->helio_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step","tags":"","loc":"interface/symba_kick_getacch_pl.html"},{"title":"symba_kick_getacch_tp – swiftest","text":"interface Calls interface~~symba_kick_getacch_tp~~CallsGraph interface~symba_kick_getacch_tp symba_kick_getacch_tp proc~symba_kick_getacch_tp symba_kick_getacch_tp interface~symba_kick_getacch_tp->proc~symba_kick_getacch_tp helio_kick_getacch_tp helio_kick_getacch_tp proc~symba_kick_getacch_tp->helio_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step","tags":"","loc":"interface/symba_kick_getacch_tp.html"},{"title":"symba_kick_pltpenc – swiftest","text":"interface Calls interface~~symba_kick_pltpenc~~CallsGraph interface~symba_kick_pltpenc symba_kick_pltpenc proc~symba_kick_pltpenc symba_kick_pltpenc interface~symba_kick_pltpenc->proc~symba_kick_pltpenc ind1 ind1 proc~symba_kick_pltpenc->ind1 ind2 ind2 proc~symba_kick_pltpenc->ind2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_kick_pltpenc(self, system, dt, irec, sgn) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(in) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level integer(kind=I4B), intent(in) :: sgn sign to be applied to acceleration","tags":"","loc":"interface/symba_kick_pltpenc.html"},{"title":"symba_setup_initialize_particle_info – swiftest","text":"interface Calls interface~~symba_setup_initialize_particle_info~~CallsGraph interface~symba_setup_initialize_particle_info symba_setup_initialize_particle_info proc~symba_setup_initialize_particle_info symba_setup_initialize_particle_info interface~symba_setup_initialize_particle_info->proc~symba_setup_initialize_particle_info interface~symba_io_dump_particle_info symba_io_dump_particle_info proc~symba_setup_initialize_particle_info->interface~symba_io_dump_particle_info proc~symba_io_dump_particle_info symba_io_dump_particle_info interface~symba_io_dump_particle_info->proc~symba_io_dump_particle_info util_exit util_exit proc~symba_io_dump_particle_info->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~symba_setup_initialize_particle_info~~CalledByGraph interface~symba_setup_initialize_particle_info symba_setup_initialize_particle_info proc~symba_setup_initialize_system symba_setup_initialize_system proc~symba_setup_initialize_system->interface~symba_setup_initialize_particle_info interface~symba_setup_initialize_system symba_setup_initialize_system interface~symba_setup_initialize_system->proc~symba_setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_setup_initialize_particle_info(system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA extensions","tags":"","loc":"interface/symba_setup_initialize_particle_info.html"},{"title":"symba_setup_initialize_system – swiftest","text":"interface Calls interface~~symba_setup_initialize_system~~CallsGraph interface~symba_setup_initialize_system symba_setup_initialize_system proc~symba_setup_initialize_system symba_setup_initialize_system interface~symba_setup_initialize_system->proc~symba_setup_initialize_system interface~symba_setup_initialize_particle_info symba_setup_initialize_particle_info proc~symba_setup_initialize_system->interface~symba_setup_initialize_particle_info whm_setup_initialize_system whm_setup_initialize_system proc~symba_setup_initialize_system->whm_setup_initialize_system interface~symba_io_read_particle symba_io_read_particle proc~symba_setup_initialize_system->interface~symba_io_read_particle proc~symba_setup_initialize_particle_info symba_setup_initialize_particle_info interface~symba_setup_initialize_particle_info->proc~symba_setup_initialize_particle_info proc~symba_io_read_particle symba_io_read_particle interface~symba_io_read_particle->proc~symba_io_read_particle util_exit util_exit proc~symba_io_read_particle->util_exit interface~symba_io_dump_particle_info symba_io_dump_particle_info proc~symba_setup_initialize_particle_info->interface~symba_io_dump_particle_info proc~symba_io_dump_particle_info symba_io_dump_particle_info interface~symba_io_dump_particle_info->proc~symba_io_dump_particle_info proc~symba_io_dump_particle_info->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/symba_setup_initialize_system.html"},{"title":"symba_setup_merger – swiftest","text":"interface Calls interface~~symba_setup_merger~~CallsGraph interface~symba_setup_merger symba_setup_merger proc~symba_setup_merger symba_setup_merger interface~symba_setup_merger->proc~symba_setup_merger interface~symba_setup_pl symba_setup_pl proc~symba_setup_merger->interface~symba_setup_pl proc~symba_setup_pl symba_setup_pl interface~symba_setup_pl->proc~symba_setup_pl setup_pl setup_pl proc~symba_setup_pl->setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_setup_merger(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA merger list object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/symba_setup_merger.html"},{"title":"symba_setup_pl – swiftest","text":"interface Calls interface~~symba_setup_pl~~CallsGraph interface~symba_setup_pl symba_setup_pl proc~symba_setup_pl symba_setup_pl interface~symba_setup_pl->proc~symba_setup_pl setup_pl setup_pl proc~symba_setup_pl->setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~symba_setup_pl~~CalledByGraph interface~symba_setup_pl symba_setup_pl proc~symba_setup_merger symba_setup_merger proc~symba_setup_merger->interface~symba_setup_pl interface~symba_setup_merger symba_setup_merger interface~symba_setup_merger->proc~symba_setup_merger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/symba_setup_pl.html"},{"title":"symba_setup_pltpenc – swiftest","text":"interface Calls interface~~symba_setup_pltpenc~~CallsGraph interface~symba_setup_pltpenc symba_setup_pltpenc proc~symba_setup_pltpenc symba_setup_pltpenc interface~symba_setup_pltpenc->proc~symba_setup_pltpenc setup_encounter setup_encounter proc~symba_setup_pltpenc->setup_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_setup_pltpenc(self, n) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-tp encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for","tags":"","loc":"interface/symba_setup_pltpenc.html"},{"title":"symba_setup_tp – swiftest","text":"interface Calls interface~~symba_setup_tp~~CallsGraph interface~symba_setup_tp symba_setup_tp proc~symba_setup_tp symba_setup_tp interface~symba_setup_tp->proc~symba_setup_tp setup_tp setup_tp proc~symba_setup_tp->setup_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter","tags":"","loc":"interface/symba_setup_tp.html"},{"title":"symba_step_system – swiftest","text":"interface Calls interface~~symba_step_system~~CallsGraph interface~symba_step_system symba_step_system proc~symba_step_system symba_step_system interface~symba_step_system->proc~symba_step_system helio_step_system helio_step_system proc~symba_step_system->helio_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"interface/symba_step_system.html"},{"title":"symba_step_interp_system – swiftest","text":"interface Calls interface~~symba_step_interp_system~~CallsGraph interface~symba_step_interp_system symba_step_interp_system proc~symba_step_interp_system symba_step_interp_system interface~symba_step_interp_system->proc~symba_step_interp_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_step_interp_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"interface/symba_step_interp_system.html"},{"title":"symba_step_set_recur_levels_system – swiftest","text":"interface Calls interface~~symba_step_set_recur_levels_system~~CallsGraph interface~symba_step_set_recur_levels_system symba_step_set_recur_levels_system proc~symba_step_set_recur_levels_system symba_step_set_recur_levels_system interface~symba_step_set_recur_levels_system->proc~symba_step_set_recur_levels_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_step_set_recur_levels_system(self, ireci) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system objec integer(kind=I4B), intent(in) :: ireci Input recursion level","tags":"","loc":"interface/symba_step_set_recur_levels_system.html"},{"title":"symba_step_recur_system – swiftest","text":"interface Calls interface~~symba_step_recur_system~~CallsGraph interface~symba_step_recur_system symba_step_recur_system proc~symba_step_recur_system symba_step_recur_system interface~symba_step_recur_system->proc~symba_step_recur_system util_exit util_exit proc~symba_step_recur_system->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public recursive module subroutine symba_step_recur_system(self, param, t, ireci) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), value :: t integer(kind=I4B), value :: ireci input recursion level","tags":"","loc":"interface/symba_step_recur_system.html"},{"title":"symba_step_reset_system – swiftest","text":"interface Calls interface~~symba_step_reset_system~~CallsGraph interface~symba_step_reset_system symba_step_reset_system proc~symba_step_reset_system symba_step_reset_system interface~symba_step_reset_system->proc~symba_step_reset_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_step_reset_system(self) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object","tags":"","loc":"interface/symba_step_reset_system.html"},{"title":"util_append – swiftest","text":"public interface util_append Called by interface~~util_append~~CalledByGraph interface~util_append util_append proc~symba_util_append_pl symba_util_append_pl proc~symba_util_append_pl->interface~util_append proc~symba_util_append_merger symba_util_append_merger proc~symba_util_append_merger->interface~util_append interface~symba_util_append_pl symba_util_append_pl proc~symba_util_append_merger->interface~symba_util_append_pl proc~symba_util_append_tp symba_util_append_tp proc~symba_util_append_tp->interface~util_append interface~symba_util_append_merger symba_util_append_merger interface~symba_util_append_merger->proc~symba_util_append_merger interface~symba_util_append_pl->proc~symba_util_append_pl interface~symba_util_append_tp symba_util_append_tp interface~symba_util_append_tp->proc~symba_util_append_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines symba_util_append_arr_info symba_util_append_arr_kin Subroutines public subroutine symba_util_append_arr_info(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name type( symba_particle_info ), intent(inout), dimension(:), allocatable :: arr Destination array type( symba_particle_info ), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to public subroutine symba_util_append_arr_kin(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: arr Destination array type( symba_kinship ), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/util_append.html"},{"title":"symba_util_append_merger – swiftest","text":"interface Calls interface~~symba_util_append_merger~~CallsGraph interface~symba_util_append_merger symba_util_append_merger proc~symba_util_append_merger symba_util_append_merger interface~symba_util_append_merger->proc~symba_util_append_merger interface~symba_util_append_pl symba_util_append_pl proc~symba_util_append_merger->interface~symba_util_append_pl interface~util_append util_append proc~symba_util_append_merger->interface~util_append util_exit util_exit proc~symba_util_append_merger->util_exit proc~symba_util_append_pl symba_util_append_pl interface~symba_util_append_pl->proc~symba_util_append_pl proc~symba_util_append_pl->interface~util_append proc~symba_util_append_pl->util_exit util_append_pl util_append_pl proc~symba_util_append_pl->util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_append_merger(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/symba_util_append_merger.html"},{"title":"symba_util_append_pl – swiftest","text":"interface Calls interface~~symba_util_append_pl~~CallsGraph interface~symba_util_append_pl symba_util_append_pl proc~symba_util_append_pl symba_util_append_pl interface~symba_util_append_pl->proc~symba_util_append_pl interface~util_append util_append proc~symba_util_append_pl->interface~util_append util_exit util_exit proc~symba_util_append_pl->util_exit util_append_pl util_append_pl proc~symba_util_append_pl->util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~symba_util_append_pl~~CalledByGraph interface~symba_util_append_pl symba_util_append_pl proc~symba_util_append_merger symba_util_append_merger proc~symba_util_append_merger->interface~symba_util_append_pl interface~symba_util_append_merger symba_util_append_merger interface~symba_util_append_merger->proc~symba_util_append_merger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/symba_util_append_pl.html"},{"title":"symba_util_append_tp – swiftest","text":"interface Calls interface~~symba_util_append_tp~~CallsGraph interface~symba_util_append_tp symba_util_append_tp proc~symba_util_append_tp symba_util_append_tp interface~symba_util_append_tp->proc~symba_util_append_tp interface~util_append util_append proc~symba_util_append_tp->interface~util_append util_append_tp util_append_tp proc~symba_util_append_tp->util_append_tp util_exit util_exit proc~symba_util_append_tp->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/symba_util_append_tp.html"},{"title":"util_fill – swiftest","text":"public interface util_fill Called by interface~~util_fill~~CalledByGraph interface~util_fill util_fill proc~symba_util_fill_pl symba_util_fill_pl proc~symba_util_fill_pl->interface~util_fill proc~symba_util_fill_tp symba_util_fill_tp proc~symba_util_fill_tp->interface~util_fill interface~symba_util_fill_tp symba_util_fill_tp interface~symba_util_fill_tp->proc~symba_util_fill_tp interface~symba_util_fill_pl symba_util_fill_pl interface~symba_util_fill_pl->proc~symba_util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines symba_util_fill_arr_info symba_util_fill_arr_kin Subroutines public subroutine symba_util_fill_arr_info(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name type( symba_particle_info ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_particle_info ), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public subroutine symba_util_fill_arr_kin(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_kinship ), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"interface/util_fill.html"},{"title":"symba_util_fill_pl – swiftest","text":"interface Calls interface~~symba_util_fill_pl~~CallsGraph interface~symba_util_fill_pl symba_util_fill_pl proc~symba_util_fill_pl symba_util_fill_pl interface~symba_util_fill_pl->proc~symba_util_fill_pl util_fill_pl util_fill_pl proc~symba_util_fill_pl->util_fill_pl interface~util_fill util_fill proc~symba_util_fill_pl->interface~util_fill util_exit util_exit proc~symba_util_fill_pl->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"interface/symba_util_fill_pl.html"},{"title":"symba_util_fill_tp – swiftest","text":"interface Calls interface~~symba_util_fill_tp~~CallsGraph interface~symba_util_fill_tp symba_util_fill_tp proc~symba_util_fill_tp symba_util_fill_tp interface~symba_util_fill_tp->proc~symba_util_fill_tp util_fill_tp util_fill_tp proc~symba_util_fill_tp->util_fill_tp interface~util_fill util_fill proc~symba_util_fill_tp->interface~util_fill util_exit util_exit proc~symba_util_fill_tp->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"interface/symba_util_fill_tp.html"},{"title":"symba_util_peri_pl – swiftest","text":"interface Calls interface~~symba_util_peri_pl~~CallsGraph interface~symba_util_peri_pl symba_util_peri_pl proc~symba_util_peri_pl symba_util_peri_pl interface~symba_util_peri_pl->proc~symba_util_peri_pl orbel_xv2aeq orbel_xv2aeq proc~symba_util_peri_pl->orbel_xv2aeq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_peri_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/symba_util_peri_pl.html"},{"title":"symba_util_rearray_pl – swiftest","text":"interface Calls interface~~symba_util_rearray_pl~~CallsGraph interface~symba_util_rearray_pl symba_util_rearray_pl proc~symba_util_rearray_pl symba_util_rearray_pl interface~symba_util_rearray_pl->proc~symba_util_rearray_pl interface~symba_io_dump_particle_info symba_io_dump_particle_info proc~symba_util_rearray_pl->interface~symba_io_dump_particle_info proc~symba_io_dump_particle_info symba_io_dump_particle_info interface~symba_io_dump_particle_info->proc~symba_io_dump_particle_info util_exit util_exit proc~symba_io_dump_particle_info->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_rearray_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions","tags":"","loc":"interface/symba_util_rearray_pl.html"},{"title":"util_resize – swiftest","text":"public interface util_resize Called by interface~~util_resize~~CalledByGraph interface~util_resize util_resize proc~symba_util_append_arr_info symba_util_append_arr_info proc~symba_util_append_arr_info->interface~util_resize proc~symba_util_resize_tp symba_util_resize_tp proc~symba_util_resize_tp->interface~util_resize proc~symba_util_resize_merger symba_util_resize_merger proc~symba_util_resize_merger->interface~util_resize interface~symba_util_resize_pl symba_util_resize_pl proc~symba_util_resize_merger->interface~symba_util_resize_pl proc~symba_util_resize_pl symba_util_resize_pl proc~symba_util_resize_pl->interface~util_resize proc~symba_util_append_arr_kin symba_util_append_arr_kin proc~symba_util_append_arr_kin->interface~util_resize interface~symba_util_resize_merger symba_util_resize_merger interface~symba_util_resize_merger->proc~symba_util_resize_merger interface~symba_util_resize_tp symba_util_resize_tp interface~symba_util_resize_tp->proc~symba_util_resize_tp interface~symba_util_resize_pl->proc~symba_util_resize_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines symba_util_resize_arr_info symba_util_resize_arr_kin Subroutines public subroutine symba_util_resize_arr_info(arr, nnew) Arguments Type Intent Optional Attributes Name type( symba_particle_info ), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size public subroutine symba_util_resize_arr_kin(arr, nnew) Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size","tags":"","loc":"interface/util_resize.html"},{"title":"symba_util_resize_merger – swiftest","text":"interface Calls interface~~symba_util_resize_merger~~CallsGraph interface~symba_util_resize_merger symba_util_resize_merger proc~symba_util_resize_merger symba_util_resize_merger interface~symba_util_resize_merger->proc~symba_util_resize_merger interface~symba_util_resize_pl symba_util_resize_pl proc~symba_util_resize_merger->interface~symba_util_resize_pl interface~util_resize util_resize proc~symba_util_resize_merger->interface~util_resize proc~symba_util_resize_pl symba_util_resize_pl interface~symba_util_resize_pl->proc~symba_util_resize_pl proc~symba_util_resize_pl->interface~util_resize util_resize_pl util_resize_pl proc~symba_util_resize_pl->util_resize_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_resize_merger(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA merger list object integer(kind=I4B), intent(in) :: nnew New size neded","tags":"","loc":"interface/symba_util_resize_merger.html"},{"title":"symba_util_resize_pl – swiftest","text":"interface Calls interface~~symba_util_resize_pl~~CallsGraph interface~symba_util_resize_pl symba_util_resize_pl proc~symba_util_resize_pl symba_util_resize_pl interface~symba_util_resize_pl->proc~symba_util_resize_pl util_resize_pl util_resize_pl proc~symba_util_resize_pl->util_resize_pl interface~util_resize util_resize proc~symba_util_resize_pl->interface~util_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~symba_util_resize_pl~~CalledByGraph interface~symba_util_resize_pl symba_util_resize_pl proc~symba_util_resize_merger symba_util_resize_merger proc~symba_util_resize_merger->interface~symba_util_resize_pl interface~symba_util_resize_merger symba_util_resize_merger interface~symba_util_resize_merger->proc~symba_util_resize_merger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: nnew New size neded","tags":"","loc":"interface/symba_util_resize_pl.html"},{"title":"symba_util_resize_tp – swiftest","text":"interface Calls interface~~symba_util_resize_tp~~CallsGraph interface~symba_util_resize_tp symba_util_resize_tp proc~symba_util_resize_tp symba_util_resize_tp interface~symba_util_resize_tp->proc~symba_util_resize_tp util_resize_tp util_resize_tp proc~symba_util_resize_tp->util_resize_tp interface~util_resize util_resize proc~symba_util_resize_tp->interface~util_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: nnew New size neded","tags":"","loc":"interface/symba_util_resize_tp.html"},{"title":"symba_util_sort_pl – swiftest","text":"interface Calls interface~~symba_util_sort_pl~~CallsGraph interface~symba_util_sort_pl symba_util_sort_pl proc~symba_util_sort_pl symba_util_sort_pl interface~symba_util_sort_pl->proc~symba_util_sort_pl util_sort_pl util_sort_pl proc~symba_util_sort_pl->util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order","tags":"","loc":"interface/symba_util_sort_pl.html"},{"title":"symba_util_sort_tp – swiftest","text":"interface Calls interface~~symba_util_sort_tp~~CallsGraph interface~symba_util_sort_tp symba_util_sort_tp proc~symba_util_sort_tp symba_util_sort_tp interface~symba_util_sort_tp->proc~symba_util_sort_tp util_sort_tp util_sort_tp proc~symba_util_sort_tp->util_sort_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order","tags":"","loc":"interface/symba_util_sort_tp.html"},{"title":"symba_util_sort_rearrange_pl – swiftest","text":"interface Calls interface~~symba_util_sort_rearrange_pl~~CallsGraph interface~symba_util_sort_rearrange_pl symba_util_sort_rearrange_pl proc~symba_util_sort_rearrange_pl symba_util_sort_rearrange_pl interface~symba_util_sort_rearrange_pl->proc~symba_util_sort_rearrange_pl util_sort_rearrange_pl util_sort_rearrange_pl proc~symba_util_sort_rearrange_pl->util_sort_rearrange_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order)","tags":"","loc":"interface/symba_util_sort_rearrange_pl.html"},{"title":"symba_util_sort_rearrange_tp – swiftest","text":"interface Calls interface~~symba_util_sort_rearrange_tp~~CallsGraph interface~symba_util_sort_rearrange_tp symba_util_sort_rearrange_tp proc~symba_util_sort_rearrange_tp symba_util_sort_rearrange_tp interface~symba_util_sort_rearrange_tp->proc~symba_util_sort_rearrange_tp util_sort_rearrange_tp util_sort_rearrange_tp proc~symba_util_sort_rearrange_tp->util_sort_rearrange_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order)","tags":"","loc":"interface/symba_util_sort_rearrange_tp.html"},{"title":"util_spill – swiftest","text":"public interface util_spill Called by interface~~util_spill~~CalledByGraph interface~util_spill util_spill proc~symba_util_spill_pltpenc symba_util_spill_pltpenc proc~symba_util_spill_pltpenc->interface~util_spill proc~symba_util_spill_pl symba_util_spill_pl proc~symba_util_spill_pl->interface~util_spill proc~symba_util_spill_tp symba_util_spill_tp proc~symba_util_spill_tp->interface~util_spill interface~symba_util_spill_pl symba_util_spill_pl interface~symba_util_spill_pl->proc~symba_util_spill_pl interface~symba_util_spill_tp symba_util_spill_tp interface~symba_util_spill_tp->proc~symba_util_spill_tp interface~symba_util_spill_pltpenc symba_util_spill_pltpenc interface~symba_util_spill_pltpenc->proc~symba_util_spill_pltpenc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines symba_util_spill_arr_info symba_util_spill_arr_kin Subroutines public subroutine symba_util_spill_arr_info(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name type( symba_particle_info ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_particle_info ), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine symba_util_spill_arr_kin(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_kinship ), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"interface/util_spill.html"},{"title":"symba_util_spill_pl – swiftest","text":"interface Calls interface~~symba_util_spill_pl~~CallsGraph interface~symba_util_spill_pl symba_util_spill_pl proc~symba_util_spill_pl symba_util_spill_pl interface~symba_util_spill_pl->proc~symba_util_spill_pl interface~util_spill util_spill proc~symba_util_spill_pl->interface~util_spill util_exit util_exit proc~symba_util_spill_pl->util_exit util_spill_pl util_spill_pl proc~symba_util_spill_pl->util_spill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"interface/symba_util_spill_pl.html"},{"title":"symba_util_spill_pltpenc – swiftest","text":"interface Calls interface~~symba_util_spill_pltpenc~~CallsGraph interface~symba_util_spill_pltpenc symba_util_spill_pltpenc proc~symba_util_spill_pltpenc symba_util_spill_pltpenc interface~symba_util_spill_pltpenc->proc~symba_util_spill_pltpenc interface~util_spill util_spill proc~symba_util_spill_pltpenc->interface~util_spill util_spill_encounter util_spill_encounter proc~symba_util_spill_pltpenc->util_spill_encounter util_exit util_exit proc~symba_util_spill_pltpenc->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_spill_pltpenc(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-tp encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list","tags":"","loc":"interface/symba_util_spill_pltpenc.html"},{"title":"symba_util_spill_tp – swiftest","text":"interface Calls interface~~symba_util_spill_tp~~CallsGraph interface~symba_util_spill_tp symba_util_spill_tp proc~symba_util_spill_tp symba_util_spill_tp interface~symba_util_spill_tp->proc~symba_util_spill_tp util_spill_tp util_spill_tp proc~symba_util_spill_tp->util_spill_tp interface~util_spill util_spill proc~symba_util_spill_tp->interface~util_spill util_exit util_exit proc~symba_util_spill_tp->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"interface/symba_util_spill_tp.html"},{"title":"io_get_args – swiftest","text":"interface Calls interface~~io_get_args~~CallsGraph interface~io_get_args io_get_args proc~io_get_args io_get_args interface~io_get_args->proc~io_get_args interface~util_version util_version proc~io_get_args->interface~util_version interface~io_toupper io_toupper proc~io_get_args->interface~io_toupper interface~util_exit util_exit proc~io_get_args->interface~util_exit proc~util_version util_version interface~util_version->proc~util_version proc~io_toupper io_toupper interface~io_toupper->proc~io_toupper proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function io_get_args(integrator, param_file_name) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=I4B) :: integrator Symbolic code of the requested integrator character(len=:), allocatable :: param_file_name Name of the input parameters file Return Value integer(kind=I4B) I/O error code","tags":"","loc":"interface/io_get_args.html"},{"title":"io_get_token – swiftest","text":"interface Calls interface~~io_get_token~~CallsGraph interface~io_get_token io_get_token proc~io_get_token io_get_token interface~io_get_token->proc~io_get_token Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~io_get_token~~CalledByGraph interface~io_get_token io_get_token proc~io_param_reader io_param_reader proc~io_param_reader->interface~io_get_token interface~io_param_reader io_param_reader interface~io_param_reader->proc~io_param_reader Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function io_get_token(buffer, ifirst, ilast, ierr) result(token) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: buffer Input string buffer integer(kind=I4B), intent(inout) :: ifirst Index of the buffer at which to start the search for a token integer(kind=I4B), intent(out) :: ilast Index of the buffer at the end of the returned token integer(kind=I4B), intent(out) :: ierr Error code Return Value character(len=:),\n  allocatable Returned token string","tags":"","loc":"interface/io_get_token.html"},{"title":"discard_pl – swiftest","text":"interface Calls interface~~discard_pl~~CallsGraph interface~discard_pl discard_pl proc~discard_pl discard_pl interface~discard_pl->proc~discard_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine discard_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameter","tags":"","loc":"interface/discard_pl.html"},{"title":"discard_system – swiftest","text":"interface Calls interface~~discard_system~~CallsGraph interface~discard_system discard_system proc~discard_system discard_system interface~discard_system->proc~discard_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine discard_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/discard_system.html"},{"title":"discard_tp – swiftest","text":"interface Calls interface~~discard_tp~~CallsGraph interface~discard_tp discard_tp proc~discard_tp discard_tp interface~discard_tp->proc~discard_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine discard_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/discard_tp.html"},{"title":"drift_all – swiftest","text":"interface Calls interface~~drift_all~~CallsGraph interface~drift_all drift_all proc~drift_all drift_all interface~drift_all->proc~drift_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~drift_all~~CalledByGraph interface~drift_all drift_all proc~drift_body drift_body proc~drift_body->interface~drift_all interface~drift_body drift_body interface~drift_body->proc~drift_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine drift_all(mu, x, v, n, param, dt, mask, iflag) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: mu Vector of gravitational constants real(kind=DP), intent(inout), dimension(:,:) :: x Position and velocity vectors real(kind=DP), intent(inout), dimension(:,:) :: v Position and velocity vectors integer(kind=I4B), intent(in) :: n number of bodies class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize logical, intent(in), dimension(:) :: mask Logical mask of size self%nbody that determines which bodies to drift. integer(kind=I4B), intent(out), dimension(:) :: iflag Vector of error flags. 0 means no problem","tags":"","loc":"interface/drift_all.html"},{"title":"drift_body – swiftest","text":"interface Calls interface~~drift_body~~CallsGraph interface~drift_body drift_body proc~drift_body drift_body interface~drift_body->proc~drift_body interface~drift_all drift_all proc~drift_body->interface~drift_all proc~drift_all drift_all interface~drift_all->proc~drift_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine drift_body(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"interface/drift_body.html"},{"title":"drift_one – swiftest","text":"interface Calls interface~~drift_one~~CallsGraph interface~drift_one drift_one proc~drift_one drift_one interface~drift_one->proc~drift_one Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure elemental module subroutine drift_one(mu, px, py, pz, vx, vy, vz, dt, iflag) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body to drift real(kind=DP), intent(inout) :: px Position and velocity of body to drift real(kind=DP), intent(inout) :: py Position and velocity of body to drift real(kind=DP), intent(inout) :: pz Position and velocity of body to drift real(kind=DP), intent(inout) :: vx Position and velocity of body to drift real(kind=DP), intent(inout) :: vy Position and velocity of body to drift real(kind=DP), intent(inout) :: vz Position and velocity of body to drift real(kind=DP), intent(in) :: dt Step size integer(kind=I4B), intent(out) :: iflag iflag : error status flag for Danby drift (0 = OK, nonzero = ERROR)","tags":"","loc":"interface/drift_one.html"},{"title":"eucl_dist_index_plpl – swiftest","text":"interface Calls interface~~eucl_dist_index_plpl~~CallsGraph interface~eucl_dist_index_plpl eucl_dist_index_plpl proc~eucl_dist_index_plpl eucl_dist_index_plpl interface~eucl_dist_index_plpl->proc~eucl_dist_index_plpl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine eucl_dist_index_plpl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object","tags":"","loc":"interface/eucl_dist_index_plpl.html"},{"title":"fragmentation_initialize – swiftest","text":"interface Calls interface~~fragmentation_initialize~~CallsGraph interface~fragmentation_initialize fragmentation_initialize proc~fragmentation_initialize fragmentation_initialize interface~fragmentation_initialize->proc~fragmentation_initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fragmentation_initialize(system, param, family, x, v, L_spin, Ip, mass, radius, nfrag, Ip_frag, m_frag, rad_frag, xb_frag, vb_frag, rot_frag, Qloss, lfailure) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters integer(kind=I4B), intent(in), dimension(:) :: family Index of bodies involved in the collision real(kind=DP), intent(inout), dimension(:,:) :: x Two-body equivalent position, vector, spin momentum, and rotational inertia values for the collision real(kind=DP), intent(inout), dimension(:,:) :: v Two-body equivalent position, vector, spin momentum, and rotational inertia values for the collision real(kind=DP), intent(inout), dimension(:,:) :: L_spin Two-body equivalent position, vector, spin momentum, and rotational inertia values for the collision real(kind=DP), intent(inout), dimension(:,:) :: Ip Two-body equivalent position, vector, spin momentum, and rotational inertia values for the collision real(kind=DP), intent(inout), dimension(:) :: mass Two-body equivalent mass and radii for the bodies in the collision real(kind=DP), intent(inout), dimension(:) :: radius Two-body equivalent mass and radii for the bodies in the collision integer(kind=I4B), intent(inout) :: nfrag Number of fragments to generate real(kind=DP), intent(inout), dimension(:,:), allocatable :: Ip_frag Fragment rotational inertia vectors real(kind=DP), intent(inout), dimension(:), allocatable :: m_frag Distribution of fragment mass and radii real(kind=DP), intent(inout), dimension(:), allocatable :: rad_frag Distribution of fragment mass and radii real(kind=DP), intent(inout), dimension(:,:), allocatable :: xb_frag Fragment barycentric position, barycentric velocity, and rotation vectors real(kind=DP), intent(inout), dimension(:,:), allocatable :: vb_frag Fragment barycentric position, barycentric velocity, and rotation vectors real(kind=DP), intent(inout), dimension(:,:), allocatable :: rot_frag Fragment barycentric position, barycentric velocity, and rotation vectors real(kind=DP), intent(inout) :: Qloss Energy lost during the collision logical, intent(out) :: lfailure Answers the question: Should this have been a merger instead?","tags":"","loc":"interface/fragmentation_initialize.html"},{"title":"fragmentation_regime – swiftest","text":"interface Calls interface~~fragmentation_regime~~CallsGraph interface~fragmentation_regime fragmentation_regime proc~fragmentation_regime fragmentation_regime interface~fragmentation_regime->proc~fragmentation_regime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fragmentation_regime(Mcb, m1, m2, rad1, rad2, xh1, xh2, vb1, vb2, den1, den2, regime, Mlr, Mslr, mtiny, Qloss) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: Mcb real(kind=DP), intent(in) :: m1 real(kind=DP), intent(in) :: m2 real(kind=DP), intent(in) :: rad1 real(kind=DP), intent(in) :: rad2 real(kind=DP), intent(in), dimension(:) :: xh1 real(kind=DP), intent(in), dimension(:) :: xh2 real(kind=DP), intent(in), dimension(:) :: vb1 real(kind=DP), intent(in), dimension(:) :: vb2 real(kind=DP), intent(in) :: den1 real(kind=DP), intent(in) :: den2 integer(kind=I4B), intent(out) :: regime real(kind=DP), intent(out) :: Mlr real(kind=DP), intent(out) :: Mslr real(kind=DP), intent(in) :: mtiny real(kind=DP), intent(out) :: Qloss Energy lost during the collision","tags":"","loc":"interface/fragmentation_regime.html"},{"title":"gr_kick_getaccb_ns_body – swiftest","text":"interface Calls interface~~gr_kick_getaccb_ns_body~~CallsGraph interface~gr_kick_getaccb_ns_body gr_kick_getaccb_ns_body proc~gr_kick_getaccb_ns_body gr_kick_getaccb_ns_body interface~gr_kick_getaccb_ns_body->proc~gr_kick_getaccb_ns_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine gr_kick_getaccb_ns_body(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/gr_kick_getaccb_ns_body.html"},{"title":"gr_kick_getacch – swiftest","text":"interface Calls interface~~gr_kick_getacch~~CallsGraph interface~gr_kick_getacch gr_kick_getacch proc~gr_kick_getacch gr_kick_getacch interface~gr_kick_getacch->proc~gr_kick_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine gr_kick_getacch(mu, x, lmask, n, inv_c2, agr) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:,:) :: x Position vectors logical, intent(in), dimension(:) :: lmask Logical mask indicating which bodies to compute integer(kind=I4B), intent(in) :: n Total number of bodies real(kind=DP), intent(in) :: inv_c2 Inverse speed of light squared: 1 / c**2 real(kind=DP), intent(out), dimension(:,:) :: agr Accelerations","tags":"","loc":"interface/gr_kick_getacch.html"},{"title":"gr_p4_pos_kick – swiftest","text":"interface Calls interface~~gr_p4_pos_kick~~CallsGraph interface~gr_p4_pos_kick gr_p4_pos_kick proc~gr_p4_pos_kick gr_p4_pos_kick interface~gr_p4_pos_kick->proc~gr_p4_pos_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine gr_p4_pos_kick(param, x, v, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(inout), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(in) :: dt Step size","tags":"","loc":"interface/gr_p4_pos_kick.html"},{"title":"gr_pseudovel2vel – swiftest","text":"interface Calls interface~~gr_pseudovel2vel~~CallsGraph interface~gr_pseudovel2vel gr_pseudovel2vel proc~gr_pseudovel2vel gr_pseudovel2vel interface~gr_pseudovel2vel->proc~gr_pseudovel2vel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine gr_pseudovel2vel(param, mu, xh, pv, vh) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real(kind=DP), intent(in), dimension(:) :: xh Heliocentric position vector real(kind=DP), intent(in), dimension(:) :: pv Pseudovelocity velocity vector - see Saha & Tremain (1994), eq. (32) real(kind=DP), intent(out), dimension(:) :: vh Heliocentric velocity vector","tags":"","loc":"interface/gr_pseudovel2vel.html"},{"title":"gr_pv2vh_body – swiftest","text":"interface Calls interface~~gr_pv2vh_body~~CallsGraph interface~gr_pv2vh_body gr_pv2vh_body proc~gr_pv2vh_body gr_pv2vh_body interface~gr_pv2vh_body->proc~gr_pv2vh_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/gr_pv2vh_body.html"},{"title":"gr_vel2pseudovel – swiftest","text":"interface Calls interface~~gr_vel2pseudovel~~CallsGraph interface~gr_vel2pseudovel gr_vel2pseudovel proc~gr_vel2pseudovel gr_vel2pseudovel interface~gr_vel2pseudovel->proc~gr_vel2pseudovel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine gr_vel2pseudovel(param, mu, xh, vh, pv) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real(kind=DP), intent(in), dimension(:) :: xh Heliocentric position vector real(kind=DP), intent(in), dimension(:) :: vh Heliocentric velocity vector real(kind=DP), intent(out), dimension(:) :: pv Pseudovelocity vector - see Saha & Tremain (1994), eq. (32)","tags":"","loc":"interface/gr_vel2pseudovel.html"},{"title":"gr_vh2pv_body – swiftest","text":"interface Calls interface~~gr_vh2pv_body~~CallsGraph interface~gr_vh2pv_body gr_vh2pv_body proc~gr_vh2pv_body gr_vh2pv_body interface~gr_vh2pv_body->proc~gr_vh2pv_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/gr_vh2pv_body.html"},{"title":"io_conservation_report – swiftest","text":"interface Calls interface~~io_conservation_report~~CallsGraph interface~io_conservation_report io_conservation_report proc~io_conservation_report io_conservation_report interface~io_conservation_report->proc~io_conservation_report ltot_orig ltot_orig proc~io_conservation_report->ltot_orig lescape lescape proc~io_conservation_report->lescape lorbit_orig lorbit_orig proc~io_conservation_report->lorbit_orig lspin_orig lspin_orig proc~io_conservation_report->lspin_orig Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_conservation_report(self, param, lterminal) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Input colleciton of user-defined parameters logical, intent(in) :: lterminal Indicates whether to output information to the terminal screen","tags":"","loc":"interface/io_conservation_report.html"},{"title":"io_dump_param – swiftest","text":"interface Calls interface~~io_dump_param~~CallsGraph interface~io_dump_param io_dump_param proc~io_dump_param io_dump_param interface~io_dump_param->proc~io_dump_param interface~util_exit util_exit proc~io_dump_param->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_dump_param(self, param_file_name) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Output collection of parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in)","tags":"","loc":"interface/io_dump_param.html"},{"title":"io_dump_swiftest – swiftest","text":"interface Calls interface~~io_dump_swiftest~~CallsGraph interface~io_dump_swiftest io_dump_swiftest proc~io_dump_swiftest io_dump_swiftest interface~io_dump_swiftest->proc~io_dump_swiftest interface~util_exit util_exit proc~io_dump_swiftest->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_dump_swiftest(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/io_dump_swiftest.html"},{"title":"io_dump_system – swiftest","text":"interface Calls interface~~io_dump_system~~CallsGraph interface~io_dump_system io_dump_system proc~io_dump_system io_dump_system interface~io_dump_system->proc~io_dump_system dump_param_file dump_param_file proc~io_dump_system->dump_param_file dump_cb_file dump_cb_file proc~io_dump_system->dump_cb_file dump_pl_file dump_pl_file proc~io_dump_system->dump_pl_file dump_tp_file dump_tp_file proc~io_dump_system->dump_tp_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_dump_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/io_dump_system.html"},{"title":"io_param_reader – swiftest","text":"interface Calls interface~~io_param_reader~~CallsGraph interface~io_param_reader io_param_reader proc~io_param_reader io_param_reader interface~io_param_reader->proc~io_param_reader interface~io_toupper io_toupper proc~io_param_reader->interface~io_toupper interface~io_get_token io_get_token proc~io_param_reader->interface~io_get_token proc~io_toupper io_toupper interface~io_toupper->proc~io_toupper proc~io_get_token io_get_token interface~io_get_token->proc~io_get_token Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_param_reader(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Collection of parameters integer(kind=I4B), intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer(kind=I4B), intent(in) :: v_list (:) The first element passes the integrator code to the reader integer(kind=I4B), intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0","tags":"","loc":"interface/io_param_reader.html"},{"title":"io_param_writer – swiftest","text":"interface Calls interface~~io_param_writer~~CallsGraph interface~io_param_writer io_param_writer proc~io_param_writer io_param_writer interface~io_param_writer->proc~io_param_writer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_param_writer(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Collection of parameters integer(kind=I4B), intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer(kind=I4B), intent(in) :: v_list (:) Not used in this procedure integer(kind=I4B), intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0","tags":"","loc":"interface/io_param_writer.html"},{"title":"io_read_body_in – swiftest","text":"interface Calls interface~~io_read_body_in~~CallsGraph interface~io_read_body_in io_read_body_in proc~io_read_body_in io_read_body_in interface~io_read_body_in->proc~io_read_body_in interface~util_exit util_exit proc~io_read_body_in->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_read_body_in(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/io_read_body_in.html"},{"title":"io_read_cb_in – swiftest","text":"interface Calls interface~~io_read_cb_in~~CallsGraph interface~io_read_cb_in io_read_cb_in proc~io_read_cb_in io_read_cb_in interface~io_read_cb_in->proc~io_read_cb_in interface~util_exit util_exit proc~io_read_cb_in->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_read_cb_in(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/io_read_cb_in.html"},{"title":"io_read_param_in – swiftest","text":"interface Calls interface~~io_read_param_in~~CallsGraph interface~io_read_param_in io_read_param_in proc~io_read_param_in io_read_param_in interface~io_read_param_in->proc~io_read_param_in interface~util_exit util_exit proc~io_read_param_in->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_read_param_in(self, param_file_name) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Current run configuration parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in)","tags":"","loc":"interface/io_read_param_in.html"},{"title":"io_read_frame_body – swiftest","text":"interface Calls interface~~io_read_frame_body~~CallsGraph interface~io_read_frame_body io_read_frame_body proc~io_read_frame_body io_read_frame_body interface~io_read_frame_body->proc~io_read_frame_body interface~util_exit util_exit proc~io_read_frame_body->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_read_frame_body(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code","tags":"","loc":"interface/io_read_frame_body.html"},{"title":"io_read_frame_cb – swiftest","text":"interface Calls interface~~io_read_frame_cb~~CallsGraph interface~io_read_frame_cb io_read_frame_cb proc~io_read_frame_cb io_read_frame_cb interface~io_read_frame_cb->proc~io_read_frame_cb interface~util_exit util_exit proc~io_read_frame_cb->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_read_frame_cb(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code","tags":"","loc":"interface/io_read_frame_cb.html"},{"title":"io_read_frame_system – swiftest","text":"interface Calls interface~~io_read_frame_system~~CallsGraph interface~io_read_frame_system io_read_frame_system proc~io_read_frame_system io_read_frame_system interface~io_read_frame_system->proc~io_read_frame_system proc~io_read_hdr io_read_hdr proc~io_read_frame_system->proc~io_read_hdr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_read_frame_system(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code","tags":"","loc":"interface/io_read_frame_system.html"},{"title":"io_write_discard – swiftest","text":"interface Calls interface~~io_write_discard~~CallsGraph interface~io_write_discard io_write_discard proc~io_write_discard io_write_discard interface~io_write_discard->proc~io_write_discard interface~util_exit util_exit proc~io_write_discard->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_write_discard(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/io_write_discard.html"},{"title":"io_toupper – swiftest","text":"interface Calls interface~~io_toupper~~CallsGraph interface~io_toupper io_toupper proc~io_toupper io_toupper interface~io_toupper->proc~io_toupper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~io_toupper~~CalledByGraph interface~io_toupper io_toupper proc~io_param_reader io_param_reader proc~io_param_reader->interface~io_toupper proc~io_get_args io_get_args proc~io_get_args->interface~io_toupper interface~io_param_reader io_param_reader interface~io_param_reader->proc~io_param_reader interface~io_get_args io_get_args interface~io_get_args->proc~io_get_args Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_toupper(string) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string String to make upper case","tags":"","loc":"interface/io_toupper.html"},{"title":"io_write_encounter – swiftest","text":"interface Calls interface~~io_write_encounter~~CallsGraph interface~io_write_encounter io_write_encounter proc~io_write_encounter io_write_encounter interface~io_write_encounter->proc~io_write_encounter interface~util_exit util_exit proc~io_write_encounter->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_write_encounter(t, name1, name2, mass1, mass2, radius1, radius2, xh1, xh2, vh1, vh2, enc_out, out_type) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: name1 integer(kind=I4B), intent(in) :: name2 real(kind=DP), intent(in) :: mass1 real(kind=DP), intent(in) :: mass2 real(kind=DP), intent(in) :: radius1 real(kind=DP), intent(in) :: radius2 real(kind=DP), intent(in), dimension(:) :: xh1 real(kind=DP), intent(in), dimension(:) :: xh2 real(kind=DP), intent(in), dimension(:) :: vh1 real(kind=DP), intent(in), dimension(:) :: vh2 character(len=*), intent(in) :: enc_out character(len=*), intent(in) :: out_type","tags":"","loc":"interface/io_write_encounter.html"},{"title":"io_write_frame_body – swiftest","text":"interface Calls interface~~io_write_frame_body~~CallsGraph interface~io_write_frame_body io_write_frame_body proc~io_write_frame_body io_write_frame_body interface~io_write_frame_body->proc~io_write_frame_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/io_write_frame_body.html"},{"title":"io_write_frame_cb – swiftest","text":"interface Calls interface~~io_write_frame_cb~~CallsGraph interface~io_write_frame_cb io_write_frame_cb proc~io_write_frame_cb io_write_frame_cb interface~io_write_frame_cb->proc~io_write_frame_cb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_write_frame_cb(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/io_write_frame_cb.html"},{"title":"io_write_frame_system – swiftest","text":"interface Calls interface~~io_write_frame_system~~CallsGraph interface~io_write_frame_system io_write_frame_system proc~io_write_frame_system io_write_frame_system interface~io_write_frame_system->proc~io_write_frame_system interface~util_exit util_exit proc~io_write_frame_system->interface~util_exit proc~io_write_hdr io_write_hdr proc~io_write_frame_system->proc~io_write_hdr proc~util_exit util_exit interface~util_exit->proc~util_exit proc~io_write_hdr->interface~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_write_frame_system(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/io_write_frame_system.html"},{"title":"kick_getacch_int_pl – swiftest","text":"interface Calls interface~~kick_getacch_int_pl~~CallsGraph interface~kick_getacch_int_pl kick_getacch_int_pl proc~kick_getacch_int_pl kick_getacch_int_pl interface~kick_getacch_int_pl->proc~kick_getacch_int_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine kick_getacch_int_pl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self","tags":"","loc":"interface/kick_getacch_int_pl.html"},{"title":"kick_getacch_int_tp – swiftest","text":"interface Calls interface~~kick_getacch_int_tp~~CallsGraph interface~kick_getacch_int_tp kick_getacch_int_tp proc~kick_getacch_int_tp kick_getacch_int_tp interface~kick_getacch_int_tp->proc~kick_getacch_int_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine kick_getacch_int_tp(self, GMpl, xhp, npl) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle real(kind=DP), intent(in), dimension(:) :: GMpl Massive body masses real(kind=DP), intent(in), dimension(:,:) :: xhp Massive body position vectors integer(kind=I4B), intent(in) :: npl Number of active massive bodies","tags":"","loc":"interface/kick_getacch_int_tp.html"},{"title":"obl_acc_body – swiftest","text":"interface Calls interface~~obl_acc_body~~CallsGraph interface~obl_acc_body obl_acc_body proc~obl_acc_body obl_acc_body interface~obl_acc_body->proc~obl_acc_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~obl_acc_body~~CalledByGraph interface~obl_acc_body obl_acc_body proc~obl_acc_tp obl_acc_tp proc~obl_acc_tp->interface~obl_acc_body proc~obl_acc_pl obl_acc_pl proc~obl_acc_pl->interface~obl_acc_body interface~obl_acc_pl obl_acc_pl interface~obl_acc_pl->proc~obl_acc_pl interface~obl_acc_tp obl_acc_tp interface~obl_acc_tp->proc~obl_acc_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine obl_acc_body(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object","tags":"","loc":"interface/obl_acc_body.html"},{"title":"obl_acc_pl – swiftest","text":"interface Calls interface~~obl_acc_pl~~CallsGraph interface~obl_acc_pl obl_acc_pl proc~obl_acc_pl obl_acc_pl interface~obl_acc_pl->proc~obl_acc_pl interface~obl_acc_body obl_acc_body proc~obl_acc_pl->interface~obl_acc_body proc~obl_acc_body obl_acc_body interface~obl_acc_body->proc~obl_acc_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine obl_acc_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object","tags":"","loc":"interface/obl_acc_pl.html"},{"title":"obl_acc_tp – swiftest","text":"interface Calls interface~~obl_acc_tp~~CallsGraph interface~obl_acc_tp obl_acc_tp proc~obl_acc_tp obl_acc_tp interface~obl_acc_tp->proc~obl_acc_tp interface~obl_acc_body obl_acc_body proc~obl_acc_tp->interface~obl_acc_body proc~obl_acc_body obl_acc_body interface~obl_acc_body->proc~obl_acc_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine obl_acc_tp(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object","tags":"","loc":"interface/obl_acc_tp.html"},{"title":"obl_pot – swiftest","text":"interface Calls interface~~obl_pot~~CallsGraph interface~obl_pot obl_pot proc~obl_pot obl_pot interface~obl_pot->proc~obl_pot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~obl_pot~~CalledByGraph interface~obl_pot obl_pot proc~util_get_energy_momentum_system util_get_energy_momentum_system proc~util_get_energy_momentum_system->interface~obl_pot interface~util_get_energy_momentum_system util_get_energy_momentum_system interface~util_get_energy_momentum_system->proc~util_get_energy_momentum_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine obl_pot(npl, Mcb, Mpl, j2rp2, j4rp4, xh, irh, oblpot) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl real(kind=DP), intent(in) :: Mcb real(kind=DP), intent(in), dimension(:) :: Mpl real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in), dimension(:, :) :: xh real(kind=DP), intent(in), dimension(:) :: irh real(kind=DP), intent(out) :: oblpot","tags":"","loc":"interface/obl_pot.html"},{"title":"orbel_el2xv_vec – swiftest","text":"interface Calls interface~~orbel_el2xv_vec~~CallsGraph interface~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv_vec->proc~orbel_el2xv proc~orbel_fhybrid orbel_fhybrid proc~orbel_el2xv->proc~orbel_fhybrid proc~orbel_ehybrid orbel_ehybrid proc~orbel_el2xv->proc~orbel_ehybrid proc~orbel_schget orbel_schget proc~orbel_el2xv->proc~orbel_schget interface~orbel_scget orbel_scget proc~orbel_el2xv->interface~orbel_scget proc~orbel_zget orbel_zget proc~orbel_el2xv->proc~orbel_zget proc~orbel_flon orbel_flon proc~orbel_fhybrid->proc~orbel_flon proc~orbel_fget orbel_fget proc~orbel_fhybrid->proc~orbel_fget proc~orbel_esolmd orbel_esolmd proc~orbel_ehybrid->proc~orbel_esolmd proc~orbel_ehie orbel_ehie proc~orbel_ehybrid->proc~orbel_ehie proc~orbel_eget orbel_eget proc~orbel_ehybrid->proc~orbel_eget proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget proc~orbel_esolmd->interface~orbel_scget proc~orbel_ehie->interface~orbel_scget 3 3 proc~orbel_flon->3 proc~orbel_eget->interface~orbel_scget proc~orbel_fget->proc~orbel_schget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/orbel_el2xv_vec.html"},{"title":"orbel_scget – swiftest","text":"interface Calls interface~~orbel_scget~~CallsGraph interface~orbel_scget orbel_scget proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~orbel_scget~~CalledByGraph interface~orbel_scget orbel_scget proc~orbel_esolmd orbel_esolmd proc~orbel_esolmd->interface~orbel_scget proc~orbel_ehie orbel_ehie proc~orbel_ehie->interface~orbel_scget proc~drift_kepu_guess drift_kepu_guess proc~drift_kepu_guess->interface~orbel_scget proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->interface~orbel_scget proc~orbel_ehybrid orbel_ehybrid proc~orbel_el2xv->proc~orbel_ehybrid proc~orbel_eget orbel_eget proc~orbel_eget->interface~orbel_scget proc~drift_kepu drift_kepu proc~drift_kepu->proc~drift_kepu_guess proc~orbel_ehybrid->proc~orbel_esolmd proc~orbel_ehybrid->proc~orbel_ehie proc~orbel_ehybrid->proc~orbel_eget proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec proc~drift_dan drift_dan proc~drift_dan->proc~drift_kepu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine orbel_scget(angle, sx, cx) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: angle real(kind=DP), intent(out) :: sx real(kind=DP), intent(out) :: cx","tags":"","loc":"interface/orbel_scget.html"},{"title":"orbel_xv2aeq – swiftest","text":"interface Calls interface~~orbel_xv2aeq~~CallsGraph interface~orbel_xv2aeq orbel_xv2aeq proc~orbel_xv2aeq orbel_xv2aeq interface~orbel_xv2aeq->proc~orbel_xv2aeq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~orbel_xv2aeq~~CalledByGraph interface~orbel_xv2aeq orbel_xv2aeq proc~util_peri_tp util_peri_tp proc~util_peri_tp->interface~orbel_xv2aeq interface~util_peri_tp util_peri_tp interface~util_peri_tp->proc~util_peri_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine orbel_xv2aeq(mu, x, v, a, e, q) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(out) :: a semimajor axis real(kind=DP), intent(out) :: e eccentricity real(kind=DP), intent(out) :: q periapsis","tags":"","loc":"interface/orbel_xv2aeq.html"},{"title":"orbel_xv2aqt – swiftest","text":"interface Calls interface~~orbel_xv2aqt~~CallsGraph interface~orbel_xv2aqt orbel_xv2aqt proc~orbel_xv2aqt orbel_xv2aqt interface~orbel_xv2aqt->proc~orbel_xv2aqt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine orbel_xv2aqt(mu, x, v, a, q, capm, tperi) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(out) :: a semimajor axis real(kind=DP), intent(out) :: q periapsis real(kind=DP), intent(out) :: capm mean anomaly real(kind=DP), intent(out) :: tperi time of pericenter passage","tags":"","loc":"interface/orbel_xv2aqt.html"},{"title":"orbel_xv2el_vec – swiftest","text":"interface Calls interface~~orbel_xv2el_vec~~CallsGraph interface~orbel_xv2el_vec orbel_xv2el_vec proc~orbel_xv2el_vec orbel_xv2el_vec interface~orbel_xv2el_vec->proc~orbel_xv2el_vec proc~orbel_xv2el orbel_xv2el proc~orbel_xv2el_vec->proc~orbel_xv2el Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/orbel_xv2el_vec.html"},{"title":"setup_body – swiftest","text":"interface Calls interface~~setup_body~~CallsGraph interface~setup_body setup_body proc~setup_body setup_body interface~setup_body->proc~setup_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~setup_body~~CalledByGraph interface~setup_body setup_body proc~setup_pl setup_pl proc~setup_pl->interface~setup_body proc~setup_tp setup_tp proc~setup_tp->interface~setup_body interface~setup_tp setup_tp interface~setup_tp->proc~setup_tp interface~setup_pl setup_pl interface~setup_pl->proc~setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine setup_body(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/setup_body.html"},{"title":"setup_construct_system – swiftest","text":"interface Calls interface~~setup_construct_system~~CallsGraph interface~setup_construct_system setup_construct_system proc~setup_construct_system setup_construct_system interface~setup_construct_system->proc~setup_construct_system interface~util_exit util_exit proc~setup_construct_system->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine setup_construct_system(system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout), allocatable :: system Swiftest system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/setup_construct_system.html"},{"title":"setup_encounter – swiftest","text":"interface Calls interface~~setup_encounter~~CallsGraph interface~setup_encounter setup_encounter proc~setup_encounter setup_encounter interface~setup_encounter->proc~setup_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine setup_encounter(self, n) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for","tags":"","loc":"interface/setup_encounter.html"},{"title":"setup_initialize_system – swiftest","text":"interface Calls interface~~setup_initialize_system~~CallsGraph interface~setup_initialize_system setup_initialize_system proc~setup_initialize_system setup_initialize_system interface~setup_initialize_system->proc~setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/setup_initialize_system.html"},{"title":"setup_pl – swiftest","text":"interface Calls interface~~setup_pl~~CallsGraph interface~setup_pl setup_pl proc~setup_pl setup_pl interface~setup_pl->proc~setup_pl interface~setup_body setup_body proc~setup_pl->interface~setup_body proc~setup_body setup_body interface~setup_body->proc~setup_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/setup_pl.html"},{"title":"setup_tp – swiftest","text":"interface Calls interface~~setup_tp~~CallsGraph interface~setup_tp setup_tp proc~setup_tp setup_tp interface~setup_tp->proc~setup_tp interface~setup_body setup_body proc~setup_tp->interface~setup_body proc~setup_body setup_body interface~setup_body->proc~setup_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parametersr","tags":"","loc":"interface/setup_tp.html"},{"title":"tides_kick_getacch_pl – swiftest","text":"interface Calls interface~~tides_kick_getacch_pl~~CallsGraph interface~tides_kick_getacch_pl tides_kick_getacch_pl proc~tides_kick_getacch_pl tides_kick_getacch_pl interface~tides_kick_getacch_pl->proc~tides_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine tides_kick_getacch_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object","tags":"","loc":"interface/tides_kick_getacch_pl.html"},{"title":"tides_step_spin_system – swiftest","text":"interface Calls interface~~tides_step_spin_system~~CallsGraph interface~tides_step_spin_system tides_step_spin_system proc~tides_step_spin_system tides_step_spin_system interface~tides_step_spin_system->proc~tides_step_spin_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine tides_step_spin_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"interface/tides_step_spin_system.html"},{"title":"user_kick_getacch_body – swiftest","text":"interface Calls interface~~user_kick_getacch_body~~CallsGraph interface~user_kick_getacch_body user_kick_getacch_body proc~user_kick_getacch_body user_kick_getacch_body interface~user_kick_getacch_body->proc~user_kick_getacch_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step","tags":"","loc":"interface/user_kick_getacch_body.html"},{"title":"util_append – swiftest","text":"public interface util_append Called by interface~~util_append~2~~CalledByGraph interface~util_append~2 util_append proc~util_append_pl util_append_pl proc~util_append_pl->interface~util_append~2 interface~util_append_body util_append_body proc~util_append_pl->interface~util_append_body proc~util_append_body util_append_body proc~util_append_body->interface~util_append~2 proc~util_append_tp util_append_tp proc~util_append_tp->interface~util_append~2 proc~util_append_tp->interface~util_append_body interface~util_append_body->proc~util_append_body interface~util_append_tp util_append_tp interface~util_append_tp->proc~util_append_tp interface~util_append_pl util_append_pl interface~util_append_pl->proc~util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines util_append_arr_char_string util_append_arr_DP util_append_arr_DPvec util_append_arr_I4B util_append_arr_logical Subroutines public subroutine util_append_arr_char_string(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: arr Destination array character(len=STRMAX), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to public subroutine util_append_arr_DP(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: arr Destination array real(kind=DP), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to public subroutine util_append_arr_DPvec(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: arr Destination array real(kind=DP), intent(in), dimension(:,:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to public subroutine util_append_arr_I4B(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to public subroutine util_append_arr_logical(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: arr Destination array logical, intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/util_append~2.html"},{"title":"util_append_body – swiftest","text":"interface Calls interface~~util_append_body~~CallsGraph interface~util_append_body util_append_body proc~util_append_body util_append_body interface~util_append_body->proc~util_append_body interface~util_append~2 util_append proc~util_append_body->interface~util_append~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~util_append_body~~CalledByGraph interface~util_append_body util_append_body proc~util_append_pl util_append_pl proc~util_append_pl->interface~util_append_body proc~util_append_tp util_append_tp proc~util_append_tp->interface~util_append_body interface~util_append_tp util_append_tp interface~util_append_tp->proc~util_append_tp interface~util_append_pl util_append_pl interface~util_append_pl->proc~util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_append_body(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/util_append_body.html"},{"title":"util_append_pl – swiftest","text":"interface Calls interface~~util_append_pl~~CallsGraph interface~util_append_pl util_append_pl proc~util_append_pl util_append_pl interface~util_append_pl->proc~util_append_pl interface~util_append_body util_append_body proc~util_append_pl->interface~util_append_body interface~util_append~2 util_append proc~util_append_pl->interface~util_append~2 interface~util_exit util_exit proc~util_append_pl->interface~util_exit proc~util_append_body util_append_body interface~util_append_body->proc~util_append_body proc~util_exit util_exit interface~util_exit->proc~util_exit proc~util_append_body->interface~util_append~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/util_append_pl.html"},{"title":"util_append_tp – swiftest","text":"interface Calls interface~~util_append_tp~~CallsGraph interface~util_append_tp util_append_tp proc~util_append_tp util_append_tp interface~util_append_tp->proc~util_append_tp interface~util_append_body util_append_body proc~util_append_tp->interface~util_append_body interface~util_append~2 util_append proc~util_append_tp->interface~util_append~2 interface~util_exit util_exit proc~util_append_tp->interface~util_exit proc~util_append_body util_append_body interface~util_append_body->proc~util_append_body proc~util_exit util_exit interface~util_exit->proc~util_exit proc~util_append_body->interface~util_append~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/util_append_tp.html"},{"title":"util_coord_b2h_pl – swiftest","text":"interface Calls interface~~util_coord_b2h_pl~~CallsGraph interface~util_coord_b2h_pl util_coord_b2h_pl proc~util_coord_b2h_pl util_coord_b2h_pl interface~util_coord_b2h_pl->proc~util_coord_b2h_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_coord_b2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/util_coord_b2h_pl.html"},{"title":"util_coord_b2h_tp – swiftest","text":"interface Calls interface~~util_coord_b2h_tp~~CallsGraph interface~util_coord_b2h_tp util_coord_b2h_tp proc~util_coord_b2h_tp util_coord_b2h_tp interface~util_coord_b2h_tp->proc~util_coord_b2h_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_coord_b2h_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object","tags":"","loc":"interface/util_coord_b2h_tp.html"},{"title":"util_coord_h2b_pl – swiftest","text":"interface Calls interface~~util_coord_h2b_pl~~CallsGraph interface~util_coord_h2b_pl util_coord_h2b_pl proc~util_coord_h2b_pl util_coord_h2b_pl interface~util_coord_h2b_pl->proc~util_coord_h2b_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_coord_h2b_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/util_coord_h2b_pl.html"},{"title":"util_coord_h2b_tp – swiftest","text":"interface Calls interface~~util_coord_h2b_tp~~CallsGraph interface~util_coord_h2b_tp util_coord_h2b_tp proc~util_coord_h2b_tp util_coord_h2b_tp interface~util_coord_h2b_tp->proc~util_coord_h2b_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_coord_h2b_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object","tags":"","loc":"interface/util_coord_h2b_tp.html"},{"title":"util_copy_encounter – swiftest","text":"interface Calls interface~~util_copy_encounter~~CallsGraph interface~util_copy_encounter util_copy_encounter proc~util_copy_encounter util_copy_encounter interface~util_copy_encounter->proc~util_copy_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_copy_encounter(self, source) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Encounter list class( swiftest_encounter ), intent(in) :: source Source object to copy into","tags":"","loc":"interface/util_copy_encounter.html"},{"title":"util_exit – swiftest","text":"interface Calls interface~~util_exit~~CallsGraph interface~util_exit util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~util_exit~~CalledByGraph interface~util_exit util_exit proc~io_write_frame_system io_write_frame_system proc~io_write_frame_system->interface~util_exit proc~io_write_hdr io_write_hdr proc~io_write_frame_system->proc~io_write_hdr proc~util_valid_id_system util_valid_id_system proc~util_valid_id_system->interface~util_exit proc~setup_construct_system setup_construct_system proc~setup_construct_system->interface~util_exit proc~io_read_body_in io_read_body_in proc~io_read_body_in->interface~util_exit proc~io_write_discard io_write_discard proc~io_write_discard->interface~util_exit proc~io_read_frame_cb io_read_frame_cb proc~io_read_frame_cb->interface~util_exit proc~util_append_pl util_append_pl proc~util_append_pl->interface~util_exit proc~util_solve_rkf45 util_solve_rkf45 proc~util_solve_rkf45->interface~util_exit proc~util_append_tp util_append_tp proc~util_append_tp->interface~util_exit proc~io_read_frame_body io_read_frame_body proc~io_read_frame_body->interface~util_exit proc~io_get_args io_get_args proc~io_get_args->interface~util_exit proc~io_read_encounter io_read_encounter proc~io_read_encounter->interface~util_exit proc~io_dump_swiftest io_dump_swiftest proc~io_dump_swiftest->interface~util_exit proc~io_read_param_in io_read_param_in proc~io_read_param_in->interface~util_exit proc~io_write_encounter io_write_encounter proc~io_write_encounter->interface~util_exit proc~io_dump_param io_dump_param proc~io_dump_param->interface~util_exit proc~io_read_cb_in io_read_cb_in proc~io_read_cb_in->interface~util_exit proc~io_write_hdr->interface~util_exit interface~io_dump_swiftest io_dump_swiftest interface~io_dump_swiftest->proc~io_dump_swiftest interface~util_append_tp util_append_tp interface~util_append_tp->proc~util_append_tp interface~io_read_frame_cb io_read_frame_cb interface~io_read_frame_cb->proc~io_read_frame_cb interface~util_append_pl util_append_pl interface~util_append_pl->proc~util_append_pl interface~io_get_args io_get_args interface~io_get_args->proc~io_get_args interface~io_read_body_in io_read_body_in interface~io_read_body_in->proc~io_read_body_in interface~io_write_discard io_write_discard interface~io_write_discard->proc~io_write_discard interface~io_write_encounter io_write_encounter interface~io_write_encounter->proc~io_write_encounter interface~util_solve_rkf45 util_solve_rkf45 interface~util_solve_rkf45->proc~util_solve_rkf45 interface~io_read_frame_body io_read_frame_body interface~io_read_frame_body->proc~io_read_frame_body interface~setup_construct_system setup_construct_system interface~setup_construct_system->proc~setup_construct_system interface~util_valid_id_system util_valid_id_system interface~util_valid_id_system->proc~util_valid_id_system interface~io_dump_param io_dump_param interface~io_dump_param->proc~io_dump_param interface~io_read_cb_in io_read_cb_in interface~io_read_cb_in->proc~io_read_cb_in interface~io_read_param_in io_read_param_in interface~io_read_param_in->proc~io_read_param_in interface~io_write_frame_system io_write_frame_system interface~io_write_frame_system->proc~io_write_frame_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_exit(code) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: code Failure exit code","tags":"","loc":"interface/util_exit.html"},{"title":"util_fill_body – swiftest","text":"interface Calls interface~~util_fill_body~~CallsGraph interface~util_fill_body util_fill_body proc~util_fill_body util_fill_body interface~util_fill_body->proc~util_fill_body interface~util_fill~2 util_fill proc~util_fill_body->interface~util_fill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~util_fill_body~~CalledByGraph interface~util_fill_body util_fill_body proc~util_fill_tp util_fill_tp proc~util_fill_tp->interface~util_fill_body proc~util_fill_pl util_fill_pl proc~util_fill_pl->interface~util_fill_body interface~util_fill_tp util_fill_tp interface~util_fill_tp->proc~util_fill_tp interface~util_fill_pl util_fill_pl interface~util_fill_pl->proc~util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_fill_body(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"interface/util_fill_body.html"},{"title":"util_fill_pl – swiftest","text":"interface Calls interface~~util_fill_pl~~CallsGraph interface~util_fill_pl util_fill_pl proc~util_fill_pl util_fill_pl interface~util_fill_pl->proc~util_fill_pl interface~util_fill_body util_fill_body proc~util_fill_pl->interface~util_fill_body interface~util_fill~2 util_fill proc~util_fill_pl->interface~util_fill~2 proc~util_fill_body util_fill_body interface~util_fill_body->proc~util_fill_body proc~util_fill_body->interface~util_fill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"interface/util_fill_pl.html"},{"title":"util_fill_tp – swiftest","text":"interface Calls interface~~util_fill_tp~~CallsGraph interface~util_fill_tp util_fill_tp proc~util_fill_tp util_fill_tp interface~util_fill_tp->proc~util_fill_tp interface~util_fill_body util_fill_body proc~util_fill_tp->interface~util_fill_body interface~util_fill~2 util_fill proc~util_fill_tp->interface~util_fill~2 proc~util_fill_body util_fill_body interface~util_fill_body->proc~util_fill_body proc~util_fill_body->interface~util_fill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"interface/util_fill_tp.html"},{"title":"util_fill – swiftest","text":"public interface util_fill Called by interface~~util_fill~2~~CalledByGraph interface~util_fill~2 util_fill proc~util_fill_body util_fill_body proc~util_fill_body->interface~util_fill~2 proc~util_fill_tp util_fill_tp proc~util_fill_tp->interface~util_fill~2 interface~util_fill_body util_fill_body proc~util_fill_tp->interface~util_fill_body proc~util_fill_pl util_fill_pl proc~util_fill_pl->interface~util_fill~2 proc~util_fill_pl->interface~util_fill_body interface~util_fill_body->proc~util_fill_body interface~util_fill_tp util_fill_tp interface~util_fill_tp->proc~util_fill_tp interface~util_fill_pl util_fill_pl interface~util_fill_pl->proc~util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines util_fill_arr_char_string util_fill_arr_DP util_fill_arr_DPvec util_fill_arr_I4B util_fill_arr_logical Subroutines public subroutine util_fill_arr_char_string(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: keeps Array of values to keep character(len=STRMAX), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public subroutine util_fill_arr_DP(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: keeps Array of values to keep real(kind=DP), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public subroutine util_fill_arr_DPvec(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: keeps Array of values to keep real(kind=DP), intent(in), dimension(:,:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public subroutine util_fill_arr_I4B(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: keeps Array of values to keep integer(kind=I4B), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public subroutine util_fill_arr_logical(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: keeps Array of values to keep logical, intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"interface/util_fill~2.html"},{"title":"util_minimize_bfgs – swiftest","text":"interface Calls interface~~util_minimize_bfgs~~CallsGraph interface~util_minimize_bfgs util_minimize_bfgs proc~util_minimize_bfgs util_minimize_bfgs interface~util_minimize_bfgs->proc~util_minimize_bfgs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function util_minimize_bfgs(f, N, x0, eps, lerr) result(x1) Implementation → Arguments Type Intent Optional Attributes Name class(lambda_obj), intent(inout) :: f integer(kind=I4B), intent(in) :: N real(kind=DP), intent(in), dimension(:) :: x0 real(kind=DP), intent(in) :: eps logical, intent(out) :: lerr Return Value real(kind=DP),\n  dimension(:),allocatable","tags":"","loc":"interface/util_minimize_bfgs.html"},{"title":"util_rescale_system – swiftest","text":"interface Calls interface~~util_rescale_system~~CallsGraph interface~util_rescale_system util_rescale_system proc~util_rescale_system util_rescale_system interface~util_rescale_system->proc~util_rescale_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_rescale_system(self, param, mscale, dscale, tscale) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters. Returns with new values of the scale vactors and GU real(kind=DP), intent(in) :: mscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: dscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: tscale Scale factors for mass, distance, and time units, respectively.","tags":"","loc":"interface/util_rescale_system.html"},{"title":"util_peri_tp – swiftest","text":"interface Calls interface~~util_peri_tp~~CallsGraph interface~util_peri_tp util_peri_tp proc~util_peri_tp util_peri_tp interface~util_peri_tp->proc~util_peri_tp interface~orbel_xv2aeq orbel_xv2aeq proc~util_peri_tp->interface~orbel_xv2aeq proc~orbel_xv2aeq orbel_xv2aeq interface~orbel_xv2aeq->proc~orbel_xv2aeq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_peri_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/util_peri_tp.html"},{"title":"util_resize – swiftest","text":"public interface util_resize Called by interface~~util_resize~2~~CalledByGraph interface~util_resize~2 util_resize proc~util_append_arr_logical util_append_arr_logical proc~util_append_arr_logical->interface~util_resize~2 proc~util_resize_body util_resize_body proc~util_resize_body->interface~util_resize~2 proc~util_append_arr_char_string util_append_arr_char_string proc~util_append_arr_char_string->interface~util_resize~2 proc~util_append_arr_dpvec util_append_arr_DPvec proc~util_append_arr_dpvec->interface~util_resize~2 proc~util_append_arr_dp util_append_arr_DP proc~util_append_arr_dp->interface~util_resize~2 proc~util_resize_tp util_resize_tp proc~util_resize_tp->interface~util_resize~2 interface~util_resize_body util_resize_body proc~util_resize_tp->interface~util_resize_body proc~util_resize_pl util_resize_pl proc~util_resize_pl->interface~util_resize~2 proc~util_resize_pl->interface~util_resize_body proc~util_append_arr_i4b util_append_arr_I4B proc~util_append_arr_i4b->interface~util_resize~2 interface~util_resize_body->proc~util_resize_body interface~util_resize_pl util_resize_pl interface~util_resize_pl->proc~util_resize_pl interface~util_resize_tp util_resize_tp interface~util_resize_tp->proc~util_resize_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines util_resize_arr_char_string util_resize_arr_DP util_resize_arr_DPvec util_resize_arr_I4B util_resize_arr_logical Subroutines public subroutine util_resize_arr_char_string(arr, nnew) Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size public subroutine util_resize_arr_DP(arr, nnew) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size public subroutine util_resize_arr_DPvec(arr, nnew) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size public subroutine util_resize_arr_I4B(arr, nnew) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size public subroutine util_resize_arr_logical(arr, nnew) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size","tags":"","loc":"interface/util_resize~2.html"},{"title":"util_resize_body – swiftest","text":"interface Calls interface~~util_resize_body~~CallsGraph interface~util_resize_body util_resize_body proc~util_resize_body util_resize_body interface~util_resize_body->proc~util_resize_body interface~util_resize~2 util_resize proc~util_resize_body->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~util_resize_body~~CalledByGraph interface~util_resize_body util_resize_body proc~util_resize_tp util_resize_tp proc~util_resize_tp->interface~util_resize_body proc~util_resize_pl util_resize_pl proc~util_resize_pl->interface~util_resize_body interface~util_resize_pl util_resize_pl interface~util_resize_pl->proc~util_resize_pl interface~util_resize_tp util_resize_tp interface~util_resize_tp->proc~util_resize_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_resize_body(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in) :: nnew New size neded","tags":"","loc":"interface/util_resize_body.html"},{"title":"util_resize_encounter – swiftest","text":"interface Calls interface~~util_resize_encounter~~CallsGraph interface~util_resize_encounter util_resize_encounter proc~util_resize_encounter util_resize_encounter interface~util_resize_encounter->proc~util_resize_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_resize_encounter(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list integer(kind=I4B), intent(in) :: nnew New size of list needed","tags":"","loc":"interface/util_resize_encounter.html"},{"title":"util_resize_pl – swiftest","text":"interface Calls interface~~util_resize_pl~~CallsGraph interface~util_resize_pl util_resize_pl proc~util_resize_pl util_resize_pl interface~util_resize_pl->proc~util_resize_pl interface~util_resize_body util_resize_body proc~util_resize_pl->interface~util_resize_body interface~util_resize~2 util_resize proc~util_resize_pl->interface~util_resize~2 proc~util_resize_body util_resize_body interface~util_resize_body->proc~util_resize_body proc~util_resize_body->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: nnew New size neded","tags":"","loc":"interface/util_resize_pl.html"},{"title":"util_resize_tp – swiftest","text":"interface Calls interface~~util_resize_tp~~CallsGraph interface~util_resize_tp util_resize_tp proc~util_resize_tp util_resize_tp interface~util_resize_tp->proc~util_resize_tp interface~util_resize_body util_resize_body proc~util_resize_tp->interface~util_resize_body interface~util_resize~2 util_resize proc~util_resize_tp->interface~util_resize~2 proc~util_resize_body util_resize_body interface~util_resize_body->proc~util_resize_body proc~util_resize_body->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: nnew New size neded","tags":"","loc":"interface/util_resize_tp.html"},{"title":"util_get_energy_momentum_system – swiftest","text":"interface Calls interface~~util_get_energy_momentum_system~~CallsGraph interface~util_get_energy_momentum_system util_get_energy_momentum_system proc~util_get_energy_momentum_system util_get_energy_momentum_system interface~util_get_energy_momentum_system->proc~util_get_energy_momentum_system px px proc~util_get_energy_momentum_system->px py py proc~util_get_energy_momentum_system->py indj indj proc~util_get_energy_momentum_system->indj indi indi proc~util_get_energy_momentum_system->indi interface~obl_pot obl_pot proc~util_get_energy_momentum_system->interface~obl_pot pz pz proc~util_get_energy_momentum_system->pz proc~obl_pot obl_pot interface~obl_pot->proc~obl_pot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_get_energy_momentum_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/util_get_energy_momentum_system.html"},{"title":"util_set_beg_end_pl – swiftest","text":"interface Calls interface~~util_set_beg_end_pl~~CallsGraph interface~util_set_beg_end_pl util_set_beg_end_pl proc~util_set_beg_end_pl util_set_beg_end_pl interface~util_set_beg_end_pl->proc~util_set_beg_end_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_set_beg_end_pl(self, xbeg, xend, vbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object real(kind=DP), intent(in), optional dimension(:,:) :: xbeg Position vectors at beginning of step real(kind=DP), intent(in), optional dimension(:,:) :: xend Positions vectors at end of step real(kind=DP), intent(in), optional dimension(:,:) :: vbeg vbeg is an unused variable to keep this method forward compatible with RMVS","tags":"","loc":"interface/util_set_beg_end_pl.html"},{"title":"util_set_ir3h – swiftest","text":"interface Calls interface~~util_set_ir3h~~CallsGraph interface~util_set_ir3h util_set_ir3h proc~util_set_ir3h util_set_ir3h interface~util_set_ir3h->proc~util_set_ir3h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object","tags":"","loc":"interface/util_set_ir3h.html"},{"title":"util_set_msys – swiftest","text":"interface Calls interface~~util_set_msys~~CallsGraph interface~util_set_msys util_set_msys proc~util_set_msys util_set_msys interface~util_set_msys->proc~util_set_msys Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_set_msys(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object","tags":"","loc":"interface/util_set_msys.html"},{"title":"util_set_mu_pl – swiftest","text":"interface Calls interface~~util_set_mu_pl~~CallsGraph interface~util_set_mu_pl util_set_mu_pl proc~util_set_mu_pl util_set_mu_pl interface~util_set_mu_pl->proc~util_set_mu_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_set_mu_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/util_set_mu_pl.html"},{"title":"util_set_mu_tp – swiftest","text":"interface Calls interface~~util_set_mu_tp~~CallsGraph interface~util_set_mu_tp util_set_mu_tp proc~util_set_mu_tp util_set_mu_tp interface~util_set_mu_tp->proc~util_set_mu_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_set_mu_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/util_set_mu_tp.html"},{"title":"util_set_rhill – swiftest","text":"interface Calls interface~~util_set_rhill~~CallsGraph interface~util_set_rhill util_set_rhill proc~util_set_rhill util_set_rhill interface~util_set_rhill->proc~util_set_rhill Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_set_rhill(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/util_set_rhill.html"},{"title":"util_set_rhill_approximate – swiftest","text":"interface Calls interface~~util_set_rhill_approximate~~CallsGraph interface~util_set_rhill_approximate util_set_rhill_approximate proc~util_set_rhill_approximate util_set_rhill_approximate interface~util_set_rhill_approximate->proc~util_set_rhill_approximate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_set_rhill_approximate(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/util_set_rhill_approximate.html"},{"title":"util_solve_linear_system – swiftest","text":"public interface util_solve_linear_system Contents Functions util_solve_linear_system_d util_solve_linear_system_q Functions public function util_solve_linear_system_d(A, b, n, lerr) result(x) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A real(kind=DP), intent(in), dimension(:) :: b integer(kind=I4B), intent(in) :: n logical, intent(out) :: lerr Return Value real(kind=DP),\n  dimension(n) public function util_solve_linear_system_q(A, b, n, lerr) result(x) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A real(kind=QP), intent(in), dimension(:) :: b integer(kind=I4B), intent(in) :: n logical, intent(out) :: lerr Return Value real(kind=QP),\n  dimension(n)","tags":"","loc":"interface/util_solve_linear_system.html"},{"title":"util_solve_rkf45 – swiftest","text":"interface Calls interface~~util_solve_rkf45~~CallsGraph interface~util_solve_rkf45 util_solve_rkf45 proc~util_solve_rkf45 util_solve_rkf45 interface~util_solve_rkf45->proc~util_solve_rkf45 interface~util_exit util_exit proc~util_solve_rkf45->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function util_solve_rkf45(f, y0in, t1, dt0, tol) result(y1) Implementation → Arguments Type Intent Optional Attributes Name class(lambda_obj), intent(inout) :: f lambda function object that has been initialized to be a function of derivatives. The object will return with components lastarg and lasteval set real(kind=DP), intent(in), dimension(:) :: y0in Initial value at t=0 real(kind=DP), intent(in) :: t1 Final time real(kind=DP), intent(in) :: dt0 Initial step size guess real(kind=DP), intent(in) :: tol Tolerance on solution Return Value real(kind=DP),\n  dimension(:),allocatable Final result","tags":"","loc":"interface/util_solve_rkf45.html"},{"title":"util_sort – swiftest","text":"public interface util_sort Called by interface~~util_sort~~CalledByGraph interface~util_sort util_sort proc~util_valid_id_system util_valid_id_system proc~util_valid_id_system->interface~util_sort interface~util_valid_id_system util_valid_id_system interface~util_valid_id_system->proc~util_valid_id_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines util_sort_i4b util_sort_index_i4b util_sort_sp util_sort_index_sp util_sort_dp util_sort_index_dp Subroutines public subroutine util_sort_i4b(arr) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:) :: arr public subroutine util_sort_index_i4b(arr, ind) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind public subroutine util_sort_sp(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), dimension(:) :: arr public subroutine util_sort_index_sp(arr, ind) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind public subroutine util_sort_dp(arr) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:) :: arr public subroutine util_sort_index_dp(arr, ind) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind","tags":"","loc":"interface/util_sort.html"},{"title":"util_sort_rearrange_body – swiftest","text":"interface Calls interface~~util_sort_rearrange_body~~CallsGraph interface~util_sort_rearrange_body util_sort_rearrange_body proc~util_sort_rearrange_body util_sort_rearrange_body interface~util_sort_rearrange_body->proc~util_sort_rearrange_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~util_sort_rearrange_body~~CalledByGraph interface~util_sort_rearrange_body util_sort_rearrange_body proc~util_sort_rearrange_pl util_sort_rearrange_pl proc~util_sort_rearrange_pl->interface~util_sort_rearrange_body proc~util_sort_rearrange_tp util_sort_rearrange_tp proc~util_sort_rearrange_tp->interface~util_sort_rearrange_body interface~util_sort_rearrange_pl util_sort_rearrange_pl interface~util_sort_rearrange_pl->proc~util_sort_rearrange_pl interface~util_sort_rearrange_tp util_sort_rearrange_tp interface~util_sort_rearrange_tp->proc~util_sort_rearrange_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_sort_rearrange_body(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order)","tags":"","loc":"interface/util_sort_rearrange_body.html"},{"title":"util_sort_rearrange_pl – swiftest","text":"interface Calls interface~~util_sort_rearrange_pl~~CallsGraph interface~util_sort_rearrange_pl util_sort_rearrange_pl proc~util_sort_rearrange_pl util_sort_rearrange_pl interface~util_sort_rearrange_pl->proc~util_sort_rearrange_pl interface~util_sort_rearrange_body util_sort_rearrange_body proc~util_sort_rearrange_pl->interface~util_sort_rearrange_body proc~util_sort_rearrange_body util_sort_rearrange_body interface~util_sort_rearrange_body->proc~util_sort_rearrange_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order)","tags":"","loc":"interface/util_sort_rearrange_pl.html"},{"title":"util_sort_rearrange_tp – swiftest","text":"interface Calls interface~~util_sort_rearrange_tp~~CallsGraph interface~util_sort_rearrange_tp util_sort_rearrange_tp proc~util_sort_rearrange_tp util_sort_rearrange_tp interface~util_sort_rearrange_tp->proc~util_sort_rearrange_tp interface~util_sort_rearrange_body util_sort_rearrange_body proc~util_sort_rearrange_tp->interface~util_sort_rearrange_body proc~util_sort_rearrange_body util_sort_rearrange_body interface~util_sort_rearrange_body->proc~util_sort_rearrange_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order)","tags":"","loc":"interface/util_sort_rearrange_tp.html"},{"title":"util_sort_body – swiftest","text":"interface Calls interface~~util_sort_body~~CallsGraph interface~util_sort_body util_sort_body proc~util_sort_body util_sort_body interface~util_sort_body->proc~util_sort_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~util_sort_body~~CalledByGraph interface~util_sort_body util_sort_body proc~util_sort_tp util_sort_tp proc~util_sort_tp->interface~util_sort_body proc~util_sort_pl util_sort_pl proc~util_sort_pl->interface~util_sort_body interface~util_sort_pl util_sort_pl interface~util_sort_pl->proc~util_sort_pl interface~util_sort_tp util_sort_tp interface~util_sort_tp->proc~util_sort_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_sort_body(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order","tags":"","loc":"interface/util_sort_body.html"},{"title":"util_sort_pl – swiftest","text":"interface Calls interface~~util_sort_pl~~CallsGraph interface~util_sort_pl util_sort_pl proc~util_sort_pl util_sort_pl interface~util_sort_pl->proc~util_sort_pl interface~util_sort_body util_sort_body proc~util_sort_pl->interface~util_sort_body proc~util_sort_body util_sort_body interface~util_sort_body->proc~util_sort_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order","tags":"","loc":"interface/util_sort_pl.html"},{"title":"util_sort_tp – swiftest","text":"interface Calls interface~~util_sort_tp~~CallsGraph interface~util_sort_tp util_sort_tp proc~util_sort_tp util_sort_tp interface~util_sort_tp->proc~util_sort_tp interface~util_sort_body util_sort_body proc~util_sort_tp->interface~util_sort_body proc~util_sort_body util_sort_body interface~util_sort_body->proc~util_sort_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order","tags":"","loc":"interface/util_sort_tp.html"},{"title":"util_spill – swiftest","text":"public interface util_spill Called by interface~~util_spill~2~~CalledByGraph interface~util_spill~2 util_spill proc~util_spill_encounter util_spill_encounter proc~util_spill_encounter->interface~util_spill~2 proc~util_spill_tp util_spill_tp proc~util_spill_tp->interface~util_spill~2 interface~util_spill_body util_spill_body proc~util_spill_tp->interface~util_spill_body proc~util_spill_body util_spill_body proc~util_spill_body->interface~util_spill~2 proc~util_spill_pl util_spill_pl proc~util_spill_pl->interface~util_spill~2 proc~util_spill_pl->interface~util_spill_body interface~util_spill_pl util_spill_pl interface~util_spill_pl->proc~util_spill_pl interface~util_spill_body->proc~util_spill_body interface~util_spill_encounter util_spill_encounter interface~util_spill_encounter->proc~util_spill_encounter interface~util_spill_tp util_spill_tp interface~util_spill_tp->proc~util_spill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines util_spill_arr_char_string util_spill_arr_DP util_spill_arr_DPvec util_spill_arr_I4B util_spill_arr_logical Subroutines public subroutine util_spill_arr_char_string(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: keeps Array of values to keep character(len=STRMAX), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine util_spill_arr_DP(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: keeps Array of values to keep real(kind=DP), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine util_spill_arr_DPvec(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: keeps Array of values to keep real(kind=DP), intent(inout), dimension(:,:), allocatable :: discards Array discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine util_spill_arr_I4B(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: keeps Array of values to keep integer(kind=I4B), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine util_spill_arr_logical(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: keeps Array of values to keep logical, intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"interface/util_spill~2.html"},{"title":"util_spill_body – swiftest","text":"interface Calls interface~~util_spill_body~~CallsGraph interface~util_spill_body util_spill_body proc~util_spill_body util_spill_body interface~util_spill_body->proc~util_spill_body interface~util_spill~2 util_spill proc~util_spill_body->interface~util_spill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~util_spill_body~~CalledByGraph interface~util_spill_body util_spill_body proc~util_spill_tp util_spill_tp proc~util_spill_tp->interface~util_spill_body proc~util_spill_pl util_spill_pl proc~util_spill_pl->interface~util_spill_body interface~util_spill_pl util_spill_pl interface~util_spill_pl->proc~util_spill_pl interface~util_spill_tp util_spill_tp interface~util_spill_tp->proc~util_spill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_spill_body(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"interface/util_spill_body.html"},{"title":"util_spill_encounter – swiftest","text":"interface Calls interface~~util_spill_encounter~~CallsGraph interface~util_spill_encounter util_spill_encounter proc~util_spill_encounter util_spill_encounter interface~util_spill_encounter->proc~util_spill_encounter interface~util_spill~2 util_spill proc~util_spill_encounter->interface~util_spill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_spill_encounter(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list","tags":"","loc":"interface/util_spill_encounter.html"},{"title":"util_spill_pl – swiftest","text":"interface Calls interface~~util_spill_pl~~CallsGraph interface~util_spill_pl util_spill_pl proc~util_spill_pl util_spill_pl interface~util_spill_pl->proc~util_spill_pl interface~util_spill~2 util_spill proc~util_spill_pl->interface~util_spill~2 interface~util_spill_body util_spill_body proc~util_spill_pl->interface~util_spill_body proc~util_spill_body util_spill_body interface~util_spill_body->proc~util_spill_body proc~util_spill_body->interface~util_spill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"interface/util_spill_pl.html"},{"title":"util_spill_tp – swiftest","text":"interface Calls interface~~util_spill_tp~~CallsGraph interface~util_spill_tp util_spill_tp proc~util_spill_tp util_spill_tp interface~util_spill_tp->proc~util_spill_tp interface~util_spill~2 util_spill proc~util_spill_tp->interface~util_spill~2 interface~util_spill_body util_spill_body proc~util_spill_tp->interface~util_spill_body proc~util_spill_body util_spill_body interface~util_spill_body->proc~util_spill_body proc~util_spill_body->interface~util_spill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"interface/util_spill_tp.html"},{"title":"util_valid_id_system – swiftest","text":"interface Calls interface~~util_valid_id_system~~CallsGraph interface~util_valid_id_system util_valid_id_system proc~util_valid_id_system util_valid_id_system interface~util_valid_id_system->proc~util_valid_id_system interface~util_sort util_sort proc~util_valid_id_system->interface~util_sort interface~util_exit util_exit proc~util_valid_id_system->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_valid_id_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/util_valid_id_system.html"},{"title":"util_version – swiftest","text":"interface Calls interface~~util_version~~CallsGraph interface~util_version util_version proc~util_version util_version interface~util_version->proc~util_version Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~util_version~~CalledByGraph interface~util_version util_version proc~io_get_args io_get_args proc~io_get_args->interface~util_version interface~io_get_args io_get_args interface~io_get_args->proc~io_get_args Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_version() Implementation → Arguments None","tags":"","loc":"interface/util_version.html"},{"title":"lambda_init_0 – swiftest","text":"public function lambda_init_0(lambda) Arguments Type Intent Optional Attributes Name procedure( lambda0 ) :: lambda Return Value type( lambda_obj ) Called by proc~~lambda_init_0~~CalledByGraph proc~lambda_init_0 lambda_init_0 interface~lambda_obj~2 lambda_obj interface~lambda_obj~2->proc~lambda_init_0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lambda_init_0.html"},{"title":"lambda_init_0_err – swiftest","text":"public function lambda_init_0_err(lambda, lerr) Arguments Type Intent Optional Attributes Name procedure( lambda0err ) :: lambda logical, intent(in) :: lerr Return Value type( lambda_obj_err ) Called by proc~~lambda_init_0_err~~CalledByGraph proc~lambda_init_0_err lambda_init_0_err interface~lambda_obj~2 lambda_obj interface~lambda_obj~2->proc~lambda_init_0_err Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lambda_init_0_err.html"},{"title":"lambda_init_tvar – swiftest","text":"public function lambda_init_tvar(lambda, t) Arguments Type Intent Optional Attributes Name procedure( lambda0tvar ) :: lambda real(kind=DP), intent(in) :: t Return Value type( lambda_obj_tvar ) Called by proc~~lambda_init_tvar~~CalledByGraph proc~lambda_init_tvar lambda_init_tvar interface~lambda_obj~2 lambda_obj interface~lambda_obj~2->proc~lambda_init_tvar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lambda_init_tvar.html"},{"title":"lambda_eval_0 – swiftest","text":"public function lambda_eval_0(self, x) result(y) Arguments Type Intent Optional Attributes Name class( lambda_obj ), intent(inout) :: self real(kind=DP), intent(in), dimension(:) :: x Return Value real(kind=DP) Contents None","tags":"","loc":"proc/lambda_eval_0.html"},{"title":"lambda_eval_0_err – swiftest","text":"public function lambda_eval_0_err(self, x) result(y) Arguments Type Intent Optional Attributes Name class( lambda_obj_err ), intent(inout) :: self real(kind=DP), intent(in), dimension(:) :: x Return Value real(kind=DP) Contents None","tags":"","loc":"proc/lambda_eval_0_err.html"},{"title":"lambda_eval_tvar – swiftest","text":"public function lambda_eval_tvar(self, x, t) result(y) Arguments Type Intent Optional Attributes Name class( lambda_obj_tvar ), intent(inout) :: self real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in) :: t Return Value real(kind=DP),\n  dimension(:),allocatable Contents None","tags":"","loc":"proc/lambda_eval_tvar.html"},{"title":"lambda_destroy – swiftest","text":"public subroutine lambda_destroy(self) Arguments Type Intent Optional Attributes Name type( lambda_obj ) :: self Contents None","tags":"","loc":"proc/lambda_destroy.html"},{"title":"lambda_obj – swiftest","text":"public interface lambda_obj Calls interface~~lambda_obj~2~~CallsGraph interface~lambda_obj~2 lambda_obj proc~lambda_init_0_err lambda_init_0_err interface~lambda_obj~2->proc~lambda_init_0_err proc~lambda_init_tvar lambda_init_tvar interface~lambda_obj~2->proc~lambda_init_tvar proc~lambda_init_0 lambda_init_0 interface~lambda_obj~2->proc~lambda_init_0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures lambda_init_0 lambda_init_0_err lambda_init_tvar Module Procedures public function lambda_init_0 (lambda) Arguments Type Intent Optional Attributes Name procedure( lambda0 ) :: lambda Return Value type( lambda_obj ) public function lambda_init_0_err (lambda, lerr) Arguments Type Intent Optional Attributes Name procedure( lambda0err ) :: lambda logical, intent(in) :: lerr Return Value type( lambda_obj_err ) public function lambda_init_tvar (lambda, t) Arguments Type Intent Optional Attributes Name procedure( lambda0tvar ) :: lambda real(kind=DP), intent(in) :: t Return Value type( lambda_obj_tvar )","tags":"","loc":"interface/lambda_obj~2.html"},{"title":"rmvs_interp_out – swiftest","text":"subroutine rmvs_interp_out(cb, pl, dt) Interpolate planet positions between two Keplerian orbits in outer encounter region Adapted from David E. Kaufmann's Swifter routine rmvs_interp_out.f90 Adapted from Hal Levison's Swift routine rmvs3_interp.f Arguments Type Intent Optional Attributes Name class( rmvs_cb ), intent(inout) :: cb RMVS central body object class( rmvs_pl ), intent(inout) :: pl RMVS massive body object real(kind=DP), intent(in) :: dt Step size Calls proc~~rmvs_interp_out~~CallsGraph proc~rmvs_interp_out rmvs_interp_out util_exit util_exit proc~rmvs_interp_out->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_interp_out~~CalledByGraph proc~rmvs_interp_out rmvs_interp_out proc~rmvs_step_system rmvs_step_system proc~rmvs_step_system->proc~rmvs_interp_out interface~rmvs_step_system rmvs_step_system interface~rmvs_step_system->proc~rmvs_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_interp_out.html"},{"title":"rmvs_step_out – swiftest","text":"subroutine rmvs_step_out(cb, pl, tp, system, param, t, dt) Step ACTIVE test particles ahead in the outer encounter region, setting up and calling the inner region\n    integration if necessar Adapted from Hal Levison's Swift routines rmvs3_step_out.f and rmvs3_step_out2.f\n Adapted from David E. Kaufmann's Swifter routines rmvs_step_out.f90 and rmvs_step_out2.f90 Arguments Type Intent Optional Attributes Name class( rmvs_cb ), intent(inout) :: cb RMVS central body object class( rmvs_pl ), intent(inout) :: pl RMVS massive body object class( rmvs_tp ), intent(inout) :: tp RMVS test particle object class( rmvs_nbody_system ), intent(inout) :: system RMVS nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current stepsiz Calls proc~~rmvs_step_out~~CallsGraph proc~rmvs_step_out rmvs_step_out proc~rmvs_interp_in rmvs_interp_in proc~rmvs_step_out->proc~rmvs_interp_in proc~rmvs_step_in rmvs_step_in proc~rmvs_step_out->proc~rmvs_step_in util_exit util_exit proc~rmvs_interp_in->util_exit proc~rmvs_end_planetocentric rmvs_end_planetocentric proc~rmvs_step_in->proc~rmvs_end_planetocentric proc~rmvs_make_planetocentric rmvs_make_planetocentric proc~rmvs_step_in->proc~rmvs_make_planetocentric proc~rmvs_peri_tp rmvs_peri_tp proc~rmvs_step_in->proc~rmvs_peri_tp xpc xpc proc~rmvs_peri_tp->xpc vpc vpc proc~rmvs_peri_tp->vpc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_step_out~~CalledByGraph proc~rmvs_step_out rmvs_step_out proc~rmvs_step_system rmvs_step_system proc~rmvs_step_system->proc~rmvs_step_out interface~rmvs_step_system rmvs_step_system interface~rmvs_step_system->proc~rmvs_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_step_out.html"},{"title":"rmvs_interp_in – swiftest","text":"subroutine rmvs_interp_in(cb, pl, system, param, dt, outer_index) Interpolate planet positions between two Keplerian orbits in inner encounter regio Adapted from David E. Kaufmann's Swifter routine rmvs_interp_in.f90 Adapted from Hal Levison's Swift routine rmvs3_interp.f Arguments Type Intent Optional Attributes Name class( rmvs_cb ), intent(inout) :: cb RMVS cenral body object class( rmvs_pl ), intent(inout) :: pl RMVS massive body object class( rmvs_nbody_system ), intent(inout) :: system RMVS nbody system object class(swiftest_parameters), intent(in) :: param Swiftest parameters file real(kind=DP), intent(in) :: dt Step size integer(kind=I4B), intent(in) :: outer_index Outer substep number within current set Calls proc~~rmvs_interp_in~~CallsGraph proc~rmvs_interp_in rmvs_interp_in util_exit util_exit proc~rmvs_interp_in->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_interp_in~~CalledByGraph proc~rmvs_interp_in rmvs_interp_in proc~rmvs_step_out rmvs_step_out proc~rmvs_step_out->proc~rmvs_interp_in proc~rmvs_step_system rmvs_step_system proc~rmvs_step_system->proc~rmvs_step_out interface~rmvs_step_system rmvs_step_system interface~rmvs_step_system->proc~rmvs_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_interp_in.html"},{"title":"rmvs_step_in – swiftest","text":"subroutine rmvs_step_in(cb, pl, tp, param, outer_time, dto) Step active test particles ahead in the inner encounter region Adapted from Hal Levison's Swift routine rmvs3_step_in.f\n Adapted from David E. Kaufmann's Swifter routine rmvs_step_in.f90 Arguments Type Intent Optional Attributes Name class( rmvs_cb ), intent(inout) :: cb RMVS central body object class( rmvs_pl ), intent(inout) :: pl RMVS massive body object class( rmvs_tp ), intent(inout) :: tp RMVS test particle object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: outer_time Current time real(kind=DP), intent(in) :: dto Outer step size Calls proc~~rmvs_step_in~~CallsGraph proc~rmvs_step_in rmvs_step_in proc~rmvs_end_planetocentric rmvs_end_planetocentric proc~rmvs_step_in->proc~rmvs_end_planetocentric proc~rmvs_make_planetocentric rmvs_make_planetocentric proc~rmvs_step_in->proc~rmvs_make_planetocentric proc~rmvs_peri_tp rmvs_peri_tp proc~rmvs_step_in->proc~rmvs_peri_tp xpc xpc proc~rmvs_peri_tp->xpc vpc vpc proc~rmvs_peri_tp->vpc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_step_in~~CalledByGraph proc~rmvs_step_in rmvs_step_in proc~rmvs_step_out rmvs_step_out proc~rmvs_step_out->proc~rmvs_step_in proc~rmvs_step_system rmvs_step_system proc~rmvs_step_system->proc~rmvs_step_out interface~rmvs_step_system rmvs_step_system interface~rmvs_step_system->proc~rmvs_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_step_in.html"},{"title":"rmvs_make_planetocentric – swiftest","text":"subroutine rmvs_make_planetocentric(param, cb, pl, tp) When encounters are detected, this method will call the interpolation methods for the planets and \n creates a Swiftest test particle structure for each planet's encountering test particles to simplify the \n planetocentric calculations. This subroutine is not based on an existing one from Swift and Swifter Arguments Type Intent Optional Attributes Name class(swiftest_parameters), intent(in) :: param Current run configuration paramete class( rmvs_cb ), intent(inout) :: cb RMVS central body object class( rmvs_pl ), intent(inout) :: pl RMVS massive body object class( rmvs_tp ), intent(inout) :: tp RMVS test particle object Called by proc~~rmvs_make_planetocentric~~CalledByGraph proc~rmvs_make_planetocentric rmvs_make_planetocentric proc~rmvs_step_in rmvs_step_in proc~rmvs_step_in->proc~rmvs_make_planetocentric proc~rmvs_step_out rmvs_step_out proc~rmvs_step_out->proc~rmvs_step_in proc~rmvs_step_system rmvs_step_system proc~rmvs_step_system->proc~rmvs_step_out interface~rmvs_step_system rmvs_step_system interface~rmvs_step_system->proc~rmvs_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_make_planetocentric.html"},{"title":"rmvs_peri_tp – swiftest","text":"subroutine rmvs_peri_tp(tp, pl, t, dt, lfirst, inner_index, ipleP, param) Determine planetocentric pericenter passages for test particles in close encounters with a planet Adapted from Hal Levison's Swift routine Adapted from Hal Levison's Swift routine util_peri.f\n Adapted from David E. Kaufmann's Swifter routine rmvs_peri.f90 Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: tp RMVS test particle object (planetocentric) class( rmvs_pl ), intent(inout) :: pl RMVS massive body object (heliocentric) real(kind=DP), intent(in) :: t current time real(kind=DP), intent(in) :: dt step size logical, intent(in) :: lfirst Logical flag indicating whether current invocation is the first integer(kind=I4B), intent(in) :: inner_index Outer substep number within current set integer(kind=I4B), intent(in) :: ipleP index of RMVS planet being closely encountered class(swiftest_parameters), intent(in) :: param Current run configuration parameters Calls proc~~rmvs_peri_tp~~CallsGraph proc~rmvs_peri_tp rmvs_peri_tp xpc xpc proc~rmvs_peri_tp->xpc vpc vpc proc~rmvs_peri_tp->vpc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_peri_tp~~CalledByGraph proc~rmvs_peri_tp rmvs_peri_tp proc~rmvs_step_in rmvs_step_in proc~rmvs_step_in->proc~rmvs_peri_tp proc~rmvs_step_out rmvs_step_out proc~rmvs_step_out->proc~rmvs_step_in proc~rmvs_step_system rmvs_step_system proc~rmvs_step_system->proc~rmvs_step_out interface~rmvs_step_system rmvs_step_system interface~rmvs_step_system->proc~rmvs_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_peri_tp.html"},{"title":"rmvs_end_planetocentric – swiftest","text":"subroutine rmvs_end_planetocentric(pl, tp) Deallocates all of the encountering particle data structures for next time Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: pl RMVS massive body object class( rmvs_tp ), intent(inout) :: tp RMVS test particle objec Called by proc~~rmvs_end_planetocentric~~CalledByGraph proc~rmvs_end_planetocentric rmvs_end_planetocentric proc~rmvs_step_in rmvs_step_in proc~rmvs_step_in->proc~rmvs_end_planetocentric proc~rmvs_step_out rmvs_step_out proc~rmvs_step_out->proc~rmvs_step_in proc~rmvs_step_system rmvs_step_system proc~rmvs_step_system->proc~rmvs_step_out interface~rmvs_step_system rmvs_step_system interface~rmvs_step_system->proc~rmvs_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_end_planetocentric.html"},{"title":"kick_getacch_int_pl – swiftest","text":"pure module subroutine kick_getacch_int_pl(self) Interface → Compute direct cross (third) term heliocentric accelerations of massive bodies Adapted from Hal Levison's Swift routine getacch_ah3.f\n Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah3.f90 and helio_kick_getacch_int.f90 Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Called by proc~~kick_getacch_int_pl~~CalledByGraph proc~kick_getacch_int_pl kick_getacch_int_pl interface~kick_getacch_int_pl kick_getacch_int_pl interface~kick_getacch_int_pl->proc~kick_getacch_int_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/kick_getacch_int_pl.html"},{"title":"kick_getacch_int_tp – swiftest","text":"pure module subroutine kick_getacch_int_tp(self, GMpl, xhp, npl) Interface → Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies Adapted from Hal Levison's Swift routine getacch_ah3_tp.f\n Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah3.f90 and helio_kick_getacch_int_tp.f90 Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle real(kind=DP), intent(in), dimension(:) :: GMpl Massive body masses real(kind=DP), intent(in), dimension(:,:) :: xhp Massive body position vectors integer(kind=I4B), intent(in) :: npl Number of active massive bodies Called by proc~~kick_getacch_int_tp~~CalledByGraph proc~kick_getacch_int_tp kick_getacch_int_tp interface~kick_getacch_int_tp kick_getacch_int_tp interface~kick_getacch_int_tp->proc~kick_getacch_int_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/kick_getacch_int_tp.html"},{"title":"tides_kick_getacch_pl – swiftest","text":"module subroutine tides_kick_getacch_pl(self, system) Interface → Calculated tidal torques from central body to any planet and from any planet to central body\n planet - planet interactions are considered negligable.\n This is a constant time lag model. Adapted from Mercury-T code from Bolmont et al. (2015) Reference:\n    Bolmont, E., Raymond, S.N., Leconte, J., Hersant, F., Correia, A.C.M., 2015. \n       Mercury-T : A new code to study tidally evolving multi-planet systems. \n       Applications to Kepler-62. A&A 583, A116. https://doi.org/10.1051/0004-6361/201525909 Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object Called by proc~~tides_kick_getacch_pl~~CalledByGraph proc~tides_kick_getacch_pl tides_kick_getacch_pl interface~tides_kick_getacch_pl tides_kick_getacch_pl interface~tides_kick_getacch_pl->proc~tides_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/tides_kick_getacch_pl.html"},{"title":"tides_step_spin_system – swiftest","text":"module subroutine tides_step_spin_system(self, param, t, dt) Interface → Integrates the spin equations for central and massive bodies of the system subjected to tides. Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize Called by proc~~tides_step_spin_system~~CalledByGraph proc~tides_step_spin_system tides_step_spin_system interface~tides_step_spin_system tides_step_spin_system interface~tides_step_spin_system->proc~tides_step_spin_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/tides_step_spin_system.html"},{"title":"obl_acc_body – swiftest","text":"module subroutine obl_acc_body(self, system) Interface → Compute the barycentric accelerations of bodies due to the oblateness of the central body\n      Returned values do not include monopole term or terms higher than J4 Adapted from David E. Kaufmann's Swifter routine: obl_acc.f90 and obl_acc_tp.f90\n Adapted from Hal Levison's Swift routine obl_acc.f and obl_acc_tp.f Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object Called by proc~~obl_acc_body~~CalledByGraph proc~obl_acc_body obl_acc_body interface~obl_acc_body obl_acc_body interface~obl_acc_body->proc~obl_acc_body proc~obl_acc_tp obl_acc_tp proc~obl_acc_tp->interface~obl_acc_body proc~obl_acc_pl obl_acc_pl proc~obl_acc_pl->interface~obl_acc_body interface~obl_acc_pl obl_acc_pl interface~obl_acc_pl->proc~obl_acc_pl interface~obl_acc_tp obl_acc_tp interface~obl_acc_tp->proc~obl_acc_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/obl_acc_body.html"},{"title":"obl_acc_pl – swiftest","text":"module subroutine obl_acc_pl(self, system) Interface → Compute the barycentric accelerations of massive bodies due to the oblateness of the central body Adapted from David E. Kaufmann's Swifter routine: obl_acc.f90 and obl_acc_tp.f90\n Adapted from Hal Levison's Swift routine obl_acc.f and obl_acc_tp.f Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object Calls proc~~obl_acc_pl~~CallsGraph proc~obl_acc_pl obl_acc_pl interface~obl_acc_body obl_acc_body proc~obl_acc_pl->interface~obl_acc_body proc~obl_acc_body obl_acc_body interface~obl_acc_body->proc~obl_acc_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~obl_acc_pl~~CalledByGraph proc~obl_acc_pl obl_acc_pl interface~obl_acc_pl obl_acc_pl interface~obl_acc_pl->proc~obl_acc_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/obl_acc_pl.html"},{"title":"obl_acc_tp – swiftest","text":"module subroutine obl_acc_tp(self, system) Interface → Compute the barycentric accelerations of massive bodies due to the oblateness of the central body Adapted from David E. Kaufmann's Swifter routine: obl_acc.f90 and obl_acc_tp.f90\n Adapted from Hal Levison's Swift routine obl_acc.f and obl_acc_tp.f Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object Calls proc~~obl_acc_tp~~CallsGraph proc~obl_acc_tp obl_acc_tp interface~obl_acc_body obl_acc_body proc~obl_acc_tp->interface~obl_acc_body proc~obl_acc_body obl_acc_body interface~obl_acc_body->proc~obl_acc_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~obl_acc_tp~~CalledByGraph proc~obl_acc_tp obl_acc_tp interface~obl_acc_tp obl_acc_tp interface~obl_acc_tp->proc~obl_acc_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/obl_acc_tp.html"},{"title":"obl_pot – swiftest","text":"module subroutine obl_pot(npl, Mcb, Mpl, j2rp2, j4rp4, xh, irh, oblpot) Interface → Compute the contribution to the total gravitational potential due solely to the oblateness of the central body\n    Returned value does not include monopole term or terms higher than J4 Reference : MacMillan , W . D . 1958 . The Theory of the Potential , ( Dover Publications ), 363 . Adapted from David E. Kaufmann's Swifter routine: obl_pot.f90 \n Adapted from Hal Levison's Swift routine obl_pot.f Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl real(kind=DP), intent(in) :: Mcb real(kind=DP), intent(in), dimension(:) :: Mpl real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in), dimension(:, :) :: xh real(kind=DP), intent(in), dimension(:) :: irh real(kind=DP), intent(out) :: oblpot Called by proc~~obl_pot~~CalledByGraph proc~obl_pot obl_pot interface~obl_pot obl_pot interface~obl_pot->proc~obl_pot proc~util_get_energy_momentum_system util_get_energy_momentum_system proc~util_get_energy_momentum_system->interface~obl_pot interface~util_get_energy_momentum_system util_get_energy_momentum_system interface~util_get_energy_momentum_system->proc~util_get_energy_momentum_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/obl_pot.html"},{"title":"orbel_el2xv_vec – swiftest","text":"module subroutine orbel_el2xv_vec(self, cb) Interface → A wrapper method that converts all of the cartesian position and velocity vectors of a Swiftest body object to orbital elements. Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body objec Calls proc~~orbel_el2xv_vec~~CallsGraph proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv_vec->proc~orbel_el2xv proc~orbel_fhybrid orbel_fhybrid proc~orbel_el2xv->proc~orbel_fhybrid proc~orbel_ehybrid orbel_ehybrid proc~orbel_el2xv->proc~orbel_ehybrid proc~orbel_schget orbel_schget proc~orbel_el2xv->proc~orbel_schget interface~orbel_scget orbel_scget proc~orbel_el2xv->interface~orbel_scget proc~orbel_zget orbel_zget proc~orbel_el2xv->proc~orbel_zget proc~orbel_flon orbel_flon proc~orbel_fhybrid->proc~orbel_flon proc~orbel_fget orbel_fget proc~orbel_fhybrid->proc~orbel_fget proc~orbel_esolmd orbel_esolmd proc~orbel_ehybrid->proc~orbel_esolmd proc~orbel_ehie orbel_ehie proc~orbel_ehybrid->proc~orbel_ehie proc~orbel_eget orbel_eget proc~orbel_ehybrid->proc~orbel_eget proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget proc~orbel_esolmd->interface~orbel_scget proc~orbel_ehie->interface~orbel_scget 3 3 proc~orbel_flon->3 proc~orbel_eget->interface~orbel_scget proc~orbel_fget->proc~orbel_schget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~orbel_el2xv_vec~~CalledByGraph proc~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_el2xv_vec.html"},{"title":"orbel_scget – swiftest","text":"pure module subroutine orbel_scget(angle, sx, cx) Interface → Efficiently compute the sine and cosine of an input angle\n      Input angle must be in radians Adapted from David E. Kaufmann's Swifter routine: orbel_scget.f90\n Adapted from Hal Levison's Swift routine orbel_scget.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: angle real(kind=DP), intent(out) :: sx real(kind=DP), intent(out) :: cx Called by proc~~orbel_scget~~CalledByGraph proc~orbel_scget orbel_scget interface~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget proc~orbel_esolmd orbel_esolmd proc~orbel_esolmd->interface~orbel_scget proc~orbel_ehie orbel_ehie proc~orbel_ehie->interface~orbel_scget proc~drift_kepu_guess drift_kepu_guess proc~drift_kepu_guess->interface~orbel_scget proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->interface~orbel_scget proc~orbel_ehybrid orbel_ehybrid proc~orbel_el2xv->proc~orbel_ehybrid proc~orbel_eget orbel_eget proc~orbel_eget->interface~orbel_scget proc~drift_kepu drift_kepu proc~drift_kepu->proc~drift_kepu_guess proc~orbel_ehybrid->proc~orbel_esolmd proc~orbel_ehybrid->proc~orbel_ehie proc~orbel_ehybrid->proc~orbel_eget proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec proc~drift_dan drift_dan proc~drift_dan->proc~drift_kepu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_scget.html"},{"title":"orbel_xv2aeq – swiftest","text":"pure module subroutine orbel_xv2aeq(mu, x, v, a, e, q) Interface → Compute semimajor axis, eccentricity, and pericentric distance from relative Cartesian position and velocity Adapted from David E. Kaufmann's Swifter routine: orbel_xv2aeq.f90\n Adapted from Luke Dones' Swift routine orbel_xv2aeq.f\n Arguments Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in), dimension(:) :: v real(kind=DP), intent(out) :: a real(kind=DP), intent(out) :: e real(kind=DP), intent(out) :: q Called by proc~~orbel_xv2aeq~~CalledByGraph proc~orbel_xv2aeq orbel_xv2aeq interface~orbel_xv2aeq orbel_xv2aeq interface~orbel_xv2aeq->proc~orbel_xv2aeq proc~util_peri_tp util_peri_tp proc~util_peri_tp->interface~orbel_xv2aeq interface~util_peri_tp util_peri_tp interface~util_peri_tp->proc~util_peri_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_xv2aeq.html"},{"title":"orbel_xv2aqt – swiftest","text":"pure module subroutine orbel_xv2aqt(mu, x, v, a, q, capm, tperi) Interface → Compute semimajor axis, pericentric distance, mean anomaly, and time to nearest pericenter passage from\n relative Cartesian position and velocity\n      tperi > 0 means nearest pericenter passage is in the future\n      tperi < 0 means nearest pericenter passage is in the past Adapted from David E. Kaufmann's Swifter routine: orbel_xv2aqt.f90 Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(out) :: a semimajor axis real(kind=DP), intent(out) :: q periapsis real(kind=DP), intent(out) :: capm mean anomaly real(kind=DP), intent(out) :: tperi time of pericenter passage Called by proc~~orbel_xv2aqt~~CalledByGraph proc~orbel_xv2aqt orbel_xv2aqt interface~orbel_xv2aqt orbel_xv2aqt interface~orbel_xv2aqt->proc~orbel_xv2aqt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_xv2aqt.html"},{"title":"orbel_xv2el_vec – swiftest","text":"module subroutine orbel_xv2el_vec(self, cb) Interface → A wrapper method that converts all of the cartesian position and velocity vectors of a Swiftest body object to orbital elements. Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object Calls proc~~orbel_xv2el_vec~~CallsGraph proc~orbel_xv2el_vec orbel_xv2el_vec proc~orbel_xv2el orbel_xv2el proc~orbel_xv2el_vec->proc~orbel_xv2el Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~orbel_xv2el_vec~~CalledByGraph proc~orbel_xv2el_vec orbel_xv2el_vec interface~orbel_xv2el_vec orbel_xv2el_vec interface~orbel_xv2el_vec->proc~orbel_xv2el_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_xv2el_vec.html"},{"title":"whm_coord_h2j_pl – swiftest","text":"module subroutine whm_coord_h2j_pl(self, cb) Interface → Convert from heliocentric to Jacobi coordinates, massive bodies only Uses pre-computed eta rather than computing it each time Adapted from David E. Kaufmann's Swifter routine coord_h2j.f90 Adapted from Hal Levison's Swift routine coord_h2j.f Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree Calls proc~~whm_coord_h2j_pl~~CallsGraph proc~whm_coord_h2j_pl whm_coord_h2j_pl gmpl gmpl proc~whm_coord_h2j_pl->gmpl vj vj proc~whm_coord_h2j_pl->vj xj xj proc~whm_coord_h2j_pl->xj vh vh proc~whm_coord_h2j_pl->vh eta eta proc~whm_coord_h2j_pl->eta xh xh proc~whm_coord_h2j_pl->xh Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_coord_h2j_pl~~CalledByGraph proc~whm_coord_h2j_pl whm_coord_h2j_pl interface~whm_coord_h2j_pl whm_coord_h2j_pl interface~whm_coord_h2j_pl->proc~whm_coord_h2j_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_coord_h2j_pl.html"},{"title":"whm_coord_j2h_pl – swiftest","text":"module subroutine whm_coord_j2h_pl(self, cb) Interface → Convert from Jacobi to heliocentric coordinates, massive bodies only. Uses pre-computed eta rather than computing it each time Adapted from David E. Kaufmann's Swifter routine coord_j2h.f90 Adapted from Hal Levison's Swift routine coord_j2h.f Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree Calls proc~~whm_coord_j2h_pl~~CallsGraph proc~whm_coord_j2h_pl whm_coord_j2h_pl gmpl gmpl proc~whm_coord_j2h_pl->gmpl vj vj proc~whm_coord_j2h_pl->vj xj xj proc~whm_coord_j2h_pl->xj vh vh proc~whm_coord_j2h_pl->vh eta eta proc~whm_coord_j2h_pl->eta xh xh proc~whm_coord_j2h_pl->xh Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_coord_j2h_pl~~CalledByGraph proc~whm_coord_j2h_pl whm_coord_j2h_pl interface~whm_coord_j2h_pl whm_coord_j2h_pl interface~whm_coord_j2h_pl->proc~whm_coord_j2h_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_coord_j2h_pl.html"},{"title":"whm_coord_vh2vj_pl – swiftest","text":"module subroutine whm_coord_vh2vj_pl(self, cb) Interface → Convert from heliocentric to Jadcobi coordinates, massive body velocities only Uses pre-computed eta rather than computing it each time Adapted from David E. Kaufmann's Swifter routine coord_vh2vj.f90 Adapted from Hal Levison's Swift routine coord_vh2vj.f Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree Calls proc~~whm_coord_vh2vj_pl~~CallsGraph proc~whm_coord_vh2vj_pl whm_coord_vh2vj_pl gmpl gmpl proc~whm_coord_vh2vj_pl->gmpl vj vj proc~whm_coord_vh2vj_pl->vj vh vh proc~whm_coord_vh2vj_pl->vh eta eta proc~whm_coord_vh2vj_pl->eta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_coord_vh2vj_pl~~CalledByGraph proc~whm_coord_vh2vj_pl whm_coord_vh2vj_pl interface~whm_coord_vh2vj_pl whm_coord_vh2vj_pl interface~whm_coord_vh2vj_pl->proc~whm_coord_vh2vj_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_coord_vh2vj_pl.html"},{"title":"whm_gr_kick_getacch_pl – swiftest","text":"module subroutine whm_gr_kick_getacch_pl(self, param) Interface → Compute relativisitic accelerations of massive bodies\n    Based on Saha & Tremaine (1994) Eq. 28 Adapted from David A. Minton's Swifter routine routine gr_whm_kick_getacch.f90 Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters Calls proc~~whm_gr_kick_getacch_pl~~CallsGraph proc~whm_gr_kick_getacch_pl whm_gr_kick_getacch_pl gr_kick_getacch gr_kick_getacch proc~whm_gr_kick_getacch_pl->gr_kick_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_gr_kick_getacch_pl~~CalledByGraph proc~whm_gr_kick_getacch_pl whm_gr_kick_getacch_pl interface~whm_gr_kick_getacch_pl whm_gr_kick_getacch_pl interface~whm_gr_kick_getacch_pl->proc~whm_gr_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_gr_kick_getacch_pl.html"},{"title":"whm_gr_kick_getacch_tp – swiftest","text":"module subroutine whm_gr_kick_getacch_tp(self, param) Interface → Compute relativisitic accelerations of test particles\n    Based on Saha & Tremaine (1994) Eq. 28 Adapted from David A. Minton's Swifter routine routine gr_whm_kick_getacch.f90 Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters Calls proc~~whm_gr_kick_getacch_tp~~CallsGraph proc~whm_gr_kick_getacch_tp whm_gr_kick_getacch_tp gr_kick_getacch gr_kick_getacch proc~whm_gr_kick_getacch_tp->gr_kick_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_gr_kick_getacch_tp~~CalledByGraph proc~whm_gr_kick_getacch_tp whm_gr_kick_getacch_tp interface~whm_gr_kick_getacch_tp whm_gr_kick_getacch_tp interface~whm_gr_kick_getacch_tp->proc~whm_gr_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_gr_kick_getacch_tp.html"},{"title":"whm_gr_p4_pl – swiftest","text":"pure module subroutine whm_gr_p4_pl(self, param, dt) Interface → Position kick to massive bodies due to p**4 term in the post-Newtonian correction\n    Based on Saha & Tremaine (1994) Eq. 28 Adapted from David A. Minton's Swifter routine routine gr_whm_p4.f90 Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size Calls proc~~whm_gr_p4_pl~~CallsGraph proc~whm_gr_p4_pl whm_gr_p4_pl gr_p4_pos_kick gr_p4_pos_kick proc~whm_gr_p4_pl->gr_p4_pos_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_gr_p4_pl~~CalledByGraph proc~whm_gr_p4_pl whm_gr_p4_pl interface~whm_gr_p4_pl whm_gr_p4_pl interface~whm_gr_p4_pl->proc~whm_gr_p4_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_gr_p4_pl.html"},{"title":"whm_gr_p4_tp – swiftest","text":"pure module subroutine whm_gr_p4_tp(self, param, dt) Interface → Position kick to test particles due to p**4 term in the post-Newtonian correction\n    Based on Saha & Tremaine (1994) Eq. 28 Adapted from David A. Minton's Swifter routine routine gr_whm_p4.f90 Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size Calls proc~~whm_gr_p4_tp~~CallsGraph proc~whm_gr_p4_tp whm_gr_p4_tp gr_p4_pos_kick gr_p4_pos_kick proc~whm_gr_p4_tp->gr_p4_pos_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_gr_p4_tp~~CalledByGraph proc~whm_gr_p4_tp whm_gr_p4_tp interface~whm_gr_p4_tp whm_gr_p4_tp interface~whm_gr_p4_tp->proc~whm_gr_p4_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_gr_p4_tp.html"},{"title":"whm_step_system – swiftest","text":"module subroutine whm_step_system(self, param, t, dt) Interface → Step massive bodies and and active test particles ahead in heliocentric coordinates Adapted from Hal Levison's Swift routine step_kdk.f\n Adapted from David E. Kaufmann's Swifter routine whm_step.f90 Arguments Type Intent Optional Attributes Name class( whm_nbody_system ), intent(inout) :: self WHM nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current stepsize Called by proc~~whm_step_system~~CalledByGraph proc~whm_step_system whm_step_system interface~whm_step_system whm_step_system interface~whm_step_system->proc~whm_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_step_system.html"},{"title":"whm_step_pl – swiftest","text":"module subroutine whm_step_pl(self, system, param, t, dt) Interface → Step planets ahead using kick-drift-kick algorithm Adapted from Hal Levison's Swift routine step_kdk_pl.f\n Adapted from David E. Kaufmann's Swifter routine whm_step_pl.f90 Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current stepsize Called by proc~~whm_step_pl~~CalledByGraph proc~whm_step_pl whm_step_pl interface~whm_step_pl whm_step_pl interface~whm_step_pl->proc~whm_step_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_step_pl.html"},{"title":"whm_step_tp – swiftest","text":"module subroutine whm_step_tp(self, system, param, t, dt) Interface → Step active test particles ahead using kick-drift-kick algorithm Adapted from Hal Levison's Swift routine step_kdk_tp.f\n Adapted from David E. Kaufmann's Swifter routine whm_step_tp.f90 Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current stepsize Called by proc~~whm_step_tp~~CalledByGraph proc~whm_step_tp whm_step_tp interface~whm_step_tp whm_step_tp interface~whm_step_tp->proc~whm_step_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_step_tp.html"},{"title":"whm_drift_pl – swiftest","text":"module subroutine whm_drift_pl(self, system, param, dt) Interface → Loop through planets and call Danby drift routine Adapted from Hal Levison's Swift routine drift.f\n Adapted from David E. Kaufmann's Swifter routine whm_drift.f90 Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize Calls proc~~whm_drift_pl~~CallsGraph proc~whm_drift_pl whm_drift_pl drift_all drift_all proc~whm_drift_pl->drift_all util_exit util_exit proc~whm_drift_pl->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_drift_pl~~CalledByGraph proc~whm_drift_pl whm_drift_pl interface~whm_drift_pl whm_drift_pl interface~whm_drift_pl->proc~whm_drift_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_drift_pl.html"},{"title":"whm_kick_getacch_pl – swiftest","text":"module subroutine whm_kick_getacch_pl(self, system, param, t, lbeg) Interface → Compute heliocentric accelerations of planets Adapted from Hal Levison's Swift routine getacch.f\n Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch.f90 Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest central body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step Calls proc~~whm_kick_getacch_pl~~CallsGraph proc~whm_kick_getacch_pl whm_kick_getacch_pl proc~whm_kick_getacch_ah2 whm_kick_getacch_ah2 proc~whm_kick_getacch_pl->proc~whm_kick_getacch_ah2 proc~whm_kick_getacch_ah0 whm_kick_getacch_ah0 proc~whm_kick_getacch_pl->proc~whm_kick_getacch_ah0 proc~whm_kick_getacch_ah1 whm_kick_getacch_ah1 proc~whm_kick_getacch_pl->proc~whm_kick_getacch_ah1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_kick_getacch_pl~~CalledByGraph proc~whm_kick_getacch_pl whm_kick_getacch_pl interface~whm_kick_getacch_pl whm_kick_getacch_pl interface~whm_kick_getacch_pl->proc~whm_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_kick_getacch_pl.html"},{"title":"whm_kick_getacch_tp – swiftest","text":"module subroutine whm_kick_getacch_tp(self, system, param, t, lbeg) Interface → Compute heliocentric accelerations of test particles Adapted from Hal Levison's Swift routine getacch_tp.f\n Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_tp.f90 Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest central body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step Calls proc~~whm_kick_getacch_tp~~CallsGraph proc~whm_kick_getacch_tp whm_kick_getacch_tp proc~whm_kick_getacch_ah0 whm_kick_getacch_ah0 proc~whm_kick_getacch_tp->proc~whm_kick_getacch_ah0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_kick_getacch_tp~~CalledByGraph proc~whm_kick_getacch_tp whm_kick_getacch_tp interface~whm_kick_getacch_tp whm_kick_getacch_tp interface~whm_kick_getacch_tp->proc~whm_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_kick_getacch_tp.html"},{"title":"whm_kick_vh_pl – swiftest","text":"module subroutine whm_kick_vh_pl(self, system, param, t, dt, lbeg) Interface → Kick heliocentric velocities of massive bodies Adapted from Martin Duncan and Hal Levison's Swift routine kickvh.f \n Adapted from David E. Kaufmann's Swifter routine whm_kickvh.f90 Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. Called by proc~~whm_kick_vh_pl~~CalledByGraph proc~whm_kick_vh_pl whm_kick_vh_pl interface~whm_kick_vh_pl whm_kick_vh_pl interface~whm_kick_vh_pl->proc~whm_kick_vh_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_kick_vh_pl.html"},{"title":"whm_kick_vh_tp – swiftest","text":"module subroutine whm_kick_vh_tp(self, system, param, t, dt, lbeg) Interface → Kick heliocentric velocities of test particles Adapted from Martin Duncan and Hal Levison's Swift routine kickvh_tp.f\n Adapted from David E. Kaufmann's Swifter routine whm_kickvh_tp.f90 Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. Called by proc~~whm_kick_vh_tp~~CalledByGraph proc~whm_kick_vh_tp whm_kick_vh_tp interface~whm_kick_vh_tp whm_kick_vh_tp interface~whm_kick_vh_tp->proc~whm_kick_vh_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_kick_vh_tp.html"},{"title":"whm_setup_pl – swiftest","text":"module subroutine whm_setup_pl(self, n, param) Interface → Allocate WHM planet structure Equivalent in functionality to David E. Kaufmann's Swifter routine whm_setup.f90\n Call allocation method for parent class Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameter Calls proc~~whm_setup_pl~~CallsGraph proc~whm_setup_pl whm_setup_pl setup_pl setup_pl proc~whm_setup_pl->setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_setup_pl~~CalledByGraph proc~whm_setup_pl whm_setup_pl interface~whm_setup_pl whm_setup_pl interface~whm_setup_pl->proc~whm_setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_setup_pl.html"},{"title":"whm_util_set_mu_eta_pl – swiftest","text":"module subroutine whm_util_set_mu_eta_pl(self, cb) Interface → Sets the Jacobi mass value eta for all massive bodies Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM system object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object Calls proc~~whm_util_set_mu_eta_pl~~CallsGraph proc~whm_util_set_mu_eta_pl whm_util_set_mu_eta_pl util_set_mu_pl util_set_mu_pl proc~whm_util_set_mu_eta_pl->util_set_mu_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_util_set_mu_eta_pl~~CalledByGraph proc~whm_util_set_mu_eta_pl whm_util_set_mu_eta_pl interface~whm_util_set_mu_eta_pl whm_util_set_mu_eta_pl interface~whm_util_set_mu_eta_pl->proc~whm_util_set_mu_eta_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_util_set_mu_eta_pl.html"},{"title":"whm_setup_initialize_system – swiftest","text":"module subroutine whm_setup_initialize_system(self, param) Interface → Initialize a WHM nbody system from files Arguments Type Intent Optional Attributes Name class( whm_nbody_system ), intent(inout) :: self Swiftest system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters Calls proc~~whm_setup_initialize_system~~CallsGraph proc~whm_setup_initialize_system whm_setup_initialize_system util_set_ir3h util_set_ir3h proc~whm_setup_initialize_system->util_set_ir3h setup_initialize_system setup_initialize_system proc~whm_setup_initialize_system->setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_setup_initialize_system~~CalledByGraph proc~whm_setup_initialize_system whm_setup_initialize_system interface~whm_setup_initialize_system whm_setup_initialize_system interface~whm_setup_initialize_system->proc~whm_setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_setup_initialize_system.html"},{"title":"whm_util_append_pl – swiftest","text":"module subroutine whm_util_append_pl(self, source, lsource_mask) Interface → Append components from one massive body object to another. \n This method will automatically resize the destination body if it is too small\n Arguments Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~whm_util_append_pl~~CallsGraph proc~whm_util_append_pl whm_util_append_pl util_append util_append proc~whm_util_append_pl->util_append util_exit util_exit proc~whm_util_append_pl->util_exit util_append_pl util_append_pl proc~whm_util_append_pl->util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_util_append_pl~~CalledByGraph proc~whm_util_append_pl whm_util_append_pl interface~whm_util_append_pl whm_util_append_pl interface~whm_util_append_pl->proc~whm_util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_util_append_pl.html"},{"title":"whm_util_fill_pl – swiftest","text":"module subroutine whm_util_fill_pl(self, inserts, lfill_list) Interface → Insert new WHM test particle structure into an old one. \n This is the inverse of a fill operation. Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(in) :: inserts inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Calls proc~~whm_util_fill_pl~~CallsGraph proc~whm_util_fill_pl whm_util_fill_pl util_fill_pl util_fill_pl proc~whm_util_fill_pl->util_fill_pl util_fill util_fill proc~whm_util_fill_pl->util_fill util_exit util_exit proc~whm_util_fill_pl->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_util_fill_pl~~CalledByGraph proc~whm_util_fill_pl whm_util_fill_pl interface~whm_util_fill_pl whm_util_fill_pl interface~whm_util_fill_pl->proc~whm_util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_util_fill_pl.html"},{"title":"whm_util_resize_pl – swiftest","text":"module subroutine whm_util_resize_pl(self, nnew) Interface → Checks the current size of a massive body against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object integer(kind=I4B), intent(in) :: nnew New size neded Calls proc~~whm_util_resize_pl~~CallsGraph proc~whm_util_resize_pl whm_util_resize_pl util_resize_pl util_resize_pl proc~whm_util_resize_pl->util_resize_pl util_resize util_resize proc~whm_util_resize_pl->util_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_util_resize_pl~~CalledByGraph proc~whm_util_resize_pl whm_util_resize_pl interface~whm_util_resize_pl whm_util_resize_pl interface~whm_util_resize_pl->proc~whm_util_resize_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_util_resize_pl.html"},{"title":"whm_util_set_ir3j – swiftest","text":"module subroutine whm_util_set_ir3j(self) Interface → Sets the inverse Jacobi and heliocentric radii cubed (1/rj 3 and 1/rh 3) Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object Called by proc~~whm_util_set_ir3j~~CalledByGraph proc~whm_util_set_ir3j whm_util_set_ir3j interface~whm_util_set_ir3j whm_util_set_ir3j interface~whm_util_set_ir3j->proc~whm_util_set_ir3j Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_util_set_ir3j.html"},{"title":"whm_util_sort_pl – swiftest","text":"module subroutine whm_util_sort_pl(self, sortby, ascending) Interface → Sort a WHM massive body object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order Calls proc~~whm_util_sort_pl~~CallsGraph proc~whm_util_sort_pl whm_util_sort_pl util_sort_pl util_sort_pl proc~whm_util_sort_pl->util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_util_sort_pl~~CalledByGraph proc~whm_util_sort_pl whm_util_sort_pl interface~whm_util_sort_pl whm_util_sort_pl interface~whm_util_sort_pl->proc~whm_util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_util_sort_pl.html"},{"title":"whm_util_sort_rearrange_pl – swiftest","text":"module subroutine whm_util_sort_rearrange_pl(self, ind) Interface → Rearrange WHM massive body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) Calls proc~~whm_util_sort_rearrange_pl~~CallsGraph proc~whm_util_sort_rearrange_pl whm_util_sort_rearrange_pl util_sort_rearrange_pl util_sort_rearrange_pl proc~whm_util_sort_rearrange_pl->util_sort_rearrange_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_util_sort_rearrange_pl~~CalledByGraph proc~whm_util_sort_rearrange_pl whm_util_sort_rearrange_pl interface~whm_util_sort_rearrange_pl whm_util_sort_rearrange_pl interface~whm_util_sort_rearrange_pl->proc~whm_util_sort_rearrange_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_util_sort_rearrange_pl.html"},{"title":"whm_util_spill_pl – swiftest","text":"module subroutine whm_util_spill_pl(self, discards, lspill_list, ldestructive) Interface → Move spilled (discarded) WHM test particle structure from active list to discard list Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not Calls proc~~whm_util_spill_pl~~CallsGraph proc~whm_util_spill_pl whm_util_spill_pl util_spill util_spill proc~whm_util_spill_pl->util_spill util_exit util_exit proc~whm_util_spill_pl->util_exit util_spill_pl util_spill_pl proc~whm_util_spill_pl->util_spill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_util_spill_pl~~CalledByGraph proc~whm_util_spill_pl whm_util_spill_pl interface~whm_util_spill_pl whm_util_spill_pl interface~whm_util_spill_pl->proc~whm_util_spill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_util_spill_pl.html"},{"title":"operator_cross_sp – swiftest","text":"pure function operator_cross_sp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: A real(kind=SP), intent(in), dimension(:) :: B Return Value real(kind=SP),\n  dimension(3) Contents None","tags":"","loc":"proc/operator_cross_sp.html"},{"title":"operator_cross_dp – swiftest","text":"pure function operator_cross_dp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: A real(kind=DP), intent(in), dimension(:) :: B Return Value real(kind=DP),\n  dimension(3) Contents None","tags":"","loc":"proc/operator_cross_dp.html"},{"title":"operator_cross_qp – swiftest","text":"pure function operator_cross_qp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:) :: A real(kind=QP), intent(in), dimension(:) :: B Return Value real(kind=QP),\n  dimension(3) Contents None","tags":"","loc":"proc/operator_cross_qp.html"},{"title":"operator_cross_i1b – swiftest","text":"pure function operator_cross_i1b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in), dimension(:) :: A integer(kind=I1B), intent(in), dimension(:) :: B Return Value integer(kind=I1B),\n  dimension(3) Contents None","tags":"","loc":"proc/operator_cross_i1b.html"},{"title":"operator_cross_i2b – swiftest","text":"pure function operator_cross_i2b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in), dimension(:) :: A integer(kind=I2B), intent(in), dimension(:) :: B Return Value integer(kind=I2B),\n  dimension(3) Contents None","tags":"","loc":"proc/operator_cross_i2b.html"},{"title":"operator_cross_i4b – swiftest","text":"pure function operator_cross_i4b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:) :: A integer(kind=I4B), intent(in), dimension(:) :: B Return Value integer(kind=I4B),\n  dimension(3) Contents None","tags":"","loc":"proc/operator_cross_i4b.html"},{"title":"operator_cross_i8b – swiftest","text":"pure function operator_cross_i8b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in), dimension(:) :: A integer(kind=I8B), intent(in), dimension(:) :: B Return Value integer(kind=I8B),\n  dimension(3) Contents None","tags":"","loc":"proc/operator_cross_i8b.html"},{"title":"operator_cross_el_sp – swiftest","text":"pure function operator_cross_el_sp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:,:) :: A real(kind=SP), intent(in), dimension(:,:) :: B Return Value real(kind=SP),\n  dimension(:,:),allocatable Contents None","tags":"","loc":"proc/operator_cross_el_sp.html"},{"title":"operator_cross_el_dp – swiftest","text":"pure function operator_cross_el_dp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A real(kind=DP), intent(in), dimension(:,:) :: B Return Value real(kind=DP),\n  dimension(:,:),allocatable Contents None","tags":"","loc":"proc/operator_cross_el_dp.html"},{"title":"operator_cross_el_qp – swiftest","text":"pure function operator_cross_el_qp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A real(kind=QP), intent(in), dimension(:,:) :: B Return Value real(kind=QP),\n  dimension(:,:),allocatable Contents None","tags":"","loc":"proc/operator_cross_el_qp.html"},{"title":"operator_cross_el_i1b – swiftest","text":"pure function operator_cross_el_i1b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in), dimension(:,:) :: A integer(kind=I1B), intent(in), dimension(:,:) :: B Return Value integer(kind=I1B),\n  dimension(:,:),allocatable Contents None","tags":"","loc":"proc/operator_cross_el_i1b.html"},{"title":"operator_cross_el_i2b – swiftest","text":"pure function operator_cross_el_i2b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in), dimension(:,:) :: A integer(kind=I2B), intent(in), dimension(:,:) :: B Return Value integer(kind=I2B),\n  dimension(:,:),allocatable Contents None","tags":"","loc":"proc/operator_cross_el_i2b.html"},{"title":"operator_cross_el_i4b – swiftest","text":"pure function operator_cross_el_i4b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:,:) :: A integer(kind=I4B), intent(in), dimension(:,:) :: B Return Value integer(kind=I4B),\n  dimension(:,:),allocatable Contents None","tags":"","loc":"proc/operator_cross_el_i4b.html"},{"title":"operator_cross_el_i8b – swiftest","text":"pure function operator_cross_el_i8b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in), dimension(:,:) :: A integer(kind=I8B), intent(in), dimension(:,:) :: B Return Value integer(kind=I8B),\n  dimension(:,:),allocatable Contents None","tags":"","loc":"proc/operator_cross_el_i8b.html"},{"title":"operator_mag_sp – swiftest","text":"pure function operator_mag_sp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: A Return Value real(kind=SP) Contents None","tags":"","loc":"proc/operator_mag_sp.html"},{"title":"operator_mag_dp – swiftest","text":"pure function operator_mag_dp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: A Return Value real(kind=DP) Contents None","tags":"","loc":"proc/operator_mag_dp.html"},{"title":"operator_mag_el_sp – swiftest","text":"pure function operator_mag_el_sp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:,:) :: A Return Value real(kind=SP),\n  dimension(:),allocatable Contents None","tags":"","loc":"proc/operator_mag_el_sp.html"},{"title":"operator_mag_el_dp – swiftest","text":"pure function operator_mag_el_dp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A Return Value real(kind=DP),\n  dimension(:),allocatable Contents None","tags":"","loc":"proc/operator_mag_el_dp.html"},{"title":"operator_mag_el_qp – swiftest","text":"pure function operator_mag_el_qp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A Return Value real(kind=QP),\n  dimension(:),allocatable Contents None","tags":"","loc":"proc/operator_mag_el_qp.html"},{"title":"util_solve_linear_system_d – swiftest","text":"function util_solve_linear_system_d(A, b, n, lerr) result(x) Uses ieee_exceptions proc~~util_solve_linear_system_d~~UsesGraph proc~util_solve_linear_system_d util_solve_linear_system_d ieee_exceptions ieee_exceptions proc~util_solve_linear_system_d->ieee_exceptions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Solves the linear equation of the form A*x = b for x. \n   A is an (n,n) arrays\n   x and b are (n) arrays\n Uses Gaussian elimination, so will have issues if system is ill-conditioned.\n Uses quad precision intermidiate values, so works best on small arrays. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A real(kind=DP), intent(in), dimension(:) :: b integer(kind=I4B), intent(in) :: n logical, intent(out) :: lerr Return Value real(kind=DP),\n  dimension(n) Calls proc~~util_solve_linear_system_d~~CallsGraph proc~util_solve_linear_system_d util_solve_linear_system_d proc~solve_wbs solve_wbs proc~util_solve_linear_system_d->proc~solve_wbs proc~ge_wpp ge_wpp proc~util_solve_linear_system_d->proc~ge_wpp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_solve_linear_system_d.html"},{"title":"util_solve_linear_system_q – swiftest","text":"function util_solve_linear_system_q(A, b, n, lerr) result(x) Uses ieee_exceptions proc~~util_solve_linear_system_q~~UsesGraph proc~util_solve_linear_system_q util_solve_linear_system_q ieee_exceptions ieee_exceptions proc~util_solve_linear_system_q->ieee_exceptions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Solves the linear equation of the form A*x = b for x. \n   A is an (n,n) arrays\n   x and b are (n) arrays\n Uses Gaussian elimination, so will have issues if system is ill-conditioned.\n Uses quad precision intermidiate values, so works best on small arrays. Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A real(kind=QP), intent(in), dimension(:) :: b integer(kind=I4B), intent(in) :: n logical, intent(out) :: lerr Return Value real(kind=QP),\n  dimension(n) Calls proc~~util_solve_linear_system_q~~CallsGraph proc~util_solve_linear_system_q util_solve_linear_system_q proc~solve_wbs solve_wbs proc~util_solve_linear_system_q->proc~solve_wbs proc~ge_wpp ge_wpp proc~util_solve_linear_system_q->proc~ge_wpp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_solve_linear_system_q.html"},{"title":"util_solve_rkf45 – swiftest","text":"module function util_solve_rkf45(f, y0in, t1, dt0, tol) result(y1) Interface → Implements the 4th order Runge-Kutta-Fehlberg ODE solver for initial value problems of the form f=dy/dt, y0 = y(t=0), solving for y1 = y(t=t1). Uses a 5th order adaptive step size control.\n Uses a lambda function object as defined in the lambda_function module Arguments Type Intent Optional Attributes Name class(lambda_obj), intent(inout) :: f lambda function object that has been initialized to be a function of derivatives. The object will return with components lastarg and lasteval set real(kind=DP), intent(in), dimension(:) :: y0in Initial value at t=0 real(kind=DP), intent(in) :: t1 Final time real(kind=DP), intent(in) :: dt0 Initial step size guess real(kind=DP), intent(in) :: tol Tolerance on solution Return Value real(kind=DP),\n  dimension(:),allocatable Final result Calls proc~~util_solve_rkf45~~CallsGraph proc~util_solve_rkf45 util_solve_rkf45 interface~util_exit util_exit proc~util_solve_rkf45->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_solve_rkf45~~CalledByGraph proc~util_solve_rkf45 util_solve_rkf45 interface~util_solve_rkf45 util_solve_rkf45 interface~util_solve_rkf45->proc~util_solve_rkf45 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_solve_rkf45.html"},{"title":"util_set_beg_end_pl – swiftest","text":"module subroutine util_set_beg_end_pl(self, xbeg, xend, vbeg) Interface → Sets one or more of the values of xbeg, xend, and vbeg Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object real(kind=DP), intent(in), optional dimension(:,:) :: xbeg real(kind=DP), intent(in), optional dimension(:,:) :: xend real(kind=DP), intent(in), optional dimension(:,:) :: vbeg Called by proc~~util_set_beg_end_pl~~CalledByGraph proc~util_set_beg_end_pl util_set_beg_end_pl interface~util_set_beg_end_pl util_set_beg_end_pl interface~util_set_beg_end_pl->proc~util_set_beg_end_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_set_beg_end_pl.html"},{"title":"util_set_ir3h – swiftest","text":"module subroutine util_set_ir3h(self) Interface → Sets the inverse heliocentric radius term (1/rh**3) for all bodies in a structure Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object Called by proc~~util_set_ir3h~~CalledByGraph proc~util_set_ir3h util_set_ir3h interface~util_set_ir3h util_set_ir3h interface~util_set_ir3h->proc~util_set_ir3h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_set_ir3h.html"},{"title":"util_set_msys – swiftest","text":"module subroutine util_set_msys(self) Interface → Sets the value of msys and the vector mass quantities based on the total mass of the system Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nobdy system object Called by proc~~util_set_msys~~CalledByGraph proc~util_set_msys util_set_msys interface~util_set_msys util_set_msys interface~util_set_msys->proc~util_set_msys Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_set_msys.html"},{"title":"util_set_mu_pl – swiftest","text":"module subroutine util_set_mu_pl(self, cb) Interface → Computes G * (M + m) for each massive body Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object Called by proc~~util_set_mu_pl~~CalledByGraph proc~util_set_mu_pl util_set_mu_pl interface~util_set_mu_pl util_set_mu_pl interface~util_set_mu_pl->proc~util_set_mu_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_set_mu_pl.html"},{"title":"util_set_mu_tp – swiftest","text":"module subroutine util_set_mu_tp(self, cb) Interface → Converts certain scalar values to arrays so that they can be used in elemental functions Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object Called by proc~~util_set_mu_tp~~CalledByGraph proc~util_set_mu_tp util_set_mu_tp interface~util_set_mu_tp util_set_mu_tp interface~util_set_mu_tp->proc~util_set_mu_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_set_mu_tp.html"},{"title":"util_set_rhill – swiftest","text":"module subroutine util_set_rhill(self, cb) Interface → Sets the value of the Hill's radius Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object Called by proc~~util_set_rhill~~CalledByGraph proc~util_set_rhill util_set_rhill interface~util_set_rhill util_set_rhill interface~util_set_rhill->proc~util_set_rhill Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_set_rhill.html"},{"title":"util_set_rhill_approximate – swiftest","text":"module subroutine util_set_rhill_approximate(self, cb) Interface → Sets the approximate value of the Hill's radius using the heliocentric radius instead of computing the semimajor axis Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object Called by proc~~util_set_rhill_approximate~~CalledByGraph proc~util_set_rhill_approximate util_set_rhill_approximate interface~util_set_rhill_approximate util_set_rhill_approximate interface~util_set_rhill_approximate->proc~util_set_rhill_approximate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_set_rhill_approximate.html"},{"title":"util_peri_tp – swiftest","text":"module subroutine util_peri_tp(self, system, param) Interface → Determine system pericenter passages for test particles\n Note:  If the coordinate system used is barycentric, then this routine assumes that the barycentric coordinates in the\n        test particle structures are up-to-date and are not recomputed Adapted from David E. Kaufmann's Swifter routine: util_peri.f90\n Adapted from Hal Levison's Swift routine util_peri.f Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~util_peri_tp~~CallsGraph proc~util_peri_tp util_peri_tp interface~orbel_xv2aeq orbel_xv2aeq proc~util_peri_tp->interface~orbel_xv2aeq proc~orbel_xv2aeq orbel_xv2aeq interface~orbel_xv2aeq->proc~orbel_xv2aeq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_peri_tp~~CalledByGraph proc~util_peri_tp util_peri_tp interface~util_peri_tp util_peri_tp interface~util_peri_tp->proc~util_peri_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_peri_tp.html"},{"title":"util_coord_h2b_pl – swiftest","text":"module subroutine util_coord_h2b_pl(self, cb) Interface → Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) Adapted from David E. Kaufmann's Swifter routine coord_h2b.f90 \n Adapted from Hal Levison's Swift routine coord_h2b.f Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object Called by proc~~util_coord_h2b_pl~~CalledByGraph proc~util_coord_h2b_pl util_coord_h2b_pl interface~util_coord_h2b_pl util_coord_h2b_pl interface~util_coord_h2b_pl->proc~util_coord_h2b_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_coord_h2b_pl.html"},{"title":"util_coord_h2b_tp – swiftest","text":"module subroutine util_coord_h2b_tp(self, cb) Interface → Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) Adapted from David E. Kaufmann's Swifter routine coord_h2b_tp.f90 \n Adapted from Hal Levison's Swift routine coord_h2b_tp.f Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object Called by proc~~util_coord_h2b_tp~~CalledByGraph proc~util_coord_h2b_tp util_coord_h2b_tp interface~util_coord_h2b_tp util_coord_h2b_tp interface~util_coord_h2b_tp->proc~util_coord_h2b_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_coord_h2b_tp.html"},{"title":"util_coord_b2h_pl – swiftest","text":"module subroutine util_coord_b2h_pl(self, cb) Interface → Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) Adapted from David E. Kaufmann's Swifter routine coord_b2h.f90 \n Adapted from Hal Levison's Swift routine coord_b2h.f Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object Called by proc~~util_coord_b2h_pl~~CalledByGraph proc~util_coord_b2h_pl util_coord_b2h_pl interface~util_coord_b2h_pl util_coord_b2h_pl interface~util_coord_b2h_pl->proc~util_coord_b2h_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_coord_b2h_pl.html"},{"title":"util_coord_b2h_tp – swiftest","text":"module subroutine util_coord_b2h_tp(self, cb) Interface → Convert test particles from barycentric to heliocentric coordinates (position and velocity) Adapted from David E. Kaufmann's Swifter routine coord_b2h_tp.f90 \n Adapted from Hal Levison's Swift routine coord_b2h_tp.f Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(in) :: cb Swiftest central body object Called by proc~~util_coord_b2h_tp~~CalledByGraph proc~util_coord_b2h_tp util_coord_b2h_tp interface~util_coord_b2h_tp util_coord_b2h_tp interface~util_coord_b2h_tp->proc~util_coord_b2h_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_coord_b2h_tp.html"},{"title":"util_rescale_system – swiftest","text":"module subroutine util_rescale_system(self, param, mscale, dscale, tscale) Interface → Rescales an nbody system to a new set of units. Inputs are the multipliers on the mass (mscale), distance (dscale), and time units (tscale). \n Rescales all united quantities in the system, as well as the mass conversion factors, gravitational constant, and Einstein's constant in the parameter object. Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters. Returns with new values of the scale vactors and GU real(kind=DP), intent(in) :: mscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: dscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: tscale Scale factors for mass, distance, and time units, respectively. Called by proc~~util_rescale_system~~CalledByGraph proc~util_rescale_system util_rescale_system interface~util_rescale_system util_rescale_system interface~util_rescale_system->proc~util_rescale_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_rescale_system.html"},{"title":"util_version – swiftest","text":"module subroutine util_version() Interface → Print program version information to terminale Adapted from David E. Kaufmann's Swifter routine: util_version.f90 Arguments None Called by proc~~util_version~~CalledByGraph proc~util_version util_version interface~util_version util_version interface~util_version->proc~util_version proc~io_get_args io_get_args proc~io_get_args->interface~util_version interface~io_get_args io_get_args interface~io_get_args->proc~io_get_args Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_version.html"},{"title":"util_sort_body – swiftest","text":"module subroutine util_sort_body(self, sortby, ascending) Interface → Sort a Swiftest body structure in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order Called by proc~~util_sort_body~~CalledByGraph proc~util_sort_body util_sort_body interface~util_sort_body util_sort_body interface~util_sort_body->proc~util_sort_body proc~util_sort_tp util_sort_tp proc~util_sort_tp->interface~util_sort_body proc~util_sort_pl util_sort_pl proc~util_sort_pl->interface~util_sort_body interface~util_sort_pl util_sort_pl interface~util_sort_pl->proc~util_sort_pl interface~util_sort_tp util_sort_tp interface~util_sort_tp->proc~util_sort_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_sort_body.html"},{"title":"util_sort_pl – swiftest","text":"module subroutine util_sort_pl(self, sortby, ascending) Interface → Sort a Swiftest massive body object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order Calls proc~~util_sort_pl~~CallsGraph proc~util_sort_pl util_sort_pl interface~util_sort_body util_sort_body proc~util_sort_pl->interface~util_sort_body proc~util_sort_body util_sort_body interface~util_sort_body->proc~util_sort_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_sort_pl~~CalledByGraph proc~util_sort_pl util_sort_pl interface~util_sort_pl util_sort_pl interface~util_sort_pl->proc~util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_sort_pl.html"},{"title":"util_sort_tp – swiftest","text":"module subroutine util_sort_tp(self, sortby, ascending) Interface → Sort a Swiftest test particle object  in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order Calls proc~~util_sort_tp~~CallsGraph proc~util_sort_tp util_sort_tp interface~util_sort_body util_sort_body proc~util_sort_tp->interface~util_sort_body proc~util_sort_body util_sort_body interface~util_sort_body->proc~util_sort_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_sort_tp~~CalledByGraph proc~util_sort_tp util_sort_tp interface~util_sort_tp util_sort_tp interface~util_sort_tp->proc~util_sort_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_sort_tp.html"},{"title":"util_sort_rearrange_body – swiftest","text":"module subroutine util_sort_rearrange_body(self, ind) Interface → Rearrange Swiftest body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) Called by proc~~util_sort_rearrange_body~~CalledByGraph proc~util_sort_rearrange_body util_sort_rearrange_body interface~util_sort_rearrange_body util_sort_rearrange_body interface~util_sort_rearrange_body->proc~util_sort_rearrange_body proc~util_sort_rearrange_pl util_sort_rearrange_pl proc~util_sort_rearrange_pl->interface~util_sort_rearrange_body proc~util_sort_rearrange_tp util_sort_rearrange_tp proc~util_sort_rearrange_tp->interface~util_sort_rearrange_body interface~util_sort_rearrange_pl util_sort_rearrange_pl interface~util_sort_rearrange_pl->proc~util_sort_rearrange_pl interface~util_sort_rearrange_tp util_sort_rearrange_tp interface~util_sort_rearrange_tp->proc~util_sort_rearrange_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_sort_rearrange_body.html"},{"title":"util_sort_rearrange_pl – swiftest","text":"module subroutine util_sort_rearrange_pl(self, ind) Interface → Rearrange Swiftest massive body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) Calls proc~~util_sort_rearrange_pl~~CallsGraph proc~util_sort_rearrange_pl util_sort_rearrange_pl interface~util_sort_rearrange_body util_sort_rearrange_body proc~util_sort_rearrange_pl->interface~util_sort_rearrange_body proc~util_sort_rearrange_body util_sort_rearrange_body interface~util_sort_rearrange_body->proc~util_sort_rearrange_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_sort_rearrange_pl~~CalledByGraph proc~util_sort_rearrange_pl util_sort_rearrange_pl interface~util_sort_rearrange_pl util_sort_rearrange_pl interface~util_sort_rearrange_pl->proc~util_sort_rearrange_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_sort_rearrange_pl.html"},{"title":"util_sort_rearrange_tp – swiftest","text":"module subroutine util_sort_rearrange_tp(self, ind) Interface → Rearrange Swiftest massive body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) Calls proc~~util_sort_rearrange_tp~~CallsGraph proc~util_sort_rearrange_tp util_sort_rearrange_tp interface~util_sort_rearrange_body util_sort_rearrange_body proc~util_sort_rearrange_tp->interface~util_sort_rearrange_body proc~util_sort_rearrange_body util_sort_rearrange_body interface~util_sort_rearrange_body->proc~util_sort_rearrange_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_sort_rearrange_tp~~CalledByGraph proc~util_sort_rearrange_tp util_sort_rearrange_tp interface~util_sort_rearrange_tp util_sort_rearrange_tp interface~util_sort_rearrange_tp->proc~util_sort_rearrange_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_sort_rearrange_tp.html"},{"title":"util_sort_dp – swiftest","text":"subroutine util_sort_dp(arr) Sort input double precision array in place into ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:) :: arr Contents None","tags":"","loc":"proc/util_sort_dp.html"},{"title":"util_sort_index_dp – swiftest","text":"subroutine util_sort_index_dp(arr, ind) Sort input double precision array by index in ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind Contents None","tags":"","loc":"proc/util_sort_index_dp.html"},{"title":"util_sort_i4b – swiftest","text":"subroutine util_sort_i4b(arr) Sort input integer array in place into ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:) :: arr Contents None","tags":"","loc":"proc/util_sort_i4b.html"},{"title":"util_sort_index_i4b – swiftest","text":"subroutine util_sort_index_i4b(arr, ind) Sort input integer array by index in ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind Contents None","tags":"","loc":"proc/util_sort_index_i4b.html"},{"title":"util_sort_sp – swiftest","text":"subroutine util_sort_sp(arr) Sort input single precision array in place into ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), dimension(:) :: arr Contents None","tags":"","loc":"proc/util_sort_sp.html"},{"title":"util_sort_index_sp – swiftest","text":"subroutine util_sort_index_sp(arr, ind) Sort input single precision array by index in ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind Contents None","tags":"","loc":"proc/util_sort_index_sp.html"},{"title":"util_spill_arr_char_string – swiftest","text":"subroutine util_spill_arr_char_string(keeps, discards, lspill_list, ldestructive) Performs a spill operation on a single array of type character strings\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: keeps Array of values to keep character(len=STRMAX), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not Contents None","tags":"","loc":"proc/util_spill_arr_char_string.html"},{"title":"util_spill_arr_DP – swiftest","text":"subroutine util_spill_arr_DP(keeps, discards, lspill_list, ldestructive) Performs a spill operation on a single array of type DP\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: keeps Array of values to keep real(kind=DP), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not Contents None","tags":"","loc":"proc/util_spill_arr_dp.html"},{"title":"util_spill_arr_DPvec – swiftest","text":"subroutine util_spill_arr_DPvec(keeps, discards, lspill_list, ldestructive) Performs a spill operation on a single array of DP vectors with shape (NDIM, n)\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: keeps Array of values to keep real(kind=DP), intent(inout), dimension(:,:), allocatable :: discards Array discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not Contents None","tags":"","loc":"proc/util_spill_arr_dpvec.html"},{"title":"util_spill_arr_I4B – swiftest","text":"subroutine util_spill_arr_I4B(keeps, discards, lspill_list, ldestructive) Performs a spill operation on a single array of type I4B\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: keeps Array of values to keep integer(kind=I4B), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not Contents None","tags":"","loc":"proc/util_spill_arr_i4b.html"},{"title":"util_spill_arr_logical – swiftest","text":"subroutine util_spill_arr_logical(keeps, discards, lspill_list, ldestructive) Performs a spill operation on a single array of logicals\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: keeps Array of values to keep logical, intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or no Contents None","tags":"","loc":"proc/util_spill_arr_logical.html"},{"title":"util_spill_body – swiftest","text":"module subroutine util_spill_body(self, discards, lspill_list, ldestructive) Interface → Move spilled (discarded) Swiftest generic particle structure from active list to discard list\n Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90\n Spill all the common components Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list Calls proc~~util_spill_body~~CallsGraph proc~util_spill_body util_spill_body interface~util_spill~2 util_spill proc~util_spill_body->interface~util_spill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_spill_body~~CalledByGraph proc~util_spill_body util_spill_body interface~util_spill_body util_spill_body interface~util_spill_body->proc~util_spill_body proc~util_spill_tp util_spill_tp proc~util_spill_tp->interface~util_spill_body proc~util_spill_pl util_spill_pl proc~util_spill_pl->interface~util_spill_body interface~util_spill_pl util_spill_pl interface~util_spill_pl->proc~util_spill_pl interface~util_spill_tp util_spill_tp interface~util_spill_tp->proc~util_spill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_spill_body.html"},{"title":"util_spill_encounter – swiftest","text":"module subroutine util_spill_encounter(self, discards, lspill_list, ldestructive) Interface → Move spilled (discarded) Swiftest encounter structure from active list to discard list Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list Calls proc~~util_spill_encounter~~CallsGraph proc~util_spill_encounter util_spill_encounter interface~util_spill~2 util_spill proc~util_spill_encounter->interface~util_spill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_spill_encounter~~CalledByGraph proc~util_spill_encounter util_spill_encounter interface~util_spill_encounter util_spill_encounter interface~util_spill_encounter->proc~util_spill_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_spill_encounter.html"},{"title":"util_spill_pl – swiftest","text":"module subroutine util_spill_pl(self, discards, lspill_list, ldestructive) Interface → Move spilled (discarded) Swiftest massive body structure from active list to discard list\n Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90\n Spill components specific to the massive body class Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list Calls proc~~util_spill_pl~~CallsGraph proc~util_spill_pl util_spill_pl interface~util_spill~2 util_spill proc~util_spill_pl->interface~util_spill~2 interface~util_spill_body util_spill_body proc~util_spill_pl->interface~util_spill_body proc~util_spill_body util_spill_body interface~util_spill_body->proc~util_spill_body proc~util_spill_body->interface~util_spill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_spill_pl~~CalledByGraph proc~util_spill_pl util_spill_pl interface~util_spill_pl util_spill_pl interface~util_spill_pl->proc~util_spill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_spill_pl.html"},{"title":"util_spill_tp – swiftest","text":"module subroutine util_spill_tp(self, discards, lspill_list, ldestructive) Interface → Move spilled (discarded) Swiftest test particle structure from active list to discard list\n Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90\n Spill components specific to the test particle class Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardse logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list Calls proc~~util_spill_tp~~CallsGraph proc~util_spill_tp util_spill_tp interface~util_spill~2 util_spill proc~util_spill_tp->interface~util_spill~2 interface~util_spill_body util_spill_body proc~util_spill_tp->interface~util_spill_body proc~util_spill_body util_spill_body interface~util_spill_body->proc~util_spill_body proc~util_spill_body->interface~util_spill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_spill_tp~~CalledByGraph proc~util_spill_tp util_spill_tp interface~util_spill_tp util_spill_tp interface~util_spill_tp->proc~util_spill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_spill_tp.html"},{"title":"util_valid_id_system – swiftest","text":"module subroutine util_valid_id_system(self, param) Interface → Validate massive body and test particle ids\n Subroutine causes program to exit with error if any ids are not unique Adapted from David E. Kaufmann's Swifter routine: util_valid.f90 Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~util_valid_id_system~~CallsGraph proc~util_valid_id_system util_valid_id_system interface~util_sort util_sort proc~util_valid_id_system->interface~util_sort interface~util_exit util_exit proc~util_valid_id_system->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_valid_id_system~~CalledByGraph proc~util_valid_id_system util_valid_id_system interface~util_valid_id_system util_valid_id_system interface~util_valid_id_system->proc~util_valid_id_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_valid_id_system.html"},{"title":"util_exit – swiftest","text":"module subroutine util_exit(code) Interface → Print termination message and exit program Adapted from David E. Kaufmann's Swifter routine: util_exit.f90\n Adapted from Hal Levison's Swift routine util_exit.f Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: code Called by proc~~util_exit~~CalledByGraph proc~util_exit util_exit interface~util_exit util_exit interface~util_exit->proc~util_exit proc~io_write_frame_system io_write_frame_system proc~io_write_frame_system->interface~util_exit proc~io_write_hdr io_write_hdr proc~io_write_frame_system->proc~io_write_hdr proc~util_valid_id_system util_valid_id_system proc~util_valid_id_system->interface~util_exit proc~setup_construct_system setup_construct_system proc~setup_construct_system->interface~util_exit proc~io_read_body_in io_read_body_in proc~io_read_body_in->interface~util_exit proc~io_write_discard io_write_discard proc~io_write_discard->interface~util_exit proc~io_read_frame_cb io_read_frame_cb proc~io_read_frame_cb->interface~util_exit proc~util_append_pl util_append_pl proc~util_append_pl->interface~util_exit proc~util_solve_rkf45 util_solve_rkf45 proc~util_solve_rkf45->interface~util_exit proc~util_append_tp util_append_tp proc~util_append_tp->interface~util_exit proc~io_read_frame_body io_read_frame_body proc~io_read_frame_body->interface~util_exit proc~io_get_args io_get_args proc~io_get_args->interface~util_exit proc~io_read_encounter io_read_encounter proc~io_read_encounter->interface~util_exit proc~io_dump_swiftest io_dump_swiftest proc~io_dump_swiftest->interface~util_exit proc~io_read_param_in io_read_param_in proc~io_read_param_in->interface~util_exit proc~io_write_encounter io_write_encounter proc~io_write_encounter->interface~util_exit proc~io_dump_param io_dump_param proc~io_dump_param->interface~util_exit proc~io_read_cb_in io_read_cb_in proc~io_read_cb_in->interface~util_exit proc~io_write_hdr->interface~util_exit interface~io_dump_swiftest io_dump_swiftest interface~io_dump_swiftest->proc~io_dump_swiftest interface~util_append_tp util_append_tp interface~util_append_tp->proc~util_append_tp interface~io_read_frame_cb io_read_frame_cb interface~io_read_frame_cb->proc~io_read_frame_cb interface~util_append_pl util_append_pl interface~util_append_pl->proc~util_append_pl interface~io_get_args io_get_args interface~io_get_args->proc~io_get_args interface~io_read_body_in io_read_body_in interface~io_read_body_in->proc~io_read_body_in interface~io_write_discard io_write_discard interface~io_write_discard->proc~io_write_discard interface~io_write_encounter io_write_encounter interface~io_write_encounter->proc~io_write_encounter interface~util_solve_rkf45 util_solve_rkf45 interface~util_solve_rkf45->proc~util_solve_rkf45 interface~io_read_frame_body io_read_frame_body interface~io_read_frame_body->proc~io_read_frame_body interface~setup_construct_system setup_construct_system interface~setup_construct_system->proc~setup_construct_system interface~util_valid_id_system util_valid_id_system interface~util_valid_id_system->proc~util_valid_id_system interface~io_dump_param io_dump_param interface~io_dump_param->proc~io_dump_param interface~io_read_cb_in io_read_cb_in interface~io_read_cb_in->proc~io_read_cb_in interface~io_read_param_in io_read_param_in interface~io_read_param_in->proc~io_read_param_in interface~io_write_frame_system io_write_frame_system interface~io_write_frame_system->proc~io_write_frame_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_exit.html"},{"title":"util_fill_arr_char_string – swiftest","text":"subroutine util_fill_arr_char_string(keeps, inserts, lfill_list) Performs a fill operation on a single array of type character strings\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: keeps Array of values to keep character(len=STRMAX), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Contents None","tags":"","loc":"proc/util_fill_arr_char_string.html"},{"title":"util_fill_arr_DP – swiftest","text":"subroutine util_fill_arr_DP(keeps, inserts, lfill_list) Performs a fill operation on a single array of type DP\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: keeps Array of values to keep real(kind=DP), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Contents None","tags":"","loc":"proc/util_fill_arr_dp.html"},{"title":"util_fill_arr_DPvec – swiftest","text":"subroutine util_fill_arr_DPvec(keeps, inserts, lfill_list) Performs a fill operation on a single array of DP vectors with shape (NDIM, n)\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: keeps Array of values to keep real(kind=DP), intent(in), dimension(:,:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Contents None","tags":"","loc":"proc/util_fill_arr_dpvec.html"},{"title":"util_fill_arr_I4B – swiftest","text":"subroutine util_fill_arr_I4B(keeps, inserts, lfill_list) Performs a fill operation on a single array of type I4B\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: keeps Array of values to keep integer(kind=I4B), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Contents None","tags":"","loc":"proc/util_fill_arr_i4b.html"},{"title":"util_fill_arr_logical – swiftest","text":"subroutine util_fill_arr_logical(keeps, inserts, lfill_list) Performs a fill operation on a single array of logicals\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: keeps Array of values to keep logical, intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Contents None","tags":"","loc":"proc/util_fill_arr_logical.html"},{"title":"util_fill_body – swiftest","text":"module subroutine util_fill_body(self, inserts, lfill_list) Interface → Insert new Swiftest generic particle structure into an old one. \n This is the inverse of a spill operation.\n Fill all the common components Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_body ), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Calls proc~~util_fill_body~~CallsGraph proc~util_fill_body util_fill_body interface~util_fill~2 util_fill proc~util_fill_body->interface~util_fill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_fill_body~~CalledByGraph proc~util_fill_body util_fill_body interface~util_fill_body util_fill_body interface~util_fill_body->proc~util_fill_body proc~util_fill_tp util_fill_tp proc~util_fill_tp->interface~util_fill_body proc~util_fill_pl util_fill_pl proc~util_fill_pl->interface~util_fill_body interface~util_fill_tp util_fill_tp interface~util_fill_tp->proc~util_fill_tp interface~util_fill_pl util_fill_pl interface~util_fill_pl->proc~util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_fill_body.html"},{"title":"util_fill_pl – swiftest","text":"module subroutine util_fill_pl(self, inserts, lfill_list) Interface → Insert new Swiftest massive body structure into an old one. \n This is the inverse of a spill operation.\n Fill components specific to the massive body class Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Calls proc~~util_fill_pl~~CallsGraph proc~util_fill_pl util_fill_pl interface~util_fill_body util_fill_body proc~util_fill_pl->interface~util_fill_body interface~util_fill~2 util_fill proc~util_fill_pl->interface~util_fill~2 proc~util_fill_body util_fill_body interface~util_fill_body->proc~util_fill_body proc~util_fill_body->interface~util_fill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_fill_pl~~CalledByGraph proc~util_fill_pl util_fill_pl interface~util_fill_pl util_fill_pl interface~util_fill_pl->proc~util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_fill_pl.html"},{"title":"util_fill_tp – swiftest","text":"module subroutine util_fill_tp(self, inserts, lfill_list) Interface → Insert new Swiftest test particle structure into an old one. \n This is the inverse of a fill operation.\n Spill components specific to the test particle class Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Calls proc~~util_fill_tp~~CallsGraph proc~util_fill_tp util_fill_tp interface~util_fill_body util_fill_body proc~util_fill_tp->interface~util_fill_body interface~util_fill~2 util_fill proc~util_fill_tp->interface~util_fill~2 proc~util_fill_body util_fill_body interface~util_fill_body->proc~util_fill_body proc~util_fill_body->interface~util_fill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_fill_tp~~CalledByGraph proc~util_fill_tp util_fill_tp interface~util_fill_tp util_fill_tp interface~util_fill_tp->proc~util_fill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_fill_tp.html"},{"title":"util_resize_arr_char_string – swiftest","text":"subroutine util_resize_arr_char_string(arr, nnew) Resizes an array component of type character string. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size Contents None","tags":"","loc":"proc/util_resize_arr_char_string.html"},{"title":"util_resize_arr_DP – swiftest","text":"subroutine util_resize_arr_DP(arr, nnew) Resizes an array component of double precision type. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size Contents None","tags":"","loc":"proc/util_resize_arr_dp.html"},{"title":"util_resize_arr_DPvec – swiftest","text":"subroutine util_resize_arr_DPvec(arr, nnew) Resizes an array component of double precision vectors of size (NDIM, n). Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size Contents None","tags":"","loc":"proc/util_resize_arr_dpvec.html"},{"title":"util_resize_arr_I4B – swiftest","text":"subroutine util_resize_arr_I4B(arr, nnew) Resizes an array component of integer type. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size Contents None","tags":"","loc":"proc/util_resize_arr_i4b.html"},{"title":"util_resize_arr_logical – swiftest","text":"subroutine util_resize_arr_logical(arr, nnew) Resizes an array component of logical type. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size Contents None","tags":"","loc":"proc/util_resize_arr_logical.html"},{"title":"util_resize_body – swiftest","text":"module subroutine util_resize_body(self, nnew) Interface → Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in) :: nnew New size neded Calls proc~~util_resize_body~~CallsGraph proc~util_resize_body util_resize_body interface~util_resize~2 util_resize proc~util_resize_body->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_resize_body~~CalledByGraph proc~util_resize_body util_resize_body interface~util_resize_body util_resize_body interface~util_resize_body->proc~util_resize_body proc~util_resize_tp util_resize_tp proc~util_resize_tp->interface~util_resize_body proc~util_resize_pl util_resize_pl proc~util_resize_pl->interface~util_resize_body interface~util_resize_pl util_resize_pl interface~util_resize_pl->proc~util_resize_pl interface~util_resize_tp util_resize_tp interface~util_resize_tp->proc~util_resize_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_resize_body.html"},{"title":"util_resize_encounter – swiftest","text":"module subroutine util_resize_encounter(self, nnew) Interface → Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small.\n Note: The reason to extend it by a factor of 2 is for performance. When there are many enounters per step, resizing every time you want to add an \n encounter takes significant computational effort. Resizing by a factor of 2 is a tradeoff between performance (fewer resize calls) and memory managment\n Memory usage grows by a factor of 2 each time it fills up, but no more. Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list integer(kind=I4B), intent(in) :: nnew New size of list needed Called by proc~~util_resize_encounter~~CalledByGraph proc~util_resize_encounter util_resize_encounter interface~util_resize_encounter util_resize_encounter interface~util_resize_encounter->proc~util_resize_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_resize_encounter.html"},{"title":"util_resize_pl – swiftest","text":"module subroutine util_resize_pl(self, nnew) Interface → Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: nnew New size neded Calls proc~~util_resize_pl~~CallsGraph proc~util_resize_pl util_resize_pl interface~util_resize_body util_resize_body proc~util_resize_pl->interface~util_resize_body interface~util_resize~2 util_resize proc~util_resize_pl->interface~util_resize~2 proc~util_resize_body util_resize_body interface~util_resize_body->proc~util_resize_body proc~util_resize_body->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_resize_pl~~CalledByGraph proc~util_resize_pl util_resize_pl interface~util_resize_pl util_resize_pl interface~util_resize_pl->proc~util_resize_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_resize_pl.html"},{"title":"util_resize_tp – swiftest","text":"module subroutine util_resize_tp(self, nnew) Interface → Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: nnew New size neded Calls proc~~util_resize_tp~~CallsGraph proc~util_resize_tp util_resize_tp interface~util_resize_body util_resize_body proc~util_resize_tp->interface~util_resize_body interface~util_resize~2 util_resize proc~util_resize_tp->interface~util_resize~2 proc~util_resize_body util_resize_body interface~util_resize_body->proc~util_resize_body proc~util_resize_body->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_resize_tp~~CalledByGraph proc~util_resize_tp util_resize_tp interface~util_resize_tp util_resize_tp interface~util_resize_tp->proc~util_resize_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_resize_tp.html"},{"title":"util_copy_encounter – swiftest","text":"module subroutine util_copy_encounter(self, source) Interface → Copies elements from the source encounter list into self. Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Encounter list class( swiftest_encounter ), intent(in) :: source Source object to copy into Called by proc~~util_copy_encounter~~CalledByGraph proc~util_copy_encounter util_copy_encounter interface~util_copy_encounter util_copy_encounter interface~util_copy_encounter->proc~util_copy_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_copy_encounter.html"},{"title":"util_minimize_bfgs – swiftest","text":"module function util_minimize_bfgs(f, N, x0, eps, lerr) result(x1) Interface → Uses ieee_exceptions proc~~util_minimize_bfgs~~UsesGraph proc~util_minimize_bfgs util_minimize_bfgs ieee_exceptions ieee_exceptions proc~util_minimize_bfgs->ieee_exceptions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. This function implements the Broyden-Fletcher-Goldfarb-Shanno method to determine the minimum of a function of N variables. It recieves as input:\n   f%eval(x) : lambda function object containing the objective function as the eval metho\n   N    :  Number of variables of function f\n   x0   :  Initial starting value of x\n   eps  :  Accuracy of 1 - dimensional minimization at each step\n The outputs include\n   lerr :  Returns .true. if it could not find the minimum\n Returns\n   x1   :  Final minimum (all 0 if none found)\n   0 = No miniumum found Arguments Type Intent Optional Attributes Name class(lambda_obj), intent(inout) :: f integer(kind=I4B), intent(in) :: N real(kind=DP), intent(in), dimension(:) :: x0 real(kind=DP), intent(in) :: eps logical, intent(out) :: lerr Return Value real(kind=DP),\n  dimension(:),allocatable Called by proc~~util_minimize_bfgs~~CalledByGraph proc~util_minimize_bfgs util_minimize_bfgs interface~util_minimize_bfgs util_minimize_bfgs interface~util_minimize_bfgs->proc~util_minimize_bfgs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_minimize_bfgs.html"},{"title":"util_append_arr_char_string – swiftest","text":"subroutine util_append_arr_char_string(arr, source, nold, nsrc, lsource_mask) Append a single array of character string type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: arr Destination array character(len=STRMAX), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~util_append_arr_char_string~~CallsGraph proc~util_append_arr_char_string util_append_arr_char_string interface~util_resize~2 util_resize proc~util_append_arr_char_string->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_append_arr_char_string.html"},{"title":"util_append_arr_DP – swiftest","text":"subroutine util_append_arr_DP(arr, source, nold, nsrc, lsource_mask) Append a single array of double precision type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: arr Destination array real(kind=DP), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~util_append_arr_dp~~CallsGraph proc~util_append_arr_dp util_append_arr_DP interface~util_resize~2 util_resize proc~util_append_arr_dp->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_append_arr_dp.html"},{"title":"util_append_arr_DPvec – swiftest","text":"subroutine util_append_arr_DPvec(arr, source, nold, nsrc, lsource_mask) Append a single array of double precision vector type of size (NDIM, n) onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: arr Destination array real(kind=DP), intent(in), dimension(:,:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~util_append_arr_dpvec~~CallsGraph proc~util_append_arr_dpvec util_append_arr_DPvec interface~util_resize~2 util_resize proc~util_append_arr_dpvec->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_append_arr_dpvec.html"},{"title":"util_append_arr_I4B – swiftest","text":"subroutine util_append_arr_I4B(arr, source, nold, nsrc, lsource_mask) Append a single array of integer(I4B) onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~util_append_arr_i4b~~CallsGraph proc~util_append_arr_i4b util_append_arr_I4B interface~util_resize~2 util_resize proc~util_append_arr_i4b->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_append_arr_i4b.html"},{"title":"util_append_arr_logical – swiftest","text":"subroutine util_append_arr_logical(arr, source, nold, nsrc, lsource_mask) Append a single array of logical type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: arr Destination array logical, intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~util_append_arr_logical~~CallsGraph proc~util_append_arr_logical util_append_arr_logical interface~util_resize~2 util_resize proc~util_append_arr_logical->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_append_arr_logical.html"},{"title":"util_append_body – swiftest","text":"module subroutine util_append_body(self, source, lsource_mask) Interface → Append components from one Swiftest body object to another. \n This method will automatically resize the destination body if it is too small Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~util_append_body~~CallsGraph proc~util_append_body util_append_body interface~util_append~2 util_append proc~util_append_body->interface~util_append~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_append_body~~CalledByGraph proc~util_append_body util_append_body interface~util_append_body util_append_body interface~util_append_body->proc~util_append_body proc~util_append_pl util_append_pl proc~util_append_pl->interface~util_append_body proc~util_append_tp util_append_tp proc~util_append_tp->interface~util_append_body interface~util_append_tp util_append_tp interface~util_append_tp->proc~util_append_tp interface~util_append_pl util_append_pl interface~util_append_pl->proc~util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_append_body.html"},{"title":"util_append_pl – swiftest","text":"module subroutine util_append_pl(self, source, lsource_mask) Interface → Append components from one Swiftest body object to another. \n This method will automatically resize the destination body if it is too small Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~util_append_pl~~CallsGraph proc~util_append_pl util_append_pl interface~util_append_body util_append_body proc~util_append_pl->interface~util_append_body interface~util_append~2 util_append proc~util_append_pl->interface~util_append~2 interface~util_exit util_exit proc~util_append_pl->interface~util_exit proc~util_append_body util_append_body interface~util_append_body->proc~util_append_body proc~util_exit util_exit interface~util_exit->proc~util_exit proc~util_append_body->interface~util_append~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_append_pl~~CalledByGraph proc~util_append_pl util_append_pl interface~util_append_pl util_append_pl interface~util_append_pl->proc~util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_append_pl.html"},{"title":"util_append_tp – swiftest","text":"module subroutine util_append_tp(self, source, lsource_mask) Interface → Append components from one Swiftest body object to another. \n This method will automatically resize the destination body if it is too small Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~util_append_tp~~CallsGraph proc~util_append_tp util_append_tp interface~util_append_body util_append_body proc~util_append_tp->interface~util_append_body interface~util_append~2 util_append proc~util_append_tp->interface~util_append~2 interface~util_exit util_exit proc~util_append_tp->interface~util_exit proc~util_append_body util_append_body interface~util_append_body->proc~util_append_body proc~util_exit util_exit interface~util_exit->proc~util_exit proc~util_append_body->interface~util_append~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_append_tp~~CalledByGraph proc~util_append_tp util_append_tp interface~util_append_tp util_append_tp interface~util_append_tp->proc~util_append_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_append_tp.html"},{"title":"util_get_energy_momentum_system – swiftest","text":"module subroutine util_get_energy_momentum_system(self, param) Interface → Compute total system angular momentum vector and kinetic, potential and total system energy Adapted from David E. Kaufmann Swifter routine symba_energy_eucl.f90 Adapted from Martin Duncan's Swift routine anal_energy.f Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~util_get_energy_momentum_system~~CallsGraph proc~util_get_energy_momentum_system util_get_energy_momentum_system px px proc~util_get_energy_momentum_system->px py py proc~util_get_energy_momentum_system->py indj indj proc~util_get_energy_momentum_system->indj indi indi proc~util_get_energy_momentum_system->indi interface~obl_pot obl_pot proc~util_get_energy_momentum_system->interface~obl_pot pz pz proc~util_get_energy_momentum_system->pz proc~obl_pot obl_pot interface~obl_pot->proc~obl_pot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_get_energy_momentum_system~~CalledByGraph proc~util_get_energy_momentum_system util_get_energy_momentum_system interface~util_get_energy_momentum_system util_get_energy_momentum_system interface~util_get_energy_momentum_system->proc~util_get_energy_momentum_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_get_energy_momentum_system.html"},{"title":"gr_kick_getaccb_ns_body – swiftest","text":"pure module subroutine gr_kick_getaccb_ns_body(self, system, param) Interface → Add relativistic correction acceleration for non-symplectic integrators.\n Based on Quinn et al. (1991) eq. 5 Reference: Quinn, T.R., Tremaine, S., Duncan, M., 1991. A three million year integration of the earth’s orbit. \n       AJ 101, 2287–2305. https://doi.org/10.1086/115850 Adapted from David A. Minton's Swifter routine routine gr_kick_getaccb_ns.f90 Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Called by proc~~gr_kick_getaccb_ns_body~~CalledByGraph proc~gr_kick_getaccb_ns_body gr_kick_getaccb_ns_body interface~gr_kick_getaccb_ns_body gr_kick_getaccb_ns_body interface~gr_kick_getaccb_ns_body->proc~gr_kick_getaccb_ns_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gr_kick_getaccb_ns_body.html"},{"title":"gr_kick_getacch – swiftest","text":"module subroutine gr_kick_getacch(mu, x, lmask, n, inv_c2, agr) Interface → Compute relativisitic accelerations of massive bodies\n    Based on Saha & Tremaine (1994) Eq. 28 Adapted from David A. Minton's Swifter routine routine gr_whm_kick_getacch.f90 Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:,:) :: x Position vectors logical, intent(in), dimension(:) :: lmask Logical mask indicating which bodies to compute integer(kind=I4B), intent(in) :: n Total number of bodies real(kind=DP), intent(in) :: inv_c2 Inverse speed of light squared: 1 / c**2 real(kind=DP), intent(out), dimension(:,:) :: agr Accelerations Called by proc~~gr_kick_getacch~~CalledByGraph proc~gr_kick_getacch gr_kick_getacch interface~gr_kick_getacch gr_kick_getacch interface~gr_kick_getacch->proc~gr_kick_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gr_kick_getacch.html"},{"title":"gr_p4_pos_kick – swiftest","text":"pure module subroutine gr_p4_pos_kick(param, x, v, dt) Interface → Position kick due to p**4 term in the post-Newtonian correction\n    Based on Saha & Tremaine (1994) Eq. 28 Reference:\n    Saha, P., Tremaine, S., 1994. Long-term planetary integration with individual time steps. \n       AJ 108, 1962–1969. https://doi.org/10.1086/117210 Adapted from David A. Minton's Swifter routine gr_whm_p4.f90 Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(inout), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(in) :: dt Step size Called by proc~~gr_p4_pos_kick~~CalledByGraph proc~gr_p4_pos_kick gr_p4_pos_kick interface~gr_p4_pos_kick gr_p4_pos_kick interface~gr_p4_pos_kick->proc~gr_p4_pos_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gr_p4_pos_kick.html"},{"title":"gr_pseudovel2vel – swiftest","text":"pure module subroutine gr_pseudovel2vel(param, mu, xh, pv, vh) Interface → Converts the relativistic pseudovelocity back into a veliocentric velocity\n    Based on Saha & Tremaine (1994) Eq. 32 Reference:\n    Saha, P., Tremaine, S., 1994. Long-term planetary integration with individual time steps. \n       AJ 108, 1962–1969. https://doi.org/10.1086/117210 Adapted from David A. Minton's Swifter routine gr_pseudovel2vel.f90 Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real(kind=DP), intent(in), dimension(:) :: xh Heliocentric position vector real(kind=DP), intent(in), dimension(:) :: pv Pseudovelocity velocity vector - see Saha & Tremain (1994), eq. (32) real(kind=DP), intent(out), dimension(:) :: vh Heliocentric velocity vector Called by proc~~gr_pseudovel2vel~~CalledByGraph proc~gr_pseudovel2vel gr_pseudovel2vel interface~gr_pseudovel2vel gr_pseudovel2vel interface~gr_pseudovel2vel->proc~gr_pseudovel2vel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gr_pseudovel2vel.html"},{"title":"gr_pv2vh_body – swiftest","text":"pure module subroutine gr_pv2vh_body(self, param) Interface → Wrapper function that converts from pseudovelocity to heliocentric velocity for swiftest bodies Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Called by proc~~gr_pv2vh_body~~CalledByGraph proc~gr_pv2vh_body gr_pv2vh_body interface~gr_pv2vh_body gr_pv2vh_body interface~gr_pv2vh_body->proc~gr_pv2vh_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gr_pv2vh_body.html"},{"title":"gr_vel2pseudovel – swiftest","text":"pure module subroutine gr_vel2pseudovel(param, mu, xh, vh, pv) Interface → Converts the heliocentric velocity into a pseudovelocity with relativistic corrections. \n Uses Newton-Raphson method with direct inversion of the Jacobian (yeah, it's slow, but \n this is only done once per run). Reference:\n    Saha, P., Tremaine, S., 1994. Long-term planetary integration with individual time steps. \n       AJ 108, 1962–1969. https://doi.org/10.1086/117210 Adapted from David A. Minton's Swifter routine gr_vel2pseudovel.f90 Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real(kind=DP), intent(in), dimension(:) :: xh Heliocentric position vector real(kind=DP), intent(in), dimension(:) :: vh Heliocentric velocity vector real(kind=DP), intent(out), dimension(:) :: pv Pseudovelocity vector - see Saha & Tremain (1994), eq. (32) Called by proc~~gr_vel2pseudovel~~CalledByGraph proc~gr_vel2pseudovel gr_vel2pseudovel interface~gr_vel2pseudovel gr_vel2pseudovel interface~gr_vel2pseudovel->proc~gr_vel2pseudovel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gr_vel2pseudovel.html"},{"title":"gr_vh2pv_body – swiftest","text":"pure module subroutine gr_vh2pv_body(self, param) Interface → Wrapper function that converts from heliocentric velocity to pseudovelocity for Swiftest bodies Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Called by proc~~gr_vh2pv_body~~CalledByGraph proc~gr_vh2pv_body gr_vh2pv_body interface~gr_vh2pv_body gr_vh2pv_body interface~gr_vh2pv_body->proc~gr_vh2pv_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gr_vh2pv_body.html"},{"title":"discard_system – swiftest","text":"module subroutine discard_system(self, param) Interface → Calls the discard methods for each body class and then the write method if any discards were detected Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Called by proc~~discard_system~~CalledByGraph proc~discard_system discard_system interface~discard_system discard_system interface~discard_system->proc~discard_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/discard_system.html"},{"title":"discard_pl – swiftest","text":"module subroutine discard_pl(self, system, param) Interface → Placeholder method for discarding massive bodies. This method does nothing except to ensure that the discard flag is set to false. \n  This method is intended to be overridden by more advanced integrators. Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameter Called by proc~~discard_pl~~CalledByGraph proc~discard_pl discard_pl interface~discard_pl discard_pl interface~discard_pl->proc~discard_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/discard_pl.html"},{"title":"discard_tp – swiftest","text":"module subroutine discard_tp(self, system, param) Interface → Check to see if particles should be discarded based on their positions relative to the massive bodies Adapted from David E. Kaufmann's Swifter routine: discard.f90\n Adapted from Hal Levison's Swift routine discard. Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameter Called by proc~~discard_tp~~CalledByGraph proc~discard_tp discard_tp interface~discard_tp discard_tp interface~discard_tp->proc~discard_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/discard_tp.html"},{"title":"helio_step_system – swiftest","text":"module subroutine helio_step_system(self, param, t, dt) Interface → Step massive bodies and and active test particles ahead in heliocentric coordinates. Currently there's no difference between this and the WHM system stepper, so this is just\n a wrapper function to keep the method calls consistent for inherited types. Adapted from Hal Levison's Swift routine step_kdk.f\n Adapted from David E. Kaufmann's Swifter routine helio_step.f90 Arguments Type Intent Optional Attributes Name class( helio_nbody_system ), intent(inout) :: self Helio nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize Calls proc~~helio_step_system~~CallsGraph proc~helio_step_system helio_step_system whm_step_system whm_step_system proc~helio_step_system->whm_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helio_step_system~~CalledByGraph proc~helio_step_system helio_step_system interface~helio_step_system helio_step_system interface~helio_step_system->proc~helio_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_step_system.html"},{"title":"helio_step_pl – swiftest","text":"module subroutine helio_step_pl(self, system, param, t, dt) Interface → Step massive bodies ahead Democratic Heliocentric method Adapted from David E. Kaufmann's Swifter helio_step_pl.f90\n Adapted from Hal Levison's Swift routine helio_step_pl.f Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nboody system class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize Called by proc~~helio_step_pl~~CalledByGraph proc~helio_step_pl helio_step_pl interface~helio_step_pl helio_step_pl interface~helio_step_pl->proc~helio_step_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_step_pl.html"},{"title":"helio_step_tp – swiftest","text":"module subroutine helio_step_tp(self, system, param, t, dt) Interface → Step active test particles ahead using Democratic Heliocentric method Adapted from David E. Kaufmann's Swifter routine helio_step_tp.f90\n Adapted from Hal Levison's Swift routine helio_step_tp.f Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nboody system class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize Called by proc~~helio_step_tp~~CalledByGraph proc~helio_step_tp helio_step_tp interface~helio_step_tp helio_step_tp interface~helio_step_tp->proc~helio_step_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_step_tp.html"},{"title":"helio_gr_kick_getacch_pl – swiftest","text":"module subroutine helio_gr_kick_getacch_pl(self, param) Interface → Compute relativisitic accelerations of massive bodies\n    Based on Saha & Tremaine (1994) Eq. 28 Adapted from David A. Minton's Swifter routine routine gr_whm_kick_getacch.f90 Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters Calls proc~~helio_gr_kick_getacch_pl~~CallsGraph proc~helio_gr_kick_getacch_pl helio_gr_kick_getacch_pl gr_kick_getacch gr_kick_getacch proc~helio_gr_kick_getacch_pl->gr_kick_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helio_gr_kick_getacch_pl~~CalledByGraph proc~helio_gr_kick_getacch_pl helio_gr_kick_getacch_pl interface~helio_gr_kick_getacch_pl helio_gr_kick_getacch_pl interface~helio_gr_kick_getacch_pl->proc~helio_gr_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_gr_kick_getacch_pl.html"},{"title":"helio_gr_kick_getacch_tp – swiftest","text":"module subroutine helio_gr_kick_getacch_tp(self, param) Interface → Compute relativisitic accelerations of test particles\n    Based on Saha & Tremaine (1994) Eq. 28 Adapted from David A. Minton's Swifter routine routine gr_helio_kick_getacch.f90 Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters Calls proc~~helio_gr_kick_getacch_tp~~CallsGraph proc~helio_gr_kick_getacch_tp helio_gr_kick_getacch_tp gr_kick_getacch gr_kick_getacch proc~helio_gr_kick_getacch_tp->gr_kick_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helio_gr_kick_getacch_tp~~CalledByGraph proc~helio_gr_kick_getacch_tp helio_gr_kick_getacch_tp interface~helio_gr_kick_getacch_tp helio_gr_kick_getacch_tp interface~helio_gr_kick_getacch_tp->proc~helio_gr_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_gr_kick_getacch_tp.html"},{"title":"helio_gr_p4_pl – swiftest","text":"pure module subroutine helio_gr_p4_pl(self, param, dt) Interface → Position kick to massive bodies due to p**4 term in the post-Newtonian correction\n    Based on Saha & Tremaine (1994) Eq. 28 Adapted from David A. Minton's Swifter routine routine gr_helio_p4.f90 Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size Calls proc~~helio_gr_p4_pl~~CallsGraph proc~helio_gr_p4_pl helio_gr_p4_pl gr_p4_pos_kick gr_p4_pos_kick proc~helio_gr_p4_pl->gr_p4_pos_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helio_gr_p4_pl~~CalledByGraph proc~helio_gr_p4_pl helio_gr_p4_pl interface~helio_gr_p4_pl helio_gr_p4_pl interface~helio_gr_p4_pl->proc~helio_gr_p4_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_gr_p4_pl.html"},{"title":"helio_gr_p4_tp – swiftest","text":"pure module subroutine helio_gr_p4_tp(self, param, dt) Interface → Position kick to test particles due to p**4 term in the post-Newtonian correction\n    Based on Saha & Tremaine (1994) Eq. 28 Adapted from David A. Minton's Swifter routine routine gr_helio_p4.f90 Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size Calls proc~~helio_gr_p4_tp~~CallsGraph proc~helio_gr_p4_tp helio_gr_p4_tp gr_p4_pos_kick gr_p4_pos_kick proc~helio_gr_p4_tp->gr_p4_pos_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helio_gr_p4_tp~~CalledByGraph proc~helio_gr_p4_tp helio_gr_p4_tp interface~helio_gr_p4_tp helio_gr_p4_tp interface~helio_gr_p4_tp->proc~helio_gr_p4_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_gr_p4_tp.html"},{"title":"helio_kick_getacch_pl – swiftest","text":"module subroutine helio_kick_getacch_pl(self, system, param, t, lbeg) Interface → Compute heliocentric accelerations of massive bodies Adapted from David E. Kaufmann's Swifter routine helio_kick_getacch.f90\n Adapted from Hal Levison's Swift routine helio_kick_getacch.f Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step Called by proc~~helio_kick_getacch_pl~~CalledByGraph proc~helio_kick_getacch_pl helio_kick_getacch_pl interface~helio_kick_getacch_pl helio_kick_getacch_pl interface~helio_kick_getacch_pl->proc~helio_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_kick_getacch_pl.html"},{"title":"helio_kick_getacch_tp – swiftest","text":"module subroutine helio_kick_getacch_tp(self, system, param, t, lbeg) Interface → Compute heliocentric accelerations of test particles Adapted from David E. Kaufmann's Swifter routine helio_kick_getacch_tp.f90\n Adapted from Hal Levison's Swift routine helio_kick_getacch_tp.f Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step Called by proc~~helio_kick_getacch_tp~~CalledByGraph proc~helio_kick_getacch_tp helio_kick_getacch_tp interface~helio_kick_getacch_tp helio_kick_getacch_tp interface~helio_kick_getacch_tp->proc~helio_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_kick_getacch_tp.html"},{"title":"helio_kick_vb_pl – swiftest","text":"module subroutine helio_kick_vb_pl(self, system, param, t, dt, lbeg) Interface → Kick barycentric velocities of bodies Adapted from Martin Duncan and Hal Levison's Swift routine kickvh.f \n Adapted from David E. Kaufmann's Swifter routine helio_kick_vb.f90 Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. Called by proc~~helio_kick_vb_pl~~CalledByGraph proc~helio_kick_vb_pl helio_kick_vb_pl interface~helio_kick_vb_pl helio_kick_vb_pl interface~helio_kick_vb_pl->proc~helio_kick_vb_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_kick_vb_pl.html"},{"title":"helio_kick_vb_tp – swiftest","text":"module subroutine helio_kick_vb_tp(self, system, param, t, dt, lbeg) Interface → Kick barycentric velocities of bodies Adapted from Martin Duncan and Hal Levison's Swift routine kickvh_tp.f\n Adapted from David E. Kaufmann's Swifter routine helio_kick_vb_tp.f90 Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. Called by proc~~helio_kick_vb_tp~~CalledByGraph proc~helio_kick_vb_tp helio_kick_vb_tp interface~helio_kick_vb_tp helio_kick_vb_tp interface~helio_kick_vb_tp->proc~helio_kick_vb_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_kick_vb_tp.html"},{"title":"helio_coord_vb2vh_pl – swiftest","text":"module subroutine helio_coord_vb2vh_pl(self, cb) Interface → Convert massive bodies from barycentric to heliocentric coordinates (velocity only) Adapted from David E. Kaufmann's Swifter routine coord_vb2vh.f90 \n Adapted from Hal Levison's Swift routine coord_vb2vh.f Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object Called by proc~~helio_coord_vb2vh_pl~~CalledByGraph proc~helio_coord_vb2vh_pl helio_coord_vb2vh_pl interface~helio_coord_vb2vh_pl helio_coord_vb2vh_pl interface~helio_coord_vb2vh_pl->proc~helio_coord_vb2vh_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_coord_vb2vh_pl.html"},{"title":"helio_coord_vb2vh_tp – swiftest","text":"module subroutine helio_coord_vb2vh_tp(self, vbcb) Interface → Convert test particles from barycentric to heliocentric coordinates (velocity only) Adapted from David E. Kaufmann's Swifter routine coord_vb2vh_tp.f90 \n Adapted from Hal Levison's Swift routine coord_vb2h_tp.f Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body Called by proc~~helio_coord_vb2vh_tp~~CalledByGraph proc~helio_coord_vb2vh_tp helio_coord_vb2vh_tp interface~helio_coord_vb2vh_tp helio_coord_vb2vh_tp interface~helio_coord_vb2vh_tp->proc~helio_coord_vb2vh_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_coord_vb2vh_tp.html"},{"title":"helio_coord_vh2vb_pl – swiftest","text":"module subroutine helio_coord_vh2vb_pl(self, cb) Interface → Convert massive bodies from heliocentric to barycentric coordinates (velocity only) Adapted from David E. Kaufmann's Swifter routine coord_vh2vb.f90 \n Adapted from Hal Levison's Swift routine coord_vh2b.f Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object Called by proc~~helio_coord_vh2vb_pl~~CalledByGraph proc~helio_coord_vh2vb_pl helio_coord_vh2vb_pl interface~helio_coord_vh2vb_pl helio_coord_vh2vb_pl interface~helio_coord_vh2vb_pl->proc~helio_coord_vh2vb_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_coord_vh2vb_pl.html"},{"title":"helio_coord_vh2vb_tp – swiftest","text":"module subroutine helio_coord_vh2vb_tp(self, vbcb) Interface → Convert test particles from heliocentric to barycentric coordinates (velocity only) Adapted from David E. Kaufmann's Swifter routine coord_vh2vb_tp.f90\n Adapted from Hal Levison's Swift routine coord_vh2b_tp.f Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body Called by proc~~helio_coord_vh2vb_tp~~CalledByGraph proc~helio_coord_vh2vb_tp helio_coord_vh2vb_tp interface~helio_coord_vh2vb_tp helio_coord_vh2vb_tp interface~helio_coord_vh2vb_tp->proc~helio_coord_vh2vb_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_coord_vh2vb_tp.html"},{"title":"helio_drift_body – swiftest","text":"module subroutine helio_drift_body(self, system, param, dt) Interface → Loop through bodies and call Danby drift routine on democratic heliocentric coordinates Adapted from David E. Kaufmann's Swifter routine helio_drift.f90\n Adapted from Hal Levison's Swift routine drift.f Arguments Type Intent Optional Attributes Name class(swiftest_body), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize Calls proc~~helio_drift_body~~CallsGraph proc~helio_drift_body helio_drift_body drift_all drift_all proc~helio_drift_body->drift_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helio_drift_body~~CalledByGraph proc~helio_drift_body helio_drift_body interface~helio_drift_body helio_drift_body interface~helio_drift_body->proc~helio_drift_body proc~helio_drift_tp helio_drift_tp proc~helio_drift_tp->interface~helio_drift_body proc~helio_drift_pl helio_drift_pl proc~helio_drift_pl->interface~helio_drift_body interface~helio_drift_tp helio_drift_tp interface~helio_drift_tp->proc~helio_drift_tp interface~helio_drift_pl helio_drift_pl interface~helio_drift_pl->proc~helio_drift_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_drift_body.html"},{"title":"helio_drift_pl – swiftest","text":"module subroutine helio_drift_pl(self, system, param, dt) Interface → Wrapper function used to call the body drift routine from a helio_pl structure Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize Calls proc~~helio_drift_pl~~CallsGraph proc~helio_drift_pl helio_drift_pl interface~helio_drift_body helio_drift_body proc~helio_drift_pl->interface~helio_drift_body proc~helio_drift_body helio_drift_body interface~helio_drift_body->proc~helio_drift_body drift_all drift_all proc~helio_drift_body->drift_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helio_drift_pl~~CalledByGraph proc~helio_drift_pl helio_drift_pl interface~helio_drift_pl helio_drift_pl interface~helio_drift_pl->proc~helio_drift_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_drift_pl.html"},{"title":"helio_drift_tp – swiftest","text":"module subroutine helio_drift_tp(self, system, param, dt) Interface → Wrapper function used to call the body drift routine from a helio_pl structure Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize Calls proc~~helio_drift_tp~~CallsGraph proc~helio_drift_tp helio_drift_tp interface~helio_drift_body helio_drift_body proc~helio_drift_tp->interface~helio_drift_body proc~helio_drift_body helio_drift_body interface~helio_drift_body->proc~helio_drift_body drift_all drift_all proc~helio_drift_body->drift_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helio_drift_tp~~CalledByGraph proc~helio_drift_tp helio_drift_tp interface~helio_drift_tp helio_drift_tp interface~helio_drift_tp->proc~helio_drift_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_drift_tp.html"},{"title":"helio_drift_linear_pl – swiftest","text":"module subroutine helio_drift_linear_pl(self, cb, dt, lbeg) Interface → Perform linear drift of massive bodies due to barycentric momentum of Sun Adapted from David E. Kaufmann's Swifter routine helio_lindrift.f90\n Adapted from Hal Levison's Swift routine helio_lindrift.f Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( helio_cb ), intent(inout) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step Called by proc~~helio_drift_linear_pl~~CalledByGraph proc~helio_drift_linear_pl helio_drift_linear_pl interface~helio_drift_linear_pl helio_drift_linear_pl interface~helio_drift_linear_pl->proc~helio_drift_linear_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_drift_linear_pl.html"},{"title":"helio_drift_linear_tp – swiftest","text":"module subroutine helio_drift_linear_tp(self, cb, dt, lbeg) Interface → Perform linear drift of test particles due to barycentric momentum of Sun\n New vectorized version included Adapted from David E. Kaufmann's Swifter routine helio_lindrift_tp.f90\n Adapted from Hal Levison's Swift routine helio_lindrift_tp.f Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particleb object class( helio_cb ), intent(in) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step Called by proc~~helio_drift_linear_tp~~CalledByGraph proc~helio_drift_linear_tp helio_drift_linear_tp interface~helio_drift_linear_tp helio_drift_linear_tp interface~helio_drift_linear_tp->proc~helio_drift_linear_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_drift_linear_tp.html"},{"title":"io_get_args – swiftest","text":"module function io_get_args(integrator, param_file_name) result(ierr) Interface → Reads in the name of the parameter file from command line arguments. Arguments Type Intent Optional Attributes Name integer(kind=I4B) :: integrator Symbolic code of the requested integrator character(len=:), allocatable :: param_file_name Name of the input parameters file Return Value integer(kind=I4B) I/O error code Calls proc~~io_get_args~~CallsGraph proc~io_get_args io_get_args interface~util_version util_version proc~io_get_args->interface~util_version interface~io_toupper io_toupper proc~io_get_args->interface~io_toupper interface~util_exit util_exit proc~io_get_args->interface~util_exit proc~util_version util_version interface~util_version->proc~util_version proc~io_toupper io_toupper interface~io_toupper->proc~io_toupper proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_get_args~~CalledByGraph proc~io_get_args io_get_args interface~io_get_args io_get_args interface~io_get_args->proc~io_get_args Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_get_args.html"},{"title":"io_get_token – swiftest","text":"module function io_get_token(buffer, ifirst, ilast, ierr) result(token) Interface → Retrieves a character token from an input string. Here a token is defined as any set of contiguous non-blank characters not \n beginning with or containing \"!\". If \"!\" is present, any remaining part of the buffer including the \"!\" is ignored Adapted from David E. Kaufmann's Swifter routine io_get_token.f90\n Bad input\n No valid token Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: buffer Input string buffer integer(kind=I4B), intent(inout) :: ifirst Index of the buffer at which to start the search for a token integer(kind=I4B), intent(out) :: ilast Index of the buffer at the end of the returned token integer(kind=I4B), intent(out) :: ierr Error code Return Value character(len=:),\n  allocatable Returned token string Called by proc~~io_get_token~~CalledByGraph proc~io_get_token io_get_token interface~io_get_token io_get_token interface~io_get_token->proc~io_get_token proc~io_param_reader io_param_reader proc~io_param_reader->interface~io_get_token interface~io_param_reader io_param_reader interface~io_param_reader->proc~io_param_reader Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_get_token.html"},{"title":"io_conservation_report – swiftest","text":"module subroutine io_conservation_report(self, param, lterminal) Interface → Reports the current state of energy, mass, and angular momentum conservation in a run Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Input colleciton of user-defined parameters logical, intent(in) :: lterminal Indicates whether to output information to the terminal screen Calls proc~~io_conservation_report~~CallsGraph proc~io_conservation_report io_conservation_report ltot_orig ltot_orig proc~io_conservation_report->ltot_orig lescape lescape proc~io_conservation_report->lescape lorbit_orig lorbit_orig proc~io_conservation_report->lorbit_orig lspin_orig lspin_orig proc~io_conservation_report->lspin_orig Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_conservation_report~~CalledByGraph proc~io_conservation_report io_conservation_report interface~io_conservation_report io_conservation_report interface~io_conservation_report->proc~io_conservation_report Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_conservation_report.html"},{"title":"io_dump_param – swiftest","text":"module subroutine io_dump_param(self, param_file_name) Interface → Dump integration parameters to file Adapted from David E. Kaufmann's Swifter routine io_dump_param.f90\n Adapted from Martin Duncan's Swift routine io_dump_param.f\n todo: Currently this procedure does not work in user-defined derived-type input mode \n    due to compiler incompatabilities Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Output collection of parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in) Calls proc~~io_dump_param~~CallsGraph proc~io_dump_param io_dump_param interface~util_exit util_exit proc~io_dump_param->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_dump_param~~CalledByGraph proc~io_dump_param io_dump_param interface~io_dump_param io_dump_param interface~io_dump_param->proc~io_dump_param Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_dump_param.html"},{"title":"io_dump_swiftest – swiftest","text":"module subroutine io_dump_swiftest(self, param) Interface → Dump massive body data to files Adapted from David E. Kaufmann's Swifter routine: io_dump_pl.f90 and io_dump_tp.f90\n Adapted from Hal Levison's Swift routine io_dump_pl.f and io_dump_tp.f Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Calls proc~~io_dump_swiftest~~CallsGraph proc~io_dump_swiftest io_dump_swiftest interface~util_exit util_exit proc~io_dump_swiftest->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_dump_swiftest~~CalledByGraph proc~io_dump_swiftest io_dump_swiftest interface~io_dump_swiftest io_dump_swiftest interface~io_dump_swiftest->proc~io_dump_swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_dump_swiftest.html"},{"title":"io_dump_system – swiftest","text":"module subroutine io_dump_system(self, param) Interface → Dumps the state of the system to files in case the simulation is interrupted.\n As a safety mechanism, there are two dump files that are written in alternating order\n so that if a dump file gets corrupted during writing, the user can restart from the older one. Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Calls proc~~io_dump_system~~CallsGraph proc~io_dump_system io_dump_system dump_param_file dump_param_file proc~io_dump_system->dump_param_file dump_cb_file dump_cb_file proc~io_dump_system->dump_cb_file dump_pl_file dump_pl_file proc~io_dump_system->dump_pl_file dump_tp_file dump_tp_file proc~io_dump_system->dump_tp_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_dump_system~~CalledByGraph proc~io_dump_system io_dump_system interface~io_dump_system io_dump_system interface~io_dump_system->proc~io_dump_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_dump_system.html"},{"title":"io_param_reader – swiftest","text":"module subroutine io_param_reader(self, unit, iotype, v_list, iostat, iomsg) Interface → Read in parameters for the integration\n Currently this procedure does not work in user-defined derived-type input mode \n    e.g. read(unit,'(DT)') param \n as the newline characters are ignored in the input file when compiled in ifort. Adapted from David E. Kaufmann's Swifter routine io_init_param.f90\n Adapted from Martin Duncan's Swift routine io_init_param.f\n Do basic sanity checks on the input values Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Collection of parameters integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) The first element passes the integrator code to the reader integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 Calls proc~~io_param_reader~~CallsGraph proc~io_param_reader io_param_reader interface~io_toupper io_toupper proc~io_param_reader->interface~io_toupper interface~io_get_token io_get_token proc~io_param_reader->interface~io_get_token proc~io_toupper io_toupper interface~io_toupper->proc~io_toupper proc~io_get_token io_get_token interface~io_get_token->proc~io_get_token Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_param_reader~~CalledByGraph proc~io_param_reader io_param_reader interface~io_param_reader io_param_reader interface~io_param_reader->proc~io_param_reader Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_param_reader.html"},{"title":"io_param_writer – swiftest","text":"module subroutine io_param_writer(self, unit, iotype, v_list, iostat, iomsg) Interface → Dump integration parameters to file Adapted from David E. Kaufmann's Swifter routine io_dump_param.f90\n Adapted from Martin Duncan's Swift routine io_dump_param.f Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Collection of parameters integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) Not used in this procedure integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 Called by proc~~io_param_writer~~CalledByGraph proc~io_param_writer io_param_writer interface~io_param_writer io_param_writer interface~io_param_writer->proc~io_param_writer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_param_writer.html"},{"title":"io_read_body_in – swiftest","text":"module subroutine io_read_body_in(self, param) Interface → Read in either test particle or massive body data Adapted from David E. Kaufmann's Swifter routine swiftest_init_pl.f90 and swiftest_init_tp.f90\n Adapted from Martin Duncan's Swift routine swiftest_init_pl.f and swiftest_init_tp.f Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Calls proc~~io_read_body_in~~CallsGraph proc~io_read_body_in io_read_body_in interface~util_exit util_exit proc~io_read_body_in->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_read_body_in~~CalledByGraph proc~io_read_body_in io_read_body_in interface~io_read_body_in io_read_body_in interface~io_read_body_in->proc~io_read_body_in Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_body_in.html"},{"title":"io_read_cb_in – swiftest","text":"module subroutine io_read_cb_in(self, param) Interface → Reads in central body data Adapted from David E. Kaufmann's Swifter routine swiftest_init_pl.f90\n Adapted from Martin Duncan's Swift routine swiftest_init_pl.f Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self class( swiftest_parameters ), intent(inout) :: param Calls proc~~io_read_cb_in~~CallsGraph proc~io_read_cb_in io_read_cb_in interface~util_exit util_exit proc~io_read_cb_in->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_read_cb_in~~CalledByGraph proc~io_read_cb_in io_read_cb_in interface~io_read_cb_in io_read_cb_in interface~io_read_cb_in->proc~io_read_cb_in Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_cb_in.html"},{"title":"io_read_frame_body – swiftest","text":"module subroutine io_read_frame_body(self, iu, param, form, ierr) Interface → Reads a frame of output of either test particle or massive body data from a binary output file Adapted from David E. Kaufmann's Swifter routine  io_read_frame.f90\n Adapted from Hal Levison's Swift routine io_read_frame.F Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code Calls proc~~io_read_frame_body~~CallsGraph proc~io_read_frame_body io_read_frame_body interface~util_exit util_exit proc~io_read_frame_body->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_read_frame_body~~CalledByGraph proc~io_read_frame_body io_read_frame_body interface~io_read_frame_body io_read_frame_body interface~io_read_frame_body->proc~io_read_frame_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_frame_body.html"},{"title":"io_read_frame_cb – swiftest","text":"module subroutine io_read_frame_cb(self, iu, param, form, ierr) Interface → Reads a frame of output of central body data to the binary output file Adapted from David E. Kaufmann's Swifter routine  io_read_frame.f90\n Adapted from Hal Levison's Swift routine io_read_frame.F Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error cod Calls proc~~io_read_frame_cb~~CallsGraph proc~io_read_frame_cb io_read_frame_cb interface~util_exit util_exit proc~io_read_frame_cb->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_read_frame_cb~~CalledByGraph proc~io_read_frame_cb io_read_frame_cb interface~io_read_frame_cb io_read_frame_cb interface~io_read_frame_cb->proc~io_read_frame_cb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_frame_cb.html"},{"title":"io_read_frame_system – swiftest","text":"module subroutine io_read_frame_system(self, iu, param, form, ierr) Interface → Read a frame (header plus records for each massive body and active test particle) from a output binary file Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code Calls proc~~io_read_frame_system~~CallsGraph proc~io_read_frame_system io_read_frame_system proc~io_read_hdr io_read_hdr proc~io_read_frame_system->proc~io_read_hdr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_read_frame_system~~CalledByGraph proc~io_read_frame_system io_read_frame_system interface~io_read_frame_system io_read_frame_system interface~io_read_frame_system->proc~io_read_frame_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_frame_system.html"},{"title":"io_read_param_in – swiftest","text":"module subroutine io_read_param_in(self, param_file_name) Interface → Read in parameters for the integration Adapted from David E. Kaufmann's Swifter routine io_init_param.f90\n Adapted from Martin Duncan's Swift routine io_init_param.f\n todo: Currently this procedure does not work in user-defined derived-type input mode \n    as the newline characters are ignored in the input file when compiled in ifort. Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Current run configuration parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in) Calls proc~~io_read_param_in~~CallsGraph proc~io_read_param_in io_read_param_in interface~util_exit util_exit proc~io_read_param_in->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_read_param_in~~CalledByGraph proc~io_read_param_in io_read_param_in interface~io_read_param_in io_read_param_in interface~io_read_param_in->proc~io_read_param_in Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_param_in.html"},{"title":"io_toupper – swiftest","text":"module subroutine io_toupper(string) Interface → Convert string to uppercase Adapted from David E. Kaufmann's Swifter routine: util_toupper.f90 Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string String to make upper case Called by proc~~io_toupper~~CalledByGraph proc~io_toupper io_toupper interface~io_toupper io_toupper interface~io_toupper->proc~io_toupper proc~io_param_reader io_param_reader proc~io_param_reader->interface~io_toupper proc~io_get_args io_get_args proc~io_get_args->interface~io_toupper interface~io_param_reader io_param_reader interface~io_param_reader->proc~io_param_reader interface~io_get_args io_get_args interface~io_get_args->proc~io_get_args Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_toupper.html"},{"title":"io_write_discard – swiftest","text":"module subroutine io_write_discard(self, param) Interface → Write out information about discarded test particle Adapted from David E. Kaufmann's Swifter routine  io_discard_write.f90\n Adapted from Hal Levison's Swift routine io_discard_write.f Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~io_write_discard~~CallsGraph proc~io_write_discard io_write_discard interface~util_exit util_exit proc~io_write_discard->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_write_discard~~CalledByGraph proc~io_write_discard io_write_discard interface~io_write_discard io_write_discard interface~io_write_discard->proc~io_write_discard Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_write_discard.html"},{"title":"io_write_encounter – swiftest","text":"module subroutine io_write_encounter(t, name1, name2, mass1, mass2, radius1, radius2, xh1, xh2, vh1, vh2, enc_out, out_type) Interface → Write close encounter data to output binary files\n  There is no direct file output from this subroutine Adapted from David E. Kaufmann's Swifter routine: io_write_encounter.f90\n Adapted from Hal Levison's Swift routine io_write_encounter.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: name1 integer(kind=I4B), intent(in) :: name2 real(kind=DP), intent(in) :: mass1 real(kind=DP), intent(in) :: mass2 real(kind=DP), intent(in) :: radius1 real(kind=DP), intent(in) :: radius2 real(kind=DP), intent(in), dimension(:) :: xh1 real(kind=DP), intent(in), dimension(:) :: xh2 real(kind=DP), intent(in), dimension(:) :: vh1 real(kind=DP), intent(in), dimension(:) :: vh2 character(len=*), intent(in) :: enc_out character(len=*), intent(in) :: out_type Calls proc~~io_write_encounter~~CallsGraph proc~io_write_encounter io_write_encounter interface~util_exit util_exit proc~io_write_encounter->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_write_encounter~~CalledByGraph proc~io_write_encounter io_write_encounter interface~io_write_encounter io_write_encounter interface~io_write_encounter->proc~io_write_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_write_encounter.html"},{"title":"io_write_frame_body – swiftest","text":"module subroutine io_write_frame_body(self, iu, param) Interface → Write a frame of output of either test particle or massive body data to the binary output file\n    Note: If outputting to orbital elements, but sure that the conversion is done prior to calling this method Adapted from David E. Kaufmann's Swifter routine  io_write_frame.f90\n Adapted from Hal Levison's Swift routine io_write_frame.F Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest particle object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Called by proc~~io_write_frame_body~~CalledByGraph proc~io_write_frame_body io_write_frame_body interface~io_write_frame_body io_write_frame_body interface~io_write_frame_body->proc~io_write_frame_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_write_frame_body.html"},{"title":"io_write_frame_cb – swiftest","text":"module subroutine io_write_frame_cb(self, iu, param) Interface → Write a frame of output of central body data to the binary output file Adapted from David E. Kaufmann's Swifter routine  io_write_frame.f90\n Adapted from Hal Levison's Swift routine io_write_frame.F Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Called by proc~~io_write_frame_cb~~CalledByGraph proc~io_write_frame_cb io_write_frame_cb interface~io_write_frame_cb io_write_frame_cb interface~io_write_frame_cb->proc~io_write_frame_cb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_write_frame_cb.html"},{"title":"io_write_frame_system – swiftest","text":"module subroutine io_write_frame_system(self, iu, param) Interface → Write a frame (header plus records for each massive body and active test particle) to output binary file\n There is no direct file output from this subroutine Adapted from David E. Kaufmann's Swifter routine  io_write_frame.f90\n Adapted from Hal Levison's Swift routine io_write_frame.F Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~io_write_frame_system~~CallsGraph proc~io_write_frame_system io_write_frame_system interface~util_exit util_exit proc~io_write_frame_system->interface~util_exit proc~io_write_hdr io_write_hdr proc~io_write_frame_system->proc~io_write_hdr proc~util_exit util_exit interface~util_exit->proc~util_exit proc~io_write_hdr->interface~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_write_frame_system~~CalledByGraph proc~io_write_frame_system io_write_frame_system interface~io_write_frame_system io_write_frame_system interface~io_write_frame_system->proc~io_write_frame_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_write_frame_system.html"},{"title":"setup_construct_system – swiftest","text":"module subroutine setup_construct_system(system, param) Interface → Constructor for a Swiftest nbody system. Creates the nbody system object based on the user-input integrator Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout), allocatable :: system Swiftest system object class( swiftest_parameters ), intent(in) :: param Swiftest parameters Calls proc~~setup_construct_system~~CallsGraph proc~setup_construct_system setup_construct_system interface~util_exit util_exit proc~setup_construct_system->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~setup_construct_system~~CalledByGraph proc~setup_construct_system setup_construct_system interface~setup_construct_system setup_construct_system interface~setup_construct_system->proc~setup_construct_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/setup_construct_system.html"},{"title":"setup_encounter – swiftest","text":"module subroutine setup_encounter(self, n) Interface → A constructor that sets the number of encounters and allocates and initializes all arrays Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for Called by proc~~setup_encounter~~CalledByGraph proc~setup_encounter setup_encounter interface~setup_encounter setup_encounter interface~setup_encounter->proc~setup_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/setup_encounter.html"},{"title":"setup_initialize_system – swiftest","text":"module subroutine setup_initialize_system(self, param) Interface → Wrapper method to initialize a basic Swiftest nbody system from files Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Called by proc~~setup_initialize_system~~CalledByGraph proc~setup_initialize_system setup_initialize_system interface~setup_initialize_system setup_initialize_system interface~setup_initialize_system->proc~setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/setup_initialize_system.html"},{"title":"setup_body – swiftest","text":"module subroutine setup_body(self, n, param) Interface → Constructor for base Swiftest particle class. Allocates space for all particles and\n initializes all components with a value.\n Note: Timing tests indicate that (NDIM, n) is more efficient than (NDIM, n) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter Called by proc~~setup_body~~CalledByGraph proc~setup_body setup_body interface~setup_body setup_body interface~setup_body->proc~setup_body proc~setup_pl setup_pl proc~setup_pl->interface~setup_body proc~setup_tp setup_tp proc~setup_tp->interface~setup_body interface~setup_tp setup_tp interface~setup_tp->proc~setup_tp interface~setup_pl setup_pl interface~setup_pl->proc~setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/setup_body.html"},{"title":"setup_pl – swiftest","text":"module subroutine setup_pl(self, n, param) Interface → Constructor for base Swiftest massive body class. Allocates space for all particles and\n initializes all components with a value. \n Call allocation method for parent class\n The parent class here is the abstract swiftest_body class, so we can't use the type-bound procedure Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter Calls proc~~setup_pl~~CallsGraph proc~setup_pl setup_pl interface~setup_body setup_body proc~setup_pl->interface~setup_body proc~setup_body setup_body interface~setup_body->proc~setup_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~setup_pl~~CalledByGraph proc~setup_pl setup_pl interface~setup_pl setup_pl interface~setup_pl->proc~setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/setup_pl.html"},{"title":"setup_tp – swiftest","text":"module subroutine setup_tp(self, n, param) Interface → Constructor for base Swiftest test particle particle class. Allocates space for \n all particles and initializes all components with a value. \n Call allocation method for parent class\n The parent class here is the abstract swiftest_body class, so we can't use the type-bound procedure Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter Calls proc~~setup_tp~~CallsGraph proc~setup_tp setup_tp interface~setup_body setup_body proc~setup_tp->interface~setup_body proc~setup_body setup_body interface~setup_body->proc~setup_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~setup_tp~~CalledByGraph proc~setup_tp setup_tp interface~setup_tp setup_tp interface~setup_tp->proc~setup_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/setup_tp.html"},{"title":"eucl_dist_index_plpl – swiftest","text":"module subroutine eucl_dist_index_plpl(self) Interface → Turns i,j indices into k index for use in the Euclidean distance matrix Reference: Mélodie Angeletti, Jean-Marie Bonny, Jonas Koko. Parallel Euclidean distance matrix computation on big datasets *. 2019. hal-0204751 Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body objec Called by proc~~eucl_dist_index_plpl~~CalledByGraph proc~eucl_dist_index_plpl eucl_dist_index_plpl interface~eucl_dist_index_plpl eucl_dist_index_plpl interface~eucl_dist_index_plpl->proc~eucl_dist_index_plpl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/eucl_dist_index_plpl.html"},{"title":"user_kick_getacch_body – swiftest","text":"module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Interface → Add user-supplied heliocentric accelerations to planets. Adapted from David E. Kaufmann's Swifter routine whm_user_kick_getacch.f90 Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters user parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the ste Called by proc~~user_kick_getacch_body~~CalledByGraph proc~user_kick_getacch_body user_kick_getacch_body interface~user_kick_getacch_body user_kick_getacch_body interface~user_kick_getacch_body->proc~user_kick_getacch_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/user_kick_getacch_body.html"},{"title":"drift_body – swiftest","text":"module subroutine drift_body(self, system, param, dt) Interface → Loop bodies and call Danby drift routine on the heliocentric position and velocities. Adapted from Hal Levison's Swift routine drift_tp.f \n Adapted from David E. Kaufmann's Swifter routine whm_drift_tp.f90 Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize Calls proc~~drift_body~~CallsGraph proc~drift_body drift_body interface~drift_all drift_all proc~drift_body->interface~drift_all proc~drift_all drift_all interface~drift_all->proc~drift_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~drift_body~~CalledByGraph proc~drift_body drift_body interface~drift_body drift_body interface~drift_body->proc~drift_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_body.html"},{"title":"drift_all – swiftest","text":"pure module subroutine drift_all(mu, x, v, n, param, dt, mask, iflag) Interface → Loop bodies and call Danby drift routine on all bodies for the given position and velocity vector. Adapted from Hal Levison's Swift routine drift_tp.f \n Adapted from David E. Kaufmann's Swifter routine whm_drift_tp.f9 Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: mu Vector of gravitational constants real(kind=DP), intent(inout), dimension(:,:) :: x Position and velocity vectors real(kind=DP), intent(inout), dimension(:,:) :: v Position and velocity vectors integer(kind=I4B), intent(in) :: n number of bodies class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize logical, intent(in), dimension(:) :: mask Logical mask of size self%nbody that determines which bodies to drift. integer(kind=I4B), intent(out), dimension(:) :: iflag Vector of error flags. 0 means no problem Called by proc~~drift_all~~CalledByGraph proc~drift_all drift_all interface~drift_all drift_all interface~drift_all->proc~drift_all proc~drift_body drift_body proc~drift_body->interface~drift_all interface~drift_body drift_body interface~drift_body->proc~drift_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_all.html"},{"title":"drift_one – swiftest","text":"pure elemental module subroutine drift_one(mu, px, py, pz, vx, vy, vz, dt, iflag) Interface → Perform Danby drift for one body, redoing drift with smaller substeps if original accuracy is insufficient Adapted from David E. Kaufmann's Swifter routine routine drift_one.f90\n Adapted from Hal Levison and Martin Duncan's Swift routine drift_one.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body to drift real(kind=DP), intent(inout) :: px Position and velocity of body to drift real(kind=DP), intent(inout) :: py Position and velocity of body to drift real(kind=DP), intent(inout) :: pz Position and velocity of body to drift real(kind=DP), intent(inout) :: vx Position and velocity of body to drift real(kind=DP), intent(inout) :: vy Position and velocity of body to drift real(kind=DP), intent(inout) :: vz Position and velocity of body to drift real(kind=DP), intent(in) :: dt Step size integer(kind=I4B), intent(out) :: iflag iflag : error status flag for Danby drift (0 = OK, nonzero = ERROR) Called by proc~~drift_one~~CalledByGraph proc~drift_one drift_one interface~drift_one drift_one interface~drift_one->proc~drift_one Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_one.html"},{"title":"symba_util_append_arr_info – swiftest","text":"subroutine symba_util_append_arr_info(arr, source, nold, nsrc, lsource_mask) Append a single array of particle information type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name type( symba_particle_info ), intent(inout), dimension(:), allocatable :: arr Destination array type( symba_particle_info ), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~symba_util_append_arr_info~~CallsGraph proc~symba_util_append_arr_info symba_util_append_arr_info interface~util_resize util_resize proc~symba_util_append_arr_info->interface~util_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_append_arr_info.html"},{"title":"symba_util_append_arr_kin – swiftest","text":"subroutine symba_util_append_arr_kin(arr, source, nold, nsrc, lsource_mask) Append a single array of kinship type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: arr Destination array type( symba_kinship ), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~symba_util_append_arr_kin~~CallsGraph proc~symba_util_append_arr_kin symba_util_append_arr_kin interface~util_resize util_resize proc~symba_util_append_arr_kin->interface~util_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_append_arr_kin.html"},{"title":"symba_util_append_pl – swiftest","text":"module subroutine symba_util_append_pl(self, source, lsource_mask) Interface → Append components from one massive body object to another. \n This method will automatically resize the destination body if it is too small\n Arguments Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~symba_util_append_pl~~CallsGraph proc~symba_util_append_pl symba_util_append_pl interface~util_append util_append proc~symba_util_append_pl->interface~util_append util_exit util_exit proc~symba_util_append_pl->util_exit util_append_pl util_append_pl proc~symba_util_append_pl->util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_append_pl~~CalledByGraph proc~symba_util_append_pl symba_util_append_pl interface~symba_util_append_pl symba_util_append_pl interface~symba_util_append_pl->proc~symba_util_append_pl proc~symba_util_append_merger symba_util_append_merger proc~symba_util_append_merger->interface~symba_util_append_pl interface~symba_util_append_merger symba_util_append_merger interface~symba_util_append_merger->proc~symba_util_append_merger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_append_pl.html"},{"title":"symba_util_append_merger – swiftest","text":"module subroutine symba_util_append_merger(self, source, lsource_mask) Interface → Append components from one massive body object to another. \n This method will automatically resize the destination body if it is too small Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~symba_util_append_merger~~CallsGraph proc~symba_util_append_merger symba_util_append_merger interface~symba_util_append_pl symba_util_append_pl proc~symba_util_append_merger->interface~symba_util_append_pl interface~util_append util_append proc~symba_util_append_merger->interface~util_append util_exit util_exit proc~symba_util_append_merger->util_exit proc~symba_util_append_pl symba_util_append_pl interface~symba_util_append_pl->proc~symba_util_append_pl proc~symba_util_append_pl->interface~util_append proc~symba_util_append_pl->util_exit util_append_pl util_append_pl proc~symba_util_append_pl->util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_append_merger~~CalledByGraph proc~symba_util_append_merger symba_util_append_merger interface~symba_util_append_merger symba_util_append_merger interface~symba_util_append_merger->proc~symba_util_append_merger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_append_merger.html"},{"title":"symba_util_append_tp – swiftest","text":"module subroutine symba_util_append_tp(self, source, lsource_mask) Interface → Append components from test particle object to another. \n This method will automatically resize the destination body if it is too small\n Arguments Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~symba_util_append_tp~~CallsGraph proc~symba_util_append_tp symba_util_append_tp interface~util_append util_append proc~symba_util_append_tp->interface~util_append util_append_tp util_append_tp proc~symba_util_append_tp->util_append_tp util_exit util_exit proc~symba_util_append_tp->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_append_tp~~CalledByGraph proc~symba_util_append_tp symba_util_append_tp interface~symba_util_append_tp symba_util_append_tp interface~symba_util_append_tp->proc~symba_util_append_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_append_tp.html"},{"title":"symba_util_fill_arr_info – swiftest","text":"subroutine symba_util_fill_arr_info(keeps, inserts, lfill_list) Performs a fill operation on a single array of particle origin information types\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name type( symba_particle_info ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_particle_info ), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Contents None","tags":"","loc":"proc/symba_util_fill_arr_info.html"},{"title":"symba_util_fill_arr_kin – swiftest","text":"subroutine symba_util_fill_arr_kin(keeps, inserts, lfill_list) Performs a fill operation on a single array of particle kinship types\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_kinship ), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Contents None","tags":"","loc":"proc/symba_util_fill_arr_kin.html"},{"title":"symba_util_fill_pl – swiftest","text":"module subroutine symba_util_fill_pl(self, inserts, lfill_list) Interface → Insert new SyMBA test particle structure into an old one. \n This is the inverse of a fill operation. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA masive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Calls proc~~symba_util_fill_pl~~CallsGraph proc~symba_util_fill_pl symba_util_fill_pl util_fill_pl util_fill_pl proc~symba_util_fill_pl->util_fill_pl interface~util_fill util_fill proc~symba_util_fill_pl->interface~util_fill util_exit util_exit proc~symba_util_fill_pl->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_fill_pl~~CalledByGraph proc~symba_util_fill_pl symba_util_fill_pl interface~symba_util_fill_pl symba_util_fill_pl interface~symba_util_fill_pl->proc~symba_util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_fill_pl.html"},{"title":"symba_util_fill_tp – swiftest","text":"module subroutine symba_util_fill_tp(self, inserts, lfill_list) Interface → Insert new SyMBA test particle structure into an old one. \n This is the inverse of a fill operation. Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Calls proc~~symba_util_fill_tp~~CallsGraph proc~symba_util_fill_tp symba_util_fill_tp util_fill_tp util_fill_tp proc~symba_util_fill_tp->util_fill_tp interface~util_fill util_fill proc~symba_util_fill_tp->interface~util_fill util_exit util_exit proc~symba_util_fill_tp->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_fill_tp~~CalledByGraph proc~symba_util_fill_tp symba_util_fill_tp interface~symba_util_fill_tp symba_util_fill_tp interface~symba_util_fill_tp->proc~symba_util_fill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_fill_tp.html"},{"title":"symba_util_peri_pl – swiftest","text":"module subroutine symba_util_peri_pl(self, system, param) Interface → Determine system pericenter passages for planets in SyMBA Adapted from David E. Kaufmann's Swifter routine: symba_peri.f90\n Adapted from Hal Levison's Swift routine util_mass_peri.f Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~symba_util_peri_pl~~CallsGraph proc~symba_util_peri_pl symba_util_peri_pl orbel_xv2aeq orbel_xv2aeq proc~symba_util_peri_pl->orbel_xv2aeq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_peri_pl~~CalledByGraph proc~symba_util_peri_pl symba_util_peri_pl interface~symba_util_peri_pl symba_util_peri_pl interface~symba_util_peri_pl->proc~symba_util_peri_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_peri_pl.html"},{"title":"symba_util_rearray_pl – swiftest","text":"module subroutine symba_util_rearray_pl(self, system, param) Interface → Clean up the massive body structures to remove discarded bodies and add new bodies Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class( symba_nbody_system ), intent(inout) :: system Swiftest nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~symba_util_rearray_pl~~CallsGraph proc~symba_util_rearray_pl symba_util_rearray_pl interface~symba_io_dump_particle_info symba_io_dump_particle_info proc~symba_util_rearray_pl->interface~symba_io_dump_particle_info proc~symba_io_dump_particle_info symba_io_dump_particle_info interface~symba_io_dump_particle_info->proc~symba_io_dump_particle_info util_exit util_exit proc~symba_io_dump_particle_info->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_rearray_pl~~CalledByGraph proc~symba_util_rearray_pl symba_util_rearray_pl interface~symba_util_rearray_pl symba_util_rearray_pl interface~symba_util_rearray_pl->proc~symba_util_rearray_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_rearray_pl.html"},{"title":"symba_util_resize_arr_info – swiftest","text":"subroutine symba_util_resize_arr_info(arr, nnew) Resizes an array component of type character string. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name type( symba_particle_info ), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size Contents None","tags":"","loc":"proc/symba_util_resize_arr_info.html"},{"title":"symba_util_resize_arr_kin – swiftest","text":"subroutine symba_util_resize_arr_kin(arr, nnew) Resizes an array component of type character string. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size Contents None","tags":"","loc":"proc/symba_util_resize_arr_kin.html"},{"title":"symba_util_resize_merger – swiftest","text":"module subroutine symba_util_resize_merger(self, nnew) Interface → Checks the current size of a SyMBA merger list against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: nnew New size neded Calls proc~~symba_util_resize_merger~~CallsGraph proc~symba_util_resize_merger symba_util_resize_merger interface~symba_util_resize_pl symba_util_resize_pl proc~symba_util_resize_merger->interface~symba_util_resize_pl interface~util_resize util_resize proc~symba_util_resize_merger->interface~util_resize proc~symba_util_resize_pl symba_util_resize_pl interface~symba_util_resize_pl->proc~symba_util_resize_pl proc~symba_util_resize_pl->interface~util_resize util_resize_pl util_resize_pl proc~symba_util_resize_pl->util_resize_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_resize_merger~~CalledByGraph proc~symba_util_resize_merger symba_util_resize_merger interface~symba_util_resize_merger symba_util_resize_merger interface~symba_util_resize_merger->proc~symba_util_resize_merger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_resize_merger.html"},{"title":"symba_util_resize_pl – swiftest","text":"module subroutine symba_util_resize_pl(self, nnew) Interface → Checks the current size of a SyMBA massive body object against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: nnew New size neded Calls proc~~symba_util_resize_pl~~CallsGraph proc~symba_util_resize_pl symba_util_resize_pl util_resize_pl util_resize_pl proc~symba_util_resize_pl->util_resize_pl interface~util_resize util_resize proc~symba_util_resize_pl->interface~util_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_resize_pl~~CalledByGraph proc~symba_util_resize_pl symba_util_resize_pl interface~symba_util_resize_pl symba_util_resize_pl interface~symba_util_resize_pl->proc~symba_util_resize_pl proc~symba_util_resize_merger symba_util_resize_merger proc~symba_util_resize_merger->interface~symba_util_resize_pl interface~symba_util_resize_merger symba_util_resize_merger interface~symba_util_resize_merger->proc~symba_util_resize_merger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_resize_pl.html"},{"title":"symba_util_resize_tp – swiftest","text":"module subroutine symba_util_resize_tp(self, nnew) Interface → Checks the current size of a test particle object against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object integer(kind=I4B), intent(in) :: nnew New size neded Calls proc~~symba_util_resize_tp~~CallsGraph proc~symba_util_resize_tp symba_util_resize_tp util_resize_tp util_resize_tp proc~symba_util_resize_tp->util_resize_tp interface~util_resize util_resize proc~symba_util_resize_tp->interface~util_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_resize_tp~~CalledByGraph proc~symba_util_resize_tp symba_util_resize_tp interface~symba_util_resize_tp symba_util_resize_tp interface~symba_util_resize_tp->proc~symba_util_resize_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_resize_tp.html"},{"title":"symba_util_sort_pl – swiftest","text":"module subroutine symba_util_sort_pl(self, sortby, ascending) Interface → Sort a SyMBA massive body object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order Calls proc~~symba_util_sort_pl~~CallsGraph proc~symba_util_sort_pl symba_util_sort_pl util_sort_pl util_sort_pl proc~symba_util_sort_pl->util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_sort_pl~~CalledByGraph proc~symba_util_sort_pl symba_util_sort_pl interface~symba_util_sort_pl symba_util_sort_pl interface~symba_util_sort_pl->proc~symba_util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_sort_pl.html"},{"title":"symba_util_sort_tp – swiftest","text":"module subroutine symba_util_sort_tp(self, sortby, ascending) Interface → Sort a SyMBA test particle object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order Calls proc~~symba_util_sort_tp~~CallsGraph proc~symba_util_sort_tp symba_util_sort_tp util_sort_tp util_sort_tp proc~symba_util_sort_tp->util_sort_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_sort_tp~~CalledByGraph proc~symba_util_sort_tp symba_util_sort_tp interface~symba_util_sort_tp symba_util_sort_tp interface~symba_util_sort_tp->proc~symba_util_sort_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_sort_tp.html"},{"title":"symba_util_sort_rearrange_pl – swiftest","text":"module subroutine symba_util_sort_rearrange_pl(self, ind) Interface → Rearrange SyMBA massive body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) Calls proc~~symba_util_sort_rearrange_pl~~CallsGraph proc~symba_util_sort_rearrange_pl symba_util_sort_rearrange_pl util_sort_rearrange_pl util_sort_rearrange_pl proc~symba_util_sort_rearrange_pl->util_sort_rearrange_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_sort_rearrange_pl~~CalledByGraph proc~symba_util_sort_rearrange_pl symba_util_sort_rearrange_pl interface~symba_util_sort_rearrange_pl symba_util_sort_rearrange_pl interface~symba_util_sort_rearrange_pl->proc~symba_util_sort_rearrange_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_sort_rearrange_pl.html"},{"title":"symba_util_sort_rearrange_tp – swiftest","text":"module subroutine symba_util_sort_rearrange_tp(self, ind) Interface → Rearrange SyMBA test particle object in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) Calls proc~~symba_util_sort_rearrange_tp~~CallsGraph proc~symba_util_sort_rearrange_tp symba_util_sort_rearrange_tp util_sort_rearrange_tp util_sort_rearrange_tp proc~symba_util_sort_rearrange_tp->util_sort_rearrange_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_sort_rearrange_tp~~CalledByGraph proc~symba_util_sort_rearrange_tp symba_util_sort_rearrange_tp interface~symba_util_sort_rearrange_tp symba_util_sort_rearrange_tp interface~symba_util_sort_rearrange_tp->proc~symba_util_sort_rearrange_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_sort_rearrange_tp.html"},{"title":"symba_util_spill_arr_info – swiftest","text":"subroutine symba_util_spill_arr_info(keeps, discards, lspill_list, ldestructive) Performs a spill operation on a single array of particle origin information types\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name type( symba_particle_info ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_particle_info ), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not Contents None","tags":"","loc":"proc/symba_util_spill_arr_info.html"},{"title":"symba_util_spill_arr_kin – swiftest","text":"subroutine symba_util_spill_arr_kin(keeps, discards, lspill_list, ldestructive) Performs a spill operation on a single array of particle kinships\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_kinship ), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not Contents None","tags":"","loc":"proc/symba_util_spill_arr_kin.html"},{"title":"symba_util_spill_pl – swiftest","text":"module subroutine symba_util_spill_pl(self, discards, lspill_list, ldestructive) Interface → Move spilled (discarded) SyMBA massive body particle structure from active list to discard list\n Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90\n Spill all the common components Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list Calls proc~~symba_util_spill_pl~~CallsGraph proc~symba_util_spill_pl symba_util_spill_pl interface~util_spill util_spill proc~symba_util_spill_pl->interface~util_spill util_exit util_exit proc~symba_util_spill_pl->util_exit util_spill_pl util_spill_pl proc~symba_util_spill_pl->util_spill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_spill_pl~~CalledByGraph proc~symba_util_spill_pl symba_util_spill_pl interface~symba_util_spill_pl symba_util_spill_pl interface~symba_util_spill_pl->proc~symba_util_spill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_spill_pl.html"},{"title":"symba_util_spill_pltpenc – swiftest","text":"module subroutine symba_util_spill_pltpenc(self, discards, lspill_list, ldestructive) Interface → Move spilled (discarded) SyMBA encounter structure from active list to discard list\n Note: Because the symba_plplenc currently does not contain any additional variable components, this method can recieve it as an input as well. Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-tp encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list Calls proc~~symba_util_spill_pltpenc~~CallsGraph proc~symba_util_spill_pltpenc symba_util_spill_pltpenc interface~util_spill util_spill proc~symba_util_spill_pltpenc->interface~util_spill util_spill_encounter util_spill_encounter proc~symba_util_spill_pltpenc->util_spill_encounter util_exit util_exit proc~symba_util_spill_pltpenc->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_spill_pltpenc~~CalledByGraph proc~symba_util_spill_pltpenc symba_util_spill_pltpenc interface~symba_util_spill_pltpenc symba_util_spill_pltpenc interface~symba_util_spill_pltpenc->proc~symba_util_spill_pltpenc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_spill_pltpenc.html"},{"title":"symba_util_spill_tp – swiftest","text":"module subroutine symba_util_spill_tp(self, discards, lspill_list, ldestructive) Interface → Move spilled (discarded) SyMBA test particle structure from active list to discard list\n Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90\n Spill all the common components Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list Calls proc~~symba_util_spill_tp~~CallsGraph proc~symba_util_spill_tp symba_util_spill_tp util_spill_tp util_spill_tp proc~symba_util_spill_tp->util_spill_tp interface~util_spill util_spill proc~symba_util_spill_tp->interface~util_spill util_exit util_exit proc~symba_util_spill_tp->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_spill_tp~~CalledByGraph proc~symba_util_spill_tp symba_util_spill_tp interface~symba_util_spill_tp symba_util_spill_tp interface~symba_util_spill_tp->proc~symba_util_spill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_spill_tp.html"},{"title":"symba_collision_check_pltpenc – swiftest","text":"module subroutine symba_collision_check_pltpenc(self, system, param, t, dt, irec) Interface → Check for merger between massive bodies and test particles in SyMBA Adapted from David E. Kaufmann's Swifter routine symba_merge.f90 and symba_merge_tp.f90 Adapted from Hal Levison's Swift routine symba5_merge.f Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t current time real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Calls proc~~symba_collision_check_pltpenc~~CallsGraph proc~symba_collision_check_pltpenc symba_collision_check_pltpenc ind1 ind1 proc~symba_collision_check_pltpenc->ind1 proc~symba_collision_check_one symba_collision_check_one proc~symba_collision_check_pltpenc->proc~symba_collision_check_one ind2 ind2 proc~symba_collision_check_pltpenc->ind2 orbel_xv2aeq orbel_xv2aeq proc~symba_collision_check_one->orbel_xv2aeq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_collision_check_pltpenc~~CalledByGraph proc~symba_collision_check_pltpenc symba_collision_check_pltpenc interface~symba_collision_check_pltpenc symba_collision_check_pltpenc interface~symba_collision_check_pltpenc->proc~symba_collision_check_pltpenc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_collision_check_pltpenc.html"},{"title":"symba_collision_encounter_scrub – swiftest","text":"module subroutine symba_collision_encounter_scrub(self, system, param) Interface → Processes the pl-pl encounter list remove only those encounters that led to a collision Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~symba_collision_encounter_scrub~~CallsGraph proc~symba_collision_encounter_scrub symba_collision_encounter_scrub idx1 idx1 proc~symba_collision_encounter_scrub->idx1 idx2 idx2 proc~symba_collision_encounter_scrub->idx2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_collision_encounter_scrub~~CalledByGraph proc~symba_collision_encounter_scrub symba_collision_encounter_scrub interface~symba_collision_encounter_scrub symba_collision_encounter_scrub interface~symba_collision_encounter_scrub->proc~symba_collision_encounter_scrub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_collision_encounter_scrub.html"},{"title":"symba_collision_make_family_pl – swiftest","text":"module subroutine symba_collision_make_family_pl(self, idx) Interface → When a single body is involved in more than one collision in a single step, it becomes part of a family.\n The largest body involved in a multi-body collision is the \"parent\" and all bodies that collide with it are its \"children,\"\n including those that collide with the children. Adapted from David E. Kaufmann's Swifter routine symba_merge_pl.f90 Adapted from Hal Levison's Swift routine symba5_merge.f Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(2) :: idx Array holding the indices of the two bodies involved in the collision Called by proc~~symba_collision_make_family_pl~~CalledByGraph proc~symba_collision_make_family_pl symba_collision_make_family_pl interface~symba_collision_make_family_pl symba_collision_make_family_pl interface~symba_collision_make_family_pl->proc~symba_collision_make_family_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_collision_make_family_pl.html"},{"title":"symba_collision_resolve_fragmentations – swiftest","text":"module subroutine symba_collision_resolve_fragmentations(self, system, param) Interface → Process list of collisions, determine the collisional regime, and then create fragments. The collective mass of the parent and its children\n The collective radius of the parent and its children\n The position of the parent from inside the step (at collision)\n The velocity of the parent from inside the step (at collision)\n The position of the parent from inside the step (at collision)\n The velocity of the parent from inside the step (at collision)\n The collective density of the parent and its children\n Use the positions and velocities of the parents from indside the step (at collision) to calculate the collisional regime Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions Calls proc~~symba_collision_resolve_fragmentations~~CallsGraph proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations idx1 idx1 proc~symba_collision_resolve_fragmentations->idx1 interface~symba_fragmentation_casehitandrun symba_fragmentation_casehitandrun proc~symba_collision_resolve_fragmentations->interface~symba_fragmentation_casehitandrun interface~symba_fragmentation_casemerge symba_fragmentation_casemerge proc~symba_collision_resolve_fragmentations->interface~symba_fragmentation_casemerge util_exit util_exit proc~symba_collision_resolve_fragmentations->util_exit proc~symba_collision_consolidate_familes symba_collision_consolidate_familes proc~symba_collision_resolve_fragmentations->proc~symba_collision_consolidate_familes interface~symba_fragmentation_casesupercatastrophic symba_fragmentation_casesupercatastrophic proc~symba_collision_resolve_fragmentations->interface~symba_fragmentation_casesupercatastrophic idx2 idx2 proc~symba_collision_resolve_fragmentations->idx2 interface~symba_fragmentation_casedisruption symba_fragmentation_casedisruption proc~symba_collision_resolve_fragmentations->interface~symba_fragmentation_casedisruption proc~symba_fragmentation_casehitandrun symba_fragmentation_casehitandrun interface~symba_fragmentation_casehitandrun->proc~symba_fragmentation_casehitandrun proc~symba_fragmentation_casemerge symba_fragmentation_casemerge interface~symba_fragmentation_casemerge->proc~symba_fragmentation_casemerge id_arr id_arr proc~symba_collision_consolidate_familes->id_arr idx_arr idx_arr proc~symba_collision_consolidate_familes->idx_arr proc~symba_fragmentation_casesupercatastrophic symba_fragmentation_casesupercatastrophic interface~symba_fragmentation_casesupercatastrophic->proc~symba_fragmentation_casesupercatastrophic proc~symba_fragmentation_casedisruption symba_fragmentation_casedisruption interface~symba_fragmentation_casedisruption->proc~symba_fragmentation_casedisruption proc~symba_fragmentation_mergeaddsub symba_fragmentation_mergeaddsub proc~symba_fragmentation_casehitandrun->proc~symba_fragmentation_mergeaddsub fragmentation_initialize fragmentation_initialize proc~symba_fragmentation_casehitandrun->fragmentation_initialize proc~symba_fragmentation_casesupercatastrophic->proc~symba_fragmentation_mergeaddsub proc~symba_fragmentation_casesupercatastrophic->fragmentation_initialize proc~symba_fragmentation_casedisruption->proc~symba_fragmentation_mergeaddsub proc~symba_fragmentation_casedisruption->fragmentation_initialize proc~symba_fragmentation_casemerge->proc~symba_fragmentation_mergeaddsub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_collision_resolve_fragmentations~~CalledByGraph proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_collision_resolve_fragmentations.html"},{"title":"symba_collision_resolve_mergers – swiftest","text":"module subroutine symba_collision_resolve_mergers(self, system, param) Interface → Process list of collisions and merge colliding bodies together. Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions Calls proc~~symba_collision_resolve_mergers~~CallsGraph proc~symba_collision_resolve_mergers symba_collision_resolve_mergers idx1 idx1 proc~symba_collision_resolve_mergers->idx1 proc~symba_collision_consolidate_familes symba_collision_consolidate_familes proc~symba_collision_resolve_mergers->proc~symba_collision_consolidate_familes interface~symba_fragmentation_casemerge symba_fragmentation_casemerge proc~symba_collision_resolve_mergers->interface~symba_fragmentation_casemerge idx2 idx2 proc~symba_collision_resolve_mergers->idx2 id_arr id_arr proc~symba_collision_consolidate_familes->id_arr idx_arr idx_arr proc~symba_collision_consolidate_familes->idx_arr proc~symba_fragmentation_casemerge symba_fragmentation_casemerge interface~symba_fragmentation_casemerge->proc~symba_fragmentation_casemerge proc~symba_fragmentation_mergeaddsub symba_fragmentation_mergeaddsub proc~symba_fragmentation_casemerge->proc~symba_fragmentation_mergeaddsub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_collision_resolve_mergers~~CalledByGraph proc~symba_collision_resolve_mergers symba_collision_resolve_mergers interface~symba_collision_resolve_mergers symba_collision_resolve_mergers interface~symba_collision_resolve_mergers->proc~symba_collision_resolve_mergers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_collision_resolve_mergers.html"},{"title":"symba_setup_initialize_particle_info – swiftest","text":"module subroutine symba_setup_initialize_particle_info(system, param) Interface → Initializes a new particle information data structure with initial conditions recorded Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA extensions Calls proc~~symba_setup_initialize_particle_info~~CallsGraph proc~symba_setup_initialize_particle_info symba_setup_initialize_particle_info interface~symba_io_dump_particle_info symba_io_dump_particle_info proc~symba_setup_initialize_particle_info->interface~symba_io_dump_particle_info proc~symba_io_dump_particle_info symba_io_dump_particle_info interface~symba_io_dump_particle_info->proc~symba_io_dump_particle_info util_exit util_exit proc~symba_io_dump_particle_info->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_setup_initialize_particle_info~~CalledByGraph proc~symba_setup_initialize_particle_info symba_setup_initialize_particle_info interface~symba_setup_initialize_particle_info symba_setup_initialize_particle_info interface~symba_setup_initialize_particle_info->proc~symba_setup_initialize_particle_info proc~symba_setup_initialize_system symba_setup_initialize_system proc~symba_setup_initialize_system->interface~symba_setup_initialize_particle_info interface~symba_setup_initialize_system symba_setup_initialize_system interface~symba_setup_initialize_system->proc~symba_setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_setup_initialize_particle_info.html"},{"title":"symba_setup_initialize_system – swiftest","text":"module subroutine symba_setup_initialize_system(self, param) Interface → Initialize an SyMBA nbody system from files and sets up the planetocentric structures.\n This subroutine will also sort the massive bodies in descending order by mass Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Calls proc~~symba_setup_initialize_system~~CallsGraph proc~symba_setup_initialize_system symba_setup_initialize_system interface~symba_setup_initialize_particle_info symba_setup_initialize_particle_info proc~symba_setup_initialize_system->interface~symba_setup_initialize_particle_info whm_setup_initialize_system whm_setup_initialize_system proc~symba_setup_initialize_system->whm_setup_initialize_system interface~symba_io_read_particle symba_io_read_particle proc~symba_setup_initialize_system->interface~symba_io_read_particle proc~symba_setup_initialize_particle_info symba_setup_initialize_particle_info interface~symba_setup_initialize_particle_info->proc~symba_setup_initialize_particle_info proc~symba_io_read_particle symba_io_read_particle interface~symba_io_read_particle->proc~symba_io_read_particle util_exit util_exit proc~symba_io_read_particle->util_exit interface~symba_io_dump_particle_info symba_io_dump_particle_info proc~symba_setup_initialize_particle_info->interface~symba_io_dump_particle_info proc~symba_io_dump_particle_info symba_io_dump_particle_info interface~symba_io_dump_particle_info->proc~symba_io_dump_particle_info proc~symba_io_dump_particle_info->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_setup_initialize_system~~CalledByGraph proc~symba_setup_initialize_system symba_setup_initialize_system interface~symba_setup_initialize_system symba_setup_initialize_system interface~symba_setup_initialize_system->proc~symba_setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_setup_initialize_system.html"},{"title":"symba_setup_merger – swiftest","text":"module subroutine symba_setup_merger(self, n, param) Interface → Allocate SyMBA test particle structure Equivalent in functionality to David E. Kaufmann's Swifter routine symba_setup.f90\n Call allocation method for parent class. In this case, helio_pl does not have its own setup method so we use the base method for swiftest_pl Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA merger list object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter Calls proc~~symba_setup_merger~~CallsGraph proc~symba_setup_merger symba_setup_merger interface~symba_setup_pl symba_setup_pl proc~symba_setup_merger->interface~symba_setup_pl proc~symba_setup_pl symba_setup_pl interface~symba_setup_pl->proc~symba_setup_pl setup_pl setup_pl proc~symba_setup_pl->setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_setup_merger~~CalledByGraph proc~symba_setup_merger symba_setup_merger interface~symba_setup_merger symba_setup_merger interface~symba_setup_merger->proc~symba_setup_merger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_setup_merger.html"},{"title":"symba_setup_pl – swiftest","text":"module subroutine symba_setup_pl(self, n, param) Interface → Allocate SyMBA test particle structure Equivalent in functionality to David E. Kaufmann's Swifter routine symba_setup.f90\n Call allocation method for parent class. In this case, helio_pl does not have its own setup method so we use the base method for swiftest_pl Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter Calls proc~~symba_setup_pl~~CallsGraph proc~symba_setup_pl symba_setup_pl setup_pl setup_pl proc~symba_setup_pl->setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_setup_pl~~CalledByGraph proc~symba_setup_pl symba_setup_pl interface~symba_setup_pl symba_setup_pl interface~symba_setup_pl->proc~symba_setup_pl proc~symba_setup_merger symba_setup_merger proc~symba_setup_merger->interface~symba_setup_pl interface~symba_setup_merger symba_setup_merger interface~symba_setup_merger->proc~symba_setup_merger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_setup_pl.html"},{"title":"symba_setup_pltpenc – swiftest","text":"module subroutine symba_setup_pltpenc(self, n) Interface → A constructor that sets the number of encounters and allocates and initializes all arrays Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-tp encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for Calls proc~~symba_setup_pltpenc~~CallsGraph proc~symba_setup_pltpenc symba_setup_pltpenc setup_encounter setup_encounter proc~symba_setup_pltpenc->setup_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_setup_pltpenc~~CalledByGraph proc~symba_setup_pltpenc symba_setup_pltpenc interface~symba_setup_pltpenc symba_setup_pltpenc interface~symba_setup_pltpenc->proc~symba_setup_pltpenc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_setup_pltpenc.html"},{"title":"symba_setup_tp – swiftest","text":"module subroutine symba_setup_tp(self, n, param) Interface → Allocate WHM test particle structure Equivalent in functionality to David E. Kaufmann's Swifter routine whm_setup.f90\n Call allocation method for parent class. In this case, helio_tp does not have its own setup method so we use the base method for swiftest_tp Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter Calls proc~~symba_setup_tp~~CallsGraph proc~symba_setup_tp symba_setup_tp setup_tp setup_tp proc~symba_setup_tp->setup_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_setup_tp~~CalledByGraph proc~symba_setup_tp symba_setup_tp interface~symba_setup_tp symba_setup_tp interface~symba_setup_tp->proc~symba_setup_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_setup_tp.html"},{"title":"symba_kick_getacch_pl – swiftest","text":"module subroutine symba_kick_getacch_pl(self, system, param, t, lbeg) Interface → Compute heliocentric accelerations of massive bodies Adapted from David E. Kaufmann's Swifter routine symba_kick_getacch.f90\n Adapted from Hal Levison's Swift routine symba5_kick_getacch.f Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step Calls proc~~symba_kick_getacch_pl~~CallsGraph proc~symba_kick_getacch_pl symba_kick_getacch_pl helio_kick_getacch_pl helio_kick_getacch_pl proc~symba_kick_getacch_pl->helio_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_kick_getacch_pl~~CalledByGraph proc~symba_kick_getacch_pl symba_kick_getacch_pl interface~symba_kick_getacch_pl symba_kick_getacch_pl interface~symba_kick_getacch_pl->proc~symba_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_kick_getacch_pl.html"},{"title":"symba_kick_getacch_tp – swiftest","text":"module subroutine symba_kick_getacch_tp(self, system, param, t, lbeg) Interface → Compute heliocentric accelerations of test particles Adapted from David E. Kaufmann's Swifter routine symba_kick_getacch_tp.f90\n Adapted from Hal Levison's Swift routine symba5_kick_getacch.f Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step Calls proc~~symba_kick_getacch_tp~~CallsGraph proc~symba_kick_getacch_tp symba_kick_getacch_tp helio_kick_getacch_tp helio_kick_getacch_tp proc~symba_kick_getacch_tp->helio_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_kick_getacch_tp~~CalledByGraph proc~symba_kick_getacch_tp symba_kick_getacch_tp interface~symba_kick_getacch_tp symba_kick_getacch_tp interface~symba_kick_getacch_tp->proc~symba_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_kick_getacch_tp.html"},{"title":"symba_kick_pltpenc – swiftest","text":"module subroutine symba_kick_pltpenc(self, system, dt, irec, sgn) Interface → Kick barycentric velocities of massive bodies and ACTIVE test particles within SyMBA recursion.\n Note: This method works for the polymorphic symba_pltpenc and symba_plplenc types Adapted from David E. Kaufmann's Swifter routine: symba_kick.f90\n Adapted from Hal Levison's Swift routine symba5_kick.f Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(in) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level integer(kind=I4B), intent(in) :: sgn sign to be applied to acceleration Calls proc~~symba_kick_pltpenc~~CallsGraph proc~symba_kick_pltpenc symba_kick_pltpenc ind1 ind1 proc~symba_kick_pltpenc->ind1 ind2 ind2 proc~symba_kick_pltpenc->ind2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_kick_pltpenc~~CalledByGraph proc~symba_kick_pltpenc symba_kick_pltpenc interface~symba_kick_pltpenc symba_kick_pltpenc interface~symba_kick_pltpenc->proc~symba_kick_pltpenc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_kick_pltpenc.html"},{"title":"symba_fragmentation_casedisruption – swiftest","text":"module function symba_fragmentation_casedisruption(system, param, family, x, v, mass, radius, L_spin, Ip, mass_res, Qloss) result(status) Interface → Create the fragments resulting from a non-catastrophic disruption collision Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(in), dimension(:) :: family List of indices of all bodies inovlved in the collision real(kind=DP), intent(inout), dimension(:,:) :: x Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: v Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: radius Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: L_spin Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: Ip Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass_res The distribution of fragment mass obtained by the regime calculation real(kind=DP), intent(inout) :: Qloss Energy lost during collision Return Value integer(kind=I4B) Status flag assigned to this outcome Calls proc~~symba_fragmentation_casedisruption~~CallsGraph proc~symba_fragmentation_casedisruption symba_fragmentation_casedisruption proc~symba_fragmentation_mergeaddsub symba_fragmentation_mergeaddsub proc~symba_fragmentation_casedisruption->proc~symba_fragmentation_mergeaddsub fragmentation_initialize fragmentation_initialize proc~symba_fragmentation_casedisruption->fragmentation_initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_fragmentation_casedisruption~~CalledByGraph proc~symba_fragmentation_casedisruption symba_fragmentation_casedisruption interface~symba_fragmentation_casedisruption symba_fragmentation_casedisruption interface~symba_fragmentation_casedisruption->proc~symba_fragmentation_casedisruption proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations proc~symba_collision_resolve_fragmentations->interface~symba_fragmentation_casedisruption interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_fragmentation_casedisruption.html"},{"title":"symba_fragmentation_casehitandrun – swiftest","text":"module function symba_fragmentation_casehitandrun(system, param, family, x, v, mass, radius, L_spin, Ip, mass_res, Qloss) result(status) Interface → Create the fragments resulting from a non-catastrophic hit-and-run collision Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(in), dimension(:) :: family List of indices of all bodies inovlved in the collision real(kind=DP), intent(inout), dimension(:,:) :: x Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: v Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: radius Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: L_spin Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: Ip Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass_res The distribution of fragment mass obtained by the regime calculation real(kind=DP), intent(inout) :: Qloss Energy lost during collision Return Value integer(kind=I4B) Status flag assigned to this outcome Calls proc~~symba_fragmentation_casehitandrun~~CallsGraph proc~symba_fragmentation_casehitandrun symba_fragmentation_casehitandrun proc~symba_fragmentation_mergeaddsub symba_fragmentation_mergeaddsub proc~symba_fragmentation_casehitandrun->proc~symba_fragmentation_mergeaddsub fragmentation_initialize fragmentation_initialize proc~symba_fragmentation_casehitandrun->fragmentation_initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_fragmentation_casehitandrun~~CalledByGraph proc~symba_fragmentation_casehitandrun symba_fragmentation_casehitandrun interface~symba_fragmentation_casehitandrun symba_fragmentation_casehitandrun interface~symba_fragmentation_casehitandrun->proc~symba_fragmentation_casehitandrun proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations proc~symba_collision_resolve_fragmentations->interface~symba_fragmentation_casehitandrun interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_fragmentation_casehitandrun.html"},{"title":"symba_fragmentation_casemerge – swiftest","text":"module function symba_fragmentation_casemerge(system, param, family, x, v, mass, radius, L_spin, Ip) result(status) Interface → Merge planets. Adapted from David E. Kaufmann's Swifter routines symba_merge_pl.f90 and symba_discard_merge_pl.f90 Adapted from Hal Levison's Swift routines symba5_merge.f and discard_mass_merge.f Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(in), dimension(:) :: family List of indices of all bodies inovlved in the collision real(kind=DP), intent(in), dimension(:,:) :: x Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(in), dimension(:,:) :: v Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(in), dimension(:) :: mass Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(in), dimension(:) :: radius Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(in), dimension(:,:) :: L_spin Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(in), dimension(:,:) :: Ip Input values that represent a 2-body equivalent of a possibly 2+ body collision Return Value integer(kind=I4B) Status flag assigned to this outcome Calls proc~~symba_fragmentation_casemerge~~CallsGraph proc~symba_fragmentation_casemerge symba_fragmentation_casemerge proc~symba_fragmentation_mergeaddsub symba_fragmentation_mergeaddsub proc~symba_fragmentation_casemerge->proc~symba_fragmentation_mergeaddsub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_fragmentation_casemerge~~CalledByGraph proc~symba_fragmentation_casemerge symba_fragmentation_casemerge interface~symba_fragmentation_casemerge symba_fragmentation_casemerge interface~symba_fragmentation_casemerge->proc~symba_fragmentation_casemerge proc~symba_collision_resolve_mergers symba_collision_resolve_mergers proc~symba_collision_resolve_mergers->interface~symba_fragmentation_casemerge proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations proc~symba_collision_resolve_fragmentations->interface~symba_fragmentation_casemerge interface~symba_collision_resolve_mergers symba_collision_resolve_mergers interface~symba_collision_resolve_mergers->proc~symba_collision_resolve_mergers interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_fragmentation_casemerge.html"},{"title":"symba_fragmentation_casesupercatastrophic – swiftest","text":"module function symba_fragmentation_casesupercatastrophic(system, param, family, x, v, mass, radius, L_spin, Ip, mass_res, Qloss) result(status) Interface → Create the fragments resulting from a supercatastrophic collision Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(in), dimension(:) :: family List of indices of all bodies inovlved in the collision real(kind=DP), intent(inout), dimension(:,:) :: x Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: v Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: radius Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: L_spin Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: Ip Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass_res The distribution of fragment mass obtained by the regime calculation real(kind=DP), intent(inout) :: Qloss Energy lost during collision Return Value integer(kind=I4B) Status flag assigned to this outcome Calls proc~~symba_fragmentation_casesupercatastrophic~~CallsGraph proc~symba_fragmentation_casesupercatastrophic symba_fragmentation_casesupercatastrophic proc~symba_fragmentation_mergeaddsub symba_fragmentation_mergeaddsub proc~symba_fragmentation_casesupercatastrophic->proc~symba_fragmentation_mergeaddsub fragmentation_initialize fragmentation_initialize proc~symba_fragmentation_casesupercatastrophic->fragmentation_initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_fragmentation_casesupercatastrophic~~CalledByGraph proc~symba_fragmentation_casesupercatastrophic symba_fragmentation_casesupercatastrophic interface~symba_fragmentation_casesupercatastrophic symba_fragmentation_casesupercatastrophic interface~symba_fragmentation_casesupercatastrophic->proc~symba_fragmentation_casesupercatastrophic proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations proc~symba_collision_resolve_fragmentations->interface~symba_fragmentation_casesupercatastrophic interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_fragmentation_casesupercatastrophic.html"},{"title":"symba_encounter_check_pl – swiftest","text":"module function symba_encounter_check_pl(self, system, dt, irec) result(lany_encounter) Interface → Check for an encounter between massive bodies. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter Called by proc~~symba_encounter_check_pl~~CalledByGraph proc~symba_encounter_check_pl symba_encounter_check_pl interface~symba_encounter_check_pl symba_encounter_check_pl interface~symba_encounter_check_pl->proc~symba_encounter_check_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_encounter_check_pl.html"},{"title":"symba_encounter_check_pltpenc – swiftest","text":"module function symba_encounter_check_pltpenc(self, system, dt, irec) result(lany_encounter) Interface → Check for an encounter between test particles and massive bodies in the pltpenc list.\n Note: This method works for the polymorphic symba_pltpenc and symba_plplenc types. Adapted from portions of David E. Kaufmann's Swifter routine: symba_step_recur.f90 Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-pl encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter Calls proc~~symba_encounter_check_pltpenc~~CallsGraph proc~symba_encounter_check_pltpenc symba_encounter_check_pltpenc ind1 ind1 proc~symba_encounter_check_pltpenc->ind1 ind2 ind2 proc~symba_encounter_check_pltpenc->ind2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_encounter_check_pltpenc~~CalledByGraph proc~symba_encounter_check_pltpenc symba_encounter_check_pltpenc interface~symba_encounter_check_pltpenc symba_encounter_check_pltpenc interface~symba_encounter_check_pltpenc->proc~symba_encounter_check_pltpenc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_encounter_check_pltpenc.html"},{"title":"symba_encounter_check_tp – swiftest","text":"module function symba_encounter_check_tp(self, system, dt, irec) result(lany_encounter) Interface → Check for an encounter between test particles and massive bodies. Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter Called by proc~~symba_encounter_check_tp~~CalledByGraph proc~symba_encounter_check_tp symba_encounter_check_tp interface~symba_encounter_check_tp symba_encounter_check_tp interface~symba_encounter_check_tp->proc~symba_encounter_check_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_encounter_check_tp.html"},{"title":"symba_encounter_check_one – swiftest","text":"pure elemental module subroutine symba_encounter_check_one(xr, yr, zr, vxr, vyr, vzr, rhill1, rhill2, dt, irec, lencounter, lvdotr) Interface → Check for an encounter. Adapted from David E. Kaufmann's Swifter routine: symba_chk.f90\n Adapted from Hal Levison's Swift routine symba5_chk.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: xr real(kind=DP), intent(in) :: yr real(kind=DP), intent(in) :: zr real(kind=DP), intent(in) :: vxr real(kind=DP), intent(in) :: vyr real(kind=DP), intent(in) :: vzr real(kind=DP), intent(in) :: rhill1 real(kind=DP), intent(in) :: rhill2 real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: irec logical, intent(out) :: lencounter logical, intent(out) :: lvdotr Calls proc~~symba_encounter_check_one~~CallsGraph proc~symba_encounter_check_one symba_encounter_check_one interface~rmvs_chk_ind rmvs_chk_ind proc~symba_encounter_check_one->interface~rmvs_chk_ind proc~rmvs_chk_ind rmvs_chk_ind interface~rmvs_chk_ind->proc~rmvs_chk_ind Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_encounter_check_one~~CalledByGraph proc~symba_encounter_check_one symba_encounter_check_one interface~symba_encounter_check_one symba_encounter_check_one interface~symba_encounter_check_one->proc~symba_encounter_check_one Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_encounter_check_one.html"},{"title":"symba_io_dump_particle_info – swiftest","text":"module subroutine symba_io_dump_particle_info(system, param, lincludecb, tpidx, plidx) Interface → Dumps the particle information data to a file. \n Pass a list of array indices for test particles (tpidx) and/or massive bodies (plidx) to append Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA extensions logical, intent(in), optional :: lincludecb Set to true to include the central body (default is false) integer(kind=I4B), intent(in), optional dimension(:) :: tpidx Array of test particle indices to append to the particle file integer(kind=I4B), intent(in), optional dimension(:) :: plidx Array of massive body indices to append to the particle file Calls proc~~symba_io_dump_particle_info~~CallsGraph proc~symba_io_dump_particle_info symba_io_dump_particle_info util_exit util_exit proc~symba_io_dump_particle_info->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_io_dump_particle_info~~CalledByGraph proc~symba_io_dump_particle_info symba_io_dump_particle_info interface~symba_io_dump_particle_info symba_io_dump_particle_info interface~symba_io_dump_particle_info->proc~symba_io_dump_particle_info proc~symba_setup_initialize_particle_info symba_setup_initialize_particle_info proc~symba_setup_initialize_particle_info->interface~symba_io_dump_particle_info proc~symba_util_rearray_pl symba_util_rearray_pl proc~symba_util_rearray_pl->interface~symba_io_dump_particle_info interface~symba_setup_initialize_particle_info symba_setup_initialize_particle_info interface~symba_setup_initialize_particle_info->proc~symba_setup_initialize_particle_info interface~symba_util_rearray_pl symba_util_rearray_pl interface~symba_util_rearray_pl->proc~symba_util_rearray_pl proc~symba_setup_initialize_system symba_setup_initialize_system proc~symba_setup_initialize_system->interface~symba_setup_initialize_particle_info interface~symba_setup_initialize_system symba_setup_initialize_system interface~symba_setup_initialize_system->proc~symba_setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_io_dump_particle_info.html"},{"title":"symba_io_param_reader – swiftest","text":"module subroutine symba_io_param_reader(self, unit, iotype, v_list, iostat, iomsg) Interface → Read in parameters specific to the SyMBA integrator, then calls the base io_param_reader. Adapted from David E. Kaufmann's Swifter routine io_init_param.f90\n Adapted from Martin Duncan's Swift routine io_init_param.f Arguments Type Intent Optional Attributes Name class( symba_parameters ), intent(inout) :: self Collection of parameters integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) The first element passes the integrator code to the reader integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 Calls proc~~symba_io_param_reader~~CallsGraph proc~symba_io_param_reader symba_io_param_reader io_toupper io_toupper proc~symba_io_param_reader->io_toupper io_param_reader io_param_reader proc~symba_io_param_reader->io_param_reader io_get_token io_get_token proc~symba_io_param_reader->io_get_token Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_io_param_reader~~CalledByGraph proc~symba_io_param_reader symba_io_param_reader interface~symba_io_param_reader symba_io_param_reader interface~symba_io_param_reader->proc~symba_io_param_reader Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_io_param_reader.html"},{"title":"symba_io_param_writer – swiftest","text":"module subroutine symba_io_param_writer(self, unit, iotype, v_list, iostat, iomsg) Interface → Dump integration parameters specific to SyMBA to file and then call the base io_param_writer method. Adapted from David E. Kaufmann's Swifter routine io_dump_param.f90\n Adapted from Martin Duncan's Swift routine io_dump_param.f Arguments Type Intent Optional Attributes Name class( symba_parameters ), intent(in) :: self Collection of SyMBA parameters integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) Not used in this procedure integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 Calls proc~~symba_io_param_writer~~CallsGraph proc~symba_io_param_writer symba_io_param_writer io_param_writer io_param_writer proc~symba_io_param_writer->io_param_writer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_io_param_writer~~CalledByGraph proc~symba_io_param_writer symba_io_param_writer interface~symba_io_param_writer symba_io_param_writer interface~symba_io_param_writer->proc~symba_io_param_writer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_io_param_writer.html"},{"title":"symba_io_read_particle – swiftest","text":"module subroutine symba_io_read_particle(system, param) Interface → Reads an old particle information file for a restartd run Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system file class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA extensions Calls proc~~symba_io_read_particle~~CallsGraph proc~symba_io_read_particle symba_io_read_particle util_exit util_exit proc~symba_io_read_particle->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_io_read_particle~~CalledByGraph proc~symba_io_read_particle symba_io_read_particle interface~symba_io_read_particle symba_io_read_particle interface~symba_io_read_particle->proc~symba_io_read_particle proc~symba_setup_initialize_system symba_setup_initialize_system proc~symba_setup_initialize_system->interface~symba_io_read_particle interface~symba_setup_initialize_system symba_setup_initialize_system interface~symba_setup_initialize_system->proc~symba_setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_io_read_particle.html"},{"title":"symba_io_write_discard – swiftest","text":"module subroutine symba_io_write_discard(self, param) Interface → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~symba_io_write_discard~~CallsGraph proc~symba_io_write_discard symba_io_write_discard util_exit util_exit proc~symba_io_write_discard->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_io_write_discard~~CalledByGraph proc~symba_io_write_discard symba_io_write_discard interface~symba_io_write_discard symba_io_write_discard interface~symba_io_write_discard->proc~symba_io_write_discard Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_io_write_discard.html"},{"title":"symba_discard_pl – swiftest","text":"module subroutine symba_discard_pl(self, system, param) Interface → Call the various flavors of discards for massive bodies in SyMBA runs, including discards due to colling with the central body, \n escaping the system, or colliding with each other. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Calls proc~~symba_discard_pl~~CallsGraph proc~symba_discard_pl symba_discard_pl proc~symba_discard_nonplpl symba_discard_nonplpl proc~symba_discard_pl->proc~symba_discard_nonplpl proc~symba_discard_nonplpl_conservation symba_discard_nonplpl_conservation proc~symba_discard_pl->proc~symba_discard_nonplpl_conservation proc~symba_discard_cb_pl symba_discard_cb_pl proc~symba_discard_nonplpl->proc~symba_discard_cb_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_discard_pl~~CalledByGraph proc~symba_discard_pl symba_discard_pl interface~symba_discard_pl symba_discard_pl interface~symba_discard_pl->proc~symba_discard_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_discard_pl.html"},{"title":"symba_step_system – swiftest","text":"module subroutine symba_step_system(self, param, t, dt) Interface → Step planets and active test particles ahead in democratic heliocentric coordinates, descending the recursive\n   branch if necessary to handle possible close encounters Adapted from David E. Kaufmann's Swifter routine: symba_step.f90\n Adapted from Hal Levison's Swift routine symba5_step_pl.f Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize Calls proc~~symba_step_system~~CallsGraph proc~symba_step_system symba_step_system helio_step_system helio_step_system proc~symba_step_system->helio_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_step_system~~CalledByGraph proc~symba_step_system symba_step_system interface~symba_step_system symba_step_system interface~symba_step_system->proc~symba_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_step_system.html"},{"title":"symba_step_interp_system – swiftest","text":"module subroutine symba_step_interp_system(self, param, t, dt) Interface → Step planets and active test particles ahead in democratic heliocentric coordinates, calling the recursive\n         subroutine to descend to the appropriate level to handle close encounters Adapted from David E. Kaufmann's Swifter routine: symba_step_interp.f90\n Adapted from Hal Levison's Swift routine symba5_step_interp.f Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize Called by proc~~symba_step_interp_system~~CalledByGraph proc~symba_step_interp_system symba_step_interp_system interface~symba_step_interp_system symba_step_interp_system interface~symba_step_interp_system->proc~symba_step_interp_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_step_interp_system.html"},{"title":"symba_step_set_recur_levels_system – swiftest","text":"module subroutine symba_step_set_recur_levels_system(self, ireci) Interface → Resets pl, tp,and encounter structures at the start of a new step Adapted from David E. Kaufmann's Swifter routine: symba_step_recur.f90\n Adapted from Hal Levison's Swift routine symba5_step_recur.f Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object integer(kind=I4B), intent(in) :: ireci Input recursion level Called by proc~~symba_step_set_recur_levels_system~~CalledByGraph proc~symba_step_set_recur_levels_system symba_step_set_recur_levels_system interface~symba_step_set_recur_levels_system symba_step_set_recur_levels_system interface~symba_step_set_recur_levels_system->proc~symba_step_set_recur_levels_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_step_set_recur_levels_system.html"},{"title":"symba_step_recur_system – swiftest","text":"recursive module subroutine symba_step_recur_system(self, param, t, ireci) Interface → Step interacting planets and active test particles ahead in democratic heliocentric coordinates at the current\n         recursion level, if applicable, and descend to the next deeper level if necessarys Adapted from David E. Kaufmann's Swifter routine: symba_step_recur.f90\n Adapted from Hal Levison's Swift routine symba5_step_recur.f Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), value :: t integer(kind=I4B), value :: ireci input recursion level Calls proc~~symba_step_recur_system~~CallsGraph proc~symba_step_recur_system symba_step_recur_system util_exit util_exit proc~symba_step_recur_system->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_step_recur_system~~CalledByGraph proc~symba_step_recur_system symba_step_recur_system interface~symba_step_recur_system symba_step_recur_system interface~symba_step_recur_system->proc~symba_step_recur_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_step_recur_system.html"},{"title":"symba_step_reset_system – swiftest","text":"module subroutine symba_step_reset_system(self) Interface → Resets pl, tp,and encounter structures at the start of a new step Adapted from David E. Kaufmann's Swifter routine: symba_step.f90\n Adapted from Hal Levison's Swift routine symba5_step.f Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object Called by proc~~symba_step_reset_system~~CalledByGraph proc~symba_step_reset_system symba_step_reset_system interface~symba_step_reset_system symba_step_reset_system interface~symba_step_reset_system->proc~symba_step_reset_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_step_reset_system.html"},{"title":"symba_drift_pl – swiftest","text":"module subroutine symba_drift_pl(self, system, param, dt) Interface → Wrapper function used to call the body drift routine from a symba_pl structure Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize Calls proc~~symba_drift_pl~~CallsGraph proc~symba_drift_pl symba_drift_pl helio_drift_body helio_drift_body proc~symba_drift_pl->helio_drift_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_drift_pl~~CalledByGraph proc~symba_drift_pl symba_drift_pl interface~symba_drift_pl symba_drift_pl interface~symba_drift_pl->proc~symba_drift_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_drift_pl.html"},{"title":"symba_drift_tp – swiftest","text":"module subroutine symba_drift_tp(self, system, param, dt) Interface → Wrapper function used to call the body drift routine from a symba_pl structure Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize Calls proc~~symba_drift_tp~~CallsGraph proc~symba_drift_tp symba_drift_tp helio_drift_body helio_drift_body proc~symba_drift_tp->helio_drift_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_drift_tp~~CalledByGraph proc~symba_drift_tp symba_drift_tp interface~symba_drift_tp symba_drift_tp interface~symba_drift_tp->proc~symba_drift_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_drift_tp.html"},{"title":"fragmentation_initialize – swiftest","text":"module subroutine fragmentation_initialize(system, param, family, x, v, L_spin, Ip, mass, radius, nfrag, Ip_frag, m_frag, rad_frag, xb_frag, vb_frag, rot_frag, Qloss, lfailure) Interface → Uses ieee_exceptions proc~~fragmentation_initialize~~UsesGraph proc~fragmentation_initialize fragmentation_initialize ieee_exceptions ieee_exceptions proc~fragmentation_initialize->ieee_exceptions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Initialize the position and velocity of fragments to conserve energy and momentum. Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters integer(kind=I4B), intent(in), dimension(:) :: family Index of bodies involved in the collision real(kind=DP), intent(inout), dimension(:,:) :: x Two-body equivalent position, vector, spin momentum, and rotational inertia values for the collision real(kind=DP), intent(inout), dimension(:,:) :: v Two-body equivalent position, vector, spin momentum, and rotational inertia values for the collision real(kind=DP), intent(inout), dimension(:,:) :: L_spin Two-body equivalent position, vector, spin momentum, and rotational inertia values for the collision real(kind=DP), intent(inout), dimension(:,:) :: Ip Two-body equivalent position, vector, spin momentum, and rotational inertia values for the collision real(kind=DP), intent(inout), dimension(:) :: mass Two-body equivalent mass and radii for the bodies in the collision real(kind=DP), intent(inout), dimension(:) :: radius Two-body equivalent mass and radii for the bodies in the collision integer(kind=I4B), intent(inout) :: nfrag Number of fragments to generate real(kind=DP), intent(inout), dimension(:,:), allocatable :: Ip_frag Fragment rotational inertia vectors real(kind=DP), intent(inout), dimension(:), allocatable :: m_frag Distribution of fragment mass and radii real(kind=DP), intent(inout), dimension(:), allocatable :: rad_frag Distribution of fragment mass and radii real(kind=DP), intent(inout), dimension(:,:), allocatable :: xb_frag Fragment barycentric position, barycentric velocity, and rotation vectors real(kind=DP), intent(inout), dimension(:,:), allocatable :: vb_frag Fragment barycentric position, barycentric velocity, and rotation vectors real(kind=DP), intent(inout), dimension(:,:), allocatable :: rot_frag Fragment barycentric position, barycentric velocity, and rotation vectors real(kind=DP), intent(inout) :: Qloss Energy lost during the collision logical, intent(out) :: lfailure Answers the question: Should this have been a merger instead? Called by proc~~fragmentation_initialize~~CalledByGraph proc~fragmentation_initialize fragmentation_initialize interface~fragmentation_initialize fragmentation_initialize interface~fragmentation_initialize->proc~fragmentation_initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fragmentation_initialize.html"},{"title":"fragmentation_regime – swiftest","text":"module subroutine fragmentation_regime(Mcb, m1, m2, rad1, rad2, xh1, xh2, vb1, vb2, den1, den2, regime, Mlr, Mslr, mtiny, Qloss) Interface → Determine the collisional regime of two colliding bodies. \n Current version requires all values to be converted to SI units prior to calling the function\n       References:\n       Kokubo, E., Genda, H., 2010. Formation of Terrestrial Planets from Protoplanets Under a Realistic Accretion \n          Condition. ApJL 714, L21. https://doi.org/10.1088/2041-8205/714/1/L21\n       Leinhardt, Z.M., Stewart, S.T., 2012. Collisions between Gravity-dominated Bodies. I. Outcome Regimes and Scaling \n          Laws 745, 79. https://doi.org/10.1088/0004-637X/745/1/79\n       Mustill, A.J., Davies, M.B., Johansen, A., 2018. The dynamical evolution of transiting planetary systems including \n          a realistic collision prescription. Mon Not R Astron Soc 478, 2896–2908. https://doi.org/10.1093/mnras/sty1273\n       Rufu, R., Aharonson, O., 2019. Impact Dynamics of Moons Within a Planetary Potential. J. Geophys. Res. Planets 124, \n          1008–1019. https://doi.org/10.1029/2018JE005798\n       Stewart, S.T., Leinhardt, Z.M., 2012. Collisions between Gravity-dominated Bodies. II. The Diversity of Impact \n          Outcomes during the End Stage of Planet Formation. ApJ 751, 32. https://doi.org/10.1088/0004-637X/751/1/32 Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: Mcb real(kind=DP), intent(in) :: m1 real(kind=DP), intent(in) :: m2 real(kind=DP), intent(in) :: rad1 real(kind=DP), intent(in) :: rad2 real(kind=DP), intent(in), dimension(:) :: xh1 real(kind=DP), intent(in), dimension(:) :: xh2 real(kind=DP), intent(in), dimension(:) :: vb1 real(kind=DP), intent(in), dimension(:) :: vb2 real(kind=DP), intent(in) :: den1 real(kind=DP), intent(in) :: den2 integer(kind=I4B), intent(out) :: regime real(kind=DP), intent(out) :: Mlr real(kind=DP), intent(out) :: Mslr real(kind=DP), intent(in) :: mtiny real(kind=DP), intent(out) :: Qloss The residual energy after the collision Called by proc~~fragmentation_regime~~CalledByGraph proc~fragmentation_regime fragmentation_regime interface~fragmentation_regime fragmentation_regime interface~fragmentation_regime->proc~fragmentation_regime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fragmentation_regime.html"},{"title":"rmvs_discard_tp – swiftest","text":"module subroutine rmvs_discard_tp(self, system, param) Interface → Check to see if test particles should be discarded based on pericenter passage distances with respect to planets encountered Adapted from Hal Levison's Swift routine discard_pl.f\n Adapted from Hal Levison's Swift routine rmvs_discard_pl.f90 Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters Calls proc~~rmvs_discard_tp~~CallsGraph proc~rmvs_discard_tp rmvs_discard_tp discard_tp discard_tp proc~rmvs_discard_tp->discard_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_discard_tp~~CalledByGraph proc~rmvs_discard_tp rmvs_discard_tp interface~rmvs_discard_tp rmvs_discard_tp interface~rmvs_discard_tp->proc~rmvs_discard_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_discard_tp.html"},{"title":"rmvs_util_append_pl – swiftest","text":"module subroutine rmvs_util_append_pl(self, source, lsource_mask) Interface → Append components from one massive body object to another. \n This method will automatically resize the destination body if it is too small\n Arguments Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~rmvs_util_append_pl~~CallsGraph proc~rmvs_util_append_pl rmvs_util_append_pl util_append util_append proc~rmvs_util_append_pl->util_append whm_util_append_pl whm_util_append_pl proc~rmvs_util_append_pl->whm_util_append_pl util_exit util_exit proc~rmvs_util_append_pl->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_append_pl~~CalledByGraph proc~rmvs_util_append_pl rmvs_util_append_pl interface~rmvs_util_append_pl rmvs_util_append_pl interface~rmvs_util_append_pl->proc~rmvs_util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_append_pl.html"},{"title":"rmvs_util_append_tp – swiftest","text":"module subroutine rmvs_util_append_tp(self, source, lsource_mask) Interface → Append components from test particle object to another. \n This method will automatically resize the destination body if it is too small\n Arguments Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~rmvs_util_append_tp~~CallsGraph proc~rmvs_util_append_tp rmvs_util_append_tp util_append util_append proc~rmvs_util_append_tp->util_append util_append_tp util_append_tp proc~rmvs_util_append_tp->util_append_tp util_exit util_exit proc~rmvs_util_append_tp->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_append_tp~~CalledByGraph proc~rmvs_util_append_tp rmvs_util_append_tp interface~rmvs_util_append_tp rmvs_util_append_tp interface~rmvs_util_append_tp->proc~rmvs_util_append_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_append_tp.html"},{"title":"rmvs_util_fill_pl – swiftest","text":"module subroutine rmvs_util_fill_pl(self, inserts, lfill_list) Interface → Insert new RMVS massive body structure into an old one. \n This is the inverse of a fill operation. Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Calls proc~~rmvs_util_fill_pl~~CallsGraph proc~rmvs_util_fill_pl rmvs_util_fill_pl util_fill util_fill proc~rmvs_util_fill_pl->util_fill util_exit util_exit proc~rmvs_util_fill_pl->util_exit whm_util_fill_pl whm_util_fill_pl proc~rmvs_util_fill_pl->whm_util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_fill_pl~~CalledByGraph proc~rmvs_util_fill_pl rmvs_util_fill_pl interface~rmvs_util_fill_pl rmvs_util_fill_pl interface~rmvs_util_fill_pl->proc~rmvs_util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_fill_pl.html"},{"title":"rmvs_util_fill_tp – swiftest","text":"module subroutine rmvs_util_fill_tp(self, inserts, lfill_list) Interface → Insert new RMVS test particle structure into an old one. \n This is the inverse of a fill operation. Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Calls proc~~rmvs_util_fill_tp~~CallsGraph proc~rmvs_util_fill_tp rmvs_util_fill_tp util_fill_tp util_fill_tp proc~rmvs_util_fill_tp->util_fill_tp util_fill util_fill proc~rmvs_util_fill_tp->util_fill util_exit util_exit proc~rmvs_util_fill_tp->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_fill_tp~~CalledByGraph proc~rmvs_util_fill_tp rmvs_util_fill_tp interface~rmvs_util_fill_tp rmvs_util_fill_tp interface~rmvs_util_fill_tp->proc~rmvs_util_fill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_fill_tp.html"},{"title":"rmvs_util_resize_pl – swiftest","text":"module subroutine rmvs_util_resize_pl(self, nnew) Interface → Checks the current size of a massive body object against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in) :: nnew New size neded Calls proc~~rmvs_util_resize_pl~~CallsGraph proc~rmvs_util_resize_pl rmvs_util_resize_pl util_resize util_resize proc~rmvs_util_resize_pl->util_resize whm_util_resize_pl whm_util_resize_pl proc~rmvs_util_resize_pl->whm_util_resize_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_resize_pl~~CalledByGraph proc~rmvs_util_resize_pl rmvs_util_resize_pl interface~rmvs_util_resize_pl rmvs_util_resize_pl interface~rmvs_util_resize_pl->proc~rmvs_util_resize_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_resize_pl.html"},{"title":"rmvs_util_resize_tp – swiftest","text":"module subroutine rmvs_util_resize_tp(self, nnew) Interface → Checks the current size of a test particle object against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: nnew New size neded Calls proc~~rmvs_util_resize_tp~~CallsGraph proc~rmvs_util_resize_tp rmvs_util_resize_tp util_resize util_resize proc~rmvs_util_resize_tp->util_resize util_resize_tp util_resize_tp proc~rmvs_util_resize_tp->util_resize_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_resize_tp~~CalledByGraph proc~rmvs_util_resize_tp rmvs_util_resize_tp interface~rmvs_util_resize_tp rmvs_util_resize_tp interface~rmvs_util_resize_tp->proc~rmvs_util_resize_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_resize_tp.html"},{"title":"rmvs_util_sort_pl – swiftest","text":"module subroutine rmvs_util_sort_pl(self, sortby, ascending) Interface → Sort a RMVS massive body object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order Calls proc~~rmvs_util_sort_pl~~CallsGraph proc~rmvs_util_sort_pl rmvs_util_sort_pl whm_util_sort_pl whm_util_sort_pl proc~rmvs_util_sort_pl->whm_util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_sort_pl~~CalledByGraph proc~rmvs_util_sort_pl rmvs_util_sort_pl interface~rmvs_util_sort_pl rmvs_util_sort_pl interface~rmvs_util_sort_pl->proc~rmvs_util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_sort_pl.html"},{"title":"rmvs_util_sort_tp – swiftest","text":"module subroutine rmvs_util_sort_tp(self, sortby, ascending) Interface → Sort a RMVS test particle object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order Calls proc~~rmvs_util_sort_tp~~CallsGraph proc~rmvs_util_sort_tp rmvs_util_sort_tp util_sort_tp util_sort_tp proc~rmvs_util_sort_tp->util_sort_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_sort_tp~~CalledByGraph proc~rmvs_util_sort_tp rmvs_util_sort_tp interface~rmvs_util_sort_tp rmvs_util_sort_tp interface~rmvs_util_sort_tp->proc~rmvs_util_sort_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_sort_tp.html"},{"title":"rmvs_util_sort_rearrange_pl – swiftest","text":"module subroutine rmvs_util_sort_rearrange_pl(self, ind) Interface → Rearrange RMVS massive body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) Calls proc~~rmvs_util_sort_rearrange_pl~~CallsGraph proc~rmvs_util_sort_rearrange_pl rmvs_util_sort_rearrange_pl util_sort_rearrange_pl util_sort_rearrange_pl proc~rmvs_util_sort_rearrange_pl->util_sort_rearrange_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_sort_rearrange_pl~~CalledByGraph proc~rmvs_util_sort_rearrange_pl rmvs_util_sort_rearrange_pl interface~rmvs_util_sort_rearrange_pl rmvs_util_sort_rearrange_pl interface~rmvs_util_sort_rearrange_pl->proc~rmvs_util_sort_rearrange_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_sort_rearrange_pl.html"},{"title":"rmvs_util_sort_rearrange_tp – swiftest","text":"module subroutine rmvs_util_sort_rearrange_tp(self, ind) Interface → Rearrange RMVS test particle object in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) Calls proc~~rmvs_util_sort_rearrange_tp~~CallsGraph proc~rmvs_util_sort_rearrange_tp rmvs_util_sort_rearrange_tp util_sort_rearrange_tp util_sort_rearrange_tp proc~rmvs_util_sort_rearrange_tp->util_sort_rearrange_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_sort_rearrange_tp~~CalledByGraph proc~rmvs_util_sort_rearrange_tp rmvs_util_sort_rearrange_tp interface~rmvs_util_sort_rearrange_tp rmvs_util_sort_rearrange_tp interface~rmvs_util_sort_rearrange_tp->proc~rmvs_util_sort_rearrange_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_sort_rearrange_tp.html"},{"title":"rmvs_util_spill_pl – swiftest","text":"module subroutine rmvs_util_spill_pl(self, discards, lspill_list, ldestructive) Interface → Move spilled (discarded) RMVS test particle structure from active list to discard list Adapted from David E. Kaufmann's Swifter routine discard_discard_spill.f90 Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not Calls proc~~rmvs_util_spill_pl~~CallsGraph proc~rmvs_util_spill_pl rmvs_util_spill_pl util_spill util_spill proc~rmvs_util_spill_pl->util_spill util_exit util_exit proc~rmvs_util_spill_pl->util_exit whm_util_spill_pl whm_util_spill_pl proc~rmvs_util_spill_pl->whm_util_spill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_spill_pl~~CalledByGraph proc~rmvs_util_spill_pl rmvs_util_spill_pl interface~rmvs_util_spill_pl rmvs_util_spill_pl interface~rmvs_util_spill_pl->proc~rmvs_util_spill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_spill_pl.html"},{"title":"rmvs_util_spill_tp – swiftest","text":"module subroutine rmvs_util_spill_tp(self, discards, lspill_list, ldestructive) Interface → Move spilled (discarded) RMVS test particle structure from active list to discard list Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not Calls proc~~rmvs_util_spill_tp~~CallsGraph proc~rmvs_util_spill_tp rmvs_util_spill_tp util_spill_tp util_spill_tp proc~rmvs_util_spill_tp->util_spill_tp util_spill util_spill proc~rmvs_util_spill_tp->util_spill util_exit util_exit proc~rmvs_util_spill_tp->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_spill_tp~~CalledByGraph proc~rmvs_util_spill_tp rmvs_util_spill_tp interface~rmvs_util_spill_tp rmvs_util_spill_tp interface~rmvs_util_spill_tp->proc~rmvs_util_spill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_spill_tp.html"},{"title":"rmvs_kick_getacch_tp – swiftest","text":"module subroutine rmvs_kick_getacch_tp(self, system, param, t, lbeg) Interface → Compute the oblateness acceleration in the inner encounter region with planets Performs a similar task as David E. Kaufmann's Swifter routine rmvs_kick_getacch_tp.f90, but \n uses object polymorphism, and so is not directly adapted. Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest central body particle data structuree class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step Calls proc~~rmvs_kick_getacch_tp~~CallsGraph proc~rmvs_kick_getacch_tp rmvs_kick_getacch_tp whm_kick_getacch_tp whm_kick_getacch_tp proc~rmvs_kick_getacch_tp->whm_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_kick_getacch_tp~~CalledByGraph proc~rmvs_kick_getacch_tp rmvs_kick_getacch_tp interface~rmvs_kick_getacch_tp rmvs_kick_getacch_tp interface~rmvs_kick_getacch_tp->proc~rmvs_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_kick_getacch_tp.html"},{"title":"rmvs_setup_pl – swiftest","text":"module subroutine rmvs_setup_pl(self, n, param) Interface → Allocate RMVS test particle structure Equivalent in functionality to David E. Kaufmann's Swifter routine rmvs_setup.f90\n Call allocation method for parent class Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameter Calls proc~~rmvs_setup_pl~~CallsGraph proc~rmvs_setup_pl rmvs_setup_pl whm_setup_pl whm_setup_pl proc~rmvs_setup_pl->whm_setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_setup_pl~~CalledByGraph proc~rmvs_setup_pl rmvs_setup_pl interface~rmvs_setup_pl rmvs_setup_pl interface~rmvs_setup_pl->proc~rmvs_setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_setup_pl.html"},{"title":"rmvs_setup_initialize_system – swiftest","text":"module subroutine rmvs_setup_initialize_system(self, param) Interface → Initialize an RMVS nbody system from files and sets up the planetocentric structures. We currently rearrange the pl order to keep it consistent with the way Swifter does it \n In Swifter, the central body occupies the first position in the pl list, and during\n encounters, the encountering planet is skipped in loops. In Swiftest, we instantiate an\n RMVS nbody system object attached to each pl to store planetocentric versions of the system\n to use during close encounters. Arguments Type Intent Optional Attributes Name class( rmvs_nbody_system ), intent(inout) :: self RMVS system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters Calls proc~~rmvs_setup_initialize_system~~CallsGraph proc~rmvs_setup_initialize_system rmvs_setup_initialize_system whm_setup_initialize_system whm_setup_initialize_system proc~rmvs_setup_initialize_system->whm_setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_setup_initialize_system~~CalledByGraph proc~rmvs_setup_initialize_system rmvs_setup_initialize_system interface~rmvs_setup_initialize_system rmvs_setup_initialize_system interface~rmvs_setup_initialize_system->proc~rmvs_setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_setup_initialize_system.html"},{"title":"rmvs_setup_tp – swiftest","text":"module subroutine rmvs_setup_tp(self, n, param) Interface → Allocate WHM test particle structure Equivalent in functionality to David E. Kaufmann's Swifter routine whm_setup.f90\n Call allocation method for parent class. In this case, whm does not have its own setup method, so we use the base method for swiftest_tp Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameter Calls proc~~rmvs_setup_tp~~CallsGraph proc~rmvs_setup_tp rmvs_setup_tp setup_tp setup_tp proc~rmvs_setup_tp->setup_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_setup_tp~~CalledByGraph proc~rmvs_setup_tp rmvs_setup_tp interface~rmvs_setup_tp rmvs_setup_tp interface~rmvs_setup_tp->proc~rmvs_setup_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_setup_tp.html"},{"title":"rmvs_step_system – swiftest","text":"module subroutine rmvs_step_system(self, param, t, dt) Interface → Step massive bodies and and active test particles ahead in heliocentric coordinates Adapted from Hal Levison's Swift routine rmvs3_step.f\n Adapted from David E. Kaufmann's Swifter routine rmvs_step.f90 Arguments Type Intent Optional Attributes Name class( rmvs_nbody_system ), intent(inout) :: self RMVS nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current stepsiz Calls proc~~rmvs_step_system~~CallsGraph proc~rmvs_step_system rmvs_step_system whm_step_system whm_step_system proc~rmvs_step_system->whm_step_system proc~rmvs_step_out rmvs_step_out proc~rmvs_step_system->proc~rmvs_step_out proc~rmvs_interp_out rmvs_interp_out proc~rmvs_step_system->proc~rmvs_interp_out proc~rmvs_interp_in rmvs_interp_in proc~rmvs_step_out->proc~rmvs_interp_in proc~rmvs_step_in rmvs_step_in proc~rmvs_step_out->proc~rmvs_step_in util_exit util_exit proc~rmvs_interp_out->util_exit proc~rmvs_interp_in->util_exit proc~rmvs_end_planetocentric rmvs_end_planetocentric proc~rmvs_step_in->proc~rmvs_end_planetocentric proc~rmvs_make_planetocentric rmvs_make_planetocentric proc~rmvs_step_in->proc~rmvs_make_planetocentric proc~rmvs_peri_tp rmvs_peri_tp proc~rmvs_step_in->proc~rmvs_peri_tp xpc xpc proc~rmvs_peri_tp->xpc vpc vpc proc~rmvs_peri_tp->vpc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_step_system~~CalledByGraph proc~rmvs_step_system rmvs_step_system interface~rmvs_step_system rmvs_step_system interface~rmvs_step_system->proc~rmvs_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_step_system.html"},{"title":"rmvs_encounter_check_tp – swiftest","text":"module function rmvs_encounter_check_tp(self, system, dt) result(lencounter) Interface → Determine whether a test particle and planet are having or will have an encounter within the next time step Adapted from David E. Kaufmann's Swifter routine: rmvs_chk.f90\n Adapted from Hal Levison's Swift routine rmvs3_chk.f Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class( rmvs_nbody_system ), intent(inout) :: system RMVS nbody system object real(kind=DP), intent(in) :: dt step size Return Value logical Returns true if there is at least one close encounter Calls proc~~rmvs_encounter_check_tp~~CallsGraph proc~rmvs_encounter_check_tp rmvs_encounter_check_tp interface~rmvs_chk_ind rmvs_chk_ind proc~rmvs_encounter_check_tp->interface~rmvs_chk_ind proc~rmvs_chk_ind rmvs_chk_ind interface~rmvs_chk_ind->proc~rmvs_chk_ind Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_encounter_check_tp~~CalledByGraph proc~rmvs_encounter_check_tp rmvs_encounter_check_tp interface~rmvs_encounter_check_tp rmvs_encounter_check_tp interface~rmvs_encounter_check_tp->proc~rmvs_encounter_check_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_encounter_check_tp.html"},{"title":"rmvs_chk_ind – swiftest","text":"elemental module function rmvs_chk_ind(r2, v2, vdotr, dt, r2crit) result(lflag) Interface → Determine whether a test particle and planet are having or will have an encounter within the next time step Adapted from David E. Kaufmann's Swifter routine: rmvs_chk_ind.f90\n Adapted from Hal Levison's Swift routine rmvs_chk_ind.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: r2 real(kind=DP), intent(in) :: v2 real(kind=DP), intent(in) :: vdotr real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r2crit Return Value logical Called by proc~~rmvs_chk_ind~~CalledByGraph proc~rmvs_chk_ind rmvs_chk_ind interface~rmvs_chk_ind rmvs_chk_ind interface~rmvs_chk_ind->proc~rmvs_chk_ind proc~symba_encounter_check_one symba_encounter_check_one proc~symba_encounter_check_one->interface~rmvs_chk_ind proc~rmvs_encounter_check_tp rmvs_encounter_check_tp proc~rmvs_encounter_check_tp->interface~rmvs_chk_ind interface~symba_encounter_check_one symba_encounter_check_one interface~symba_encounter_check_one->proc~symba_encounter_check_one interface~rmvs_encounter_check_tp rmvs_encounter_check_tp interface~rmvs_encounter_check_tp->proc~rmvs_encounter_check_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_chk_ind.html"},{"title":"rmvs_classes – swiftest","text":"Definition of classes and methods specific to the Regularized Mixed Variable Symplectic (RMVS) integrator\n Partially adapted from David E. Kaufmann's Swifter module: module_rmvs.f90 rmvs_cb class definitions and method interfaces rmvs_tp class definitions and method interfaces RMVS test particle class rmvs_pl class definitions and method interfaces Uses swiftest_globals whm_classes module~~rmvs_classes~~UsesGraph module~rmvs_classes rmvs_classes module~swiftest_globals swiftest_globals module~rmvs_classes->module~swiftest_globals module~whm_classes whm_classes module~rmvs_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~swiftest_classes swiftest_classes module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: s_rmvs_chk s_rmvs_discard s_rmvs_kick s_rmvs_setup s_rmvs_step s_rmvs_util module~~rmvs_classes~~UsedByGraph module~rmvs_classes rmvs_classes module~s_rmvs_step s_rmvs_step module~s_rmvs_step->module~rmvs_classes module~swiftest swiftest module~s_rmvs_step->module~swiftest module~swiftest->module~rmvs_classes module~symba_classes symba_classes module~swiftest->module~symba_classes module~s_rmvs_util s_rmvs_util module~s_rmvs_util->module~rmvs_classes module~s_rmvs_util->module~swiftest module~symba_classes->module~rmvs_classes module~s_rmvs_kick s_rmvs_kick module~s_rmvs_kick->module~rmvs_classes module~s_rmvs_kick->module~swiftest module~s_rmvs_setup s_rmvs_setup module~s_rmvs_setup->module~rmvs_classes module~s_rmvs_setup->module~swiftest module~s_rmvs_chk s_rmvs_chk module~s_rmvs_chk->module~rmvs_classes module~s_rmvs_chk->module~swiftest module~s_rmvs_discard s_rmvs_discard module~s_rmvs_discard->module~rmvs_classes module~s_rmvs_discard->module~swiftest module~whm_drift whm_drift module~whm_drift->module~swiftest module~s_gr s_gr module~s_gr->module~swiftest module~s_symba_setup s_symba_setup module~s_symba_setup->module~swiftest module~s_symba_setup->module~symba_classes module~s_whm_setup s_whm_setup module~s_whm_setup->module~swiftest module~s_util_append s_util_append module~s_util_append->module~swiftest module~s_helio_kick s_helio_kick module~s_helio_kick->module~swiftest module~s_helio_gr s_helio_gr module~s_helio_gr->module~swiftest module~s_symba_discard s_symba_discard module~s_symba_discard->module~swiftest module~s_symba_discard->module~symba_classes module~s_obl s_obl module~s_obl->module~swiftest module~s_util_set s_util_set module~s_util_set->module~swiftest module~s_helio_step s_helio_step module~s_helio_step->module~swiftest module~s_util_exit s_util_exit module~s_util_exit->module~swiftest module~s_symba_fragmentation s_symba_fragmentation module~s_symba_fragmentation->module~swiftest module~s_symba_fragmentation->module~symba_classes module~s_util_coord s_util_coord module~s_util_coord->module~swiftest proc~ge_wpp ge_wpp proc~ge_wpp->module~swiftest module~s_util_sort s_util_sort module~s_util_sort->module~swiftest module~s_util_copy s_util_copy module~s_util_copy->module~swiftest module~s_symba_util s_symba_util module~s_symba_util->module~swiftest module~s_symba_util->module~symba_classes module~s_symba_encounter_check s_symba_encounter_check module~s_symba_encounter_check->module~swiftest module~s_symba_encounter_check->module~symba_classes module~s_whm_kick s_whm_kick module~s_whm_kick->module~swiftest module~s_util_fill s_util_fill module~s_util_fill->module~swiftest module~s_symba_io s_symba_io module~s_symba_io->module~swiftest module~s_symba_io->module~symba_classes module~drift_implementation drift_implementation module~drift_implementation->module~swiftest module~s_symba_collision s_symba_collision module~s_symba_collision->module~swiftest module~s_symba_collision->module~symba_classes module~s_tides_step_spin s_tides_step_spin module~s_tides_step_spin->module~swiftest module~s_user_kick_getacch s_user_kick_getacch module~s_user_kick_getacch->module~swiftest module~s_util_version s_util_version module~s_util_version->module~swiftest module~s_util_spill s_util_spill module~s_util_spill->module~swiftest module~s_helio_coord s_helio_coord module~s_helio_coord->module~swiftest module~s_orbel s_orbel module~s_orbel->module~swiftest module~s_util_valid s_util_valid module~s_util_valid->module~swiftest module~s_eucl s_eucl module~s_eucl->module~swiftest module~s_operator_cross s_operator_cross module~s_operator_cross->module~swiftest module~s_discard s_discard module~s_discard->module~swiftest module~s_helio_drift s_helio_drift module~s_helio_drift->module~swiftest program~swiftest_driver swiftest_driver program~swiftest_driver->module~swiftest module~s_util_solve s_util_solve module~s_util_solve->module~swiftest module~s_whm_util s_whm_util module~s_whm_util->module~swiftest module~s_setup s_setup module~s_setup->module~swiftest module~s_symba_kick s_symba_kick module~s_symba_kick->module~swiftest module~s_symba_kick->module~symba_classes proc~solve_wbs solve_wbs proc~solve_wbs->module~swiftest module~s_kick s_kick module~s_kick->module~swiftest module~s_tides_kick_getacch s_tides_kick_getacch module~s_tides_kick_getacch->module~swiftest module~s_util_minimize_bfgs s_util_minimize_bfgs module~s_util_minimize_bfgs->module~swiftest module~s_util_get_energy_momentum s_util_get_energy_momentum module~s_util_get_energy_momentum->module~swiftest module~s_whm_coord s_whm_coord module~s_whm_coord->module~swiftest module~s_util_resize s_util_resize module~s_util_resize->module~swiftest module~s_util_rescale s_util_rescale module~s_util_rescale->module~swiftest module~s_whm_gr s_whm_gr module~s_whm_gr->module~swiftest module~s_whm_step s_whm_step module~s_whm_step->module~swiftest module~s_fragmentation s_fragmentation module~s_fragmentation->module~swiftest module~s_symba_drift s_symba_drift module~s_symba_drift->module~swiftest module~s_symba_drift->module~symba_classes module~s_symba_step s_symba_step module~s_symba_step->module~swiftest module~s_symba_step->module~symba_classes module~s_io s_io module~s_io->module~swiftest module~s_util_peri s_util_peri module~s_util_peri->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables NTENC NTPHENC NTPENC RHSCALE RHPSCALE FACQDT Interfaces rmvs_chk_ind rmvs_encounter_check_tp rmvs_discard_tp rmvs_kick_getacch_tp rmvs_setup_pl rmvs_setup_initialize_system rmvs_setup_tp rmvs_util_append_pl rmvs_util_append_tp rmvs_util_fill_pl rmvs_util_fill_tp rmvs_util_resize_pl rmvs_util_resize_tp rmvs_util_sort_pl rmvs_util_sort_tp rmvs_util_sort_rearrange_pl rmvs_util_sort_rearrange_tp rmvs_util_spill_pl rmvs_util_spill_tp rmvs_step_system Derived Types rmvs_nbody_system rmvs_interp rmvs_cb rmvs_tp rmvs_pl Variables Type Visibility Attributes Name Initial integer(kind=I4B), private, parameter :: NTENC = 10 integer(kind=I4B), private, parameter :: NTPHENC = 3 integer(kind=I4B), private, parameter :: NTPENC = NTENC*NTPHENC real(kind=DP), private, parameter :: RHSCALE = 3.5_DP real(kind=DP), private, parameter :: RHPSCALE = 1.0_DP real(kind=DP), private, parameter :: FACQDT = 2.0_DP rmvs_nbody_system class definitions and method interfaces Interfaces interface public elemental module function rmvs_chk_ind(r2, v2, vdotr, dt, r2crit) result(lflag) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: r2 real(kind=DP), intent(in) :: v2 real(kind=DP), intent(in) :: vdotr real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r2crit Return Value logical interface public module function rmvs_encounter_check_tp(self, system, dt) result(lencounter) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class( rmvs_nbody_system ), intent(inout) :: system RMVS nbody system object real(kind=DP), intent(in) :: dt step size Return Value logical Returns true if there is at least one close encounter interface public module subroutine rmvs_discard_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters interface public module subroutine rmvs_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest central body particle data structuree class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step interface public module subroutine rmvs_setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameters interface public module subroutine rmvs_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_nbody_system ), intent(inout) :: self RMVS system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters interface public module subroutine rmvs_setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parametere interface public module subroutine rmvs_util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine rmvs_util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine rmvs_util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps interface public module subroutine rmvs_util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps interface public module subroutine rmvs_util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in) :: nnew New size neded interface public module subroutine rmvs_util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: nnew New size neded interface public module subroutine rmvs_util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order interface public module subroutine rmvs_util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order interface public module subroutine rmvs_util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) interface public module subroutine rmvs_util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) interface public module subroutine rmvs_util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not interface public module subroutine rmvs_util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not interface public module subroutine rmvs_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_nbody_system ), intent(inout) :: self RMVS nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize Derived Types type, public, extends( whm_nbody_system ) :: rmvs_nbody_system Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step class( swiftest_cb ), public, allocatable :: cb Central body data structure class( swiftest_pl ), public, allocatable :: pl Massive body data structure class( swiftest_tp ), public, allocatable :: tp Test particle data structure class( swiftest_tp ), public, allocatable :: tp_discards Discarded test particle data structure class( swiftest_pl ), public, allocatable :: pl_discards Discarded massive body particle data structure real(kind=DP), public :: Gmtot = 0.0_DP Total system mass - used for barycentric coordinate conversion real(kind=DP), public :: ke_orbit = 0.0_DP System orbital kinetic energy real(kind=DP), public :: ke_spin = 0.0_DP System spin kinetic energy real(kind=DP), public :: pe = 0.0_DP System potential energy real(kind=DP), public :: te = 0.0_DP System total energy real(kind=DP), public, dimension(NDIM) :: Lorbit = 0.0_DP System orbital angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lspin = 0.0_DP System spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lescape = 0.0_DP Angular momentum of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Mescape = 0.0_DP Mass of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Ecollisions = 0.0_DP Energy lost from system due to collisions real(kind=DP), public :: Euntracked = 0.0_DP Energy gained from system due to escaped bodies logical, public :: lbeg True if this is the beginning of a step. This is used so that test particle steps can be calculated \n    separately from massive bodies.  Massive body variables are saved at half steps, and passed to \n    the test particles integer(kind=I4B), public :: maxid = -1 The current maximum particle id number logical, public :: lplanetocentric = .false. In the RMVS integrator, only test particles are discarded\n Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations real(kind=DP), public :: rts fraction of Hill's sphere radius to use as radius of encounter region real(kind=DP), public, dimension(:,:), allocatable :: vbeg Planet velocities at beginning ot step Type-Bound Procedures procedure, public :: discard => discard_system Perform a discard step on the system procedure, public :: conservation_report => io_conservation_report Compute energy and momentum and print out the change with time procedure, public :: dump => io_dump_system Dump the state of the system to a file procedure, public :: read_frame => io_read_frame_system Read in a frame of input data from file procedure, public :: write_discard => io_write_discard Write out information about discarded test particles procedure, public :: write_frame => io_write_frame_system Append a frame of output data to file procedure, public :: step_spin => tides_step_spin_system Steps the spins of the massive & central bodies due to tides. procedure, public :: set_msys => util_set_msys Sets the value of msys from the masses of system bodies. procedure, public :: get_energy_and_momentum => util_get_energy_momentum_system Calculates the total system energy and momentum procedure, public :: rescale => util_rescale_system Rescales the system into a new set of units procedure, public :: validate_ids => util_valid_id_system Validate the numerical ids passed to the system and save the maximum value procedure, public :: initialize => rmvs_setup_initialize_system Replace the abstract procedures with concrete ones\n Performs RMVS-specific initilization steps, including generating the close encounter planetocentric structures procedure, public :: step => rmvs_step_system Advance the RMVS nbody system forward in time by one step type, private :: rmvs_interp Components Type Visibility Attributes Name Initial real(kind=DP), public, dimension(:, :), allocatable :: x interpolated heliocentric planet position for outer encounter real(kind=DP), public, dimension(:, :), allocatable :: v interpolated heliocentric planet velocity for outer encounter real(kind=DP), public, dimension(:, :), allocatable :: aobl Encountering planet's oblateness acceleration value real(kind=DP), public, dimension(:, :), allocatable :: atide Encountering planet's tidal acceleration value type, public, extends( whm_cb ) :: rmvs_cb RMVS central body particle class Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step character(len=STRMAX), public :: name Non-unique name integer(kind=I4B), public :: id = 0 External identifier (unique) real(kind=DP), public :: mass = 0.0_DP Central body mass (units MU) real(kind=DP), public :: Gmass = 0.0_DP Central mass gravitational term G * mass (units GU * MU) real(kind=DP), public :: radius = 0.0_DP Central body radius (units DU) real(kind=DP), public :: density = 1.0_DP Central body mass density - calculated internally (units MU / DU**3) real(kind=DP), public :: j2rp2 = 0.0_DP J2*R&#94;2 term for central body real(kind=DP), public :: j4rp4 = 0.0_DP J4*R&#94;2 term for central body real(kind=DP), public, dimension(NDIM) :: aobl = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: atide = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: aoblbeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: aoblend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: atidebeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: atideend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: xb = 0.0_DP Barycentric position (units DU) real(kind=DP), public, dimension(NDIM) :: vb = 0.0_DP Barycentric velocity (units DU / TU) real(kind=DP), public, dimension(NDIM) :: agr = 0.0_DP Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(NDIM) :: Ip = 0.0_DP Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(NDIM) :: rot = 0.0_DP Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public :: k2 = 0.0_DP Tidal Love number real(kind=DP), public :: Q = 0.0_DP Tidal quality factor real(kind=DP), public :: tlag = 0.0_DP Tidal phase lag angle real(kind=DP), public, dimension(NDIM) :: L0 = 0.0_DP Initial angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: dL = 0.0_DP Change in angular momentum of the central body type( rmvs_interp ), public, dimension(:), allocatable :: outer interpolated heliocentric central body position for outer encounters type( rmvs_interp ), public, dimension(:), allocatable :: inner interpolated heliocentric central body position for inner encounters logical, public :: lplanetocentric = .false. Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations Type-Bound Procedures procedure, public :: dump => io_dump_swiftest procedure, public :: initialize => io_read_cb_in I/O routine for reading in central body data procedure, public :: read_frame => io_read_frame_cb I/O routine for reading out a single frame of time-series data for the central body procedure, public :: write_frame => io_write_frame_cb I/O routine for writing out a single frame of time-series data for the central body type, public, extends( whm_tp ) :: rmvs_tp Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the\n    component list, such as rmvs_setup_tp and rmvs_util_spill_tp Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill integer(kind=I4B), public, dimension(:), allocatable :: isperi Perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri Perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp Semimajor axis following perihelion passage\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_tp and util_spill_tp logical, public, dimension(:), allocatable :: lperi planetocentric pericenter passage flag (persistent for a full rmvs time step) over a full RMVS time step) integer(kind=I4B), public, dimension(:), allocatable :: plperP index of planet associated with pericenter distance peri (persistent over a full RMVS time step) integer(kind=I4B), public, dimension(:), allocatable :: plencP index of planet that test particle is encountering (not persistent for a full RMVS time step) type( rmvs_cb ), public :: cb_heliocentric Copy of original central body object passed to close encounter (used for oblateness acceleration during planetocentric encoountters) real(kind=DP), public, dimension(:,:), allocatable :: xheliocentric original heliocentric position (used for oblateness calculation during close encounters) integer(kind=I4B), public :: index inner substep number within current set integer(kind=I4B), public :: ipleP index value of encountering planet logical, public :: lplanetocentric = .false. Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations Type-Bound Procedures procedure, public :: dump => io_dump_swiftest procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) procedure, public :: accel_int => kick_getacch_int_tp Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies procedure, public :: accel_obl => obl_acc_tp Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: h2b => util_coord_h2b_tp Convert test particles from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_tp Convert test particles from barycentric to heliocentric coordinates (position and velocity) procedure, public :: get_peri => util_peri_tp Determine system pericenter passages for test particles procedure, public :: set_mu => util_set_mu_tp Method used to construct the vectorized form of the central body mass procedure, public :: accel_gr => whm_gr_kick_getacch_tp Acceleration term arising from the post-Newtonian correction procedure, public :: gr_pos_kick => whm_gr_p4_tp Position kick due to p**4 term in the post-Newtonian correction procedure, public :: kick => whm_kick_vh_tp Kick heliocentric velocities of test particles procedure, public :: step => whm_step_tp Steps the particle forward one stepsize procedure, public :: discard => rmvs_discard_tp Check to see if test particles should be discarded based on pericenter passage distances with respect to planets encountered procedure, public :: encounter_check => rmvs_encounter_check_tp Checks if any test particles are undergoing a close encounter with a massive body procedure, public :: accel => rmvs_kick_getacch_tp Calculates either the standard or modified version of the acceleration depending if the\n    if the test particle is undergoing a close encounter or not procedure, public :: setup => rmvs_setup_tp Constructor method - Allocates space for the input number of bodiess procedure, public :: append => rmvs_util_append_tp Appends elements from one structure to another procedure, public :: fill => rmvs_util_fill_tp \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: resize => rmvs_util_resize_tp Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure, public :: sort => rmvs_util_sort_tp Sorts body arrays by a sortable componen procedure, public :: rearrange => rmvs_util_sort_rearrange_tp Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => rmvs_util_spill_tp \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) type, public, extends( whm_pl ) :: rmvs_pl RMVS massive body particle class Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl real(kind=DP), public, dimension(:), allocatable :: eta Jacobi mass real(kind=DP), public, dimension(:,:), allocatable :: xj Jacobi position real(kind=DP), public, dimension(:,:), allocatable :: vj Jacobi velocity real(kind=DP), public, dimension(:), allocatable :: muj Jacobi mu: GMcb * eta(i) / eta(i - 1) real(kind=DP), public, dimension(:), allocatable :: ir3j Third term of heliocentric acceleration\n Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the\n    component list, such as whm_setup_pl and whm_util_spill_pl integer(kind=I4B), public, dimension(:), allocatable :: nenc number of test particles encountering planet this full rmvs time step integer(kind=I4B), public, dimension(:), allocatable :: tpenc1P index of first test particle encountering planet integer(kind=I4B), public, dimension(:), allocatable :: plind Connects the planetocentric indices back to the heliocentric planet list type( rmvs_interp ), public, dimension(:), allocatable :: outer interpolated heliocentric central body position for outer encounters type( rmvs_interp ), public, dimension(:), allocatable :: inner interpolated heliocentric central body position for inner encounters class( rmvs_nbody_system ), public, dimension(:), allocatable :: planetocentric Planetocentric version of the massive body objects (one for each massive body) logical, public :: lplanetocentric = .false. Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations Type-Bound Procedures procedure, public :: dump => io_dump_swiftest procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: discard => discard_pl Placeholder method for discarding massive bodies procedure, public :: eucl_index => eucl_dist_index_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body procedure, public :: h2j => whm_coord_h2j_pl Convert position and velcoity vectors from heliocentric to Jacobi coordinates procedure, public :: j2h => whm_coord_j2h_pl Convert position and velcoity vectors from Jacobi to helliocentric coordinates procedure, public :: vh2vj => whm_coord_vh2vj_pl Convert velocity vectors from heliocentric to Jacobi coordinates procedure, public :: drift => whm_drift_pl Loop through massive bodies and call Danby drift routine to jacobi coordinates procedure, public :: accel_gr => whm_gr_kick_getacch_pl Acceleration term arising from the post-Newtonian correction procedure, public :: gr_pos_kick => whm_gr_p4_pl Position kick due to p**4 term in the post-Newtonian correction procedure, public :: accel => whm_kick_getacch_pl Compute heliocentric accelerations of massive bodies procedure, public :: kick => whm_kick_vh_pl Kick heliocentric velocities of massive bodies procedure, public :: set_ir3 => whm_util_set_ir3j Sets both the heliocentric and jacobi inverse radius terms (1/rj 3 and 1/rh 3) procedure, public :: set_mu => whm_util_set_mu_eta_pl Sets the Jacobi mass value for all massive bodies. procedure, public :: step => whm_step_pl Steps the body forward one stepsize procedure, public :: setup => rmvs_setup_pl Constructor method - Allocates space for the input number of bodiess procedure, public :: append => rmvs_util_append_pl Appends elements from one structure to another procedure, public :: fill => rmvs_util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: resize => rmvs_util_resize_pl Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure, public :: sort => rmvs_util_sort_pl Sorts body arrays by a sortable componen procedure, public :: rearrange => rmvs_util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => rmvs_util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic)","tags":"","loc":"module/rmvs_classes.html"},{"title":"swiftest_globals – swiftest","text":"Basic parameters, definitions, and global type definitions used throughout the Swiftest project\n Adapted from David E. Kaufmann's Swifter routine: swiftest_globals.f90 and module_swifter.f90 Uses iso_fortran_env Contents Variables I8B I4B I2B I1B SP DP QP PIBY2 PI PI3BY2 TWOPI THIRD DEGRAD LOWERCASE_BEGIN LOWERCASE_END UPPERCASE_OFFSET VERSION_NUMBER UNKNOWN_INTEGRATOR BS HELIO RA15 TU4 WHM RMVS SYMBA RINGMOONS STRMAX ASCII_TYPE REAL4_TYPE REAL8_TYPE SWIFTER_REAL4_TYPE SWIFTER_REAL8_TYPE EL XV nthreads NTHERSHOLD SUCCESS FAILURE USAGE HELP SUCCESS_MSG FAIL_MSG USAGE_MSG HELP_MSG ELLIPSE PARABOLA HYPERBOLA ACTIVE INACTIVE DISCARDED_RMAX DISCARDED_RMIN DISCARDED_RMAXU DISCARDED_PERI DISCARDED_PLR DISCARDED_PLQ DISCARDED_DRIFTERR MERGED DISRUPTION SUPERCATASTROPHIC GRAZE_AND_MERGE HIT_AND_RUN COLLISION COLLRESOLVE_REGIME_MERGE COLLRESOLVE_REGIME_DISRUPTION COLLRESOLVE_REGIME_SUPERCATASTROPHIC COLLRESOLVE_REGIME_GRAZE_AND_MERGE COLLRESOLVE_REGIME_HIT_AND_RUN ADD SUB NDUMPFILES DUMP_CB_FILE DUMP_PL_FILE DUMP_TP_FILE DUMP_PARAM_FILE ENC_OUTFILE DISCARD_FILE ENERGY_FILE CB_INFILE PL_INFILE TP_INFILE BIN_OUTFILE BINUNIT NDIM NDIM2 VSMALL GC einsteinC Variables Type Visibility Attributes Name Initial integer, public, parameter :: I8B = int64 Symbolic name for kind types of 8-byte integers integer, public, parameter :: I4B = int32 Symbolic name for kind types of 4-byte integers integer, public, parameter :: I2B = int16 Symbolic name for kind types of 2-byte integers integer, public, parameter :: I1B = int8 Symbolic name for kind types of 1-byte integers integer, public, parameter :: SP = real32 Symbolic name for kind types of single-precision reals integer, public, parameter :: DP = real64 Symbolic name for kind types of double-precision reals integer, public, parameter :: QP = real128 Symbolic name for kind types of quad-precision reals real(kind=DP), public, parameter :: PIBY2 = 1.570796326794896619231321691639751442099_DP Definition of /(\\pi / 2) real(kind=DP), public, parameter :: PI = 3.141592653589793238462643383279502884197_DP Definition of /(\\pi) real(kind=DP), public, parameter :: PI3BY2 = 4.712388980384689857693965074919254326296_DP Definition of /(3 \\pi / 2) real(kind=DP), public, parameter :: TWOPI = 6.283185307179586476925286766559005768394_DP Definition of 2 \\pi real(kind=DP), public, parameter :: THIRD = 0.333333333333333333333333333333333333333_DP Definition of 1 / 3 real(kind=DP), public, parameter :: DEGRAD = 180.0_DP/PI Definition of conversion factor from degrees to radians integer(kind=I4B), public, parameter :: LOWERCASE_BEGIN = iachar('a') ASCII character set parameter for lower to upper conversion - start of lowercase integer(kind=I4B), public, parameter :: LOWERCASE_END = iachar('z') ASCII character set parameter for lower to upper conversion - end of lowercase integer(kind=I4B), public, parameter :: UPPERCASE_OFFSET = iachar('A')-iachar('a') ASCII character set parameter for lower to upper conversion - offset between upper and lower real(kind=SP), public, parameter :: VERSION_NUMBER = 0.1_SP swiftest version integer(kind=I4B), public, parameter :: UNKNOWN_INTEGRATOR = 1 Symbolic name for integrator types integer(kind=I4B), public, parameter :: BS = 2 integer(kind=I4B), public, parameter :: HELIO = 3 integer(kind=I4B), public, parameter :: RA15 = 4 integer(kind=I4B), public, parameter :: TU4 = 5 integer(kind=I4B), public, parameter :: WHM = 6 integer(kind=I4B), public, parameter :: RMVS = 7 integer(kind=I4B), public, parameter :: SYMBA = 8 integer(kind=I4B), public, parameter :: RINGMOONS = 9 integer(kind=I4B), public, parameter :: STRMAX = 128 Maximum size of character strings character(len=*), public, parameter :: ASCII_TYPE = 'ASCII' Symbolic name for ASCII file type character(len=*), public, parameter :: REAL4_TYPE = 'REAL4' Symbolic name for binary file type REAL4 character(len=*), public, parameter :: REAL8_TYPE = 'REAL8' Symbolic name for binary file type REAL8 character(len=*), public, parameter :: SWIFTER_REAL4_TYPE = 'SWIFTER4' Symbolic name for binary file type for the old style Swifter REAL4 character(len=*), public, parameter :: SWIFTER_REAL8_TYPE = 'SWIFTER8' Symbolic name for binary file type for the old style Swifter REAL8 character(len=*), public, parameter :: EL = 'EL' Symbolic name for binary output file contents for orbital element type character(len=*), public, parameter :: XV = 'XV' Symbolic name for binary output file contents for cartesian position and velocity type integer(kind=I4B), public :: nthreads = 1 Number of OpenMP threads integer(kind=I4B), public, parameter :: NTHERSHOLD = 1000 Threshold value for OpenMP loop parallelization integer(kind=I4B), public, parameter :: SUCCESS = 0 Symbolic name for function return/flag code for success integer(kind=I4B), public, parameter :: FAILURE = -1 Symbolic name for function return/flag code for failure integer(kind=I4B), public, parameter :: USAGE = -2 Symbolic name for function return/flag code for printing the usage message integer(kind=I4B), public, parameter :: HELP = -3 Symbolic name for function return/flag code for printing the usage message character(len=*), public, parameter :: SUCCESS_MSG = '(/, \"Normal termination of Swiftest (version \", f3.1, \")\")' character(len=*), public, parameter :: FAIL_MSG = '(/, \"Terminating Swiftest (version \", f3.1, \") due to error!!\")' character(len=*), public, parameter :: USAGE_MSG = '(\"Usage: swiftest [bs|helio|ra15|rmvs|symba|tu4|whm] \")' character(len=*), public, parameter :: HELP_MSG = USAGE_MSG integer(kind=I4B), public, parameter :: ELLIPSE = -1 Symbolic names for orbit types - ellipse integer(kind=I4B), public, parameter :: PARABOLA = 0 Symbolic names for orbit types - parabola integer(kind=I4B), public, parameter :: HYPERBOLA = 1 Symbolic names for orbit types - hyperbola integer(kind=I4B), public, parameter :: ACTIVE = 0 Symbolic names for body/particle status codes: integer(kind=I4B), public, parameter :: INACTIVE = 1 integer(kind=I4B), public, parameter :: DISCARDED_RMAX = -1 integer(kind=I4B), public, parameter :: DISCARDED_RMIN = -2 integer(kind=I4B), public, parameter :: DISCARDED_RMAXU = -3 integer(kind=I4B), public, parameter :: DISCARDED_PERI = -4 integer(kind=I4B), public, parameter :: DISCARDED_PLR = -5 integer(kind=I4B), public, parameter :: DISCARDED_PLQ = -6 integer(kind=I4B), public, parameter :: DISCARDED_DRIFTERR = -7 integer(kind=I4B), public, parameter :: MERGED = -8 integer(kind=I4B), public, parameter :: DISRUPTION = -9 integer(kind=I4B), public, parameter :: SUPERCATASTROPHIC = -10 integer(kind=I4B), public, parameter :: GRAZE_AND_MERGE = -11 integer(kind=I4B), public, parameter :: HIT_AND_RUN = -12 integer(kind=I4B), public, parameter :: COLLISION = -13 integer(kind=I4B), public, parameter :: COLLRESOLVE_REGIME_MERGE = 1 Symbolic names for collisional outcomes from collresolve_resolve: integer(kind=I4B), public, parameter :: COLLRESOLVE_REGIME_DISRUPTION = 2 integer(kind=I4B), public, parameter :: COLLRESOLVE_REGIME_SUPERCATASTROPHIC = 3 integer(kind=I4B), public, parameter :: COLLRESOLVE_REGIME_GRAZE_AND_MERGE = 4 integer(kind=I4B), public, parameter :: COLLRESOLVE_REGIME_HIT_AND_RUN = 5 character(len=*), public, parameter :: ADD = '+1' String labels for body/particle addition/subtraction in discard file character(len=*), public, parameter :: SUB = '-1' integer(kind=I4B), public, parameter :: NDUMPFILES = 2 Standard file names character(len=*), public, parameter, dimension(2) :: DUMP_CB_FILE = ['dump_cb1.bin', 'dump_cb2.bin'] character(len=*), public, parameter, dimension(2) :: DUMP_PL_FILE = ['dump_pl1.bin', 'dump_pl2.bin'] character(len=*), public, parameter, dimension(2) :: DUMP_TP_FILE = ['dump_tp1.bin', 'dump_tp2.bin'] character(len=*), public, parameter, dimension(2) :: DUMP_PARAM_FILE = ['dump_param1.dat', 'dump_param2.dat'] character(len=*), public, parameter :: ENC_OUTFILE = 'encounter.out' Default file names that can be changed by the user in the parameters file character(len=*), public, parameter :: DISCARD_FILE = 'discard.out' character(len=*), public, parameter :: ENERGY_FILE = 'energy.out' character(len=*), public, parameter :: CB_INFILE = 'cb.in' character(len=*), public, parameter :: PL_INFILE = 'pl.in' character(len=*), public, parameter :: TP_INFILE = 'tp.in' character(len=*), public, parameter :: BIN_OUTFILE = 'bin.dat' integer(kind=I4B), public, parameter :: BINUNIT = 20 File unit number for the binary output file integer(kind=I4B), public, parameter :: NDIM = 3 Miscellaneous constants:\n Number of dimensions in our reality integer(kind=I4B), public, parameter :: NDIM2 = 2*NDIM 2x the number of dimensions real(kind=DP), public, parameter :: VSMALL = 2*epsilon(1._DP) Very small number used to prevent floating underflow real(kind=DP), public, parameter :: GC = 6.6743E-11_DP Universal gravitational constant in SI units real(kind=DP), public, parameter :: einsteinC = 299792458.0_DP Speed of light in SI units","tags":"","loc":"module/swiftest_globals.html"},{"title":"swiftest_operators – swiftest","text":"Custom operators, including\n   A .cross. B = Cross product of A(1:3) and B(1:3) Each operator can also do element-wise computation on arrays of the form .mag. A(1:3, 1:n) Interfaces for .cross. operator Interfaces for .mag. operator Uses swiftest_globals module~~swiftest_operators~~UsesGraph module~swiftest_operators swiftest_operators module~swiftest_globals swiftest_globals module~swiftest_operators->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: s_operator_mag s_operator_cross module~~swiftest_operators~~UsedByGraph module~swiftest_operators swiftest_operators module~swiftest swiftest module~swiftest->module~swiftest_operators module~s_operator_mag s_operator_mag module~s_operator_mag->module~swiftest_operators module~s_operator_cross s_operator_cross module~s_operator_cross->module~swiftest_operators module~s_operator_cross->module~swiftest module~whm_drift whm_drift module~whm_drift->module~swiftest module~s_gr s_gr module~s_gr->module~swiftest module~s_symba_setup s_symba_setup module~s_symba_setup->module~swiftest module~s_whm_setup s_whm_setup module~s_whm_setup->module~swiftest module~s_util_append s_util_append module~s_util_append->module~swiftest module~s_helio_kick s_helio_kick module~s_helio_kick->module~swiftest module~s_helio_gr s_helio_gr module~s_helio_gr->module~swiftest module~s_symba_discard s_symba_discard module~s_symba_discard->module~swiftest module~s_rmvs_util s_rmvs_util module~s_rmvs_util->module~swiftest module~s_obl s_obl module~s_obl->module~swiftest module~s_rmvs_setup s_rmvs_setup module~s_rmvs_setup->module~swiftest module~s_util_set s_util_set module~s_util_set->module~swiftest module~s_helio_step s_helio_step module~s_helio_step->module~swiftest module~s_util_exit s_util_exit module~s_util_exit->module~swiftest module~s_rmvs_step s_rmvs_step module~s_rmvs_step->module~swiftest module~s_symba_fragmentation s_symba_fragmentation module~s_symba_fragmentation->module~swiftest module~s_util_coord s_util_coord module~s_util_coord->module~swiftest proc~ge_wpp ge_wpp proc~ge_wpp->module~swiftest module~s_util_sort s_util_sort module~s_util_sort->module~swiftest module~s_util_copy s_util_copy module~s_util_copy->module~swiftest module~s_symba_util s_symba_util module~s_symba_util->module~swiftest module~s_symba_encounter_check s_symba_encounter_check module~s_symba_encounter_check->module~swiftest module~s_whm_kick s_whm_kick module~s_whm_kick->module~swiftest module~s_util_fill s_util_fill module~s_util_fill->module~swiftest module~s_symba_io s_symba_io module~s_symba_io->module~swiftest module~drift_implementation drift_implementation module~drift_implementation->module~swiftest module~s_symba_collision s_symba_collision module~s_symba_collision->module~swiftest module~s_tides_step_spin s_tides_step_spin module~s_tides_step_spin->module~swiftest module~s_user_kick_getacch s_user_kick_getacch module~s_user_kick_getacch->module~swiftest module~s_util_version s_util_version module~s_util_version->module~swiftest module~s_util_spill s_util_spill module~s_util_spill->module~swiftest module~s_helio_coord s_helio_coord module~s_helio_coord->module~swiftest module~s_rmvs_discard s_rmvs_discard module~s_rmvs_discard->module~swiftest module~s_orbel s_orbel module~s_orbel->module~swiftest module~s_util_valid s_util_valid module~s_util_valid->module~swiftest module~s_eucl s_eucl module~s_eucl->module~swiftest module~s_discard s_discard module~s_discard->module~swiftest module~s_helio_drift s_helio_drift module~s_helio_drift->module~swiftest program~swiftest_driver swiftest_driver program~swiftest_driver->module~swiftest module~s_util_solve s_util_solve module~s_util_solve->module~swiftest module~s_whm_util s_whm_util module~s_whm_util->module~swiftest module~s_setup s_setup module~s_setup->module~swiftest module~s_symba_kick s_symba_kick module~s_symba_kick->module~swiftest proc~solve_wbs solve_wbs proc~solve_wbs->module~swiftest module~s_kick s_kick module~s_kick->module~swiftest module~s_tides_kick_getacch s_tides_kick_getacch module~s_tides_kick_getacch->module~swiftest module~s_rmvs_chk s_rmvs_chk module~s_rmvs_chk->module~swiftest module~s_util_minimize_bfgs s_util_minimize_bfgs module~s_util_minimize_bfgs->module~swiftest module~s_util_get_energy_momentum s_util_get_energy_momentum module~s_util_get_energy_momentum->module~swiftest module~s_whm_coord s_whm_coord module~s_whm_coord->module~swiftest module~s_util_resize s_util_resize module~s_util_resize->module~swiftest module~s_util_rescale s_util_rescale module~s_util_rescale->module~swiftest module~s_whm_gr s_whm_gr module~s_whm_gr->module~swiftest module~s_rmvs_kick s_rmvs_kick module~s_rmvs_kick->module~swiftest module~s_whm_step s_whm_step module~s_whm_step->module~swiftest module~s_fragmentation s_fragmentation module~s_fragmentation->module~swiftest module~s_symba_drift s_symba_drift module~s_symba_drift->module~swiftest module~s_symba_step s_symba_step module~s_symba_step->module~swiftest module~s_io s_io module~s_io->module~swiftest module~s_util_peri s_util_peri module~s_util_peri->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces operator(.cross.) operator(.mag.) Interfaces public interface operator(.cross.) public pure function operator_cross_sp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: A real(kind=SP), intent(in), dimension(:) :: B Return Value real(kind=SP),\n  dimension(3) public pure function operator_cross_dp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: A real(kind=DP), intent(in), dimension(:) :: B Return Value real(kind=DP),\n  dimension(3) public pure function operator_cross_qp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:) :: A real(kind=QP), intent(in), dimension(:) :: B Return Value real(kind=QP),\n  dimension(3) public pure function operator_cross_i1b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in), dimension(:) :: A integer(kind=I1B), intent(in), dimension(:) :: B Return Value integer(kind=I1B),\n  dimension(3) public pure function operator_cross_i2b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in), dimension(:) :: A integer(kind=I2B), intent(in), dimension(:) :: B Return Value integer(kind=I2B),\n  dimension(3) public pure function operator_cross_i4b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:) :: A integer(kind=I4B), intent(in), dimension(:) :: B Return Value integer(kind=I4B),\n  dimension(3) public pure function operator_cross_i8b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in), dimension(:) :: A integer(kind=I8B), intent(in), dimension(:) :: B Return Value integer(kind=I8B),\n  dimension(3) public pure function operator_cross_el_sp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:,:) :: A real(kind=SP), intent(in), dimension(:,:) :: B Return Value real(kind=SP),\n  dimension(:,:), allocatable public pure function operator_cross_el_dp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A real(kind=DP), intent(in), dimension(:,:) :: B Return Value real(kind=DP),\n  dimension(:,:), allocatable public pure function operator_cross_el_qp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A real(kind=QP), intent(in), dimension(:,:) :: B Return Value real(kind=QP),\n  dimension(:,:), allocatable public pure function operator_cross_el_i1b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in), dimension(:,:) :: A integer(kind=I1B), intent(in), dimension(:,:) :: B Return Value integer(kind=I1B),\n  dimension(:,:), allocatable public pure function operator_cross_el_i2b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in), dimension(:,:) :: A integer(kind=I2B), intent(in), dimension(:,:) :: B Return Value integer(kind=I2B),\n  dimension(:,:), allocatable public pure function operator_cross_el_i4b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:,:) :: A integer(kind=I4B), intent(in), dimension(:,:) :: B Return Value integer(kind=I4B),\n  dimension(:,:), allocatable public pure function operator_cross_el_i8b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in), dimension(:,:) :: A integer(kind=I8B), intent(in), dimension(:,:) :: B Return Value integer(kind=I8B),\n  dimension(:,:), allocatable public interface operator(.mag.) public pure function operator_mag_sp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: A Return Value real(kind=SP) public pure function operator_mag_dp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: A Return Value real(kind=DP) public pure function operator_mag_qp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:) :: A Return Value real(kind=QP) public pure function operator_mag_el_sp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:,:) :: A Return Value real(kind=SP),\n  dimension(:), allocatable public pure function operator_mag_el_dp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A Return Value real(kind=DP),\n  dimension(:), allocatable public pure function operator_mag_el_qp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A Return Value real(kind=QP),\n  dimension(:), allocatable","tags":"","loc":"module/swiftest_operators.html"},{"title":"helio_classes – swiftest","text":"Definition of classes and methods specific to the Democratic Heliocentric Method\n Adapted from David E. Kaufmann's Swifter routine: helio.f90 helio_nbody_system class definitions and method interfaces helio_cb class definitions and method interfaces helio_pl class definitions and method interfaces Helio massive body particle class helio_tp class definitions and method interfaces Helio test particle class Uses swiftest_globals swiftest_classes whm_classes module~~helio_classes~~UsesGraph module~helio_classes helio_classes module~swiftest_classes swiftest_classes module~helio_classes->module~swiftest_classes module~swiftest_globals swiftest_globals module~helio_classes->module~swiftest_globals module~whm_classes whm_classes module~helio_classes->module~whm_classes module~swiftest_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: s_helio_coord s_helio_drift s_helio_gr s_helio_kick s_helio_step module~~helio_classes~~UsedByGraph module~helio_classes helio_classes module~swiftest swiftest module~swiftest->module~helio_classes module~symba_classes symba_classes module~swiftest->module~symba_classes module~s_helio_kick s_helio_kick module~s_helio_kick->module~helio_classes module~s_helio_kick->module~swiftest module~symba_classes->module~helio_classes module~s_helio_gr s_helio_gr module~s_helio_gr->module~helio_classes module~s_helio_gr->module~swiftest module~s_helio_drift s_helio_drift module~s_helio_drift->module~helio_classes module~s_helio_drift->module~swiftest module~s_helio_coord s_helio_coord module~s_helio_coord->module~helio_classes module~s_helio_coord->module~swiftest module~s_helio_step s_helio_step module~s_helio_step->module~helio_classes module~s_helio_step->module~swiftest module~whm_drift whm_drift module~whm_drift->module~swiftest module~s_gr s_gr module~s_gr->module~swiftest module~s_symba_setup s_symba_setup module~s_symba_setup->module~swiftest module~s_symba_setup->module~symba_classes module~s_whm_setup s_whm_setup module~s_whm_setup->module~swiftest module~s_util_append s_util_append module~s_util_append->module~swiftest module~s_symba_discard s_symba_discard module~s_symba_discard->module~swiftest module~s_symba_discard->module~symba_classes module~s_rmvs_util s_rmvs_util module~s_rmvs_util->module~swiftest module~s_obl s_obl module~s_obl->module~swiftest module~s_rmvs_setup s_rmvs_setup module~s_rmvs_setup->module~swiftest module~s_util_set s_util_set module~s_util_set->module~swiftest module~s_util_exit s_util_exit module~s_util_exit->module~swiftest module~s_rmvs_step s_rmvs_step module~s_rmvs_step->module~swiftest module~s_symba_fragmentation s_symba_fragmentation module~s_symba_fragmentation->module~swiftest module~s_symba_fragmentation->module~symba_classes module~s_util_coord s_util_coord module~s_util_coord->module~swiftest proc~ge_wpp ge_wpp proc~ge_wpp->module~swiftest module~s_util_sort s_util_sort module~s_util_sort->module~swiftest module~s_util_copy s_util_copy module~s_util_copy->module~swiftest module~s_symba_util s_symba_util module~s_symba_util->module~swiftest module~s_symba_util->module~symba_classes module~s_symba_encounter_check s_symba_encounter_check module~s_symba_encounter_check->module~swiftest module~s_symba_encounter_check->module~symba_classes module~s_whm_kick s_whm_kick module~s_whm_kick->module~swiftest module~s_util_fill s_util_fill module~s_util_fill->module~swiftest module~s_symba_io s_symba_io module~s_symba_io->module~swiftest module~s_symba_io->module~symba_classes module~drift_implementation drift_implementation module~drift_implementation->module~swiftest module~s_symba_collision s_symba_collision module~s_symba_collision->module~swiftest module~s_symba_collision->module~symba_classes module~s_tides_step_spin s_tides_step_spin module~s_tides_step_spin->module~swiftest module~s_user_kick_getacch s_user_kick_getacch module~s_user_kick_getacch->module~swiftest module~s_util_version s_util_version module~s_util_version->module~swiftest module~s_util_spill s_util_spill module~s_util_spill->module~swiftest module~s_rmvs_discard s_rmvs_discard module~s_rmvs_discard->module~swiftest module~s_orbel s_orbel module~s_orbel->module~swiftest module~s_util_valid s_util_valid module~s_util_valid->module~swiftest module~s_eucl s_eucl module~s_eucl->module~swiftest module~s_operator_cross s_operator_cross module~s_operator_cross->module~swiftest module~s_discard s_discard module~s_discard->module~swiftest program~swiftest_driver swiftest_driver program~swiftest_driver->module~swiftest module~s_util_solve s_util_solve module~s_util_solve->module~swiftest module~s_whm_util s_whm_util module~s_whm_util->module~swiftest module~s_setup s_setup module~s_setup->module~swiftest module~s_symba_kick s_symba_kick module~s_symba_kick->module~swiftest module~s_symba_kick->module~symba_classes proc~solve_wbs solve_wbs proc~solve_wbs->module~swiftest module~s_kick s_kick module~s_kick->module~swiftest module~s_tides_kick_getacch s_tides_kick_getacch module~s_tides_kick_getacch->module~swiftest module~s_rmvs_chk s_rmvs_chk module~s_rmvs_chk->module~swiftest module~s_util_minimize_bfgs s_util_minimize_bfgs module~s_util_minimize_bfgs->module~swiftest module~s_util_get_energy_momentum s_util_get_energy_momentum module~s_util_get_energy_momentum->module~swiftest module~s_whm_coord s_whm_coord module~s_whm_coord->module~swiftest module~s_util_resize s_util_resize module~s_util_resize->module~swiftest module~s_util_rescale s_util_rescale module~s_util_rescale->module~swiftest module~s_whm_gr s_whm_gr module~s_whm_gr->module~swiftest module~s_rmvs_kick s_rmvs_kick module~s_rmvs_kick->module~swiftest module~s_whm_step s_whm_step module~s_whm_step->module~swiftest module~s_fragmentation s_fragmentation module~s_fragmentation->module~swiftest module~s_symba_drift s_symba_drift module~s_symba_drift->module~swiftest module~s_symba_drift->module~symba_classes module~s_symba_step s_symba_step module~s_symba_step->module~swiftest module~s_symba_step->module~symba_classes module~s_io s_io module~s_io->module~swiftest module~s_util_peri s_util_peri module~s_util_peri->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces helio_coord_vb2vh_pl helio_coord_vb2vh_tp helio_coord_vh2vb_pl helio_coord_vh2vb_tp helio_drift_body helio_drift_pl helio_drift_tp helio_drift_linear_pl helio_drift_linear_tp helio_gr_kick_getacch_pl helio_gr_kick_getacch_tp helio_gr_p4_pl helio_gr_p4_tp helio_kick_getacch_pl helio_kick_getacch_tp helio_kick_vb_pl helio_kick_vb_tp helio_step_pl helio_step_system helio_step_tp Derived Types helio_nbody_system helio_cb helio_pl helio_tp Interfaces interface public module subroutine helio_coord_vb2vh_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object interface public module subroutine helio_coord_vb2vh_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body interface public module subroutine helio_coord_vh2vb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object interface public module subroutine helio_coord_vh2vb_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body interface public module subroutine helio_drift_body(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class(swiftest_body), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize interface public module subroutine helio_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize interface public module subroutine helio_drift_tp(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize interface public module subroutine helio_drift_linear_pl(self, cb, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( helio_cb ), intent(inout) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step interface public module subroutine helio_drift_linear_tp(self, cb, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( helio_cb ), intent(in) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step interface public module subroutine helio_gr_kick_getacch_pl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters interface public module subroutine helio_gr_kick_getacch_tp(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters interface public pure module subroutine helio_gr_p4_pl(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size interface public pure module subroutine helio_gr_p4_tp(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size interface public module subroutine helio_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step interface public module subroutine helio_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step interface public module subroutine helio_kick_vb_pl(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. interface public module subroutine helio_kick_vb_tp(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. interface public module subroutine helio_step_pl(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nboody system class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize interface public module subroutine helio_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_nbody_system ), intent(inout) :: self Helio nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize interface public module subroutine helio_step_tp(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsizee Derived Types type, public, extends( whm_nbody_system ) :: helio_nbody_system Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step class( swiftest_cb ), public, allocatable :: cb Central body data structure class( swiftest_pl ), public, allocatable :: pl Massive body data structure class( swiftest_tp ), public, allocatable :: tp Test particle data structure class( swiftest_tp ), public, allocatable :: tp_discards Discarded test particle data structure class( swiftest_pl ), public, allocatable :: pl_discards Discarded massive body particle data structure real(kind=DP), public :: Gmtot = 0.0_DP Total system mass - used for barycentric coordinate conversion real(kind=DP), public :: ke_orbit = 0.0_DP System orbital kinetic energy real(kind=DP), public :: ke_spin = 0.0_DP System spin kinetic energy real(kind=DP), public :: pe = 0.0_DP System potential energy real(kind=DP), public :: te = 0.0_DP System total energy real(kind=DP), public, dimension(NDIM) :: Lorbit = 0.0_DP System orbital angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lspin = 0.0_DP System spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lescape = 0.0_DP Angular momentum of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Mescape = 0.0_DP Mass of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Ecollisions = 0.0_DP Energy lost from system due to collisions real(kind=DP), public :: Euntracked = 0.0_DP Energy gained from system due to escaped bodies logical, public :: lbeg True if this is the beginning of a step. This is used so that test particle steps can be calculated \n    separately from massive bodies.  Massive body variables are saved at half steps, and passed to \n    the test particles integer(kind=I4B), public :: maxid = -1 The current maximum particle id number Type-Bound Procedures procedure, public :: discard => discard_system Perform a discard step on the system procedure, public :: conservation_report => io_conservation_report Compute energy and momentum and print out the change with time procedure, public :: dump => io_dump_system Dump the state of the system to a file procedure, public :: read_frame => io_read_frame_system Read in a frame of input data from file procedure, public :: write_discard => io_write_discard Write out information about discarded test particles procedure, public :: write_frame => io_write_frame_system Append a frame of output data to file procedure, public :: step_spin => tides_step_spin_system Steps the spins of the massive & central bodies due to tides. procedure, public :: set_msys => util_set_msys Sets the value of msys from the masses of system bodies. procedure, public :: get_energy_and_momentum => util_get_energy_momentum_system Calculates the total system energy and momentum procedure, public :: rescale => util_rescale_system Rescales the system into a new set of units procedure, public :: validate_ids => util_valid_id_system Validate the numerical ids passed to the system and save the maximum value procedure, public :: initialize => whm_setup_initialize_system Replace the abstract procedures with concrete ones\n Performs WHM-specific initilization steps, like calculating the Jacobi masses procedure, public :: step => helio_step_system Advance the Helio nbody system forward in time by one step type, public, extends( swiftest_cb ) :: helio_cb Helio central body particle class Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step character(len=STRMAX), public :: name Non-unique name integer(kind=I4B), public :: id = 0 External identifier (unique) real(kind=DP), public :: mass = 0.0_DP Central body mass (units MU) real(kind=DP), public :: Gmass = 0.0_DP Central mass gravitational term G * mass (units GU * MU) real(kind=DP), public :: radius = 0.0_DP Central body radius (units DU) real(kind=DP), public :: density = 1.0_DP Central body mass density - calculated internally (units MU / DU**3) real(kind=DP), public :: j2rp2 = 0.0_DP J2*R&#94;2 term for central body real(kind=DP), public :: j4rp4 = 0.0_DP J4*R&#94;2 term for central body real(kind=DP), public, dimension(NDIM) :: aobl = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: atide = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: aoblbeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: aoblend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: atidebeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: atideend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: xb = 0.0_DP Barycentric position (units DU) real(kind=DP), public, dimension(NDIM) :: vb = 0.0_DP Barycentric velocity (units DU / TU) real(kind=DP), public, dimension(NDIM) :: agr = 0.0_DP Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(NDIM) :: Ip = 0.0_DP Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(NDIM) :: rot = 0.0_DP Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public :: k2 = 0.0_DP Tidal Love number real(kind=DP), public :: Q = 0.0_DP Tidal quality factor real(kind=DP), public :: tlag = 0.0_DP Tidal phase lag angle real(kind=DP), public, dimension(NDIM) :: L0 = 0.0_DP Initial angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: dL = 0.0_DP Change in angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: ptbeg negative barycentric velocity of the central body at the beginning of time step real(kind=DP), public, dimension(NDIM) :: ptend negative barycentric velocity of the central body at the end of time step Type-Bound Procedures procedure, public :: dump => io_dump_swiftest procedure, public :: initialize => io_read_cb_in I/O routine for reading in central body data procedure, public :: read_frame => io_read_frame_cb I/O routine for reading out a single frame of time-series data for the central body procedure, public :: write_frame => io_write_frame_cb I/O routine for writing out a single frame of time-series data for the central body type, public, extends( swiftest_pl ) :: helio_pl Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl Type-Bound Procedures procedure, public :: dump => io_dump_swiftest procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) procedure, public :: discard => discard_pl Placeholder method for discarding massive bodies procedure, public :: eucl_index => eucl_dist_index_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: setup => setup_pl A base constructor that sets the number of bodies and allocates and initializes all arrays procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body procedure, public :: append => util_append_pl Appends elements from one structure to another procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) procedure, public :: fill => util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: resize => util_resize_pl Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. procedure, public :: set_mu => util_set_mu_pl Method used to construct the vectorized form of the central body mass procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body procedure, public :: sort => util_sort_pl Sorts body arrays by a sortable component procedure, public :: rearrange => util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure, public :: vh2vb => helio_coord_vh2vb_pl Convert massive bodies from heliocentric to barycentric coordinates (velocity only) procedure, public :: vb2vh => helio_coord_vb2vh_pl Convert massive bodies from barycentric to heliocentric coordinates (velocity only) procedure, public :: drift => helio_drift_pl Method for Danby drift in Democratic Heliocentric coordinates procedure, public :: lindrift => helio_drift_linear_pl Method for linear drift of massive bodies due to barycentric momentum of Sun procedure, public :: accel_gr => helio_gr_kick_getacch_pl Acceleration term arising from the post-Newtonian correction procedure, public :: gr_pos_kick => helio_gr_p4_pl Position kick due to p**4 term in the post-Newtonian correction procedure, public :: accel => helio_kick_getacch_pl Compute heliocentric accelerations of massive bodies procedure, public :: kick => helio_kick_vb_pl Kicks the barycentric velocities procedure, public :: step => helio_step_pl Steps the body forward one stepsize type, public, extends( swiftest_tp ) :: helio_tp Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill integer(kind=I4B), public, dimension(:), allocatable :: isperi Perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri Perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp Semimajor axis following perihelion passage\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_tp and util_spill_tp Type-Bound Procedures procedure, public :: dump => io_dump_swiftest procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) procedure, public :: discard => discard_tp Check to see if test particles should be discarded based on their positions relative to the massive bodies procedure, public :: accel_int => kick_getacch_int_tp Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies procedure, public :: accel_obl => obl_acc_tp Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: setup => setup_tp A base constructor that sets the number of bodies and procedure, public :: append => util_append_tp Appends elements from one structure to another procedure, public :: h2b => util_coord_h2b_tp Convert test particles from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_tp Convert test particles from barycentric to heliocentric coordinates (position and velocity) procedure, public :: fill => util_fill_tp \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: get_peri => util_peri_tp Determine system pericenter passages for test particles procedure, public :: resize => util_resize_tp Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure, public :: set_mu => util_set_mu_tp Method used to construct the vectorized form of the central body mass procedure, public :: sort => util_sort_tp Sorts body arrays by a sortable component procedure, public :: rearrange => util_sort_rearrange_tp Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => util_spill_tp \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure, public :: vh2vb => helio_coord_vh2vb_tp Convert test particles from heliocentric to barycentric coordinates (velocity only) procedure, public :: vb2vh => helio_coord_vb2vh_tp Convert test particles from barycentric to heliocentric coordinates (velocity only) procedure, public :: lindrift => helio_drift_linear_tp Method for linear drift of massive bodies due to barycentric momentum of Sun procedure, public :: drift => helio_drift_tp Method for Danby drift in Democratic Heliocentric coordinates procedure, public :: accel_gr => helio_gr_kick_getacch_tp Acceleration term arising from the post-Newtonian correction procedure, public :: gr_pos_kick => helio_gr_p4_tp Position kick due to p**4 term in the post-Newtonian correction procedure, public :: accel => helio_kick_getacch_tp Compute heliocentric accelerations of massive bodies procedure, public :: kick => helio_kick_vb_tp Kicks the barycentric velocities procedure, public :: step => helio_step_tp Steps the body forward one stepsize","tags":"","loc":"module/helio_classes.html"},{"title":"whm_classes – swiftest","text":"Definition of classes and methods specific to the Democratic Heliocentric Method\n Partially adapted from David E. Kaufmann's Swifter module: module_whm.f90 whm_cb class definitions and method interfaces whm_pl class definitions and method interfaces whm_tp class definitions and method interfaces WHM test particle class whm_nbody_system class definitions and method interfaces Uses swiftest_globals swiftest_classes module~~whm_classes~~UsesGraph module~whm_classes whm_classes module~swiftest_globals swiftest_globals module~whm_classes->module~swiftest_globals module~swiftest_classes swiftest_classes module~whm_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~swiftest_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: s_whm_coord s_whm_gr s_whm_kick s_whm_setup s_whm_step s_whm_util whm_drift module~~whm_classes~~UsedByGraph module~whm_classes whm_classes module~whm_drift whm_drift module~whm_drift->module~whm_classes module~swiftest swiftest module~whm_drift->module~swiftest module~swiftest->module~whm_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~symba_classes symba_classes module~swiftest->module~symba_classes module~s_whm_setup s_whm_setup module~s_whm_setup->module~whm_classes module~s_whm_setup->module~swiftest module~s_whm_coord s_whm_coord module~s_whm_coord->module~whm_classes module~s_whm_coord->module~swiftest module~s_whm_kick s_whm_kick module~s_whm_kick->module~whm_classes module~s_whm_kick->module~swiftest module~s_whm_gr s_whm_gr module~s_whm_gr->module~whm_classes module~s_whm_gr->module~swiftest module~s_whm_step s_whm_step module~s_whm_step->module~whm_classes module~s_whm_step->module~swiftest module~s_whm_util s_whm_util module~s_whm_util->module~whm_classes module~s_whm_util->module~swiftest module~helio_classes->module~whm_classes module~rmvs_classes->module~whm_classes module~s_gr s_gr module~s_gr->module~swiftest module~s_symba_setup s_symba_setup module~s_symba_setup->module~swiftest module~s_symba_setup->module~symba_classes module~s_util_append s_util_append module~s_util_append->module~swiftest module~s_helio_kick s_helio_kick module~s_helio_kick->module~swiftest module~s_helio_kick->module~helio_classes module~s_helio_gr s_helio_gr module~s_helio_gr->module~swiftest module~s_helio_gr->module~helio_classes module~s_symba_discard s_symba_discard module~s_symba_discard->module~swiftest module~s_symba_discard->module~symba_classes module~s_rmvs_util s_rmvs_util module~s_rmvs_util->module~swiftest module~s_rmvs_util->module~rmvs_classes module~s_obl s_obl module~s_obl->module~swiftest module~s_rmvs_setup s_rmvs_setup module~s_rmvs_setup->module~swiftest module~s_rmvs_setup->module~rmvs_classes module~s_util_set s_util_set module~s_util_set->module~swiftest module~s_helio_step s_helio_step module~s_helio_step->module~swiftest module~s_helio_step->module~helio_classes module~s_util_exit s_util_exit module~s_util_exit->module~swiftest module~s_rmvs_step s_rmvs_step module~s_rmvs_step->module~swiftest module~s_rmvs_step->module~rmvs_classes module~s_symba_fragmentation s_symba_fragmentation module~s_symba_fragmentation->module~swiftest module~s_symba_fragmentation->module~symba_classes module~s_util_coord s_util_coord module~s_util_coord->module~swiftest proc~ge_wpp ge_wpp proc~ge_wpp->module~swiftest module~s_util_sort s_util_sort module~s_util_sort->module~swiftest module~s_util_copy s_util_copy module~s_util_copy->module~swiftest module~s_symba_util s_symba_util module~s_symba_util->module~swiftest module~s_symba_util->module~symba_classes module~s_symba_encounter_check s_symba_encounter_check module~s_symba_encounter_check->module~swiftest module~s_symba_encounter_check->module~symba_classes module~s_symba_io s_symba_io module~s_symba_io->module~swiftest module~s_symba_io->module~symba_classes module~s_util_fill s_util_fill module~s_util_fill->module~swiftest module~drift_implementation drift_implementation module~drift_implementation->module~swiftest module~s_symba_collision s_symba_collision module~s_symba_collision->module~swiftest module~s_symba_collision->module~symba_classes module~s_tides_step_spin s_tides_step_spin module~s_tides_step_spin->module~swiftest module~s_user_kick_getacch s_user_kick_getacch module~s_user_kick_getacch->module~swiftest module~s_util_version s_util_version module~s_util_version->module~swiftest module~s_util_spill s_util_spill module~s_util_spill->module~swiftest module~s_helio_coord s_helio_coord module~s_helio_coord->module~swiftest module~s_helio_coord->module~helio_classes module~s_rmvs_discard s_rmvs_discard module~s_rmvs_discard->module~swiftest module~s_rmvs_discard->module~rmvs_classes module~s_orbel s_orbel module~s_orbel->module~swiftest module~s_util_valid s_util_valid module~s_util_valid->module~swiftest module~s_eucl s_eucl module~s_eucl->module~swiftest module~s_operator_cross s_operator_cross module~s_operator_cross->module~swiftest module~s_discard s_discard module~s_discard->module~swiftest module~s_helio_drift s_helio_drift module~s_helio_drift->module~swiftest module~s_helio_drift->module~helio_classes program~swiftest_driver swiftest_driver program~swiftest_driver->module~swiftest module~s_util_solve s_util_solve module~s_util_solve->module~swiftest module~s_setup s_setup module~s_setup->module~swiftest module~s_symba_kick s_symba_kick module~s_symba_kick->module~swiftest module~s_symba_kick->module~symba_classes proc~solve_wbs solve_wbs proc~solve_wbs->module~swiftest module~s_kick s_kick module~s_kick->module~swiftest module~s_tides_kick_getacch s_tides_kick_getacch module~s_tides_kick_getacch->module~swiftest module~s_rmvs_chk s_rmvs_chk module~s_rmvs_chk->module~swiftest module~s_rmvs_chk->module~rmvs_classes module~s_util_minimize_bfgs s_util_minimize_bfgs module~s_util_minimize_bfgs->module~swiftest module~s_util_get_energy_momentum s_util_get_energy_momentum module~s_util_get_energy_momentum->module~swiftest module~symba_classes->module~helio_classes module~symba_classes->module~rmvs_classes module~s_util_resize s_util_resize module~s_util_resize->module~swiftest module~s_util_rescale s_util_rescale module~s_util_rescale->module~swiftest module~s_rmvs_kick s_rmvs_kick module~s_rmvs_kick->module~swiftest module~s_rmvs_kick->module~rmvs_classes module~s_fragmentation s_fragmentation module~s_fragmentation->module~swiftest module~s_symba_drift s_symba_drift module~s_symba_drift->module~swiftest module~s_symba_drift->module~symba_classes module~s_symba_step s_symba_step module~s_symba_step->module~swiftest module~s_symba_step->module~symba_classes module~s_io s_io module~s_io->module~swiftest module~s_util_peri s_util_peri module~s_util_peri->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces whm_coord_h2j_pl whm_coord_j2h_pl whm_coord_vh2vj_pl whm_drift_pl whm_kick_getacch_pl whm_kick_getacch_tp whm_kick_vh_pl whm_kick_vh_tp whm_gr_kick_getacch_pl whm_gr_kick_getacch_tp whm_gr_p4_pl whm_gr_p4_tp whm_setup_pl whm_setup_initialize_system whm_step_pl whm_step_system whm_step_tp whm_util_append_pl whm_util_spill_pl whm_util_fill_pl whm_util_resize_pl whm_util_set_ir3j whm_util_set_mu_eta_pl whm_util_sort_pl whm_util_sort_rearrange_pl Derived Types whm_cb whm_pl whm_tp whm_nbody_system Interfaces interface public module subroutine whm_coord_h2j_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree interface public module subroutine whm_coord_j2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree interface public module subroutine whm_coord_vh2vj_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree interface public module subroutine whm_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize interface public module subroutine whm_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Get heliocentric accelration of massive bodies Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step interface public module subroutine whm_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Get heliocentric accelration of the test particle Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step interface public module subroutine whm_kick_vh_pl(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. interface public module subroutine whm_kick_vh_tp(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. interface public module subroutine whm_gr_kick_getacch_pl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters interface public module subroutine whm_gr_kick_getacch_tp(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters interface public pure module subroutine whm_gr_p4_pl(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size interface public pure module subroutine whm_gr_p4_tp(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size interface public module subroutine whm_setup_pl(self, n, param) Implementation → Reads WHM massive body object in from file Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body objectobject integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameters interface public module subroutine whm_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_nbody_system ), intent(inout) :: self WHM nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters interface public module subroutine whm_step_pl(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize interface public module subroutine whm_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_nbody_system ), intent(inout) :: self WHM system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize interface public module subroutine whm_step_tp(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize interface public module subroutine whm_util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine whm_util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not interface public module subroutine whm_util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(in) :: inserts inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps interface public module subroutine whm_util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object integer(kind=I4B), intent(in) :: nnew New size neded interface public module subroutine whm_util_set_ir3j(self) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object interface public module subroutine whm_util_set_mu_eta_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object interface public module subroutine whm_util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order interface public module subroutine whm_util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) Derived Types type, public, extends( swiftest_cb ) :: whm_cb Swiftest central body particle class Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step character(len=STRMAX), public :: name Non-unique name integer(kind=I4B), public :: id = 0 External identifier (unique) real(kind=DP), public :: mass = 0.0_DP Central body mass (units MU) real(kind=DP), public :: Gmass = 0.0_DP Central mass gravitational term G * mass (units GU * MU) real(kind=DP), public :: radius = 0.0_DP Central body radius (units DU) real(kind=DP), public :: density = 1.0_DP Central body mass density - calculated internally (units MU / DU**3) real(kind=DP), public :: j2rp2 = 0.0_DP J2*R&#94;2 term for central body real(kind=DP), public :: j4rp4 = 0.0_DP J4*R&#94;2 term for central body real(kind=DP), public, dimension(NDIM) :: aobl = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: atide = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: aoblbeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: aoblend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: atidebeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: atideend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: xb = 0.0_DP Barycentric position (units DU) real(kind=DP), public, dimension(NDIM) :: vb = 0.0_DP Barycentric velocity (units DU / TU) real(kind=DP), public, dimension(NDIM) :: agr = 0.0_DP Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(NDIM) :: Ip = 0.0_DP Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(NDIM) :: rot = 0.0_DP Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public :: k2 = 0.0_DP Tidal Love number real(kind=DP), public :: Q = 0.0_DP Tidal quality factor real(kind=DP), public :: tlag = 0.0_DP Tidal phase lag angle real(kind=DP), public, dimension(NDIM) :: L0 = 0.0_DP Initial angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: dL = 0.0_DP Change in angular momentum of the central body Type-Bound Procedures procedure, public :: dump => io_dump_swiftest procedure, public :: initialize => io_read_cb_in I/O routine for reading in central body data procedure, public :: read_frame => io_read_frame_cb I/O routine for reading out a single frame of time-series data for the central body procedure, public :: write_frame => io_write_frame_cb I/O routine for writing out a single frame of time-series data for the central body type, public, extends( swiftest_pl ) :: whm_pl WHM massive body particle class Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl real(kind=DP), public, dimension(:), allocatable :: eta Jacobi mass real(kind=DP), public, dimension(:,:), allocatable :: xj Jacobi position real(kind=DP), public, dimension(:,:), allocatable :: vj Jacobi velocity real(kind=DP), public, dimension(:), allocatable :: muj Jacobi mu: GMcb * eta(i) / eta(i - 1) real(kind=DP), public, dimension(:), allocatable :: ir3j Third term of heliocentric acceleration\n Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the\n    component list, such as whm_setup_pl and whm_util_spill_pl Type-Bound Procedures procedure, public :: dump => io_dump_swiftest procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: discard => discard_pl Placeholder method for discarding massive bodies procedure, public :: eucl_index => eucl_dist_index_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body procedure, public :: h2j => whm_coord_h2j_pl Convert position and velcoity vectors from heliocentric to Jacobi coordinates procedure, public :: j2h => whm_coord_j2h_pl Convert position and velcoity vectors from Jacobi to helliocentric coordinates procedure, public :: vh2vj => whm_coord_vh2vj_pl Convert velocity vectors from heliocentric to Jacobi coordinates procedure, public :: drift => whm_drift_pl Loop through massive bodies and call Danby drift routine to jacobi coordinates procedure, public :: accel_gr => whm_gr_kick_getacch_pl Acceleration term arising from the post-Newtonian correction procedure, public :: gr_pos_kick => whm_gr_p4_pl Position kick due to p**4 term in the post-Newtonian correction procedure, public :: accel => whm_kick_getacch_pl Compute heliocentric accelerations of massive bodies procedure, public :: kick => whm_kick_vh_pl Kick heliocentric velocities of massive bodies procedure, public :: append => whm_util_append_pl Appends elements from one structure to another procedure, public :: fill => whm_util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: resize => whm_util_resize_pl Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure, public :: set_ir3 => whm_util_set_ir3j Sets both the heliocentric and jacobi inverse radius terms (1/rj 3 and 1/rh 3) procedure, public :: set_mu => whm_util_set_mu_eta_pl Sets the Jacobi mass value for all massive bodies. procedure, public :: sort => whm_util_sort_pl Sort a WHM massive body object in-place. procedure, public :: rearrange => whm_util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => whm_util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure, public :: setup => whm_setup_pl Constructor method - Allocates space for the input number of bodiess procedure, public :: step => whm_step_pl Steps the body forward one stepsize type, public, extends( swiftest_tp ) :: whm_tp Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the\n    component list, such as whm_util_spill_tp Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill integer(kind=I4B), public, dimension(:), allocatable :: isperi Perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri Perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp Semimajor axis following perihelion passage\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_tp and util_spill_tp Type-Bound Procedures procedure, public :: dump => io_dump_swiftest procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) procedure, public :: discard => discard_tp Check to see if test particles should be discarded based on their positions relative to the massive bodies procedure, public :: accel_int => kick_getacch_int_tp Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies procedure, public :: accel_obl => obl_acc_tp Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: setup => setup_tp A base constructor that sets the number of bodies and procedure, public :: append => util_append_tp Appends elements from one structure to another procedure, public :: h2b => util_coord_h2b_tp Convert test particles from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_tp Convert test particles from barycentric to heliocentric coordinates (position and velocity) procedure, public :: fill => util_fill_tp \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: get_peri => util_peri_tp Determine system pericenter passages for test particles procedure, public :: resize => util_resize_tp Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure, public :: set_mu => util_set_mu_tp Method used to construct the vectorized form of the central body mass procedure, public :: sort => util_sort_tp Sorts body arrays by a sortable component procedure, public :: rearrange => util_sort_rearrange_tp Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => util_spill_tp \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure, public :: accel_gr => whm_gr_kick_getacch_tp Acceleration term arising from the post-Newtonian correction procedure, public :: gr_pos_kick => whm_gr_p4_tp Position kick due to p**4 term in the post-Newtonian correction procedure, public :: accel => whm_kick_getacch_tp Compute heliocentric accelerations of test particles procedure, public :: kick => whm_kick_vh_tp Kick heliocentric velocities of test particles procedure, public :: step => whm_step_tp Steps the particle forward one stepsize type, public, extends( swiftest_nbody_system ) :: whm_nbody_system An abstract class for the WHM integrator nbody system Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step class( swiftest_cb ), public, allocatable :: cb Central body data structure class( swiftest_pl ), public, allocatable :: pl Massive body data structure class( swiftest_tp ), public, allocatable :: tp Test particle data structure class( swiftest_tp ), public, allocatable :: tp_discards Discarded test particle data structure class( swiftest_pl ), public, allocatable :: pl_discards Discarded massive body particle data structure real(kind=DP), public :: Gmtot = 0.0_DP Total system mass - used for barycentric coordinate conversion real(kind=DP), public :: ke_orbit = 0.0_DP System orbital kinetic energy real(kind=DP), public :: ke_spin = 0.0_DP System spin kinetic energy real(kind=DP), public :: pe = 0.0_DP System potential energy real(kind=DP), public :: te = 0.0_DP System total energy real(kind=DP), public, dimension(NDIM) :: Lorbit = 0.0_DP System orbital angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lspin = 0.0_DP System spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lescape = 0.0_DP Angular momentum of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Mescape = 0.0_DP Mass of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Ecollisions = 0.0_DP Energy lost from system due to collisions real(kind=DP), public :: Euntracked = 0.0_DP Energy gained from system due to escaped bodies logical, public :: lbeg True if this is the beginning of a step. This is used so that test particle steps can be calculated \n    separately from massive bodies.  Massive body variables are saved at half steps, and passed to \n    the test particles integer(kind=I4B), public :: maxid = -1 The current maximum particle id number Type-Bound Procedures procedure, public :: discard => discard_system Perform a discard step on the system procedure, public :: conservation_report => io_conservation_report Compute energy and momentum and print out the change with time procedure, public :: dump => io_dump_system Dump the state of the system to a file procedure, public :: read_frame => io_read_frame_system Read in a frame of input data from file procedure, public :: write_discard => io_write_discard Write out information about discarded test particles procedure, public :: write_frame => io_write_frame_system Append a frame of output data to file procedure, public :: step_spin => tides_step_spin_system Steps the spins of the massive & central bodies due to tides. procedure, public :: set_msys => util_set_msys Sets the value of msys from the masses of system bodies. procedure, public :: get_energy_and_momentum => util_get_energy_momentum_system Calculates the total system energy and momentum procedure, public :: rescale => util_rescale_system Rescales the system into a new set of units procedure, public :: validate_ids => util_valid_id_system Validate the numerical ids passed to the system and save the maximum value procedure, public :: initialize => whm_setup_initialize_system Replace the abstract procedures with concrete ones\n Performs WHM-specific initilization steps, like calculating the Jacobi masses procedure, public :: step => whm_step_system Advance the WHM nbody system forward in time by one step","tags":"","loc":"module/whm_classes.html"},{"title":"symba_classes – swiftest","text":"Definition of classes and methods specific to the Democratic SyMBAcentric Method\n Adapted from David E. Kaufmann's Swifter routine: helio.f90 symba_particle_info class definitions and method interfaces symba_kinship class definitions and method interfaces symba_cb class definitions and method interfaces symba_pl class definitions and method interfaces symba_tp class definitions and method interfaces symba_pltpenc class definitions and method interfaces symba_plplenc class definitions and method interfaces symba_nbody_system class definitions and method interfaces Uses swiftest_globals swiftest_classes helio_classes rmvs_classes module~~symba_classes~~UsesGraph module~symba_classes symba_classes module~helio_classes helio_classes module~symba_classes->module~helio_classes module~swiftest_globals swiftest_globals module~symba_classes->module~swiftest_globals module~swiftest_classes swiftest_classes module~symba_classes->module~swiftest_classes module~rmvs_classes rmvs_classes module~symba_classes->module~rmvs_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~whm_classes whm_classes module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: s_symba_collision s_symba_discard s_symba_drift s_symba_encounter_check s_symba_fragmentation s_symba_io s_symba_kick s_symba_setup s_symba_step s_symba_util module~~symba_classes~~UsedByGraph module~symba_classes symba_classes module~swiftest swiftest module~swiftest->module~symba_classes module~s_symba_setup s_symba_setup module~s_symba_setup->module~symba_classes module~s_symba_setup->module~swiftest module~s_symba_fragmentation s_symba_fragmentation module~s_symba_fragmentation->module~symba_classes module~s_symba_fragmentation->module~swiftest module~s_symba_discard s_symba_discard module~s_symba_discard->module~symba_classes module~s_symba_discard->module~swiftest module~s_symba_util s_symba_util module~s_symba_util->module~symba_classes module~s_symba_util->module~swiftest module~s_symba_encounter_check s_symba_encounter_check module~s_symba_encounter_check->module~symba_classes module~s_symba_encounter_check->module~swiftest module~s_symba_io s_symba_io module~s_symba_io->module~symba_classes module~s_symba_io->module~swiftest module~s_symba_collision s_symba_collision module~s_symba_collision->module~symba_classes module~s_symba_collision->module~swiftest module~s_symba_kick s_symba_kick module~s_symba_kick->module~symba_classes module~s_symba_kick->module~swiftest module~s_symba_drift s_symba_drift module~s_symba_drift->module~symba_classes module~s_symba_drift->module~swiftest module~s_symba_step s_symba_step module~s_symba_step->module~symba_classes module~s_symba_step->module~swiftest module~whm_drift whm_drift module~whm_drift->module~swiftest module~s_gr s_gr module~s_gr->module~swiftest module~s_whm_setup s_whm_setup module~s_whm_setup->module~swiftest module~s_util_append s_util_append module~s_util_append->module~swiftest module~s_helio_kick s_helio_kick module~s_helio_kick->module~swiftest module~s_helio_gr s_helio_gr module~s_helio_gr->module~swiftest module~s_rmvs_util s_rmvs_util module~s_rmvs_util->module~swiftest module~s_obl s_obl module~s_obl->module~swiftest module~s_rmvs_setup s_rmvs_setup module~s_rmvs_setup->module~swiftest module~s_util_set s_util_set module~s_util_set->module~swiftest module~s_helio_step s_helio_step module~s_helio_step->module~swiftest module~s_util_exit s_util_exit module~s_util_exit->module~swiftest module~s_rmvs_step s_rmvs_step module~s_rmvs_step->module~swiftest module~s_util_coord s_util_coord module~s_util_coord->module~swiftest proc~ge_wpp ge_wpp proc~ge_wpp->module~swiftest module~s_util_sort s_util_sort module~s_util_sort->module~swiftest module~s_util_copy s_util_copy module~s_util_copy->module~swiftest module~s_whm_kick s_whm_kick module~s_whm_kick->module~swiftest module~s_util_fill s_util_fill module~s_util_fill->module~swiftest module~drift_implementation drift_implementation module~drift_implementation->module~swiftest module~s_tides_step_spin s_tides_step_spin module~s_tides_step_spin->module~swiftest module~s_user_kick_getacch s_user_kick_getacch module~s_user_kick_getacch->module~swiftest module~s_util_version s_util_version module~s_util_version->module~swiftest module~s_util_spill s_util_spill module~s_util_spill->module~swiftest module~s_helio_coord s_helio_coord module~s_helio_coord->module~swiftest module~s_rmvs_discard s_rmvs_discard module~s_rmvs_discard->module~swiftest module~s_orbel s_orbel module~s_orbel->module~swiftest module~s_util_valid s_util_valid module~s_util_valid->module~swiftest module~s_eucl s_eucl module~s_eucl->module~swiftest module~s_operator_cross s_operator_cross module~s_operator_cross->module~swiftest module~s_discard s_discard module~s_discard->module~swiftest module~s_helio_drift s_helio_drift module~s_helio_drift->module~swiftest program~swiftest_driver swiftest_driver program~swiftest_driver->module~swiftest module~s_util_solve s_util_solve module~s_util_solve->module~swiftest module~s_whm_util s_whm_util module~s_whm_util->module~swiftest module~s_setup s_setup module~s_setup->module~swiftest module~s_rmvs_chk s_rmvs_chk module~s_rmvs_chk->module~swiftest proc~solve_wbs solve_wbs proc~solve_wbs->module~swiftest module~s_kick s_kick module~s_kick->module~swiftest module~s_tides_kick_getacch s_tides_kick_getacch module~s_tides_kick_getacch->module~swiftest module~s_util_minimize_bfgs s_util_minimize_bfgs module~s_util_minimize_bfgs->module~swiftest module~s_util_get_energy_momentum s_util_get_energy_momentum module~s_util_get_energy_momentum->module~swiftest module~s_whm_coord s_whm_coord module~s_whm_coord->module~swiftest module~s_util_resize s_util_resize module~s_util_resize->module~swiftest module~s_util_rescale s_util_rescale module~s_util_rescale->module~swiftest module~s_whm_gr s_whm_gr module~s_whm_gr->module~swiftest module~s_rmvs_kick s_rmvs_kick module~s_rmvs_kick->module~swiftest module~s_whm_step s_whm_step module~s_whm_step->module~swiftest module~s_fragmentation s_fragmentation module~s_fragmentation->module~swiftest module~s_io s_io module~s_io->module~swiftest module~s_util_peri s_util_peri module~s_util_peri->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables NENMAX NTENC RHSCALE RSHELL PARTICLE_OUTFILE PARTICLEUNIT Interfaces symba_encounter_check_pl symba_encounter_check_pltpenc symba_encounter_check_tp symba_fragmentation_casedisruption symba_fragmentation_casehitandrun symba_fragmentation_casemerge symba_fragmentation_casesupercatastrophic symba_collision_check_pltpenc symba_collision_encounter_scrub symba_collision_make_family_pl symba_collision_resolve_fragmentations symba_collision_resolve_mergers symba_discard_pl symba_drift_pl symba_drift_tp symba_encounter_check_one symba_io_write_discard symba_io_dump_particle_info symba_io_param_reader symba_io_param_writer symba_io_read_particle symba_kick_getacch_pl symba_kick_getacch_tp symba_kick_pltpenc symba_setup_initialize_particle_info symba_setup_initialize_system symba_setup_merger symba_setup_pl symba_setup_pltpenc symba_setup_tp symba_step_system symba_step_interp_system symba_step_set_recur_levels_system symba_step_recur_system symba_step_reset_system util_append symba_util_append_merger symba_util_append_pl symba_util_append_tp util_fill symba_util_fill_pl symba_util_fill_tp symba_util_peri_pl symba_util_rearray_pl util_resize symba_util_resize_merger symba_util_resize_pl symba_util_resize_tp symba_util_sort_pl symba_util_sort_tp symba_util_sort_rearrange_pl symba_util_sort_rearrange_tp util_spill symba_util_spill_pl symba_util_spill_pltpenc symba_util_spill_tp Derived Types symba_parameters symba_particle_info symba_kinship symba_cb symba_pl symba_merger symba_tp symba_pltpenc symba_plplenc symba_nbody_system Variables Type Visibility Attributes Name Initial integer(kind=I4B), private, parameter :: NENMAX = 32767 integer(kind=I4B), private, parameter :: NTENC = 3 real(kind=DP), private, parameter :: RHSCALE = 6.5_DP real(kind=DP), private, parameter :: RSHELL = 0.48075_DP character(len=*), public, parameter :: PARTICLE_OUTFILE = 'particle.dat' integer(kind=I4B), public, parameter :: PARTICLEUNIT = 44 File unit number for the binary particle info output file Interfaces interface public module function symba_encounter_check_pl(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter interface public module function symba_encounter_check_pltpenc(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-pl encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter interface public module function symba_encounter_check_tp(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter interface public module function symba_fragmentation_casedisruption(system, param, family, x, v, mass, radius, L_spin, Ip, mass_res, Qloss) result(status) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(in), dimension(:) :: family List of indices of all bodies inovlved in the collision real(kind=DP), intent(inout), dimension(:,:) :: x Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: v Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: radius Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: L_spin Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: Ip Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass_res The distribution of fragment mass obtained by the regime calculation real(kind=DP), intent(inout) :: Qloss Energy lost during collisionn Return Value integer(kind=I4B) Status flag assigned to this outcome interface public module function symba_fragmentation_casehitandrun(system, param, family, x, v, mass, radius, L_spin, Ip, mass_res, Qloss) result(status) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(in), dimension(:) :: family List of indices of all bodies inovlved in the collision real(kind=DP), intent(inout), dimension(:,:) :: x Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: v Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: radius Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: L_spin Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: Ip Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass_res The distribution of fragment mass obtained by the regime calculation real(kind=DP), intent(inout) :: Qloss Energy lost during collision Return Value integer(kind=I4B) Status flag assigned to this outcome interface public module function symba_fragmentation_casemerge(system, param, family, x, v, mass, radius, L_spin, Ip) result(status) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(in), dimension(:) :: family List of indices of all bodies inovlved in the collision real(kind=DP), intent(in), dimension(:,:) :: x Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(in), dimension(:,:) :: v Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(in), dimension(:) :: mass Input values that represent a 2-body equivalent of a possibly 2+ body collisio real(kind=DP), intent(in), dimension(:) :: radius Input values that represent a 2-body equivalent of a possibly 2+ body collisio real(kind=DP), intent(in), dimension(:,:) :: L_spin Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(in), dimension(:,:) :: Ip Input values that represent a 2-body equivalent of a possibly 2+ body collision Return Value integer(kind=I4B) Status flag assigned to this outcome interface public module function symba_fragmentation_casesupercatastrophic(system, param, family, x, v, mass, radius, L_spin, Ip, mass_res, Qloss) result(status) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(in), dimension(:) :: family List of indices of all bodies inovlved in the collision real(kind=DP), intent(inout), dimension(:,:) :: x Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: v Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: radius Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: L_spin Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: Ip Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass_res The distribution of fragment mass obtained by the regime calculation real(kind=DP), intent(inout) :: Qloss Energy lost during collision Return Value integer(kind=I4B) Status flag assigned to this outcome interface public module subroutine symba_collision_check_pltpenc(self, system, param, t, dt, irec) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t current time real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level interface public module subroutine symba_collision_encounter_scrub(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameterss interface public module subroutine symba_collision_make_family_pl(self, idx) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(2) :: idx Array holding the indices of the two bodies involved in the collision interface public module subroutine symba_collision_resolve_fragmentations(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions interface public module subroutine symba_collision_resolve_mergers(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions interface public module subroutine symba_discard_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine symba_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize interface public module subroutine symba_drift_tp(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize interface public pure elemental module subroutine symba_encounter_check_one(xr, yr, zr, vxr, vyr, vzr, rhill1, rhill2, dt, irec, lencounter, lvdotr) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: xr real(kind=DP), intent(in) :: yr real(kind=DP), intent(in) :: zr real(kind=DP), intent(in) :: vxr real(kind=DP), intent(in) :: vyr real(kind=DP), intent(in) :: vzr real(kind=DP), intent(in) :: rhill1 real(kind=DP), intent(in) :: rhill2 real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: irec logical, intent(out) :: lencounter logical, intent(out) :: lvdotr interface public module subroutine symba_io_write_discard(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine symba_io_dump_particle_info(system, param, lincludecb, tpidx, plidx) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA extensions logical, intent(in), optional :: lincludecb Set to true to include the central body (default is false) integer(kind=I4B), intent(in), optional dimension(:) :: tpidx Array of test particle indices to append to the particle file integer(kind=I4B), intent(in), optional dimension(:) :: plidx Array of massive body indices to append to the particle file interface public module subroutine symba_io_param_reader(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_parameters ), intent(inout) :: self Current run configuration parameters with SyMBA additionss integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) The first element passes the integrator code to the reader integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 interface public module subroutine symba_io_param_writer(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_parameters ), intent(in) :: self Current run configuration parameters with SyMBA additions integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) Not used in this procedure integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 interface public module subroutine symba_io_read_particle(system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system file class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA extensions interface public module subroutine symba_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step interface public module subroutine symba_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step interface public module subroutine symba_kick_pltpenc(self, system, dt, irec, sgn) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(in) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level integer(kind=I4B), intent(in) :: sgn sign to be applied to acceleration interface public module subroutine symba_setup_initialize_particle_info(system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA extensions interface public module subroutine symba_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine symba_setup_merger(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA merger list object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine symba_setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine symba_setup_pltpenc(self, n) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-tp encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for interface public module subroutine symba_setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter interface public module subroutine symba_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize interface public module subroutine symba_step_interp_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize interface public module subroutine symba_step_set_recur_levels_system(self, ireci) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system objec integer(kind=I4B), intent(in) :: ireci Input recursion level interface public recursive module subroutine symba_step_recur_system(self, param, t, ireci) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), value :: t integer(kind=I4B), value :: ireci input recursion level interface public module subroutine symba_step_reset_system(self) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object public interface util_append public subroutine symba_util_append_arr_info(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name type( symba_particle_info ), intent(inout), dimension(:), allocatable :: arr Destination array type( symba_particle_info ), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to public subroutine symba_util_append_arr_kin(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: arr Destination array type( symba_kinship ), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine symba_util_append_merger(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine symba_util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine symba_util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to public interface util_fill public subroutine symba_util_fill_arr_info(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name type( symba_particle_info ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_particle_info ), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public subroutine symba_util_fill_arr_kin(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_kinship ), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps interface public module subroutine symba_util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps interface public module subroutine symba_util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps interface public module subroutine symba_util_peri_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine symba_util_rearray_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions public interface util_resize public subroutine symba_util_resize_arr_info(arr, nnew) Arguments Type Intent Optional Attributes Name type( symba_particle_info ), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size public subroutine symba_util_resize_arr_kin(arr, nnew) Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size interface public module subroutine symba_util_resize_merger(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA merger list object integer(kind=I4B), intent(in) :: nnew New size neded interface public module subroutine symba_util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: nnew New size neded interface public module subroutine symba_util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: nnew New size neded interface public module subroutine symba_util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order interface public module subroutine symba_util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order interface public module subroutine symba_util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) interface public module subroutine symba_util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) public interface util_spill public subroutine symba_util_spill_arr_info(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name type( symba_particle_info ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_particle_info ), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine symba_util_spill_arr_kin(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_kinship ), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not interface public module subroutine symba_util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not interface public module subroutine symba_util_spill_pltpenc(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-tp encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list interface public module subroutine symba_util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not Derived Types type, public, extends( swiftest_parameters ) :: symba_parameters Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: integrator = UNKNOWN_INTEGRATOR Symbolic name of the nbody integrator  used integer(kind=I4B), public :: nplmax = -1 Maximum allowed number of massive bodies integer(kind=I4B), public :: ntpmax = -1 Maximum allowed number of test particles real(kind=DP), public :: t0 = -1.0_DP Integration start time real(kind=DP), public :: t = -1.0_DP Integration current time real(kind=DP), public :: tstop = -1.0_DP Integration stop time real(kind=DP), public :: dt = -1.0_DP Time step character(len=STRMAX), public :: incbfile = CB_INFILE Name of input file for the central body character(len=STRMAX), public :: inplfile = PL_INFILE Name of input file for massive bodies character(len=STRMAX), public :: intpfile = TP_INFILE Name of input file for test particles character(len=STRMAX), public :: in_type = ASCII_TYPE Format of input data files integer(kind=I4B), public :: istep_out = -1 Number of time steps between binary outputs character(len=STRMAX), public :: outfile = BIN_OUTFILE Name of output binary file character(len=STRMAX), public :: out_type = REAL8_TYPE Binary format of output file character(len=STRMAX), public :: out_form = XV Data to write to output file character(len=STRMAX), public :: out_stat = 'NEW' Open status for output binary file integer(kind=I4B), public :: istep_dump = -1 Number of time steps between dumps real(kind=DP), public :: rmin = -1.0_DP Minimum heliocentric radius for test particle real(kind=DP), public :: rmax = -1.0_DP Maximum heliocentric radius for test particle real(kind=DP), public :: rmaxu = -1.0_DP Maximum unbound heliocentric radius for test particle real(kind=DP), public :: qmin = -1.0_DP Minimum pericenter distance for test particle character(len=STRMAX), public :: qmin_coord = 'HELIO' Coordinate frame to use for qmin real(kind=DP), public :: qmin_alo = -1.0_DP Minimum semimajor axis for qmin real(kind=DP), public :: qmin_ahi = -1.0_DP Maximum semimajor axis for qmin character(len=STRMAX), public :: enc_out = \"\" Name of output file for encounters character(len=STRMAX), public :: discard_out = \"\" Name of output file for discards real(kind=QP), public :: MU2KG = -1.0_QP Converts mass units to grams real(kind=QP), public :: TU2S = -1.0_QP Converts time units to seconds real(kind=QP), public :: DU2M = -1.0_QP Converts distance unit to centimeters real(kind=DP), public :: GU = -1.0_DP Universal gravitational constant in the system units real(kind=DP), public :: inv_c2 = -1.0_DP Inverse speed of light squared in the system units character(len=STRMAX), public :: energy_out = \"\" Name of output energy and momentum report file logical, public :: lrhill_present = .false. Hill radii are given as an input rather than calculated by the code (can be used to inflate close encounter regions manually) logical, public :: lextra_force = .false. User defined force function turned on logical, public :: lbig_discard = .false. Save big bodies on every discard logical, public :: lclose = .false. Turn on close encounters logical, public :: lenergy = .false. Track the total energy of the system logical, public :: loblatecb = .false. Calculate acceleration from oblate central body (automatically turns true if nonzero J2 is input) logical, public :: lrotation = .false. Include rotation states of big bodies logical, public :: ltides = .false. Include tidal dissipation real(kind=DP), public :: Eorbit_orig = 0.0_DP Initial orbital energy real(kind=DP), public :: Mtot_orig = 0.0_DP Initial system mass real(kind=DP), public :: Lmag_orig = 0.0_DP Initial total angular momentum magnitude real(kind=DP), public, dimension(NDIM) :: Ltot_orig = 0.0_DP Initial total angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lorbit_orig = 0.0_DP Initial orbital angular momentum real(kind=DP), public, dimension(NDIM) :: Lspin_orig = 0.0_DP Initial spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Ltot = 0.0_DP System angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lescape = 0.0_DP Angular momentum of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Mescape = 0.0_DP Mass of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Ecollisions = 0.0_DP Energy lost from system due to collisions real(kind=DP), public :: Euntracked = 0.0_DP Energy gained from system due to escaped bodies logical, public :: lfirstenergy = .true. This is the first time computing energe logical, public :: lfirstkick = .true. Initiate the first kick in a symplectic step logical, public :: lrestart = .false. Indicates whether or not this is a restarted run logical, public :: lgr = .false. Turn on GR logical, public :: lyarkovsky = .false. Turn on Yarkovsky effect logical, public :: lyorp = .false. Turn on YORP effect character(len=STRMAX), public :: particle_out = PARTICLE_OUTFILE Name of output particle information file real(kind=DP), public :: GMTINY = -1.0_DP Smallest mass that is fully gravitating integer(kind=I4B), public, dimension(:), allocatable :: seed Random seeds logical, public :: lfragmentation = .false. Do fragmentation modeling instead of simple merger. Type-Bound Procedures procedure, public :: dump => io_dump_param procedure, public :: read_from_file => io_read_param_in procedure, public :: reader => symba_io_param_reader procedure, public :: writer => symba_io_param_writer type, public, sequence  :: symba_particle_info Class definition for the particle origin information object. This object is used to track time, location, and collisional regime\n of fragments produced in collisional events. Components Type Visibility Attributes Name Initial character(len=32), public :: origin_type String containing a description of the origin of the particle (e.g. Initial Conditions, Supercatastrophic, Disruption, etc.) real(kind=DP), public :: origin_time The time of the particle's formation real(kind=DP), public, dimension(NDIM) :: origin_xh The heliocentric distance vector at the time of the particle's formation real(kind=DP), public, dimension(NDIM) :: origin_vh The heliocentric velocity vector at the time of the particle's formation type, public :: symba_kinship Class definition for the kinship relationships used in bookkeeping multiple collisions bodies in a single time step. Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: parent Index of parent particle integer(kind=I4B), public :: nchild number of children in merger list integer(kind=I4B), public, dimension(:), allocatable :: child Index of children particles type, public, extends( helio_cb ) :: symba_cb SyMBA central body particle class Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step character(len=STRMAX), public :: name Non-unique name integer(kind=I4B), public :: id = 0 External identifier (unique) real(kind=DP), public :: mass = 0.0_DP Central body mass (units MU) real(kind=DP), public :: Gmass = 0.0_DP Central mass gravitational term G * mass (units GU * MU) real(kind=DP), public :: radius = 0.0_DP Central body radius (units DU) real(kind=DP), public :: density = 1.0_DP Central body mass density - calculated internally (units MU / DU**3) real(kind=DP), public :: j2rp2 = 0.0_DP J2*R&#94;2 term for central body real(kind=DP), public :: j4rp4 = 0.0_DP J4*R&#94;2 term for central body real(kind=DP), public, dimension(NDIM) :: aobl = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: atide = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: aoblbeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: aoblend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: atidebeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: atideend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: xb = 0.0_DP Barycentric position (units DU) real(kind=DP), public, dimension(NDIM) :: vb = 0.0_DP Barycentric velocity (units DU / TU) real(kind=DP), public, dimension(NDIM) :: agr = 0.0_DP Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(NDIM) :: Ip = 0.0_DP Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(NDIM) :: rot = 0.0_DP Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public :: k2 = 0.0_DP Tidal Love number real(kind=DP), public :: Q = 0.0_DP Tidal quality factor real(kind=DP), public :: tlag = 0.0_DP Tidal phase lag angle real(kind=DP), public, dimension(NDIM) :: L0 = 0.0_DP Initial angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: dL = 0.0_DP Change in angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: ptbeg negative barycentric velocity of the central body at the beginning of time step real(kind=DP), public, dimension(NDIM) :: ptend negative barycentric velocity of the central body at the end of time step real(kind=DP), public :: M0 = 0.0_DP Initial mass of the central body real(kind=DP), public :: dM = 0.0_DP Change in mass of the central body real(kind=DP), public :: R0 = 0.0_DP Initial radius of the central body real(kind=DP), public :: dR = 0.0_DP Change in the radius of the central body type( symba_particle_info ), public :: info Type-Bound Procedures procedure, public :: dump => io_dump_swiftest procedure, public :: initialize => io_read_cb_in I/O routine for reading in central body data procedure, public :: read_frame => io_read_frame_cb I/O routine for reading out a single frame of time-series data for the central body procedure, public :: write_frame => io_write_frame_cb I/O routine for writing out a single frame of time-series data for the central body type, public, extends( helio_pl ) :: symba_pl SyMBA massive body class Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl logical, public, dimension(:), allocatable :: lcollision flag indicating whether body has merged with another this time step logical, public, dimension(:), allocatable :: lencounter flag indicating whether body is part of an encounter this time step logical, public, dimension(:), allocatable :: lmtiny flag indicating whether this body is below the GMTINY cutoff value integer(kind=I4B), public :: nplm number of bodies above the GMTINY limit integer(kind=I8B), public :: nplplm Number of body (all massive)-body (only those above GMTINY) comparisons in the flattened upper triangular matrix integer(kind=I4B), public, dimension(:), allocatable :: nplenc number of encounters with other planets this time step integer(kind=I4B), public, dimension(:), allocatable :: ntpenc number of encounters with test particles this time step integer(kind=I4B), public, dimension(:), allocatable :: levelg level at which this body should be moved integer(kind=I4B), public, dimension(:), allocatable :: levelm deepest encounter level achieved this time step integer(kind=I4B), public, dimension(:), allocatable :: isperi perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp semimajor axis following perihelion passage type( symba_kinship ), public, dimension(:), allocatable :: kin Array of merger relationship structures that can account for multiple pairwise mergers in a single step type( symba_particle_info ), public, dimension(:), allocatable :: info Type-Bound Procedures procedure, public :: dump => io_dump_swiftest procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) procedure, public :: eucl_index => eucl_dist_index_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. procedure, public :: set_mu => util_set_mu_pl Method used to construct the vectorized form of the central body mass procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body procedure, public :: vh2vb => helio_coord_vh2vb_pl Convert massive bodies from heliocentric to barycentric coordinates (velocity only) procedure, public :: vb2vh => helio_coord_vb2vh_pl Convert massive bodies from barycentric to heliocentric coordinates (velocity only) procedure, public :: lindrift => helio_drift_linear_pl Method for linear drift of massive bodies due to barycentric momentum of Sun procedure, public :: accel_gr => helio_gr_kick_getacch_pl Acceleration term arising from the post-Newtonian correction procedure, public :: gr_pos_kick => helio_gr_p4_pl Position kick due to p**4 term in the post-Newtonian correction procedure, public :: kick => helio_kick_vb_pl Kicks the barycentric velocities procedure, public :: step => helio_step_pl Steps the body forward one stepsize procedure, public :: make_family => symba_collision_make_family_pl When a single body is involved in more than one collision in a single step, it becomes part of a family procedure, public :: discard => symba_discard_pl Process massive body discards procedure, public :: drift => symba_drift_pl Method for Danby drift in Democratic Heliocentric coordinates. Sets the mask to the current recursion level procedure, public :: encounter_check => symba_encounter_check_pl Checks if massive bodies are going through close encounters with each other procedure, public :: accel => symba_kick_getacch_pl Compute heliocentric accelerations of massive bodies procedure, public :: setup => symba_setup_pl Constructor method - Allocates space for the input number of bodies procedure, public :: append => symba_util_append_pl Appends elements from one structure to another procedure, public :: fill => symba_util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: get_peri => symba_util_peri_pl Determine system pericenter passages for massive bodies procedure, public :: rearray => symba_util_rearray_pl Clean up the massive body structures to remove discarded bodies and add new bodies procedure, public :: resize => symba_util_resize_pl Checks the current size of a SyMBA massive body against the requested size and resizes it if it is too small. procedure, public :: sort => symba_util_sort_pl Sorts body arrays by a sortable componen procedure, public :: rearrange => symba_util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => symba_util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) type, public, extends( symba_pl ) :: symba_merger Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl logical, public, dimension(:), allocatable :: lcollision flag indicating whether body has merged with another this time step logical, public, dimension(:), allocatable :: lencounter flag indicating whether body is part of an encounter this time step logical, public, dimension(:), allocatable :: lmtiny flag indicating whether this body is below the GMTINY cutoff value integer(kind=I4B), public :: nplm number of bodies above the GMTINY limit integer(kind=I8B), public :: nplplm Number of body (all massive)-body (only those above GMTINY) comparisons in the flattened upper triangular matrix integer(kind=I4B), public, dimension(:), allocatable :: nplenc number of encounters with other planets this time step integer(kind=I4B), public, dimension(:), allocatable :: ntpenc number of encounters with test particles this time step integer(kind=I4B), public, dimension(:), allocatable :: levelg level at which this body should be moved integer(kind=I4B), public, dimension(:), allocatable :: levelm deepest encounter level achieved this time step integer(kind=I4B), public, dimension(:), allocatable :: isperi perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp semimajor axis following perihelion passage type( symba_kinship ), public, dimension(:), allocatable :: kin Array of merger relationship structures that can account for multiple pairwise mergers in a single step type( symba_particle_info ), public, dimension(:), allocatable :: info integer(kind=I4B), public, dimension(:), allocatable :: ncomp Type-Bound Procedures procedure, public :: dump => io_dump_swiftest procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) procedure, public :: eucl_index => eucl_dist_index_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. procedure, public :: set_mu => util_set_mu_pl Method used to construct the vectorized form of the central body mass procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body procedure, public :: vh2vb => helio_coord_vh2vb_pl Convert massive bodies from heliocentric to barycentric coordinates (velocity only) procedure, public :: vb2vh => helio_coord_vb2vh_pl Convert massive bodies from barycentric to heliocentric coordinates (velocity only) procedure, public :: lindrift => helio_drift_linear_pl Method for linear drift of massive bodies due to barycentric momentum of Sun procedure, public :: accel_gr => helio_gr_kick_getacch_pl Acceleration term arising from the post-Newtonian correction procedure, public :: gr_pos_kick => helio_gr_p4_pl Position kick due to p**4 term in the post-Newtonian correction procedure, public :: kick => helio_kick_vb_pl Kicks the barycentric velocities procedure, public :: step => helio_step_pl Steps the body forward one stepsize procedure, public :: make_family => symba_collision_make_family_pl When a single body is involved in more than one collision in a single step, it becomes part of a family procedure, public :: discard => symba_discard_pl Process massive body discards procedure, public :: drift => symba_drift_pl Method for Danby drift in Democratic Heliocentric coordinates. Sets the mask to the current recursion level procedure, public :: encounter_check => symba_encounter_check_pl Checks if massive bodies are going through close encounters with each other procedure, public :: accel => symba_kick_getacch_pl Compute heliocentric accelerations of massive bodies procedure, public :: fill => symba_util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: get_peri => symba_util_peri_pl Determine system pericenter passages for massive bodies procedure, public :: rearray => symba_util_rearray_pl Clean up the massive body structures to remove discarded bodies and add new bodies procedure, public :: sort => symba_util_sort_pl Sorts body arrays by a sortable componen procedure, public :: rearrange => symba_util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => symba_util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure, public :: append => symba_util_append_merger Appends elements from one structure to another procedure, public :: resize => symba_util_resize_merger Checks the current size of a SyMBA merger list against the requested size and resizes it if it is too small. procedure, public :: setup => symba_setup_merger Constructor method - Allocates space for the input number of bodies type, public, extends( helio_tp ) :: symba_tp SyMBA test particle class Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill integer(kind=I4B), public, dimension(:), allocatable :: isperi Perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri Perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp Semimajor axis following perihelion passage\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_tp and util_spill_tp integer(kind=I4B), public, dimension(:), allocatable :: nplenc number of encounters with planets this time step integer(kind=I4B), public, dimension(:), allocatable :: levelg level at which this particle should be moved integer(kind=I4B), public, dimension(:), allocatable :: levelm deepest encounter level achieved this time step type( symba_particle_info ), public, dimension(:), allocatable :: info Type-Bound Procedures procedure, public :: dump => io_dump_swiftest procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) procedure, public :: discard => discard_tp Check to see if test particles should be discarded based on their positions relative to the massive bodies procedure, public :: accel_int => kick_getacch_int_tp Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies procedure, public :: accel_obl => obl_acc_tp Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: h2b => util_coord_h2b_tp Convert test particles from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_tp Convert test particles from barycentric to heliocentric coordinates (position and velocity) procedure, public :: get_peri => util_peri_tp Determine system pericenter passages for test particles procedure, public :: set_mu => util_set_mu_tp Method used to construct the vectorized form of the central body mass procedure, public :: vh2vb => helio_coord_vh2vb_tp Convert test particles from heliocentric to barycentric coordinates (velocity only) procedure, public :: vb2vh => helio_coord_vb2vh_tp Convert test particles from barycentric to heliocentric coordinates (velocity only) procedure, public :: lindrift => helio_drift_linear_tp Method for linear drift of massive bodies due to barycentric momentum of Sun procedure, public :: accel_gr => helio_gr_kick_getacch_tp Acceleration term arising from the post-Newtonian correction procedure, public :: gr_pos_kick => helio_gr_p4_tp Position kick due to p**4 term in the post-Newtonian correction procedure, public :: kick => helio_kick_vb_tp Kicks the barycentric velocities procedure, public :: step => helio_step_tp Steps the body forward one stepsize procedure, public :: drift => symba_drift_tp Method for Danby drift in Democratic Heliocentric coordinates. Sets the mask to the current recursion level procedure, public :: encounter_check => symba_encounter_check_tp Checks if any test particles are undergoing a close encounter with a massive body procedure, public :: accel => symba_kick_getacch_tp Compute heliocentric accelerations of test particles procedure, public :: setup => symba_setup_tp Constructor method - Allocates space for the input number of bodies procedure, public :: append => symba_util_append_tp Appends elements from one structure to another procedure, public :: fill => symba_util_fill_tp \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: resize => symba_util_resize_tp Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure, public :: sort => symba_util_sort_tp Sorts body arrays by a sortable componen procedure, public :: rearrange => symba_util_sort_rearrange_tp Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => symba_util_spill_tp \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) type, public, extends( swiftest_encounter ) :: symba_pltpenc SyMBA class for tracking pl-tp close encounters in a step Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: nenc Total number of encounters logical, public, dimension(:), allocatable :: lvdotr relative vdotr flag integer(kind=I4B), public, dimension(:), allocatable :: status status of the interaction integer(kind=I4B), public, dimension(:), allocatable :: index1 position of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: index2 position of the second body in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x1 the position of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x2 the position of body 2 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v1 the velocity of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v2 the velocity of body 2 in the encounter integer(kind=I4B), public, dimension(:), allocatable :: level encounter recursion level Type-Bound Procedures procedure, public :: copy => util_copy_encounter Copies elements from the source encounter list into self. procedure, public :: resize => util_resize_encounter Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small. procedure, public :: collision_check => symba_collision_check_pltpenc Checks if a test particle is going to collide with a massive body procedure, public :: encounter_check => symba_encounter_check_pltpenc Checks if massive bodies are going through close encounters with each other procedure, public :: kick => symba_kick_pltpenc Kick barycentric velocities of active test particles within SyMBA recursion procedure, public :: setup => symba_setup_pltpenc A constructor that sets the number of encounters and allocates and initializes all arrays procedure, public :: spill => symba_util_spill_pltpenc \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) type, public, extends( symba_pltpenc ) :: symba_plplenc SyMBA class for tracking pl-pl close encounters in a step Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: nenc Total number of encounters logical, public, dimension(:), allocatable :: lvdotr relative vdotr flag integer(kind=I4B), public, dimension(:), allocatable :: status status of the interaction integer(kind=I4B), public, dimension(:), allocatable :: index1 position of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: index2 position of the second body in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x1 the position of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x2 the position of body 2 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v1 the velocity of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v2 the velocity of body 2 in the encounter integer(kind=I4B), public, dimension(:), allocatable :: level encounter recursion level Type-Bound Procedures procedure, public :: copy => util_copy_encounter Copies elements from the source encounter list into self. procedure, public :: resize => util_resize_encounter Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small. procedure, public :: collision_check => symba_collision_check_pltpenc Checks if a test particle is going to collide with a massive body procedure, public :: encounter_check => symba_encounter_check_pltpenc Checks if massive bodies are going through close encounters with each other procedure, public :: kick => symba_kick_pltpenc Kick barycentric velocities of active test particles within SyMBA recursion procedure, public :: setup => symba_setup_pltpenc A constructor that sets the number of encounters and allocates and initializes all arrays procedure, public :: spill => symba_util_spill_pltpenc \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure, public :: scrub_non_collision => symba_collision_encounter_scrub Processes the pl-pl encounter list remove only those encounters that led to a collision procedure, public :: resolve_fragmentations => symba_collision_resolve_fragmentations Process list of collisions, determine the collisional regime, and then create fragments procedure, public :: resolve_mergers => symba_collision_resolve_mergers Process list of collisions and merge colliding bodies together type, public, extends( helio_nbody_system ) :: symba_nbody_system Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step class( swiftest_cb ), public, allocatable :: cb Central body data structure class( swiftest_pl ), public, allocatable :: pl Massive body data structure class( swiftest_tp ), public, allocatable :: tp Test particle data structure class( swiftest_tp ), public, allocatable :: tp_discards Discarded test particle data structure class( swiftest_pl ), public, allocatable :: pl_discards Discarded massive body particle data structure real(kind=DP), public :: Gmtot = 0.0_DP Total system mass - used for barycentric coordinate conversion real(kind=DP), public :: ke_orbit = 0.0_DP System orbital kinetic energy real(kind=DP), public :: ke_spin = 0.0_DP System spin kinetic energy real(kind=DP), public :: pe = 0.0_DP System potential energy real(kind=DP), public :: te = 0.0_DP System total energy real(kind=DP), public, dimension(NDIM) :: Lorbit = 0.0_DP System orbital angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lspin = 0.0_DP System spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lescape = 0.0_DP Angular momentum of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Mescape = 0.0_DP Mass of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Ecollisions = 0.0_DP Energy lost from system due to collisions real(kind=DP), public :: Euntracked = 0.0_DP Energy gained from system due to escaped bodies logical, public :: lbeg True if this is the beginning of a step. This is used so that test particle steps can be calculated \n    separately from massive bodies.  Massive body variables are saved at half steps, and passed to \n    the test particles integer(kind=I4B), public :: maxid = -1 The current maximum particle id number class( symba_merger ), public, allocatable :: pl_adds List of added bodies in mergers or collisions class( symba_pltpenc ), public, allocatable :: pltpenc_list List of massive body-test particle encounters in a single step class( symba_plplenc ), public, allocatable :: plplenc_list List of massive body-massive body encounters in a single step integer(kind=I4B), public :: irec System recursion level Type-Bound Procedures procedure, public :: discard => discard_system Perform a discard step on the system procedure, public :: conservation_report => io_conservation_report Compute energy and momentum and print out the change with time procedure, public :: dump => io_dump_system Dump the state of the system to a file procedure, public :: read_frame => io_read_frame_system Read in a frame of input data from file procedure, public :: write_frame => io_write_frame_system Append a frame of output data to file procedure, public :: step_spin => tides_step_spin_system Steps the spins of the massive & central bodies due to tides. procedure, public :: set_msys => util_set_msys Sets the value of msys from the masses of system bodies. procedure, public :: get_energy_and_momentum => util_get_energy_momentum_system Calculates the total system energy and momentum procedure, public :: rescale => util_rescale_system Rescales the system into a new set of units procedure, public :: validate_ids => util_valid_id_system Validate the numerical ids passed to the system and save the maximum value procedure, public :: write_discard => symba_io_write_discard Write out information about discarded and merged planets and test particles in SyMBA procedure, public :: initialize => symba_setup_initialize_system Performs SyMBA-specific initilization steps procedure, public :: step => symba_step_system Advance the SyMBA nbody system forward in time by one step procedure, public :: interp => symba_step_interp_system Perform an interpolation step on the SymBA nbody system procedure, public :: set_recur_levels => symba_step_set_recur_levels_system Sets recursion levels of bodies and encounter lists to the current system level procedure, public :: recursive_step => symba_step_recur_system Step interacting planets and active test particles ahead in democratic heliocentric coordinates at the current recursion level, if applicable, and descend to the next deeper level if necessary procedure, public :: reset => symba_step_reset_system Resets pl, tp,and encounter structures at the start of a new step","tags":"","loc":"module/symba_classes.html"},{"title":"swiftest – swiftest","text":"This module serves to combine all of the Swiftest project modules under a single umbrella so that they can be accessed from individual submodule implementations with a simple \"use swiftest\" line. Uses swiftest_globals swiftest_operators swiftest_classes whm_classes rmvs_classes helio_classes symba_classes lambda_function Contents None","tags":"","loc":"module/swiftest.html"},{"title":"swiftest_classes – swiftest","text":"Definition of data and structures generic to all integrators.\n Adapted from David E. Kaufmann's Swifter routine: module_swifter.f90 swiftest_parameters class definitions swiftest_base class definitions and methods swiftest_cb class definitions and methods swiftest_body definitions and methods swiftest_pl definitions and methods swiftest_tp definitions and methods swiftest_nbody_system class definitions and methods Uses swiftest_globals module~~swiftest_classes~~UsesGraph module~swiftest_classes swiftest_classes module~swiftest_globals swiftest_globals module~swiftest_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: drift_implementation s_discard s_eucl s_fragmentation s_gr s_io s_kick s_obl s_orbel s_setup s_tides_kick_getacch s_tides_step_spin s_user_kick_getacch s_util_append s_util_coord s_util_copy s_util_exit s_util_fill s_util_get_energy_momentum s_util_minimize_bfgs s_util_peri s_util_rescale s_util_resize s_util_set s_util_solve s_util_sort s_util_spill s_util_valid s_util_version module~~swiftest_classes~~UsedByGraph module~swiftest_classes swiftest_classes module~s_gr s_gr module~s_gr->module~swiftest_classes module~swiftest swiftest module~s_gr->module~swiftest module~s_util_append s_util_append module~s_util_append->module~swiftest_classes module~s_util_append->module~swiftest module~s_obl s_obl module~s_obl->module~swiftest_classes module~s_obl->module~swiftest module~s_util_set s_util_set module~s_util_set->module~swiftest_classes module~s_util_set->module~swiftest module~s_util_exit s_util_exit module~s_util_exit->module~swiftest_classes module~s_util_exit->module~swiftest module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~s_util_coord s_util_coord module~s_util_coord->module~swiftest_classes module~s_util_coord->module~swiftest module~s_util_sort s_util_sort module~s_util_sort->module~swiftest_classes module~s_util_sort->module~swiftest module~s_util_copy s_util_copy module~s_util_copy->module~swiftest_classes module~s_util_copy->module~swiftest module~s_util_fill s_util_fill module~s_util_fill->module~swiftest_classes module~s_util_fill->module~swiftest module~drift_implementation drift_implementation module~drift_implementation->module~swiftest_classes module~drift_implementation->module~swiftest module~s_tides_step_spin s_tides_step_spin module~s_tides_step_spin->module~swiftest_classes module~s_tides_step_spin->module~swiftest module~s_user_kick_getacch s_user_kick_getacch module~s_user_kick_getacch->module~swiftest_classes module~s_user_kick_getacch->module~swiftest module~s_util_spill s_util_spill module~s_util_spill->module~swiftest_classes module~s_util_spill->module~swiftest module~s_util_version s_util_version module~s_util_version->module~swiftest_classes module~s_util_version->module~swiftest module~whm_classes->module~swiftest_classes module~s_util_valid s_util_valid module~s_util_valid->module~swiftest_classes module~s_util_valid->module~swiftest module~s_orbel s_orbel module~s_orbel->module~swiftest_classes module~s_orbel->module~swiftest module~s_eucl s_eucl module~s_eucl->module~swiftest_classes module~s_eucl->module~swiftest module~s_discard s_discard module~s_discard->module~swiftest_classes module~s_discard->module~swiftest module~s_util_solve s_util_solve module~s_util_solve->module~swiftest_classes module~s_util_solve->module~swiftest module~s_setup s_setup module~s_setup->module~swiftest_classes module~s_setup->module~swiftest module~s_kick s_kick module~s_kick->module~swiftest_classes module~s_kick->module~swiftest module~s_tides_kick_getacch s_tides_kick_getacch module~s_tides_kick_getacch->module~swiftest_classes module~s_tides_kick_getacch->module~swiftest module~s_util_minimize_bfgs s_util_minimize_bfgs module~s_util_minimize_bfgs->module~swiftest_classes module~s_util_minimize_bfgs->module~swiftest module~s_util_get_energy_momentum s_util_get_energy_momentum module~s_util_get_energy_momentum->module~swiftest_classes module~s_util_get_energy_momentum->module~swiftest module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~rmvs_classes module~s_util_resize s_util_resize module~s_util_resize->module~swiftest_classes module~s_util_resize->module~swiftest module~s_util_rescale s_util_rescale module~s_util_rescale->module~swiftest_classes module~s_util_rescale->module~swiftest module~s_fragmentation s_fragmentation module~s_fragmentation->module~swiftest_classes module~s_fragmentation->module~swiftest module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~s_io s_io module~s_io->module~swiftest_classes module~s_io->module~swiftest module~s_util_peri s_util_peri module~s_util_peri->module~swiftest_classes module~s_util_peri->module~swiftest module~whm_drift whm_drift module~whm_drift->module~swiftest module~whm_drift->module~whm_classes module~s_symba_setup s_symba_setup module~s_symba_setup->module~swiftest module~s_symba_setup->module~symba_classes module~s_whm_setup s_whm_setup module~s_whm_setup->module~swiftest module~s_whm_setup->module~whm_classes module~s_helio_kick s_helio_kick module~s_helio_kick->module~swiftest module~s_helio_kick->module~helio_classes module~s_symba_discard s_symba_discard module~s_symba_discard->module~swiftest module~s_symba_discard->module~symba_classes module~s_helio_gr s_helio_gr module~s_helio_gr->module~swiftest module~s_helio_gr->module~helio_classes module~s_rmvs_util s_rmvs_util module~s_rmvs_util->module~swiftest module~s_rmvs_util->module~rmvs_classes module~s_rmvs_setup s_rmvs_setup module~s_rmvs_setup->module~swiftest module~s_rmvs_setup->module~rmvs_classes module~s_helio_step s_helio_step module~s_helio_step->module~swiftest module~s_helio_step->module~helio_classes module~s_rmvs_step s_rmvs_step module~s_rmvs_step->module~swiftest module~s_rmvs_step->module~rmvs_classes module~s_symba_fragmentation s_symba_fragmentation module~s_symba_fragmentation->module~swiftest module~s_symba_fragmentation->module~symba_classes proc~ge_wpp ge_wpp proc~ge_wpp->module~swiftest module~s_symba_util s_symba_util module~s_symba_util->module~swiftest module~s_symba_util->module~symba_classes module~s_symba_encounter_check s_symba_encounter_check module~s_symba_encounter_check->module~swiftest module~s_symba_encounter_check->module~symba_classes module~s_symba_io s_symba_io module~s_symba_io->module~swiftest module~s_symba_io->module~symba_classes module~s_whm_kick s_whm_kick module~s_whm_kick->module~swiftest module~s_whm_kick->module~whm_classes module~s_symba_collision s_symba_collision module~s_symba_collision->module~swiftest module~s_symba_collision->module~symba_classes module~s_helio_coord s_helio_coord module~s_helio_coord->module~swiftest module~s_helio_coord->module~helio_classes module~s_rmvs_discard s_rmvs_discard module~s_rmvs_discard->module~swiftest module~s_rmvs_discard->module~rmvs_classes module~s_operator_cross s_operator_cross module~s_operator_cross->module~swiftest program~swiftest_driver swiftest_driver program~swiftest_driver->module~swiftest module~s_helio_drift s_helio_drift module~s_helio_drift->module~swiftest module~s_helio_drift->module~helio_classes module~s_whm_util s_whm_util module~s_whm_util->module~swiftest module~s_whm_util->module~whm_classes module~s_symba_kick s_symba_kick module~s_symba_kick->module~swiftest module~s_symba_kick->module~symba_classes proc~solve_wbs solve_wbs proc~solve_wbs->module~swiftest module~s_rmvs_chk s_rmvs_chk module~s_rmvs_chk->module~swiftest module~s_rmvs_chk->module~rmvs_classes module~rmvs_classes->module~whm_classes module~s_whm_coord s_whm_coord module~s_whm_coord->module~swiftest module~s_whm_coord->module~whm_classes module~s_rmvs_kick s_rmvs_kick module~s_rmvs_kick->module~swiftest module~s_rmvs_kick->module~rmvs_classes module~s_whm_gr s_whm_gr module~s_whm_gr->module~swiftest module~s_whm_gr->module~whm_classes module~s_whm_step s_whm_step module~s_whm_step->module~swiftest module~s_whm_step->module~whm_classes module~s_symba_drift s_symba_drift module~s_symba_drift->module~swiftest module~s_symba_drift->module~symba_classes module~s_symba_step s_symba_step module~s_symba_step->module~swiftest module~s_symba_step->module~symba_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces io_get_args io_get_token discard_pl discard_system discard_tp drift_all drift_body drift_one eucl_dist_index_plpl fragmentation_initialize fragmentation_regime gr_kick_getaccb_ns_body gr_kick_getacch gr_p4_pos_kick gr_pseudovel2vel gr_pv2vh_body gr_vel2pseudovel gr_vh2pv_body io_conservation_report io_dump_param io_dump_swiftest io_dump_system io_param_reader io_param_writer io_read_body_in io_read_cb_in io_read_param_in io_read_frame_body io_read_frame_cb io_read_frame_system io_write_discard io_toupper io_write_encounter io_write_frame_body io_write_frame_cb io_write_frame_system kick_getacch_int_pl kick_getacch_int_tp obl_acc_body obl_acc_pl obl_acc_tp obl_pot orbel_el2xv_vec orbel_scget orbel_xv2aeq orbel_xv2aqt orbel_xv2el_vec setup_body setup_construct_system setup_encounter setup_initialize_system setup_pl setup_tp tides_kick_getacch_pl tides_step_spin_system user_kick_getacch_body util_append util_append_body util_append_pl util_append_tp util_coord_b2h_pl util_coord_b2h_tp util_coord_h2b_pl util_coord_h2b_tp util_copy_encounter util_exit util_fill_body util_fill_pl util_fill_tp util_fill util_minimize_bfgs util_rescale_system util_peri_tp util_resize util_resize_body util_resize_encounter util_resize_pl util_resize_tp util_get_energy_momentum_system util_set_beg_end_pl util_set_ir3h util_set_msys util_set_mu_pl util_set_mu_tp util_set_rhill util_set_rhill_approximate util_solve_linear_system util_solve_rkf45 util_sort util_sort_rearrange_body util_sort_rearrange_pl util_sort_rearrange_tp util_sort_body util_sort_pl util_sort_tp util_spill util_spill_body util_spill_encounter util_spill_pl util_spill_tp util_valid_id_system util_version Abstract Interfaces abstract_discard_body abstract_accel abstract_initialize abstract_kick_body abstract_read_frame abstract_set_mu abstract_step_body abstract_step_system abstract_write_frame Derived Types swiftest_parameters swiftest_base swiftest_cb swiftest_body swiftest_pl swiftest_tp swiftest_nbody_system swiftest_encounter Interfaces interface public module function io_get_args(integrator, param_file_name) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=I4B) :: integrator Symbolic code of the requested integrator character(len=:), allocatable :: param_file_name Name of the input parameters file Return Value integer(kind=I4B) I/O error code interface public module function io_get_token(buffer, ifirst, ilast, ierr) result(token) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: buffer Input string buffer integer(kind=I4B), intent(inout) :: ifirst Index of the buffer at which to start the search for a token integer(kind=I4B), intent(out) :: ilast Index of the buffer at the end of the returned token integer(kind=I4B), intent(out) :: ierr Error code Return Value character(len=:),\n  allocatable Returned token string interface public module subroutine discard_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameter interface public module subroutine discard_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine discard_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public pure module subroutine drift_all(mu, x, v, n, param, dt, mask, iflag) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: mu Vector of gravitational constants real(kind=DP), intent(inout), dimension(:,:) :: x Position and velocity vectors real(kind=DP), intent(inout), dimension(:,:) :: v Position and velocity vectors integer(kind=I4B), intent(in) :: n number of bodies class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize logical, intent(in), dimension(:) :: mask Logical mask of size self%nbody that determines which bodies to drift. integer(kind=I4B), intent(out), dimension(:) :: iflag Vector of error flags. 0 means no problem interface public module subroutine drift_body(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize interface public pure elemental module subroutine drift_one(mu, px, py, pz, vx, vy, vz, dt, iflag) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body to drift real(kind=DP), intent(inout) :: px Position and velocity of body to drift real(kind=DP), intent(inout) :: py Position and velocity of body to drift real(kind=DP), intent(inout) :: pz Position and velocity of body to drift real(kind=DP), intent(inout) :: vx Position and velocity of body to drift real(kind=DP), intent(inout) :: vy Position and velocity of body to drift real(kind=DP), intent(inout) :: vz Position and velocity of body to drift real(kind=DP), intent(in) :: dt Step size integer(kind=I4B), intent(out) :: iflag iflag : error status flag for Danby drift (0 = OK, nonzero = ERROR) interface public module subroutine eucl_dist_index_plpl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object interface public module subroutine fragmentation_initialize(system, param, family, x, v, L_spin, Ip, mass, radius, nfrag, Ip_frag, m_frag, rad_frag, xb_frag, vb_frag, rot_frag, Qloss, lfailure) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters integer(kind=I4B), intent(in), dimension(:) :: family Index of bodies involved in the collision real(kind=DP), intent(inout), dimension(:,:) :: x Two-body equivalent position, vector, spin momentum, and rotational inertia values for the collision real(kind=DP), intent(inout), dimension(:,:) :: v Two-body equivalent position, vector, spin momentum, and rotational inertia values for the collision real(kind=DP), intent(inout), dimension(:,:) :: L_spin Two-body equivalent position, vector, spin momentum, and rotational inertia values for the collision real(kind=DP), intent(inout), dimension(:,:) :: Ip Two-body equivalent position, vector, spin momentum, and rotational inertia values for the collision real(kind=DP), intent(inout), dimension(:) :: mass Two-body equivalent mass and radii for the bodies in the collision real(kind=DP), intent(inout), dimension(:) :: radius Two-body equivalent mass and radii for the bodies in the collision integer(kind=I4B), intent(inout) :: nfrag Number of fragments to generate real(kind=DP), intent(inout), dimension(:,:), allocatable :: Ip_frag Fragment rotational inertia vectors real(kind=DP), intent(inout), dimension(:), allocatable :: m_frag Distribution of fragment mass and radii real(kind=DP), intent(inout), dimension(:), allocatable :: rad_frag Distribution of fragment mass and radii real(kind=DP), intent(inout), dimension(:,:), allocatable :: xb_frag Fragment barycentric position, barycentric velocity, and rotation vectors real(kind=DP), intent(inout), dimension(:,:), allocatable :: vb_frag Fragment barycentric position, barycentric velocity, and rotation vectors real(kind=DP), intent(inout), dimension(:,:), allocatable :: rot_frag Fragment barycentric position, barycentric velocity, and rotation vectors real(kind=DP), intent(inout) :: Qloss Energy lost during the collision logical, intent(out) :: lfailure Answers the question: Should this have been a merger instead? interface public module subroutine fragmentation_regime(Mcb, m1, m2, rad1, rad2, xh1, xh2, vb1, vb2, den1, den2, regime, Mlr, Mslr, mtiny, Qloss) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: Mcb real(kind=DP), intent(in) :: m1 real(kind=DP), intent(in) :: m2 real(kind=DP), intent(in) :: rad1 real(kind=DP), intent(in) :: rad2 real(kind=DP), intent(in), dimension(:) :: xh1 real(kind=DP), intent(in), dimension(:) :: xh2 real(kind=DP), intent(in), dimension(:) :: vb1 real(kind=DP), intent(in), dimension(:) :: vb2 real(kind=DP), intent(in) :: den1 real(kind=DP), intent(in) :: den2 integer(kind=I4B), intent(out) :: regime real(kind=DP), intent(out) :: Mlr real(kind=DP), intent(out) :: Mslr real(kind=DP), intent(in) :: mtiny real(kind=DP), intent(out) :: Qloss Energy lost during the collision interface public pure module subroutine gr_kick_getaccb_ns_body(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine gr_kick_getacch(mu, x, lmask, n, inv_c2, agr) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:,:) :: x Position vectors logical, intent(in), dimension(:) :: lmask Logical mask indicating which bodies to compute integer(kind=I4B), intent(in) :: n Total number of bodies real(kind=DP), intent(in) :: inv_c2 Inverse speed of light squared: 1 / c**2 real(kind=DP), intent(out), dimension(:,:) :: agr Accelerations interface public pure module subroutine gr_p4_pos_kick(param, x, v, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(inout), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(in) :: dt Step size interface public pure module subroutine gr_pseudovel2vel(param, mu, xh, pv, vh) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real(kind=DP), intent(in), dimension(:) :: xh Heliocentric position vector real(kind=DP), intent(in), dimension(:) :: pv Pseudovelocity velocity vector - see Saha & Tremain (1994), eq. (32) real(kind=DP), intent(out), dimension(:) :: vh Heliocentric velocity vector interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public pure module subroutine gr_vel2pseudovel(param, mu, xh, vh, pv) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real(kind=DP), intent(in), dimension(:) :: xh Heliocentric position vector real(kind=DP), intent(in), dimension(:) :: vh Heliocentric velocity vector real(kind=DP), intent(out), dimension(:) :: pv Pseudovelocity vector - see Saha & Tremain (1994), eq. (32) interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine io_conservation_report(self, param, lterminal) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Input colleciton of user-defined parameters logical, intent(in) :: lterminal Indicates whether to output information to the terminal screen interface public module subroutine io_dump_param(self, param_file_name) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Output collection of parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in) interface public module subroutine io_dump_swiftest(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine io_dump_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine io_param_reader(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Collection of parameters integer(kind=I4B), intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer(kind=I4B), intent(in) :: v_list (:) The first element passes the integrator code to the reader integer(kind=I4B), intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 interface public module subroutine io_param_writer(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Collection of parameters integer(kind=I4B), intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer(kind=I4B), intent(in) :: v_list (:) Not used in this procedure integer(kind=I4B), intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 interface public module subroutine io_read_body_in(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine io_read_cb_in(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine io_read_param_in(self, param_file_name) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Current run configuration parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in) interface public module subroutine io_read_frame_body(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code interface public module subroutine io_read_frame_cb(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code interface public module subroutine io_read_frame_system(self, iu, param, form, ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code interface public module subroutine io_write_discard(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine io_toupper(string) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string String to make upper case interface public module subroutine io_write_encounter(t, name1, name2, mass1, mass2, radius1, radius2, xh1, xh2, vh1, vh2, enc_out, out_type) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: name1 integer(kind=I4B), intent(in) :: name2 real(kind=DP), intent(in) :: mass1 real(kind=DP), intent(in) :: mass2 real(kind=DP), intent(in) :: radius1 real(kind=DP), intent(in) :: radius2 real(kind=DP), intent(in), dimension(:) :: xh1 real(kind=DP), intent(in), dimension(:) :: xh2 real(kind=DP), intent(in), dimension(:) :: vh1 real(kind=DP), intent(in), dimension(:) :: vh2 character(len=*), intent(in) :: enc_out character(len=*), intent(in) :: out_type interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine io_write_frame_cb(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine io_write_frame_system(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public pure module subroutine kick_getacch_int_pl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self interface public pure module subroutine kick_getacch_int_tp(self, GMpl, xhp, npl) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle real(kind=DP), intent(in), dimension(:) :: GMpl Massive body masses real(kind=DP), intent(in), dimension(:,:) :: xhp Massive body position vectors integer(kind=I4B), intent(in) :: npl Number of active massive bodies interface public module subroutine obl_acc_body(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object interface public module subroutine obl_acc_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object interface public module subroutine obl_acc_tp(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object interface public module subroutine obl_pot(npl, Mcb, Mpl, j2rp2, j4rp4, xh, irh, oblpot) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl real(kind=DP), intent(in) :: Mcb real(kind=DP), intent(in), dimension(:) :: Mpl real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in), dimension(:, :) :: xh real(kind=DP), intent(in), dimension(:) :: irh real(kind=DP), intent(out) :: oblpot interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object interface public pure module subroutine orbel_scget(angle, sx, cx) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: angle real(kind=DP), intent(out) :: sx real(kind=DP), intent(out) :: cx interface public pure module subroutine orbel_xv2aeq(mu, x, v, a, e, q) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(out) :: a semimajor axis real(kind=DP), intent(out) :: e eccentricity real(kind=DP), intent(out) :: q periapsis interface public pure module subroutine orbel_xv2aqt(mu, x, v, a, q, capm, tperi) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(out) :: a semimajor axis real(kind=DP), intent(out) :: q periapsis real(kind=DP), intent(out) :: capm mean anomaly real(kind=DP), intent(out) :: tperi time of pericenter passage interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object interface public module subroutine setup_body(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine setup_construct_system(system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout), allocatable :: system Swiftest system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine setup_encounter(self, n) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for interface public module subroutine setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parametersr interface public module subroutine tides_kick_getacch_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object interface public module subroutine tides_step_spin_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step public interface util_append public subroutine util_append_arr_char_string(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: arr Destination array character(len=STRMAX), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to public subroutine util_append_arr_DP(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: arr Destination array real(kind=DP), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to public subroutine util_append_arr_DPvec(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: arr Destination array real(kind=DP), intent(in), dimension(:,:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to public subroutine util_append_arr_I4B(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to public subroutine util_append_arr_logical(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: arr Destination array logical, intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine util_append_body(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine util_coord_b2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object interface public module subroutine util_coord_b2h_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object interface public module subroutine util_coord_h2b_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object interface public module subroutine util_coord_h2b_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object interface public module subroutine util_copy_encounter(self, source) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Encounter list class( swiftest_encounter ), intent(in) :: source Source object to copy into interface public module subroutine util_exit(code) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: code Failure exit code interface public module subroutine util_fill_body(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps interface public module subroutine util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps interface public module subroutine util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public interface util_fill public subroutine util_fill_arr_char_string(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: keeps Array of values to keep character(len=STRMAX), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public subroutine util_fill_arr_DP(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: keeps Array of values to keep real(kind=DP), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public subroutine util_fill_arr_DPvec(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: keeps Array of values to keep real(kind=DP), intent(in), dimension(:,:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public subroutine util_fill_arr_I4B(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: keeps Array of values to keep integer(kind=I4B), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public subroutine util_fill_arr_logical(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: keeps Array of values to keep logical, intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps interface public module function util_minimize_bfgs(f, N, x0, eps, lerr) result(x1) Implementation → Arguments Type Intent Optional Attributes Name class(lambda_obj), intent(inout) :: f integer(kind=I4B), intent(in) :: N real(kind=DP), intent(in), dimension(:) :: x0 real(kind=DP), intent(in) :: eps logical, intent(out) :: lerr Return Value real(kind=DP),\n  dimension(:), allocatable interface public module subroutine util_rescale_system(self, param, mscale, dscale, tscale) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters. Returns with new values of the scale vactors and GU real(kind=DP), intent(in) :: mscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: dscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: tscale Scale factors for mass, distance, and time units, respectively. interface public module subroutine util_peri_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters public interface util_resize public subroutine util_resize_arr_char_string(arr, nnew) Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size public subroutine util_resize_arr_DP(arr, nnew) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size public subroutine util_resize_arr_DPvec(arr, nnew) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size public subroutine util_resize_arr_I4B(arr, nnew) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size public subroutine util_resize_arr_logical(arr, nnew) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size interface public module subroutine util_resize_body(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in) :: nnew New size neded interface public module subroutine util_resize_encounter(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list integer(kind=I4B), intent(in) :: nnew New size of list needed interface public module subroutine util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: nnew New size neded interface public module subroutine util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: nnew New size neded interface public module subroutine util_get_energy_momentum_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine util_set_beg_end_pl(self, xbeg, xend, vbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object real(kind=DP), intent(in), optional dimension(:,:) :: xbeg Position vectors at beginning of step real(kind=DP), intent(in), optional dimension(:,:) :: xend Positions vectors at end of step real(kind=DP), intent(in), optional dimension(:,:) :: vbeg vbeg is an unused variable to keep this method forward compatible with RMVS interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object interface public module subroutine util_set_msys(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object interface public module subroutine util_set_mu_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object interface public module subroutine util_set_mu_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object interface public module subroutine util_set_rhill(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object interface public module subroutine util_set_rhill_approximate(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object public interface util_solve_linear_system public function util_solve_linear_system_d(A, b, n, lerr) result(x) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A real(kind=DP), intent(in), dimension(:) :: b integer(kind=I4B), intent(in) :: n logical, intent(out) :: lerr Return Value real(kind=DP),\n  dimension(n) public function util_solve_linear_system_q(A, b, n, lerr) result(x) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A real(kind=QP), intent(in), dimension(:) :: b integer(kind=I4B), intent(in) :: n logical, intent(out) :: lerr Return Value real(kind=QP),\n  dimension(n) interface public module function util_solve_rkf45(f, y0in, t1, dt0, tol) result(y1) Implementation → Arguments Type Intent Optional Attributes Name class(lambda_obj), intent(inout) :: f lambda function object that has been initialized to be a function of derivatives. The object will return with components lastarg and lasteval set real(kind=DP), intent(in), dimension(:) :: y0in Initial value at t=0 real(kind=DP), intent(in) :: t1 Final time real(kind=DP), intent(in) :: dt0 Initial step size guess real(kind=DP), intent(in) :: tol Tolerance on solution Return Value real(kind=DP),\n  dimension(:), allocatable Final result public interface util_sort public subroutine util_sort_i4b(arr) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:) :: arr public subroutine util_sort_index_i4b(arr, ind) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind public subroutine util_sort_sp(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), dimension(:) :: arr public subroutine util_sort_index_sp(arr, ind) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind public subroutine util_sort_dp(arr) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:) :: arr public subroutine util_sort_index_dp(arr, ind) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind interface public module subroutine util_sort_rearrange_body(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) interface public module subroutine util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) interface public module subroutine util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) interface public module subroutine util_sort_body(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order interface public module subroutine util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order interface public module subroutine util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order public interface util_spill public subroutine util_spill_arr_char_string(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: keeps Array of values to keep character(len=STRMAX), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine util_spill_arr_DP(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: keeps Array of values to keep real(kind=DP), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine util_spill_arr_DPvec(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: keeps Array of values to keep real(kind=DP), intent(inout), dimension(:,:), allocatable :: discards Array discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine util_spill_arr_I4B(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: keeps Array of values to keep integer(kind=I4B), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine util_spill_arr_logical(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: keeps Array of values to keep logical, intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not interface public module subroutine util_spill_body(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not interface public module subroutine util_spill_encounter(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list interface public module subroutine util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not interface public module subroutine util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not interface public module subroutine util_valid_id_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine util_version() Implementation → Arguments None Abstract Interfaces abstract interface public subroutine abstract_discard_body(self, system, param) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters abstract interface public subroutine abstract_accel(self, system, param, t, lbeg) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step abstract interface public subroutine abstract_initialize(self, param) Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters abstract interface public subroutine abstract_kick_body(self, system, param, t, dt, lbeg) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system objec class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. abstract interface public subroutine abstract_read_frame(self, iu, param, form, ierr) Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code abstract interface public subroutine abstract_set_mu(self, cb) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object abstract interface public subroutine abstract_step_body(self, system, param, t, dt) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize abstract interface public subroutine abstract_step_system(self, param, t, dt) Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize abstract interface public subroutine abstract_write_frame(self, iu, param) Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Derived Types type, public :: swiftest_parameters User defined parameters that are read in from the parameters input file. \n    Each paramter is initialized to a default values. Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: integrator = UNKNOWN_INTEGRATOR Symbolic name of the nbody integrator  used integer(kind=I4B), public :: nplmax = -1 Maximum allowed number of massive bodies integer(kind=I4B), public :: ntpmax = -1 Maximum allowed number of test particles real(kind=DP), public :: t0 = -1.0_DP Integration start time real(kind=DP), public :: t = -1.0_DP Integration current time real(kind=DP), public :: tstop = -1.0_DP Integration stop time real(kind=DP), public :: dt = -1.0_DP Time step character(len=STRMAX), public :: incbfile = CB_INFILE Name of input file for the central body character(len=STRMAX), public :: inplfile = PL_INFILE Name of input file for massive bodies character(len=STRMAX), public :: intpfile = TP_INFILE Name of input file for test particles character(len=STRMAX), public :: in_type = ASCII_TYPE Format of input data files integer(kind=I4B), public :: istep_out = -1 Number of time steps between binary outputs character(len=STRMAX), public :: outfile = BIN_OUTFILE Name of output binary file character(len=STRMAX), public :: out_type = REAL8_TYPE Binary format of output file character(len=STRMAX), public :: out_form = XV Data to write to output file character(len=STRMAX), public :: out_stat = 'NEW' Open status for output binary file integer(kind=I4B), public :: istep_dump = -1 Number of time steps between dumps real(kind=DP), public :: rmin = -1.0_DP Minimum heliocentric radius for test particle real(kind=DP), public :: rmax = -1.0_DP Maximum heliocentric radius for test particle real(kind=DP), public :: rmaxu = -1.0_DP Maximum unbound heliocentric radius for test particle real(kind=DP), public :: qmin = -1.0_DP Minimum pericenter distance for test particle character(len=STRMAX), public :: qmin_coord = 'HELIO' Coordinate frame to use for qmin real(kind=DP), public :: qmin_alo = -1.0_DP Minimum semimajor axis for qmin real(kind=DP), public :: qmin_ahi = -1.0_DP Maximum semimajor axis for qmin character(len=STRMAX), public :: enc_out = \"\" Name of output file for encounters character(len=STRMAX), public :: discard_out = \"\" Name of output file for discards real(kind=QP), public :: MU2KG = -1.0_QP Converts mass units to grams real(kind=QP), public :: TU2S = -1.0_QP Converts time units to seconds real(kind=QP), public :: DU2M = -1.0_QP Converts distance unit to centimeters real(kind=DP), public :: GU = -1.0_DP Universal gravitational constant in the system units real(kind=DP), public :: inv_c2 = -1.0_DP Inverse speed of light squared in the system units character(len=STRMAX), public :: energy_out = \"\" Name of output energy and momentum report file logical, public :: lrhill_present = .false. Hill radii are given as an input rather than calculated by the code (can be used to inflate close encounter regions manually) logical, public :: lextra_force = .false. User defined force function turned on logical, public :: lbig_discard = .false. Save big bodies on every discard logical, public :: lclose = .false. Turn on close encounters logical, public :: lenergy = .false. Track the total energy of the system logical, public :: loblatecb = .false. Calculate acceleration from oblate central body (automatically turns true if nonzero J2 is input) logical, public :: lrotation = .false. Include rotation states of big bodies logical, public :: ltides = .false. Include tidal dissipation real(kind=DP), public :: Eorbit_orig = 0.0_DP Initial orbital energy real(kind=DP), public :: Mtot_orig = 0.0_DP Initial system mass real(kind=DP), public :: Lmag_orig = 0.0_DP Initial total angular momentum magnitude real(kind=DP), public, dimension(NDIM) :: Ltot_orig = 0.0_DP Initial total angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lorbit_orig = 0.0_DP Initial orbital angular momentum real(kind=DP), public, dimension(NDIM) :: Lspin_orig = 0.0_DP Initial spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Ltot = 0.0_DP System angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lescape = 0.0_DP Angular momentum of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Mescape = 0.0_DP Mass of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Ecollisions = 0.0_DP Energy lost from system due to collisions real(kind=DP), public :: Euntracked = 0.0_DP Energy gained from system due to escaped bodies logical, public :: lfirstenergy = .true. This is the first time computing energe logical, public :: lfirstkick = .true. Initiate the first kick in a symplectic step logical, public :: lrestart = .false. Indicates whether or not this is a restarted run logical, public :: lgr = .false. Turn on GR logical, public :: lyarkovsky = .false. Turn on Yarkovsky effect logical, public :: lyorp = .false. Turn on YORP effect Type-Bound Procedures procedure, public :: reader => io_param_reader procedure, public :: writer => io_param_writer procedure, public :: dump => io_dump_param procedure, public :: read_from_file => io_read_param_in type, public, abstract :: swiftest_base An superclass for a generic Swiftest object\n The minimal methods that all systems must have Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step Type-Bound Procedures procedure, public :: dump => io_dump_swiftest procedure(abstract_initialize), public :: initialize procedure(abstract_read_frame), public :: read_frame procedure(abstract_write_frame), public :: write_frame type, public, abstract, extends( swiftest_base ) :: swiftest_cb A concrete lass for the central body in a Swiftest simulation Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step character(len=STRMAX), public :: name Non-unique name integer(kind=I4B), public :: id = 0 External identifier (unique) real(kind=DP), public :: mass = 0.0_DP Central body mass (units MU) real(kind=DP), public :: Gmass = 0.0_DP Central mass gravitational term G * mass (units GU * MU) real(kind=DP), public :: radius = 0.0_DP Central body radius (units DU) real(kind=DP), public :: density = 1.0_DP Central body mass density - calculated internally (units MU / DU**3) real(kind=DP), public :: j2rp2 = 0.0_DP J2*R&#94;2 term for central body real(kind=DP), public :: j4rp4 = 0.0_DP J4*R&#94;2 term for central body real(kind=DP), public, dimension(NDIM) :: aobl = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: atide = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: aoblbeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: aoblend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: atidebeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: atideend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: xb = 0.0_DP Barycentric position (units DU) real(kind=DP), public, dimension(NDIM) :: vb = 0.0_DP Barycentric velocity (units DU / TU) real(kind=DP), public, dimension(NDIM) :: agr = 0.0_DP Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(NDIM) :: Ip = 0.0_DP Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(NDIM) :: rot = 0.0_DP Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public :: k2 = 0.0_DP Tidal Love number real(kind=DP), public :: Q = 0.0_DP Tidal quality factor real(kind=DP), public :: tlag = 0.0_DP Tidal phase lag angle real(kind=DP), public, dimension(NDIM) :: L0 = 0.0_DP Initial angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: dL = 0.0_DP Change in angular momentum of the central body Type-Bound Procedures procedure, public :: dump => io_dump_swiftest procedure, public :: initialize => io_read_cb_in I/O routine for reading in central body data procedure, public :: read_frame => io_read_frame_cb I/O routine for reading out a single frame of time-series data for the central body procedure, public :: write_frame => io_write_frame_cb I/O routine for writing out a single frame of time-series data for the central body type, public, abstract, extends( swiftest_base ) :: swiftest_body An abstract class for a generic collection of Swiftest bodies\n Superclass that defines the generic elements of a Swiftest particle Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill Type-Bound Procedures procedure, public :: dump => io_dump_swiftest procedure(abstract_discard_body), public :: discard procedure(abstract_kick_body), public :: kick procedure(abstract_set_mu), public :: set_mu procedure(abstract_step_body), public :: step procedure(abstract_accel), public :: accel procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: accel_obl => obl_acc_body Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: setup => setup_body A constructor that sets the number of bodies and allocates all allocatable arrays procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: append => util_append_body Appends elements from one structure to another procedure, public :: fill => util_fill_body \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: resize => util_resize_body Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) procedure, public :: sort => util_sort_body Sorts body arrays by a sortable componen procedure, public :: rearrange => util_sort_rearrange_body Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => util_spill_body \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) type, public, abstract, extends( swiftest_body ) :: swiftest_pl An abstract class for a generic collection of Swiftest massive bodies\n Superclass that defines the generic elements of a Swiftest particle Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl Type-Bound Procedures procedure, public :: dump => io_dump_swiftest procedure(abstract_kick_body), public :: kick procedure(abstract_step_body), public :: step procedure(abstract_accel), public :: accel procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) procedure, public :: discard => discard_pl Placeholder method for discarding massive bodies procedure, public :: eucl_index => eucl_dist_index_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: setup => setup_pl A base constructor that sets the number of bodies and allocates and initializes all arrays procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body procedure, public :: append => util_append_pl Appends elements from one structure to another procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) procedure, public :: fill => util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: resize => util_resize_pl Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. procedure, public :: set_mu => util_set_mu_pl Method used to construct the vectorized form of the central body mass procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body procedure, public :: sort => util_sort_pl Sorts body arrays by a sortable component procedure, public :: rearrange => util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) type, public, abstract, extends( swiftest_body ) :: swiftest_tp An abstract class for a generic collection of Swiftest test particles\n Superclass that defines the generic elements of a Swiftest test particle Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies character(len=STRMAX), public, dimension(:), allocatable :: name Non-unique name integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Heliocentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Heliocentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill integer(kind=I4B), public, dimension(:), allocatable :: isperi Perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri Perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp Semimajor axis following perihelion passage\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_tp and util_spill_tp Type-Bound Procedures procedure, public :: dump => io_dump_swiftest procedure(abstract_kick_body), public :: kick procedure(abstract_step_body), public :: step procedure(abstract_accel), public :: accel procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: initialize => io_read_body_in Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) procedure, public :: discard => discard_tp Check to see if test particles should be discarded based on their positions relative to the massive bodies procedure, public :: accel_int => kick_getacch_int_tp Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies procedure, public :: accel_obl => obl_acc_tp Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: setup => setup_tp A base constructor that sets the number of bodies and procedure, public :: append => util_append_tp Appends elements from one structure to another procedure, public :: h2b => util_coord_h2b_tp Convert test particles from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_tp Convert test particles from barycentric to heliocentric coordinates (position and velocity) procedure, public :: fill => util_fill_tp \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: get_peri => util_peri_tp Determine system pericenter passages for test particles procedure, public :: resize => util_resize_tp Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure, public :: set_mu => util_set_mu_tp Method used to construct the vectorized form of the central body mass procedure, public :: sort => util_sort_tp Sorts body arrays by a sortable component procedure, public :: rearrange => util_sort_rearrange_tp Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => util_spill_tp \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) type, public, abstract, extends( swiftest_base ) :: swiftest_nbody_system An abstract class for a basic Swiftest nbody system \n  This superclass contains a minimial system of a set of test particles (tp), massive bodies (pl), and a central body (cb) Components Type Visibility Attributes Name Initial logical, public :: lintegrate = .false. Flag indicating that this object should be integrated in the current step class( swiftest_cb ), public, allocatable :: cb Central body data structure class( swiftest_pl ), public, allocatable :: pl Massive body data structure class( swiftest_tp ), public, allocatable :: tp Test particle data structure class( swiftest_tp ), public, allocatable :: tp_discards Discarded test particle data structure class( swiftest_pl ), public, allocatable :: pl_discards Discarded massive body particle data structure real(kind=DP), public :: Gmtot = 0.0_DP Total system mass - used for barycentric coordinate conversion real(kind=DP), public :: ke_orbit = 0.0_DP System orbital kinetic energy real(kind=DP), public :: ke_spin = 0.0_DP System spin kinetic energy real(kind=DP), public :: pe = 0.0_DP System potential energy real(kind=DP), public :: te = 0.0_DP System total energy real(kind=DP), public, dimension(NDIM) :: Lorbit = 0.0_DP System orbital angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lspin = 0.0_DP System spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lescape = 0.0_DP Angular momentum of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Mescape = 0.0_DP Mass of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Ecollisions = 0.0_DP Energy lost from system due to collisions real(kind=DP), public :: Euntracked = 0.0_DP Energy gained from system due to escaped bodies logical, public :: lbeg True if this is the beginning of a step. This is used so that test particle steps can be calculated \n    separately from massive bodies.  Massive body variables are saved at half steps, and passed to \n    the test particles integer(kind=I4B), public :: maxid = -1 The current maximum particle id number Type-Bound Procedures procedure(abstract_step_system), public :: step Each integrator will have its own version of the step procedure, public :: discard => discard_system Perform a discard step on the system procedure, public :: conservation_report => io_conservation_report Compute energy and momentum and print out the change with time procedure, public :: dump => io_dump_system Dump the state of the system to a file procedure, public :: read_frame => io_read_frame_system Read in a frame of input data from file procedure, public :: write_discard => io_write_discard Write out information about discarded test particles procedure, public :: write_frame => io_write_frame_system Append a frame of output data to file procedure, public :: initialize => setup_initialize_system Initialize the system from input files procedure, public :: step_spin => tides_step_spin_system Steps the spins of the massive & central bodies due to tides. procedure, public :: set_msys => util_set_msys Sets the value of msys from the masses of system bodies. procedure, public :: get_energy_and_momentum => util_get_energy_momentum_system Calculates the total system energy and momentum procedure, public :: rescale => util_rescale_system Rescales the system into a new set of units procedure, public :: validate_ids => util_valid_id_system Validate the numerical ids passed to the system and save the maximum value type, public :: swiftest_encounter Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: nenc Total number of encounters logical, public, dimension(:), allocatable :: lvdotr relative vdotr flag integer(kind=I4B), public, dimension(:), allocatable :: status status of the interaction integer(kind=I4B), public, dimension(:), allocatable :: index1 position of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: index2 position of the second body in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x1 the position of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x2 the position of body 2 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v1 the velocity of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v2 the velocity of body 2 in the encounter Type-Bound Procedures procedure, public :: setup => setup_encounter A constructor that sets the number of encounters and allocates and initializes all arrays procedure, public :: copy => util_copy_encounter Copies elements from the source encounter list into self. procedure, public :: spill => util_spill_encounter \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure, public :: resize => util_resize_encounter Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small.","tags":"","loc":"module/swiftest_classes.html"},{"title":"lambda_function – swiftest","text":"Defines a class that can enable objects that behave like lambda functions. To use this class, define a type of either lambda_obj or lambda_obj_err, or extend the lambda_obj class as necessary, such that an interface that matches the function you wish to lambdafy.\n Once defined, the lambda object can evaluate itself by calling the type-bound procedure eval. e.g. f%eval(x) (or f%eval(x, lerr), f%eval(x, [argument list], etc)) Example - Defining a lambda function f(x,rval,ival) where rval and ival are a real and integer argument, respectively. This implementation uses an abstract interface, though this is not\n strictly necessary unless you want to bind more than one function with the same interface. module lambda_new \n    use swiftest ! This will bring in the lambda_function module\n    ! Define types in a module type , extends ( lambda_obj ) :: lambda_obj_ri_args procedure ( abstract_lambda_ri_args ), pointer , nopass :: lambdaptr_ri_args => null () real ( DP ) :: rval !! Real parameter integer ( I4B ) :: ival !! Integer paramete contains generic :: init => lambda_ri_args_init procedure :: eval => lambda_ri_args_eval procedure , nopass :: lambda_ri_args_init final :: lambda_ri_args_destroy end type interface lambda_obj module procedure lambda_ri_args_init end interface abstract interface function abstract_lambda_ri_args ( x , rval , ival ) result ( y ) ! Template for the lambda function import DP , I4B real ( DP ), dimension (:), intent ( in ) :: x !! Dependent variable real ( DP ), intent ( in ) :: rval !! Real parameter integer ( I4B ), intent ( in ) :: ival !! Integer parameter real ( DP ) :: y !! Real result end function end interface contains\n    type(lambda_obj_ri_args) function lambda_ri_args_init(lambda, rval, ival)\n       !! Initializes the lambda function parameters (can be used as a structure constructor)\n       implicit none\n       procedure(abstract_lambda_ri_args)  :: lambda !! The lambda function that will be passed\n       real(DP),     intent(in)            :: rval     !! Real parameter\n       integer(I4B), intent(in)            :: ival     !! Integer parameter ! Assign the procedure passed to this function to the procedure pointer lambda_ri_args_init % lambdaptr_ri_args => lambda ! Assign the argument values lambda_ri_args_init % rval = rval lambda_ri_args_init % ival = ival return end function lambda_ri_args_init function lambda_ri_args_eval ( self , x ) result ( y ) !! Defines the evaluation method , allowing the lambda function to be called with a single argument implicit none class ( lambda_obj_ri_args ), intent ( inout ) :: self real ( DP ), dimension (:), intent ( in ) :: x real ( DP ) :: y if ( associated ( self % lambdaptr_ri_args )) then y = self % lambdaptr_ri_args ( x , self % rval , self % ival ) self % lastval = y if ( allocated ( self % lastarg )) deallocate ( self % lastarg ) allocate ( self % lastarg , source = x ) else error stop \"Lambda function was not initialized\" end if end function lambda_ri_args_eval subroutine lambda_ri_args_destroy ( self ) !! Finalizer method . Use this as a template for cleaning up the object upon destruction , such as nullifying pointers implicit none type ( lambda_obj_ri_args ) :: self if ( associated ( self % lambdaptr_ri_args )) nullify ( self % lambdaptr_ri_args ) end subroutine lambda_ri_args_destroy function example_function ( x , rval , ival ) result ( y ) ! This is the actual function you are going to use as the lambda function . Its interface must match the abstract interface previously defined implicit none ! Arguments real ( DP ), dimension (:), intent ( in ) :: x real ( DP ), intent ( in ) :: rval integer ( I4B ), intent ( in ) :: ival ! Result real ( DP ) :: y ! Internals integer ( I4B ) :: i , n n = size ( x ) y = 42 . _DP * ival do i = 1 , n y = y + x ( i ) ** 2 end do return end function example_function end module lambda_new program usage\n    use swiftest\n    use lambda_new\n    implicit none\n    type(lambda_obj_ri_args) :: f\n    real(DP) :: sigma_par\n    integer(I4B) :: iwonky, i,j\n    real(DP), dimension(12) :: xarr sigma_par = 3 . 14 _DP iwonky = 13 f = lambda_obj ( example_function , sigma_par , iwonky ) do i = 1 , 10 xarr (:) = [( j * 0 . 25 _DP / i , j = 1 , 12 )] write ( * , * ) i , f % eval ( xarr ) end do end program usage Uses swiftest_globals module~~lambda_function~~UsesGraph module~lambda_function lambda_function module~swiftest_globals swiftest_globals module~lambda_function->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~lambda_function~~UsedByGraph module~lambda_function lambda_function module~swiftest swiftest module~swiftest->module~lambda_function module~whm_drift whm_drift module~whm_drift->module~swiftest module~s_gr s_gr module~s_gr->module~swiftest module~s_symba_setup s_symba_setup module~s_symba_setup->module~swiftest module~s_whm_setup s_whm_setup module~s_whm_setup->module~swiftest module~s_util_append s_util_append module~s_util_append->module~swiftest module~s_helio_kick s_helio_kick module~s_helio_kick->module~swiftest module~s_helio_gr s_helio_gr module~s_helio_gr->module~swiftest module~s_symba_discard s_symba_discard module~s_symba_discard->module~swiftest module~s_rmvs_util s_rmvs_util module~s_rmvs_util->module~swiftest module~s_obl s_obl module~s_obl->module~swiftest module~s_rmvs_setup s_rmvs_setup module~s_rmvs_setup->module~swiftest module~s_util_set s_util_set module~s_util_set->module~swiftest module~s_helio_step s_helio_step module~s_helio_step->module~swiftest module~s_util_exit s_util_exit module~s_util_exit->module~swiftest module~s_rmvs_step s_rmvs_step module~s_rmvs_step->module~swiftest module~s_symba_fragmentation s_symba_fragmentation module~s_symba_fragmentation->module~swiftest module~s_util_coord s_util_coord module~s_util_coord->module~swiftest proc~ge_wpp ge_wpp proc~ge_wpp->module~swiftest module~s_util_sort s_util_sort module~s_util_sort->module~swiftest module~s_util_copy s_util_copy module~s_util_copy->module~swiftest module~s_symba_util s_symba_util module~s_symba_util->module~swiftest module~s_symba_encounter_check s_symba_encounter_check module~s_symba_encounter_check->module~swiftest module~s_whm_kick s_whm_kick module~s_whm_kick->module~swiftest module~s_util_fill s_util_fill module~s_util_fill->module~swiftest module~s_symba_io s_symba_io module~s_symba_io->module~swiftest module~drift_implementation drift_implementation module~drift_implementation->module~swiftest module~s_symba_collision s_symba_collision module~s_symba_collision->module~swiftest module~s_tides_step_spin s_tides_step_spin module~s_tides_step_spin->module~swiftest module~s_user_kick_getacch s_user_kick_getacch module~s_user_kick_getacch->module~swiftest module~s_util_version s_util_version module~s_util_version->module~swiftest module~s_util_spill s_util_spill module~s_util_spill->module~swiftest module~s_helio_coord s_helio_coord module~s_helio_coord->module~swiftest module~s_rmvs_discard s_rmvs_discard module~s_rmvs_discard->module~swiftest module~s_orbel s_orbel module~s_orbel->module~swiftest module~s_util_valid s_util_valid module~s_util_valid->module~swiftest module~s_eucl s_eucl module~s_eucl->module~swiftest module~s_operator_cross s_operator_cross module~s_operator_cross->module~swiftest module~s_discard s_discard module~s_discard->module~swiftest module~s_helio_drift s_helio_drift module~s_helio_drift->module~swiftest program~swiftest_driver swiftest_driver program~swiftest_driver->module~swiftest module~s_util_solve s_util_solve module~s_util_solve->module~swiftest module~s_whm_util s_whm_util module~s_whm_util->module~swiftest module~s_setup s_setup module~s_setup->module~swiftest module~s_symba_kick s_symba_kick module~s_symba_kick->module~swiftest proc~solve_wbs solve_wbs proc~solve_wbs->module~swiftest module~s_kick s_kick module~s_kick->module~swiftest module~s_tides_kick_getacch s_tides_kick_getacch module~s_tides_kick_getacch->module~swiftest module~s_rmvs_chk s_rmvs_chk module~s_rmvs_chk->module~swiftest module~s_util_minimize_bfgs s_util_minimize_bfgs module~s_util_minimize_bfgs->module~swiftest module~s_util_get_energy_momentum s_util_get_energy_momentum module~s_util_get_energy_momentum->module~swiftest module~s_whm_coord s_whm_coord module~s_whm_coord->module~swiftest module~s_util_resize s_util_resize module~s_util_resize->module~swiftest module~s_util_rescale s_util_rescale module~s_util_rescale->module~swiftest module~s_whm_gr s_whm_gr module~s_whm_gr->module~swiftest module~s_rmvs_kick s_rmvs_kick module~s_rmvs_kick->module~swiftest module~s_whm_step s_whm_step module~s_whm_step->module~swiftest module~s_fragmentation s_fragmentation module~s_fragmentation->module~swiftest module~s_symba_drift s_symba_drift module~s_symba_drift->module~swiftest module~s_symba_step s_symba_step module~s_symba_step->module~swiftest module~s_io s_io module~s_io->module~swiftest module~s_util_peri s_util_peri module~s_util_peri->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces lambda_obj Abstract Interfaces lambda0 lambda0err lambda0tvar Derived Types lambda_obj lambda_obj_err lambda_obj_tvar Functions lambda_init_0 lambda_init_0_err lambda_init_tvar lambda_eval_0 lambda_eval_0_err lambda_eval_tvar Subroutines lambda_destroy Interfaces public interface lambda_obj public function lambda_init_0 (lambda) Arguments Type Intent Optional Attributes Name procedure( lambda0 ) :: lambda Return Value type( lambda_obj ) public function lambda_init_0_err (lambda, lerr) Arguments Type Intent Optional Attributes Name procedure( lambda0err ) :: lambda logical, intent(in) :: lerr Return Value type( lambda_obj_err ) public function lambda_init_tvar (lambda, t) Arguments Type Intent Optional Attributes Name procedure( lambda0tvar ) :: lambda real(kind=DP), intent(in) :: t Return Value type( lambda_obj_tvar ) Abstract Interfaces abstract interface public function lambda0(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: x Return Value real(kind=DP) abstract interface public function lambda0err(x, lerr) result(y) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: x logical, intent(out) :: lerr Return Value real(kind=DP) abstract interface public function lambda0tvar(x, t) result(y) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in) :: t Return Value real(kind=DP),\n  dimension(:), allocatable Derived Types type, public :: lambda_obj Base class for an lambda function object. This object takes no additional arguments other than the dependent variable x, an array of real numbers Components Type Visibility Attributes Name Initial procedure( lambda0 ), public, pointer, nopass :: lambdaptr => null() real(kind=DP), public :: lastval real(kind=DP), public, dimension(:), allocatable :: lastarg Constructor public  function lambda_init_0 (lambda) public  function lambda_init_0_err (lambda, lerr) public  function lambda_init_tvar (lambda, t) Finalizations Procedures final :: lambda_destroy","tags":"","loc":"module/lambda_function.html"},{"title":"s_kick – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_kick~~UsesGraph module~s_kick s_kick module~swiftest swiftest module~s_kick->module~swiftest module~swiftest_classes swiftest_classes module~s_kick->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines kick_getacch_int_pl kick_getacch_int_tp Module Subroutines pure module subroutine kick_getacch_int_pl (self) Interface → Author David A. Minton Compute direct cross (third) term heliocentric accelerations of massive bodies Read more… Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self pure module subroutine kick_getacch_int_tp (self, GMpl, xhp, npl) Interface → Author David A. Minton Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle real(kind=DP), intent(in), dimension(:) :: GMpl Massive body masses real(kind=DP), intent(in), dimension(:,:) :: xhp Massive body position vectors integer(kind=I4B), intent(in) :: npl Number of active massive bodies","tags":"","loc":"module/s_kick.html"},{"title":"s_tides_kick_getacch – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_tides_kick_getacch~~UsesGraph module~s_tides_kick_getacch s_tides_kick_getacch module~swiftest swiftest module~s_tides_kick_getacch->module~swiftest module~swiftest_classes swiftest_classes module~s_tides_kick_getacch->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines tides_kick_getacch_pl Module Subroutines module subroutine tides_kick_getacch_pl (self, system) Interface → Author Jennifer L.L. Pouplin, Carlisle A. wishard, and David A. Minton Calculated tidal torques from central body to any planet and from any planet to central body\n planet - planet interactions are considered negligable.\n This is a constant time lag model. Read more… Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object","tags":"","loc":"module/s_tides_kick_getacch.html"},{"title":"s_tides_step_spin – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_tides_step_spin~~UsesGraph module~s_tides_step_spin s_tides_step_spin module~swiftest swiftest module~s_tides_step_spin->module~swiftest module~swiftest_classes swiftest_classes module~s_tides_step_spin->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces lambda_obj Abstract Interfaces tidederiv Derived Types tides_derivs_func Functions tides_spin_derivs tides_derivs_eval tides_derivs_init Module Subroutines tides_step_spin_system Interfaces interface lambda_obj function tides_derivs_init (lambda, dt, xbeg, xend) result(f) Arguments Type Intent Optional Attributes Name procedure( tidederiv ) :: lambda real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), dimension(:,:) :: xbeg real(kind=DP), intent(in), dimension(:,:) :: xend Return Value type( tides_derivs_func ) Abstract Interfaces abstract interface function tidederiv(x, t, dt, xbeg, xend) result(y) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), dimension(:,:) :: xbeg real(kind=DP), intent(in), dimension(:,:) :: xend Return Value real(kind=DP),\n  dimension(:), allocatable Derived Types type, extends(lambda_obj_tvar) :: tides_derivs_func Base class for an lambda function object. This object takes no additional arguments other than the dependent variable x, an array of real numbers Components Type Visibility Attributes Name Initial procedure( tidederiv ), public, pointer, nopass :: lambdaptr_tides_deriv real(kind=DP), public, dimension(:,:), allocatable :: xbeg real(kind=DP), public, dimension(:,:), allocatable :: xend real(kind=DP), public :: dt Type-Bound Procedures generic, public :: init => tides_derivs_init procedure, public :: evalt => tides_derivs_eval procedure, public, nopass :: tides_derivs_init Functions function tides_spin_derivs (rot_pl_cb, t, dt, xbeg, xend) result(drot) Need to add more arguments so we can pull in mass, radius, Ip, J2, etc...\n author: Jennifer L.L. Pouplin and David A. Minton Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: rot_pl_cb Array of rotations. The last element is the central body, and all others are massive bodies real(kind=DP), intent(in) :: t Current time, which is used to interpolate the massive body positions real(kind=DP), intent(in) :: dt Total step size real(kind=DP), intent(in), dimension(:,:) :: xbeg real(kind=DP), intent(in), dimension(:,:) :: xend Return Value real(kind=DP),\n  dimension(:,:), allocatable function tides_derivs_eval (self, x, t) result(y) Arguments Type Intent Optional Attributes Name class( tides_derivs_func ), intent(inout) :: self real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in) :: t Return Value real(kind=DP),\n  dimension(:), allocatable function tides_derivs_init (lambda, dt, xbeg, xend) result(f) Arguments Type Intent Optional Attributes Name procedure( tidederiv ) :: lambda real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), dimension(:,:) :: xbeg real(kind=DP), intent(in), dimension(:,:) :: xend Return Value type( tides_derivs_func ) Module Subroutines module subroutine tides_step_spin_system (self, param, t, dt) Interface → Author Jennifer L.L. Pouplin and David A. Minton Integrates the spin equations for central and massive bodies of the system subjected to tides. Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"module/s_tides_step_spin.html"},{"title":"s_obl – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_obl~~UsesGraph module~s_obl s_obl module~swiftest swiftest module~s_obl->module~swiftest module~swiftest_classes swiftest_classes module~s_obl->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines obl_acc_body obl_acc_pl obl_acc_tp obl_pot Module Subroutines module subroutine obl_acc_body (self, system) Interface → Author David A. Minton Compute the barycentric accelerations of bodies due to the oblateness of the central body\n      Returned values do not include monopole term or terms higher than J4 Read more… Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object module subroutine obl_acc_pl (self, system) Interface → Author David A. Minton Compute the barycentric accelerations of massive bodies due to the oblateness of the central body Read more… Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object module subroutine obl_acc_tp (self, system) Interface → Author David A. Minton Compute the barycentric accelerations of massive bodies due to the oblateness of the central body Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object module subroutine obl_pot (npl, Mcb, Mpl, j2rp2, j4rp4, xh, irh, oblpot) Interface → Author David A. Minton Compute the contribution to the total gravitational potential due solely to the oblateness of the central body\n    Returned value does not include monopole term or terms higher than J4 Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl real(kind=DP), intent(in) :: Mcb real(kind=DP), intent(in), dimension(:) :: Mpl real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in), dimension(:, :) :: xh real(kind=DP), intent(in), dimension(:) :: irh real(kind=DP), intent(out) :: oblpot","tags":"","loc":"module/s_obl.html"},{"title":"s_orbel – swiftest","text":"Code converted to Modern Fortran by David A. Minton\n Date: 2020-06-29 ORBEL_SCHGET.F PURPOSE : Given an angle , efficiently compute sinh and cosh . Input : angle ==> angle in radians ( real scalar ) Output : shx ==> sinh ( angle ) ( real scalar ) chx ==> cosh ( angle ) ( real scalar ) ALGORITHM : Obvious from the code REMARKS : Based on the routine SCGET for sine 's and cosine' s . We use the sqrt rather than cosh ( it 's faster) BE SURE THE ANGLE IS IN RADIANS AND IT CAN' T BE LARGER THAN 300 OR OVERFLOWS WILL OCCUR ! AUTHOR : M . Duncan . DATE WRITTEN : May 6 , 1992 . REVISIONS : Code converted to Modern Fortran by David A. Minton\n Date: 2020-06-29 !                    ORBEL_FLON.F PURPOSE : Solves Kepler ' s eqn . for hyperbola using hybrid approach . Input : e ==> eccentricity anomaly . ( real scalar ) capn ==> hyperbola mean anomaly . ( real scalar ) Returns : orbel_flon ==> eccentric anomaly . ( real scalar ) ALGORITHM : Uses power series for N in terms of F and Newton , s method REMARKS : ONLY GOOD FOR LOW VALUES OF N ( N < 0 . 636 * e - 0 . 6 ) AUTHOR : M . Duncan DATE WRITTEN : May 26 , 1992 . REVISIONS : Code converted to Modern Fortran by David A. Minton\n Date: 2020-06-29 ORBEL_FGET.F PURPOSE : Solves Kepler 's eqn. for hyperbola using hybrid approach. Input: e ==> eccentricity anomaly. (real scalar) capn ==> hyperbola mean anomaly. (real scalar) Returns: orbel_fget ==>  eccentric anomaly. (real scalar) ALGORITHM: Based on pp. 70-72 of Fitzpatrick' s book \"Principles of Cel. Mech. \" . Quartic convergence from Danby ' s book . REMARKS : AUTHOR : M . Duncan DATE WRITTEN : May 11 , 1992 . REVISIONS : 2 / 26 / 93 hfl Code converted to Modern Fortran by David A. Minton\n Date: 2020-06-29 ORBEL_ZGET.F PURPOSE : Solves the equivalent of Kepler 's eqn. for a parabola given Q (Fitz. notation.) Input: q ==>  parabola mean anomaly. (real scalar) Returns: orbel_zget ==>  eccentric anomaly. (real scalar) ALGORITHM: p. 70-72 of Fitzpatrick' s book \"Princ. of Cel. Mech.\" REMARKS : For a parabola we can solve analytically . AUTHOR : M . Duncan DATE WRITTEN : May 11 , 1992 . REVISIONS : May 27 - corrected it for negative Q and use power series for small Q . Code converted to Modern Fortran by David A. Minton\n Date: 2020-06-29 ORBEL_ESOLMD.F PURPOSE : Solves Kepler ' s eqn . e is ecc . m is mean anomaly . Input : e ==> eccentricity anomaly . ( real scalar ) m ==> mean anomaly . ( real scalar ) Returns : orbel_esolmd ==> eccentric anomaly . ( real scalar ) ALGORITHM : Some sort of quartic convergence from Wisdom . REMARKS : ONLY GOOD FOR SMALL ECCENTRICITY SINCE IT ONLY ITERATES ONCE . ( GOOD FOR PLANET CALCS .) ALSO DOES NOT PUT M OR E BETWEEN 0 . AND 2 * PI INCLUDES : needs SCGET . F AUTHOR : M . Duncan DATE WRITTEN : May 7 , 1992 . REVISIONS : 2 / 26 / 93 hfl Code converted to Modern Fortran by David A. Minton\n Date: 2020-06-29 ORBEL_EHIE.F PURPOSE : Solves Kepler 's eqn.   e is ecc.   m is mean anomaly. Input: e ==> eccentricity anomaly. (real scalar) m ==> mean anomaly. (real scalar) Returns: orbel_ehybrid ==>  eccentric anomaly. (real scalar) ALGORITHM: Use Danby' s quartic for 3 iterations . Eqn . is f ( x ) = x - e * sin ( x + M ). Note that E = x + M . First guess is very good for e near 1 . Need to first get M between 0 . and PI and use symmetry to return right answer if M between PI and 2PI\n     REMARKS: Modifies M so that both E and M are in range (0,TWOPI)\n     AUTHOR: M. Duncan\n     DATE WRITTEN: May 25,1992.\n     REVISIONS: Code converted to Modern Fortran by David A. Minton\n Date: 2020-06-29 ORBEL_EGET.F PURPOSE : Solves Kepler ' s eqn . e is ecc . m is mean anomaly . Input : e ==> eccentricity anomaly . ( real scalar ) m ==> mean anomaly . ( real scalar ) Returns : orbel_eget ==> eccentric anomaly . ( real scalar ) ALGORITHM : Quartic convergence from Danby REMARKS : For results very near roundoff , give it M between 0 and 2 * pi . One can condition M before calling EGET by calling my double precision function MOD2PI ( M ). This is not done within the routine to speed it up and because it works fine even for large M . AUTHOR : M . Duncan DATE WRITTEN : May 7 , 1992. REVISIONS : May 21 , 1992. Now have it go through EXACTLY two iterations with the premise that it will only be called if we have an ellipse with e between 0.15 and 0.8 Code converted to Modern Fortran by David A. Minton\n Date: 2020-06-29 ORBEL_EHYBRID.F PURPOSE : Solves Kepler ' s eqn . e is ecc . m is mean anomaly . Input : e ==> eccentricity anomaly . ( real scalar ) m ==> mean anomaly . ( real scalar ) Returns : orbel_ehybrid ==> eccentric anomaly . ( real scalar ) ALGORITHM : For e < 0 . 18 uses fast routine ESOLMD For larger e but less than 0 . 8 , uses EGET For e > 0 . 8 uses EHIE REMARKS : Only EHIE brings M and E into range ( 0 , TWOPI ) AUTHOR : M . Duncan DATE WRITTEN : May 25 , 1992 . REVISIONS : 2 / 26 / 93 hfl Code converted to Modern Fortran by David A. Minton\n Date: 2020-06-29 ORBEL_FHYBRID.F PURPOSE : Solves Kepler ' s eqn . for hyperbola using hybrid approach . Input : e ==> eccentricity anomaly . ( real scalar ) n ==> hyperbola mean anomaly . ( real scalar ) Returns : orbel_fhybrid ==> eccentric anomaly . ( real scalar ) ALGORITHM : For abs ( N ) < 0 . 636 * ecc - 0 . 6 , use FLON For larger N , uses FGET REMARKS : AUTHOR : M . Duncan DATE WRITTEN : May 26 , 1992 . REVISIONS :: REVISIONS : 2 / 26 / 93 hfl Uses swiftest Ancestors: swiftest_classes module~~s_orbel~~UsesGraph module~s_orbel s_orbel module~swiftest swiftest module~s_orbel->module~swiftest module~swiftest_classes swiftest_classes module~s_orbel->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions orbel_flon orbel_fget orbel_zget orbel_esolmd orbel_ehie orbel_eget orbel_ehybrid orbel_fhybrid Subroutines orbel_el2xv orbel_schget orbel_xv2el Module Subroutines orbel_el2xv_vec orbel_scget orbel_xv2aeq orbel_xv2aqt orbel_xv2el_vec Functions pure function orbel_flon (e, icapn) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: icapn Return Value real(kind=DP) pure function orbel_fget (e, capn) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: capn Return Value real(kind=DP) pure function orbel_zget (iq) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: iq Return Value real(kind=DP) pure function orbel_esolmd (e, m) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: m Return Value real(kind=DP) pure function orbel_ehie (e, im) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: im Return Value real(kind=DP) pure function orbel_eget (e, m) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: m Return Value real(kind=DP) pure function orbel_ehybrid (e, m) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: m Return Value real(kind=DP) pure function orbel_fhybrid (e, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: n Return Value real(kind=DP) Subroutines pure subroutine orbel_el2xv (mu, a, ie, inc, capom, omega, capm, x, v) Author David A. Minton Compute osculating orbital elements from relative C)rtesian position and velocity\n  All angular measures are returned in radians\n      If inclination < TINY, longitude of the ascending node is arbitrarily set to 0 Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: a real(kind=DP), intent(in) :: ie real(kind=DP), intent(in) :: inc real(kind=DP), intent(in) :: capom real(kind=DP), intent(in) :: omega real(kind=DP), intent(in) :: capm real(kind=DP), intent(out), dimension(:) :: x real(kind=DP), intent(out), dimension(:) :: v pure subroutine orbel_schget (angle, shx, chx) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: angle real(kind=DP), intent(out) :: shx real(kind=DP), intent(out) :: chx pure subroutine orbel_xv2el (mu, x, v, a, e, inc, capom, omega, capm) Author David A. Minton Compute osculating orbital elements from relative Cartesian position and velocity\n  All angular measures are returned in radians\n      If inclination < TINY, longitude of the ascending node is arbitrarily set to 0 Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in), dimension(:) :: v real(kind=DP), intent(out) :: a real(kind=DP), intent(out) :: e real(kind=DP), intent(out) :: inc real(kind=DP), intent(out) :: capom real(kind=DP), intent(out) :: omega real(kind=DP), intent(out) :: capm Module Subroutines module subroutine orbel_el2xv_vec (self, cb) Interface → Author David A. Minton A wrapper method that converts all of the cartesian position and velocity vectors of a Swiftest body object to orbital elements. Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body objec pure module subroutine orbel_scget (angle, sx, cx) Interface → Author David A. Minton Efficiently compute the sine and cosine of an input angle\n      Input angle must be in radians Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: angle real(kind=DP), intent(out) :: sx real(kind=DP), intent(out) :: cx pure module subroutine orbel_xv2aeq (mu, x, v, a, e, q) Interface → Author David A. Minton Compute semimajor axis, eccentricity, and pericentric distance from relative Cartesian position and velocity Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in), dimension(:) :: v real(kind=DP), intent(out) :: a real(kind=DP), intent(out) :: e real(kind=DP), intent(out) :: q pure module subroutine orbel_xv2aqt (mu, x, v, a, q, capm, tperi) Interface → Author David A. Minton Compute semimajor axis, pericentric distance, mean anomaly, and time to nearest pericenter passage from\n relative Cartesian position and velocity\n      tperi > 0 means nearest pericenter passage is in the future\n      tperi < 0 means nearest pericenter passage is in the past Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(out) :: a semimajor axis real(kind=DP), intent(out) :: q periapsis real(kind=DP), intent(out) :: capm mean anomaly real(kind=DP), intent(out) :: tperi time of pericenter passage module subroutine orbel_xv2el_vec (self, cb) Interface → Author David A. Minton A wrapper method that converts all of the cartesian position and velocity vectors of a Swiftest body object to orbital elements. Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"module/s_orbel.html"},{"title":"s_whm_coord – swiftest","text":"Uses swiftest Ancestors: whm_classes module~~s_whm_coord~~UsesGraph module~s_whm_coord s_whm_coord module~swiftest swiftest module~s_whm_coord->module~swiftest module~whm_classes whm_classes module~s_whm_coord->module~whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines whm_coord_h2j_pl whm_coord_j2h_pl whm_coord_vh2vj_pl Module Subroutines module subroutine whm_coord_h2j_pl (self, cb) Interface → Author David A. Minton Convert from heliocentric to Jacobi coordinates, massive bodies only Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree module subroutine whm_coord_j2h_pl (self, cb) Interface → Author David A. Minton Convert from Jacobi to heliocentric coordinates, massive bodies only. Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree module subroutine whm_coord_vh2vj_pl (self, cb) Interface → Author David A. Minton Convert from heliocentric to Jadcobi coordinates, massive body velocities only Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree","tags":"","loc":"module/s_whm_coord.html"},{"title":"s_whm_gr – swiftest","text":"Uses swiftest Ancestors: whm_classes module~~s_whm_gr~~UsesGraph module~s_whm_gr s_whm_gr module~swiftest swiftest module~s_whm_gr->module~swiftest module~whm_classes whm_classes module~s_whm_gr->module~whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines whm_gr_kick_getacch_pl whm_gr_kick_getacch_tp whm_gr_p4_pl whm_gr_p4_tp Module Subroutines module subroutine whm_gr_kick_getacch_pl (self, param) Interface → Author David A. Minton Compute relativisitic accelerations of massive bodies\n    Based on Saha & Tremaine (1994) Eq. 28 Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters module subroutine whm_gr_kick_getacch_tp (self, param) Interface → Author David A. Minton Compute relativisitic accelerations of test particles\n    Based on Saha & Tremaine (1994) Eq. 28 Read more… Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters pure module subroutine whm_gr_p4_pl (self, param, dt) Interface → Author David A. Minton Position kick to massive bodies due to p**4 term in the post-Newtonian correction\n    Based on Saha & Tremaine (1994) Eq. 28 Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size pure module subroutine whm_gr_p4_tp (self, param, dt) Interface → Author David A. Minton Position kick to test particles due to p**4 term in the post-Newtonian correction\n    Based on Saha & Tremaine (1994) Eq. 28 Read more… Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size","tags":"","loc":"module/s_whm_gr.html"},{"title":"s_whm_step – swiftest","text":"Uses swiftest Ancestors: whm_classes module~~s_whm_step~~UsesGraph module~s_whm_step s_whm_step module~swiftest swiftest module~s_whm_step->module~swiftest module~whm_classes whm_classes module~s_whm_step->module~whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines whm_step_system whm_step_pl whm_step_tp Module Subroutines module subroutine whm_step_system (self, param, t, dt) Interface → Author David A. Minton Step massive bodies and and active test particles ahead in heliocentric coordinates Read more… Arguments Type Intent Optional Attributes Name class( whm_nbody_system ), intent(inout) :: self WHM nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current stepsize module subroutine whm_step_pl (self, system, param, t, dt) Interface → Author David A. Minton Step planets ahead using kick-drift-kick algorithm Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current stepsize module subroutine whm_step_tp (self, system, param, t, dt) Interface → Author David A. Minton Step active test particles ahead using kick-drift-kick algorithm Read more… Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"module/s_whm_step.html"},{"title":"whm_drift – swiftest","text":"Uses swiftest Ancestors: whm_classes module~~whm_drift~~UsesGraph module~whm_drift whm_drift module~swiftest swiftest module~whm_drift->module~swiftest module~whm_classes whm_classes module~whm_drift->module~whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines whm_drift_pl Module Subroutines module subroutine whm_drift_pl (self, system, param, dt) Interface → Author David A. Minton Loop through planets and call Danby drift routine Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"module/whm_drift.html"},{"title":"s_whm_kick – swiftest","text":"Uses swiftest Ancestors: whm_classes module~~s_whm_kick~~UsesGraph module~s_whm_kick s_whm_kick module~swiftest swiftest module~s_whm_kick->module~swiftest module~whm_classes whm_classes module~s_whm_kick->module~whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions whm_kick_getacch_ah0 Subroutines whm_kick_getacch_ah1 whm_kick_getacch_ah2 Module Subroutines whm_kick_getacch_pl whm_kick_getacch_tp whm_kick_vh_pl whm_kick_vh_tp Functions function whm_kick_getacch_ah0 (mu, xhp, n) result(ah0) Author David A. Minton Compute zeroth term heliocentric accelerations of planets Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: mu real(kind=DP), intent(in), dimension(:,:) :: xhp integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  dimension(NDIM) Subroutines pure subroutine whm_kick_getacch_ah1 (cb, pl) Author David A. Minton Compute first term heliocentric accelerations of planets Read more… Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: cb WHM central body object class( whm_pl ), intent(inout) :: pl WHM massive body object pure subroutine whm_kick_getacch_ah2 (cb, pl) Author David A. Minton Compute second term heliocentric accelerations of planets Read more… Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: cb Swiftest central body object class( whm_pl ), intent(inout) :: pl WHM massive body object Module Subroutines module subroutine whm_kick_getacch_pl (self, system, param, t, lbeg) Interface → Author David A. Minton Compute heliocentric accelerations of planets Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest central body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step module subroutine whm_kick_getacch_tp (self, system, param, t, lbeg) Interface → Author David A. Minton Compute heliocentric accelerations of test particles Read more… Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest central body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step module subroutine whm_kick_vh_pl (self, system, param, t, dt, lbeg) Interface → Author David A. Minton Kick heliocentric velocities of massive bodies Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. module subroutine whm_kick_vh_tp (self, system, param, t, dt, lbeg) Interface → Author David A. Minton Kick heliocentric velocities of test particles Read more… Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not.","tags":"","loc":"module/s_whm_kick.html"},{"title":"s_whm_setup – swiftest","text":"Uses swiftest Ancestors: whm_classes module~~s_whm_setup~~UsesGraph module~s_whm_setup s_whm_setup module~swiftest swiftest module~s_whm_setup->module~swiftest module~whm_classes whm_classes module~s_whm_setup->module~whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines whm_setup_pl whm_util_set_mu_eta_pl whm_setup_initialize_system Module Subroutines module subroutine whm_setup_pl (self, n, param) Interface → Author David A. Minton Allocate WHM planet structure Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameter module subroutine whm_util_set_mu_eta_pl (self, cb) Interface → Author David A. Minton Sets the Jacobi mass value eta for all massive bodies Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM system object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object module subroutine whm_setup_initialize_system (self, param) Interface → Author David A. Minton Initialize a WHM nbody system from files Arguments Type Intent Optional Attributes Name class( whm_nbody_system ), intent(inout) :: self Swiftest system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters","tags":"","loc":"module/s_whm_setup.html"},{"title":"s_whm_util – swiftest","text":"Uses swiftest Ancestors: whm_classes module~~s_whm_util~~UsesGraph module~s_whm_util s_whm_util module~swiftest swiftest module~s_whm_util->module~swiftest module~whm_classes whm_classes module~s_whm_util->module~whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines whm_util_append_pl whm_util_fill_pl whm_util_resize_pl whm_util_set_ir3j whm_util_sort_pl whm_util_sort_rearrange_pl whm_util_spill_pl Module Subroutines module subroutine whm_util_append_pl (self, source, lsource_mask) Interface → Author David A. Minton Append components from one massive body object to another. \n This method will automatically resize the destination body if it is too small\n Arguments Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to module subroutine whm_util_fill_pl (self, inserts, lfill_list) Interface → Author David A. Minton Insert new WHM test particle structure into an old one. \n This is the inverse of a fill operation. Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(in) :: inserts inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps module subroutine whm_util_resize_pl (self, nnew) Interface → Author David A. Minton Checks the current size of a massive body against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object integer(kind=I4B), intent(in) :: nnew New size neded module subroutine whm_util_set_ir3j (self) Interface → Author David A. Minton Sets the inverse Jacobi and heliocentric radii cubed (1/rj 3 and 1/rh 3) Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object module subroutine whm_util_sort_pl (self, sortby, ascending) Interface → Author David A. Minton Sort a WHM massive body object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order module subroutine whm_util_sort_rearrange_pl (self, ind) Interface → Author David A. Minton Rearrange WHM massive body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) module subroutine whm_util_spill_pl (self, discards, lspill_list, ldestructive) Interface → Author David A. Minton Move spilled (discarded) WHM test particle structure from active list to discard list Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"module/s_whm_util.html"},{"title":"s_operator_cross – swiftest","text":"Contains implementations for the .cross. operator for all defined integer and real types\n Single vector implementations: C(1:3)   = A(1:3)   .cross. B(1:3) \n Vector list implementations:   C(1:3, :) = A(1:3, :) .cross. B(1:3, :) Uses swiftest Ancestors: swiftest_operators module~~s_operator_cross~~UsesGraph module~s_operator_cross s_operator_cross module~swiftest_operators swiftest_operators module~s_operator_cross->module~swiftest_operators module~swiftest swiftest module~s_operator_cross->module~swiftest module~swiftest_globals swiftest_globals module~swiftest_operators->module~swiftest_globals module~swiftest->module~swiftest_operators module~whm_classes whm_classes module~swiftest->module~whm_classes module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest->module~swiftest_globals module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Functions operator_cross_sp operator_cross_dp operator_cross_qp operator_cross_i1b operator_cross_i2b operator_cross_i4b operator_cross_i8b operator_cross_el_sp operator_cross_el_dp operator_cross_el_qp operator_cross_el_i1b operator_cross_el_i2b operator_cross_el_i4b operator_cross_el_i8b Module Functions pure function operator_cross_sp (A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: A real(kind=SP), intent(in), dimension(:) :: B Return Value real(kind=SP),\n  dimension(3) pure function operator_cross_dp (A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: A real(kind=DP), intent(in), dimension(:) :: B Return Value real(kind=DP),\n  dimension(3) pure function operator_cross_qp (A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:) :: A real(kind=QP), intent(in), dimension(:) :: B Return Value real(kind=QP),\n  dimension(3) pure function operator_cross_i1b (A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in), dimension(:) :: A integer(kind=I1B), intent(in), dimension(:) :: B Return Value integer(kind=I1B),\n  dimension(3) pure function operator_cross_i2b (A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in), dimension(:) :: A integer(kind=I2B), intent(in), dimension(:) :: B Return Value integer(kind=I2B),\n  dimension(3) pure function operator_cross_i4b (A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:) :: A integer(kind=I4B), intent(in), dimension(:) :: B Return Value integer(kind=I4B),\n  dimension(3) pure function operator_cross_i8b (A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in), dimension(:) :: A integer(kind=I8B), intent(in), dimension(:) :: B Return Value integer(kind=I8B),\n  dimension(3) pure function operator_cross_el_sp (A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:,:) :: A real(kind=SP), intent(in), dimension(:,:) :: B Return Value real(kind=SP),\n  dimension(:,:), allocatable pure function operator_cross_el_dp (A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A real(kind=DP), intent(in), dimension(:,:) :: B Return Value real(kind=DP),\n  dimension(:,:), allocatable pure function operator_cross_el_qp (A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A real(kind=QP), intent(in), dimension(:,:) :: B Return Value real(kind=QP),\n  dimension(:,:), allocatable pure function operator_cross_el_i1b (A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in), dimension(:,:) :: A integer(kind=I1B), intent(in), dimension(:,:) :: B Return Value integer(kind=I1B),\n  dimension(:,:), allocatable pure function operator_cross_el_i2b (A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in), dimension(:,:) :: A integer(kind=I2B), intent(in), dimension(:,:) :: B Return Value integer(kind=I2B),\n  dimension(:,:), allocatable pure function operator_cross_el_i4b (A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:,:) :: A integer(kind=I4B), intent(in), dimension(:,:) :: B Return Value integer(kind=I4B),\n  dimension(:,:), allocatable pure function operator_cross_el_i8b (A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in), dimension(:,:) :: A integer(kind=I8B), intent(in), dimension(:,:) :: B Return Value integer(kind=I8B),\n  dimension(:,:), allocatable","tags":"","loc":"module/s_operator_cross.html"},{"title":"s_operator_mag – swiftest","text":"Contains implementations for the .mag. operator for all defined real types\n Single vector implementations:  B   = .mag. A(1:3)\n Vector list implementations:   B(:) = .mag. A(1:3, :) Uses Ancestors: swiftest_operators module~~s_operator_mag~~UsesGraph module~s_operator_mag s_operator_mag module~swiftest_operators swiftest_operators module~s_operator_mag->module~swiftest_operators module~swiftest_globals swiftest_globals module~swiftest_operators->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Functions operator_mag_sp operator_mag_dp operator_mag_el_sp operator_mag_el_dp operator_mag_el_qp Module Functions pure function operator_mag_sp (A) result(B) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: A Return Value real(kind=SP) pure function operator_mag_dp (A) result(B) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: A Return Value real(kind=DP) pure function operator_mag_el_sp (A) result(B) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:,:) :: A Return Value real(kind=SP),\n  dimension(:), allocatable pure function operator_mag_el_dp (A) result(B) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A Return Value real(kind=DP),\n  dimension(:), allocatable pure function operator_mag_el_qp (A) result(B) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A Return Value real(kind=QP),\n  dimension(:), allocatable","tags":"","loc":"module/s_operator_mag.html"},{"title":"s_util_solve – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_solve~~UsesGraph module~s_util_solve s_util_solve module~swiftest swiftest module~s_util_solve->module~swiftest module~swiftest_classes swiftest_classes module~s_util_solve->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions solve_wbs ge_wpp Module Functions util_solve_linear_system_d util_solve_linear_system_q util_solve_rkf45 Functions function solve_wbs (u) result(x) Based on code available on Rosetta Code: https://rosettacode.org/wiki/Gaussian_elimination#Fortran Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:), allocatable :: u Return Value real(kind=QP),\n  dimension(:), allocatable function ge_wpp (A, b) result(u) Solve  Ax=b  using Gaussian elimination then backwards substitution.\n   A being an n by n matrix.\n   x and b are n by 1 vectors. \n Based on code available on Rosetta Code: https://rosettacode.org/wiki/Gaussian_elimination#Fortran Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A real(kind=QP), intent(in), dimension(:) :: b Return Value real(kind=QP),\n  dimension(:,:), allocatable Module Functions function util_solve_linear_system_d (A, b, n, lerr) result(x) Author David A. Minton Solves the linear equation of the form A*x = b for x. \n   A is an (n,n) arrays\n   x and b are (n) arrays\n Uses Gaussian elimination, so will have issues if system is ill-conditioned.\n Uses quad precision intermidiate values, so works best on small arrays. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A real(kind=DP), intent(in), dimension(:) :: b integer(kind=I4B), intent(in) :: n logical, intent(out) :: lerr Return Value real(kind=DP),\n  dimension(n) function util_solve_linear_system_q (A, b, n, lerr) result(x) Author David A. Minton Solves the linear equation of the form A*x = b for x. \n   A is an (n,n) arrays\n   x and b are (n) arrays\n Uses Gaussian elimination, so will have issues if system is ill-conditioned.\n Uses quad precision intermidiate values, so works best on small arrays. Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A real(kind=QP), intent(in), dimension(:) :: b integer(kind=I4B), intent(in) :: n logical, intent(out) :: lerr Return Value real(kind=QP),\n  dimension(n) module function util_solve_rkf45 (f, y0in, t1, dt0, tol) result(y1) Interface → Author David A. Minton Implements the 4th order Runge-Kutta-Fehlberg ODE solver for initial value problems of the form f=dy/dt, y0 = y(t=0), solving for y1 = y(t=t1). Uses a 5th order adaptive step size control.\n Uses a lambda function object as defined in the lambda_function module Arguments Type Intent Optional Attributes Name class(lambda_obj), intent(inout) :: f lambda function object that has been initialized to be a function of derivatives. The object will return with components lastarg and lasteval set real(kind=DP), intent(in), dimension(:) :: y0in Initial value at t=0 real(kind=DP), intent(in) :: t1 Final time real(kind=DP), intent(in) :: dt0 Initial step size guess real(kind=DP), intent(in) :: tol Tolerance on solution Return Value real(kind=DP),\n  dimension(:), allocatable Final result","tags":"","loc":"module/s_util_solve.html"},{"title":"s_util_set – swiftest","text":"This submodule contains a collection of setter method implementations Uses swiftest Ancestors: swiftest_classes module~~s_util_set~~UsesGraph module~s_util_set s_util_set module~swiftest swiftest module~s_util_set->module~swiftest module~swiftest_classes swiftest_classes module~s_util_set->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_set_beg_end_pl util_set_ir3h util_set_msys util_set_mu_pl util_set_mu_tp util_set_rhill util_set_rhill_approximate Module Subroutines module subroutine util_set_beg_end_pl (self, xbeg, xend, vbeg) Interface → Author David A. Minton Sets one or more of the values of xbeg, xend, and vbeg Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object real(kind=DP), intent(in), optional dimension(:,:) :: xbeg real(kind=DP), intent(in), optional dimension(:,:) :: xend real(kind=DP), intent(in), optional dimension(:,:) :: vbeg module subroutine util_set_ir3h (self) Interface → Author David A. Minton Sets the inverse heliocentric radius term (1/rh**3) for all bodies in a structure Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object module subroutine util_set_msys (self) Interface → Author David A. Minton Sets the value of msys and the vector mass quantities based on the total mass of the system Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nobdy system object module subroutine util_set_mu_pl (self, cb) Interface → Author David A. Minton Computes G * (M + m) for each massive body Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object module subroutine util_set_mu_tp (self, cb) Interface → Author David A. Minton Converts certain scalar values to arrays so that they can be used in elemental functions Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object module subroutine util_set_rhill (self, cb) Interface → Author David A. Minton Sets the value of the Hill's radius Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object module subroutine util_set_rhill_approximate (self, cb) Interface → Author David A. Minton Sets the approximate value of the Hill's radius using the heliocentric radius instead of computing the semimajor axis Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"module/s_util_set.html"},{"title":"s_util_peri – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_peri~~UsesGraph module~s_util_peri s_util_peri module~swiftest swiftest module~s_util_peri->module~swiftest module~swiftest_classes swiftest_classes module~s_util_peri->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_peri_tp Module Subroutines module subroutine util_peri_tp (self, system, param) Interface → Author David A. Minton Determine system pericenter passages for test particles\n Note:  If the coordinate system used is barycentric, then this routine assumes that the barycentric coordinates in the\n        test particle structures are up-to-date and are not recomputed Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"module/s_util_peri.html"},{"title":"s_util_coord – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_coord~~UsesGraph module~s_util_coord s_util_coord module~swiftest swiftest module~s_util_coord->module~swiftest module~swiftest_classes swiftest_classes module~s_util_coord->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_coord_h2b_pl util_coord_h2b_tp util_coord_b2h_pl util_coord_b2h_tp Module Subroutines module subroutine util_coord_h2b_pl (self, cb) Interface → Author David A. Minton Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) Read more… Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object module subroutine util_coord_h2b_tp (self, cb) Interface → Author David A. Minton Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object module subroutine util_coord_b2h_pl (self, cb) Interface → Author David A. Minton Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) Read more… Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object module subroutine util_coord_b2h_tp (self, cb) Interface → Author David A. Minton Convert test particles from barycentric to heliocentric coordinates (position and velocity) Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(in) :: cb Swiftest central body object","tags":"","loc":"module/s_util_coord.html"},{"title":"s_util_rescale – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_rescale~~UsesGraph module~s_util_rescale s_util_rescale module~swiftest swiftest module~s_util_rescale->module~swiftest module~swiftest_classes swiftest_classes module~s_util_rescale->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_rescale_system Module Subroutines module subroutine util_rescale_system (self, param, mscale, dscale, tscale) Interface → Author David A. Minton Rescales an nbody system to a new set of units. Inputs are the multipliers on the mass (mscale), distance (dscale), and time units (tscale). \n Rescales all united quantities in the system, as well as the mass conversion factors, gravitational constant, and Einstein's constant in the parameter object. Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters. Returns with new values of the scale vactors and GU real(kind=DP), intent(in) :: mscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: dscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: tscale Scale factors for mass, distance, and time units, respectively.","tags":"","loc":"module/s_util_rescale.html"},{"title":"s_util_version – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_version~~UsesGraph module~s_util_version s_util_version module~swiftest swiftest module~s_util_version->module~swiftest module~swiftest_classes swiftest_classes module~s_util_version->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_version Module Subroutines module subroutine util_version () Interface → Author David A. Minton Print program version information to terminale Read more… Arguments None","tags":"","loc":"module/s_util_version.html"},{"title":"s_util_sort – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_sort~~UsesGraph module~s_util_sort s_util_sort module~swiftest swiftest module~s_util_sort->module~swiftest module~swiftest_classes swiftest_classes module~s_util_sort->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_sort_body util_sort_pl util_sort_tp util_sort_rearrange_body util_sort_rearrange_pl util_sort_rearrange_tp util_sort_dp util_sort_index_dp util_sort_i4b util_sort_index_i4b util_sort_sp util_sort_index_sp Module Subroutines module subroutine util_sort_body (self, sortby, ascending) Interface → Author David A. Minton Sort a Swiftest body structure in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order module subroutine util_sort_pl (self, sortby, ascending) Interface → Author David A. Minton Sort a Swiftest massive body object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order module subroutine util_sort_tp (self, sortby, ascending) Interface → Author David A. Minton Sort a Swiftest test particle object  in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order module subroutine util_sort_rearrange_body (self, ind) Interface → Author David A. Minton Rearrange Swiftest body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) module subroutine util_sort_rearrange_pl (self, ind) Interface → Author David A. Minton Rearrange Swiftest massive body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) module subroutine util_sort_rearrange_tp (self, ind) Interface → Author David A. Minton Rearrange Swiftest massive body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) subroutine util_sort_dp (arr) Author David A. Minton Sort input double precision array in place into ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:) :: arr subroutine util_sort_index_dp (arr, ind) Author David A. Minton Sort input double precision array by index in ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind subroutine util_sort_i4b (arr) Author David A. Minton Sort input integer array in place into ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:) :: arr subroutine util_sort_index_i4b (arr, ind) Author David A. Minton Sort input integer array by index in ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind subroutine util_sort_sp (arr) Author David A. Minton Sort input single precision array in place into ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), dimension(:) :: arr subroutine util_sort_index_sp (arr, ind) Author David A. Minton Sort input single precision array by index in ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind","tags":"","loc":"module/s_util_sort.html"},{"title":"s_util_spill – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_spill~~UsesGraph module~s_util_spill s_util_spill module~swiftest swiftest module~s_util_spill->module~swiftest module~swiftest_classes swiftest_classes module~s_util_spill->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_spill_arr_char_string util_spill_arr_DP util_spill_arr_DPvec util_spill_arr_I4B util_spill_arr_logical util_spill_body util_spill_encounter util_spill_pl util_spill_tp Module Subroutines subroutine util_spill_arr_char_string (keeps, discards, lspill_list, ldestructive) Author David A. Minton Performs a spill operation on a single array of type character strings\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: keeps Array of values to keep character(len=STRMAX), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not subroutine util_spill_arr_DP (keeps, discards, lspill_list, ldestructive) Author David A. Minton Performs a spill operation on a single array of type DP\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: keeps Array of values to keep real(kind=DP), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not subroutine util_spill_arr_DPvec (keeps, discards, lspill_list, ldestructive) Author David A. Minton Performs a spill operation on a single array of DP vectors with shape (NDIM, n)\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: keeps Array of values to keep real(kind=DP), intent(inout), dimension(:,:), allocatable :: discards Array discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not subroutine util_spill_arr_I4B (keeps, discards, lspill_list, ldestructive) Author David A. Minton Performs a spill operation on a single array of type I4B\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: keeps Array of values to keep integer(kind=I4B), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not subroutine util_spill_arr_logical (keeps, discards, lspill_list, ldestructive) Author David A. Minton Performs a spill operation on a single array of logicals\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: keeps Array of values to keep logical, intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or no module subroutine util_spill_body (self, discards, lspill_list, ldestructive) Interface → Author David A. Minton Move spilled (discarded) Swiftest generic particle structure from active list to discard list\n Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90\n Spill all the common components Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list module subroutine util_spill_encounter (self, discards, lspill_list, ldestructive) Interface → Author David A. Minton Move spilled (discarded) Swiftest encounter structure from active list to discard list Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list module subroutine util_spill_pl (self, discards, lspill_list, ldestructive) Interface → Author David A. Minton Move spilled (discarded) Swiftest massive body structure from active list to discard list\n Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90\n Spill components specific to the massive body class Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list module subroutine util_spill_tp (self, discards, lspill_list, ldestructive) Interface → Author David A. Minton Move spilled (discarded) Swiftest test particle structure from active list to discard list\n Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90\n Spill components specific to the test particle class Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardse logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list","tags":"","loc":"module/s_util_spill.html"},{"title":"s_util_valid – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_valid~~UsesGraph module~s_util_valid s_util_valid module~swiftest swiftest module~s_util_valid->module~swiftest module~swiftest_classes swiftest_classes module~s_util_valid->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_valid_id_system Module Subroutines module subroutine util_valid_id_system (self, param) Interface → Author David A. Minton Validate massive body and test particle ids\n Subroutine causes program to exit with error if any ids are not unique Read more… Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"module/s_util_valid.html"},{"title":"s_util_exit – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_exit~~UsesGraph module~s_util_exit s_util_exit module~swiftest swiftest module~s_util_exit->module~swiftest module~swiftest_classes swiftest_classes module~s_util_exit->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_exit Module Subroutines module subroutine util_exit (code) Interface → Author David A. Minton Print termination message and exit program Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: code","tags":"","loc":"module/s_util_exit.html"},{"title":"s_util_fill – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_fill~~UsesGraph module~s_util_fill s_util_fill module~swiftest swiftest module~s_util_fill->module~swiftest module~swiftest_classes swiftest_classes module~s_util_fill->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_fill_arr_char_string util_fill_arr_DP util_fill_arr_DPvec util_fill_arr_I4B util_fill_arr_logical util_fill_body util_fill_pl util_fill_tp Module Subroutines subroutine util_fill_arr_char_string (keeps, inserts, lfill_list) Author David A. Minton Performs a fill operation on a single array of type character strings\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: keeps Array of values to keep character(len=STRMAX), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps subroutine util_fill_arr_DP (keeps, inserts, lfill_list) Author David A. Minton Performs a fill operation on a single array of type DP\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: keeps Array of values to keep real(kind=DP), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps subroutine util_fill_arr_DPvec (keeps, inserts, lfill_list) Author David A. Minton Performs a fill operation on a single array of DP vectors with shape (NDIM, n)\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: keeps Array of values to keep real(kind=DP), intent(in), dimension(:,:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps subroutine util_fill_arr_I4B (keeps, inserts, lfill_list) Author David A. Minton Performs a fill operation on a single array of type I4B\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: keeps Array of values to keep integer(kind=I4B), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps subroutine util_fill_arr_logical (keeps, inserts, lfill_list) Author David A. Minton Performs a fill operation on a single array of logicals\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: keeps Array of values to keep logical, intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps module subroutine util_fill_body (self, inserts, lfill_list) Interface → Author David A. Minton Insert new Swiftest generic particle structure into an old one. \n This is the inverse of a spill operation.\n Fill all the common components Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_body ), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps module subroutine util_fill_pl (self, inserts, lfill_list) Interface → Author David A. Minton Insert new Swiftest massive body structure into an old one. \n This is the inverse of a spill operation.\n Fill components specific to the massive body class Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps module subroutine util_fill_tp (self, inserts, lfill_list) Interface → Author David A. Minton Insert new Swiftest test particle structure into an old one. \n This is the inverse of a fill operation.\n Spill components specific to the test particle class Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"module/s_util_fill.html"},{"title":"s_util_resize – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_resize~~UsesGraph module~s_util_resize s_util_resize module~swiftest swiftest module~s_util_resize->module~swiftest module~swiftest_classes swiftest_classes module~s_util_resize->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_resize_arr_char_string util_resize_arr_DP util_resize_arr_DPvec util_resize_arr_I4B util_resize_arr_logical util_resize_body util_resize_encounter util_resize_pl util_resize_tp Module Subroutines subroutine util_resize_arr_char_string (arr, nnew) Author David A. Minton Resizes an array component of type character string. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size subroutine util_resize_arr_DP (arr, nnew) Author David A. Minton Resizes an array component of double precision type. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size subroutine util_resize_arr_DPvec (arr, nnew) Author David A. Minton Resizes an array component of double precision vectors of size (NDIM, n). Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size subroutine util_resize_arr_I4B (arr, nnew) Author David A. Minton Resizes an array component of integer type. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size subroutine util_resize_arr_logical (arr, nnew) Author David A. Minton Resizes an array component of logical type. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size module subroutine util_resize_body (self, nnew) Interface → Author David A. Minton Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in) :: nnew New size neded module subroutine util_resize_encounter (self, nnew) Interface → Author David A. Minton Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small.\n Note: The reason to extend it by a factor of 2 is for performance. When there are many enounters per step, resizing every time you want to add an \n encounter takes significant computational effort. Resizing by a factor of 2 is a tradeoff between performance (fewer resize calls) and memory managment\n Memory usage grows by a factor of 2 each time it fills up, but no more. Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list integer(kind=I4B), intent(in) :: nnew New size of list needed module subroutine util_resize_pl (self, nnew) Interface → Author David A. Minton Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: nnew New size neded module subroutine util_resize_tp (self, nnew) Interface → Author David A. Minton Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: nnew New size neded","tags":"","loc":"module/s_util_resize.html"},{"title":"s_util_copy – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_copy~~UsesGraph module~s_util_copy s_util_copy module~swiftest swiftest module~s_util_copy->module~swiftest module~swiftest_classes swiftest_classes module~s_util_copy->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_copy_encounter Module Subroutines module subroutine util_copy_encounter (self, source) Interface → Author David A. Minton Copies elements from the source encounter list into self. Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Encounter list class( swiftest_encounter ), intent(in) :: source Source object to copy into","tags":"","loc":"module/s_util_copy.html"},{"title":"s_util_minimize_bfgs – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_minimize_bfgs~~UsesGraph module~s_util_minimize_bfgs s_util_minimize_bfgs module~swiftest swiftest module~s_util_minimize_bfgs->module~swiftest module~swiftest_classes swiftest_classes module~s_util_minimize_bfgs->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Functions util_minimize_bfgs Module Functions module function util_minimize_bfgs (f, N, x0, eps, lerr) result(x1) Interface → Author David A. Minton This function implements the Broyden-Fletcher-Goldfarb-Shanno method to determine the minimum of a function of N variables. It recieves as input:\n   f%eval(x) : lambda function object containing the objective function as the eval metho\n   N    :  Number of variables of function f\n   x0   :  Initial starting value of x\n   eps  :  Accuracy of 1 - dimensional minimization at each step\n The outputs include\n   lerr :  Returns .true. if it could not find the minimum\n Returns\n   x1   :  Final minimum (all 0 if none found)\n   0 = No miniumum found Read more… Arguments Type Intent Optional Attributes Name class(lambda_obj), intent(inout) :: f integer(kind=I4B), intent(in) :: N real(kind=DP), intent(in), dimension(:) :: x0 real(kind=DP), intent(in) :: eps logical, intent(out) :: lerr Return Value real(kind=DP),\n  dimension(:), allocatable","tags":"","loc":"module/s_util_minimize_bfgs.html"},{"title":"s_util_append – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_append~~UsesGraph module~s_util_append s_util_append module~swiftest swiftest module~s_util_append->module~swiftest module~swiftest_classes swiftest_classes module~s_util_append->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_append_arr_char_string util_append_arr_DP util_append_arr_DPvec util_append_arr_I4B util_append_arr_logical util_append_body util_append_pl util_append_tp Module Subroutines subroutine util_append_arr_char_string (arr, source, nold, nsrc, lsource_mask) Author David A. Minton Append a single array of character string type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: arr Destination array character(len=STRMAX), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to subroutine util_append_arr_DP (arr, source, nold, nsrc, lsource_mask) Author David A. Minton Append a single array of double precision type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: arr Destination array real(kind=DP), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to subroutine util_append_arr_DPvec (arr, source, nold, nsrc, lsource_mask) Author David A. Minton Append a single array of double precision vector type of size (NDIM, n) onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: arr Destination array real(kind=DP), intent(in), dimension(:,:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to subroutine util_append_arr_I4B (arr, source, nold, nsrc, lsource_mask) Author David A. Minton Append a single array of integer(I4B) onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to subroutine util_append_arr_logical (arr, source, nold, nsrc, lsource_mask) Author David A. Minton Append a single array of logical type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: arr Destination array logical, intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to module subroutine util_append_body (self, source, lsource_mask) Interface → Author David A. Minton Append components from one Swiftest body object to another. \n This method will automatically resize the destination body if it is too small Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to module subroutine util_append_pl (self, source, lsource_mask) Interface → Author David A. Minton Append components from one Swiftest body object to another. \n This method will automatically resize the destination body if it is too small Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to module subroutine util_append_tp (self, source, lsource_mask) Interface → Author David A. Minton Append components from one Swiftest body object to another. \n This method will automatically resize the destination body if it is too small Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"module/s_util_append.html"},{"title":"s_util_get_energy_momentum – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_get_energy_momentum~~UsesGraph module~s_util_get_energy_momentum s_util_get_energy_momentum module~swiftest swiftest module~s_util_get_energy_momentum->module~swiftest module~swiftest_classes swiftest_classes module~s_util_get_energy_momentum->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_get_energy_momentum_system Module Subroutines module subroutine util_get_energy_momentum_system (self, param) Interface → Author David A. Minton Compute total system angular momentum vector and kinetic, potential and total system energy Read more… Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"module/s_util_get_energy_momentum.html"},{"title":"s_gr – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_gr~~UsesGraph module~s_gr s_gr module~swiftest swiftest module~s_gr->module~swiftest module~swiftest_classes swiftest_classes module~s_gr->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines gr_kick_getaccb_ns_body gr_kick_getacch gr_p4_pos_kick gr_pseudovel2vel gr_pv2vh_body gr_vel2pseudovel gr_vh2pv_body Module Subroutines pure module subroutine gr_kick_getaccb_ns_body (self, system, param) Interface → Author David A. Minton Add relativistic correction acceleration for non-symplectic integrators.\n Based on Quinn et al. (1991) eq. 5 Read more… Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters module subroutine gr_kick_getacch (mu, x, lmask, n, inv_c2, agr) Interface → Author David A. Minton Compute relativisitic accelerations of massive bodies\n    Based on Saha & Tremaine (1994) Eq. 28 Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:,:) :: x Position vectors logical, intent(in), dimension(:) :: lmask Logical mask indicating which bodies to compute integer(kind=I4B), intent(in) :: n Total number of bodies real(kind=DP), intent(in) :: inv_c2 Inverse speed of light squared: 1 / c**2 real(kind=DP), intent(out), dimension(:,:) :: agr Accelerations pure module subroutine gr_p4_pos_kick (param, x, v, dt) Interface → Author David A. Minton Position kick due to p**4 term in the post-Newtonian correction\n    Based on Saha & Tremaine (1994) Eq. 28 Read more… Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(inout), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(in) :: dt Step size pure module subroutine gr_pseudovel2vel (param, mu, xh, pv, vh) Interface → Author David A. Minton Converts the relativistic pseudovelocity back into a veliocentric velocity\n    Based on Saha & Tremaine (1994) Eq. 32 Read more… Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real(kind=DP), intent(in), dimension(:) :: xh Heliocentric position vector real(kind=DP), intent(in), dimension(:) :: pv Pseudovelocity velocity vector - see Saha & Tremain (1994), eq. (32) real(kind=DP), intent(out), dimension(:) :: vh Heliocentric velocity vector pure module subroutine gr_pv2vh_body (self, param) Interface → Author David A. Minton Wrapper function that converts from pseudovelocity to heliocentric velocity for swiftest bodies Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters pure module subroutine gr_vel2pseudovel (param, mu, xh, vh, pv) Interface → Author David A. Minton Converts the heliocentric velocity into a pseudovelocity with relativistic corrections. \n Uses Newton-Raphson method with direct inversion of the Jacobian (yeah, it's slow, but \n this is only done once per run). Read more… Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real(kind=DP), intent(in), dimension(:) :: xh Heliocentric position vector real(kind=DP), intent(in), dimension(:) :: vh Heliocentric velocity vector real(kind=DP), intent(out), dimension(:) :: pv Pseudovelocity vector - see Saha & Tremain (1994), eq. (32) pure module subroutine gr_vh2pv_body (self, param) Interface → Author David A. Minton Wrapper function that converts from heliocentric velocity to pseudovelocity for Swiftest bodies Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"module/s_gr.html"},{"title":"s_discard – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_discard~~UsesGraph module~s_discard s_discard module~swiftest swiftest module~s_discard->module~swiftest module~swiftest_classes swiftest_classes module~s_discard->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines discard_cb_tp discard_peri_tp discard_pl_tp discard_pl_close Module Subroutines discard_system discard_pl discard_tp Subroutines subroutine discard_cb_tp (tp, system, param) Author David A. Minton Check to see if test particles should be discarded based on their positions relative to the Sun\n        or because they are unbound from the system Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: tp Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters subroutine discard_peri_tp (tp, system, param) Author David A. Minton Check to see if a test particle should be discarded because its perihelion distance becomes too small Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: tp Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameterss subroutine discard_pl_tp (tp, system, param) Author David A. Minton Check to see if test particles should be discarded based on their positions relative to the massive bodies Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: tp Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters subroutine discard_pl_close (dx, dv, dt, r2crit, iflag, r2min) Author David A. Minton Check to see if a test particle and massive body are having, or will have within the next time step, an encounter such\n          that the separation distance r is less than some critical radius rcrit (or r 2 < rcrit 2 = r2crit) Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: dx real(kind=DP), intent(in), dimension(:) :: dv real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r2crit integer(kind=I4B), intent(out) :: iflag real(kind=DP), intent(out) :: r2min Module Subroutines module subroutine discard_system (self, param) Interface → Author David A. Minton Calls the discard methods for each body class and then the write method if any discards were detected Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters module subroutine discard_pl (self, system, param) Interface → Author David A. Minton Placeholder method for discarding massive bodies. This method does nothing except to ensure that the discard flag is set to false. \n  This method is intended to be overridden by more advanced integrators. Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameter module subroutine discard_tp (self, system, param) Interface → Author David A. Minton Check to see if particles should be discarded based on their positions relative to the massive bodies Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameter","tags":"","loc":"module/s_discard.html"},{"title":"s_helio_step – swiftest","text":"Uses swiftest Ancestors: helio_classes module~~s_helio_step~~UsesGraph module~s_helio_step s_helio_step module~swiftest swiftest module~s_helio_step->module~swiftest module~helio_classes helio_classes module~s_helio_step->module~helio_classes module~swiftest->module~helio_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~whm_classes whm_classes module~swiftest->module~whm_classes module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~swiftest_operators->module~swiftest_globals module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines helio_step_system helio_step_pl helio_step_tp Module Subroutines module subroutine helio_step_system (self, param, t, dt) Interface → Author David A. Minton Step massive bodies and and active test particles ahead in heliocentric coordinates. Read more… Arguments Type Intent Optional Attributes Name class( helio_nbody_system ), intent(inout) :: self Helio nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize module subroutine helio_step_pl (self, system, param, t, dt) Interface → Author David A. Minton Step massive bodies ahead Democratic Heliocentric method Read more… Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nboody system class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize module subroutine helio_step_tp (self, system, param, t, dt) Interface → Author David A. Minton Step active test particles ahead using Democratic Heliocentric method Read more… Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nboody system class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"module/s_helio_step.html"},{"title":"s_helio_gr – swiftest","text":"Uses swiftest Ancestors: helio_classes module~~s_helio_gr~~UsesGraph module~s_helio_gr s_helio_gr module~swiftest swiftest module~s_helio_gr->module~swiftest module~helio_classes helio_classes module~s_helio_gr->module~helio_classes module~swiftest->module~helio_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~whm_classes whm_classes module~swiftest->module~whm_classes module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~swiftest_operators->module~swiftest_globals module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines helio_gr_kick_getacch_pl helio_gr_kick_getacch_tp helio_gr_p4_pl helio_gr_p4_tp Module Subroutines module subroutine helio_gr_kick_getacch_pl (self, param) Interface → Author David A. Minton Compute relativisitic accelerations of massive bodies\n    Based on Saha & Tremaine (1994) Eq. 28 Read more… Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters module subroutine helio_gr_kick_getacch_tp (self, param) Interface → Author David A. Minton Compute relativisitic accelerations of test particles\n    Based on Saha & Tremaine (1994) Eq. 28 Read more… Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters pure module subroutine helio_gr_p4_pl (self, param, dt) Interface → Author David A. Minton Position kick to massive bodies due to p**4 term in the post-Newtonian correction\n    Based on Saha & Tremaine (1994) Eq. 28 Read more… Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size pure module subroutine helio_gr_p4_tp (self, param, dt) Interface → Author David A. Minton Position kick to test particles due to p**4 term in the post-Newtonian correction\n    Based on Saha & Tremaine (1994) Eq. 28 Read more… Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size","tags":"","loc":"module/s_helio_gr.html"},{"title":"s_helio_kick – swiftest","text":"Uses swiftest Ancestors: helio_classes module~~s_helio_kick~~UsesGraph module~s_helio_kick s_helio_kick module~swiftest swiftest module~s_helio_kick->module~swiftest module~helio_classes helio_classes module~s_helio_kick->module~helio_classes module~swiftest->module~helio_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~whm_classes whm_classes module~swiftest->module~whm_classes module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~swiftest_operators->module~swiftest_globals module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines helio_kick_getacch_pl helio_kick_getacch_tp helio_kick_vb_pl helio_kick_vb_tp Module Subroutines module subroutine helio_kick_getacch_pl (self, system, param, t, lbeg) Interface → Author David A. Minton Compute heliocentric accelerations of massive bodies Read more… Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step module subroutine helio_kick_getacch_tp (self, system, param, t, lbeg) Interface → Author David A. Minton Compute heliocentric accelerations of test particles Read more… Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step module subroutine helio_kick_vb_pl (self, system, param, t, dt, lbeg) Interface → Author David A. Minton Kick barycentric velocities of bodies Read more… Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. module subroutine helio_kick_vb_tp (self, system, param, t, dt, lbeg) Interface → Author David A. Minton Kick barycentric velocities of bodies Read more… Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not.","tags":"","loc":"module/s_helio_kick.html"},{"title":"s_helio_coord – swiftest","text":"Uses swiftest Ancestors: helio_classes module~~s_helio_coord~~UsesGraph module~s_helio_coord s_helio_coord module~swiftest swiftest module~s_helio_coord->module~swiftest module~helio_classes helio_classes module~s_helio_coord->module~helio_classes module~swiftest->module~helio_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~whm_classes whm_classes module~swiftest->module~whm_classes module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~swiftest_operators->module~swiftest_globals module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines helio_coord_vb2vh_pl helio_coord_vb2vh_tp helio_coord_vh2vb_pl helio_coord_vh2vb_tp Module Subroutines module subroutine helio_coord_vb2vh_pl (self, cb) Interface → Author David A. Minton Convert massive bodies from barycentric to heliocentric coordinates (velocity only) Read more… Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object module subroutine helio_coord_vb2vh_tp (self, vbcb) Interface → Author David A. Minton Convert test particles from barycentric to heliocentric coordinates (velocity only) Read more… Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body module subroutine helio_coord_vh2vb_pl (self, cb) Interface → Author David A. Minton Convert massive bodies from heliocentric to barycentric coordinates (velocity only) Read more… Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object module subroutine helio_coord_vh2vb_tp (self, vbcb) Interface → Author David A. Minton Convert test particles from heliocentric to barycentric coordinates (velocity only) Read more… Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body","tags":"","loc":"module/s_helio_coord.html"},{"title":"s_helio_drift – swiftest","text":"Uses swiftest Ancestors: helio_classes module~~s_helio_drift~~UsesGraph module~s_helio_drift s_helio_drift module~swiftest swiftest module~s_helio_drift->module~swiftest module~helio_classes helio_classes module~s_helio_drift->module~helio_classes module~swiftest->module~helio_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~whm_classes whm_classes module~swiftest->module~whm_classes module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~swiftest_operators->module~swiftest_globals module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines helio_drift_body helio_drift_pl helio_drift_tp helio_drift_linear_pl helio_drift_linear_tp Module Subroutines module subroutine helio_drift_body (self, system, param, dt) Interface → Author David A. Minton Loop through bodies and call Danby drift routine on democratic heliocentric coordinates Read more… Arguments Type Intent Optional Attributes Name class(swiftest_body), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize module subroutine helio_drift_pl (self, system, param, dt) Interface → Author David A. Minton Wrapper function used to call the body drift routine from a helio_pl structure Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize module subroutine helio_drift_tp (self, system, param, dt) Interface → Author David A. Minton Wrapper function used to call the body drift routine from a helio_pl structure Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize module subroutine helio_drift_linear_pl (self, cb, dt, lbeg) Interface → Author David A. Minton Perform linear drift of massive bodies due to barycentric momentum of Sun Read more… Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( helio_cb ), intent(inout) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step module subroutine helio_drift_linear_tp (self, cb, dt, lbeg) Interface → Author David A. Minton Perform linear drift of test particles due to barycentric momentum of Sun\n New vectorized version included Read more… Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particleb object class( helio_cb ), intent(in) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step","tags":"","loc":"module/s_helio_drift.html"},{"title":"s_io – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_io~~UsesGraph module~s_io s_io module~swiftest swiftest module~s_io->module~swiftest module~swiftest_classes swiftest_classes module~s_io->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions io_read_encounter io_read_hdr Subroutines io_write_hdr Module Functions io_get_args io_get_token Module Subroutines io_conservation_report io_dump_param io_dump_swiftest io_dump_system io_param_reader io_param_writer io_read_body_in io_read_cb_in io_read_frame_body io_read_frame_cb io_read_frame_system io_read_param_in io_toupper io_write_discard io_write_encounter io_write_frame_body io_write_frame_cb io_write_frame_system Functions function io_read_encounter (t, name1, name2, mass1, mass2, radius1, radius2, xh1, xh2, vh1, vh2, enc_out, out_type) result(ierr) Author David A. Minton Read close encounter data from input binary files\n     Other than time t, there is no direct file input from this function\n     Function returns read error status (0 = OK, nonzero = ERROR)\n Adapted from David E. Kaufmann's Swifter routine: io_read_encounter.f90 Arguments Type Intent Optional Attributes Name real(kind=DP), intent(out) :: t integer(kind=I4B), intent(out) :: name1 integer(kind=I4B), intent(out) :: name2 real(kind=DP), intent(out) :: mass1 real(kind=DP), intent(out) :: mass2 real(kind=DP), intent(out) :: radius1 real(kind=DP), intent(out) :: radius2 real(kind=DP), intent(out), dimension(:) :: xh1 real(kind=DP), intent(out), dimension(:) :: xh2 real(kind=DP), intent(out), dimension(:) :: vh1 real(kind=DP), intent(out), dimension(:) :: vh2 character(len=*), intent(in) :: enc_out character(len=*), intent(in) :: out_type Return Value integer(kind=I4B) function io_read_hdr (iu, t, npl, ntp, out_form, out_type) result(ierr) Author David A. Minton Read frame header from input binary files\n     Function returns read error status (0 = OK, nonzero = ERROR)\n Adapted from David E. Kaufmann's Swifter routine: io_read_hdr.f90\n Adapted from Hal Levison's Swift routine io_read_hdr.f Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu real(kind=DP), intent(out) :: t integer(kind=I4B), intent(out) :: npl integer(kind=I4B), intent(out) :: ntp character(len=*), intent(out) :: out_form character(len=*), intent(in) :: out_type Return Value integer(kind=I4B) Subroutines subroutine io_write_hdr (iu, t, npl, ntp, out_form, out_type) Author The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott Write frame header to output binary file Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu Output file unit number real(kind=DP), intent(in) :: t Current time of simulation integer(kind=I4B), intent(in) :: npl Number of massive bodies integer(kind=I4B), intent(in) :: ntp Number of test particles character(len=*), intent(in) :: out_form Output format type (\"EL\" or  \"XV\") character(len=*), intent(in) :: out_type Output file format type (REAL4, REAL8 - see swiftest module for symbolic name definitions) Module Functions module function io_get_args (integrator, param_file_name) result(ierr) Interface → Author David A. Minton Reads in the name of the parameter file from command line arguments. Arguments Type Intent Optional Attributes Name integer(kind=I4B) :: integrator Symbolic code of the requested integrator character(len=:), allocatable :: param_file_name Name of the input parameters file Return Value integer(kind=I4B) I/O error code module function io_get_token (buffer, ifirst, ilast, ierr) result(token) Interface → Author David A. Minton Retrieves a character token from an input string. Here a token is defined as any set of contiguous non-blank characters not \n beginning with or containing \"!\". If \"!\" is present, any remaining part of the buffer including the \"!\" is ignored Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: buffer Input string buffer integer(kind=I4B), intent(inout) :: ifirst Index of the buffer at which to start the search for a token integer(kind=I4B), intent(out) :: ilast Index of the buffer at the end of the returned token integer(kind=I4B), intent(out) :: ierr Error code Return Value character(len=:),\n  allocatable Returned token string Module Subroutines module subroutine io_conservation_report (self, param, lterminal) Interface → Author The Purdue Swiftest Team -  David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott Reports the current state of energy, mass, and angular momentum conservation in a run Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Input colleciton of user-defined parameters logical, intent(in) :: lterminal Indicates whether to output information to the terminal screen module subroutine io_dump_param (self, param_file_name) Interface → Author David A. Minton Dump integration parameters to file Read more… Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Output collection of parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in) module subroutine io_dump_swiftest (self, param) Interface → Author David A. Minton Dump massive body data to files Read more… Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters module subroutine io_dump_system (self, param) Interface → Author David A. Minton Dumps the state of the system to files in case the simulation is interrupted.\n As a safety mechanism, there are two dump files that are written in alternating order\n so that if a dump file gets corrupted during writing, the user can restart from the older one. Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters module subroutine io_param_reader (self, unit, iotype, v_list, iostat, iomsg) Interface → Author The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott Read in parameters for the integration\n Currently this procedure does not work in user-defined derived-type input mode \n    e.g. read(unit,'(DT)') param \n as the newline characters are ignored in the input file when compiled in ifort. Read more… Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Collection of parameters integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) The first element passes the integrator code to the reader integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 module subroutine io_param_writer (self, unit, iotype, v_list, iostat, iomsg) Interface → Author David A. Minton Dump integration parameters to file Read more… Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Collection of parameters integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) Not used in this procedure integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 module subroutine io_read_body_in (self, param) Interface → Author The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott Read in either test particle or massive body data Read more… Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters module subroutine io_read_cb_in (self, param) Interface → Author David A. Minton Reads in central body data Read more… Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self class( swiftest_parameters ), intent(inout) :: param module subroutine io_read_frame_body (self, iu, param, form, ierr) Interface → Author David A. Minton Reads a frame of output of either test particle or massive body data from a binary output file Read more… Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code module subroutine io_read_frame_cb (self, iu, param, form, ierr) Interface → Author David A. Minton Reads a frame of output of central body data to the binary output file Read more… Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error cod module subroutine io_read_frame_system (self, iu, param, form, ierr) Interface → Author The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott Read a frame (header plus records for each massive body and active test particle) from a output binary file Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters character(len=*), intent(in) :: form Input format code (\"XV\" or \"EL\") integer(kind=I4B), intent(out) :: ierr Error code module subroutine io_read_param_in (self, param_file_name) Interface → Author David A. Minton Read in parameters for the integration Read more… Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Current run configuration parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in) module subroutine io_toupper (string) Interface → Author David A. Minton Convert string to uppercase Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string String to make upper case module subroutine io_write_discard (self, param) Interface → Author David A. Minton Write out information about discarded test particle Read more… Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters module subroutine io_write_encounter (t, name1, name2, mass1, mass2, radius1, radius2, xh1, xh2, vh1, vh2, enc_out, out_type) Interface → Author David A. Minton Write close encounter data to output binary files\n  There is no direct file output from this subroutine Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: name1 integer(kind=I4B), intent(in) :: name2 real(kind=DP), intent(in) :: mass1 real(kind=DP), intent(in) :: mass2 real(kind=DP), intent(in) :: radius1 real(kind=DP), intent(in) :: radius2 real(kind=DP), intent(in), dimension(:) :: xh1 real(kind=DP), intent(in), dimension(:) :: xh2 real(kind=DP), intent(in), dimension(:) :: vh1 real(kind=DP), intent(in), dimension(:) :: vh2 character(len=*), intent(in) :: enc_out character(len=*), intent(in) :: out_type module subroutine io_write_frame_body (self, iu, param) Interface → Author David A. Minton Write a frame of output of either test particle or massive body data to the binary output file\n    Note: If outputting to orbital elements, but sure that the conversion is done prior to calling this method Read more… Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest particle object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters module subroutine io_write_frame_cb (self, iu, param) Interface → Author David A. Minton Write a frame of output of central body data to the binary output file Read more… Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters module subroutine io_write_frame_system (self, iu, param) Interface → Author The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott Write a frame (header plus records for each massive body and active test particle) to output binary file\n There is no direct file output from this subroutine Read more… Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"module/s_io.html"},{"title":"s_setup – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_setup~~UsesGraph module~s_setup s_setup module~swiftest swiftest module~s_setup->module~swiftest module~swiftest_classes swiftest_classes module~s_setup->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines setup_construct_system setup_encounter setup_initialize_system setup_body setup_pl setup_tp Module Subroutines module subroutine setup_construct_system (system, param) Interface → Author David A. Minton Constructor for a Swiftest nbody system. Creates the nbody system object based on the user-input integrator Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout), allocatable :: system Swiftest system object class( swiftest_parameters ), intent(in) :: param Swiftest parameters module subroutine setup_encounter (self, n) Interface → Author David A. Minton A constructor that sets the number of encounters and allocates and initializes all arrays Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for module subroutine setup_initialize_system (self, param) Interface → Author David A. Minton Wrapper method to initialize a basic Swiftest nbody system from files Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters module subroutine setup_body (self, n, param) Interface → Author David A. Minton Constructor for base Swiftest particle class. Allocates space for all particles and\n initializes all components with a value.\n Note: Timing tests indicate that (NDIM, n) is more efficient than (NDIM, n) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter module subroutine setup_pl (self, n, param) Interface → Author David A. Minton Constructor for base Swiftest massive body class. Allocates space for all particles and\n initializes all components with a value. \n Call allocation method for parent class\n The parent class here is the abstract swiftest_body class, so we can't use the type-bound procedure Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter module subroutine setup_tp (self, n, param) Interface → Author David A. Minton Constructor for base Swiftest test particle particle class. Allocates space for \n all particles and initializes all components with a value. \n Call allocation method for parent class\n The parent class here is the abstract swiftest_body class, so we can't use the type-bound procedure Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter","tags":"","loc":"module/s_setup.html"},{"title":"s_eucl – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_eucl~~UsesGraph module~s_eucl s_eucl module~swiftest swiftest module~s_eucl->module~swiftest module~swiftest_classes swiftest_classes module~s_eucl->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines eucl_dist_index_plpl Module Subroutines module subroutine eucl_dist_index_plpl (self) Interface → Author Jacob R. Elliott and David A. Minton Turns i,j indices into k index for use in the Euclidean distance matrix Read more… Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body objec","tags":"","loc":"module/s_eucl.html"},{"title":"s_user_kick_getacch – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_user_kick_getacch~~UsesGraph module~s_user_kick_getacch s_user_kick_getacch module~swiftest swiftest module~s_user_kick_getacch->module~swiftest module~swiftest_classes swiftest_classes module~s_user_kick_getacch->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines user_kick_getacch_body Module Subroutines module subroutine user_kick_getacch_body (self, system, param, t, lbeg) Interface → Author David A. Minton Add user-supplied heliocentric accelerations to planets. Read more… Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters user parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the ste","tags":"","loc":"module/s_user_kick_getacch.html"},{"title":"drift_implementation – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~drift_implementation~~UsesGraph module~drift_implementation drift_implementation module~swiftest swiftest module~drift_implementation->module~swiftest module~swiftest_classes swiftest_classes module~drift_implementation->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables E2MAX DM2MAX E2DM2MAX DANBYB NLAG1 NLAG2 Subroutines drift_dan drift_kepmd drift_kepu drift_kepu_fchk drift_kepu_guess drift_kepu_lag drift_kepu_new drift_kepu_p3solve drift_kepu_stumpff Module Subroutines drift_body drift_all drift_one Variables Type Visibility Attributes Name Initial real(kind=DP), private, parameter :: E2MAX = 0.36_DP Integration control parameters: real(kind=DP), private, parameter :: DM2MAX = 0.16_DP real(kind=DP), private, parameter :: E2DM2MAX = 0.0016_DP real(kind=DP), private, parameter :: DANBYB = 1.0E-13_DP integer(kind=I2B), private, parameter :: NLAG1 = 50 integer(kind=I2B), private, parameter :: NLAG2 = 40 Subroutines pure subroutine drift_dan (mu, x0, v0, dt0, iflag) Author David A. Minton Perform Kepler drift, solving Kepler's equation in appropriate variables Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu real(kind=DP), intent(inout), dimension(:) :: x0 real(kind=DP), intent(inout), dimension(:) :: v0 real(kind=DP), intent(in) :: dt0 integer(kind=I4B), intent(out) :: iflag pure subroutine drift_kepmd (dm, es, ec, x, s, c) Author David A. Minton Solve Kepler's equation in difference form for an ellipse for small input dm and eccentricity\n    Original disclaimer: built for speed, does not check how well the original equation is solved\n    Can do that in calling routine by checking how close (x - ec s + es (1.0 - c) - dm) is to zero Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dm real(kind=DP), intent(in) :: es real(kind=DP), intent(in) :: ec real(kind=DP), intent(out) :: x real(kind=DP), intent(out) :: s real(kind=DP), intent(out) :: c pure subroutine drift_kepu (dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Author David A. Minton Solve Kepler's equation in universal variables Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: fp real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 integer(kind=I4B), intent(out) :: iflag pure subroutine drift_kepu_fchk (dt, r0, mu, alpha, u, s, f) Author David A. Minton Computes the value of f, the function whose root we are trying to find in universal variables Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(in) :: s real(kind=DP), intent(out) :: f pure subroutine drift_kepu_guess (dt, r0, mu, alpha, u, s) Author David A. Minton Compute initial guess for solving Kepler's equation using universal variables Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: s pure subroutine drift_kepu_lag (s, dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Author David A. Minton Solve Kepler's equation in universal variables using Laguerre's method\n      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 178 - 180. Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout) :: s real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: fp real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 integer(kind=I4B), intent(out) :: iflag pure subroutine drift_kepu_new (s, dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Author David A. Minton Solve Kepler's equation in universal variables using Newton's method\n      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 174 - 175. Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout) :: s real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: fp real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 integer(kind=I4B), intent(out) :: iflag pure subroutine drift_kepu_p3solve (dt, r0, mu, alpha, u, s, iflag) Author David A. Minton Computes real root of cubic involved in setting initial guess for solving Kepler's equation in universal variables\n      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 177 - 178. Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: s integer(kind=I4B), intent(out) :: iflag pure subroutine drift_kepu_stumpff (x, c0, c1, c2, c3) Author David A. Minton Compute Stumpff functions needed for Kepler drift in universal variables\n      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 171 - 172. Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout) :: x real(kind=DP), intent(out) :: c0 real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 Module Subroutines module subroutine drift_body (self, system, param, dt) Interface → Author David A. Minton Loop bodies and call Danby drift routine on the heliocentric position and velocities. Read more… Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize pure module subroutine drift_all (mu, x, v, n, param, dt, mask, iflag) Interface → Author David A. Minton Loop bodies and call Danby drift routine on all bodies for the given position and velocity vector. Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: mu Vector of gravitational constants real(kind=DP), intent(inout), dimension(:,:) :: x Position and velocity vectors real(kind=DP), intent(inout), dimension(:,:) :: v Position and velocity vectors integer(kind=I4B), intent(in) :: n number of bodies class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize logical, intent(in), dimension(:) :: mask Logical mask of size self%nbody that determines which bodies to drift. integer(kind=I4B), intent(out), dimension(:) :: iflag Vector of error flags. 0 means no problem pure elemental module subroutine drift_one (mu, px, py, pz, vx, vy, vz, dt, iflag) Interface → Author The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott Perform Danby drift for one body, redoing drift with smaller substeps if original accuracy is insufficient Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body to drift real(kind=DP), intent(inout) :: px Position and velocity of body to drift real(kind=DP), intent(inout) :: py Position and velocity of body to drift real(kind=DP), intent(inout) :: pz Position and velocity of body to drift real(kind=DP), intent(inout) :: vx Position and velocity of body to drift real(kind=DP), intent(inout) :: vy Position and velocity of body to drift real(kind=DP), intent(inout) :: vz Position and velocity of body to drift real(kind=DP), intent(in) :: dt Step size integer(kind=I4B), intent(out) :: iflag iflag : error status flag for Danby drift (0 = OK, nonzero = ERROR)","tags":"","loc":"module/drift_implementation.html"},{"title":"s_symba_util – swiftest","text":"Uses swiftest Ancestors: symba_classes module~~s_symba_util~~UsesGraph module~s_symba_util s_symba_util module~swiftest swiftest module~s_symba_util->module~swiftest module~symba_classes symba_classes module~s_symba_util->module~symba_classes module~swiftest->module~symba_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~swiftest_operators->module~swiftest_globals module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines symba_util_append_arr_info symba_util_append_arr_kin symba_util_append_pl symba_util_append_merger symba_util_append_tp symba_util_fill_arr_info symba_util_fill_arr_kin symba_util_fill_pl symba_util_fill_tp symba_util_peri_pl symba_util_rearray_pl symba_util_resize_arr_info symba_util_resize_arr_kin symba_util_resize_merger symba_util_resize_pl symba_util_resize_tp symba_util_sort_pl symba_util_sort_tp symba_util_sort_rearrange_pl symba_util_sort_rearrange_tp symba_util_spill_arr_info symba_util_spill_arr_kin symba_util_spill_pl symba_util_spill_pltpenc symba_util_spill_tp Module Subroutines subroutine symba_util_append_arr_info (arr, source, nold, nsrc, lsource_mask) Author David A. Minton Append a single array of particle information type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name type( symba_particle_info ), intent(inout), dimension(:), allocatable :: arr Destination array type( symba_particle_info ), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to subroutine symba_util_append_arr_kin (arr, source, nold, nsrc, lsource_mask) Author David A. Minton Append a single array of kinship type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: arr Destination array type( symba_kinship ), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to module subroutine symba_util_append_pl (self, source, lsource_mask) Interface → Author David A. Minton Append components from one massive body object to another. \n This method will automatically resize the destination body if it is too small\n Arguments Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to module subroutine symba_util_append_merger (self, source, lsource_mask) Interface → Author David A. Minton Append components from one massive body object to another. \n This method will automatically resize the destination body if it is too small Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to module subroutine symba_util_append_tp (self, source, lsource_mask) Interface → Author David A. Minton Append components from test particle object to another. \n This method will automatically resize the destination body if it is too small\n Arguments Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to subroutine symba_util_fill_arr_info (keeps, inserts, lfill_list) Author David A. Minton Performs a fill operation on a single array of particle origin information types\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name type( symba_particle_info ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_particle_info ), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps subroutine symba_util_fill_arr_kin (keeps, inserts, lfill_list) Author David A. Minton Performs a fill operation on a single array of particle kinship types\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_kinship ), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps module subroutine symba_util_fill_pl (self, inserts, lfill_list) Interface → Author David A. Minton Insert new SyMBA test particle structure into an old one. \n This is the inverse of a fill operation. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA masive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps module subroutine symba_util_fill_tp (self, inserts, lfill_list) Interface → Author David A. Minton Insert new SyMBA test particle structure into an old one. \n This is the inverse of a fill operation. Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps module subroutine symba_util_peri_pl (self, system, param) Interface → Author David A. Minton Determine system pericenter passages for planets in SyMBA Read more… Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters module subroutine symba_util_rearray_pl (self, system, param) Interface → Author the Purdue Swiftest Team -  David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott Clean up the massive body structures to remove discarded bodies and add new bodies Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class( symba_nbody_system ), intent(inout) :: system Swiftest nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters subroutine symba_util_resize_arr_info (arr, nnew) Author David A. Minton Resizes an array component of type character string. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name type( symba_particle_info ), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size subroutine symba_util_resize_arr_kin (arr, nnew) Author David A. Minton Resizes an array component of type character string. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size module subroutine symba_util_resize_merger (self, nnew) Interface → Author David A. Minton Checks the current size of a SyMBA merger list against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: nnew New size neded module subroutine symba_util_resize_pl (self, nnew) Interface → Author David A. Minton Checks the current size of a SyMBA massive body object against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: nnew New size neded module subroutine symba_util_resize_tp (self, nnew) Interface → Author David A. Minton Checks the current size of a test particle object against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object integer(kind=I4B), intent(in) :: nnew New size neded module subroutine symba_util_sort_pl (self, sortby, ascending) Interface → Author David A. Minton Sort a SyMBA massive body object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order module subroutine symba_util_sort_tp (self, sortby, ascending) Interface → Author David A. Minton Sort a SyMBA test particle object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order module subroutine symba_util_sort_rearrange_pl (self, ind) Interface → Author David A. Minton Rearrange SyMBA massive body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) module subroutine symba_util_sort_rearrange_tp (self, ind) Interface → Author David A. Minton Rearrange SyMBA test particle object in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) subroutine symba_util_spill_arr_info (keeps, discards, lspill_list, ldestructive) Author David A. Minton Performs a spill operation on a single array of particle origin information types\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name type( symba_particle_info ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_particle_info ), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not subroutine symba_util_spill_arr_kin (keeps, discards, lspill_list, ldestructive) Author David A. Minton Performs a spill operation on a single array of particle kinships\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_kinship ), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not module subroutine symba_util_spill_pl (self, discards, lspill_list, ldestructive) Interface → Author David A. Minton Move spilled (discarded) SyMBA massive body particle structure from active list to discard list\n Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90\n Spill all the common components Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list module subroutine symba_util_spill_pltpenc (self, discards, lspill_list, ldestructive) Interface → Author David A. Minton Move spilled (discarded) SyMBA encounter structure from active list to discard list\n Note: Because the symba_plplenc currently does not contain any additional variable components, this method can recieve it as an input as well. Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-tp encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list module subroutine symba_util_spill_tp (self, discards, lspill_list, ldestructive) Interface → Author David A. Minton Move spilled (discarded) SyMBA test particle structure from active list to discard list\n Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90\n Spill all the common components Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list","tags":"","loc":"module/s_symba_util.html"},{"title":"s_symba_collision – swiftest","text":"Uses swiftest Ancestors: symba_classes module~~s_symba_collision~~UsesGraph module~s_symba_collision s_symba_collision module~swiftest swiftest module~s_symba_collision->module~swiftest module~symba_classes symba_classes module~s_symba_collision->module~symba_classes module~swiftest->module~symba_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~swiftest_operators->module~swiftest_globals module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions symba_collision_check_one symba_collision_consolidate_familes Module Subroutines symba_collision_check_pltpenc symba_collision_encounter_scrub symba_collision_make_family_pl symba_collision_resolve_fragmentations symba_collision_resolve_mergers Functions pure elemental function symba_collision_check_one (xr, yr, zr, vxr, vyr, vzr, Gmtot, rlim, dt, lvdotr) result(lcollision) Author David A. Minton Check for a merger between a single pair of particles Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: xr Relative position vector components real(kind=DP), intent(in) :: yr Relative position vector components real(kind=DP), intent(in) :: zr Relative position vector components real(kind=DP), intent(in) :: vxr Relative velocity vector components real(kind=DP), intent(in) :: vyr Relative velocity vector components real(kind=DP), intent(in) :: vzr Relative velocity vector components real(kind=DP), intent(in) :: Gmtot Sum of G*mass of colliding bodies real(kind=DP), intent(in) :: rlim Collision limit - Typically the sum of the radii of colliding bodies real(kind=DP), intent(in) :: dt Step size logical, intent(in) :: lvdotr Logical flag indicating that these two bodies are approaching in the current substep Return Value logical Logical flag indicating whether these two bodies will collide or not function symba_collision_consolidate_familes (pl, param, idx_parent, family, x, v, mass, radius, L_spin, Ip) result(lflag) Author David A. Minton Loops through the pl-pl collision list and groups families together by index. Outputs the indices of all family members, \n and pairs of quantities (x and v vectors, mass, radius, L_spin, and Ip) that can be used to resolve the collisional outcome. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl SyMBA massive body object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(inout), dimension(2) :: idx_parent Index of the two bodies considered the \"parents\" of the collision integer(kind=I4B), intent(out), dimension(:), allocatable :: family List of indices of all bodies inovlved in the collision real(kind=DP), intent(out), dimension(NDIM,2) :: x Output values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(out), dimension(NDIM,2) :: v Output values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(out), dimension(2) :: mass Output values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(out), dimension(2) :: radius Output values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(out), dimension(NDIM,2) :: L_spin Output values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(out), dimension(NDIM,2) :: Ip Output values that represent a 2-body equivalent of a possibly 2+ body collision Return Value logical Logical flag indicating whether a family was successfully created or not Module Subroutines module subroutine symba_collision_check_pltpenc (self, system, param, t, dt, irec) Interface → Author David A. Minton Check for merger between massive bodies and test particles in SyMBA Read more… Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t current time real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level module subroutine symba_collision_encounter_scrub (self, system, param) Interface → Author David A. Minton Processes the pl-pl encounter list remove only those encounters that led to a collision Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters module subroutine symba_collision_make_family_pl (self, idx) Interface → Author Jennifer L.L. Pouplin, Carlisle A. wishard, and David A. Minton When a single body is involved in more than one collision in a single step, it becomes part of a family.\n The largest body involved in a multi-body collision is the \"parent\" and all bodies that collide with it are its \"children,\"\n including those that collide with the children. Read more… Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(2) :: idx Array holding the indices of the two bodies involved in the collision module subroutine symba_collision_resolve_fragmentations (self, system, param) Interface → Author David A. Minton Process list of collisions, determine the collisional regime, and then create fragments. Read more… Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions module subroutine symba_collision_resolve_mergers (self, system, param) Interface → Author David A. Minton Process list of collisions and merge colliding bodies together. Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions","tags":"","loc":"module/s_symba_collision.html"},{"title":"s_symba_setup – swiftest","text":"Uses swiftest Ancestors: symba_classes module~~s_symba_setup~~UsesGraph module~s_symba_setup s_symba_setup module~swiftest swiftest module~s_symba_setup->module~swiftest module~symba_classes symba_classes module~s_symba_setup->module~symba_classes module~swiftest->module~symba_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~swiftest_operators->module~swiftest_globals module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines symba_setup_initialize_particle_info symba_setup_initialize_system symba_setup_merger symba_setup_pl symba_setup_pltpenc symba_setup_tp Module Subroutines module subroutine symba_setup_initialize_particle_info (system, param) Interface → Author David A. Minton Initializes a new particle information data structure with initial conditions recorded Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA extensions module subroutine symba_setup_initialize_system (self, param) Interface → Author David A. Minton Initialize an SyMBA nbody system from files and sets up the planetocentric structures.\n This subroutine will also sort the massive bodies in descending order by mass Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters module subroutine symba_setup_merger (self, n, param) Interface → Author David A. Minton Allocate SyMBA test particle structure Read more… Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA merger list object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter module subroutine symba_setup_pl (self, n, param) Interface → Author David A. Minton Allocate SyMBA test particle structure Read more… Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter module subroutine symba_setup_pltpenc (self, n) Interface → Author David A. Minton A constructor that sets the number of encounters and allocates and initializes all arrays Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-tp encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for module subroutine symba_setup_tp (self, n, param) Interface → Author David A. Minton Allocate WHM test particle structure Read more… Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter","tags":"","loc":"module/s_symba_setup.html"},{"title":"s_symba_kick – swiftest","text":"Uses swiftest Ancestors: symba_classes module~~s_symba_kick~~UsesGraph module~s_symba_kick s_symba_kick module~swiftest swiftest module~s_symba_kick->module~swiftest module~symba_classes symba_classes module~s_symba_kick->module~symba_classes module~swiftest->module~symba_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~swiftest_operators->module~swiftest_globals module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines symba_kick_getacch_pl symba_kick_getacch_tp symba_kick_pltpenc Module Subroutines module subroutine symba_kick_getacch_pl (self, system, param, t, lbeg) Interface → Author David A. Minton Compute heliocentric accelerations of massive bodies Read more… Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step module subroutine symba_kick_getacch_tp (self, system, param, t, lbeg) Interface → Author David A. Minton Compute heliocentric accelerations of test particles Read more… Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step module subroutine symba_kick_pltpenc (self, system, dt, irec, sgn) Interface → Author David A. Minton Kick barycentric velocities of massive bodies and ACTIVE test particles within SyMBA recursion.\n Note: This method works for the polymorphic symba_pltpenc and symba_plplenc types Read more… Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(in) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level integer(kind=I4B), intent(in) :: sgn sign to be applied to acceleration","tags":"","loc":"module/s_symba_kick.html"},{"title":"s_symba_fragmentation – swiftest","text":"Uses swiftest Ancestors: symba_classes module~~s_symba_fragmentation~~UsesGraph module~s_symba_fragmentation s_symba_fragmentation module~swiftest swiftest module~s_symba_fragmentation->module~swiftest module~symba_classes symba_classes module~s_symba_fragmentation->module~symba_classes module~swiftest->module~symba_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~swiftest_operators->module~swiftest_globals module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables NFRAG_DISRUPT NFRAG_SUPERCAT Subroutines symba_fragmentation_mergeaddsub Module Functions symba_fragmentation_casedisruption symba_fragmentation_casehitandrun symba_fragmentation_casemerge symba_fragmentation_casesupercatastrophic Variables Type Visibility Attributes Name Initial integer(kind=I4B), private, parameter :: NFRAG_DISRUPT = 12 integer(kind=I4B), private, parameter :: NFRAG_SUPERCAT = 20 Subroutines subroutine symba_fragmentation_mergeaddsub (system, param, family, id_frag, Ip_frag, m_frag, rad_frag, xb_frag, vb_frag, rot_frag, status) Author David A. Minton Fills the pl_discards and pl_adds with removed and added bodies Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(in), dimension(:) :: family List of indices of all bodies inovlved in the collision integer(kind=I4B), intent(in), dimension(:) :: id_frag List of fragment ids real(kind=DP), intent(in), dimension(:,:) :: Ip_frag Fragment rotational inertia vectors real(kind=DP), intent(in), dimension(:) :: m_frag Distribution of fragment mass and radii real(kind=DP), intent(in), dimension(:) :: rad_frag Distribution of fragment mass and radii real(kind=DP), intent(in), dimension(:,:) :: xb_frag Fragment barycentric position, barycentric velocity, and rotation vectors real(kind=DP), intent(in), dimension(:,:) :: vb_frag Fragment barycentric position, barycentric velocity, and rotation vectors real(kind=DP), intent(in), dimension(:,:) :: rot_frag Fragment barycentric position, barycentric velocity, and rotation vectors integer(kind=I4B), intent(in) :: status Status flag to assign to adds Module Functions module function symba_fragmentation_casedisruption (system, param, family, x, v, mass, radius, L_spin, Ip, mass_res, Qloss) result(status) Interface → Author Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton Create the fragments resulting from a non-catastrophic disruption collision Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(in), dimension(:) :: family List of indices of all bodies inovlved in the collision real(kind=DP), intent(inout), dimension(:,:) :: x Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: v Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: radius Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: L_spin Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: Ip Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass_res The distribution of fragment mass obtained by the regime calculation real(kind=DP), intent(inout) :: Qloss Energy lost during collision Return Value integer(kind=I4B) Status flag assigned to this outcome module function symba_fragmentation_casehitandrun (system, param, family, x, v, mass, radius, L_spin, Ip, mass_res, Qloss) result(status) Interface → Author Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton Create the fragments resulting from a non-catastrophic hit-and-run collision Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(in), dimension(:) :: family List of indices of all bodies inovlved in the collision real(kind=DP), intent(inout), dimension(:,:) :: x Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: v Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: radius Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: L_spin Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: Ip Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass_res The distribution of fragment mass obtained by the regime calculation real(kind=DP), intent(inout) :: Qloss Energy lost during collision Return Value integer(kind=I4B) Status flag assigned to this outcome module function symba_fragmentation_casemerge (system, param, family, x, v, mass, radius, L_spin, Ip) result(status) Interface → Author Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton Merge planets. Read more… Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(in), dimension(:) :: family List of indices of all bodies inovlved in the collision real(kind=DP), intent(in), dimension(:,:) :: x Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(in), dimension(:,:) :: v Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(in), dimension(:) :: mass Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(in), dimension(:) :: radius Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(in), dimension(:,:) :: L_spin Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(in), dimension(:,:) :: Ip Input values that represent a 2-body equivalent of a possibly 2+ body collision Return Value integer(kind=I4B) Status flag assigned to this outcome module function symba_fragmentation_casesupercatastrophic (system, param, family, x, v, mass, radius, L_spin, Ip, mass_res, Qloss) result(status) Interface → Author Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton Create the fragments resulting from a supercatastrophic collision Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(in), dimension(:) :: family List of indices of all bodies inovlved in the collision real(kind=DP), intent(inout), dimension(:,:) :: x Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: v Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: radius Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: L_spin Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:,:) :: Ip Input values that represent a 2-body equivalent of a possibly 2+ body collision real(kind=DP), intent(inout), dimension(:) :: mass_res The distribution of fragment mass obtained by the regime calculation real(kind=DP), intent(inout) :: Qloss Energy lost during collision Return Value integer(kind=I4B) Status flag assigned to this outcome","tags":"","loc":"module/s_symba_fragmentation.html"},{"title":"s_symba_encounter_check – swiftest","text":"Uses swiftest Ancestors: symba_classes module~~s_symba_encounter_check~~UsesGraph module~s_symba_encounter_check s_symba_encounter_check module~swiftest swiftest module~s_symba_encounter_check->module~swiftest module~symba_classes symba_classes module~s_symba_encounter_check->module~symba_classes module~swiftest->module~symba_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~swiftest_operators->module~swiftest_globals module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Functions symba_encounter_check_pl symba_encounter_check_pltpenc symba_encounter_check_tp Module Subroutines symba_encounter_check_one Module Functions module function symba_encounter_check_pl (self, system, dt, irec) result(lany_encounter) Interface → Author David A. Minton Check for an encounter between massive bodies. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter module function symba_encounter_check_pltpenc (self, system, dt, irec) result(lany_encounter) Interface → Author David A. Minton Check for an encounter between test particles and massive bodies in the pltpenc list.\n Note: This method works for the polymorphic symba_pltpenc and symba_plplenc types. Read more… Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-pl encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter module function symba_encounter_check_tp (self, system, dt, irec) result(lany_encounter) Interface → Author David A. Minton Check for an encounter between test particles and massive bodies. Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter Module Subroutines pure elemental module subroutine symba_encounter_check_one (xr, yr, zr, vxr, vyr, vzr, rhill1, rhill2, dt, irec, lencounter, lvdotr) Interface → Author David A. Minton Check for an encounter. Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: xr real(kind=DP), intent(in) :: yr real(kind=DP), intent(in) :: zr real(kind=DP), intent(in) :: vxr real(kind=DP), intent(in) :: vyr real(kind=DP), intent(in) :: vzr real(kind=DP), intent(in) :: rhill1 real(kind=DP), intent(in) :: rhill2 real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: irec logical, intent(out) :: lencounter logical, intent(out) :: lvdotr","tags":"","loc":"module/s_symba_encounter_check.html"},{"title":"s_symba_io – swiftest","text":"Uses swiftest Ancestors: symba_classes module~~s_symba_io~~UsesGraph module~s_symba_io s_symba_io module~swiftest swiftest module~s_symba_io->module~swiftest module~symba_classes symba_classes module~s_symba_io->module~symba_classes module~swiftest->module~symba_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~swiftest_operators->module~swiftest_globals module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines symba_io_dump_particle_info symba_io_param_reader symba_io_param_writer symba_io_read_particle symba_io_write_discard Module Subroutines module subroutine symba_io_dump_particle_info (system, param, lincludecb, tpidx, plidx) Interface → Author David A. Minton Dumps the particle information data to a file. \n Pass a list of array indices for test particles (tpidx) and/or massive bodies (plidx) to append Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA extensions logical, intent(in), optional :: lincludecb Set to true to include the central body (default is false) integer(kind=I4B), intent(in), optional dimension(:) :: tpidx Array of test particle indices to append to the particle file integer(kind=I4B), intent(in), optional dimension(:) :: plidx Array of massive body indices to append to the particle file module subroutine symba_io_param_reader (self, unit, iotype, v_list, iostat, iomsg) Interface → Author The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott Read in parameters specific to the SyMBA integrator, then calls the base io_param_reader. Read more… Arguments Type Intent Optional Attributes Name class( symba_parameters ), intent(inout) :: self Collection of parameters integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) The first element passes the integrator code to the reader integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 module subroutine symba_io_param_writer (self, unit, iotype, v_list, iostat, iomsg) Interface → Author David A. Minton Dump integration parameters specific to SyMBA to file and then call the base io_param_writer method. Read more… Arguments Type Intent Optional Attributes Name class( symba_parameters ), intent(in) :: self Collection of SyMBA parameters integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) Not used in this procedure integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 module subroutine symba_io_read_particle (system, param) Interface → Author David A. Minton Reads an old particle information file for a restartd run Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system file class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA extensions module subroutine symba_io_write_discard (self, param) Interface → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"module/s_symba_io.html"},{"title":"s_symba_discard – swiftest","text":"Uses swiftest Ancestors: symba_classes module~~s_symba_discard~~UsesGraph module~s_symba_discard s_symba_discard module~swiftest swiftest module~s_symba_discard->module~swiftest module~symba_classes symba_classes module~s_symba_discard->module~symba_classes module~swiftest->module~symba_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~swiftest_operators->module~swiftest_globals module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines symba_discard_cb_pl symba_discard_conserve_mtm symba_discard_nonplpl symba_discard_nonplpl_conservation symba_discard_peri_pl Module Subroutines symba_discard_pl Subroutines subroutine symba_discard_cb_pl (pl, system, param) Author David A. Minton Check to see if planets should be discarded based on their positions relative to the central body.\n If a body gets flagged here when it has also been previously flagged for a collision with another massive body,\n its collisional status will be revoked. Discards due to colliding with or escaping the central body take precedence \n over pl-pl collisions Read more… Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl SyMBA massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters subroutine symba_discard_conserve_mtm (pl, system, param, ipl, lescape_body) Author David A. Minton Conserves system momentum when a body is lost from the system or collides with central body Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl class( symba_nbody_system ), intent(inout) :: system class( symba_parameters ), intent(inout) :: param integer(kind=I4B), intent(in) :: ipl logical, intent(in) :: lescape_body subroutine symba_discard_nonplpl (pl, system, param) Author David A. Minton Check to see if planets should be discarded based on their positions or because they are unbound Read more… Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl SyMBA test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters subroutine symba_discard_nonplpl_conservation (pl, system, param) Author David A. Minton If there are any bodies that are removed due to either colliding with the central body or escaping the systme,\n we need to track the conserved quantities with the system bookkeeping terms. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters subroutine symba_discard_peri_pl (pl, system, param) Author David A. Minton Check to see if a test particle should be discarded because its perihelion distance becomes too small Read more… Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl SyMBA massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Module Subroutines module subroutine symba_discard_pl (self, system, param) Interface → Author David A. Minton Call the various flavors of discards for massive bodies in SyMBA runs, including discards due to colling with the central body, \n escaping the system, or colliding with each other. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"module/s_symba_discard.html"},{"title":"s_symba_step – swiftest","text":"Uses swiftest Ancestors: symba_classes module~~s_symba_step~~UsesGraph module~s_symba_step s_symba_step module~swiftest swiftest module~s_symba_step->module~swiftest module~symba_classes symba_classes module~s_symba_step->module~symba_classes module~swiftest->module~symba_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~swiftest_operators->module~swiftest_globals module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines symba_step_system symba_step_interp_system symba_step_set_recur_levels_system symba_step_recur_system symba_step_reset_system Module Subroutines module subroutine symba_step_system (self, param, t, dt) Interface → Author David A. Minton Step planets and active test particles ahead in democratic heliocentric coordinates, descending the recursive\n   branch if necessary to handle possible close encounters Read more… Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize module subroutine symba_step_interp_system (self, param, t, dt) Interface → Author David A. Minton Step planets and active test particles ahead in democratic heliocentric coordinates, calling the recursive\n         subroutine to descend to the appropriate level to handle close encounters Read more… Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize module subroutine symba_step_set_recur_levels_system (self, ireci) Interface → Author David A. Minton Resets pl, tp,and encounter structures at the start of a new step Read more… Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object integer(kind=I4B), intent(in) :: ireci Input recursion level recursive module subroutine symba_step_recur_system (self, param, t, ireci) Interface → Author David A. Minton Step interacting planets and active test particles ahead in democratic heliocentric coordinates at the current\n         recursion level, if applicable, and descend to the next deeper level if necessarys Read more… Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), value :: t integer(kind=I4B), value :: ireci input recursion level module subroutine symba_step_reset_system (self) Interface → Author David A. Minton Resets pl, tp,and encounter structures at the start of a new step Read more… Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object","tags":"","loc":"module/s_symba_step.html"},{"title":"s_symba_drift – swiftest","text":"Uses swiftest Ancestors: symba_classes module~~s_symba_drift~~UsesGraph module~s_symba_drift s_symba_drift module~swiftest swiftest module~s_symba_drift->module~swiftest module~symba_classes symba_classes module~s_symba_drift->module~symba_classes module~swiftest->module~symba_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~swiftest_operators->module~swiftest_globals module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines symba_drift_pl symba_drift_tp Module Subroutines module subroutine symba_drift_pl (self, system, param, dt) Interface → Author David A. Minton Wrapper function used to call the body drift routine from a symba_pl structure Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize module subroutine symba_drift_tp (self, system, param, dt) Interface → Author David A. Minton Wrapper function used to call the body drift routine from a symba_pl structure Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"module/s_symba_drift.html"},{"title":"s_fragmentation – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_fragmentation~~UsesGraph module~s_fragmentation s_fragmentation module~swiftest swiftest module~s_fragmentation->module~swiftest module~swiftest_classes swiftest_classes module~s_fragmentation->module~swiftest_classes module~swiftest->module~swiftest_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines fragmentation_initialize fragmentation_regime Module Subroutines module subroutine fragmentation_initialize (system, param, family, x, v, L_spin, Ip, mass, radius, nfrag, Ip_frag, m_frag, rad_frag, xb_frag, vb_frag, rot_frag, Qloss, lfailure) Interface → Author Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton Initialize the position and velocity of fragments to conserve energy and momentum. Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters integer(kind=I4B), intent(in), dimension(:) :: family Index of bodies involved in the collision real(kind=DP), intent(inout), dimension(:,:) :: x Two-body equivalent position, vector, spin momentum, and rotational inertia values for the collision real(kind=DP), intent(inout), dimension(:,:) :: v Two-body equivalent position, vector, spin momentum, and rotational inertia values for the collision real(kind=DP), intent(inout), dimension(:,:) :: L_spin Two-body equivalent position, vector, spin momentum, and rotational inertia values for the collision real(kind=DP), intent(inout), dimension(:,:) :: Ip Two-body equivalent position, vector, spin momentum, and rotational inertia values for the collision real(kind=DP), intent(inout), dimension(:) :: mass Two-body equivalent mass and radii for the bodies in the collision real(kind=DP), intent(inout), dimension(:) :: radius Two-body equivalent mass and radii for the bodies in the collision integer(kind=I4B), intent(inout) :: nfrag Number of fragments to generate real(kind=DP), intent(inout), dimension(:,:), allocatable :: Ip_frag Fragment rotational inertia vectors real(kind=DP), intent(inout), dimension(:), allocatable :: m_frag Distribution of fragment mass and radii real(kind=DP), intent(inout), dimension(:), allocatable :: rad_frag Distribution of fragment mass and radii real(kind=DP), intent(inout), dimension(:,:), allocatable :: xb_frag Fragment barycentric position, barycentric velocity, and rotation vectors real(kind=DP), intent(inout), dimension(:,:), allocatable :: vb_frag Fragment barycentric position, barycentric velocity, and rotation vectors real(kind=DP), intent(inout), dimension(:,:), allocatable :: rot_frag Fragment barycentric position, barycentric velocity, and rotation vectors real(kind=DP), intent(inout) :: Qloss Energy lost during the collision logical, intent(out) :: lfailure Answers the question: Should this have been a merger instead? module subroutine fragmentation_regime (Mcb, m1, m2, rad1, rad2, xh1, xh2, vb1, vb2, den1, den2, regime, Mlr, Mslr, mtiny, Qloss) Interface → Author Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton Determine the collisional regime of two colliding bodies. \n Current version requires all values to be converted to SI units prior to calling the function\n       References:\n       Kokubo, E., Genda, H., 2010. Formation of Terrestrial Planets from Protoplanets Under a Realistic Accretion \n          Condition. ApJL 714, L21. https://doi.org/10.1088/2041-8205/714/1/L21\n       Leinhardt, Z.M., Stewart, S.T., 2012. Collisions between Gravity-dominated Bodies. I. Outcome Regimes and Scaling \n          Laws 745, 79. https://doi.org/10.1088/0004-637X/745/1/79\n       Mustill, A.J., Davies, M.B., Johansen, A., 2018. The dynamical evolution of transiting planetary systems including \n          a realistic collision prescription. Mon Not R Astron Soc 478, 2896–2908. https://doi.org/10.1093/mnras/sty1273\n       Rufu, R., Aharonson, O., 2019. Impact Dynamics of Moons Within a Planetary Potential. J. Geophys. Res. Planets 124, \n          1008–1019. https://doi.org/10.1029/2018JE005798\n       Stewart, S.T., Leinhardt, Z.M., 2012. Collisions between Gravity-dominated Bodies. II. The Diversity of Impact \n          Outcomes during the End Stage of Planet Formation. ApJ 751, 32. https://doi.org/10.1088/0004-637X/751/1/32 Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: Mcb real(kind=DP), intent(in) :: m1 real(kind=DP), intent(in) :: m2 real(kind=DP), intent(in) :: rad1 real(kind=DP), intent(in) :: rad2 real(kind=DP), intent(in), dimension(:) :: xh1 real(kind=DP), intent(in), dimension(:) :: xh2 real(kind=DP), intent(in), dimension(:) :: vb1 real(kind=DP), intent(in), dimension(:) :: vb2 real(kind=DP), intent(in) :: den1 real(kind=DP), intent(in) :: den2 integer(kind=I4B), intent(out) :: regime real(kind=DP), intent(out) :: Mlr real(kind=DP), intent(out) :: Mslr real(kind=DP), intent(in) :: mtiny real(kind=DP), intent(out) :: Qloss The residual energy after the collision","tags":"","loc":"module/s_fragmentation.html"},{"title":"s_rmvs_discard – swiftest","text":"Uses swiftest Ancestors: rmvs_classes module~~s_rmvs_discard~~UsesGraph module~s_rmvs_discard s_rmvs_discard module~swiftest swiftest module~s_rmvs_discard->module~swiftest module~rmvs_classes rmvs_classes module~s_rmvs_discard->module~rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~swiftest_operators->module~swiftest_globals module~symba_classes->module~rmvs_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines rmvs_discard_tp Module Subroutines module subroutine rmvs_discard_tp (self, system, param) Interface → Author David A. Minton Check to see if test particles should be discarded based on pericenter passage distances with respect to planets encountered Read more… Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters","tags":"","loc":"module/s_rmvs_discard.html"},{"title":"s_rmvs_util – swiftest","text":"Uses swiftest Ancestors: rmvs_classes module~~s_rmvs_util~~UsesGraph module~s_rmvs_util s_rmvs_util module~swiftest swiftest module~s_rmvs_util->module~swiftest module~rmvs_classes rmvs_classes module~s_rmvs_util->module~rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~swiftest_operators->module~swiftest_globals module~symba_classes->module~rmvs_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines rmvs_util_append_pl rmvs_util_append_tp rmvs_util_fill_pl rmvs_util_fill_tp rmvs_util_resize_pl rmvs_util_resize_tp rmvs_util_sort_pl rmvs_util_sort_tp rmvs_util_sort_rearrange_pl rmvs_util_sort_rearrange_tp rmvs_util_spill_pl rmvs_util_spill_tp Module Subroutines module subroutine rmvs_util_append_pl (self, source, lsource_mask) Interface → Author David A. Minton Append components from one massive body object to another. \n This method will automatically resize the destination body if it is too small\n Arguments Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to module subroutine rmvs_util_append_tp (self, source, lsource_mask) Interface → Author David A. Minton Append components from test particle object to another. \n This method will automatically resize the destination body if it is too small\n Arguments Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to module subroutine rmvs_util_fill_pl (self, inserts, lfill_list) Interface → Author David A. Minton Insert new RMVS massive body structure into an old one. \n This is the inverse of a fill operation. Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps module subroutine rmvs_util_fill_tp (self, inserts, lfill_list) Interface → Author David A. Minton Insert new RMVS test particle structure into an old one. \n This is the inverse of a fill operation. Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps module subroutine rmvs_util_resize_pl (self, nnew) Interface → Author David A. Minton Checks the current size of a massive body object against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in) :: nnew New size neded module subroutine rmvs_util_resize_tp (self, nnew) Interface → Author David A. Minton Checks the current size of a test particle object against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: nnew New size neded module subroutine rmvs_util_sort_pl (self, sortby, ascending) Interface → Author David A. Minton Sort a RMVS massive body object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order module subroutine rmvs_util_sort_tp (self, sortby, ascending) Interface → Author David A. Minton Sort a RMVS test particle object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order module subroutine rmvs_util_sort_rearrange_pl (self, ind) Interface → Author David A. Minton Rearrange RMVS massive body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) module subroutine rmvs_util_sort_rearrange_tp (self, ind) Interface → Author David A. Minton Rearrange RMVS test particle object in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) module subroutine rmvs_util_spill_pl (self, discards, lspill_list, ldestructive) Interface → Author David A. Minton Move spilled (discarded) RMVS test particle structure from active list to discard list Read more… Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not module subroutine rmvs_util_spill_tp (self, discards, lspill_list, ldestructive) Interface → Author David A. Minton Move spilled (discarded) RMVS test particle structure from active list to discard list Read more… Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"module/s_rmvs_util.html"},{"title":"s_rmvs_kick – swiftest","text":"Uses swiftest Ancestors: rmvs_classes module~~s_rmvs_kick~~UsesGraph module~s_rmvs_kick s_rmvs_kick module~swiftest swiftest module~s_rmvs_kick->module~swiftest module~rmvs_classes rmvs_classes module~s_rmvs_kick->module~rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~swiftest_operators->module~swiftest_globals module~symba_classes->module~rmvs_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines rmvs_kick_getacch_tp Module Subroutines module subroutine rmvs_kick_getacch_tp (self, system, param, t, lbeg) Interface → Author David A. Minton Compute the oblateness acceleration in the inner encounter region with planets Read more… Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest central body particle data structuree class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step","tags":"","loc":"module/s_rmvs_kick.html"},{"title":"s_rmvs_setup – swiftest","text":"Uses swiftest Ancestors: rmvs_classes module~~s_rmvs_setup~~UsesGraph module~s_rmvs_setup s_rmvs_setup module~swiftest swiftest module~s_rmvs_setup->module~swiftest module~rmvs_classes rmvs_classes module~s_rmvs_setup->module~rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~swiftest_operators->module~swiftest_globals module~symba_classes->module~rmvs_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines rmvs_setup_pl rmvs_setup_initialize_system rmvs_setup_tp Module Subroutines module subroutine rmvs_setup_pl (self, n, param) Interface → Author David A. Minton Allocate RMVS test particle structure Read more… Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameter module subroutine rmvs_setup_initialize_system (self, param) Interface → Author David A. Minton Initialize an RMVS nbody system from files and sets up the planetocentric structures. Read more… Arguments Type Intent Optional Attributes Name class( rmvs_nbody_system ), intent(inout) :: self RMVS system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters module subroutine rmvs_setup_tp (self, n, param) Interface → Author David A. Minton Allocate WHM test particle structure Read more… Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameter","tags":"","loc":"module/s_rmvs_setup.html"},{"title":"s_rmvs_step – swiftest","text":"Uses swiftest Ancestors: rmvs_classes module~~s_rmvs_step~~UsesGraph module~s_rmvs_step s_rmvs_step module~swiftest swiftest module~s_rmvs_step->module~swiftest module~rmvs_classes rmvs_classes module~s_rmvs_step->module~rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~swiftest_operators->module~swiftest_globals module~symba_classes->module~rmvs_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines rmvs_interp_out rmvs_step_out rmvs_interp_in rmvs_step_in rmvs_make_planetocentric rmvs_peri_tp rmvs_end_planetocentric Module Subroutines rmvs_step_system Subroutines subroutine rmvs_interp_out (cb, pl, dt) Author David A. Minton Interpolate planet positions between two Keplerian orbits in outer encounter region Read more… Arguments Type Intent Optional Attributes Name class( rmvs_cb ), intent(inout) :: cb RMVS central body object class( rmvs_pl ), intent(inout) :: pl RMVS massive body object real(kind=DP), intent(in) :: dt Step size subroutine rmvs_step_out (cb, pl, tp, system, param, t, dt) Author David A. Minton Step ACTIVE test particles ahead in the outer encounter region, setting up and calling the inner region\n    integration if necessar Read more… Arguments Type Intent Optional Attributes Name class( rmvs_cb ), intent(inout) :: cb RMVS central body object class( rmvs_pl ), intent(inout) :: pl RMVS massive body object class( rmvs_tp ), intent(inout) :: tp RMVS test particle object class( rmvs_nbody_system ), intent(inout) :: system RMVS nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current stepsiz subroutine rmvs_interp_in (cb, pl, system, param, dt, outer_index) Author David A. Minton Interpolate planet positions between two Keplerian orbits in inner encounter regio Read more… Arguments Type Intent Optional Attributes Name class( rmvs_cb ), intent(inout) :: cb RMVS cenral body object class( rmvs_pl ), intent(inout) :: pl RMVS massive body object class( rmvs_nbody_system ), intent(inout) :: system RMVS nbody system object class(swiftest_parameters), intent(in) :: param Swiftest parameters file real(kind=DP), intent(in) :: dt Step size integer(kind=I4B), intent(in) :: outer_index Outer substep number within current set subroutine rmvs_step_in (cb, pl, tp, param, outer_time, dto) Author David A. Minton Step active test particles ahead in the inner encounter region Read more… Arguments Type Intent Optional Attributes Name class( rmvs_cb ), intent(inout) :: cb RMVS central body object class( rmvs_pl ), intent(inout) :: pl RMVS massive body object class( rmvs_tp ), intent(inout) :: tp RMVS test particle object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: outer_time Current time real(kind=DP), intent(in) :: dto Outer step size subroutine rmvs_make_planetocentric (param, cb, pl, tp) Author David A. Minton When encounters are detected, this method will call the interpolation methods for the planets and \n creates a Swiftest test particle structure for each planet's encountering test particles to simplify the \n planetocentric calculations. This subroutine is not based on an existing one from Swift and Swifter Arguments Type Intent Optional Attributes Name class(swiftest_parameters), intent(in) :: param Current run configuration paramete class( rmvs_cb ), intent(inout) :: cb RMVS central body object class( rmvs_pl ), intent(inout) :: pl RMVS massive body object class( rmvs_tp ), intent(inout) :: tp RMVS test particle object subroutine rmvs_peri_tp (tp, pl, t, dt, lfirst, inner_index, ipleP, param) Author David A. Minton Determine planetocentric pericenter passages for test particles in close encounters with a planet Read more… Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: tp RMVS test particle object (planetocentric) class( rmvs_pl ), intent(inout) :: pl RMVS massive body object (heliocentric) real(kind=DP), intent(in) :: t current time real(kind=DP), intent(in) :: dt step size logical, intent(in) :: lfirst Logical flag indicating whether current invocation is the first integer(kind=I4B), intent(in) :: inner_index Outer substep number within current set integer(kind=I4B), intent(in) :: ipleP index of RMVS planet being closely encountered class(swiftest_parameters), intent(in) :: param Current run configuration parameters subroutine rmvs_end_planetocentric (pl, tp) Author David A. Minton Deallocates all of the encountering particle data structures for next time Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: pl RMVS massive body object class( rmvs_tp ), intent(inout) :: tp RMVS test particle objec Module Subroutines module subroutine rmvs_step_system (self, param, t, dt) Interface → Author David A. Minton Step massive bodies and and active test particles ahead in heliocentric coordinates Read more… Arguments Type Intent Optional Attributes Name class( rmvs_nbody_system ), intent(inout) :: self RMVS nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current stepsiz","tags":"","loc":"module/s_rmvs_step.html"},{"title":"s_rmvs_chk – swiftest","text":"Uses swiftest Ancestors: rmvs_classes module~~s_rmvs_chk~~UsesGraph module~s_rmvs_chk s_rmvs_chk module~swiftest swiftest module~s_rmvs_chk->module~swiftest module~rmvs_classes rmvs_classes module~s_rmvs_chk->module~rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~swiftest_operators->module~swiftest_globals module~symba_classes->module~rmvs_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Functions rmvs_encounter_check_tp rmvs_chk_ind Module Functions module function rmvs_encounter_check_tp (self, system, dt) result(lencounter) Interface → Author David A. Minton Determine whether a test particle and planet are having or will have an encounter within the next time step Read more… Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class( rmvs_nbody_system ), intent(inout) :: system RMVS nbody system object real(kind=DP), intent(in) :: dt step size Return Value logical Returns true if there is at least one close encounter elemental module function rmvs_chk_ind (r2, v2, vdotr, dt, r2crit) result(lflag) Interface → Author David A. Minton Determine whether a test particle and planet are having or will have an encounter within the next time step Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: r2 real(kind=DP), intent(in) :: v2 real(kind=DP), intent(in) :: vdotr real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r2crit Return Value logical","tags":"","loc":"module/s_rmvs_chk.html"},{"title":"swiftest_driver – swiftest","text":"Uses swiftest program~~swiftest_driver~~UsesGraph program~swiftest_driver swiftest_driver module~swiftest swiftest program~swiftest_driver->module~swiftest module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~helio_classes helio_classes module~swiftest->module~helio_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~rmvs_classes module~lambda_function->module~swiftest_globals module~helio_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Driver program for the Swiftest integrators. Unlike the earlier Swift and Swifter drivers, in Swiftest all integrators \n    are run from this single program. Adapted from Swifter by David E. Kaufmann's Swifter driver programs swifter_[bs,helio,ra15,rmvs,symba,tu4,whm].f90\n Adapted from Hal Levison and Martin Duncan's Swift driver programs\n Read in the user-defined parameters file and the initial conditions of the system\n Define the maximum number of threads Step the system forward in time Evaluate any discards or collisional outcomes If the loop counter is at the output cadence value, append the data file with a single frame\n If the loop counter is at the dump cadence value, dump the state of the system to a file in case it needs to be restarted Calls program~~swiftest_driver~~CallsGraph program~swiftest_driver swiftest_driver io_get_args io_get_args program~swiftest_driver->io_get_args setup_construct_system setup_construct_system program~swiftest_driver->setup_construct_system util_exit util_exit program~swiftest_driver->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables nbody_system param integrator param_file_name ierr iloop idump iout nloops iu Variables Type Attributes Name Initial class(swiftest_nbody_system), allocatable :: nbody_system Polymorphic object containing the nbody system to be integrated class(swiftest_parameters), allocatable :: param Run configuration parameters integer(kind=I4B) :: integrator Integrator type code (see swiftest_globals for symbolic names) character(len=:), allocatable :: param_file_name Name of the file containing user-defined parameters integer(kind=I4B) :: ierr I/O error code integer(kind=I8B) :: iloop Loop counter integer(kind=I8B) :: idump Dump cadence counter integer(kind=I8B) :: iout Output cadence counter integer(kind=I8B) :: nloops Number of steps to take in the simulation integer(kind=I4B) :: iu Unit number of binary file","tags":"","loc":"program/swiftest_driver.html"}]}