var tipuesearch = {"pages":[{"title":" swiftest ","text":"swiftest Put Markdown test of arbitrary length here. Developer Info David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott The Purdue University Minton Research Group","tags":"home","loc":"index.html"},{"title":"obl_acc.f90 – swiftest","text":"Unit Name   : obl_acc\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : obl\n  Language    : Fortran 90/95 Description : Compute the barycentric accelerations of planets due to the oblateness of the central body Input\n    Arguments : npl          : number of planets\n                swifter_pl1P : pointer to head of Swifter planet structure linked-list\n                j2rp2        : J2 * R 2 for the Sun\n                j4rp4        : J4 * R 4 for the Sun\n                xh           : heliocentric positions of planets\n                irh          : inverse heliocentric radii of planets\n    Terminal  : none\n    File      : none Output\n    Arguments : aobl         : barycentric accelerations of planets due to central body oblateness\n    Terminal  : none\n    File      : none Invocation  : CALL obl_acc(npl, swifter_pl1P, j2rp2, j4rp4, xh, irh, aobl) Notes       : Adapted from Martin Duncan's Swift routine obl_acc.f Returned values do not include monopole term or terms higher than J4 Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~obl_acc.f90~~EfferentGraph sourcefile~obl_acc.f90 obl_acc.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~obl_acc.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~obl_acc.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~obl_acc.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines obl_acc Source Code obl_acc.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : obl_acc !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : obl !  Language    : Fortran 90/95 ! !  Description : Compute the barycentric accelerations of planets due to the oblateness of the central body ! !  Input !    Arguments : npl          : number of planets !                swifter_pl1P : pointer to head of Swifter planet structure linked-list !                j2rp2        : J2 * R**2 for the Sun !                j4rp4        : J4 * R**4 for the Sun !                xh           : heliocentric positions of planets !                irh          : inverse heliocentric radii of planets !    Terminal  : none !    File      : none ! !  Output !    Arguments : aobl         : barycentric accelerations of planets due to central body oblateness !    Terminal  : none !    File      : none ! !  Invocation  : CALL obl_acc(npl, swifter_pl1P, j2rp2, j4rp4, xh, irh, aobl) ! !  Notes       : Adapted from Martin Duncan's Swift routine obl_acc.f ! !                Returned values do not include monopole term or terms higher than J4 ! !********************************************************************************************************************************** SUBROUTINE obl_acc ( npl , swiftest_plA , j2rp2 , j4rp4 , xh , irh , aobl ) ! Modules USE swiftest USE module_swiftest USE module_interfaces , EXCEPT_THIS_ONE => obl_acc IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: j2rp2 , j4rp4 REAL ( DP ), DIMENSION ( npl ), INTENT ( IN ) :: irh REAL ( DP ), DIMENSION ( NDIM , npl ), INTENT ( IN ) :: xh REAL ( DP ), DIMENSION ( NDIM , npl ), INTENT ( OUT ) :: aobl TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA ! Internals INTEGER ( I4B ) :: i REAL ( DP ) :: rinv2 , t0 , t1 , t2 , t3 , fac1 , fac2 , msun ! Executable code msun = swiftest_plA % mass ( 1 ) DO i = 2 , npl rinv2 = irh ( i ) ** 2 t0 = - msun * rinv2 * rinv2 * irh ( i ) t1 = 1.5_DP * j2rp2 t2 = xh ( 3 , i ) * xh ( 3 , i ) * rinv2 t3 = 1.875_DP * j4rp4 * rinv2 fac1 = t0 * ( t1 - t3 - ( 5.0_DP * t1 - ( 1 4.0_DP - 2 1.0_DP * t2 ) * t3 ) * t2 ) fac2 = 2.0_DP * t0 * ( t1 - ( 2.0_DP - ( 1 4.0_DP * t2 / 3.0_DP )) * t3 ) aobl (:, i ) = fac1 * xh (:, i ) aobl ( 3 , i ) = fac2 * xh ( 3 , i ) + aobl ( 3 , i ) END DO aobl (:, 1 ) = ( / 0.0_DP , 0.0_DP , 0.0_DP / ) DO i = 2 , npl aobl (:, 1 ) = aobl (:, 1 ) - swiftest_plA % mass ( i ) * aobl (:, i ) / msun END DO RETURN END SUBROUTINE obl_acc !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/obl_acc.f90.html"},{"title":"obl_acc_tp.f90 – swiftest","text":"Unit Name   : obl_acc_tp\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : obl\n  Language    : Fortran 90/95 Description : Compute the barycentric accelerations of test particles due to the oblateness of the central body Input\n    Arguments : ntp   : number of active test particles\n                xht   : heliocentric positions of test particles\n                j2rp2 : J2 * R 2 for the Sun\n                j4rp4 : J4 * R 4 for the Sun\n                irht  : inverse heliocentric radii of test particles\n                msun  : mass of the Sun\n    Terminal  : none\n    File      : none Output\n    Arguments : aoblt : barycentric accelerations of test particles due to central body oblateness\n    Terminal  : none\n    File      : none Invocation  : CALL obl_acc_tp(ntp, xht, j2rp2, j4rp4, irht, aoblt, msun) Notes       : Adapted from Hal Levison's Swift routine obl_acc_tp.f Returned values do not include monopole term or terms higher than J4 Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~obl_acc_tp.f90~~EfferentGraph sourcefile~obl_acc_tp.f90 obl_acc_tp.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~obl_acc_tp.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~obl_acc_tp.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines obl_acc_tp Source Code obl_acc_tp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : obl_acc_tp !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : obl !  Language    : Fortran 90/95 ! !  Description : Compute the barycentric accelerations of test particles due to the oblateness of the central body ! !  Input !    Arguments : ntp   : number of active test particles !                xht   : heliocentric positions of test particles !                j2rp2 : J2 * R**2 for the Sun !                j4rp4 : J4 * R**4 for the Sun !                irht  : inverse heliocentric radii of test particles !                msun  : mass of the Sun !    Terminal  : none !    File      : none ! !  Output !    Arguments : aoblt : barycentric accelerations of test particles due to central body oblateness !    Terminal  : none !    File      : none ! !  Invocation  : CALL obl_acc_tp(ntp, xht, j2rp2, j4rp4, irht, aoblt, msun) ! !  Notes       : Adapted from Hal Levison's Swift routine obl_acc_tp.f ! !                Returned values do not include monopole term or terms higher than J4 ! !********************************************************************************************************************************** SUBROUTINE obl_acc_tp ( ntp , xht , j2rp2 , j4rp4 , irht , aoblt , msun ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => obl_acc_tp IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: ntp REAL ( DP ), INTENT ( IN ) :: j2rp2 , j4rp4 , msun REAL ( DP ), DIMENSION ( ntp ), INTENT ( IN ) :: irht REAL ( DP ), DIMENSION ( NDIM , ntp ), INTENT ( IN ) :: xht REAL ( DP ), DIMENSION ( NDIM , ntp ), INTENT ( OUT ) :: aoblt ! Internals INTEGER ( I4B ) :: i REAL ( DP ) :: rinv2 , t0 , t1 , t2 , t3 , fac1 , fac2 ! Executable code DO i = 1 , ntp rinv2 = irht ( i ) ** 2 t0 = - msun * rinv2 * rinv2 * irht ( i ) t1 = 1.5_DP * j2rp2 t2 = xht ( 3 , i ) * xht ( 3 , i ) * rinv2 t3 = 1.875_DP * j4rp4 * rinv2 fac1 = t0 * ( t1 - t3 - ( 5.0_DP * t1 - ( 1 4.0_DP - 2 1.0_DP * t2 ) * t3 ) * t2 ) fac2 = 2.0_DP * t0 * ( t1 - ( 2.0_DP - ( 1 4.0_DP * t2 / 3.0_DP )) * t3 ) aoblt (:, i ) = fac1 * xht (:, i ) aoblt ( 3 , i ) = aoblt ( 3 , i ) + fac2 * xht ( 3 , i ) END DO RETURN END SUBROUTINE obl_acc_tp !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/obl_acc_tp.f90.html"},{"title":"obl_pot.f90 – swiftest","text":"Unit Name   : obl_pot\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : obl\n  Language    : Fortran 90/95 Description : Compute the contribution to the total gravitational potential due solely to the oblateness of the central body Input\n    Arguments : npl          : number of planets\n                swifter_pl1P : pointer to head of Swifter planet structure linked-list\n                j2rp2        : J2 * R 2 for the Sun\n                j4rp4        : J4 * R 4 for the Sun\n                xh           : heliocentric positions of the planets\n                irh          : inverse heliocentric radii of the planets\n    Terminal  : none\n    File      : none Output\n    Arguments : oblpot       : total gravitational potential due to J2 and J4 oblateness terms for the central body\n    Terminal  : none\n    File      : none Invocation  : CALL obl_pot(npl, swifter_pl1P, j2rp2, j4rp4, xh, irh, oblpot) Notes       : Adapted from Martin Duncan's Swift routine obl_pot.f Returned value does not include monopole term or terms higher than J4 Reference : MacMillan , W . D . 1958 . The Theory of the Potential , ( Dover Publications ), 363 . Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~obl_pot.f90~~EfferentGraph sourcefile~obl_pot.f90 obl_pot.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~obl_pot.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~obl_pot.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~obl_pot.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines obl_pot Source Code obl_pot.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : obl_pot !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : obl !  Language    : Fortran 90/95 ! !  Description : Compute the contribution to the total gravitational potential due solely to the oblateness of the central body ! !  Input !    Arguments : npl          : number of planets !                swifter_pl1P : pointer to head of Swifter planet structure linked-list !                j2rp2        : J2 * R**2 for the Sun !                j4rp4        : J4 * R**4 for the Sun !                xh           : heliocentric positions of the planets !                irh          : inverse heliocentric radii of the planets !    Terminal  : none !    File      : none ! !  Output !    Arguments : oblpot       : total gravitational potential due to J2 and J4 oblateness terms for the central body !    Terminal  : none !    File      : none ! !  Invocation  : CALL obl_pot(npl, swifter_pl1P, j2rp2, j4rp4, xh, irh, oblpot) ! !  Notes       : Adapted from Martin Duncan's Swift routine obl_pot.f ! !                Returned value does not include monopole term or terms higher than J4 ! !                Reference: MacMillan, W. D. 1958. The Theory of the Potential, (Dover Publications), 363. ! !********************************************************************************************************************************** SUBROUTINE obl_pot ( npl , swiftest_plA , j2rp2 , j4rp4 , xh , irh , oblpot ) ! Modules USE swiftest USE module_swiftest USE module_interfaces , EXCEPT_THIS_ONE => obl_pot IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: j2rp2 , j4rp4 REAL ( DP ), INTENT ( OUT ) :: oblpot REAL ( DP ), DIMENSION ( npl ), INTENT ( IN ) :: irh REAL ( DP ), DIMENSION ( NDIM , npl ), INTENT ( IN ) :: xh TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA ! Internals INTEGER ( I4B ) :: i REAL ( DP ) :: rinv2 , t0 , t1 , t2 , t3 , p2 , p4 , mu ! Executable code oblpot = 0.0_DP mu = swiftest_plA % mass ( 1 ) DO i = 2 , npl rinv2 = irh ( i ) ** 2 t0 = mu * swiftest_plA % mass ( i ) * rinv2 * irh ( i ) t1 = j2rp2 t2 = xh ( 3 , i ) * xh ( 3 , i ) * rinv2 t3 = j4rp4 * rinv2 p2 = 0.5_DP * ( 3.0_DP * t2 - 1.0_DP ) p4 = 0.125_DP * (( 3 5.0_DP * t2 - 3 0.0_DP ) * t2 + 3.0_DP ) oblpot = oblpot + t0 * ( t1 * p2 + t3 * p4 ) END DO RETURN END SUBROUTINE obl_pot !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/obl_pot.f90.html"},{"title":"orbel_scget.f90 – swiftest","text":"Unit Name   : orbel_scget\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : orbel\n  Language    : Fortran 90/95 Description : Efficiently compute the sine and cosine of an input angle Input\n    Arguments : angle : input angle\n    Terminal  : none\n    File      : none Output\n    Arguments : sx    : sine of the angle\n                cx    : cosine of the angle\n    Terminal  : none\n    File      : none Invocation  : CALL orbel_scget(angle, sx, cx) Notes       : Adapted from Martin Duncan's Swift routine orbel_scget.f Input angle must be in radians Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~orbel_scget.f90~~EfferentGraph sourcefile~orbel_scget.f90 orbel_scget.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~orbel_scget.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~orbel_scget.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines orbel_scget Source Code orbel_scget.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : orbel_scget !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : orbel !  Language    : Fortran 90/95 ! !  Description : Efficiently compute the sine and cosine of an input angle ! !  Input !    Arguments : angle : input angle !    Terminal  : none !    File      : none ! !  Output !    Arguments : sx    : sine of the angle !                cx    : cosine of the angle !    Terminal  : none !    File      : none ! !  Invocation  : CALL orbel_scget(angle, sx, cx) ! !  Notes       : Adapted from Martin Duncan's Swift routine orbel_scget.f ! !                Input angle must be in radians ! !********************************************************************************************************************************** SUBROUTINE orbel_scget ( angle , sx , cx ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => orbel_scget IMPLICIT NONE ! Arguments REAL ( DP ), INTENT ( IN ) :: angle REAL ( DP ), INTENT ( OUT ) :: sx , cx ! Internals INTEGER ( I4B ) :: nper REAL ( DP ) :: x ! Executable code nper = angle / TWOPI x = angle - nper * TWOPI IF ( x < 0.0_DP ) x = x + TWOPI sx = SIN ( x ) cx = SQRT ( 1.0_DP - sx * sx ) IF (( x > PIBY2 ) . AND . ( x < PI3BY2 )) cx = - cx RETURN END SUBROUTINE orbel_scget !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/orbel_scget.f90.html"},{"title":"orbel_xv2el.f90 – swiftest","text":"Unit Name   : orbel_xv2el\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : orbel\n  Language    : Fortran 90/95 Description : Compute osculating orbital elements from relative Cartesian position and velocity Input\n    Arguments : x     : relative position\n                v     : relative velocity\n                mu    : G * (m1 + m2)\n    Terminal  : none\n    File      : none Output\n    Arguments : a     : semimajor axis (pericentric distance for a parabolic orbit)\n                e     : eccentricity\n                inc   : inclination\n                capom : longitude of ascending node\n                omega : argument of pericenter\n                capm  : mean anomaly\n    Terminal  : none\n    File      : none Invocation  : CALL orbel_xv2el(x, v, mu, a, e, inc, capom, omega, capm) Notes       : Adapted from Martin Duncan's Swift routine orbel_xv2el.f All angular measures are returned in radians If inclination < TINY , longitude of the ascending node is arbitrarily set to 0 If eccentricity < sqrt ( TINY ), argument of pericenter is arbitrarily set to 0 References : Danby , J . M . A . 1988 . Fundamentals of Celestial Mechanics , ( Willmann - Bell , Inc .), 201 - 206 . Fitzpatrick , P . M . 1970 . Principles of Celestial Mechanics , ( Academic Press ), 69 - 73 . Roy , A . E . 1982 . Orbital Motion , ( Adam Hilger , Ltd .), 75 - 95 . Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~orbel_xv2el.f90~~EfferentGraph sourcefile~orbel_xv2el.f90 orbel_xv2el.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~orbel_xv2el.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~orbel_xv2el.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines orbel_xv2el Source Code orbel_xv2el.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : orbel_xv2el !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : orbel !  Language    : Fortran 90/95 ! !  Description : Compute osculating orbital elements from relative Cartesian position and velocity ! !  Input !    Arguments : x     : relative position !                v     : relative velocity !                mu    : G * (m1 + m2) !    Terminal  : none !    File      : none ! !  Output !    Arguments : a     : semimajor axis (pericentric distance for a parabolic orbit) !                e     : eccentricity !                inc   : inclination !                capom : longitude of ascending node !                omega : argument of pericenter !                capm  : mean anomaly !    Terminal  : none !    File      : none ! !  Invocation  : CALL orbel_xv2el(x, v, mu, a, e, inc, capom, omega, capm) ! !  Notes       : Adapted from Martin Duncan's Swift routine orbel_xv2el.f ! !                All angular measures are returned in radians ! !                If inclination < TINY, longitude of the ascending node is arbitrarily set to 0 ! !                If eccentricity < sqrt(TINY), argument of pericenter is arbitrarily set to 0 ! !                References: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 201 - 206. !                            Fitzpatrick, P. M. 1970. Principles of Celestial Mechanics, (Academic Press), 69 - 73. !                            Roy, A. E. 1982. Orbital Motion, (Adam Hilger, Ltd.), 75 - 95. ! !********************************************************************************************************************************** SUBROUTINE orbel_xv2el ( x , v , mu , a , e , inc , capom , omega , capm ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => orbel_xv2el IMPLICIT NONE ! Arguments REAL ( DP ), INTENT ( IN ) :: mu REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: x , v REAL ( DP ), INTENT ( OUT ) :: a , e , inc , capom , omega , capm ! Internals INTEGER ( I4B ) :: iorbit_type REAL ( DP ) :: r , v2 , hx , hy , hz , h2 , h , rdotv , energy , fac , u , w , cw , sw , face , cape , tmpf , capf ! Executable code a = 0.0_DP e = 0.0_DP inc = 0.0_DP capom = 0.0_DP omega = 0.0_DP capm = 0.0_DP r = SQRT ( DOT_PRODUCT ( x (:), x (:))) v2 = DOT_PRODUCT ( v (:), v (:)) hx = x ( 2 ) * v ( 3 ) - x ( 3 ) * v ( 2 ) hy = x ( 3 ) * v ( 1 ) - x ( 1 ) * v ( 3 ) hz = x ( 1 ) * v ( 2 ) - x ( 2 ) * v ( 1 ) h2 = hx * hx + hy * hy + hz * hz h = SQRT ( h2 ) IF ( h2 == 0.0_DP ) RETURN rdotv = DOT_PRODUCT ( x (:), v (:)) energy = 0.5_DP * v2 - mu / r fac = hz / h IF ( fac < - 1.0_DP ) THEN inc = PI ELSE IF ( fac < 1.0_DP ) THEN inc = ACOS ( fac ) END IF fac = SQRT ( hx * hx + hy * hy ) / h IF ( fac < TINY ) THEN u = ATAN2 ( x ( 2 ), x ( 1 )) IF ( hz < 0.0_DP ) u = - u ELSE capom = ATAN2 ( hx , - hy ) u = ATAN2 ( x ( 3 ) / SIN ( inc ), x ( 1 ) * COS ( capom ) + x ( 2 ) * SIN ( capom )) END IF IF ( capom < 0.0_DP ) capom = capom + TWOPI IF ( u < 0.0_DP ) u = u + TWOPI IF ( ABS ( energy * r / mu ) < SQRT ( TINY )) THEN iorbit_type = PARABOLA ELSE a = - 0.5_DP * mu / energy IF ( a < 0.0_DP ) THEN fac = - h2 / ( mu * a ) IF ( fac > TINY ) THEN iorbit_type = HYPERBOLA ELSE iorbit_type = PARABOLA END IF ELSE iorbit_type = ELLIPSE END IF END IF SELECT CASE ( iorbit_type ) CASE ( ELLIPSE ) fac = 1.0_DP - h2 / ( mu * a ) IF ( fac > TINY ) THEN e = SQRT ( fac ) cape = 0.0_DP face = ( a - r ) / ( a * e ) IF ( face < - 1.0_DP ) THEN cape = PI ELSE IF ( face < 1.0_DP ) THEN cape = ACOS ( face ) END IF IF ( rdotv < 0.0_DP ) cape = TWOPI - cape fac = 1.0_DP - e * COS ( cape ) cw = ( COS ( cape ) - e ) / fac sw = SQRT ( 1.0_DP - e * e ) * SIN ( cape ) / fac w = ATAN2 ( sw , cw ) IF ( w < 0.0_DP ) w = w + TWOPI ELSE cape = u w = u END IF capm = cape - e * SIN ( cape ) CASE ( PARABOLA ) a = 0.5_DP * h2 / mu e = 1.0_DP w = 0.0_DP fac = 2.0_DP * a / r - 1.0_DP IF ( fac < - 1.0_DP ) THEN w = PI ELSE IF ( fac < 1.0_DP ) THEN w = ACOS ( fac ) END IF IF ( rdotv < 0.0_DP ) w = TWOPI - w tmpf = TAN ( 0.5_DP * w ) capm = tmpf * ( 1.0_DP + tmpf * tmpf / 3.0_DP ) CASE ( HYPERBOLA ) e = SQRT ( 1.0_DP + fac ) tmpf = ( a - r ) / ( a * e ) IF ( tmpf < 1.0_DP ) tmpf = 1.0_DP capf = LOG ( tmpf + SQRT ( tmpf * tmpf - 1.0_DP )) IF ( rdotv < 0.0_DP ) capf = - capf fac = e * COSH ( capf ) - 1.0_DP cw = ( e - COSH ( capf )) / fac sw = SQRT ( e * e - 1.0_DP ) * SINH ( capf ) / fac w = ATAN2 ( sw , cw ) IF ( w < 0.0_DP ) w = w + TWOPI capm = e * SINH ( capf ) - capf END SELECT omega = u - w IF ( omega < 0.0_DP ) omega = omega + TWOPI RETURN END SUBROUTINE orbel_xv2el !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/orbel_xv2el.f90.html"},{"title":"orbel_xv2aqt.f90 – swiftest","text":"Unit Name   : orbel_xv2aqt\n  Unit Type   : subroutine\n  Project     : Swifter\n  Package     : orbel\n  Language    : Fortran 90/95 Description : Compute semimajor axis, pericentric distance, mean anomaly, and time to nearest pericenter passage from\n                relative Cartesian position and velocity Input\n    Arguments : x     : relative position\n                v     : relative velocity\n                mu    : G * (m1 + m2)\n    Terminal  : none\n    File      : none Output\n    Arguments : a     : semimajor axis (pericentric distance for a parabolic orbit)\n                q     : pericentric distance\n                capm  : mean anomaly\n                tperi : time to nearest pericenter passage\n    Terminal  : none\n    File      : none Invocation  : CALL orbel_xv2aqt(x, v, mu, a, q, capm, tperi) Notes       : Adapted from Hal Levison's Swift routine orbel_xv2aqt.f tperi > 0 means nearest pericenter passage is in the future tperi < 0 means nearest pericenter passage is in the past Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~orbel_xv2aqt.f90~~EfferentGraph sourcefile~orbel_xv2aqt.f90 orbel_xv2aqt.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~orbel_xv2aqt.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~orbel_xv2aqt.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines orbel_xv2aqt Source Code orbel_xv2aqt.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : orbel_xv2aqt !  Unit Type   : subroutine !  Project     : Swifter !  Package     : orbel !  Language    : Fortran 90/95 ! !  Description : Compute semimajor axis, pericentric distance, mean anomaly, and time to nearest pericenter passage from !                relative Cartesian position and velocity ! !  Input !    Arguments : x     : relative position !                v     : relative velocity !                mu    : G * (m1 + m2) !    Terminal  : none !    File      : none ! !  Output !    Arguments : a     : semimajor axis (pericentric distance for a parabolic orbit) !                q     : pericentric distance !                capm  : mean anomaly !                tperi : time to nearest pericenter passage !    Terminal  : none !    File      : none ! !  Invocation  : CALL orbel_xv2aqt(x, v, mu, a, q, capm, tperi) ! !  Notes       : Adapted from Hal Levison's Swift routine orbel_xv2aqt.f ! !                tperi > 0 means nearest pericenter passage is in the future !                tperi < 0 means nearest pericenter passage is in the past ! !********************************************************************************************************************************** SUBROUTINE orbel_xv2aqt ( x , v , mu , a , q , capm , tperi ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => orbel_xv2aqt IMPLICIT NONE ! Arguments REAL ( DP ), INTENT ( IN ) :: mu REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: x , v REAL ( DP ), INTENT ( OUT ) :: a , q , capm , tperi ! Internals INTEGER ( I4B ) :: iorbit_type REAL ( DP ) :: r , v2 , hx , hy , hz , h2 , rdotv , energy , fac , w , face , cape , e , tmpf , capf , mm ! Executable code a = 0.0_DP q = 0.0_DP capm = 0.0_DP tperi = 0.0_DP r = SQRT ( DOT_PRODUCT ( x (:), x (:))) v2 = DOT_PRODUCT ( v (:), v (:)) hx = x ( 2 ) * v ( 3 ) - x ( 3 ) * v ( 2 ) hy = x ( 3 ) * v ( 1 ) - x ( 1 ) * v ( 3 ) hz = x ( 1 ) * v ( 2 ) - x ( 2 ) * v ( 1 ) h2 = hx * hx + hy * hy + hz * hz IF ( h2 == 0.0_DP ) RETURN rdotv = DOT_PRODUCT ( x (:), v (:)) energy = 0.5_DP * v2 - mu / r IF ( ABS ( energy * r / mu ) < SQRT ( TINY )) THEN iorbit_type = PARABOLA ELSE a = - 0.5_DP * mu / energy IF ( a < 0.0_DP ) THEN fac = - h2 / ( mu * a ) IF ( fac > TINY ) THEN iorbit_type = HYPERBOLA ELSE iorbit_type = PARABOLA END IF ELSE iorbit_type = ELLIPSE END IF END IF SELECT CASE ( iorbit_type ) CASE ( ELLIPSE ) fac = 1.0_DP - h2 / ( mu * a ) IF ( fac > TINY ) THEN e = SQRT ( fac ) cape = 0.0_DP face = ( a - r ) / ( a * e ) IF ( face < - 1.0_DP ) THEN cape = PI ELSE IF ( face < 1.0_DP ) THEN cape = ACOS ( face ) END IF IF ( rdotv < 0.0_DP ) cape = TWOPI - cape ELSE e = 0.0_DP cape = 0.0_DP END IF capm = cape - e * SIN ( cape ) q = a * ( 1.0_DP - e ) mm = SQRT ( mu / ( a ** 3 )) IF ( capm < PI ) THEN tperi = - 1.0_DP * capm / mm ELSE tperi = - 1.0_DP * ( capm - TWOPI ) / mm END IF CASE ( PARABOLA ) a = 0.5_DP * h2 / mu e = 1.0_DP w = 0.0_DP fac = 2.0_DP * a / r - 1.0_DP IF ( fac < - 1.0_DP ) THEN w = PI ELSE IF ( fac < 1.0_DP ) THEN w = ACOS ( fac ) END IF IF ( rdotv < 0.0_DP ) w = TWOPI - w tmpf = TAN ( 0.5_DP * w ) capm = tmpf * ( 1.0_DP + tmpf * tmpf / 3.0_DP ) q = a mm = SQRT ( 0.5_DP * mu / ( q ** 3 )) tperi = - 1.0_DP * capm / mm CASE ( HYPERBOLA ) e = SQRT ( 1.0_DP + fac ) tmpf = ( a - r ) / ( a * e ) IF ( tmpf < 1.0_DP ) tmpf = 1.0_DP capf = LOG ( tmpf + SQRT ( tmpf * tmpf - 1.0_DP )) IF ( rdotv < 0.0_DP ) capf = - capf capm = e * SINH ( capf ) - capf q = a * ( 1.0_DP - e ) mm = SQRT ( - mu / ( a ** 3 )) tperi = - 1.0_DP * capm / mm END SELECT RETURN END SUBROUTINE orbel_xv2aqt !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/orbel_xv2aqt.f90.html"},{"title":"orbel_xv2aeq.f90 – swiftest","text":"Unit Name   : orbel_xv2aeq\n  Unit Type   : subroutine\n  Project     : Swifter\n  Package     : orbel\n  Language    : Fortran 90/95 Description : Compute semimajor axis, eccentricity, and pericentric distance from relative Cartesian position and velocity Input\n    Arguments : x  : relative position\n                v  : relative velocity\n                mu : G * (m1 + m2)\n    Terminal  : none\n    File      : none Output\n    Arguments : a  : semimajor axis (pericentric distance for a parabolic orbit)\n                e  : eccentricity\n                q  : pericentric distance\n    Terminal  : none\n    File      : none Invocation  : CALL orbel_xv2aeq(x, v, mu, a, e, q) Notes       : Adapted from Luke Dones' Swift routine orbel_xv2aeq.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~orbel_xv2aeq.f90~~EfferentGraph sourcefile~orbel_xv2aeq.f90 orbel_xv2aeq.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~orbel_xv2aeq.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~orbel_xv2aeq.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines orbel_xv2aeq Source Code orbel_xv2aeq.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : orbel_xv2aeq !  Unit Type   : subroutine !  Project     : Swifter !  Package     : orbel !  Language    : Fortran 90/95 ! !  Description : Compute semimajor axis, eccentricity, and pericentric distance from relative Cartesian position and velocity ! !  Input !    Arguments : x  : relative position !                v  : relative velocity !                mu : G * (m1 + m2) !    Terminal  : none !    File      : none ! !  Output !    Arguments : a  : semimajor axis (pericentric distance for a parabolic orbit) !                e  : eccentricity !                q  : pericentric distance !    Terminal  : none !    File      : none ! !  Invocation  : CALL orbel_xv2aeq(x, v, mu, a, e, q) ! !  Notes       : Adapted from Luke Dones' Swift routine orbel_xv2aeq.f ! !********************************************************************************************************************************** SUBROUTINE orbel_xv2aeq ( x , v , mu , a , e , q ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => orbel_xv2aeq IMPLICIT NONE ! Arguments REAL ( DP ), INTENT ( IN ) :: mu REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: x , v REAL ( DP ), INTENT ( OUT ) :: a , e , q ! Internals INTEGER ( I4B ) :: iorbit_type REAL ( DP ) :: r , v2 , hx , hy , hz , h2 , energy , fac ! Executable code a = 0.0_DP e = 0.0_DP q = 0.0_DP r = SQRT ( DOT_PRODUCT ( x (:), x (:))) v2 = DOT_PRODUCT ( v (:), v (:)) hx = x ( 2 ) * v ( 3 ) - x ( 3 ) * v ( 2 ) hy = x ( 3 ) * v ( 1 ) - x ( 1 ) * v ( 3 ) hz = x ( 1 ) * v ( 2 ) - x ( 2 ) * v ( 1 ) h2 = hx * hx + hy * hy + hz * hz IF ( h2 == 0.0_DP ) RETURN energy = 0.5_DP * v2 - mu / r IF ( ABS ( energy * r / mu ) < SQRT ( TINY )) THEN iorbit_type = PARABOLA ELSE a = - 0.5_DP * mu / energy IF ( a < 0.0_DP ) THEN fac = - h2 / ( mu * a ) IF ( fac > TINY ) THEN iorbit_type = HYPERBOLA ELSE iorbit_type = PARABOLA END IF ELSE iorbit_type = ELLIPSE END IF END IF SELECT CASE ( iorbit_type ) CASE ( ELLIPSE ) fac = 1.0_DP - h2 / ( mu * a ) IF ( fac > TINY ) e = SQRT ( fac ) q = a * ( 1.0_DP - e ) CASE ( PARABOLA ) a = 0.5_DP * h2 / mu e = 1.0_DP q = a CASE ( HYPERBOLA ) e = SQRT ( 1.0_DP + fac ) q = a * ( 1.0_DP - e ) END SELECT RETURN END SUBROUTINE orbel_xv2aeq !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/orbel_xv2aeq.f90.html"},{"title":"coord_vh2vb_tp.f90 – swiftest","text":"Unit Name   : coord_vh2vb_tp\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : coord\n  Language    : Fortran 90/95 Description : Convert from heliocentric to barycentric coordinates, active test particle velocities only Input\n    Arguments : ntp          : number of active test particles\n                swifter_tp1P : pointer to head of active Swifter test particle structure linked-list\n                vs           : barycentric velocity of the Sun\n    Terminal  : none\n    File      : none Output\n    Arguments : swifter_tp1P : pointer to head of active Swifter test particle structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL coord_vh2vb_tp(ntp, swifter_tp1P, vs) Notes       : Adapted from Hal Levison's Swift routine coord_vh2b_tp.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~coord_vh2vb_tp.f90~~EfferentGraph sourcefile~coord_vh2vb_tp.f90 coord_vh2vb_tp.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~coord_vh2vb_tp.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~coord_vh2vb_tp.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~coord_vh2vb_tp.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines coord_vh2vb_tp Source Code coord_vh2vb_tp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : coord_vh2vb_tp !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : coord !  Language    : Fortran 90/95 ! !  Description : Convert from heliocentric to barycentric coordinates, active test particle velocities only ! !  Input !    Arguments : ntp          : number of active test particles !                swifter_tp1P : pointer to head of active Swifter test particle structure linked-list !                vs           : barycentric velocity of the Sun !    Terminal  : none !    File      : none ! !  Output !    Arguments : swifter_tp1P : pointer to head of active Swifter test particle structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL coord_vh2vb_tp(ntp, swifter_tp1P, vs) ! !  Notes       : Adapted from Hal Levison's Swift routine coord_vh2b_tp.f ! !********************************************************************************************************************************** SUBROUTINE coord_vh2vb_tp ( ntp , swiftest_tpA , vs ) ! Modules USE swiftest USE module_swiftest USE module_interfaces , EXCEPT_THIS_ONE => coord_vh2vb_tp IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: ntp REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: vs TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA ! Internals INTEGER ( I4B ) :: i ! Executable code DO i = 1 , ntp IF ( swiftest_tpA % status ( i ) == ACTIVE ) swiftest_tpA % vb (:, i ) = swiftest_tpA % vh (:, i ) + vs (:) END DO RETURN END SUBROUTINE coord_vh2vb_tp !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/coord_vh2vb_tp.f90.html"},{"title":"coord_h2b.f90 – swiftest","text":"Unit Name   : coord_h2b\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : coord\n  Language    : Fortran 90/95 Description : Convert from heliocentric to barycentric coordinates, planets only Input\n    Arguments : npl          : number of planets\n                swifter_pl1P : pointer to head of Swifter planet structure linked-list\n    Terminal  : none\n    File      : none Output\n    Arguments : swifter_pl1P : pointer to head of Swifter planet structure linked-list\n                msys         : total system mass\n    Terminal  : none\n    File      : none Invocation  : CALL coord_h2b(npl, swifter_pl1P, msys) Notes       : Adapted from Martin Duncan and Hal Levison's Swift routine coord_h2b.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~coord_h2b.f90~~EfferentGraph sourcefile~coord_h2b.f90 coord_h2b.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~coord_h2b.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~coord_h2b.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~coord_h2b.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines coord_h2b Source Code coord_h2b.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : coord_h2b !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : coord !  Language    : Fortran 90/95 ! !  Description : Convert from heliocentric to barycentric coordinates, planets only ! !  Input !    Arguments : npl          : number of planets !                swifter_pl1P : pointer to head of Swifter planet structure linked-list !    Terminal  : none !    File      : none ! !  Output !    Arguments : swifter_pl1P : pointer to head of Swifter planet structure linked-list !                msys         : total system mass !    Terminal  : none !    File      : none ! !  Invocation  : CALL coord_h2b(npl, swifter_pl1P, msys) ! !  Notes       : Adapted from Martin Duncan and Hal Levison's Swift routine coord_h2b.f ! !********************************************************************************************************************************** SUBROUTINE coord_h2b ( npl , swiftest_plA , msys ) ! Modules USE swiftest USE module_swiftest USE module_interfaces , EXCEPT_THIS_ONE => coord_h2b IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( OUT ) :: msys TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA ! Internals INTEGER ( I4B ) :: i REAL ( DP ), DIMENSION ( NDIM ) :: xtmp , vtmp ! Executable code msys = swiftest_plA % mass ( 1 ) xtmp (:) = ( / 0.0_DP , 0.0_DP , 0.0_DP / ) vtmp (:) = ( / 0.0_DP , 0.0_DP , 0.0_DP / ) DO i = 2 , npl msys = msys + swiftest_plA % mass ( i ) xtmp (:) = xtmp (:) + swiftest_plA % mass ( i ) * swiftest_plA % xh (:, i ) vtmp (:) = vtmp (:) + swiftest_plA % mass ( i ) * swiftest_plA % vh (:, i ) END DO swiftest_plA % xb (:, 1 ) = - xtmp (:) / msys swiftest_plA % vb (:, 1 ) = - vtmp (:) / msys xtmp (:) = swiftest_plA % xb (:, 1 ) vtmp (:) = swiftest_plA % vb (:, 1 ) DO i = 2 , npl swiftest_plA % xb (:, i ) = swiftest_plA % xh (:, i ) + xtmp (:) swiftest_plA % vb (:, i ) = swiftest_plA % vh (:, i ) + vtmp (:) END DO RETURN END SUBROUTINE coord_h2b !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/coord_h2b.f90.html"},{"title":"coord_vb2vh_tp.f90 – swiftest","text":"Unit Name   : coord_vb2vh_tp\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : coord\n  Language    : Fortran 90/95 Description : Convert from barycentric to heliocentric coordinates, active test particle velocities only Input\n    Arguments : ntp          : number of active test particles\n                swifter_tp1P : pointer to head of active Swifter test particle structure linked-list\n                vs           : barycentric velocity of the Sun\n    Terminal  : none\n    File      : none Output\n    Arguments : swifter_tp1P : pointer to head of active Swifter test particle structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL coord_vb2vh_tp(ntp, swifter_tp1P, vs) Notes       : Adapted from Hal Levison's Swift routine coord_vb2h_tp.f Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~coord_vb2vh_tp.f90~~EfferentGraph sourcefile~coord_vb2vh_tp.f90 coord_vb2vh_tp.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~coord_vb2vh_tp.f90->sourcefile~module_swiftest.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~coord_vb2vh_tp.f90->sourcefile~module_interfaces.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~coord_vb2vh_tp.f90->sourcefile~module_symba.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~coord_vb2vh_tp.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines coord_vb2vh_tp Source Code coord_vb2vh_tp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : coord_vb2vh_tp !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : coord !  Language    : Fortran 90/95 ! !  Description : Convert from barycentric to heliocentric coordinates, active test particle velocities only ! !  Input !    Arguments : ntp          : number of active test particles !                swifter_tp1P : pointer to head of active Swifter test particle structure linked-list !                vs           : barycentric velocity of the Sun !    Terminal  : none !    File      : none ! !  Output !    Arguments : swifter_tp1P : pointer to head of active Swifter test particle structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL coord_vb2vh_tp(ntp, swifter_tp1P, vs) ! !  Notes       : Adapted from Hal Levison's Swift routine coord_vb2h_tp.f ! !********************************************************************************************************************************** SUBROUTINE coord_vb2vh_tp ( ntp , swiftest_tpA , vs ) ! Modules USE swiftest USE module_swiftest USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => coord_vb2vh_tp IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: ntp REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: vs TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA ! Internals INTEGER ( I4B ) :: i ! Executable code DO i = 1 , ntp IF ( swiftest_tpA % status ( i ) == ACTIVE ) swiftest_tpA % vh (:, i ) = swiftest_tpA % vb (:, i ) - vs (:) END DO RETURN END SUBROUTINE coord_vb2vh_tp !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/coord_vb2vh_tp.f90.html"},{"title":"coord_vh2vb.f90 – swiftest","text":"Unit Name   : coord_vh2vb\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : coord\n  Language    : Fortran 90/95 Description : Convert from heliocentric to barycentric coordinates, planet velocities only Input\n    Arguments : npl          : number of planets\n                swifter_pl1P : pointer to head of Swifter planet structure linked-list\n    Terminal  : none\n    File      : none Output\n    Arguments : swifter_pl1P : pointer to head of Swifter planet structure linked-list\n                msys         : total system mass\n    Terminal  : none\n    File      : none Invocation  : CALL coord_vh2vb(npl, swifter_pl1P, msys) Notes       : Adapted from Hal Levison's Swift routine coord_vh2b.f Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~coord_vh2vb.f90~~EfferentGraph sourcefile~coord_vh2vb.f90 coord_vh2vb.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~coord_vh2vb.f90->sourcefile~module_swiftest.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~coord_vh2vb.f90->sourcefile~module_interfaces.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~coord_vh2vb.f90->sourcefile~module_symba.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~coord_vh2vb.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines coord_vh2vb Source Code coord_vh2vb.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : coord_vh2vb !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : coord !  Language    : Fortran 90/95 ! !  Description : Convert from heliocentric to barycentric coordinates, planet velocities only ! !  Input !    Arguments : npl          : number of planets !                swifter_pl1P : pointer to head of Swifter planet structure linked-list !    Terminal  : none !    File      : none ! !  Output !    Arguments : swifter_pl1P : pointer to head of Swifter planet structure linked-list !                msys         : total system mass !    Terminal  : none !    File      : none ! !  Invocation  : CALL coord_vh2vb(npl, swifter_pl1P, msys) ! !  Notes       : Adapted from Hal Levison's Swift routine coord_vh2b.f ! !********************************************************************************************************************************** SUBROUTINE coord_vh2vb ( npl , swiftest_plA , msys ) ! Modules USE swiftest USE module_swiftest USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => coord_vh2vb IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( OUT ) :: msys TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA ! Internals INTEGER ( I4B ) :: i REAL ( DP ), DIMENSION ( NDIM ) :: vtmp ! Executable code vtmp (:) = ( / 0.0_DP , 0.0_DP , 0.0_DP / ) msys = swiftest_plA % mass ( 1 ) ! EDIT FOR PARALLELIZATION DO i = 2 , npl msys = msys + swiftest_plA % mass ( i ) vtmp (:) = vtmp (:) + swiftest_plA % mass ( i ) * swiftest_plA % vh (:, i ) END DO swiftest_plA % vb (:, 1 ) = - vtmp (:) / msys vtmp (:) = swiftest_plA % vb (:, 1 ) DO i = 2 , npl swiftest_plA % vb (:, i ) = swiftest_plA % vh (:, i ) + vtmp (:) END DO RETURN END SUBROUTINE coord_vh2vb !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/coord_vh2vb.f90.html"},{"title":"coord_vb2vh.f90 – swiftest","text":"Unit Name   : coord_vb2vh\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : coord\n  Language    : Fortran 90/95 Description : Convert from barycentric to heliocentric coordinates, planet velocities only Input\n    Arguments : npl          : number of planets\n                swifter_pl1P : pointer to head of Swifter planet structure linked-list\n    Terminal  : none\n    File      : none Output\n    Arguments : swifter_pl1P : pointer to head of Swifter planet structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL coord_vb2vh(npl, swifter_pl1P) Notes       : Adapted from Hal Levison's Swift routine coord_vb2h.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~coord_vb2vh.f90~~EfferentGraph sourcefile~coord_vb2vh.f90 coord_vb2vh.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~coord_vb2vh.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~coord_vb2vh.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~coord_vb2vh.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines coord_vb2vh Source Code coord_vb2vh.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : coord_vb2vh !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : coord !  Language    : Fortran 90/95 ! !  Description : Convert from barycentric to heliocentric coordinates, planet velocities only ! !  Input !    Arguments : npl          : number of planets !                swifter_pl1P : pointer to head of Swifter planet structure linked-list !    Terminal  : none !    File      : none ! !  Output !    Arguments : swifter_pl1P : pointer to head of Swifter planet structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL coord_vb2vh(npl, swifter_pl1P) ! !  Notes       : Adapted from Hal Levison's Swift routine coord_vb2h.f ! !********************************************************************************************************************************** SUBROUTINE coord_vb2vh ( npl , swiftest_plA ) ! Modules USE swiftest USE module_swiftest USE module_interfaces , EXCEPT_THIS_ONE => coord_vb2vh IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA ! Internals INTEGER ( I4B ) :: i REAL ( DP ), DIMENSION ( NDIM ) :: vtmp ! Executable code vtmp (:) = ( / 0.0_DP , 0.0_DP , 0.0_DP / ) DO i = 2 , npl vtmp (:) = vtmp (:) - swiftest_plA % mass ( i ) * swiftest_plA % vb (:, i ) END DO vtmp (:) = vtmp (:) / swiftest_plA % mass ( 1 ) swiftest_plA % vb (:, 1 ) = vtmp (:) DO i = 2 , npl swiftest_plA % vh (:, i ) = swiftest_plA % vb (:, i ) - vtmp (:) END DO RETURN END SUBROUTINE coord_vb2vh !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/coord_vb2vh.f90.html"},{"title":"coord_h2b_tp.f90 – swiftest","text":"Unit Name   : coord_h2b_tp\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : coord\n  Language    : Fortran 90/95 Description : Convert from heliocentric to barycentric coordinates, active test particles only Input\n    Arguments : ntp          : number of active test particles\n                swifter_tp1P : pointer to head of active Swifter test particle structure linked-list\n                swifter_pl1P : pointer to head of Swifter planet structure linked-list\n    Terminal  : none\n    File      : none Output\n    Arguments : swifter_tp1P : pointer to head of active Swifter test particle structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL coord_h2b_tp(ntp, swifter_tp1P, swifter_pl1P) Notes       : Adapted from Hal Levison's Swift routine coord_h2b_tp.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~coord_h2b_tp.f90~~EfferentGraph sourcefile~coord_h2b_tp.f90 coord_h2b_tp.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~coord_h2b_tp.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~coord_h2b_tp.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~coord_h2b_tp.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines coord_h2b_tp Source Code coord_h2b_tp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : coord_h2b_tp !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : coord !  Language    : Fortran 90/95 ! !  Description : Convert from heliocentric to barycentric coordinates, active test particles only ! !  Input !    Arguments : ntp          : number of active test particles !                swifter_tp1P : pointer to head of active Swifter test particle structure linked-list !                swifter_pl1P : pointer to head of Swifter planet structure linked-list !    Terminal  : none !    File      : none ! !  Output !    Arguments : swifter_tp1P : pointer to head of active Swifter test particle structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL coord_h2b_tp(ntp, swifter_tp1P, swifter_pl1P) ! !  Notes       : Adapted from Hal Levison's Swift routine coord_h2b_tp.f ! !********************************************************************************************************************************** SUBROUTINE coord_h2b_tp ( ntp , swiftest_tpA , swiftest_plA ) ! Modules USE swiftest USE module_swiftest USE module_interfaces , EXCEPT_THIS_ONE => coord_h2b_tp IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: ntp TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA ! Internals INTEGER ( I4B ) :: i REAL ( DP ), DIMENSION ( NDIM ) :: xtmp , vtmp ! Executable code xtmp (:) = swiftest_plA % xb (:, 1 ) vtmp (:) = swiftest_plA % vb (:, 1 ) DO i = 1 , ntp swiftest_tpA % xb (:, i ) = swiftest_tpA % xh (:, i ) + xtmp (:) swiftest_tpA % vb (:, i ) = swiftest_tpA % vh (:, i ) + vtmp (:) END DO RETURN END SUBROUTINE coord_h2b_tp !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/coord_h2b_tp.f90.html"},{"title":"util_peri.f90 – swiftest","text":"Unit Name   : util_peri\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : util\n  Language    : Fortran 90/95 Description : Determine system pericenter passages for test particles Input\n    Arguments : lfirst       : logical flag indicating whether current invocation is the first\n                ntp          : number of active test particles\n                swiftest_tp1P : pointer to head of active SWIFTER test particle structure linked-list\n                mu           : G * (m1 + m2) = mass of the Sun in this routine\n                msys         : total system mass\n                qmin_coord   : coordinate frame for qmin\n    Terminal  : none\n    File      : none Output\n    Arguments : swiftest_tp1P : pointer to head of active SWIFTER test particle structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL util_peri(lfirst, ntp, swiftest_tp1P, mu, msys, qmin_coord) Notes       : Adapted from Hal Levison's Swift routine util_peri.f If the coordinate system used is barycentric, then this routine assumes that the barycentric coordinates in the test particle structures are up-to-date and are not recomputed Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~util_peri.f90~~EfferentGraph sourcefile~util_peri.f90 util_peri.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~util_peri.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~util_peri.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines util_peri Source Code util_peri.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : util_peri !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : util !  Language    : Fortran 90/95 ! !  Description : Determine system pericenter passages for test particles ! !  Input !    Arguments : lfirst       : logical flag indicating whether current invocation is the first !                ntp          : number of active test particles !                swiftest_tp1P : pointer to head of active SWIFTER test particle structure linked-list !                mu           : G * (m1 + m2) = mass of the Sun in this routine !                msys         : total system mass !                qmin_coord   : coordinate frame for qmin !    Terminal  : none !    File      : none ! !  Output !    Arguments : swiftest_tp1P : pointer to head of active SWIFTER test particle structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL util_peri(lfirst, ntp, swiftest_tp1P, mu, msys, qmin_coord) ! !  Notes       : Adapted from Hal Levison's Swift routine util_peri.f ! !                If the coordinate system used is barycentric, then this routine assumes that the barycentric coordinates in the !                test particle structures are up-to-date and are not recomputed ! !********************************************************************************************************************************** SUBROUTINE util_peri ( lfirst , ntp , swiftest_tpA , mu , msys , qmin_coord ) ! Modules USE swiftest USE module_swiftest USE module_interfaces , EXCEPT_THIS_ONE => util_peri IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( IN ) :: lfirst INTEGER ( I4B ), INTENT ( IN ) :: ntp REAL ( DP ), INTENT ( IN ) :: mu , msys CHARACTER ( * ), INTENT ( IN ) :: qmin_coord TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA ! Internals INTEGER ( I4B ) :: i REAL ( DP ) :: vdotr , e ! Executable code IF ( lfirst ) THEN IF ( qmin_coord == \"HELIO\" ) THEN DO i = 1 , ntp IF ( swiftest_tpA % status ( i ) == ACTIVE ) THEN vdotr = DOT_PRODUCT ( swiftest_tpA % xh (:, i ), swiftest_tpA % vh (:, i )) IF ( vdotr > 0.0_DP ) THEN swiftest_tpA % isperi ( i ) = 1 ELSE swiftest_tpA % isperi ( i ) = - 1 END IF END IF END DO ELSE DO i = 1 , ntp IF ( swiftest_tpA % status ( i ) == ACTIVE ) THEN vdotr = DOT_PRODUCT ( swiftest_tpA % xb (:, i ), swiftest_tpA % vb (:, i )) IF ( vdotr > 0.0_DP ) THEN swiftest_tpA % isperi ( i ) = 1 ELSE swiftest_tpA % isperi ( i ) = - 1 END IF END IF END DO END IF ELSE IF ( qmin_coord == \"HELIO\" ) THEN DO i = 1 , ntp IF ( swiftest_tpA % status ( i ) == ACTIVE ) THEN vdotr = DOT_PRODUCT ( swiftest_tpA % xh (:, i ), swiftest_tpA % vh (:, i )) IF ( swiftest_tpA % isperi ( i ) == - 1 ) THEN IF ( vdotr >= 0.0_DP ) THEN swiftest_tpA % isperi ( i ) = 0 CALL orbel_xv2aeq ( swiftest_tpA % xh (:, i ), swiftest_tpA % vh (:, i ), mu , & swiftest_tpA % atp ( i ), e , swiftest_tpA % peri ( i )) END IF ELSE IF ( vdotr > 0.0_DP ) THEN swiftest_tpA % isperi ( i ) = 1 ELSE swiftest_tpA % isperi ( i ) = - 1 END IF END IF END IF END DO ELSE DO i = 1 , ntp IF ( swiftest_tpA % status ( i ) == ACTIVE ) THEN vdotr = DOT_PRODUCT ( swiftest_tpA % xb (:, i ), swiftest_tpA % vb (:, i )) IF ( swiftest_tpA % isperi ( i ) == - 1 ) THEN IF ( vdotr >= 0.0_DP ) THEN swiftest_tpA % isperi ( i ) = 0 CALL orbel_xv2aeq ( swiftest_tpA % xb (:, i ), swiftest_tpA % vb (:, i ), msys , & swiftest_tpA % atp ( i ), e , swiftest_tpA % peri ( i )) END IF ELSE IF ( vdotr > 0.0_DP ) THEN swiftest_tpA % isperi ( i ) = 1 ELSE swiftest_tpA % isperi ( i ) = - 1 END IF END IF END IF END DO END IF END IF RETURN END SUBROUTINE util_peri !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/util_peri.f90.html"},{"title":"util_hills.f90 – swiftest","text":"Unit Name   : util_hills\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : util\n  Language    : Fortran 90/95 Description : Compute Hill sphere radii of planets Input\n    Arguments : npl          : number of planets\n                swifter_pl1P : pointer to head of SWIFTER planet structure linked-list\n    Terminal  : none\n    File      : none Output\n    Arguments : swifter_pl1P : pointer to head of SWIFTER planet structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL util_hills(npl, swifter_pl1P) Notes       : Adapted from Hal Levison's Swift routine util_hills.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~util_hills.f90~~EfferentGraph sourcefile~util_hills.f90 util_hills.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~util_hills.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~util_hills.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_hills.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines util_hills Source Code util_hills.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : util_hills !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : util !  Language    : Fortran 90/95 ! !  Description : Compute Hill sphere radii of planets ! !  Input !    Arguments : npl          : number of planets !                swifter_pl1P : pointer to head of SWIFTER planet structure linked-list !    Terminal  : none !    File      : none ! !  Output !    Arguments : swifter_pl1P : pointer to head of SWIFTER planet structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL util_hills(npl, swifter_pl1P) ! !  Notes       : Adapted from Hal Levison's Swift routine util_hills.f ! !********************************************************************************************************************************** SUBROUTINE util_hills ( npl , swiftest_plA ) ! Modules USE swiftest USE module_swiftest USE module_interfaces , EXCEPT_THIS_ONE => util_hills IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA ! Internals INTEGER ( I4B ) :: i REAL ( DP ) :: msun , mp , mu , energy , ap , r , v2 ! Executable code msun = swiftest_plA % mass ( 1 ) DO i = 2 , npl mp = swiftest_plA % mass ( i ) IF ( mp > 0.0_DP ) THEN mu = msun + mp r = SQRT ( DOT_PRODUCT ( swiftest_plA % xh (:, i ), swiftest_plA % xh (:, i ))) v2 = DOT_PRODUCT ( swiftest_plA % vh (:, i ), swiftest_plA % vh (:, i )) energy = 0.5_DP * v2 - mu / r ap = - 0.5_DP * mu / energy swiftest_plA % rhill ( i ) = ap * ((( mp / mu ) / 3.0_DP ) ** ( 1.0_DP / 3.0_DP )) ELSE swiftest_plA % rhill ( i ) = 0.0_DP END IF END DO RETURN END SUBROUTINE util_hills !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/util_hills.f90.html"},{"title":"util_sort_dp.f90 – swiftest","text":"Unit Name   : util_sort_dp\n  Unit Type   : subroutine\n  Project     : Swifter\n  Package     : util\n  Language    : Fortran 90/95 Description : Sort input double precision array into ascending numerical order using Quicksort algorithm Input\n    Arguments : arr : array to sort\n    Terminal  : none\n    File      : none Output\n    Arguments : arr : sorted array\n    Terminal  : error message\n    File      : none Invocation  : CALL util_sort(arr) Notes       : Adapted from Numerical Recipes in Fortran 90: The Art of Parallel Scientific Computing, by Press, Teukolsky,\n                Vetterling, and Flannery, 2nd ed., pp. 1169-70 Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~util_sort_dp.f90~~EfferentGraph sourcefile~util_sort_dp.f90 util_sort_dp.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~util_sort_dp.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_sort_dp.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines util_sort_dp Source Code util_sort_dp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : util_sort_dp !  Unit Type   : subroutine !  Project     : Swifter !  Package     : util !  Language    : Fortran 90/95 ! !  Description : Sort input double precision array into ascending numerical order using Quicksort algorithm ! !  Input !    Arguments : arr : array to sort !    Terminal  : none !    File      : none ! !  Output !    Arguments : arr : sorted array !    Terminal  : error message !    File      : none ! !  Invocation  : CALL util_sort(arr) ! !  Notes       : Adapted from Numerical Recipes in Fortran 90: The Art of Parallel Scientific Computing, by Press, Teukolsky, !                Vetterling, and Flannery, 2nd ed., pp. 1169-70 ! !********************************************************************************************************************************** SUBROUTINE util_sort_dp ( arr ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => util_sort_dp IMPLICIT NONE ! Arguments REAL ( DP ), DIMENSION (:), INTENT ( INOUT ) :: arr ! Internals INTEGER ( I4B ), PARAMETER :: NN = 15 , NSTACK = 50 REAL ( DP ) :: a , dum INTEGER ( I4B ) :: n , k , i , j , jstack , l , r INTEGER ( I4B ), DIMENSION ( NSTACK ) :: istack ! Executable code n = SIZE ( arr ) jstack = 0 l = 1 r = n DO IF (( r - l ) < NN ) THEN DO j = l + 1 , r a = arr ( j ) DO i = j - 1 , l , - 1 IF ( arr ( i ) <= a ) EXIT arr ( i + 1 ) = arr ( i ) END DO arr ( i + 1 ) = a END DO IF ( jstack == 0 ) RETURN r = istack ( jstack ) l = istack ( jstack - 1 ) jstack = jstack - 2 ELSE k = ( l + r ) / 2 dum = arr ( k ); arr ( k ) = arr ( l + 1 ); arr ( l + 1 ) = dum IF ( arr ( l ) > arr ( r )) THEN dum = arr ( l ); arr ( l ) = arr ( r ); arr ( r ) = dum END IF IF ( arr ( l + 1 ) > arr ( r )) THEN dum = arr ( l + 1 ); arr ( l + 1 ) = arr ( r ); arr ( r ) = dum END IF IF ( arr ( l ) > arr ( l + 1 )) THEN dum = arr ( l ); arr ( l ) = arr ( l + 1 ); arr ( l + 1 ) = dum END IF i = l + 1 j = r a = arr ( l + 1 ) DO DO i = i + 1 IF ( arr ( i ) >= a ) EXIT END DO DO j = j - 1 IF ( arr ( j ) <= a ) EXIT END DO IF ( j < i ) EXIT dum = arr ( i ); arr ( i ) = arr ( j ); arr ( j ) = dum END DO arr ( l + 1 ) = arr ( j ) arr ( j ) = a jstack = jstack + 2 IF ( jstack > NSTACK ) THEN WRITE ( * , * ) \"SWIFTER Error:\" WRITE ( * , * ) \"   NSTACK too small in util_sort_i4b\" CALL util_exit ( FAILURE ) END IF IF (( r - i + 1 ) >= ( j - l )) THEN istack ( jstack ) = r istack ( jstack - 1 ) = i r = j - 1 ELSE istack ( jstack ) = j - 1 istack ( jstack - 1 ) = l l = i END IF END IF END DO RETURN END SUBROUTINE util_sort_dp !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/util_sort_dp.f90.html"},{"title":"util_toupper.f90 – swiftest","text":"Unit Name   : util_toupper\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : util\n  Language    : Fortran 90/95 Description : Convert string to uppercase Input\n    Arguments : string : string to convert\n    Terminal  : none\n    File      : none Output\n    Arguments : string : converted string\n    Terminal  : none\n    File      : none Invocation  : CALL util_toupper(string) Notes       : Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~util_toupper.f90~~EfferentGraph sourcefile~util_toupper.f90 util_toupper.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~util_toupper.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_toupper.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines util_toupper Source Code util_toupper.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : util_toupper !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : util !  Language    : Fortran 90/95 ! !  Description : Convert string to uppercase ! !  Input !    Arguments : string : string to convert !    Terminal  : none !    File      : none ! !  Output !    Arguments : string : converted string !    Terminal  : none !    File      : none ! !  Invocation  : CALL util_toupper(string) ! !  Notes       : ! !********************************************************************************************************************************** SUBROUTINE util_toupper ( string ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => util_toupper IMPLICIT NONE ! Arguments CHARACTER ( * ), INTENT ( INOUT ) :: string ! Internals INTEGER ( I4B ) :: i , length , idx ! Executable code length = LEN ( string ) DO i = 1 , length idx = IACHAR ( string ( i : i )) IF (( idx >= LOWERCASE_BEGIN ) . AND . ( idx <= LOWERCASE_END )) THEN idx = idx + UPPERCASE_OFFSET string ( i : i ) = ACHAR ( idx ) END IF END DO RETURN END SUBROUTINE util_toupper !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/util_toupper.f90.html"},{"title":"util_resize_pl.f90 – swiftest","text":"Unit Name   : util_resize_pl\n  Unit Type   : subroutine\n  Project     : Swifter\n  Package     : util\n  Language    : Fortran 90/95 Description : Index input real array into ascending numerical order using Quicksort algorithm Input\n    Arguments : arr   : array to index\n    Terminal  : none\n    File      : none Output\n    Arguments : index : index table for sorted array\n    Terminal  : error message\n    File      : none Invocation  : CALL util_resize_pl(symba_plA, npl) Notes       : Adapted from Numerical Recipes in Fortran 90: The Art of Parallel Scientific Computing, by Press, Teukolsky,\n                Vetterling, and Flannery, 2nd ed., pp. 1173-4 Author(s)   : C.Wishard and J.Pouplin Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~util_resize_pl.f90~~EfferentGraph sourcefile~util_resize_pl.f90 util_resize_pl.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~util_resize_pl.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~util_resize_pl.f90->sourcefile~module_symba.f90 sourcefile~module_nrutil.f90 module_nrutil.f90 sourcefile~util_resize_pl.f90->sourcefile~module_nrutil.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~util_resize_pl.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~util_resize_pl.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftestalloc.f90 module_swiftestalloc.f90 sourcefile~util_resize_pl.f90->sourcefile~module_swiftestalloc.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_resize_pl.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_nrutil.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftestalloc.f90->sourcefile~module_swiftest.f90 sourcefile~module_swiftestalloc.f90->sourcefile~module_symba.f90 sourcefile~module_swiftestalloc.f90->sourcefile~module_helio.f90 sourcefile~module_swiftestalloc.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines util_resize_pl Source Code util_resize_pl.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : util_resize_pl !  Unit Type   : subroutine !  Project     : Swifter !  Package     : util !  Language    : Fortran 90/95 ! !  Description : Index input real array into ascending numerical order using Quicksort algorithm ! !  Input !    Arguments : arr   : array to index !    Terminal  : none !    File      : none ! !  Output !    Arguments : index : index table for sorted array !    Terminal  : error message !    File      : none ! !  Invocation  : CALL util_resize_pl(symba_plA, npl) ! !  Notes       : Adapted from Numerical Recipes in Fortran 90: The Art of Parallel Scientific Computing, by Press, Teukolsky, !                Vetterling, and Flannery, 2nd ed., pp. 1173-4 ! !********************************************************************************************************************************** SUBROUTINE util_resize_pl ( symba_plA , npl_new , npl_old ) ! Modules USE swiftest USE module_symba USE module_swiftest USE module_helio USE module_nrutil USE module_swiftestalloc USE module_interfaces , EXCEPT_THIS_ONE => util_resize_pl IMPLICIT NONE ! Arguments TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA INTEGER ( I4B ), INTENT ( IN ) :: npl_old , npl_new ! Internals TYPE ( symba_pl ) :: new_symba_plA ! Executable code IF ( npl_new >= npl_old ) THEN CALL symba_pl_allocate ( new_symba_plA , npl_new ) new_symba_plA % helio % swiftest % name ( 1 : npl_old ) = symba_plA % helio % swiftest % name ( 1 : npl_old ) new_symba_plA % helio % swiftest % status ( 1 : npl_old ) = symba_plA % helio % swiftest % status ( 1 : npl_old ) new_symba_plA % helio % swiftest % mass ( 1 : npl_old ) = symba_plA % helio % swiftest % mass ( 1 : npl_old ) new_symba_plA % helio % swiftest % radius ( 1 : npl_old ) = symba_plA % helio % swiftest % radius ( 1 : npl_old ) new_symba_plA % helio % swiftest % xh ( 1 , 1 : npl_old ) = symba_plA % helio % swiftest % xh ( 1 , 1 : npl_old ) new_symba_plA % helio % swiftest % xh ( 2 , 1 : npl_old ) = symba_plA % helio % swiftest % xh ( 2 , 1 : npl_old ) new_symba_plA % helio % swiftest % xh ( 3 , 1 : npl_old ) = symba_plA % helio % swiftest % xh ( 3 , 1 : npl_old ) new_symba_plA % helio % swiftest % vh ( 1 , 1 : npl_old ) = symba_plA % helio % swiftest % vh ( 1 , 1 : npl_old ) new_symba_plA % helio % swiftest % vh ( 2 , 1 : npl_old ) = symba_plA % helio % swiftest % vh ( 2 , 1 : npl_old ) new_symba_plA % helio % swiftest % vh ( 3 , 1 : npl_old ) = symba_plA % helio % swiftest % vh ( 3 , 1 : npl_old ) new_symba_plA % helio % swiftest % rhill ( 1 : npl_old ) = symba_plA % helio % swiftest % rhill ( 1 : npl_old ) new_symba_plA % helio % swiftest % xb ( 1 , 1 : npl_old ) = symba_plA % helio % swiftest % xb ( 1 , 1 : npl_old ) new_symba_plA % helio % swiftest % xb ( 2 , 1 : npl_old ) = symba_plA % helio % swiftest % xb ( 2 , 1 : npl_old ) new_symba_plA % helio % swiftest % xb ( 3 , 1 : npl_old ) = symba_plA % helio % swiftest % xb ( 3 , 1 : npl_old ) new_symba_plA % helio % swiftest % vb ( 1 , 1 : npl_old ) = symba_plA % helio % swiftest % vb ( 1 , 1 : npl_old ) new_symba_plA % helio % swiftest % vb ( 2 , 1 : npl_old ) = symba_plA % helio % swiftest % vb ( 2 , 1 : npl_old ) new_symba_plA % helio % swiftest % vb ( 3 , 1 : npl_old ) = symba_plA % helio % swiftest % vb ( 3 , 1 : npl_old ) new_symba_plA % helio % ah ( 1 , 1 : npl_old ) = symba_plA % helio % ah ( 1 , 1 : npl_old ) new_symba_plA % helio % ah ( 2 , 1 : npl_old ) = symba_plA % helio % ah ( 2 , 1 : npl_old ) new_symba_plA % helio % ah ( 3 , 1 : npl_old ) = symba_plA % helio % ah ( 3 , 1 : npl_old ) END IF IF ( npl_new < npl_old ) THEN CALL symba_pl_allocate ( new_symba_plA , npl_new ) new_symba_plA % helio % swiftest % name ( 1 : npl_new ) = symba_plA % helio % swiftest % name ( 1 : npl_new ) new_symba_plA % helio % swiftest % status ( 1 : npl_new ) = symba_plA % helio % swiftest % status ( 1 : npl_new ) new_symba_plA % helio % swiftest % mass ( 1 : npl_new ) = symba_plA % helio % swiftest % mass ( 1 : npl_new ) new_symba_plA % helio % swiftest % radius ( 1 : npl_new ) = symba_plA % helio % swiftest % radius ( 1 : npl_new ) new_symba_plA % helio % swiftest % xh ( 1 , 1 : npl_new ) = symba_plA % helio % swiftest % xh ( 1 , 1 : npl_new ) new_symba_plA % helio % swiftest % xh ( 2 , 1 : npl_new ) = symba_plA % helio % swiftest % xh ( 2 , 1 : npl_new ) new_symba_plA % helio % swiftest % xh ( 3 , 1 : npl_new ) = symba_plA % helio % swiftest % xh ( 3 , 1 : npl_new ) new_symba_plA % helio % swiftest % vh ( 1 , 1 : npl_new ) = symba_plA % helio % swiftest % vh ( 1 , 1 : npl_new ) new_symba_plA % helio % swiftest % vh ( 2 , 1 : npl_new ) = symba_plA % helio % swiftest % vh ( 2 , 1 : npl_new ) new_symba_plA % helio % swiftest % vh ( 3 , 1 : npl_new ) = symba_plA % helio % swiftest % vh ( 3 , 1 : npl_new ) new_symba_plA % helio % swiftest % rhill ( 1 : npl_new ) = symba_plA % helio % swiftest % rhill ( 1 : npl_new ) new_symba_plA % helio % swiftest % xb ( 1 , 1 : npl_new ) = symba_plA % helio % swiftest % xb ( 1 , 1 : npl_new ) new_symba_plA % helio % swiftest % xb ( 2 , 1 : npl_new ) = symba_plA % helio % swiftest % xb ( 2 , 1 : npl_new ) new_symba_plA % helio % swiftest % xb ( 3 , 1 : npl_new ) = symba_plA % helio % swiftest % xb ( 3 , 1 : npl_new ) new_symba_plA % helio % swiftest % vb ( 1 , 1 : npl_new ) = symba_plA % helio % swiftest % vb ( 1 , 1 : npl_new ) new_symba_plA % helio % swiftest % vb ( 2 , 1 : npl_new ) = symba_plA % helio % swiftest % vb ( 2 , 1 : npl_new ) new_symba_plA % helio % swiftest % vb ( 3 , 1 : npl_new ) = symba_plA % helio % swiftest % vb ( 3 , 1 : npl_new ) new_symba_plA % helio % ah ( 1 , 1 : npl_new ) = symba_plA % helio % ah ( 1 , 1 : npl_old ) new_symba_plA % helio % ah ( 2 , 1 : npl_new ) = symba_plA % helio % ah ( 2 , 1 : npl_old ) new_symba_plA % helio % ah ( 3 , 1 : npl_new ) = symba_plA % helio % ah ( 3 , 1 : npl_old ) END IF CALL symba_pl_deallocate ( symba_plA ) CALL symba_pl_allocate ( symba_plA , npl_new ) symba_plA % helio % swiftest % name = new_symba_plA % helio % swiftest % name symba_plA % helio % swiftest % status = new_symba_plA % helio % swiftest % status symba_plA % helio % swiftest % mass = new_symba_plA % helio % swiftest % mass symba_plA % helio % swiftest % radius = new_symba_plA % helio % swiftest % radius symba_plA % helio % swiftest % xh = new_symba_plA % helio % swiftest % xh symba_plA % helio % swiftest % vh = new_symba_plA % helio % swiftest % vh symba_plA % helio % swiftest % rhill = new_symba_plA % helio % swiftest % rhill symba_plA % helio % swiftest % xb = new_symba_plA % helio % swiftest % xb symba_plA % helio % swiftest % vb = new_symba_plA % helio % swiftest % vb symba_plA % helio % ah = new_symba_plA % helio % ah CALL symba_pl_deallocate ( new_symba_plA ) RETURN END SUBROUTINE util_resize_pl !********************************************************************************************************************************** ! !  Author(s)   : C.Wishard and J.Pouplin ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/util_resize_pl.f90.html"},{"title":"util_index.f90 – swiftest","text":"Unit Name   : util_index\n  Unit Type   : subroutine\n  Project     : Swifter\n  Package     : util\n  Language    : Fortran 90/95 Description : Index input real array into ascending numerical order using Quicksort algorithm Input\n    Arguments : arr   : array to index\n    Terminal  : none\n    File      : none Output\n    Arguments : index : index table for sorted array\n    Terminal  : error message\n    File      : none Invocation  : CALL util_index(arr, index) Notes       : Adapted from Numerical Recipes in Fortran 90: The Art of Parallel Scientific Computing, by Press, Teukolsky,\n                Vetterling, and Flannery, 2nd ed., pp. 1173-4 Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~util_index.f90~~EfferentGraph sourcefile~util_index.f90 util_index.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~util_index.f90->sourcefile~module_interfaces.f90 sourcefile~module_nrutil.f90 module_nrutil.f90 sourcefile~util_index.f90->sourcefile~module_nrutil.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_index.f90->sourcefile~swiftest.f90 sourcefile~module_nrutil.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines util_index Source Code util_index.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : util_index !  Unit Type   : subroutine !  Project     : Swifter !  Package     : util !  Language    : Fortran 90/95 ! !  Description : Index input real array into ascending numerical order using Quicksort algorithm ! !  Input !    Arguments : arr   : array to index !    Terminal  : none !    File      : none ! !  Output !    Arguments : index : index table for sorted array !    Terminal  : error message !    File      : none ! !  Invocation  : CALL util_index(arr, index) ! !  Notes       : Adapted from Numerical Recipes in Fortran 90: The Art of Parallel Scientific Computing, by Press, Teukolsky, !                Vetterling, and Flannery, 2nd ed., pp. 1173-4 ! !********************************************************************************************************************************** SUBROUTINE util_index ( arr , index ) ! Modules USE swiftest USE module_nrutil USE module_interfaces , EXCEPT_THIS_ONE => util_index IMPLICIT NONE ! Arguments INTEGER ( I4B ), DIMENSION (:), INTENT ( OUT ) :: index REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: arr ! Internals INTEGER ( I4B ), PARAMETER :: NN = 15 , NSTACK = 50 INTEGER ( I4B ) :: n , k , i , j , indext , jstack , l , r , dum INTEGER ( I4B ), DIMENSION ( NSTACK ) :: istack REAL ( DP ) :: a ! Executable code n = SIZE ( arr ) IF ( n /= SIZE ( index )) THEN WRITE ( * , * ) \"SWIFTER Error:\" WRITE ( * , * ) \"   Array size mismatch in util_index\" CALL util_exit ( FAILURE ) END IF index = arth ( 1 , 1 , n ) jstack = 0 ! l is the counter ie 'the one we are at' l = 1 ! r is the length of the array ie 'the total number of particles' r = n DO IF (( r - l ) < NN ) THEN DO j = l + 1 , r indext = index ( j ) a = arr ( indext ) DO i = j - 1 , l , - 1 IF ( arr ( index ( i )) <= a ) EXIT index ( i + 1 ) = index ( i ) END DO index ( i + 1 ) = indext END DO IF ( jstack == 0 ) RETURN r = istack ( jstack ) l = istack ( jstack - 1 ) jstack = jstack - 2 ELSE k = ( l + r ) / 2 dum = index ( k ); index ( k ) = index ( l + 1 ); index ( l + 1 ) = dum ! if the mass of the particle we are at in our counting is greater than the mass of the last particle then put the particle we are at above the last one IF ( arr ( index ( l )) > arr ( index ( r ))) THEN dum = index ( l ); index ( l ) = index ( r ); index ( r ) = dum END IF ! if the mass of the particle above the one we are at in our counting is greater than the last particle then put that particle above the last one IF ( arr ( index ( l + 1 )) > arr ( index ( r ))) THEN dum = index ( l + 1 ); index ( l + 1 ) = index ( r ); index ( r ) = dum END IF ! if the mass of teh particle we are at in our counting is greater than the one above it, then put it above the one above it IF ( arr ( index ( l )) > arr ( index ( l + 1 ))) THEN dum = index ( l ); index ( l ) = index ( l + 1 ); index ( l + 1 ) = dum END IF i = l + 1 j = r indext = index ( l + 1 ) a = arr ( indext ) DO DO i = i + 1 IF ( arr ( index ( i )) >= a ) EXIT END DO DO j = j - 1 IF ( arr ( index ( j )) <= a ) EXIT END DO IF ( j < i ) EXIT dum = index ( i ); index ( i ) = index ( j ); index ( j ) = dum END DO index ( l + 1 ) = index ( j ) index ( j ) = indext jstack = jstack + 2 IF ( jstack > NSTACK ) THEN WRITE ( * , * ) \"SWIFTER Error:\" WRITE ( * , * ) \"   NSTACK too small in util_sort\" CALL util_exit ( FAILURE ) END IF IF (( r - i + 1 ) >= ( j - l )) THEN istack ( jstack ) = r istack ( jstack - 1 ) = i r = j - 1 ELSE istack ( jstack ) = j - 1 istack ( jstack - 1 ) = l l = i END IF END IF END DO RETURN END SUBROUTINE util_index !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/util_index.f90.html"},{"title":"util_version.f90 – swiftest","text":"Unit Name   : util_version\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : util\n  Language    : Fortran 90/95 Description : Print program version information to terminal Input\n    Arguments : none\n    Terminal  : none\n    File      : none Output\n    Arguments : none\n    Terminal  : Program version information\n    File      : none Invocation  : CALL util_version Notes       : Adapted from Hal Levison's Swift routine util_version.f Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~util_version.f90~~EfferentGraph sourcefile~util_version.f90 util_version.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~util_version.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines util_version Source Code util_version.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : util_version !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : util !  Language    : Fortran 90/95 ! !  Description : Print program version information to terminal ! !  Input !    Arguments : none !    Terminal  : none !    File      : none ! !  Output !    Arguments : none !    Terminal  : Program version information !    File      : none ! !  Invocation  : CALL util_version ! !  Notes       : Adapted from Hal Levison's Swift routine util_version.f ! !********************************************************************************************************************************** SUBROUTINE util_version ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => util_version IMPLICIT NONE ! Executable code WRITE ( * , 100 ) VERSION_NUMBER 100 FORMAT ( / , \"************* SWIFTEST: Version \" , F3 . 1 , \" *************\" , // , & \"BASED OFF OF SWIFTER:\" , // , & \"Authors:\" , // , & \"    Martin Duncan: Queen's University\" , / , & \"    Hal Levison  : Southwest Research Institute\" , // , & \"Please address comments and questions to:\" , // , & \"    Hal Levison or David Kaufmann\" , / , & \"    Department of Space Studies\" , / , & \"    Southwest Research Institute\" , / , & \"    1050 Walnut Street, Suite 400\" , / , & \"    Boulder, Colorado  80302\" , / , & \"    303-546-0290 (HFL), 720-240-0119 (DEK)\" , / , & \"    303-546-9687 (fax)\" , / , & \"    hal@gort.boulder.swri.edu (HFL)\" , / , & \"    kaufmann@boulder.swri.edu (DEK)\" , // , & \"************************************************\" , / ) RETURN END SUBROUTINE util_version !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/util_version.f90.html"},{"title":"util_sort_sp.f90 – swiftest","text":"Unit Name   : util_sort_sp\n  Unit Type   : subroutine\n  Project     : Swifter\n  Package     : util\n  Language    : Fortran 90/95 Description : Sort input single precision array into ascending numerical order using Quicksort algorithm Input\n    Arguments : arr : array to sort\n    Terminal  : none\n    File      : none Output\n    Arguments : arr : sorted array\n    Terminal  : error message\n    File      : none Invocation  : CALL util_sort(arr) Notes       : Adapted from Numerical Recipes in Fortran 90: The Art of Parallel Scientific Computing, by Press, Teukolsky,\n                Vetterling, and Flannery, 2nd ed., pp. 1169-70 Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~util_sort_sp.f90~~EfferentGraph sourcefile~util_sort_sp.f90 util_sort_sp.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~util_sort_sp.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_sort_sp.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines util_sort_sp Source Code util_sort_sp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : util_sort_sp !  Unit Type   : subroutine !  Project     : Swifter !  Package     : util !  Language    : Fortran 90/95 ! !  Description : Sort input single precision array into ascending numerical order using Quicksort algorithm ! !  Input !    Arguments : arr : array to sort !    Terminal  : none !    File      : none ! !  Output !    Arguments : arr : sorted array !    Terminal  : error message !    File      : none ! !  Invocation  : CALL util_sort(arr) ! !  Notes       : Adapted from Numerical Recipes in Fortran 90: The Art of Parallel Scientific Computing, by Press, Teukolsky, !                Vetterling, and Flannery, 2nd ed., pp. 1169-70 ! !********************************************************************************************************************************** SUBROUTINE util_sort_sp ( arr ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => util_sort_sp IMPLICIT NONE ! Arguments REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: arr ! Internals INTEGER ( I4B ), PARAMETER :: NN = 15 , NSTACK = 50 REAL ( SP ) :: a , dum INTEGER ( I4B ) :: n , k , i , j , jstack , l , r INTEGER ( I4B ), DIMENSION ( NSTACK ) :: istack ! Executable code n = SIZE ( arr ) jstack = 0 l = 1 r = n DO IF (( r - l ) < NN ) THEN DO j = l + 1 , r a = arr ( j ) DO i = j - 1 , l , - 1 IF ( arr ( i ) <= a ) EXIT arr ( i + 1 ) = arr ( i ) END DO arr ( i + 1 ) = a END DO IF ( jstack == 0 ) RETURN r = istack ( jstack ) l = istack ( jstack - 1 ) jstack = jstack - 2 ELSE k = ( l + r ) / 2 dum = arr ( k ); arr ( k ) = arr ( l + 1 ); arr ( l + 1 ) = dum IF ( arr ( l ) > arr ( r )) THEN dum = arr ( l ); arr ( l ) = arr ( r ); arr ( r ) = dum END IF IF ( arr ( l + 1 ) > arr ( r )) THEN dum = arr ( l + 1 ); arr ( l + 1 ) = arr ( r ); arr ( r ) = dum END IF IF ( arr ( l ) > arr ( l + 1 )) THEN dum = arr ( l ); arr ( l ) = arr ( l + 1 ); arr ( l + 1 ) = dum END IF i = l + 1 j = r a = arr ( l + 1 ) DO DO i = i + 1 IF ( arr ( i ) >= a ) EXIT END DO DO j = j - 1 IF ( arr ( j ) <= a ) EXIT END DO IF ( j < i ) EXIT dum = arr ( i ); arr ( i ) = arr ( j ); arr ( j ) = dum END DO arr ( l + 1 ) = arr ( j ) arr ( j ) = a jstack = jstack + 2 IF ( jstack > NSTACK ) THEN WRITE ( * , * ) \"SWIFTER Error:\" WRITE ( * , * ) \"   NSTACK too small in util_sort_i4b\" CALL util_exit ( FAILURE ) END IF IF (( r - i + 1 ) >= ( j - l )) THEN istack ( jstack ) = r istack ( jstack - 1 ) = i r = j - 1 ELSE istack ( jstack ) = j - 1 istack ( jstack - 1 ) = l l = i END IF END IF END DO RETURN END SUBROUTINE util_sort_sp !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/util_sort_sp.f90.html"},{"title":"util_valid.f90 – swiftest","text":"Unit Name   : util_valid\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : util\n  Language    : Fortran 90/95 Description : Validate planet and test particle ids Input\n    Arguments : npl          : number of planets\n                ntp          : number of active test particles\n                swifter_pl1P : pointer to head of SWIFTER planet structure linked-list\n                swifter_tp1P : pointer to head of active SWIFTER test particle structure linked-list\n    Terminal  : none\n    File      : none Output\n    Arguments : none\n    Terminal  : error message\n    File      : none Invocation  : CALL util_valid(npl, ntp, swifter_pl1P, swifter_tp1P) Notes       : Subroutine causes program to exit with error if any ids are not unique Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~util_valid.f90~~EfferentGraph sourcefile~util_valid.f90 util_valid.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~util_valid.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~util_valid.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines util_valid Source Code util_valid.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : util_valid !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : util !  Language    : Fortran 90/95 ! !  Description : Validate planet and test particle ids ! !  Input !    Arguments : npl          : number of planets !                ntp          : number of active test particles !                swifter_pl1P : pointer to head of SWIFTER planet structure linked-list !                swifter_tp1P : pointer to head of active SWIFTER test particle structure linked-list !    Terminal  : none !    File      : none ! !  Output !    Arguments : none !    Terminal  : error message !    File      : none ! !  Invocation  : CALL util_valid(npl, ntp, swifter_pl1P, swifter_tp1P) ! !  Notes       : Subroutine causes program to exit with error if any ids are not unique ! !********************************************************************************************************************************** SUBROUTINE util_valid ( npl , ntp , swiftest_plA , swiftest_tpA ) ! Modules USE swiftest USE module_swiftest USE module_interfaces , EXCEPT_THIS_ONE => util_valid IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl , ntp TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA ! Internals INTEGER ( I4B ) :: i INTEGER ( I4B ), DIMENSION (:), ALLOCATABLE :: idarr ! Executable code ALLOCATE ( idarr ( npl + ntp )) DO i = 1 , npl idarr ( i ) = swiftest_plA % name ( i ) END DO DO i = 1 , ntp idarr ( npl + i ) = swiftest_tpA % name ( i ) END DO CALL util_sort ( idarr ) DO i = 1 , npl + ntp - 1 IF ( idarr ( i ) == idarr ( i + 1 )) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   More than one body/particle has id = \" , idarr ( i ) CALL util_exit ( FAILURE ) END IF END DO DEALLOCATE ( idarr ) RETURN END SUBROUTINE util_valid !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/util_valid.f90.html"},{"title":"util_exit.f90 – swiftest","text":"Unit Name   : util_exit\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : util\n  Language    : Fortran 90/95 Description : Print termination message and exit program Input\n    Arguments : code : exit code\n    Terminal  : none\n    File      : none Output\n    Arguments : none\n    Terminal  : termination message\n    File      : none Invocation  : CALL util_exit(code) Notes       : Adapted from Hal Levison's Swift routine util_exit.f Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~util_exit.f90~~EfferentGraph sourcefile~util_exit.f90 util_exit.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~util_exit.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines util_exit Source Code util_exit.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : util_exit !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : util !  Language    : Fortran 90/95 ! !  Description : Print termination message and exit program ! !  Input !    Arguments : code : exit code !    Terminal  : none !    File      : none ! !  Output !    Arguments : none !    Terminal  : termination message !    File      : none ! !  Invocation  : CALL util_exit(code) ! !  Notes       : Adapted from Hal Levison's Swift routine util_exit.f ! !********************************************************************************************************************************** SUBROUTINE util_exit ( code ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => util_exit IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: code ! Executable code IF ( code == SUCCESS ) THEN WRITE ( * , 100 ) VERSION_NUMBER ELSE WRITE ( * , 200 ) VERSION_NUMBER END IF 100 FORMAT ( / , \"Normal termination of SWIFTEST (Version \" , F3 . 1 , \")\" ) 200 FORMAT ( / , \"Terminating SWIFTEST (Version \" , F3 . 1 , \") due to ERROR!!\" ) WRITE ( * , 300 ) \"------------------------------------------------\" 300 FORMAT ( A ) STOP END SUBROUTINE util_exit !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/util_exit.f90.html"},{"title":"util_sort_i4b.f90 – swiftest","text":"Unit Name   : util_sort_i4b\n  Unit Type   : subroutine\n  Project     : Swifter\n  Package     : util\n  Language    : Fortran 90/95 Description : Sort input integer array into ascending numerical order using Quicksort algorithm Input\n    Arguments : arr : array to sort\n    Terminal  : none\n    File      : none Output\n    Arguments : arr : sorted array\n    Terminal  : error message\n    File      : none Invocation  : CALL util_sort(arr) Notes       : Adapted from Numerical Recipes in Fortran 90: The Art of Parallel Scientific Computing, by Press, Teukolsky,\n                Vetterling, and Flannery, 2nd ed., pp. 1169-70 Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~util_sort_i4b.f90~~EfferentGraph sourcefile~util_sort_i4b.f90 util_sort_i4b.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~util_sort_i4b.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_sort_i4b.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines util_sort_i4b Source Code util_sort_i4b.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : util_sort_i4b !  Unit Type   : subroutine !  Project     : Swifter !  Package     : util !  Language    : Fortran 90/95 ! !  Description : Sort input integer array into ascending numerical order using Quicksort algorithm ! !  Input !    Arguments : arr : array to sort !    Terminal  : none !    File      : none ! !  Output !    Arguments : arr : sorted array !    Terminal  : error message !    File      : none ! !  Invocation  : CALL util_sort(arr) ! !  Notes       : Adapted from Numerical Recipes in Fortran 90: The Art of Parallel Scientific Computing, by Press, Teukolsky, !                Vetterling, and Flannery, 2nd ed., pp. 1169-70 ! !********************************************************************************************************************************** SUBROUTINE util_sort_i4b ( arr ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => util_sort_i4b IMPLICIT NONE ! Arguments INTEGER ( I4B ), DIMENSION (:), INTENT ( INOUT ) :: arr ! Internals INTEGER ( I4B ), PARAMETER :: NN = 15 , NSTACK = 50 INTEGER ( I4B ) :: a , n , k , i , j , jstack , l , r , dum INTEGER ( I4B ), DIMENSION ( NSTACK ) :: istack ! Executable code n = SIZE ( arr ) jstack = 0 l = 1 r = n DO IF (( r - l ) < NN ) THEN DO j = l + 1 , r a = arr ( j ) DO i = j - 1 , l , - 1 IF ( arr ( i ) <= a ) EXIT arr ( i + 1 ) = arr ( i ) END DO arr ( i + 1 ) = a END DO IF ( jstack == 0 ) RETURN r = istack ( jstack ) l = istack ( jstack - 1 ) jstack = jstack - 2 ELSE k = ( l + r ) / 2 dum = arr ( k ); arr ( k ) = arr ( l + 1 ); arr ( l + 1 ) = dum IF ( arr ( l ) > arr ( r )) THEN dum = arr ( l ); arr ( l ) = arr ( r ); arr ( r ) = dum END IF IF ( arr ( l + 1 ) > arr ( r )) THEN dum = arr ( l + 1 ); arr ( l + 1 ) = arr ( r ); arr ( r ) = dum END IF IF ( arr ( l ) > arr ( l + 1 )) THEN dum = arr ( l ); arr ( l ) = arr ( l + 1 ); arr ( l + 1 ) = dum END IF i = l + 1 j = r a = arr ( l + 1 ) DO DO i = i + 1 IF ( arr ( i ) >= a ) EXIT END DO DO j = j - 1 IF ( arr ( j ) <= a ) EXIT END DO IF ( j < i ) EXIT dum = arr ( i ); arr ( i ) = arr ( j ); arr ( j ) = dum END DO arr ( l + 1 ) = arr ( j ) arr ( j ) = a jstack = jstack + 2 IF ( jstack > NSTACK ) THEN WRITE ( * , * ) \"SWIFTER Error:\" WRITE ( * , * ) \"   NSTACK too small in util_sort_i4b\" CALL util_exit ( FAILURE ) END IF IF (( r - i + 1 ) >= ( j - l )) THEN istack ( jstack ) = r istack ( jstack - 1 ) = i r = j - 1 ELSE istack ( jstack ) = j - 1 istack ( jstack - 1 ) = l l = i END IF END IF END DO RETURN END SUBROUTINE util_sort_i4b !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/util_sort_i4b.f90.html"},{"title":"util_kahan_sum.f90 – swiftest","text":"This file depends on sourcefile~~util_kahan_sum.f90~~EfferentGraph sourcefile~util_kahan_sum.f90 util_kahan_sum.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~util_kahan_sum.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_kahan_sum.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Functions util_kahan_sum Source Code util_kahan_sum.f90 Source Code FUNCTION util_kahan_sum ( xsum_current , xi , xerror ) RESULT ( xsum_new ) !------------------------------------------------------------------------------------------- !\t\t\t\t\tUTIL_KAHAN_SUM.F90 !------------------------------------------------------------------------------------------- ! Sums two floating point scalars more accurately utilitizing the Kahan summation formula ! This function is designed to be used inside a do or while loop, where the initial value of ! of xsum_current is initialized appropriately and the initial value of xerror is 0.0_dp ! ! N.B. Use this function if the summation is being performed for more than *three* terms ! ! Input:  xsum_current - Current value of the sum !         xi           - i-th term to be added to the sum !         xerror       - Error term from the previous term of the sum ! ! Output: xsum_new     - The updated value of the sum !         xerror       - The error term for this term of the sum ! ! By: Chris Capobianco ! Date: 05/04/09 !       01/26/10 D. Minton - added to SWIFTER and modified types !------------------------------------------------------------------------------------------- ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => util_kahan_sum implicit none ! Input/Output variables real ( dp ), intent ( in ) :: xsum_current , xi real ( dp ), intent ( inout ) :: xerror real ( dp ) :: xsum_new ! Internal variables real ( dp ) :: low_bits low_bits = xi - xerror xsum_new = xsum_current + low_bits xerror = ( xsum_new - xsum_current ) - low_bits return end function util_kahan_sum","tags":"","loc":"sourcefile/util_kahan_sum.f90.html"},{"title":"discard_pl_close.f90 – swiftest","text":"Unit Name   : discard_pl_close\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : discard\n  Language    : Fortran 90/95 Description : Check to see if a test particle and planet are having, or will have within the next time step, an encounter such\n                that the separation distance r is less than some critical radius rcrit (or r 2 < rcrit 2 = r2crit) Input\n    Arguments : dx     : relative position of test particle with respect to planet\n                dv     : relative velocity of test particle with respect to planet\n                dt     : time step\n                r2crit : square of the boundary of the encounter region\n    Terminal  : none\n    File      : none Output\n    Arguments : iflag  : flag indicating encounter (0 = NO, 1 = YES)\n                r2min  : square of the smallest predicted separation distance\n    Terminal  : none\n    File      : none Invocation  : CALL discard_pl_close(dx, dv, dt, r2crit, iflag, r2min) Notes       : Adapted from Hal Levison's Swift routine discard_pl_close.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~discard_pl_close.f90~~EfferentGraph sourcefile~discard_pl_close.f90 discard_pl_close.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~discard_pl_close.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~discard_pl_close.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines discard_pl_close Source Code discard_pl_close.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : discard_pl_close !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : discard !  Language    : Fortran 90/95 ! !  Description : Check to see if a test particle and planet are having, or will have within the next time step, an encounter such !                that the separation distance r is less than some critical radius rcrit (or r**2 < rcrit**2 = r2crit) ! !  Input !    Arguments : dx     : relative position of test particle with respect to planet !                dv     : relative velocity of test particle with respect to planet !                dt     : time step !                r2crit : square of the boundary of the encounter region !    Terminal  : none !    File      : none ! !  Output !    Arguments : iflag  : flag indicating encounter (0 = NO, 1 = YES) !                r2min  : square of the smallest predicted separation distance !    Terminal  : none !    File      : none ! !  Invocation  : CALL discard_pl_close(dx, dv, dt, r2crit, iflag, r2min) ! !  Notes       : Adapted from Hal Levison's Swift routine discard_pl_close.f ! !********************************************************************************************************************************** SUBROUTINE discard_pl_close ( dx , dv , dt , r2crit , iflag , r2min ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => discard_pl_close IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( OUT ) :: iflag REAL ( DP ), INTENT ( IN ) :: dt , r2crit REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: dx , dv REAL ( DP ), INTENT ( OUT ) :: r2min ! Internals REAL ( DP ) :: r2 , v2 , vdotr , tmin ! Executable code r2 = DOT_PRODUCT ( dx (:), dx (:)) IF ( r2 <= r2crit ) THEN iflag = 1 ELSE vdotr = DOT_PRODUCT ( dx (:), dv (:)) IF ( vdotr > 0.0_DP ) THEN iflag = 0 ELSE v2 = DOT_PRODUCT ( dv (:), dv (:)) tmin = - vdotr / v2 IF ( tmin < dt ) THEN r2min = r2 - vdotr * vdotr / v2 ELSE r2min = r2 + 2.0_DP * vdotr * dt + v2 * dt * dt END IF r2min = MIN ( r2min , r2 ) IF ( r2min <= r2crit ) THEN iflag = 1 ELSE iflag = 0 END IF END IF END IF RETURN END SUBROUTINE discard_pl_close !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/discard_pl_close.f90.html"},{"title":"discard_sun.f90 – swiftest","text":"Unit Name   : discard_sun\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : discard\n  Language    : Fortran 90/95 Description : Check to see if test particles should be discarded based on their positions relative to the Sun\n                or because they are unbound from the system Input\n    Arguments : t            : time\n                ntp          : number of active test particles\n                msys         : total system mass\n                swifter_tp1P : pointer to head of active Swifter test particle structure linked-list\n                rmin         : minimum heliocentric radius for test particle\n                rmax         : maximum heliocentric radius for test particle\n                rmaxu        : maximum unbound heliocentric radius for test particle\n    Terminal  : none\n    File      : none Output\n    Arguments : swifter_tp1P : pointer to head of active Swifter test particle structure linked-list\n    Terminal  : status messages\n    File      : none Invocation  : CALL discard_sun(t, ntp, msys, swifter_tp1P, rmin, rmax, rmaxu) Notes       : Adapted from Hal Levison's Swift routine discard_sun.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~discard_sun.f90~~EfferentGraph sourcefile~discard_sun.f90 discard_sun.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~discard_sun.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~discard_sun.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~discard_sun.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines discard_sun Source Code discard_sun.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : discard_sun !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : discard !  Language    : Fortran 90/95 ! !  Description : Check to see if test particles should be discarded based on their positions relative to the Sun !                or because they are unbound from the system ! !  Input !    Arguments : t            : time !                ntp          : number of active test particles !                msys         : total system mass !                swifter_tp1P : pointer to head of active Swifter test particle structure linked-list !                rmin         : minimum heliocentric radius for test particle !                rmax         : maximum heliocentric radius for test particle !                rmaxu        : maximum unbound heliocentric radius for test particle !    Terminal  : none !    File      : none ! !  Output !    Arguments : swifter_tp1P : pointer to head of active Swifter test particle structure linked-list !    Terminal  : status messages !    File      : none ! !  Invocation  : CALL discard_sun(t, ntp, msys, swifter_tp1P, rmin, rmax, rmaxu) ! !  Notes       : Adapted from Hal Levison's Swift routine discard_sun.f ! !********************************************************************************************************************************** SUBROUTINE discard_sun ( t , ntp , msys , swiftest_tpA , rmin , rmax , rmaxu ) ! Modules USE swiftest USE module_swiftest USE module_interfaces , EXCEPT_THIS_ONE => discard_sun IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: ntp REAL ( DP ), INTENT ( IN ) :: t , msys , rmin , rmax , rmaxu TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA ! Internals INTEGER ( I4B ) :: i REAL ( DP ) :: energy , vb2 , rb2 , rh2 , rmin2 , rmax2 , rmaxu2 ! Executable code rmin2 = rmin * rmin rmax2 = rmax * rmax rmaxu2 = rmaxu * rmaxu DO i = 1 , ntp IF ( swiftest_tpA % status ( i ) == ACTIVE ) THEN rh2 = DOT_PRODUCT ( swiftest_tpA % xh (:, i ), swiftest_tpA % xh (:, i )) IF (( rmax >= 0.0_DP ) . AND . ( rh2 > rmax2 )) THEN swiftest_tpA % status ( i ) = DISCARDED_RMAX WRITE ( * , * ) \"Particle \" , swiftest_tpA % name ( i ), \" too far from Sun at t = \" , t ldiscard_tp = . TRUE . ELSE IF (( rmin >= 0.0_DP ) . AND . ( rh2 < rmin2 )) THEN swiftest_tpA % status ( i ) = DISCARDED_RMIN WRITE ( * , * ) \"Particle \" , swiftest_tpA % name ( i ), \" too close to Sun at t = \" , t ldiscard_tp = . TRUE . ELSE IF ( rmaxu >= 0.0_DP ) THEN rb2 = DOT_PRODUCT ( swiftest_tpA % xb (:, i ), swiftest_tpA % xb (:, i )) vb2 = DOT_PRODUCT ( swiftest_tpA % vb (:, i ), swiftest_tpA % vb (:, i )) energy = 0.5_DP * vb2 - msys / SQRT ( rb2 ) IF (( energy > 0.0_DP ) . AND . ( rb2 > rmaxu2 )) THEN swiftest_tpA % status ( i ) = DISCARDED_RMAXU WRITE ( * , * ) \"Particle \" , swiftest_tpA % name ( i ), \" is unbound and too far from barycenter at t = \" , t ldiscard_tp = . TRUE . END IF END IF END IF END DO RETURN END SUBROUTINE discard_sun !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/discard_sun.f90.html"},{"title":"discard_pl.f90 – swiftest","text":"Unit Name   : discard_pl\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : discard\n  Language    : Fortran 90/95 Description : Check to see if test particles should be discarded based on their positions relative to the planets Input\n    Arguments : t            : time\n                dt           : time step\n                npl          : number of planets\n                ntp          : number of active test particles\n                swifter_pl1P : pointer to head of Swifter planet structure linked-list\n                swifter_tp1P : pointer to head of active Swifter test particle structure linked-list\n    Terminal  : none\n    File      : none Output\n    Arguments : swifter_tp1P : pointer to head of active Swifter test particle structure linked-list\n    Terminal  : status message\n    File      : none Invocation  : CALL discard_pl(t, dt, npl, ntp, swifter_pl1P, swifter_tp1P) Notes       : Adapted from Hal Levison's Swift routine discard_pl.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~discard_pl.f90~~EfferentGraph sourcefile~discard_pl.f90 discard_pl.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~discard_pl.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~discard_pl.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~discard_pl.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines discard_pl Source Code discard_pl.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : discard_pl !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : discard !  Language    : Fortran 90/95 ! !  Description : Check to see if test particles should be discarded based on their positions relative to the planets ! !  Input !    Arguments : t            : time !                dt           : time step !                npl          : number of planets !                ntp          : number of active test particles !                swifter_pl1P : pointer to head of Swifter planet structure linked-list !                swifter_tp1P : pointer to head of active Swifter test particle structure linked-list !    Terminal  : none !    File      : none ! !  Output !    Arguments : swifter_tp1P : pointer to head of active Swifter test particle structure linked-list !    Terminal  : status message !    File      : none ! !  Invocation  : CALL discard_pl(t, dt, npl, ntp, swifter_pl1P, swifter_tp1P) ! !  Notes       : Adapted from Hal Levison's Swift routine discard_pl.f ! !********************************************************************************************************************************** SUBROUTINE discard_pl ( t , dt , npl , ntp , swiftest_plA , swiftest_tpA ) ! Modules USE swiftest USE module_swiftest USE module_interfaces , EXCEPT_THIS_ONE => discard_pl IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl , ntp REAL ( DP ), INTENT ( IN ) :: t , dt TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA ! Internals INTEGER ( I4B ) :: i , j , isp REAL ( DP ) :: r2min , radius REAL ( DP ), DIMENSION ( NDIM ) :: dx , dv ! Executable code DO i = 1 , ntp IF ( swiftest_tpA % status ( i ) == ACTIVE ) THEN DO j = 2 , npl dx (:) = swiftest_tpA % xh (:, i ) - swiftest_plA % xh (:, i ) dv (:) = swiftest_tpA % vh (:, i ) - swiftest_plA % vh (:, i ) radius = swiftest_plA % radius ( i ) CALL discard_pl_close ( dx (:), dv (:), dt , radius * radius , isp , r2min ) IF ( isp /= 0 ) THEN swiftest_tpA % status ( i ) = DISCARDED_PLR ldiscard = . TRUE . WRITE ( * , * ) \"Particle \" , swiftest_tpA % name ( i ), \" too close to Planet \" , swiftest_plA % name ( i ), \" at t = \" , t ldiscard_tp = . TRUE . EXIT END IF END DO END IF END DO RETURN END SUBROUTINE discard_pl !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/discard_pl.f90.html"},{"title":"discard.f90 – swiftest","text":"Unit Name   : discard\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : discard\n  Language    : Fortran 90/95 Description : Check to see if test particles should be discarded based on their positions or because they are unbound from\n                the system Input\n    Arguments : t              : time\n                dt             : time step\n                npl            : number of planets\n                ntp            : number of test particles\n                swifter_pl1P   : pointer to head of Swifter planet structure linked-list\n                swifter_tp1P   : pointer to head of active Swifter test particle structure linked-list\n                rmin           : minimum heliocentric radius for test particle\n                rmax           : maximum heliocentric radius for test particle\n                rmaxu          : maximum unbound heliocentric radius for test particle\n                qmin           : minimum pericenter distance for test particle\n                qmin_alo       : minimum semimajor axis for qmin\n                qmin_ahi       : maximum semimajor axis for qmin\n                qmin_coord     : coordinate frame to use for qmin\n                lclose         : logical flag indicating whether to check for planet-test particle encounters\n                lrhill_present : logical flag indicating whether Hill sphere radii for planets are present\n    Terminal  : none\n    File      : none Output\n    Arguments : swifter_tp1P   : pointer to head of active Swifter test particle structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL discard(t, dt, npl, ntp, swifter_pl1P, swifter_tp1P, rmin, rmax, rmaxu, qmin, qmin_alo, qmin_ahi,\n                             qmin_coord, lclose, lrhill_present) Notes       : Adapted from Hal Levison's Swift routine discard.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~discard.f90~~EfferentGraph sourcefile~discard.f90 discard.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~discard.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~discard.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines discard Source Code discard.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : discard !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : discard !  Language    : Fortran 90/95 ! !  Description : Check to see if test particles should be discarded based on their positions or because they are unbound from !                the system ! !  Input !    Arguments : t              : time !                dt             : time step !                npl            : number of planets !                ntp            : number of test particles !                swifter_pl1P   : pointer to head of Swifter planet structure linked-list !                swifter_tp1P   : pointer to head of active Swifter test particle structure linked-list !                rmin           : minimum heliocentric radius for test particle !                rmax           : maximum heliocentric radius for test particle !                rmaxu          : maximum unbound heliocentric radius for test particle !                qmin           : minimum pericenter distance for test particle !                qmin_alo       : minimum semimajor axis for qmin !                qmin_ahi       : maximum semimajor axis for qmin !                qmin_coord     : coordinate frame to use for qmin !                lclose         : logical flag indicating whether to check for planet-test particle encounters !                lrhill_present : logical flag indicating whether Hill sphere radii for planets are present !    Terminal  : none !    File      : none ! !  Output !    Arguments : swifter_tp1P   : pointer to head of active Swifter test particle structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL discard(t, dt, npl, ntp, swifter_pl1P, swifter_tp1P, rmin, rmax, rmaxu, qmin, qmin_alo, qmin_ahi, !                             qmin_coord, lclose, lrhill_present) ! !  Notes       : Adapted from Hal Levison's Swift routine discard.f ! !********************************************************************************************************************************** SUBROUTINE discard ( t , dt , npl , ntp , swiftest_plA , swiftest_tpA , rmin , rmax , rmaxu , qmin , qmin_alo , qmin_ahi , qmin_coord , lclose , & lrhill_present ) ! Modules USE swiftest USE module_swiftest USE module_interfaces , EXCEPT_THIS_ONE => discard IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( IN ) :: lclose , lrhill_present INTEGER ( I4B ), INTENT ( IN ) :: npl , ntp REAL ( DP ), INTENT ( IN ) :: t , dt , rmin , rmax , rmaxu , qmin , qmin_alo , qmin_ahi CHARACTER ( * ), INTENT ( IN ) :: qmin_coord TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA ! Internals REAL ( DP ) :: msys ! Executable code IF (( rmin >= 0.0_DP ) . OR . ( rmax >= 0.0_DP ) . OR . ( rmaxu >= 0.0_DP ) . OR . (( qmin >= 0.0_DP ) . AND . ( qmin_coord == \"BARY\" ))) THEN CALL coord_h2b ( npl , swiftest_plA , msys ) CALL coord_h2b_tp ( ntp , swiftest_tpA , swiftest_plA ) END IF IF (( rmin >= 0.0_DP ) . OR . ( rmax >= 0.0_DP ) . OR . ( rmaxu >= 0.0_DP )) CALL discard_sun ( t , ntp , msys , swiftest_tpA , rmin , rmax , & rmaxu ) IF ( qmin >= 0.0_DP ) CALL discard_peri ( t , npl , ntp , swiftest_plA , swiftest_tpA , msys , qmin , qmin_alo , qmin_ahi , qmin_coord , & lrhill_present ) IF ( lclose ) CALL discard_pl ( t , dt , npl , ntp , swiftest_plA , swiftest_tpA ) RETURN END SUBROUTINE discard !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/discard.f90.html"},{"title":"discard_peri.f90 – swiftest","text":"Unit Name   : discard_peri\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : discard\n  Language    : Fortran 90/95 Description : Check to see if a test particle should be discarded because its perihelion distance becomes too small Input\n    Arguments : t              : time\n                npl            : number of planets\n                ntp            : number of active test particles\n                swifter_pl1P   : pointer to head of Swifter planet structure linked-list\n                swifter_tp1P   : pointer to head of active Swifter test particle structure linked-list\n                msys           : total system mass\n                qmin           : minimum pericenter distance for test particle\n                qmin_alo       : minimum semimajor axis for qmin\n                qmin_ahi       : maximum semimajor axis for qmin\n                qmin_coord     : coordinate frame to use for qmin\n                lrhill_present : logical flag indicating whether Hill sphere radii for planets are present\n    Terminal  : none\n    File      : none Output\n    Arguments : swifter_tp1P   : pointer to head of active Swifter test particle structure linked-list\n    Terminal  : status message\n    File      : none Invocation  : CALL discard_peri(t, npl, ntp, swifter_pl1P, swifter_tp1P, msys, qmin, qmin_alo, qmin_ahi, qmin_coord,\n                                  lrhill_present) Notes       : Adapted from Hal Levison's Swift routine discard_peri.f Author(s)   : Davname E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~discard_peri.f90~~EfferentGraph sourcefile~discard_peri.f90 discard_peri.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~discard_peri.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~discard_peri.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~discard_peri.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines discard_peri Source Code discard_peri.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : discard_peri !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : discard !  Language    : Fortran 90/95 ! !  Description : Check to see if a test particle should be discarded because its perihelion distance becomes too small ! !  Input !    Arguments : t              : time !                npl            : number of planets !                ntp            : number of active test particles !                swifter_pl1P   : pointer to head of Swifter planet structure linked-list !                swifter_tp1P   : pointer to head of active Swifter test particle structure linked-list !                msys           : total system mass !                qmin           : minimum pericenter distance for test particle !                qmin_alo       : minimum semimajor axis for qmin !                qmin_ahi       : maximum semimajor axis for qmin !                qmin_coord     : coordinate frame to use for qmin !                lrhill_present : logical flag indicating whether Hill sphere radii for planets are present !    Terminal  : none !    File      : none ! !  Output !    Arguments : swifter_tp1P   : pointer to head of active Swifter test particle structure linked-list !    Terminal  : status message !    File      : none ! !  Invocation  : CALL discard_peri(t, npl, ntp, swifter_pl1P, swifter_tp1P, msys, qmin, qmin_alo, qmin_ahi, qmin_coord, !                                  lrhill_present) ! !  Notes       : Adapted from Hal Levison's Swift routine discard_peri.f ! !********************************************************************************************************************************** SUBROUTINE discard_peri ( t , npl , ntp , swiftest_plA , swiftest_tpA , msys , qmin , qmin_alo , qmin_ahi , qmin_coord , lrhill_present ) ! Modules USE swiftest USE module_swiftest USE module_interfaces , EXCEPT_THIS_ONE => discard_peri IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( IN ) :: lrhill_present INTEGER ( I4B ), INTENT ( IN ) :: npl , ntp REAL ( DP ), INTENT ( IN ) :: t , msys , qmin , qmin_alo , qmin_ahi CHARACTER ( * ), INTENT ( IN ) :: qmin_coord TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA ! Internals LOGICAL ( LGT ), SAVE :: lfirst = . TRUE . INTEGER ( I4B ) :: i , j , ih REAL ( DP ) :: r2 REAL ( DP ), DIMENSION ( NDIM ) :: dx ! Executable code IF ( lfirst ) THEN IF (. NOT . lrhill_present ) CALL util_hills ( npl , swiftest_plA ) CALL util_peri ( lfirst , ntp , swiftest_tpA , swiftest_plA % mass ( 1 ), msys , qmin_coord ) lfirst = . FALSE . ELSE CALL util_peri ( lfirst , ntp , swiftest_tpA , swiftest_plA % mass ( 1 ), msys , qmin_coord ) DO i = 1 , ntp IF ( swiftest_tpA % status ( i ) == ACTIVE ) THEN IF ( swiftest_tpA % isperi ( i ) == 0 ) THEN ih = 1 DO j = 2 , npl dx (:) = swiftest_tpA % xh (:, i ) - swiftest_plA % xh (:, j ) r2 = DOT_PRODUCT ( dx (:), dx (:)) IF ( r2 <= swiftest_plA % rhill ( j ) * swiftest_plA % rhill ( j )) ih = 0 END DO IF ( ih == 1 ) THEN IF (( swiftest_tpA % atp ( i ) >= qmin_alo ) . AND . & ( swiftest_tpA % atp ( i ) <= qmin_ahi ) . AND . & ( swiftest_tpA % peri ( i ) <= qmin )) THEN swiftest_tpA % status ( i ) = DISCARDED_PERI WRITE ( * , * ) \"Particle \" , swiftest_tpA % name ( i ), \" perihelion distance too small at t = \" , t ldiscard_tp = . TRUE . END IF END IF END IF END IF END DO END IF RETURN END SUBROUTINE discard_peri !********************************************************************************************************************************** ! !  Author(s)   : Davname E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/discard_peri.f90.html"},{"title":"helio_getacch.f90 – swiftest","text":"Unit Name   : helio_getacch\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : helio\n  Language    : Fortran 90/95 Description : Compute heliocentric accelerations of planets Input\n    Arguments : lflag        : logical flag indicating whether to recompute direct cross term accelerations\n                lextra_force : logical flag indicating whether to include user-supplied accelerations\n                t            : time\n                npl          : number of planets\n                nplmax       : maximum allowed number of planets\n                helio_pl1P   : pointer to head of helio planet structure linked-list\n                j2rp2        : J2 * R 2 for the Sun\n                j4rp4        : J4 * R 4 for the Sun\n    Terminal  : none\n    File      : none Output\n    Arguments : helio_pl1P   : pointer to head of helio planet structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL helio_getacch(lflag, lextra_force, t, npl, nplmax, helio_pl1P, j2rp2, j4rp4) Notes       : Adapted from Hal Levison's Swift routine helio_getacch.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~helio_getacch.f90~~EfferentGraph sourcefile~helio_getacch.f90 helio_getacch.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~helio_getacch.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~helio_getacch.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~helio_getacch.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_getacch.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines helio_getacch Source Code helio_getacch.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : helio_getacch !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : helio !  Language    : Fortran 90/95 ! !  Description : Compute heliocentric accelerations of planets ! !  Input !    Arguments : lflag        : logical flag indicating whether to recompute direct cross term accelerations !                lextra_force : logical flag indicating whether to include user-supplied accelerations !                t            : time !                npl          : number of planets !                nplmax       : maximum allowed number of planets !                helio_pl1P   : pointer to head of helio planet structure linked-list !                j2rp2        : J2 * R**2 for the Sun !                j4rp4        : J4 * R**4 for the Sun !    Terminal  : none !    File      : none ! !  Output !    Arguments : helio_pl1P   : pointer to head of helio planet structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL helio_getacch(lflag, lextra_force, t, npl, nplmax, helio_pl1P, j2rp2, j4rp4) ! !  Notes       : Adapted from Hal Levison's Swift routine helio_getacch.f ! !********************************************************************************************************************************** SUBROUTINE helio_getacch ( lflag , lextra_force , t , npl , nplmax , helio_plA , j2rp2 , j4rp4 ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_interfaces , EXCEPT_THIS_ONE => helio_getacch IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( IN ) :: lflag , lextra_force INTEGER ( I4B ), INTENT ( IN ) :: npl , nplmax REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 ! Internals LOGICAL ( LGT ), SAVE :: lmalloc = . TRUE . INTEGER ( I4B ) :: i REAL ( DP ) :: r2 REAL ( DP ), DIMENSION (:), ALLOCATABLE , SAVE :: irh REAL ( DP ), DIMENSION (:, :), ALLOCATABLE , SAVE :: xh , aobl TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA ! Executable code IF ( lflag ) THEN DO i = 2 , npl helio_plA % ahi (:, i ) = ( / 0.0_DP , 0.0_DP , 0.0_DP / ) END DO CALL helio_getacch_int ( npl , helio_plA ) END IF IF ( j2rp2 /= 0.0_DP ) THEN IF ( lmalloc ) THEN ALLOCATE ( xh ( NDIM , nplmax ), aobl ( NDIM , nplmax ), irh ( nplmax )) lmalloc = . FALSE . END IF DO i = 2 , npl xh (:, i ) = helio_plA % swiftest % xh (:, i ) r2 = DOT_PRODUCT ( xh (:, i ), xh (:, i )) irh ( i ) = 1.0_DP / SQRT ( r2 ) END DO CALL obl_acc ( npl , helio_plA % swiftest , j2rp2 , j4rp4 , xh , irh , aobl ) DO i = 2 , npl helio_plA % ah (:, i ) = helio_plA % ahi (:, i ) + aobl (:, i ) - aobl (:, 1 ) END DO ELSE DO i = 2 , npl helio_plA % ah (:, i ) = helio_plA % ahi (:, i ) END DO END IF IF ( lextra_force ) CALL helio_user_getacch ( t , npl , helio_plA ) RETURN END SUBROUTINE helio_getacch !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/helio_getacch.f90.html"},{"title":"helio_user_getacch.f90 – swiftest","text":"Unit Name   : helio_user_getacch\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : helio\n  Language    : Fortran 90/95 Description : Add user-supplied heliocentric accelerations to planets Input\n    Arguments : t          : time\n                npl        : number of planets\n                helio_pl1P : pointer to head of helio planet structure linked-list\n    Terminal  : TBS as needed by user\n    File      : TBS as needed by user Output\n    Arguments : helio_pl1P : pointer to head of helio planet structure linked-list\n    Terminal  : TBS as needed by user\n    File      : TBS as needed by user Invocation  : CALL helio_user_getacch(t, npl, helio_pl1P) Notes       : Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~helio_user_getacch.f90~~EfferentGraph sourcefile~helio_user_getacch.f90 helio_user_getacch.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~helio_user_getacch.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~helio_user_getacch.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_user_getacch.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines helio_user_getacch Source Code helio_user_getacch.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : helio_user_getacch !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : helio !  Language    : Fortran 90/95 ! !  Description : Add user-supplied heliocentric accelerations to planets ! !  Input !    Arguments : t          : time !                npl        : number of planets !                helio_pl1P : pointer to head of helio planet structure linked-list !    Terminal  : TBS as needed by user !    File      : TBS as needed by user ! !  Output !    Arguments : helio_pl1P : pointer to head of helio planet structure linked-list !    Terminal  : TBS as needed by user !    File      : TBS as needed by user ! !  Invocation  : CALL helio_user_getacch(t, npl, helio_pl1P) ! !  Notes       : ! !********************************************************************************************************************************** SUBROUTINE helio_user_getacch ( t , npl , helio_plA ) ! Modules USE swiftest USE module_helio USE module_interfaces , EXCEPT_THIS_ONE => helio_user_getacch IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: t TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA ! Internals ! Executable code RETURN END SUBROUTINE helio_user_getacch !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/helio_user_getacch.f90.html"},{"title":"helio_getacch_int.f90 – swiftest","text":"Unit Name   : helio_getacch_int\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : helio\n  Language    : Fortran 90/95 Description : Compute direct cross term heliocentric accelerations of planets Input\n    Arguments : npl        : number of planets\n                helio_pl1P : pointer to head of helio planet structure linked-list\n    Terminal  : none\n    File      : none Output\n    Arguments : helio_pl1P : pointer to head of helio planet structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL helio_getacch_int(npl, helio_pl1P) Notes       : Adapted from Hal Levison's Swift routine getacch_ah3.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~helio_getacch_int.f90~~EfferentGraph sourcefile~helio_getacch_int.f90 helio_getacch_int.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~helio_getacch_int.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~helio_getacch_int.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_getacch_int.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines helio_getacch_int Source Code helio_getacch_int.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : helio_getacch_int !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : helio !  Language    : Fortran 90/95 ! !  Description : Compute direct cross term heliocentric accelerations of planets ! !  Input !    Arguments : npl        : number of planets !                helio_pl1P : pointer to head of helio planet structure linked-list !    Terminal  : none !    File      : none ! !  Output !    Arguments : helio_pl1P : pointer to head of helio planet structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL helio_getacch_int(npl, helio_pl1P) ! !  Notes       : Adapted from Hal Levison's Swift routine getacch_ah3.f ! !********************************************************************************************************************************** SUBROUTINE helio_getacch_int ( npl , helio_plA ) ! Modules USE swiftest USE module_helio USE module_interfaces , EXCEPT_THIS_ONE => helio_getacch_int IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA ! Internals INTEGER ( I4B ) :: i , j REAL ( DP ) :: rji2 , irij3 , faci , facj REAL ( DP ), DIMENSION ( NDIM ) :: dx ! Executable code DO i = 2 , npl - 1 DO j = i + 1 , npl dx (:) = helio_plA % swiftest % xh (:, j ) - helio_plA % swiftest % xh (:, i ) rji2 = DOT_PRODUCT ( dx (:), dx (:)) irij3 = 1.0_DP / ( rji2 * SQRT ( rji2 )) faci = helio_plA % swiftest % mass ( i ) * irij3 facj = helio_plA % swiftest % mass ( j ) * irij3 helio_plA % ahi (:, i ) = helio_plA % ahi (:, i ) + facj * dx (:) helio_plA % ahi (:, i ) = helio_plA % ahi (:, j ) - faci * dx (:) END DO END DO RETURN END SUBROUTINE helio_getacch_int !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/helio_getacch_int.f90.html"},{"title":"helio_getacch_int_tp.f90 – swiftest","text":"Unit Name   : helio_getacch_int_tp\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : helio\n  Language    : Fortran 90/95 Description : Compute direct cross term heliocentric accelerations of test particles Input\n    Arguments : npl          : number of planets\n                ntp          : number of active test particles\n                swifter_pl1P : pointer to head of Swifter planet structure linked-list\n                helio_tp1P   : pointer to head of active helio test particle structure linked-list\n                xh           : heliocentric planet positions\n    Terminal  : none\n    File      : none Output\n    Arguments : helio_tp1P   : pointer to head of active helio test particle structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL helio_getacch_int_tp(npl, ntp, swifter_pl1P, helio_tp1P, xh) Notes       : Adapted from Hal Levison's Swift routine getacch_ah3_tp.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~helio_getacch_int_tp.f90~~EfferentGraph sourcefile~helio_getacch_int_tp.f90 helio_getacch_int_tp.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~helio_getacch_int_tp.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~helio_getacch_int_tp.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~helio_getacch_int_tp.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_getacch_int_tp.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines helio_getacch_int_tp Source Code helio_getacch_int_tp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : helio_getacch_int_tp !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : helio !  Language    : Fortran 90/95 ! !  Description : Compute direct cross term heliocentric accelerations of test particles ! !  Input !    Arguments : npl          : number of planets !                ntp          : number of active test particles !                swifter_pl1P : pointer to head of Swifter planet structure linked-list !                helio_tp1P   : pointer to head of active helio test particle structure linked-list !                xh           : heliocentric planet positions !    Terminal  : none !    File      : none ! !  Output !    Arguments : helio_tp1P   : pointer to head of active helio test particle structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL helio_getacch_int_tp(npl, ntp, swifter_pl1P, helio_tp1P, xh) ! !  Notes       : Adapted from Hal Levison's Swift routine getacch_ah3_tp.f ! !********************************************************************************************************************************** SUBROUTINE helio_getacch_int_tp ( npl , ntp , swiftest_plA , helio_tpA ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_interfaces , EXCEPT_THIS_ONE => helio_getacch_int_tp IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl , ntp TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA TYPE ( helio_tp ), INTENT ( INOUT ) :: helio_tpA ! Internals INTEGER ( I4B ) :: i , j REAL ( DP ) :: r2 , fac REAL ( DP ), DIMENSION ( NDIM ) :: dx ! Executable code DO i = 1 , ntp IF ( helio_tpA % swiftest % status ( i ) == ACTIVE ) THEN DO j = 2 , npl dx (:) = helio_tpA % swiftest % xh (:, i ) - swiftest_plA % xh (:, j ) r2 = DOT_PRODUCT ( dx (:), dx (:)) fac = swiftest_plA % mass ( j ) / ( r2 * SQRT ( r2 )) helio_tpA % ahi (:, i ) = helio_tpA % ahi (:, i ) - fac * dx (:) END DO END IF END DO RETURN END SUBROUTINE helio_getacch_int_tp !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/helio_getacch_int_tp.f90.html"},{"title":"helio_kickvb.f90 – swiftest","text":"Unit Name   : helio_kickvb\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : helio\n  Language    : Fortran 90/95 Description : Kick barycentric velocities of planets Input\n    Arguments : npl        : number of planets\n                helio_plA : pointer to head of helio planet structure linked-list\n                dt         : time step\n    Terminal  : none\n    File      : none Output\n    Arguments : helio_plA : pointer to head of helio planet structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL helio_kickvb(npl, helio_plA, dt) Notes       : Adapted from Martin Duncan and Hal Levison's Swift routine kickvh.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~helio_kickvb.f90~~EfferentGraph sourcefile~helio_kickvb.f90 helio_kickvb.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~helio_kickvb.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~helio_kickvb.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~helio_kickvb.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_kickvb.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines helio_kickvb Source Code helio_kickvb.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : helio_kickvb !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : helio !  Language    : Fortran 90/95 ! !  Description : Kick barycentric velocities of planets ! !  Input !    Arguments : npl        : number of planets !                helio_plA : pointer to head of helio planet structure linked-list !                dt         : time step !    Terminal  : none !    File      : none ! !  Output !    Arguments : helio_plA : pointer to head of helio planet structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL helio_kickvb(npl, helio_plA, dt) ! !  Notes       : Adapted from Martin Duncan and Hal Levison's Swift routine kickvh.f ! !********************************************************************************************************************************** SUBROUTINE helio_kickvb ( npl , helio_plA , dt ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_interfaces , EXCEPT_THIS_ONE => helio_kickvb IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: dt TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA ! Internals INTEGER ( I4B ) :: i ! Executable code DO i = 2 , npl helio_plA % swiftest % vb (:, i ) = helio_plA % swiftest % vb (:, i ) + helio_plA % ah (:, i ) * dt END DO RETURN END SUBROUTINE helio_kickvb !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/helio_kickvb.f90.html"},{"title":"helio_kickvb_tp.f90 – swiftest","text":"Unit Name   : helio_kickvb_tp\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : helio\n  Language    : Fortran 90/95 Description : Kick barycentric velocities of active test particles Input\n    Arguments : ntp        : number of active test particles\n                helio_tp1P : pointer to head of active helio test particle structure linked-list\n                dt         : time step\n    Terminal  : none\n    File      : none Output\n    Arguments : helio_tp1P : pointer to head of active helio test particle structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL helio_kickvb_tp(ntp, helio_tp1P, dt) Notes       : Adapted from Martin Duncan and Hal Levison's Swift routine kickvh_tp.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~helio_kickvb_tp.f90~~EfferentGraph sourcefile~helio_kickvb_tp.f90 helio_kickvb_tp.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~helio_kickvb_tp.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~helio_kickvb_tp.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~helio_kickvb_tp.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_kickvb_tp.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines helio_kickvb_tp Source Code helio_kickvb_tp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : helio_kickvb_tp !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : helio !  Language    : Fortran 90/95 ! !  Description : Kick barycentric velocities of active test particles ! !  Input !    Arguments : ntp        : number of active test particles !                helio_tp1P : pointer to head of active helio test particle structure linked-list !                dt         : time step !    Terminal  : none !    File      : none ! !  Output !    Arguments : helio_tp1P : pointer to head of active helio test particle structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL helio_kickvb_tp(ntp, helio_tp1P, dt) ! !  Notes       : Adapted from Martin Duncan and Hal Levison's Swift routine kickvh_tp.f ! !********************************************************************************************************************************** SUBROUTINE helio_kickvb_tp ( ntp , helio_tpA , dt ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_interfaces , EXCEPT_THIS_ONE => helio_kickvb_tp IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: ntp REAL ( DP ), INTENT ( IN ) :: dt TYPE ( helio_tp ), INTENT ( INOUT ) :: helio_tpA ! Internals INTEGER ( I4B ) :: i ! Executable code DO i = 1 , ntp IF ( helio_tpA % swiftest % status ( i ) == ACTIVE ) helio_tpA % swiftest % vb (:, i ) = helio_tpA % swiftest % vb (:, i ) + helio_tpA % ah (:, i ) * dt END DO RETURN END SUBROUTINE helio_kickvb_tp !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/helio_kickvb_tp.f90.html"},{"title":"helio_lindrift_tp.f90 – swiftest","text":"Unit Name   : helio_lindrift_tp\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : helio\n  Language    : Fortran 90/95 Description : Perform linear drift of test particles due to barycentric momentum of Sun Input\n    Arguments : ntp          : number of active test particles\n                swifter_tp1P : pointer to head of active Swifter test particle structure linked-list\n                dt           : time step\n                pt           : negative barycentric velocity of the Sun\n    Terminal  : none\n    File      : none Output\n    Arguments : swifter_tp1P : pointer to head of active Swifter test particle structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL helio_lindrift_tp(ntp, swifter_tp1P, dt, pt) Notes       : Adapted from Hal Levison's Swift routine helio_lindrift_tp.f Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~helio_lindrift_tp.f90~~EfferentGraph sourcefile~helio_lindrift_tp.f90 helio_lindrift_tp.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~helio_lindrift_tp.f90->sourcefile~module_swiftest.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~helio_lindrift_tp.f90->sourcefile~module_interfaces.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~helio_lindrift_tp.f90->sourcefile~module_symba.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_lindrift_tp.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines helio_lindrift_tp Source Code helio_lindrift_tp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : helio_lindrift_tp !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : helio !  Language    : Fortran 90/95 ! !  Description : Perform linear drift of test particles due to barycentric momentum of Sun ! !  Input !    Arguments : ntp          : number of active test particles !                swifter_tp1P : pointer to head of active Swifter test particle structure linked-list !                dt           : time step !                pt           : negative barycentric velocity of the Sun !    Terminal  : none !    File      : none ! !  Output !    Arguments : swifter_tp1P : pointer to head of active Swifter test particle structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL helio_lindrift_tp(ntp, swifter_tp1P, dt, pt) ! !  Notes       : Adapted from Hal Levison's Swift routine helio_lindrift_tp.f ! !********************************************************************************************************************************** SUBROUTINE helio_lindrift_tp ( ntp , swiftest_tpA , dt , pt ) ! Modules USE swiftest USE module_swiftest USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => helio_lindrift_tp IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: ntp REAL ( DP ), INTENT ( IN ) :: dt REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: pt TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA ! Internals INTEGER ( I4B ) :: i ! Executable code DO i = 1 , ntp IF ( swiftest_tpA % status ( i ) == ACTIVE ) THEN swiftest_tpA % xh (:, i ) = swiftest_tpA % xh (:, i ) + pt (:) * dt END IF END DO RETURN END SUBROUTINE helio_lindrift_tp !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/helio_lindrift_tp.f90.html"},{"title":"helio_step_pl.f90 – swiftest","text":"Unit Name   : helio_step_pl\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : helio\n  Language    : Fortran 90/95 Description : Step planets ahead Democratic Heliocentric method Input\n    Arguments : lfirst       : logical flag indicating whether current invocation is the first\n                lextra_force : logical flag indicating whether to include user-supplied accelerations\n                t            : time\n                npl          : number of planets\n                nplmax       : maximum allowed number of planets\n                helio_pl1P   : pointer to head of helio planet structure linked-list\n                j2rp2        : J2 * R 2 for the Sun\n                j4rp4        : J4 * R 4 for the Sun\n                dt           : time step\n    Terminal  : none\n    File      : none Output\n    Arguments : lfirst       : logical flag indicating whether current invocation is the first\n                helio_pl1P   : pointer to head of helio planet structure linked-list\n                xbeg         : heliocentric planet positions at beginning of time step\n                xend         : heliocentric planet positions at end of time step\n                ptb          : negative barycentric velocity of the Sun at beginning of time step\n                pte          : negative barycentric velocity of the Sun at end of time step\n    Terminal  : none\n    File      : none Invocation  : CALL helio_step_pl(lfirst, lextra_force, t, npl, nplmax, helio_pl1P, j2rp2, j4rp4, dt, xbeg, xend, ptb, pte) Notes       : Adapted from Hal Levison's Swift routine helio_step_pl.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~helio_step_pl.f90~~EfferentGraph sourcefile~helio_step_pl.f90 helio_step_pl.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~helio_step_pl.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~helio_step_pl.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~helio_step_pl.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_step_pl.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines helio_step_pl Source Code helio_step_pl.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : helio_step_pl !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : helio !  Language    : Fortran 90/95 ! !  Description : Step planets ahead Democratic Heliocentric method ! !  Input !    Arguments : lfirst       : logical flag indicating whether current invocation is the first !                lextra_force : logical flag indicating whether to include user-supplied accelerations !                t            : time !                npl          : number of planets !                nplmax       : maximum allowed number of planets !                helio_pl1P   : pointer to head of helio planet structure linked-list !                j2rp2        : J2 * R**2 for the Sun !                j4rp4        : J4 * R**4 for the Sun !                dt           : time step !    Terminal  : none !    File      : none ! !  Output !    Arguments : lfirst       : logical flag indicating whether current invocation is the first !                helio_pl1P   : pointer to head of helio planet structure linked-list !                xbeg         : heliocentric planet positions at beginning of time step !                xend         : heliocentric planet positions at end of time step !                ptb          : negative barycentric velocity of the Sun at beginning of time step !                pte          : negative barycentric velocity of the Sun at end of time step !    Terminal  : none !    File      : none ! !  Invocation  : CALL helio_step_pl(lfirst, lextra_force, t, npl, nplmax, helio_pl1P, j2rp2, j4rp4, dt, xbeg, xend, ptb, pte) ! !  Notes       : Adapted from Hal Levison's Swift routine helio_step_pl.f ! !********************************************************************************************************************************** SUBROUTINE helio_step_pl ( lfirst , lextra_force , t , npl , nplmax , helio_plA , j2rp2 , j4rp4 , dt , xbeg , xend , ptb , pte ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_interfaces , EXCEPT_THIS_ONE => helio_step_pl IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( IN ) :: lextra_force LOGICAL ( LGT ), INTENT ( INOUT ) :: lfirst INTEGER ( I4B ), INTENT ( IN ) :: npl , nplmax REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 , dt REAL ( DP ), DIMENSION ( NDIM ), INTENT ( OUT ) :: ptb , pte REAL ( DP ), DIMENSION ( NDIM , npl ), INTENT ( OUT ) :: xbeg , xend TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA ! Internals LOGICAL ( LGT ) :: lflag INTEGER ( I4B ) :: i REAL ( DP ) :: dth , msys ! Executable code dth = 0.5_DP * dt lflag = lfirst IF ( lfirst ) THEN CALL coord_vh2vb ( npl , helio_plA % swiftest , msys ) lfirst = . FALSE . END IF CALL helio_lindrift ( npl , helio_plA % swiftest , dth , ptb ) CALL helio_getacch ( lflag , lextra_force , t , npl , nplmax , helio_plA , j2rp2 , j4rp4 ) lflag = . TRUE . CALL helio_kickvb ( npl , helio_plA , dth ) DO i = 2 , npl xbeg (:, i ) = helio_plA % swiftest % xh (:, i ) END DO CALL helio_drift ( npl , helio_plA % swiftest , dt ) DO i = 2 , npl xend (:, i ) = helio_plA % swiftest % xh (:, i ) END DO CALL helio_getacch ( lflag , lextra_force , t + dt , npl , nplmax , helio_plA , j2rp2 , j4rp4 ) CALL helio_kickvb ( npl , helio_plA , dth ) CALL helio_lindrift ( npl , helio_plA % swiftest , dth , pte ) CALL coord_vb2vh ( npl , helio_plA % swiftest ) RETURN END SUBROUTINE helio_step_pl !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/helio_step_pl.f90.html"},{"title":"helio_drift_tp.f90 – swiftest","text":"Unit Name   : helio_drift_tp\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : helio\n  Language    : Fortran 90/95 Description : Loop through test particles and call Danby drift routine Input\n    Arguments : ntp          : number of active test particles\n                swifter_tp1P : pointer to head of active Swifter test particle structure linked-list\n    Terminal  : none\n    File      : none Output\n    Arguments : swifter_tp1P : pointer to head of active Swifter test particle structure linked-list\n    Terminal  : error message\n    File      : none Invocation  : CALL helio_drift_tp(ntp, swifter_tp1P, mu, dt) Notes       : Adapted from Hal Levison's Swift routine drift_tp.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~helio_drift_tp.f90~~EfferentGraph sourcefile~helio_drift_tp.f90 helio_drift_tp.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~helio_drift_tp.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~helio_drift_tp.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_drift_tp.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines helio_drift_tp Source Code helio_drift_tp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : helio_drift_tp !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : helio !  Language    : Fortran 90/95 ! !  Description : Loop through test particles and call Danby drift routine ! !  Input !    Arguments : ntp          : number of active test particles !                swifter_tp1P : pointer to head of active Swifter test particle structure linked-list !    Terminal  : none !    File      : none ! !  Output !    Arguments : swifter_tp1P : pointer to head of active Swifter test particle structure linked-list !    Terminal  : error message !    File      : none ! !  Invocation  : CALL helio_drift_tp(ntp, swifter_tp1P, mu, dt) ! !  Notes       : Adapted from Hal Levison's Swift routine drift_tp.f ! !********************************************************************************************************************************** SUBROUTINE helio_drift_tp ( ntp , swiftest_tpA , mu , dt ) ! Modules USE swiftest USE module_swiftest USE module_interfaces , EXCEPT_THIS_ONE => helio_drift_tp IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: ntp REAL ( DP ), INTENT ( IN ) :: mu , dt TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA ! Internals INTEGER ( I4B ) :: i , iflag ! Executable code DO i = 1 , ntp IF ( swiftest_tpA % status ( i ) == ACTIVE ) THEN CALL drift_one ( mu , swiftest_tpA % xh (:, i ), swiftest_tpA % vb (:, i ), dt , iflag ) IF ( iflag /= 0 ) THEN swiftest_tpA % status ( i ) = DISCARDED_DRIFTERR WRITE ( * , * ) \"Particle \" , swiftest_tpA % name ( i ), \" lost due to error in Danby drift\" END IF END IF END DO RETURN END SUBROUTINE helio_drift_tp !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/helio_drift_tp.f90.html"},{"title":"helio_step_tp.f90 – swiftest","text":"Unit Name   : helio_step_tp\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : helio\n  Language    : Fortran 90/95 Description : Step active test particles ahead using Democratic Heliocentric method Input\n    Arguments : lfirsttp     : logical flag indicating whether current invocation is the first\n                lextra_force : logical flag indicating whether to include user-supplied accelerations\n                t            : time\n                npl          : number of planets\n                nplmax       : maximum allowed number of planets\n                ntp          : number of active test particles\n                ntpmax       : maximum allowed number of test particles\n                helio_pl1P   : pointer to head of helio planet structure linked-list\n                helio_tp1P   : pointer to head of active helio test particle structure linked-list\n                j2rp2        : J2 * R 2 for the Sun\n                j4rp4        : J4 * R 4 for the Sun\n                dt           : time step\n                xbeg         : heliocentric planet positions at beginning of time step\n                xend         : heliocentric planet positions at end of time step\n                ptb          : negative barycentric velocity of the Sun at beginning of time step\n                pte          : negative barycentric velocity of the Sun at end of time step\n    Terminal  : none\n    File      : none Output\n    Arguments : lfirsttp     : logical flag indicating whether current invocation is the first\n                helio_tp1P   : pointer to head of active helio test particle structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL helio_step_tp(lfirsttp, lextra_force, t, npl, nplmax, ntp, ntpmax, helio_pl1P, helio_tp1P, j2rp2, j4rp4, dt,\n                                   xbeg, xend, ptb, pte) Notes       : Adapted from Hal Levison's Swift routine helio_step_tp.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~helio_step_tp.f90~~EfferentGraph sourcefile~helio_step_tp.f90 helio_step_tp.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~helio_step_tp.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~helio_step_tp.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~helio_step_tp.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_step_tp.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines helio_step_tp Source Code helio_step_tp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : helio_step_tp !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : helio !  Language    : Fortran 90/95 ! !  Description : Step active test particles ahead using Democratic Heliocentric method ! !  Input !    Arguments : lfirsttp     : logical flag indicating whether current invocation is the first !                lextra_force : logical flag indicating whether to include user-supplied accelerations !                t            : time !                npl          : number of planets !                nplmax       : maximum allowed number of planets !                ntp          : number of active test particles !                ntpmax       : maximum allowed number of test particles !                helio_pl1P   : pointer to head of helio planet structure linked-list !                helio_tp1P   : pointer to head of active helio test particle structure linked-list !                j2rp2        : J2 * R**2 for the Sun !                j4rp4        : J4 * R**4 for the Sun !                dt           : time step !                xbeg         : heliocentric planet positions at beginning of time step !                xend         : heliocentric planet positions at end of time step !                ptb          : negative barycentric velocity of the Sun at beginning of time step !                pte          : negative barycentric velocity of the Sun at end of time step !    Terminal  : none !    File      : none ! !  Output !    Arguments : lfirsttp     : logical flag indicating whether current invocation is the first !                helio_tp1P   : pointer to head of active helio test particle structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL helio_step_tp(lfirsttp, lextra_force, t, npl, nplmax, ntp, ntpmax, helio_pl1P, helio_tp1P, j2rp2, j4rp4, dt, !                                   xbeg, xend, ptb, pte) ! !  Notes       : Adapted from Hal Levison's Swift routine helio_step_tp.f ! !********************************************************************************************************************************** SUBROUTINE helio_step_tp ( lfirsttp , lextra_force , t , npl , nplmax , ntp , ntpmax , helio_plA , helio_tpA , j2rp2 , j4rp4 , dt , xbeg , & xend , ptb , pte ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_interfaces , EXCEPT_THIS_ONE => helio_step_tp IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( IN ) :: lextra_force LOGICAL ( LGT ), INTENT ( INOUT ) :: lfirsttp INTEGER ( I4B ), INTENT ( IN ) :: npl , nplmax , ntp , ntpmax REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 , dt REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: ptb , pte REAL ( DP ), DIMENSION ( NDIM , npl ), INTENT ( IN ) :: xbeg , xend TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA TYPE ( helio_tp ), INTENT ( INOUT ) :: helio_tpA ! Internals LOGICAL ( LGT ) :: lflag REAL ( DP ) :: dth , mu ! Executable code dth = 0.5_DP * dt lflag = lfirsttp mu = helio_plA % swiftest % mass ( 1 ) IF ( lfirsttp ) THEN CALL coord_vh2vb_tp ( ntp , helio_tpA % swiftest , - ptb ) lfirsttp = . FALSE . END IF CALL helio_lindrift_tp ( ntp , helio_tpA % swiftest , dth , ptb ) CALL helio_getacch_tp ( lflag , lextra_force , t , npl , nplmax , ntp , ntpmax , helio_plA , helio_tpA , xbeg , j2rp2 , j4rp4 ) lflag = . TRUE . CALL helio_kickvb_tp ( ntp , helio_tpA , dth ) CALL helio_drift_tp ( ntp , helio_tpA % swiftest , mu , dt ) CALL helio_getacch_tp ( lflag , lextra_force , t + dt , npl , nplmax , ntp , ntpmax , helio_plA , helio_tpA , xend , j2rp2 , j4rp4 ) CALL helio_kickvb_tp ( ntp , helio_tpA , dth ) CALL helio_lindrift_tp ( ntp , helio_tpA % swiftest , dth , pte ) CALL coord_vb2vh_tp ( ntp , helio_tpA % swiftest , - pte ) RETURN END SUBROUTINE helio_step_tp !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/helio_step_tp.f90.html"},{"title":"helio_lindrift.f90 – swiftest","text":"Unit Name   : helio_lindrift\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : helio\n  Language    : Fortran 90/95 Description : Perform linear drift of planets due to barycentric momentum of Sun Input\n    Arguments : npl          : number of planets\n                swifter_pl1P : pointer to head of Swifter planet structure linked-list\n                dt           : time step\n    Terminal  : none\n    File      : none Output\n    Arguments : swifter_pl1P : pointer to head of Swifter planet structure linked-list\n                pt           : negative barycentric velocity of the Sun\n    Terminal  : none\n    File      : none Invocation  : CALL helio_lindrift(npl, swifter_pl1P, dt, pt) Notes       : Adapted from Hal Levison's Swift routine helio_lindrift.f Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~helio_lindrift.f90~~EfferentGraph sourcefile~helio_lindrift.f90 helio_lindrift.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~helio_lindrift.f90->sourcefile~module_swiftest.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~helio_lindrift.f90->sourcefile~module_interfaces.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~helio_lindrift.f90->sourcefile~module_symba.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_lindrift.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines helio_lindrift Source Code helio_lindrift.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : helio_lindrift !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : helio !  Language    : Fortran 90/95 ! !  Description : Perform linear drift of planets due to barycentric momentum of Sun ! !  Input !    Arguments : npl          : number of planets !                swifter_pl1P : pointer to head of Swifter planet structure linked-list !                dt           : time step !    Terminal  : none !    File      : none ! !  Output !    Arguments : swifter_pl1P : pointer to head of Swifter planet structure linked-list !                pt           : negative barycentric velocity of the Sun !    Terminal  : none !    File      : none ! !  Invocation  : CALL helio_lindrift(npl, swifter_pl1P, dt, pt) ! !  Notes       : Adapted from Hal Levison's Swift routine helio_lindrift.f ! !********************************************************************************************************************************** SUBROUTINE helio_lindrift ( npl , swiftest_plA , dt , pt ) ! Modules USE swiftest USE module_swiftest USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => helio_lindrift IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: dt REAL ( DP ), DIMENSION ( NDIM ), INTENT ( OUT ) :: pt TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA ! Internals INTEGER ( I4B ) :: i ! Added by D. Minton REAL ( DP ), DIMENSION ( NDIM ) :: pttmp !INTENT(OUT) variables don't play nicely !with OpenMP's reduction for some reason ! Executable code pttmp (:) = ( / 0.0_DP , 0.0_DP , 0.0_DP / ) DO i = 2 , npl pttmp (:) = pttmp (:) + swiftest_plA % mass ( i ) * swiftest_plA % vb (:, i ) END DO pttmp (:) = pttmp (:) / swiftest_plA % mass ( 1 ) DO i = 2 , npl swiftest_plA % xh (:, i ) = swiftest_plA % xh (:, i ) + pttmp (:) * dt END DO pt (:) = pttmp (:) RETURN END SUBROUTINE helio_lindrift !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/helio_lindrift.f90.html"},{"title":"helio_drift.f90 – swiftest","text":"Unit Name   : helio_drift\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : helio\n  Language    : Fortran 90/95 Description : Loop through planets and call Danby drift routine Input\n    Arguments : npl          : number of planets\n                swifter_pl1P : pointer to head of Swifter planet structure linked-list\n                dt           : time step\n    Terminal  : none\n    File      : none Output\n    Arguments : swifter_pl1P : pointer to head of Swifter planet structure linked-list\n    Terminal  : error message\n    File      : none Invocation  : CALL helio_drift(npl, swifter_pl1P, dt) Notes       : Adapted from Hal Levison's Swift routine drift.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~helio_drift.f90~~EfferentGraph sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~helio_drift.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~helio_drift.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines helio_drift Source Code helio_drift.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : helio_drift !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : helio !  Language    : Fortran 90/95 ! !  Description : Loop through planets and call Danby drift routine ! !  Input !    Arguments : npl          : number of planets !                swifter_pl1P : pointer to head of Swifter planet structure linked-list !                dt           : time step !    Terminal  : none !    File      : none ! !  Output !    Arguments : swifter_pl1P : pointer to head of Swifter planet structure linked-list !    Terminal  : error message !    File      : none ! !  Invocation  : CALL helio_drift(npl, swifter_pl1P, dt) ! !  Notes       : Adapted from Hal Levison's Swift routine drift.f ! !********************************************************************************************************************************** SUBROUTINE helio_drift ( npl , swiftest_plA , dt ) ! Modules USE swiftest USE module_swiftest USE module_interfaces , EXCEPT_THIS_ONE => helio_drift IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: dt TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA ! Internals INTEGER ( I4B ) :: i , iflag REAL ( DP ) :: mu ! Executable code mu = swiftest_plA % mass ( 1 ) DO i = 2 , npl CALL drift_one ( mu , swiftest_plA % xh (:, i ), swiftest_plA % vb (:, i ), dt , iflag ) IF ( iflag /= 0 ) THEN WRITE ( * , * ) \" Planet \" , swiftest_plA % name ( i ), \" is lost!!!!!!!!!!\" WRITE ( * , * ) mu , dt WRITE ( * , * ) swiftest_plA % xh (:, i ) WRITE ( * , * ) swiftest_plA % vb (:, i ) WRITE ( * , * ) \" STOPPING \" CALL util_exit ( FAILURE ) END IF END DO RETURN END SUBROUTINE helio_drift !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/helio_drift.f90.html"},{"title":"helio_getacch_tp.f90 – swiftest","text":"Unit Name   : helio_getacch_tp\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : helio\n  Language    : Fortran 90/95 Description : Compute heliocentric accelerations of test particles Input\n    Arguments : lflag        : logical flag indicating whether to recompute direct cross term accelerations\n                lextra_force : logical flag indicating whether to include user-supplied accelerations\n                t            : time\n                npl          : number of planets\n                nplmax       : maximum allowed number of planets\n                ntp          : number of active test particles\n                ntpmax       : maximum allowed number of test particles\n                helio_plA   : pointer to head of helio planet structure linked-list\n                helio_tpA   : pointer to head of active helio test particle structure linked-list\n                xh           : heliocentric positions of planets at time t\n                j2rp2        : J2 * R 2 for the Sun\n                j4rp4        : J4 * R 4 for the Sun\n    Terminal  : none\n    File      : none Output\n    Arguments : helio_tp1P   : pointer to head of active helio test particle structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL helio_getacch_tp(lflag, lextra_force, t, npl, nplmax, ntp, ntpmax, helio_plA, helio_tpA, xh, j2rp2, j4rp4) Notes       : Adapted from Hal Levison's Swift routine helio_getacch_tp.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~helio_getacch_tp.f90~~EfferentGraph sourcefile~helio_getacch_tp.f90 helio_getacch_tp.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~helio_getacch_tp.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~helio_getacch_tp.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~helio_getacch_tp.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_getacch_tp.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines helio_getacch_tp Source Code helio_getacch_tp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : helio_getacch_tp !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : helio !  Language    : Fortran 90/95 ! !  Description : Compute heliocentric accelerations of test particles ! !  Input !    Arguments : lflag        : logical flag indicating whether to recompute direct cross term accelerations !                lextra_force : logical flag indicating whether to include user-supplied accelerations !                t            : time !                npl          : number of planets !                nplmax       : maximum allowed number of planets !                ntp          : number of active test particles !                ntpmax       : maximum allowed number of test particles !                helio_plA   : pointer to head of helio planet structure linked-list !                helio_tpA   : pointer to head of active helio test particle structure linked-list !                xh           : heliocentric positions of planets at time t !                j2rp2        : J2 * R**2 for the Sun !                j4rp4        : J4 * R**4 for the Sun !    Terminal  : none !    File      : none ! !  Output !    Arguments : helio_tp1P   : pointer to head of active helio test particle structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL helio_getacch_tp(lflag, lextra_force, t, npl, nplmax, ntp, ntpmax, helio_plA, helio_tpA, xh, j2rp2, j4rp4) ! !  Notes       : Adapted from Hal Levison's Swift routine helio_getacch_tp.f ! !********************************************************************************************************************************** SUBROUTINE helio_getacch_tp ( lflag , lextra_force , t , npl , nplmax , ntp , ntpmax , helio_plA , helio_tpA , xh , j2rp2 , j4rp4 ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_interfaces , EXCEPT_THIS_ONE => helio_getacch_tp IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( IN ) :: lflag , lextra_force INTEGER ( I4B ), INTENT ( IN ) :: npl , nplmax , ntp , ntpmax REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 REAL ( DP ), DIMENSION ( NDIM , npl ), INTENT ( IN ) :: xh TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA TYPE ( helio_tp ), INTENT ( INOUT ) :: helio_tpA ! Internals LOGICAL ( LGT ), SAVE :: lmalloc = . TRUE . INTEGER ( I4B ) :: i REAL ( DP ) :: r2 , mu REAL ( DP ), DIMENSION (:), ALLOCATABLE , SAVE :: irh , irht REAL ( DP ), DIMENSION (:, :), ALLOCATABLE , SAVE :: aobl , xht , aoblt ! Executable code IF ( lflag ) THEN DO i = 1 , ntp helio_tpA % ahi (:, i ) = ( / 0.0_DP , 0.0_DP , 0.0_DP / ) END DO CALL helio_getacch_int_tp ( npl , ntp , helio_plA % swiftest , helio_tpA ) END IF IF ( j2rp2 /= 0.0_DP ) THEN IF ( lmalloc ) THEN ALLOCATE ( aobl ( NDIM , nplmax ), irh ( nplmax ), xht ( NDIM , ntpmax ), aoblt ( NDIM , ntpmax ), irht ( ntpmax )) lmalloc = . FALSE . END IF DO i = 2 , npl r2 = DOT_PRODUCT ( xh (:, i ), xh (:, i )) irh ( i ) = 1.0_DP / SQRT ( r2 ) END DO CALL obl_acc ( npl , helio_plA % swiftest , j2rp2 , j4rp4 , xh , irh , aobl ) mu = helio_plA % swiftest % mass ( 1 ) DO i = 1 , ntp xht (:, i ) = helio_tpA % swiftest % xh (:, i ) r2 = DOT_PRODUCT ( xht (:, i ), xht (:, i )) irht ( i ) = 1.0_DP / SQRT ( r2 ) END DO CALL obl_acc_tp ( ntp , xht , j2rp2 , j4rp4 , irht , aoblt , mu ) DO i = 1 , ntp helio_tpA % ah (:, i ) = helio_tpA % ahi (:, i ) + aoblt (:, i ) - aobl (:, 1 ) END DO ELSE DO i = 1 , ntp helio_tpA % ah (:, i ) = helio_tpA % ahi (:, i ) END DO END IF IF ( lextra_force ) CALL helio_user_getacch_tp ( t , ntp , helio_tpA ) RETURN END SUBROUTINE helio_getacch_tp !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/helio_getacch_tp.f90.html"},{"title":"helio_user_getacch_tp.f90 – swiftest","text":"Unit Name   : helio_user_getacch_tp\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : helio\n  Language    : Fortran 90/95 Description : Add user-supplied heliocentric accelerations to test particles Input\n    Arguments : t          : time\n                ntp        : number of active test particles\n                helio_tp1P : pointer to head of active helio test particle structure linked-list\n    Terminal  : TBS as needed by user\n    File      : TBS as needed by user Output\n    Arguments : helio_tp1P : pointer to head of active helio test particle structure linked-list\n    Terminal  : TBS as needed by user\n    File      : TBS as needed by user Invocation  : CALL helio_user_getacch_tp(t, ntp, helio_tp1P) Notes       : Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~helio_user_getacch_tp.f90~~EfferentGraph sourcefile~helio_user_getacch_tp.f90 helio_user_getacch_tp.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~helio_user_getacch_tp.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~helio_user_getacch_tp.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_user_getacch_tp.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines helio_user_getacch_tp Source Code helio_user_getacch_tp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : helio_user_getacch_tp !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : helio !  Language    : Fortran 90/95 ! !  Description : Add user-supplied heliocentric accelerations to test particles ! !  Input !    Arguments : t          : time !                ntp        : number of active test particles !                helio_tp1P : pointer to head of active helio test particle structure linked-list !    Terminal  : TBS as needed by user !    File      : TBS as needed by user ! !  Output !    Arguments : helio_tp1P : pointer to head of active helio test particle structure linked-list !    Terminal  : TBS as needed by user !    File      : TBS as needed by user ! !  Invocation  : CALL helio_user_getacch_tp(t, ntp, helio_tp1P) ! !  Notes       : ! !********************************************************************************************************************************** SUBROUTINE helio_user_getacch_tp ( t , ntp , helio_tpA ) ! Modules USE swiftest USE module_helio USE module_interfaces , EXCEPT_THIS_ONE => helio_user_getacch_tp IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: ntp REAL ( DP ), INTENT ( IN ) :: t TYPE ( helio_tp ), INTENT ( INOUT ) :: helio_tpA ! Internals ! Executable code RETURN END SUBROUTINE helio_user_getacch_tp !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/helio_user_getacch_tp.f90.html"},{"title":"module_interfaces.f90 – swiftest","text":"Unit Name   : module_interfaces\n  Unit Type   : module\n  Project     : Swiftest\n  Package     : module\n  Language    : Fortran 90/95 Description : Definition of interfaces of subroutines and functions used in swiftest package Input\n    Arguments : N/A\n    Terminal  : N/A\n    File      : N/A Output\n    Arguments : N/A\n    Terminal  : N/A\n    File      : N/A Invocation  : N/A Notes       : Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ Files dependent on this one sourcefile~~module_interfaces.f90~~AfferentGraph sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_helio_getacch_int.f90 symba_helio_getacch_int.f90 sourcefile~symba_helio_getacch_int.f90->sourcefile~module_interfaces.f90 sourcefile~orbel_xv2aqt.f90 orbel_xv2aqt.f90 sourcefile~orbel_xv2aqt.f90->sourcefile~module_interfaces.f90 sourcefile~helio_lindrift_tp.f90 helio_lindrift_tp.f90 sourcefile~helio_lindrift_tp.f90->sourcefile~module_interfaces.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~module_interfaces.f90 sourcefile~symba_discard_tp.f90 symba_discard_tp.f90 sourcefile~symba_discard_tp.f90->sourcefile~module_interfaces.f90 sourcefile~drift_one.f90 drift_one.f90 sourcefile~drift_one.f90->sourcefile~module_interfaces.f90 sourcefile~util_kahan_sum.f90 util_kahan_sum.f90 sourcefile~util_kahan_sum.f90->sourcefile~module_interfaces.f90 sourcefile~discard_pl_close.f90 discard_pl_close.f90 sourcefile~discard_pl_close.f90->sourcefile~module_interfaces.f90 sourcefile~symba_fragmentation.f90 symba_fragmentation.f90 sourcefile~symba_fragmentation.f90->sourcefile~module_interfaces.f90 sourcefile~obl_pot.f90 obl_pot.f90 sourcefile~obl_pot.f90->sourcefile~module_interfaces.f90 sourcefile~helio_step_tp.f90 helio_step_tp.f90 sourcefile~helio_step_tp.f90->sourcefile~module_interfaces.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~module_interfaces.f90 sourcefile~discard_peri.f90 discard_peri.f90 sourcefile~discard_peri.f90->sourcefile~module_interfaces.f90 sourcefile~io_read_encounter.f90 io_read_encounter.f90 sourcefile~io_read_encounter.f90->sourcefile~module_interfaces.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~module_interfaces.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~module_interfaces.f90 sourcefile~symba_casemerge.f90 symba_casemerge.f90 sourcefile~symba_casemerge.f90->sourcefile~module_interfaces.f90 sourcefile~io_dump_pl.f90 io_dump_pl.f90 sourcefile~io_dump_pl.f90->sourcefile~module_interfaces.f90 sourcefile~symba_reorder_pl.f90 symba_reorder_pl.f90 sourcefile~symba_reorder_pl.f90->sourcefile~module_interfaces.f90 sourcefile~symba_step_recur.f90 symba_step_recur.f90 sourcefile~symba_step_recur.f90->sourcefile~module_interfaces.f90 sourcefile~coord_vh2vb.f90 coord_vh2vb.f90 sourcefile~coord_vh2vb.f90->sourcefile~module_interfaces.f90 sourcefile~tool_encounter_read.f90 tool_encounter_read.f90 sourcefile~tool_encounter_read.f90->sourcefile~module_interfaces.f90 sourcefile~io.f90 io.f90 sourcefile~tool_encounter_read.f90->sourcefile~io.f90 sourcefile~coord_vb2vh_tp.f90 coord_vb2vh_tp.f90 sourcefile~coord_vb2vh_tp.f90->sourcefile~module_interfaces.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~module_interfaces.f90 sourcefile~util_sort_i4b.f90 util_sort_i4b.f90 sourcefile~util_sort_i4b.f90->sourcefile~module_interfaces.f90 sourcefile~symba_discard_pl.f90 symba_discard_pl.f90 sourcefile~symba_discard_pl.f90->sourcefile~module_interfaces.f90 sourcefile~util_resize_pl.f90 util_resize_pl.f90 sourcefile~util_resize_pl.f90->sourcefile~module_interfaces.f90 sourcefile~symba_step_interp.f90 symba_step_interp.f90 sourcefile~symba_step_interp.f90->sourcefile~module_interfaces.f90 sourcefile~io_write_frame.f90 io_write_frame.f90 sourcefile~io_write_frame.f90->sourcefile~module_interfaces.f90 sourcefile~symba_casedisruption.f90 symba_casedisruption.f90 sourcefile~symba_casedisruption.f90->sourcefile~module_interfaces.f90 sourcefile~helio_lindrift.f90 helio_lindrift.f90 sourcefile~helio_lindrift.f90->sourcefile~module_interfaces.f90 sourcefile~helio_user_getacch_tp.f90 helio_user_getacch_tp.f90 sourcefile~helio_user_getacch_tp.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest_symba.f90 swiftest_symba.f90 sourcefile~swiftest_symba.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest_symba.f90->sourcefile~io.f90 sourcefile~symba_user_getacch_tp.f90 symba_user_getacch_tp.f90 sourcefile~symba_user_getacch_tp.f90->sourcefile~module_interfaces.f90 sourcefile~io_getn.f90 io_getn.f90 sourcefile~io_getn.f90->sourcefile~module_interfaces.f90 sourcefile~drift_kepu_fchk.f90 drift_kepu_fchk.f90 sourcefile~drift_kepu_fchk.f90->sourcefile~module_interfaces.f90 sourcefile~helio_getacch_tp.f90 helio_getacch_tp.f90 sourcefile~helio_getacch_tp.f90->sourcefile~module_interfaces.f90 sourcefile~symba_merge_tp.f90 symba_merge_tp.f90 sourcefile~symba_merge_tp.f90->sourcefile~module_interfaces.f90 sourcefile~orbel_xv2aeq.f90 orbel_xv2aeq.f90 sourcefile~orbel_xv2aeq.f90->sourcefile~module_interfaces.f90 sourcefile~coord_h2b.f90 coord_h2b.f90 sourcefile~coord_h2b.f90->sourcefile~module_interfaces.f90 sourcefile~drift_kepu_guess.f90 drift_kepu_guess.f90 sourcefile~drift_kepu_guess.f90->sourcefile~module_interfaces.f90 sourcefile~drift_kepu_stumpff.f90 drift_kepu_stumpff.f90 sourcefile~drift_kepu_stumpff.f90->sourcefile~module_interfaces.f90 sourcefile~io_init_pl.f90 io_init_pl.f90 sourcefile~io_init_pl.f90->sourcefile~module_interfaces.f90 sourcefile~symba_step_helio.f90 symba_step_helio.f90 sourcefile~symba_step_helio.f90->sourcefile~module_interfaces.f90 sourcefile~obl_acc.f90 obl_acc.f90 sourcefile~obl_acc.f90->sourcefile~module_interfaces.f90 sourcefile~io.f90->sourcefile~module_interfaces.f90 sourcefile~symba_chk.f90 symba_chk.f90 sourcefile~symba_chk.f90->sourcefile~module_interfaces.f90 sourcefile~drift_kepmd.f90 drift_kepmd.f90 sourcefile~drift_kepmd.f90->sourcefile~module_interfaces.f90 sourcefile~util_hills.f90 util_hills.f90 sourcefile~util_hills.f90->sourcefile~module_interfaces.f90 sourcefile~drift_kepu_new.f90 drift_kepu_new.f90 sourcefile~drift_kepu_new.f90->sourcefile~module_interfaces.f90 sourcefile~io_read_hdr.f90 io_read_hdr.f90 sourcefile~io_read_hdr.f90->sourcefile~module_interfaces.f90 sourcefile~orbel_xv2el.f90 orbel_xv2el.f90 sourcefile~orbel_xv2el.f90->sourcefile~module_interfaces.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~module_interfaces.f90 sourcefile~discard_sun.f90 discard_sun.f90 sourcefile~discard_sun.f90->sourcefile~module_interfaces.f90 sourcefile~io_write_line.f90 io_write_line.f90 sourcefile~io_write_line.f90->sourcefile~module_interfaces.f90 sourcefile~coord_h2b_tp.f90 coord_h2b_tp.f90 sourcefile~coord_h2b_tp.f90->sourcefile~module_interfaces.f90 sourcefile~drift_kepu_p3solve.f90 drift_kepu_p3solve.f90 sourcefile~drift_kepu_p3solve.f90->sourcefile~module_interfaces.f90 sourcefile~util_toupper.f90 util_toupper.f90 sourcefile~util_toupper.f90->sourcefile~module_interfaces.f90 sourcefile~symba_discard_peri_pl.f90 symba_discard_peri_pl.f90 sourcefile~symba_discard_peri_pl.f90->sourcefile~module_interfaces.f90 sourcefile~drift_dan.f90 drift_dan.f90 sourcefile~drift_dan.f90->sourcefile~module_interfaces.f90 sourcefile~io_write_hdr.f90 io_write_hdr.f90 sourcefile~io_write_hdr.f90->sourcefile~module_interfaces.f90 sourcefile~symba_step_helio_pl.f90 symba_step_helio_pl.f90 sourcefile~symba_step_helio_pl.f90->sourcefile~module_interfaces.f90 sourcefile~symba_getacch_tp.f90 symba_getacch_tp.f90 sourcefile~symba_getacch_tp.f90->sourcefile~module_interfaces.f90 sourcefile~symba_helio_drift_tp.f90 symba_helio_drift_tp.f90 sourcefile~symba_helio_drift_tp.f90->sourcefile~module_interfaces.f90 sourcefile~helio_kickvb.f90 helio_kickvb.f90 sourcefile~helio_kickvb.f90->sourcefile~module_interfaces.f90 sourcefile~symba_helio_getacch.f90 symba_helio_getacch.f90 sourcefile~symba_helio_getacch.f90->sourcefile~module_interfaces.f90 sourcefile~symba_helio_drift.f90 symba_helio_drift.f90 sourcefile~symba_helio_drift.f90->sourcefile~module_interfaces.f90 sourcefile~coord_vh2vb_tp.f90 coord_vh2vb_tp.f90 sourcefile~coord_vh2vb_tp.f90->sourcefile~module_interfaces.f90 sourcefile~symba_casehitandrun.f90 symba_casehitandrun.f90 sourcefile~symba_casehitandrun.f90->sourcefile~module_interfaces.f90 sourcefile~coord_vb2vh.f90 coord_vb2vh.f90 sourcefile~coord_vb2vh.f90->sourcefile~module_interfaces.f90 sourcefile~helio_getacch_int_tp.f90 helio_getacch_int_tp.f90 sourcefile~helio_getacch_int_tp.f90->sourcefile~module_interfaces.f90 sourcefile~helio_step_pl.f90 helio_step_pl.f90 sourcefile~helio_step_pl.f90->sourcefile~module_interfaces.f90 sourcefile~symba_merge_pl.f90 symba_merge_pl.f90 sourcefile~symba_merge_pl.f90->sourcefile~module_interfaces.f90 sourcefile~io_open_fxdr.f90 io_open_fxdr.f90 sourcefile~io_open_fxdr.f90->sourcefile~module_interfaces.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~module_interfaces.f90 sourcefile~io_open.f90 io_open.f90 sourcefile~io_open.f90->sourcefile~module_interfaces.f90 sourcefile~drift_kepu.f90 drift_kepu.f90 sourcefile~drift_kepu.f90->sourcefile~module_interfaces.f90 sourcefile~symba_peri.f90 symba_peri.f90 sourcefile~symba_peri.f90->sourcefile~module_interfaces.f90 sourcefile~io_write_encounter.f90 io_write_encounter.f90 sourcefile~io_write_encounter.f90->sourcefile~module_interfaces.f90 sourcefile~symba_discard_sun_pl.f90 symba_discard_sun_pl.f90 sourcefile~symba_discard_sun_pl.f90->sourcefile~module_interfaces.f90 sourcefile~io_discard_write_symba.f90 io_discard_write_symba.f90 sourcefile~io_discard_write_symba.f90->sourcefile~module_interfaces.f90 sourcefile~symba_rearray.f90 symba_rearray.f90 sourcefile~symba_rearray.f90->sourcefile~module_interfaces.f90 sourcefile~io_dump_param.f90 io_dump_param.f90 sourcefile~io_dump_param.f90->sourcefile~module_interfaces.f90 sourcefile~helio_getacch.f90 helio_getacch.f90 sourcefile~helio_getacch.f90->sourcefile~module_interfaces.f90 sourcefile~helio_getacch_int.f90 helio_getacch_int.f90 sourcefile~helio_getacch_int.f90->sourcefile~module_interfaces.f90 sourcefile~io_init_tp.f90 io_init_tp.f90 sourcefile~io_init_tp.f90->sourcefile~module_interfaces.f90 sourcefile~obl_acc_tp.f90 obl_acc_tp.f90 sourcefile~obl_acc_tp.f90->sourcefile~module_interfaces.f90 sourcefile~util_sort_sp.f90 util_sort_sp.f90 sourcefile~util_sort_sp.f90->sourcefile~module_interfaces.f90 sourcefile~orbel_scget.f90 orbel_scget.f90 sourcefile~orbel_scget.f90->sourcefile~module_interfaces.f90 sourcefile~util_sort_dp.f90 util_sort_dp.f90 sourcefile~util_sort_dp.f90->sourcefile~module_interfaces.f90 sourcefile~helio_drift_tp.f90 helio_drift_tp.f90 sourcefile~helio_drift_tp.f90->sourcefile~module_interfaces.f90 sourcefile~helio_user_getacch.f90 helio_user_getacch.f90 sourcefile~helio_user_getacch.f90->sourcefile~module_interfaces.f90 sourcefile~helio_kickvb_tp.f90 helio_kickvb_tp.f90 sourcefile~helio_kickvb_tp.f90->sourcefile~module_interfaces.f90 sourcefile~python_io_write_frame_tp.f90 python_io_write_frame_tp.f90 sourcefile~python_io_write_frame_tp.f90->sourcefile~module_interfaces.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~module_interfaces.f90 sourcefile~io_read_line.f90 io_read_line.f90 sourcefile~io_read_line.f90->sourcefile~module_interfaces.f90 sourcefile~util_index.f90 util_index.f90 sourcefile~util_index.f90->sourcefile~module_interfaces.f90 sourcefile~io_dump_tp.f90 io_dump_tp.f90 sourcefile~io_dump_tp.f90->sourcefile~module_interfaces.f90 sourcefile~symba_caseresolve.f90 symba_caseresolve.f90 sourcefile~symba_caseresolve.f90->sourcefile~module_interfaces.f90 sourcefile~symba_energy.f90 symba_energy.f90 sourcefile~symba_energy.f90->sourcefile~module_interfaces.f90 sourcefile~symba_user_getacch.f90 symba_user_getacch.f90 sourcefile~symba_user_getacch.f90->sourcefile~module_interfaces.f90 sourcefile~symba_getacch.f90 symba_getacch.f90 sourcefile~symba_getacch.f90->sourcefile~module_interfaces.f90 sourcefile~discard_pl.f90 discard_pl.f90 sourcefile~discard_pl.f90->sourcefile~module_interfaces.f90 sourcefile~python_io_write_frame_pl.f90 python_io_write_frame_pl.f90 sourcefile~python_io_write_frame_pl.f90->sourcefile~module_interfaces.f90 sourcefile~symba_discard_merge_pl.f90 symba_discard_merge_pl.f90 sourcefile~symba_discard_merge_pl.f90->sourcefile~module_interfaces.f90 sourcefile~rmvs_chk_ind.f90 rmvs_chk_ind.f90 sourcefile~rmvs_chk_ind.f90->sourcefile~module_interfaces.f90 sourcefile~symba_casesupercatastrophic.f90 symba_casesupercatastrophic.f90 sourcefile~symba_casesupercatastrophic.f90->sourcefile~module_interfaces.f90 sourcefile~drift_kepu_lag.f90 drift_kepu_lag.f90 sourcefile~drift_kepu_lag.f90->sourcefile~module_interfaces.f90 sourcefile~io_read_param_in.f90 io_read_param_in.f90 sourcefile~io_read_param_in.f90->sourcefile~io.f90 sourcefile~io_read_pl_in.f90 io_read_pl_in.f90 sourcefile~io_read_pl_in.f90->sourcefile~io.f90 sourcefile~io_get_token.f90 io_get_token.f90 sourcefile~io_get_token.f90->sourcefile~io.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules module_interfaces Source Code module_interfaces.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : module_interfaces !  Unit Type   : module !  Project     : Swiftest !  Package     : module !  Language    : Fortran 90/95 ! !  Description : Definition of interfaces of subroutines and functions used in swiftest package ! !  Input !    Arguments : N/A !    Terminal  : N/A !    File      : N/A ! !  Output !    Arguments : N/A !    Terminal  : N/A !    File      : N/A ! !  Invocation  : N/A ! !  Notes       : ! !********************************************************************************************************************************** MODULE module_interfaces IMPLICIT NONE INTERFACE SUBROUTINE coord_h2b ( npl , swiftest_plA , msys ) USE swiftest USE module_swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( OUT ) :: msys TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA END SUBROUTINE coord_h2b END INTERFACE INTERFACE SUBROUTINE coord_h2b_tp ( ntp , swiftest_tpA , swiftest_plA ) USE swiftest USE module_swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: ntp TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA END SUBROUTINE coord_h2b_tp END INTERFACE INTERFACE SUBROUTINE coord_vb2vh ( npl , swiftest_plA ) USE swiftest USE module_swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: npl TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA END SUBROUTINE coord_vb2vh END INTERFACE INTERFACE SUBROUTINE coord_vb2vh_tp ( ntp , swiftest_tpA , vs ) USE swiftest USE module_swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: ntp REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: vs TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA END SUBROUTINE coord_vb2vh_tp END INTERFACE INTERFACE SUBROUTINE coord_vh2vb ( npl , swiftest_plA , msys ) USE swiftest USE module_swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( OUT ) :: msys TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA END SUBROUTINE coord_vh2vb END INTERFACE INTERFACE SUBROUTINE coord_vh2vb_tp ( ntp , swiftest_tpA , vs ) USE swiftest USE module_swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: ntp REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: vs TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA END SUBROUTINE coord_vh2vb_tp END INTERFACE INTERFACE SUBROUTINE discard ( t , dt , npl , ntp , swiftest_plA , swiftest_tpA , rmin , rmax , rmaxu , qmin , & qmin_alo , qmin_ahi , qmin_coord , lclose , lrhill_present ) USE swiftest USE module_swiftest IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lclose , lrhill_present INTEGER ( I4B ), INTENT ( IN ) :: npl , ntp REAL ( DP ), INTENT ( IN ) :: t , dt , rmin , rmax , rmaxu , qmin , qmin_alo , qmin_ahi CHARACTER ( * ), INTENT ( IN ) :: qmin_coord TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA END SUBROUTINE discard END INTERFACE INTERFACE SUBROUTINE discard_peri ( t , npl , ntp , swiftest_plA , swiftest_tpA , msys , qmin , qmin_alo , & qmin_ahi , qmin_coord , lrhill_present ) USE swiftest USE module_swiftest IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lrhill_present INTEGER ( I4B ), INTENT ( IN ) :: npl , ntp REAL ( DP ), INTENT ( IN ) :: t , msys , qmin , qmin_alo , qmin_ahi CHARACTER ( * ), INTENT ( IN ) :: qmin_coord TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA END SUBROUTINE discard_peri END INTERFACE INTERFACE SUBROUTINE discard_pl_close ( dx , dv , dt , r2crit , iflag , r2min ) USE swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( OUT ) :: iflag REAL ( DP ), INTENT ( IN ) :: dt , r2crit REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: dx , dv REAL ( DP ), INTENT ( OUT ) :: r2min END SUBROUTINE discard_pl_close END INTERFACE INTERFACE SUBROUTINE discard_pl ( t , dt , npl , ntp , swiftest_plA , swiftest_tpA ) USE swiftest USE module_swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: npl , ntp REAL ( DP ), INTENT ( IN ) :: t , dt TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA END SUBROUTINE discard_pl END INTERFACE INTERFACE SUBROUTINE discard_sun ( t , ntp , msys , swifter_tpA , rmin , rmax , rmaxu ) USE swiftest USE module_swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: ntp REAL ( DP ), INTENT ( IN ) :: t , msys , rmin , rmax , rmaxu TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swifter_tpA END SUBROUTINE discard_sun END INTERFACE INTERFACE SUBROUTINE drift_dan ( mu , x0 , v0 , dt0 , iflag ) USE swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( OUT ) :: iflag REAL ( DP ), INTENT ( IN ) :: mu , dt0 REAL ( DP ), DIMENSION ( NDIM ), INTENT ( INOUT ) :: x0 , v0 END SUBROUTINE drift_dan END INTERFACE INTERFACE SUBROUTINE drift_kepmd ( dm , es , ec , x , s , c ) USE swiftest IMPLICIT NONE REAL ( DP ), INTENT ( IN ) :: dm , es , ec REAL ( DP ), INTENT ( OUT ) :: x , s , c END SUBROUTINE drift_kepmd END INTERFACE INTERFACE SUBROUTINE drift_kepu ( dt , r0 , mu , alpha , u , fp , c1 , c2 , c3 , iflag ) USE swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( OUT ) :: iflag REAL ( DP ), INTENT ( IN ) :: dt , r0 , mu , alpha , u REAL ( DP ), INTENT ( OUT ) :: fp , c1 , c2 , c3 END SUBROUTINE drift_kepu END INTERFACE INTERFACE SUBROUTINE drift_kepu_fchk ( dt , r0 , mu , alpha , u , s , f ) USE swiftest IMPLICIT NONE REAL ( DP ), INTENT ( IN ) :: dt , r0 , mu , alpha , u , s REAL ( DP ), INTENT ( OUT ) :: f END SUBROUTINE drift_kepu_fchk END INTERFACE INTERFACE SUBROUTINE drift_kepu_guess ( dt , r0 , mu , alpha , u , s ) USE swiftest IMPLICIT NONE REAL ( DP ), INTENT ( IN ) :: dt , r0 , mu , alpha , u REAL ( DP ), INTENT ( OUT ) :: s END SUBROUTINE drift_kepu_guess END INTERFACE INTERFACE SUBROUTINE drift_kepu_lag ( s , dt , r0 , mu , alpha , u , fp , c1 , c2 , c3 , iflag ) USE swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( OUT ) :: iflag REAL ( DP ), INTENT ( IN ) :: dt , r0 , mu , alpha , u REAL ( DP ), INTENT ( INOUT ) :: s REAL ( DP ), INTENT ( OUT ) :: fp , c1 , c2 , c3 END SUBROUTINE drift_kepu_lag END INTERFACE INTERFACE SUBROUTINE drift_kepu_new ( s , dt , r0 , mu , alpha , u , fp , c1 , c2 , c3 , iflag ) USE swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( OUT ) :: iflag REAL ( DP ), INTENT ( IN ) :: dt , r0 , mu , alpha , u REAL ( DP ), INTENT ( INOUT ) :: s REAL ( DP ), INTENT ( OUT ) :: fp , c1 , c2 , c3 END SUBROUTINE drift_kepu_new END INTERFACE INTERFACE SUBROUTINE drift_kepu_p3solve ( dt , r0 , mu , alpha , u , s , iflag ) USE swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( OUT ) :: iflag REAL ( DP ), INTENT ( IN ) :: dt , r0 , mu , alpha , u REAL ( DP ), INTENT ( OUT ) :: s END SUBROUTINE drift_kepu_p3solve END INTERFACE INTERFACE SUBROUTINE drift_kepu_stumpff ( x , c0 , c1 , c2 , c3 ) USE swiftest IMPLICIT NONE REAL ( DP ), INTENT ( INOUT ) :: x REAL ( DP ), INTENT ( OUT ) :: c0 , c1 , c2 , c3 END SUBROUTINE drift_kepu_stumpff END INTERFACE INTERFACE SUBROUTINE drift_one ( mu , x , v , dt , iflag ) USE swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( OUT ) :: iflag REAL ( DP ), INTENT ( IN ) :: mu , dt REAL ( DP ), DIMENSION ( NDIM ), INTENT ( INOUT ) :: x , v END SUBROUTINE drift_one END INTERFACE INTERFACE SUBROUTINE helio_drift ( npl , swiftest_plA , dt ) USE swiftest USE module_swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: dt TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA END SUBROUTINE helio_drift END INTERFACE INTERFACE SUBROUTINE helio_drift_tp ( ntp , swiftest_tpA , mu , dt ) USE swiftest USE module_swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: ntp REAL ( DP ), INTENT ( IN ) :: mu , dt TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA END SUBROUTINE helio_drift_tp END INTERFACE INTERFACE SUBROUTINE helio_getacch ( lflag , lextra_force , t , npl , nplmax , helio_plA , j2rp2 , j4rp4 ) USE swiftest USE module_swiftest USE module_helio IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lflag , lextra_force INTEGER ( I4B ), INTENT ( IN ) :: npl , nplmax REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA END SUBROUTINE helio_getacch END INTERFACE INTERFACE SUBROUTINE helio_getacch_int ( npl , helio_plA ) USE swiftest USE module_helio IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: npl TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA END SUBROUTINE helio_getacch_int END INTERFACE INTERFACE SUBROUTINE helio_getacch_int_tp ( npl , ntp , swiftest_plA , helio_tpA ) USE swiftest USE module_swiftest USE module_helio IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: npl , ntp TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA TYPE ( helio_tp ), INTENT ( INOUT ) :: helio_tpA END SUBROUTINE helio_getacch_int_tp END INTERFACE INTERFACE SUBROUTINE helio_getacch_tp ( lflag , lextra_force , t , npl , nplmax , ntp , ntpmax , helio_plA , helio_tpA , xh , j2rp2 , j4rp4 ) USE swiftest USE module_swiftest USE module_helio IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lflag , lextra_force INTEGER ( I4B ), INTENT ( IN ) :: npl , nplmax , ntp , ntpmax REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 REAL ( DP ), DIMENSION ( NDIM , npl ), INTENT ( IN ) :: xh TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA TYPE ( helio_tp ), INTENT ( INOUT ) :: helio_tpA END SUBROUTINE helio_getacch_tp END INTERFACE INTERFACE SUBROUTINE helio_kickvb ( npl , helio_plA , dt ) USE swiftest USE module_swiftest USE module_helio IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: dt TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA END SUBROUTINE helio_kickvb END INTERFACE INTERFACE SUBROUTINE helio_kickvb_tp ( ntp , helio_tpA , dt ) USE swiftest USE module_swiftest USE module_helio IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: ntp REAL ( DP ), INTENT ( IN ) :: dt TYPE ( helio_tp ), INTENT ( INOUT ) :: helio_tpA END SUBROUTINE helio_kickvb_tp END INTERFACE INTERFACE SUBROUTINE helio_lindrift ( npl , swiftest_plA , dt , pt ) USE swiftest USE module_swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: dt REAL ( DP ), DIMENSION ( NDIM ), INTENT ( OUT ) :: pt TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA END SUBROUTINE helio_lindrift END INTERFACE INTERFACE SUBROUTINE helio_lindrift_tp ( ntp , swiftest_tpA , dt , pt ) USE swiftest USE module_swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: ntp REAL ( DP ), INTENT ( IN ) :: dt REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: pt TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA END SUBROUTINE helio_lindrift_tp END INTERFACE INTERFACE SUBROUTINE helio_step ( lfirst , lextra_force , t , npl , nplmax , ntp , ntpmax , helio_plA , helio_tpA , j2rp2 , j4rp4 , dt ) USE swiftest USE module_helio IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lextra_force LOGICAL ( LGT ), INTENT ( INOUT ) :: lfirst INTEGER ( I4B ), INTENT ( IN ) :: npl , nplmax , ntp , ntpmax REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 , dt TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA TYPE ( helio_tp ), INTENT ( INOUT ) :: helio_tpA END SUBROUTINE helio_step END INTERFACE INTERFACE SUBROUTINE helio_step_pl ( lfirst , lextra_force , t , npl , nplmax , helio_plA , j2rp2 , j4rp4 , dt , xbeg , xend , ptb , pte ) USE swiftest USE module_swiftest USE module_helio IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lextra_force LOGICAL ( LGT ), INTENT ( INOUT ) :: lfirst INTEGER ( I4B ), INTENT ( IN ) :: npl , nplmax REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 , dt REAL ( DP ), DIMENSION ( NDIM ), INTENT ( OUT ) :: ptb , pte REAL ( DP ), DIMENSION ( NDIM , npl ), INTENT ( OUT ) :: xbeg , xend TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA END SUBROUTINE helio_step_pl END INTERFACE INTERFACE SUBROUTINE helio_step_tp ( lfirsttp , lextra_force , t , npl , nplmax , ntp , ntpmax , helio_plA , helio_tpA , j2rp2 , j4rp4 , dt , & xbeg , xend , ptb , pte ) USE swiftest USE module_swiftest USE module_helio IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lextra_force LOGICAL ( LGT ), INTENT ( INOUT ) :: lfirsttp INTEGER ( I4B ), INTENT ( IN ) :: npl , nplmax , ntp , ntpmax REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 , dt REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: ptb , pte REAL ( DP ), DIMENSION ( NDIM , npl ), INTENT ( IN ) :: xbeg , xend TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA TYPE ( helio_tp ), INTENT ( INOUT ) :: helio_tpA END SUBROUTINE helio_step_tp END INTERFACE INTERFACE SUBROUTINE helio_user_getacch ( t , npl , helio_plA ) USE swiftest USE module_helio IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: t TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA END SUBROUTINE helio_user_getacch END INTERFACE INTERFACE SUBROUTINE helio_user_getacch_tp ( t , ntp , helio_tpA ) USE swiftest USE module_helio IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: ntp REAL ( DP ), INTENT ( IN ) :: t TYPE ( helio_tp ), INTENT ( INOUT ) :: helio_tpA END SUBROUTINE helio_user_getacch_tp END INTERFACE INTERFACE SUBROUTINE io_discard_write_symba ( t , mtiny , npl , ntp , nsppl , nsptp , nmergeadd , symba_plA , & discard_plA , discard_tpA , mergeadd_list , mergesub_list , fname , lbig_discard ) USE swiftest USE module_swiftest USE module_symba IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lbig_discard INTEGER ( I4B ), INTENT ( IN ) :: npl , ntp , nsppl , nsptp , nmergeadd REAL ( DP ), INTENT ( IN ) :: t , mtiny CHARACTER ( * ), INTENT ( IN ) :: fname TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( swiftest_tp ), INTENT ( INOUT ) :: discard_tpA TYPE ( swiftest_pl ), INTENT ( INOUT ) :: discard_plA TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list END SUBROUTINE io_discard_write_symba END INTERFACE INTERFACE SUBROUTINE io_dump_param ( nplmax , ntpmax , ntp , t , tstop , dt , in_type , istep_out , outfile , out_type , out_form , & istep_dump , j2rp2 , j4rp4 , rmin , rmax , rmaxu , qmin , qmin_coord , qmin_alo , qmin_ahi , encounter_file , & mtiny , feature , ring_outfile ) USE swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: nplmax , ntpmax , ntp , istep_out , istep_dump REAL ( DP ), INTENT ( IN ) :: t , tstop , dt , j2rp2 , j4rp4 , rmin , rmax , rmaxu , qmin , qmin_alo , qmin_ahi CHARACTER ( * ), INTENT ( IN ) :: qmin_coord , encounter_file , in_type , outfile , out_type , out_form REAl ( DP ), INTENT ( IN ), OPTIONAL :: mtiny TYPE ( feature_list ), INTENT ( IN ) :: feature CHARACTER ( * ), INTENT ( IN ), OPTIONAL :: ring_outfile END SUBROUTINE io_dump_param END INTERFACE INTERFACE SUBROUTINE io_dump_pl ( npl , swiftest_plA , lclose , lrhill_present ) USE swiftest USE module_swiftest USE module_fxdr IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lclose , lrhill_present INTEGER ( I4B ), INTENT ( IN ) :: npl TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA END SUBROUTINE io_dump_pl END INTERFACE INTERFACE SUBROUTINE io_dump_tp ( ntp , swiftest_tpA ) USE swiftest USE module_swiftest USE module_fxdr IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: ntp TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA END SUBROUTINE io_dump_tp END INTERFACE INTERFACE SUBROUTINE io_getn ( inplfile , intpfile , in_type , npl , nplmax , ntp , ntpmax ) USE swiftest USE module_fxdr IMPLICIT NONE INTEGER ( I4B ), INTENT ( INOUT ) :: nplmax , ntpmax INTEGER ( I4B ), INTENT ( OUT ) :: npl , ntp CHARACTER ( * ), INTENT ( IN ) :: inplfile , intpfile , in_type END SUBROUTINE io_getn END INTERFACE INTERFACE SUBROUTINE io_init_pl ( inplfile , in_type , lclose , lrhill_present , npl , symba_plA ) USE swiftest USE module_swiftest USE module_symba USE module_helio USE module_fxdr IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lclose , lrhill_present INTEGER ( I4B ), INTENT ( IN ) :: npl CHARACTER ( * ), INTENT ( IN ) :: inplfile , in_type TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA END SUBROUTINE io_init_pl END INTERFACE INTERFACE SUBROUTINE io_init_tp ( intpfile , in_type , ntp , symba_tpA ) USE swiftest USE module_swiftest USE module_symba USE module_helio USE module_fxdr IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: ntp CHARACTER ( * ), INTENT ( IN ) :: intpfile , in_type TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA END SUBROUTINE io_init_tp END INTERFACE INTERFACE SUBROUTINE io_open ( iu , fname , fopenstat , fmt , ierr ) USE swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: iu INTEGER ( I4B ), INTENT ( OUT ) :: ierr CHARACTER ( * ), INTENT ( IN ) :: fname , fopenstat , fmt END SUBROUTINE io_open END INTERFACE INTERFACE SUBROUTINE io_open_fxdr ( fname , fopenstat , lflag , iu , ierr ) USE swiftest USE module_fxdr IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lflag INTEGER ( I4B ), INTENT ( OUT ) :: iu , ierr CHARACTER ( * ), INTENT ( IN ) :: fname CHARACTER ( 1 ), INTENT ( IN ) :: fopenstat END SUBROUTINE io_open_fxdr END INTERFACE INTERFACE FUNCTION io_read_encounter ( t , name1 , name2 , mass1 , mass2 , xh1 , xh2 , vh1 , vh2 , encounter_file , out_type ) USE swiftest USE module_fxdr IMPLICIT NONE INTEGER ( I4B ) :: io_read_encounter INTEGER ( I4B ), INTENT ( OUT ) :: name1 , name2 REAL ( DP ), INTENT ( OUT ) :: t , mass1 , mass2 REAL ( DP ), DIMENSION ( NDIM ), INTENT ( OUT ) :: xh1 , xh2 , vh1 , vh2 CHARACTER ( * ), INTENT ( IN ) :: encounter_file , out_type END FUNCTION io_read_encounter END INTERFACE INTERFACE FUNCTION io_read_hdr ( iu , t , npl , ntp , iout_form , out_type ) USE swiftest USE module_fxdr IMPLICIT NONE INTEGER ( I4B ) :: io_read_hdr INTEGER ( I4B ), INTENT ( IN ) :: iu INTEGER ( I4B ), INTENT ( OUT ) :: npl , ntp , iout_form REAL ( DP ), INTENT ( OUT ) :: t CHARACTER ( * ), INTENT ( IN ) :: out_type END FUNCTION io_read_hdr END INTERFACE INTERFACE FUNCTION io_read_line ( iu , name , d1 , d2 , d3 , d4 , d5 , d6 , out_type , MASS , RADIUS ) USE swiftest USE module_fxdr IMPLICIT NONE INTEGER ( I4B ) :: io_read_line INTEGER ( I4B ), INTENT ( IN ) :: iu INTEGER ( I4B ), INTENT ( OUT ) :: name REAL ( DP ), INTENT ( OUT ) :: d1 , d2 , d3 , d4 , d5 , d6 REAL ( DP ), OPTIONAL , INTENT ( OUT ) :: MASS , RADIUS CHARACTER ( * ), INTENT ( IN ) :: out_type END FUNCTION io_read_line END INTERFACE INTERFACE SUBROUTINE io_write_encounter ( t , name1 , name2 , mass1 , mass2 , radius1 , radius2 , & xh1 , xh2 , vh1 , vh2 , encounter_file , out_type ) USE swiftest USE module_fxdr IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: name1 , name2 REAL ( DP ), INTENT ( IN ) :: t , mass1 , mass2 , radius1 , radius2 REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: xh1 , xh2 , vh1 , vh2 CHARACTER ( * ), INTENT ( IN ) :: encounter_file , out_type END SUBROUTINE io_write_encounter END INTERFACE INTERFACE SUBROUTINE io_write_frame ( t , npl , ntp , swiftest_plA , swiftest_tpA , outfile , & out_type , out_form , out_stat ) USE swiftest USE module_swiftest USE module_fxdr IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: npl , ntp REAL ( DP ), INTENT ( IN ) :: t CHARACTER ( * ), INTENT ( IN ) :: outfile , out_type , out_form , out_stat TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA END SUBROUTINE io_write_frame END INTERFACE INTERFACE SUBROUTINE io_write_hdr ( iu , t , npl , ntp , iout_form , out_type ) USE swiftest USE module_fxdr IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: iu , npl , ntp , iout_form REAL ( DP ), INTENT ( IN ) :: t CHARACTER ( * ), INTENT ( IN ) :: out_type END SUBROUTINE io_write_hdr END INTERFACE INTERFACE SUBROUTINE io_write_line ( iu , name , d1 , d2 , d3 , d4 , d5 , d6 , out_type , MASS , RADIUS ) USE swiftest USE module_fxdr IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: iu , name REAL ( DP ), INTENT ( IN ) :: d1 , d2 , d3 , d4 , d5 , d6 REAL ( DP ), OPTIONAL , INTENT ( IN ) :: MASS , RADIUS CHARACTER ( * ), INTENT ( IN ) :: out_type END SUBROUTINE io_write_line END INTERFACE INTERFACE SUBROUTINE obl_acc ( npl , swiftest_plA , j2rp2 , j4rp4 , xh , irh , aobl ) USE swiftest USE module_swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: j2rp2 , j4rp4 REAL ( DP ), DIMENSION ( npl ), INTENT ( IN ) :: irh REAL ( DP ), DIMENSION ( NDIM , npl ), INTENT ( IN ) :: xh REAL ( DP ), DIMENSION ( NDIM , npl ), INTENT ( OUT ) :: aobl TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA END SUBROUTINE obl_acc END INTERFACE INTERFACE SUBROUTINE obl_acc_tp ( ntp , xht , j2rp2 , j4rp4 , irht , aoblt , msun ) USE swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: ntp REAL ( DP ), INTENT ( IN ) :: j2rp2 , j4rp4 , msun REAL ( DP ), DIMENSION ( ntp ), INTENT ( IN ) :: irht REAL ( DP ), DIMENSION ( NDIM , ntp ), INTENT ( IN ) :: xht REAL ( DP ), DIMENSION ( NDIM , ntp ), INTENT ( OUT ) :: aoblt END SUBROUTINE obl_acc_tp END INTERFACE INTERFACE SUBROUTINE obl_pot ( npl , swiftest_plA , j2rp2 , j4rp4 , xh , irh , oblpot ) USE swiftest USE module_swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: j2rp2 , j4rp4 REAL ( DP ), INTENT ( OUT ) :: oblpot REAL ( DP ), DIMENSION ( npl ), INTENT ( IN ) :: irh REAL ( DP ), DIMENSION ( NDIM , npl ), INTENT ( IN ) :: xh TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA END SUBROUTINE obl_pot END INTERFACE INTERFACE SUBROUTINE orbel_scget ( angle , sx , cx ) USE swiftest IMPLICIT NONE REAL ( DP ), INTENT ( IN ) :: angle REAL ( DP ), INTENT ( OUT ) :: sx , cx END SUBROUTINE orbel_scget END INTERFACE INTERFACE SUBROUTINE orbel_xv2aeq ( x , v , mu , a , e , q ) USE swiftest IMPLICIT NONE REAL ( DP ), INTENT ( IN ) :: mu REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: x , v REAL ( DP ), INTENT ( OUT ) :: a , e , q END SUBROUTINE orbel_xv2aeq END INTERFACE INTERFACE SUBROUTINE orbel_xv2aqt ( x , v , mu , a , q , capm , tperi ) USE swiftest IMPLICIT NONE REAL ( DP ), INTENT ( IN ) :: mu REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: x , v REAL ( DP ), INTENT ( OUT ) :: a , q , capm , tperi END SUBROUTINE orbel_xv2aqt END INTERFACE INTERFACE SUBROUTINE orbel_xv2el ( x , v , mu , a , e , inc , capom , omega , capm ) USE swiftest IMPLICIT NONE REAL ( DP ), INTENT ( IN ) :: mu REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: x , v REAL ( DP ), INTENT ( OUT ) :: a , e , inc , capom , omega , capm END SUBROUTINE orbel_xv2el END INTERFACE INTERFACE SUBROUTINE python_io_write_frame_pl ( t , symba_plA , npl , out_stat ) use swiftest use module_swiftest use module_helio use module_symba IMPLICIT NONE real ( DP ), intent ( in ) :: t type ( symba_pl ), intent ( in ) :: symba_plA integer , intent ( in ) :: npl character ( * ), intent ( in ) :: out_stat END SUBROUTINE python_io_write_frame_pl END INTERFACE INTERFACE SUBROUTINE python_io_write_frame_tp ( t , symba_tpA , ntp , out_stat ) use swiftest use module_swiftest use module_helio use module_symba IMPLICIT NONE real ( DP ), intent ( in ) :: t type ( symba_tp ), intent ( in ) :: symba_tpA integer , intent ( in ) :: ntp character ( * ), intent ( in ) :: out_stat END SUBROUTINE python_io_write_frame_tp END INTERFACE INTERFACE SUBROUTINE rmvs_chk_ind ( xr , vr , dt , r2crit , iflag ) USE swiftest IMPLICIT NONE REAL ( DP ), INTENT ( IN ) :: dt , r2crit REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: xr , vr INTEGER ( I4B ), INTENT ( OUT ) :: iflag END SUBROUTINE rmvs_chk_ind END INTERFACE INTERFACE SUBROUTINE symba_casedisruption ( t , dt , index_enc , nmergeadd , nmergesub , mergeadd_list , mergesub_list , eoffset , vbs , & symba_plA , nplplenc , plplenc_list , nplmax , ntpmax , fragmax , mres , rres , m1 , m2 , rad1 , rad2 , x1 , x2 , v1 , v2 ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: index_enc , nplmax , ntpmax INTEGER ( I4B ), INTENT ( INOUT ) :: nmergeadd , nmergesub , nplplenc , fragmax REAL ( DP ), INTENT ( IN ) :: t , dt REAL ( DP ), INTENT ( INOUT ) :: eoffset , m1 , m2 , rad1 , rad2 REAL ( DP ), DIMENSION ( 3 ), INTENT ( INOUT ) :: mres , rres REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: vbs REAL ( DP ), DIMENSION ( NDIM ), INTENT ( INOUT ) :: x1 , x2 , v1 , v2 TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA END SUBROUTINE symba_casedisruption END INTERFACE INTERFACE SUBROUTINE symba_casehitandrun ( t , index_enc , nmergeadd , nmergesub , mergeadd_list , mergesub_list , eoffset , vbs , & symba_plA , nplplenc , plplenc_list , nplmax , ntpmax , fragmax , mres , rres , m1 , m2 , rad1 , rad2 , x1 , x2 , v1 , v2 ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: index_enc , nplmax , ntpmax INTEGER ( I4B ), INTENT ( INOUT ) :: nmergeadd , nmergesub , nplplenc , fragmax REAL ( DP ), INTENT ( IN ) :: t REAL ( DP ), INTENT ( INOUT ) :: eoffset , m1 , m2 , rad1 , rad2 REAL ( DP ), DIMENSION ( 3 ), INTENT ( INOUT ) :: mres , rres REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: vbs REAL ( DP ), DIMENSION ( NDIM ), INTENT ( INOUT ) :: x1 , x2 , v1 , v2 TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA END SUBROUTINE symba_casehitandrun END INTERFACE INTERFACE SUBROUTINE symba_casemerge ( t , dt , index_enc , nmergeadd , nmergesub , mergeadd_list , mergesub_list , eoffset , vbs , & encounter_file , out_type , npl , ntp , symba_plA , symba_tpA , nplplenc , npltpenc , pltpenc_list , plplenc_list , & array_index1_child , array_index2_child , m1 , m2 , rad1 , rad2 , x1 , x2 , v1 , v2 ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: index_enc INTEGER ( I4B ), INTENT ( INOUT ) :: npl , ntp , nmergeadd , nmergesub , nplplenc , npltpenc REAL ( DP ), INTENT ( IN ) :: t , dt REAL ( DP ), INTENT ( INOUT ) :: eoffset , m1 , m2 , rad1 , rad2 REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: vbs REAL ( DP ), DIMENSION ( NDIM ), INTENT ( INOUT ) :: x1 , x2 , v1 , v2 CHARACTER ( * ), INTENT ( IN ) :: encounter_file , out_type TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list TYPE ( symba_pltpenc ), INTENT ( INOUT ) :: pltpenc_list TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA INTEGER ( I4B ), DIMENSION ( npl ), INTENT ( INOUT ) :: array_index1_child , array_index2_child END SUBROUTINE symba_casemerge END INTERFACE INTERFACE SUBROUTINE symba_caseresolve ( t , dt , index_enc , nmergeadd , nmergesub , mergeadd_list , mergesub_list , eoffset , vbs , & encounter_file , out_type , npl , ntp , symba_plA , symba_tpA , nplplenc , npltpenc , pltpenc_list , plplenc_list , regime , & nplmax , ntpmax , fragmax , mres , rres , array_index1_child , array_index2_child , m1 , m2 , rad1 , rad2 , x1 , x2 , v1 , v2 ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: index_enc , nplmax , ntpmax INTEGER ( I4B ), INTENT ( INOUT ) :: npl , ntp , nmergeadd , nmergesub , nplplenc , npltpenc , fragmax REAL ( DP ), INTENT ( IN ) :: t , dt REAL ( DP ), INTENT ( INOUT ) :: eoffset , m1 , m2 , rad1 , rad2 REAL ( DP ), DIMENSION ( 3 ), INTENT ( INOUT ) :: mres , rres REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: vbs REAL ( DP ), DIMENSION ( NDIM ), INTENT ( INOUT ) :: x1 , x2 , v1 , v2 CHARACTER ( * ), INTENT ( IN ) :: encounter_file , out_type TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list TYPE ( symba_pltpenc ), INTENT ( INOUT ) :: pltpenc_list TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA INTEGER ( I4B ), INTENT ( IN ) :: regime INTEGER ( I4B ), DIMENSION ( npl ), INTENT ( INOUT ) :: array_index1_child , array_index2_child END SUBROUTINE symba_caseresolve END INTERFACE INTERFACE SUBROUTINE symba_casesupercatastrophic ( t , dt , index_enc , nmergeadd , nmergesub , mergeadd_list , mergesub_list , & eoffset , vbs , symba_plA , nplplenc , plplenc_list , nplmax , ntpmax , fragmax , mres , rres , m1 , m2 , rad1 , & rad2 , x1 , x2 , v1 , v2 ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: index_enc , nplmax , ntpmax INTEGER ( I4B ), INTENT ( INOUT ) :: nmergeadd , nmergesub , nplplenc , fragmax REAL ( DP ), INTENT ( IN ) :: t , dt REAL ( DP ), INTENT ( INOUT ) :: eoffset , m1 , m2 , rad1 , rad2 REAL ( DP ), DIMENSION ( 3 ), INTENT ( INOUT ) :: mres , rres REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: vbs REAL ( DP ), DIMENSION ( NDIM ), INTENT ( INOUT ) :: x1 , x2 , v1 , v2 TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA END SUBROUTINE symba_casesupercatastrophic END INTERFACE INTERFACE SUBROUTINE symba_chk ( xr , vr , rhill1 , rhill2 , dt , irec , lencounter , lvdotr ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE LOGICAL ( LGT ), INTENT ( OUT ) :: lencounter , lvdotr INTEGER ( I4B ), INTENT ( IN ) :: irec REAL ( DP ), INTENT ( IN ) :: rhill1 , rhill2 , dt REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: xr , vr END SUBROUTINE symba_chk END INTERFACE INTERFACE SUBROUTINE symba_discard_merge_pl ( t , npl , symba_plA , nplplenc , plplenc_list ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: nplplenc INTEGER ( I4B ), INTENT ( INOUT ) :: npl REAL ( DP ), INTENT ( IN ) :: t TYPE ( symba_pl ) :: symba_plA TYPE ( symba_plplenc ), INTENT ( IN ) :: plplenc_list END SUBROUTINE symba_discard_merge_pl END INTERFACE INTERFACE SUBROUTINE symba_discard_peri_pl ( t , npl , symba_plA , msys , qmin , qmin_alo , qmin_ahi , qmin_coord , ldiscards ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE LOGICAL ( LGT ), INTENT ( INOUT ) :: ldiscards INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: t , msys , qmin , qmin_alo , qmin_ahi CHARACTER ( * ), INTENT ( IN ) :: qmin_coord TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA END SUBROUTINE symba_discard_peri_pl END INTERFACE INTERFACE SUBROUTINE symba_discard_pl ( t , npl , nplmax , nsp , symba_plA , rmin , rmax , rmaxu , qmin , qmin_coord , & qmin_alo , qmin_ahi , j2rp2 , j4rp4 , eoffset ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: nplmax INTEGER ( I4B ), INTENT ( INOUT ) :: npl , nsp REAL ( DP ), INTENT ( IN ) :: t , rmin , rmax , rmaxu , qmin , qmin_alo , qmin_ahi , j2rp2 , j4rp4 REAL ( DP ), INTENT ( INOUT ) :: eoffset CHARACTER ( * ), INTENT ( IN ) :: qmin_coord TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA END SUBROUTINE symba_discard_pl END INTERFACE INTERFACE SUBROUTINE symba_discard_sun_pl ( t , npl , msys , swiftest_plA , rmin , rmax , rmaxu , ldiscards ) USE swiftest USE module_swiftest IMPLICIT NONE LOGICAL ( LGT ), INTENT ( INOUT ) :: ldiscards INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: t , msys , rmin , rmax , rmaxu TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA END SUBROUTINE symba_discard_sun_pl END INTERFACE INTERFACE SUBROUTINE symba_discard_tp ( t , npl , ntp , nsp , symba_plA , symba_tpA , dt , & rmin , rmax , rmaxu , qmin , qmin_coord , qmin_alo , qmin_ahi , lclose , lrhill_present ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lclose , lrhill_present INTEGER ( I4B ), INTENT ( IN ) :: npl INTEGER ( I4B ), INTENT ( INOUT ) :: ntp , nsp REAL ( DP ), INTENT ( IN ) :: t , dt , rmin , rmax , rmaxu , qmin , qmin_alo , qmin_ahi CHARACTER ( * ), INTENT ( IN ) :: qmin_coord TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA END SUBROUTINE symba_discard_tp END INTERFACE INTERFACE SUBROUTINE symba_energy ( npl , swiftest_plA , j2rp2 , j4rp4 , ke , pe , te , htot ) USE swiftest USE module_swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: j2rp2 , j4rp4 REAL ( DP ), INTENT ( OUT ) :: ke , pe , te REAL ( DP ), DIMENSION ( NDIM ), INTENT ( OUT ) :: htot TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA END SUBROUTINE symba_energy END INTERFACE INTERFACE SUBROUTINE symba_fragmentation ( t , dt , index_enc , nmergeadd , nmergesub , mergeadd_list , & mergesub_list , eoffset , vbs , encounter_file , out_type , npl , ntp , & symba_plA , symba_tpA , nplplenc , npltpenc , pltpenc_list , plplenc_list , & nplmax , ntpmax , fragmax ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: index_enc , nplmax , ntpmax INTEGER ( I4B ), INTENT ( INOUT ) :: nmergeadd , nmergesub , nplplenc , npltpenc , fragmax INTEGER ( I4B ), INTENT ( INOUT ) :: npl , ntp REAL ( DP ), INTENT ( IN ) :: t , dt REAL ( DP ), INTENT ( INOUT ) :: eoffset REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: vbs CHARACTER ( * ), INTENT ( IN ) :: encounter_file , out_type TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list TYPE ( symba_pltpenc ), INTENT ( INOUT ) :: pltpenc_list TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA END SUBROUTINE symba_fragmentation END INTERFACE INTERFACE SUBROUTINE symba_getacch ( lextra_force , t , npl , nplm , symba_plA , j2rp2 , j4rp4 , nplplenc , & plplenc_list ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lextra_force INTEGER ( I4B ), INTENT ( IN ) :: npl , nplm , nplplenc REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_plplenc ), INTENT ( IN ) :: plplenc_list END SUBROUTINE symba_getacch END INTERFACE INTERFACE SUBROUTINE symba_getacch_tp ( lextra_force , t , npl , nplm , nplmax , ntp , ntpmax , symba_plA , symba_tpA , & xh , j2rp2 , j4rp4 , & npltpenc , pltpenc_list ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lextra_force INTEGER ( I4B ), INTENT ( IN ) :: npl , nplm , nplmax , ntp , ntpmax , npltpenc REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 REAL ( DP ), DIMENSION ( NDIM , npl ), INTENT ( IN ) :: xh TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA TYPE ( symba_pltpenc ), INTENT ( IN ) :: pltpenc_list END SUBROUTINE symba_getacch_tp END INTERFACE INTERFACE SUBROUTINE symba_helio_drift ( irec , npl , symba_plA , dt ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: irec , npl REAL ( DP ), INTENT ( IN ) :: dt TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA END SUBROUTINE symba_helio_drift END INTERFACE INTERFACE SUBROUTINE symba_helio_drift_tp ( irec , ntp , symba_tpA , mu , dt ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: irec , ntp REAL ( DP ), INTENT ( IN ) :: mu , dt TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA END SUBROUTINE symba_helio_drift_tp END INTERFACE INTERFACE SUBROUTINE symba_helio_getacch ( lflag , lextra_force , t , npl , nplm , nplmax , helio_plA , j2rp2 , j4rp4 ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lflag , lextra_force INTEGER ( I4B ), INTENT ( IN ) :: npl , nplm , nplmax REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA END SUBROUTINE symba_helio_getacch END INTERFACE INTERFACE SUBROUTINE symba_helio_getacch_int ( npl , nplm , helio_plA ) USE swiftest USE module_helio USE module_symba IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: npl , nplm TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA END SUBROUTINE symba_helio_getacch_int END INTERFACE INTERFACE SUBROUTINE symba_kick ( irec , nplplenc , npltpenc , plplenc_list , pltpenc_list , dt , sgn , symba_plA , & symba_tpA ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: irec , nplplenc , npltpenc REAL ( DP ), INTENT ( IN ) :: dt , sgn TYPE ( symba_plplenc ), INTENT ( IN ) :: plplenc_list TYPE ( symba_pltpenc ), INTENT ( IN ) :: pltpenc_list TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA END SUBROUTINE symba_kick END INTERFACE INTERFACE SUBROUTINE symba_merge_pl ( t , dt , index_enc , nplplenc , plplenc_list , nmergeadd , nmergesub , & mergeadd_list , mergesub_list , eoffset , vbs , encounter_file , out_type , npl , symba_plA , & symba_tpA ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: index_enc , nplplenc INTEGER ( I4B ), INTENT ( INOUT ) :: nmergeadd , nmergesub , npl REAL ( DP ), INTENT ( IN ) :: t , dt REAL ( DP ), INTENT ( INOUT ) :: eoffset REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: vbs CHARACTER ( * ), INTENT ( IN ) :: encounter_file , out_type TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA END SUBROUTINE symba_merge_pl END INTERFACE INTERFACE SUBROUTINE symba_merge_tp ( t , dt , index_enc , npltpenc , pltpenc_list , vbs , encounter_file , out_type , symba_plA , symba_tpA ) USE swiftest USE module_swifter USE module_helio USE module_symba IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: index_enc , npltpenc REAL ( DP ), INTENT ( IN ) :: t , dt REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: vbs CHARACTER ( * ), INTENT ( IN ) :: encounter_file , out_type TYPE ( symba_pltpenc ), INTENT ( INOUT ) :: pltpenc_list TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA END SUBROUTINE symba_merge_tp END INTERFACE INTERFACE SUBROUTINE symba_peri ( lfirst , npl , symba_plA , msys , qmin_coord ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lfirst INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: msys CHARACTER ( * ), INTENT ( IN ) :: qmin_coord TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA END SUBROUTINE symba_peri END INTERFACE INTERFACE SUBROUTINE symba_rearray ( npl , ntp , nsppl , nsptp , symba_plA , symba_tpA , nmergeadd , mergeadd_list , discard_plA , & discard_tpA , feature ) USE swiftest USE module_swiftestalloc USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE INTEGER ( I4B ), INTENT ( INOUT ) :: npl , ntp , nsppl , nsptp , nmergeadd !change to fragadd TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA TYPE ( swiftest_tp ), INTENT ( INOUT ) :: discard_tpA TYPE ( swiftest_pl ), INTENT ( INOUT ) :: discard_plA TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list !change to fragadd_list TYPE ( feature_list ), intent ( in ) :: feature END SUBROUTINE symba_rearray END INTERFACE INTERFACE SUBROUTINE symba_reorder_pl ( npl , symba_plA ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: npl TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA INTEGER ( I4B ) :: i INTEGER ( I4B ), DIMENSION (:), ALLOCATABLE :: index REAL ( DP ), DIMENSION (:), ALLOCATABLE :: mass REAL ( DP ), DIMENSION (:,:), allocatable :: symba_plwkspA INTEGER ( I4B ), DIMENSION (:,:), allocatable :: symba_plwkspA_id_status END SUBROUTINE symba_reorder_pl END INTERFACE INTERFACE SUBROUTINE symba_setup ( npl , ntp , symba_plA , symba_tpA , symba_pl1P , symba_tp1P , swiftest_pl1P , & swiftest_tp1P ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: npl , ntp TYPE ( swiftest_pl ), POINTER :: swiftest_pl1P TYPE ( swiftest_tp ), POINTER :: swiftest_tp1P TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA TYPE ( symba_pl ), POINTER :: symba_pl1P TYPE ( symba_tp ), POINTER :: symba_tp1P END SUBROUTINE symba_setup END INTERFACE INTERFACE SUBROUTINE symba_step ( lfirst , lextra_force , lclose , t , npl , nplmax , ntp , ntpmax , symba_plA , & symba_tpA , j2rp2 , j4rp4 , dt , nplplenc , npltpenc , plplenc_list , pltpenc_list , nmergeadd , & nmergesub , mergeadd_list , mergesub_list , eoffset , mtiny , encounter_file , out_type , & fragmax , feature ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lextra_force , lclose LOGICAL ( LGT ), INTENT ( INOUT ) :: lfirst INTEGER ( I4B ), INTENT ( IN ) :: npl , nplmax , ntp , ntpmax INTEGER ( I4B ), INTENT ( INOUT ) :: nplplenc , npltpenc , nmergeadd , nmergesub , fragmax REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 , dt , mtiny REAL ( DP ), INTENT ( INOUT ) :: eoffset CHARACTER ( * ), INTENT ( IN ) :: encounter_file , out_type TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list TYPE ( symba_pltpenc ), INTENT ( INOUT ) :: pltpenc_list TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list TYPE ( feature_list ) :: feature ! Derived type containing logical flags to turn on or off various features of the code END SUBROUTINE symba_step END INTERFACE INTERFACE SUBROUTINE symba_step_helio ( lfirst , lextra_force , t , npl , nplm , nplmax , ntp , ntpmax , helio_plA , helio_tpA , j2rp2 , & j4rp4 , dt ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lextra_force LOGICAL ( LGT ), INTENT ( INOUT ) :: lfirst INTEGER ( I4B ), INTENT ( IN ) :: npl , nplm , nplmax , ntp , ntpmax REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 , dt TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA TYPE ( helio_tp ), INTENT ( INOUT ) :: helio_tpA END SUBROUTINE symba_step_helio END INTERFACE INTERFACE SUBROUTINE symba_step_helio_pl ( lfirst , lextra_force , t , npl , nplm , nplmax , helio_plA , j2rp2 , j4rp4 , dt , xbeg , xend , & ptb , pte ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lextra_force LOGICAL ( LGT ), INTENT ( INOUT ) :: lfirst INTEGER ( I4B ), INTENT ( IN ) :: npl , nplm , nplmax REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 , dt REAL ( DP ), DIMENSION ( NDIM , nplm ), INTENT ( OUT ) :: xbeg , xend REAL ( DP ), DIMENSION ( NDIM ), INTENT ( OUT ) :: ptb , pte TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA END SUBROUTINE symba_step_helio_pl END INTERFACE INTERFACE SUBROUTINE symba_step_interp ( lextra_force , lclose , t , npl , nplm , nplmax , ntp , ntpmax , symba_plA , symba_tpA , j2rp2 , & j4rp4 , dt , eoffset , nplplenc , npltpenc , plplenc_list , pltpenc_list , nmergeadd , nmergesub , mergeadd_list , & mergesub_list , encounter_file , out_type , fragmax , feature ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lextra_force , lclose INTEGER ( I4B ), INTENT ( IN ) :: npl , nplm , nplmax , ntp , ntpmax , nplplenc , npltpenc INTEGER ( I4B ), INTENT ( INOUT ) :: nmergeadd , nmergesub , fragmax REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 , dt REAL ( DP ), INTENT ( INOUT ) :: eoffset CHARACTER ( * ), INTENT ( IN ) :: encounter_file , out_type TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list TYPE ( symba_pltpenc ), INTENT ( INOUT ) :: pltpenc_list TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list type ( feature_list ), intent ( in ) :: feature END SUBROUTINE symba_step_interp END INTERFACE INTERFACE RECURSIVE SUBROUTINE symba_step_recur ( lclose , t , ireci , npl , nplm , ntp , symba_plA , symba_tpA , dt0 , eoffset , nplplenc , & npltpenc , plplenc_list , pltpenc_list , nmergeadd , nmergesub , mergeadd_list , mergesub_list , encounter_file , & out_type , nplmax , ntpmax , fragmax , feature ) USE swiftest USE module_swiftest USE module_helio USE module_symba IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lclose INTEGER ( I4B ), INTENT ( IN ) :: ireci , npl , nplm , ntp , nplplenc , npltpenc , nplmax , ntpmax , fragmax INTEGER ( I4B ), INTENT ( INOUT ) :: nmergeadd , nmergesub REAL ( DP ), INTENT ( IN ) :: t , dt0 REAL ( DP ), INTENT ( INOUT ) :: eoffset CHARACTER ( * ), INTENT ( IN ) :: encounter_file , out_type TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list TYPE ( symba_pltpenc ), INTENT ( INOUT ) :: pltpenc_list TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list type ( feature_list ), intent ( in ) :: feature END SUBROUTINE symba_step_recur END INTERFACE INTERFACE SUBROUTINE symba_user_getacch ( t , npl , symba_plA ) USE swiftest USE module_symba IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: t TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA END SUBROUTINE symba_user_getacch END INTERFACE INTERFACE SUBROUTINE symba_user_getacch_tp ( t , ntp , symba_tpA ) USE swiftest USE module_symba IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: ntp REAL ( DP ), INTENT ( IN ) :: t TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA END SUBROUTINE symba_user_getacch_tp END INTERFACE INTERFACE SUBROUTINE util_exit ( code ) USE swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: code END SUBROUTINE util_exit END INTERFACE INTERFACE SUBROUTINE util_hills ( npl , swiftest_plA ) USE swiftest USE module_swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: npl TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA END SUBROUTINE util_hills END INTERFACE INTERFACE SUBROUTINE util_index ( arr , index ) USE swiftest USE module_nrutil IMPLICIT NONE INTEGER ( I4B ), DIMENSION (:), INTENT ( OUT ) :: index REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: arr END SUBROUTINE util_index END INTERFACE INTERFACE SUBROUTINE util_peri ( lfirst , ntp , swiftest_tpA , mu , msys , qmin_coord ) USE swiftest USE module_swiftest IMPLICIT NONE LOGICAL ( LGT ), INTENT ( IN ) :: lfirst INTEGER ( I4B ), INTENT ( IN ) :: ntp REAL ( DP ), INTENT ( IN ) :: mu , msys CHARACTER ( * ), INTENT ( IN ) :: qmin_coord TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA END SUBROUTINE util_peri END INTERFACE INTERFACE SUBROUTINE util_resize_pl ( symba_plA , npl_new , npl_old ) USE swiftest USE module_symba USE module_swiftest USE module_helio USE module_nrutil USE module_swiftestalloc IMPLICIT NONE TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA INTEGER ( I4B ), INTENT ( IN ) :: npl_old , npl_new END SUBROUTINE util_resize_pl END INTERFACE INTERFACE util_sort SUBROUTINE util_sort_i4b ( arr ) USE swiftest IMPLICIT NONE INTEGER ( I4B ), DIMENSION (:), INTENT ( INOUT ) :: arr END SUBROUTINE util_sort_i4b SUBROUTINE util_sort_sp ( arr ) USE swiftest IMPLICIT NONE REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: arr END SUBROUTINE util_sort_sp SUBROUTINE util_sort_dp ( arr ) USE swiftest IMPLICIT NONE REAL ( DP ), DIMENSION (:), INTENT ( INOUT ) :: arr END SUBROUTINE util_sort_dp END INTERFACE INTERFACE SUBROUTINE util_toupper ( string ) USE swiftest IMPLICIT NONE CHARACTER ( * ), INTENT ( INOUT ) :: string END SUBROUTINE util_toupper END INTERFACE INTERFACE SUBROUTINE util_valid ( npl , ntp , swiftest_plA , swiftest_tpA ) USE swiftest USE module_swiftest IMPLICIT NONE INTEGER ( I4B ), INTENT ( IN ) :: npl , ntp TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA END SUBROUTINE util_valid END INTERFACE INTERFACE SUBROUTINE util_version USE swiftest IMPLICIT NONE END SUBROUTINE util_version END INTERFACE ! Added by D. Minton INTERFACE FUNCTION util_kahan_sum ( xsum_current , xi , xerror ) USE swiftest IMPLICIT NONE REAL ( DP ) :: util_kahan_sum REAL ( DP ), INTENT ( IN ) :: xsum_current , xi REAL ( DP ), INTENT ( INOUT ) :: xerror END FUNCTION END INTERFACE INTERFACE FUNCTION collresolve_resolve ( model , m1 , m2 , r1 , r2 , p1 , p2 , v1 , v2 , n , mres , rres , pres , vres ) USE swiftest IMPLICIT NONE INTEGER ( I4B ) :: collresolve_resolve INTEGER ( I4B ), INTENT ( IN ) :: model ! collision model to apply REAL ( DP ), INTENT ( IN ) :: m1 ! mass of the target REAL ( DP ), INTENT ( IN ) :: m2 ! mass of the impactor REAL ( DP ), INTENT ( IN ) :: r1 ! radius of the target REAL ( DP ), INTENT ( IN ) :: r2 ! radius of the impactor REAL ( DP ), DIMENSION ( 3 ), INTENT ( IN ) :: p1 ! position of the target REAL ( DP ), DIMENSION ( 3 ), INTENT ( IN ) :: p2 ! position of the impactor REAL ( DP ), DIMENSION ( 3 ), INTENT ( IN ) :: v1 ! velocity of the target REAL ( DP ), DIMENSION ( 3 ), INTENT ( IN ) :: v2 ! velocity of the impactor INTEGER , INTENT ( IN ) :: n ! number of bodies to return REAL ( DP ), DIMENSION ( n + 1 ), INTENT ( OUT ) :: mres ! mass of the resulting bodies REAL ( DP ), DIMENSION ( n + 1 ), INTENT ( OUT ) :: rres ! radius of the resulting bodies REAL ( DP ), DIMENSION ( 3 , n + 1 ), INTENT ( OUT ) :: pres ! position of the resulting bodies REAL ( DP ), DIMENSION ( 3 , n + 1 ), INTENT ( OUT ) :: vres ! velocity of the resulting bodies END FUNCTION END INTERFACE INTERFACE SUBROUTINE util_regime ( symba_plA , index1 , index2 , regime , Mlr , Mslr ) USE swiftest USE module_swiftest USE module_symba IMPLICIT NONE TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA INTEGER ( I4B ), INTENT ( IN ) :: index1 , index2 INTEGER ( I4B ), INTENT ( OUT ) :: regime REAL ( DP ), INTENT ( OUT ) :: Mlr , Mslr END SUBROUTINE util_regime END INTERFACE END MODULE module_interfaces !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/module_interfaces.f90.html"},{"title":"module_swiftest.f90 – swiftest","text":"Unit Name   : module_swiftest\n  Unit Type   : module\n  Project     : SWIFTEST\n  Package     : module\n  Language    : Fortran 2003 Description : Definition of data and structures generic to all integrators Input\n    Arguments : N/A\n    Terminal  : N/A\n    File      : N/A Output\n    Arguments : N/A\n    Terminal  : N/A\n    File      : N/A Invocation  : N/A Notes       : Author(s)   : David A. Minton This file depends on sourcefile~~module_swiftest.f90~~EfferentGraph sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~module_swiftest.f90~~AfferentGraph sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_discard_pl.f90 symba_discard_pl.f90 sourcefile~symba_discard_pl.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_discard_pl.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_discard_pl.f90->sourcefile~module_symba.f90 sourcefile~util_resize_pl.f90 util_resize_pl.f90 sourcefile~util_resize_pl.f90->sourcefile~module_swiftest.f90 sourcefile~util_resize_pl.f90->sourcefile~module_helio.f90 sourcefile~module_swiftestalloc.f90 module_swiftestalloc.f90 sourcefile~util_resize_pl.f90->sourcefile~module_swiftestalloc.f90 sourcefile~util_resize_pl.f90->sourcefile~module_symba.f90 sourcefile~coord_h2b_tp.f90 coord_h2b_tp.f90 sourcefile~coord_h2b_tp.f90->sourcefile~module_swiftest.f90 sourcefile~symba_step_interp.f90 symba_step_interp.f90 sourcefile~symba_step_interp.f90->sourcefile~module_swiftest.f90 sourcefile~symba_step_interp.f90->sourcefile~module_helio.f90 sourcefile~symba_step_interp.f90->sourcefile~module_symba.f90 sourcefile~symba_discard_sun_pl.f90 symba_discard_sun_pl.f90 sourcefile~symba_discard_sun_pl.f90->sourcefile~module_swiftest.f90 sourcefile~io_write_frame.f90 io_write_frame.f90 sourcefile~io_write_frame.f90->sourcefile~module_swiftest.f90 sourcefile~io_discard_write_symba.f90 io_discard_write_symba.f90 sourcefile~io_discard_write_symba.f90->sourcefile~module_swiftest.f90 sourcefile~io_discard_write_symba.f90->sourcefile~module_symba.f90 sourcefile~symba_casedisruption.f90 symba_casedisruption.f90 sourcefile~symba_casedisruption.f90->sourcefile~module_swiftest.f90 sourcefile~symba_casedisruption.f90->sourcefile~module_helio.f90 sourcefile~symba_casedisruption.f90->sourcefile~module_symba.f90 sourcefile~symba_rearray.f90 symba_rearray.f90 sourcefile~symba_rearray.f90->sourcefile~module_swiftest.f90 sourcefile~symba_rearray.f90->sourcefile~module_helio.f90 sourcefile~symba_rearray.f90->sourcefile~module_swiftestalloc.f90 sourcefile~symba_rearray.f90->sourcefile~module_symba.f90 sourcefile~helio_getacch.f90 helio_getacch.f90 sourcefile~helio_getacch.f90->sourcefile~module_swiftest.f90 sourcefile~helio_getacch.f90->sourcefile~module_helio.f90 sourcefile~helio_lindrift.f90 helio_lindrift.f90 sourcefile~helio_lindrift.f90->sourcefile~module_swiftest.f90 sourcefile~helio_lindrift.f90->sourcefile~module_symba.f90 sourcefile~symba_discard_peri_pl.f90 symba_discard_peri_pl.f90 sourcefile~symba_discard_peri_pl.f90->sourcefile~module_swiftest.f90 sourcefile~symba_discard_peri_pl.f90->sourcefile~module_helio.f90 sourcefile~symba_discard_peri_pl.f90->sourcefile~module_symba.f90 sourcefile~swiftest_symba.f90 swiftest_symba.f90 sourcefile~swiftest_symba.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest_symba.f90->sourcefile~module_swiftestalloc.f90 sourcefile~swiftest_symba.f90->sourcefile~module_symba.f90 sourcefile~io.f90 io.f90 sourcefile~swiftest_symba.f90->sourcefile~io.f90 sourcefile~io_init_tp.f90 io_init_tp.f90 sourcefile~io_init_tp.f90->sourcefile~module_swiftest.f90 sourcefile~io_init_tp.f90->sourcefile~module_helio.f90 sourcefile~io_init_tp.f90->sourcefile~module_symba.f90 sourcefile~helio_lindrift_tp.f90 helio_lindrift_tp.f90 sourcefile~helio_lindrift_tp.f90->sourcefile~module_swiftest.f90 sourcefile~helio_lindrift_tp.f90->sourcefile~module_symba.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~module_swiftest.f90 sourcefile~symba_discard_tp.f90 symba_discard_tp.f90 sourcefile~symba_discard_tp.f90->sourcefile~module_swiftest.f90 sourcefile~symba_discard_tp.f90->sourcefile~module_helio.f90 sourcefile~symba_discard_tp.f90->sourcefile~module_symba.f90 sourcefile~symba_step_helio_pl.f90 symba_step_helio_pl.f90 sourcefile~symba_step_helio_pl.f90->sourcefile~module_swiftest.f90 sourcefile~symba_step_helio_pl.f90->sourcefile~module_helio.f90 sourcefile~symba_step_helio_pl.f90->sourcefile~module_symba.f90 sourcefile~symba_getacch_tp.f90 symba_getacch_tp.f90 sourcefile~symba_getacch_tp.f90->sourcefile~module_swiftest.f90 sourcefile~symba_getacch_tp.f90->sourcefile~module_helio.f90 sourcefile~symba_getacch_tp.f90->sourcefile~module_symba.f90 sourcefile~symba_helio_drift_tp.f90 symba_helio_drift_tp.f90 sourcefile~symba_helio_drift_tp.f90->sourcefile~module_swiftest.f90 sourcefile~symba_helio_drift_tp.f90->sourcefile~module_helio.f90 sourcefile~symba_helio_drift_tp.f90->sourcefile~module_symba.f90 sourcefile~helio_kickvb.f90 helio_kickvb.f90 sourcefile~helio_kickvb.f90->sourcefile~module_swiftest.f90 sourcefile~helio_kickvb.f90->sourcefile~module_helio.f90 sourcefile~helio_drift_tp.f90 helio_drift_tp.f90 sourcefile~helio_drift_tp.f90->sourcefile~module_swiftest.f90 sourcefile~symba_fragmentation.f90 symba_fragmentation.f90 sourcefile~symba_fragmentation.f90->sourcefile~module_swiftest.f90 sourcefile~symba_fragmentation.f90->sourcefile~module_helio.f90 sourcefile~symba_fragmentation.f90->sourcefile~module_symba.f90 sourcefile~helio_getacch_tp.f90 helio_getacch_tp.f90 sourcefile~helio_getacch_tp.f90->sourcefile~module_swiftest.f90 sourcefile~helio_getacch_tp.f90->sourcefile~module_helio.f90 sourcefile~symba_helio_getacch.f90 symba_helio_getacch.f90 sourcefile~symba_helio_getacch.f90->sourcefile~module_swiftest.f90 sourcefile~symba_helio_getacch.f90->sourcefile~module_helio.f90 sourcefile~symba_helio_getacch.f90->sourcefile~module_symba.f90 sourcefile~obl_pot.f90 obl_pot.f90 sourcefile~obl_pot.f90->sourcefile~module_swiftest.f90 sourcefile~coord_h2b.f90 coord_h2b.f90 sourcefile~coord_h2b.f90->sourcefile~module_swiftest.f90 sourcefile~helio_step_tp.f90 helio_step_tp.f90 sourcefile~helio_step_tp.f90->sourcefile~module_swiftest.f90 sourcefile~helio_step_tp.f90->sourcefile~module_helio.f90 sourcefile~helio_kickvb_tp.f90 helio_kickvb_tp.f90 sourcefile~helio_kickvb_tp.f90->sourcefile~module_swiftest.f90 sourcefile~helio_kickvb_tp.f90->sourcefile~module_helio.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~module_swiftest.f90 sourcefile~python_io_write_frame_tp.f90 python_io_write_frame_tp.f90 sourcefile~python_io_write_frame_tp.f90->sourcefile~module_swiftest.f90 sourcefile~python_io_write_frame_tp.f90->sourcefile~module_helio.f90 sourcefile~python_io_write_frame_tp.f90->sourcefile~module_symba.f90 sourcefile~discard_peri.f90 discard_peri.f90 sourcefile~discard_peri.f90->sourcefile~module_swiftest.f90 sourcefile~symba_helio_drift.f90 symba_helio_drift.f90 sourcefile~symba_helio_drift.f90->sourcefile~module_swiftest.f90 sourcefile~symba_helio_drift.f90->sourcefile~module_helio.f90 sourcefile~symba_helio_drift.f90->sourcefile~module_symba.f90 sourcefile~coord_vh2vb_tp.f90 coord_vh2vb_tp.f90 sourcefile~coord_vh2vb_tp.f90->sourcefile~module_swiftest.f90 sourcefile~symba_casehitandrun.f90 symba_casehitandrun.f90 sourcefile~symba_casehitandrun.f90->sourcefile~module_swiftest.f90 sourcefile~symba_casehitandrun.f90->sourcefile~module_helio.f90 sourcefile~symba_casehitandrun.f90->sourcefile~module_symba.f90 sourcefile~io_init_pl.f90 io_init_pl.f90 sourcefile~io_init_pl.f90->sourcefile~module_swiftest.f90 sourcefile~io_init_pl.f90->sourcefile~module_helio.f90 sourcefile~io_init_pl.f90->sourcefile~module_symba.f90 sourcefile~coord_vb2vh.f90 coord_vb2vh.f90 sourcefile~coord_vb2vh.f90->sourcefile~module_swiftest.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~helio_getacch_int_tp.f90 helio_getacch_int_tp.f90 sourcefile~helio_getacch_int_tp.f90->sourcefile~module_swiftest.f90 sourcefile~helio_getacch_int_tp.f90->sourcefile~module_helio.f90 sourcefile~io_dump_tp.f90 io_dump_tp.f90 sourcefile~io_dump_tp.f90->sourcefile~module_swiftest.f90 sourcefile~symba_step_helio.f90 symba_step_helio.f90 sourcefile~symba_step_helio.f90->sourcefile~module_swiftest.f90 sourcefile~symba_step_helio.f90->sourcefile~module_helio.f90 sourcefile~symba_step_helio.f90->sourcefile~module_symba.f90 sourcefile~obl_acc.f90 obl_acc.f90 sourcefile~obl_acc.f90->sourcefile~module_swiftest.f90 sourcefile~helio_step_pl.f90 helio_step_pl.f90 sourcefile~helio_step_pl.f90->sourcefile~module_swiftest.f90 sourcefile~helio_step_pl.f90->sourcefile~module_helio.f90 sourcefile~symba_casemerge.f90 symba_casemerge.f90 sourcefile~symba_casemerge.f90->sourcefile~module_swiftest.f90 sourcefile~symba_casemerge.f90->sourcefile~module_helio.f90 sourcefile~symba_casemerge.f90->sourcefile~module_symba.f90 sourcefile~symba_caseresolve.f90 symba_caseresolve.f90 sourcefile~symba_caseresolve.f90->sourcefile~module_swiftest.f90 sourcefile~symba_caseresolve.f90->sourcefile~module_helio.f90 sourcefile~symba_caseresolve.f90->sourcefile~module_symba.f90 sourcefile~symba_chk.f90 symba_chk.f90 sourcefile~symba_chk.f90->sourcefile~module_swiftest.f90 sourcefile~symba_chk.f90->sourcefile~module_helio.f90 sourcefile~symba_chk.f90->sourcefile~module_symba.f90 sourcefile~symba_energy.f90 symba_energy.f90 sourcefile~symba_energy.f90->sourcefile~module_swiftest.f90 sourcefile~io_dump_pl.f90 io_dump_pl.f90 sourcefile~io_dump_pl.f90->sourcefile~module_swiftest.f90 sourcefile~symba_reorder_pl.f90 symba_reorder_pl.f90 sourcefile~symba_reorder_pl.f90->sourcefile~module_swiftest.f90 sourcefile~symba_reorder_pl.f90->sourcefile~module_helio.f90 sourcefile~symba_reorder_pl.f90->sourcefile~module_symba.f90 sourcefile~symba_getacch.f90 symba_getacch.f90 sourcefile~symba_getacch.f90->sourcefile~module_swiftest.f90 sourcefile~symba_getacch.f90->sourcefile~module_helio.f90 sourcefile~symba_getacch.f90->sourcefile~module_symba.f90 sourcefile~symba_merge_pl.f90 symba_merge_pl.f90 sourcefile~symba_merge_pl.f90->sourcefile~module_swiftest.f90 sourcefile~symba_merge_pl.f90->sourcefile~module_helio.f90 sourcefile~symba_merge_pl.f90->sourcefile~module_symba.f90 sourcefile~symba_step_recur.f90 symba_step_recur.f90 sourcefile~symba_step_recur.f90->sourcefile~module_swiftest.f90 sourcefile~symba_step_recur.f90->sourcefile~module_helio.f90 sourcefile~symba_step_recur.f90->sourcefile~module_symba.f90 sourcefile~util_hills.f90 util_hills.f90 sourcefile~util_hills.f90->sourcefile~module_swiftest.f90 sourcefile~coord_vh2vb.f90 coord_vh2vb.f90 sourcefile~coord_vh2vb.f90->sourcefile~module_swiftest.f90 sourcefile~coord_vh2vb.f90->sourcefile~module_symba.f90 sourcefile~discard_pl.f90 discard_pl.f90 sourcefile~discard_pl.f90->sourcefile~module_swiftest.f90 sourcefile~coord_vb2vh_tp.f90 coord_vb2vh_tp.f90 sourcefile~coord_vb2vh_tp.f90->sourcefile~module_swiftest.f90 sourcefile~coord_vb2vh_tp.f90->sourcefile~module_symba.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~module_swiftest.f90 sourcefile~python_io_write_frame_pl.f90 python_io_write_frame_pl.f90 sourcefile~python_io_write_frame_pl.f90->sourcefile~module_swiftest.f90 sourcefile~python_io_write_frame_pl.f90->sourcefile~module_helio.f90 sourcefile~python_io_write_frame_pl.f90->sourcefile~module_symba.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~module_swiftest.f90 sourcefile~symba_kick.f90->sourcefile~module_helio.f90 sourcefile~symba_kick.f90->sourcefile~module_symba.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~module_swiftest.f90 sourcefile~symba_step.f90->sourcefile~module_helio.f90 sourcefile~symba_step.f90->sourcefile~module_symba.f90 sourcefile~module_swiftestalloc.f90->sourcefile~module_swiftest.f90 sourcefile~module_swiftestalloc.f90->sourcefile~module_helio.f90 sourcefile~module_swiftestalloc.f90->sourcefile~module_symba.f90 sourcefile~discard_sun.f90 discard_sun.f90 sourcefile~discard_sun.f90->sourcefile~module_swiftest.f90 sourcefile~symba_casesupercatastrophic.f90 symba_casesupercatastrophic.f90 sourcefile~symba_casesupercatastrophic.f90->sourcefile~module_swiftest.f90 sourcefile~symba_casesupercatastrophic.f90->sourcefile~module_helio.f90 sourcefile~symba_casesupercatastrophic.f90->sourcefile~module_symba.f90 sourcefile~symba_peri.f90 symba_peri.f90 sourcefile~symba_peri.f90->sourcefile~module_swiftest.f90 sourcefile~symba_peri.f90->sourcefile~module_helio.f90 sourcefile~symba_peri.f90->sourcefile~module_symba.f90 sourcefile~symba_helio_getacch_int.f90 symba_helio_getacch_int.f90 sourcefile~symba_helio_getacch_int.f90->sourcefile~module_helio.f90 sourcefile~symba_helio_getacch_int.f90->sourcefile~module_symba.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~helio_getacch_int.f90 helio_getacch_int.f90 sourcefile~helio_getacch_int.f90->sourcefile~module_helio.f90 sourcefile~symba_merge_tp.f90 symba_merge_tp.f90 sourcefile~symba_merge_tp.f90->sourcefile~module_helio.f90 sourcefile~symba_merge_tp.f90->sourcefile~module_symba.f90 sourcefile~symba_discard_merge_pl.f90 symba_discard_merge_pl.f90 sourcefile~symba_discard_merge_pl.f90->sourcefile~module_helio.f90 sourcefile~symba_discard_merge_pl.f90->sourcefile~module_symba.f90 sourcefile~helio_user_getacch_tp.f90 helio_user_getacch_tp.f90 sourcefile~helio_user_getacch_tp.f90->sourcefile~module_helio.f90 sourcefile~helio_user_getacch.f90 helio_user_getacch.f90 sourcefile~helio_user_getacch.f90->sourcefile~module_helio.f90 sourcefile~symba_user_getacch.f90 symba_user_getacch.f90 sourcefile~symba_user_getacch.f90->sourcefile~module_symba.f90 sourcefile~symba_user_getacch_tp.f90 symba_user_getacch_tp.f90 sourcefile~symba_user_getacch_tp.f90->sourcefile~module_symba.f90 sourcefile~io.f90->sourcefile~module_symba.f90 sourcefile~io_read_pl_in.f90 io_read_pl_in.f90 sourcefile~io_read_pl_in.f90->sourcefile~module_symba.f90 sourcefile~io_read_pl_in.f90->sourcefile~io.f90 sourcefile~tool_encounter_read.f90 tool_encounter_read.f90 sourcefile~tool_encounter_read.f90->sourcefile~io.f90 sourcefile~io_read_param_in.f90 io_read_param_in.f90 sourcefile~io_read_param_in.f90->sourcefile~io.f90 sourcefile~io_get_token.f90 io_get_token.f90 sourcefile~io_get_token.f90->sourcefile~io.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules module_swiftest Source Code module_swiftest.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : module_swiftest !  Unit Type   : module !  Project     : SWIFTEST !  Package     : module !  Language    : Fortran 2003 ! !  Description : Definition of data and structures generic to all integrators ! !  Input !    Arguments : N/A !    Terminal  : N/A !    File      : N/A ! !  Output !    Arguments : N/A !    Terminal  : N/A !    File      : N/A ! !  Invocation  : N/A ! !  Notes       : ! !********************************************************************************************************************************** ! !  Author(s)   : David A. Minton ! !********************************************************************************************************************************** module module_swiftest use swiftest implicit none !integer(I4B), parameter :: NENMAX = 32767 !integer(I4B), parameter :: NTENC = 3 !real(DP), parameter     :: RHSCALE = 6.5_DP !real(DP), parameter     :: RSHELL = 0.48075_DP type swiftest_pl integer ( I4B ), dimension (:), allocatable :: name ! external identifier (hash) integer ( I4B ), dimension (:), allocatable :: status ! status real ( DP ), dimension (:), allocatable :: mass ! mass real ( DP ), dimension (:), allocatable :: radius ! radius real ( DP ), dimension (:), allocatable :: rhill ! hill's sphere radius real ( DP ), dimension (:,:), allocatable :: xh ! heliocentric position real ( DP ), dimension (:,:), allocatable :: vh ! heliocentric velocity real ( DP ), dimension (:,:), allocatable :: xb ! barycentric position real ( DP ), dimension (:,:), allocatable :: vb ! barycentric velocity end type swiftest_pl type swiftest_tp integer ( I4B ), dimension (:), allocatable :: name ! external identifier (hash) integer ( I4B ), dimension (:), allocatable :: status ! status integer ( I4B ), dimension (:), allocatable :: isperi ! perihelion passage flag real ( DP ), dimension (:), allocatable :: peri ! perihelion distance real ( DP ), dimension (:), allocatable :: atp ! semimajor axis following perihelion passage real ( DP ), dimension (:,:), allocatable :: xh ! heliocentric position real ( DP ), dimension (:,:), allocatable :: vh ! heliocentric velocity real ( DP ), dimension (:,:), allocatable :: xb ! barycentric position real ( DP ), dimension (:,:), allocatable :: vb ! barycentric velocity end type swiftest_tp end module module_swiftest","tags":"","loc":"sourcefile/module_swiftest.f90.html"},{"title":"module_swiftestalloc.f90 – swiftest","text":"Unit Name   : module_swiftestalloc\n  Unit Type   : module\n  Project     : SWIFTEST\n  Package     : module\n  Language    : Fortran 2003 Description : Input\n    Arguments : N/A\n    Terminal  : N/A\n    File      : N/A Output\n    Arguments : N/A\n    Terminal  : N/A\n    File      : N/A Invocation  : N/A Notes       : Author(s)   : Jennifer Pouplin & Carlisle Wisahrd This file depends on sourcefile~~module_swiftestalloc.f90~~EfferentGraph sourcefile~module_swiftestalloc.f90 module_swiftestalloc.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~module_swiftestalloc.f90->sourcefile~module_helio.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~module_swiftestalloc.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~module_swiftestalloc.f90->sourcefile~module_symba.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~module_swiftestalloc.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~module_swiftestalloc.f90~~AfferentGraph sourcefile~module_swiftestalloc.f90 module_swiftestalloc.f90 sourcefile~util_resize_pl.f90 util_resize_pl.f90 sourcefile~util_resize_pl.f90->sourcefile~module_swiftestalloc.f90 sourcefile~symba_rearray.f90 symba_rearray.f90 sourcefile~symba_rearray.f90->sourcefile~module_swiftestalloc.f90 sourcefile~swiftest_symba.f90 swiftest_symba.f90 sourcefile~swiftest_symba.f90->sourcefile~module_swiftestalloc.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules module_swiftestalloc Source Code module_swiftestalloc.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : module_swiftestalloc !  Unit Type   : module !  Project     : SWIFTEST !  Package     : module !  Language    : Fortran 2003 ! !  Description : ! !  Input !    Arguments : N/A !    Terminal  : N/A !    File      : N/A ! !  Output !    Arguments : N/A !    Terminal  : N/A !    File      : N/A ! !  Invocation  : N/A ! !  Notes       : ! !********************************************************************************************************************************** ! !  Author(s)   : Jennifer Pouplin & Carlisle Wisahrd ! !********************************************************************************************************************************** MODULE module_swiftestalloc USE swiftest IMPLICIT NONE CONTAINS SUBROUTINE swiftest_pl_allocate ( swiftest_plA , npl ) USE swiftest USE module_swiftest IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA ALLOCATE ( swiftest_plA % name ( npl )) ALLOCATE ( swiftest_plA % status ( npl )) ALLOCATE ( swiftest_plA % mass ( npl )) ALLOCATE ( swiftest_plA % radius ( npl )) ALLOCATE ( swiftest_plA % rhill ( npl )) ALLOCATE ( swiftest_plA % xh ( NDIM , npl )) ALLOCATE ( swiftest_plA % vh ( NDIM , npl )) ALLOCATE ( swiftest_plA % xb ( NDIM , npl )) ALLOCATE ( swiftest_plA % vb ( NDIM , npl )) RETURN END SUBROUTINE swiftest_pl_allocate SUBROUTINE helio_pl_allocate ( helio_plA , npl ) USE swiftest USE module_helio IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA ALLOCATE ( helio_plA % ah ( NDIM , npl )) ALLOCATE ( helio_plA % ahi ( NDIM , npl )) CALL swiftest_pl_allocate ( helio_plA % swiftest , npl ) return END SUBROUTINE helio_pl_allocate SUBROUTINE symba_pl_allocate ( symba_plA , npl ) USE swiftest USE module_symba IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA ALLOCATE ( symba_plA % lmerged ( npl )) ALLOCATE ( symba_plA % nplenc ( npl )) ALLOCATE ( symba_plA % ntpenc ( npl )) ALLOCATE ( symba_plA % levelg ( npl )) ALLOCATE ( symba_plA % levelm ( npl )) ALLOCATE ( symba_plA % nchild ( npl )) ALLOCATE ( symba_plA % isperi ( npl )) ALLOCATE ( symba_plA % peri ( npl )) ALLOCATE ( symba_plA % atp ( npl )) ALLOCATE ( symba_plA % index_parent ( npl )) ALLOCATE ( symba_plA % index_child ( npl , npl )) CALL helio_pl_allocate ( symba_plA % helio , npl ) return END SUBROUTINE symba_pl_allocate SUBROUTINE symba_plplenc_allocate ( plplenc_list , nplplenc ) USE swiftest USE module_symba IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: nplplenc TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list ALLOCATE ( plplenc_list % lvdotr ( nplplenc )) ALLOCATE ( plplenc_list % status ( nplplenc )) ALLOCATE ( plplenc_list % level ( nplplenc )) ALLOCATE ( plplenc_list % index1 ( nplplenc )) ALLOCATE ( plplenc_list % index2 ( nplplenc )) ALLOCATE ( plplenc_list % enc_child ( nplplenc )) ALLOCATE ( plplenc_list % enc_parent ( nplplenc )) return END SUBROUTINE symba_plplenc_allocate SUBROUTINE symba_merger_allocate ( mergeadd_list , nmergeadd ) USE swiftest USE module_symba IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: nmergeadd TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list ALLOCATE ( mergeadd_list % name ( nmergeadd )) ALLOCATE ( mergeadd_list % index_ps ( nmergeadd )) ALLOCATE ( mergeadd_list % status ( nmergeadd )) ALLOCATE ( mergeadd_list % ncomp ( nmergeadd )) ALLOCATE ( mergeadd_list % xh ( NDIM , nmergeadd )) ALLOCATE ( mergeadd_list % vh ( NDIM , nmergeadd )) ALLOCATE ( mergeadd_list % mass ( nmergeadd )) ALLOCATE ( mergeadd_list % radius ( nmergeadd )) return END SUBROUTINE symba_merger_allocate SUBROUTINE swiftest_tp_allocate ( swiftest_tpA , ntp ) USE swiftest USE module_swiftest IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: ntp TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA ALLOCATE ( swiftest_tpA % name ( ntp )) ALLOCATE ( swiftest_tpA % status ( ntp )) ALLOCATE ( swiftest_tpA % peri ( ntp )) ALLOCATE ( swiftest_tpA % atp ( ntp )) ALLOCATE ( swiftest_tpA % isperi ( ntp )) ALLOCATE ( swiftest_tpA % xh ( NDIM , ntp )) ALLOCATE ( swiftest_tpA % vh ( NDIM , ntp )) ALLOCATE ( swiftest_tpA % xb ( NDIM , ntp )) ALLOCATE ( swiftest_tpA % vb ( NDIM , ntp )) return END SUBROUTINE swiftest_tp_allocate SUBROUTINE helio_tp_allocate ( helio_tpA , ntp ) USE swiftest USE module_helio IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: ntp TYPE ( helio_tp ), INTENT ( INOUT ) :: helio_tpA ALLOCATE ( helio_tpA % ah ( NDIM , ntp )) ALLOCATE ( helio_tpA % ahi ( NDIM , ntp )) CALL swiftest_tp_allocate ( helio_tpA % swiftest , ntp ) return END SUBROUTINE helio_tp_allocate SUBROUTINE symba_tp_allocate ( symba_tpA , ntp ) USE swiftest USE module_symba IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: ntp TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA ALLOCATE ( symba_tpA % nplenc ( ntp )) ALLOCATE ( symba_tpA % levelg ( ntp )) ALLOCATE ( symba_tpA % levelm ( ntp )) CALL helio_tp_allocate ( symba_tpA % helio , ntp ) return END SUBROUTINE symba_tp_allocate SUBROUTINE symba_pltpenc_allocate ( pltpenc_list , npltpenc ) USE swiftest USE module_symba IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npltpenc TYPE ( symba_pltpenc ), INTENT ( INOUT ) :: pltpenc_list ALLOCATE ( pltpenc_list % lvdotr ( npltpenc )) ALLOCATE ( pltpenc_list % status ( npltpenc )) ALLOCATE ( pltpenc_list % level ( npltpenc )) ALLOCATE ( pltpenc_list % indexpl ( npltpenc )) ALLOCATE ( pltpenc_list % indextp ( npltpenc )) return END SUBROUTINE symba_pltpenc_allocate !___________________________ SUBROUTINE swiftest_pl_deallocate ( swiftest_plA ) USE swiftest USE module_swiftest IMPLICIT NONE ! Arguments TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA DEALLOCATE ( swiftest_plA % name ) DEALLOCATE ( swiftest_plA % status ) DEALLOCATE ( swiftest_plA % mass ) DEALLOCATE ( swiftest_plA % radius ) DEALLOCATE ( swiftest_plA % rhill ) DEALLOCATE ( swiftest_plA % xh ) DEALLOCATE ( swiftest_plA % vh ) DEALLOCATE ( swiftest_plA % xb ) DEALLOCATE ( swiftest_plA % vb ) return END SUBROUTINE swiftest_pl_deallocate SUBROUTINE helio_pl_deallocate ( helio_plA ) USE swiftest USE module_helio IMPLICIT NONE ! Arguments TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA DEALLOCATE ( helio_plA % ah ) DEALLOCATE ( helio_plA % ahi ) CALL swiftest_pl_deallocate ( helio_plA % swiftest ) return END SUBROUTINE helio_pl_deallocate SUBROUTINE symba_pl_deallocate ( symba_plA ) USE swiftest USE module_symba IMPLICIT NONE ! Arguments TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA DEALLOCATE ( symba_plA % lmerged ) DEALLOCATE ( symba_plA % nplenc ) DEALLOCATE ( symba_plA % ntpenc ) DEALLOCATE ( symba_plA % levelg ) DEALLOCATE ( symba_plA % levelm ) DEALLOCATE ( symba_plA % nchild ) DEALLOCATE ( symba_plA % isperi ) DEALLOCATE ( symba_plA % peri ) DEALLOCATE ( symba_plA % atp ) DEALLOCATE ( symba_plA % index_parent ) DEALLOCATE ( symba_plA % index_child ) CALL helio_pl_deallocate ( symba_plA % helio ) return END SUBROUTINE symba_pl_deallocate SUBROUTINE symba_plplenc_deallocate ( plplenc_list ) USE swiftest USE module_symba IMPLICIT NONE ! Arguments TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list DEALLOCATE ( plplenc_list % lvdotr ) DEALLOCATE ( plplenc_list % status ) DEALLOCATE ( plplenc_list % level ) DEALLOCATE ( plplenc_list % index1 ) DEALLOCATE ( plplenc_list % index2 ) DEALLOCATE ( plplenc_list % enc_child ) DEALLOCATE ( plplenc_list % enc_parent ) return END SUBROUTINE symba_plplenc_deallocate SUBROUTINE symba_merger_deallocate ( mergeadd_list ) USE swiftest USE module_symba IMPLICIT NONE ! Arguments TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list DEALLOCATE ( mergeadd_list % name ) DEALLOCATE ( mergeadd_list % index_ps ) DEALLOCATE ( mergeadd_list % status ) DEALLOCATE ( mergeadd_list % ncomp ) DEALLOCATE ( mergeadd_list % xh ) DEALLOCATE ( mergeadd_list % vh ) DEALLOCATE ( mergeadd_list % mass ) DEALLOCATE ( mergeadd_list % radius ) return END SUBROUTINE symba_merger_deallocate SUBROUTINE swiftest_tp_deallocate ( swiftest_tpA ) USE swiftest USE module_swiftest IMPLICIT NONE ! Arguments TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA DEALLOCATE ( swiftest_tpA % name ) DEALLOCATE ( swiftest_tpA % status ) DEALLOCATE ( swiftest_tpA % peri ) DEALLOCATE ( swiftest_tpA % atp ) DEALLOCATE ( swiftest_tpA % isperi ) DEALLOCATE ( swiftest_tpA % xh ) DEALLOCATE ( swiftest_tpA % vh ) DEALLOCATE ( swiftest_tpA % xb ) DEALLOCATE ( swiftest_tpA % vb ) return END SUBROUTINE swiftest_tp_deallocate SUBROUTINE helio_tp_deallocate ( helio_tpA ) USE swiftest USE module_helio IMPLICIT NONE ! Arguments TYPE ( helio_tp ), INTENT ( INOUT ) :: helio_tpA DEALLOCATE ( helio_tpA % ah ) DEALLOCATE ( helio_tpA % ahi ) CALL swiftest_tp_deallocate ( helio_tpA % swiftest ) return END SUBROUTINE helio_tp_deallocate SUBROUTINE symba_tp_deallocate ( symba_tpA ) USE swiftest USE module_symba IMPLICIT NONE ! Arguments TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA DEALLOCATE ( symba_tpA % nplenc ) DEALLOCATE ( symba_tpA % levelg ) DEALLOCATE ( symba_tpA % levelm ) return END SUBROUTINE symba_tp_deallocate SUBROUTINE symba_pltpenc_deallocate ( pltpenc_list ) USE swiftest USE module_symba IMPLICIT NONE ! Arguments TYPE ( symba_pltpenc ), INTENT ( INOUT ) :: pltpenc_list DEALLOCATE ( pltpenc_list % lvdotr ) DEALLOCATE ( pltpenc_list % status ) DEALLOCATE ( pltpenc_list % level ) DEALLOCATE ( pltpenc_list % indexpl ) DEALLOCATE ( pltpenc_list % indextp ) return END SUBROUTINE symba_pltpenc_deallocate END MODULE module_swiftestalloc","tags":"","loc":"sourcefile/module_swiftestalloc.f90.html"},{"title":"swiftest.f90 – swiftest","text":"Files dependent on this one sourcefile~~swiftest.f90~~AfferentGraph sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_helio_getacch_int.f90 symba_helio_getacch_int.f90 sourcefile~symba_helio_getacch_int.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_helio_getacch_int.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_helio_getacch_int.f90->sourcefile~module_helio.f90 sourcefile~orbel_xv2aqt.f90 orbel_xv2aqt.f90 sourcefile~orbel_xv2aqt.f90->sourcefile~swiftest.f90 sourcefile~helio_lindrift_tp.f90 helio_lindrift_tp.f90 sourcefile~helio_lindrift_tp.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~helio_lindrift_tp.f90->sourcefile~module_swiftest.f90 sourcefile~helio_lindrift_tp.f90->sourcefile~module_symba.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~helio_drift.f90->sourcefile~module_swiftest.f90 sourcefile~symba_discard_tp.f90 symba_discard_tp.f90 sourcefile~symba_discard_tp.f90->sourcefile~swiftest.f90 sourcefile~symba_discard_tp.f90->sourcefile~module_swiftest.f90 sourcefile~symba_discard_tp.f90->sourcefile~module_symba.f90 sourcefile~symba_discard_tp.f90->sourcefile~module_helio.f90 sourcefile~drift_one.f90 drift_one.f90 sourcefile~drift_one.f90->sourcefile~swiftest.f90 sourcefile~util_kahan_sum.f90 util_kahan_sum.f90 sourcefile~util_kahan_sum.f90->sourcefile~swiftest.f90 sourcefile~discard_pl_close.f90 discard_pl_close.f90 sourcefile~discard_pl_close.f90->sourcefile~swiftest.f90 sourcefile~symba_fragmentation.f90 symba_fragmentation.f90 sourcefile~symba_fragmentation.f90->sourcefile~swiftest.f90 sourcefile~symba_fragmentation.f90->sourcefile~module_swiftest.f90 sourcefile~symba_fragmentation.f90->sourcefile~module_symba.f90 sourcefile~symba_fragmentation.f90->sourcefile~module_helio.f90 sourcefile~obl_pot.f90 obl_pot.f90 sourcefile~obl_pot.f90->sourcefile~swiftest.f90 sourcefile~obl_pot.f90->sourcefile~module_swiftest.f90 sourcefile~helio_step_tp.f90 helio_step_tp.f90 sourcefile~helio_step_tp.f90->sourcefile~swiftest.f90 sourcefile~helio_step_tp.f90->sourcefile~module_swiftest.f90 sourcefile~helio_step_tp.f90->sourcefile~module_helio.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~discard.f90->sourcefile~module_swiftest.f90 sourcefile~discard_peri.f90 discard_peri.f90 sourcefile~discard_peri.f90->sourcefile~swiftest.f90 sourcefile~discard_peri.f90->sourcefile~module_swiftest.f90 sourcefile~io_read_encounter.f90 io_read_encounter.f90 sourcefile~io_read_encounter.f90->sourcefile~swiftest.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~util_peri.f90->sourcefile~module_swiftest.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~io_read_pl_in.f90 io_read_pl_in.f90 sourcefile~io_read_pl_in.f90->sourcefile~swiftest.f90 sourcefile~io.f90 io.f90 sourcefile~io_read_pl_in.f90->sourcefile~io.f90 sourcefile~io_read_pl_in.f90->sourcefile~module_symba.f90 sourcefile~symba_casemerge.f90 symba_casemerge.f90 sourcefile~symba_casemerge.f90->sourcefile~swiftest.f90 sourcefile~symba_casemerge.f90->sourcefile~module_swiftest.f90 sourcefile~symba_casemerge.f90->sourcefile~module_symba.f90 sourcefile~symba_casemerge.f90->sourcefile~module_helio.f90 sourcefile~io_dump_pl.f90 io_dump_pl.f90 sourcefile~io_dump_pl.f90->sourcefile~swiftest.f90 sourcefile~io_dump_pl.f90->sourcefile~module_swiftest.f90 sourcefile~symba_reorder_pl.f90 symba_reorder_pl.f90 sourcefile~symba_reorder_pl.f90->sourcefile~swiftest.f90 sourcefile~symba_reorder_pl.f90->sourcefile~module_swiftest.f90 sourcefile~symba_reorder_pl.f90->sourcefile~module_symba.f90 sourcefile~symba_reorder_pl.f90->sourcefile~module_helio.f90 sourcefile~symba_step_recur.f90 symba_step_recur.f90 sourcefile~symba_step_recur.f90->sourcefile~swiftest.f90 sourcefile~symba_step_recur.f90->sourcefile~module_swiftest.f90 sourcefile~symba_step_recur.f90->sourcefile~module_symba.f90 sourcefile~symba_step_recur.f90->sourcefile~module_helio.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~coord_vh2vb.f90 coord_vh2vb.f90 sourcefile~coord_vh2vb.f90->sourcefile~swiftest.f90 sourcefile~coord_vh2vb.f90->sourcefile~module_swiftest.f90 sourcefile~coord_vh2vb.f90->sourcefile~module_symba.f90 sourcefile~tool_encounter_read.f90 tool_encounter_read.f90 sourcefile~tool_encounter_read.f90->sourcefile~swiftest.f90 sourcefile~tool_encounter_read.f90->sourcefile~io.f90 sourcefile~coord_vb2vh_tp.f90 coord_vb2vh_tp.f90 sourcefile~coord_vb2vh_tp.f90->sourcefile~swiftest.f90 sourcefile~coord_vb2vh_tp.f90->sourcefile~module_swiftest.f90 sourcefile~coord_vb2vh_tp.f90->sourcefile~module_symba.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90->sourcefile~module_swiftest.f90 sourcefile~symba_step.f90->sourcefile~module_symba.f90 sourcefile~symba_step.f90->sourcefile~module_helio.f90 sourcefile~util_sort_i4b.f90 util_sort_i4b.f90 sourcefile~util_sort_i4b.f90->sourcefile~swiftest.f90 sourcefile~symba_discard_pl.f90 symba_discard_pl.f90 sourcefile~symba_discard_pl.f90->sourcefile~swiftest.f90 sourcefile~symba_discard_pl.f90->sourcefile~module_swiftest.f90 sourcefile~symba_discard_pl.f90->sourcefile~module_symba.f90 sourcefile~symba_discard_pl.f90->sourcefile~module_helio.f90 sourcefile~util_resize_pl.f90 util_resize_pl.f90 sourcefile~util_resize_pl.f90->sourcefile~swiftest.f90 sourcefile~util_resize_pl.f90->sourcefile~module_swiftest.f90 sourcefile~module_nrutil.f90 module_nrutil.f90 sourcefile~util_resize_pl.f90->sourcefile~module_nrutil.f90 sourcefile~module_swiftestalloc.f90 module_swiftestalloc.f90 sourcefile~util_resize_pl.f90->sourcefile~module_swiftestalloc.f90 sourcefile~util_resize_pl.f90->sourcefile~module_symba.f90 sourcefile~util_resize_pl.f90->sourcefile~module_helio.f90 sourcefile~symba_step_interp.f90 symba_step_interp.f90 sourcefile~symba_step_interp.f90->sourcefile~swiftest.f90 sourcefile~symba_step_interp.f90->sourcefile~module_swiftest.f90 sourcefile~symba_step_interp.f90->sourcefile~module_symba.f90 sourcefile~symba_step_interp.f90->sourcefile~module_helio.f90 sourcefile~io_write_frame.f90 io_write_frame.f90 sourcefile~io_write_frame.f90->sourcefile~swiftest.f90 sourcefile~io_write_frame.f90->sourcefile~module_swiftest.f90 sourcefile~symba_casedisruption.f90 symba_casedisruption.f90 sourcefile~symba_casedisruption.f90->sourcefile~swiftest.f90 sourcefile~symba_casedisruption.f90->sourcefile~module_swiftest.f90 sourcefile~symba_casedisruption.f90->sourcefile~module_symba.f90 sourcefile~symba_casedisruption.f90->sourcefile~module_helio.f90 sourcefile~helio_lindrift.f90 helio_lindrift.f90 sourcefile~helio_lindrift.f90->sourcefile~swiftest.f90 sourcefile~helio_lindrift.f90->sourcefile~module_swiftest.f90 sourcefile~helio_lindrift.f90->sourcefile~module_symba.f90 sourcefile~helio_user_getacch_tp.f90 helio_user_getacch_tp.f90 sourcefile~helio_user_getacch_tp.f90->sourcefile~swiftest.f90 sourcefile~helio_user_getacch_tp.f90->sourcefile~module_helio.f90 sourcefile~swiftest_symba.f90 swiftest_symba.f90 sourcefile~swiftest_symba.f90->sourcefile~swiftest.f90 sourcefile~swiftest_symba.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest_symba.f90->sourcefile~io.f90 sourcefile~swiftest_symba.f90->sourcefile~module_swiftestalloc.f90 sourcefile~swiftest_symba.f90->sourcefile~module_symba.f90 sourcefile~symba_user_getacch_tp.f90 symba_user_getacch_tp.f90 sourcefile~symba_user_getacch_tp.f90->sourcefile~swiftest.f90 sourcefile~symba_user_getacch_tp.f90->sourcefile~module_symba.f90 sourcefile~io_getn.f90 io_getn.f90 sourcefile~io_getn.f90->sourcefile~swiftest.f90 sourcefile~drift_kepu_fchk.f90 drift_kepu_fchk.f90 sourcefile~drift_kepu_fchk.f90->sourcefile~swiftest.f90 sourcefile~helio_getacch_tp.f90 helio_getacch_tp.f90 sourcefile~helio_getacch_tp.f90->sourcefile~swiftest.f90 sourcefile~helio_getacch_tp.f90->sourcefile~module_swiftest.f90 sourcefile~helio_getacch_tp.f90->sourcefile~module_helio.f90 sourcefile~symba_merge_tp.f90 symba_merge_tp.f90 sourcefile~symba_merge_tp.f90->sourcefile~swiftest.f90 sourcefile~module_swifter.f90 module_swifter.f90 sourcefile~symba_merge_tp.f90->sourcefile~module_swifter.f90 sourcefile~symba_merge_tp.f90->sourcefile~module_symba.f90 sourcefile~symba_merge_tp.f90->sourcefile~module_helio.f90 sourcefile~orbel_xv2aeq.f90 orbel_xv2aeq.f90 sourcefile~orbel_xv2aeq.f90->sourcefile~swiftest.f90 sourcefile~coord_h2b.f90 coord_h2b.f90 sourcefile~coord_h2b.f90->sourcefile~swiftest.f90 sourcefile~coord_h2b.f90->sourcefile~module_swiftest.f90 sourcefile~drift_kepu_guess.f90 drift_kepu_guess.f90 sourcefile~drift_kepu_guess.f90->sourcefile~swiftest.f90 sourcefile~drift_kepu_stumpff.f90 drift_kepu_stumpff.f90 sourcefile~drift_kepu_stumpff.f90->sourcefile~swiftest.f90 sourcefile~io_init_pl.f90 io_init_pl.f90 sourcefile~io_init_pl.f90->sourcefile~swiftest.f90 sourcefile~io_init_pl.f90->sourcefile~module_swiftest.f90 sourcefile~io_init_pl.f90->sourcefile~module_symba.f90 sourcefile~io_init_pl.f90->sourcefile~module_helio.f90 sourcefile~symba_step_helio.f90 symba_step_helio.f90 sourcefile~symba_step_helio.f90->sourcefile~swiftest.f90 sourcefile~symba_step_helio.f90->sourcefile~module_swiftest.f90 sourcefile~symba_step_helio.f90->sourcefile~module_symba.f90 sourcefile~symba_step_helio.f90->sourcefile~module_helio.f90 sourcefile~obl_acc.f90 obl_acc.f90 sourcefile~obl_acc.f90->sourcefile~swiftest.f90 sourcefile~obl_acc.f90->sourcefile~module_swiftest.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~io.f90->sourcefile~module_symba.f90 sourcefile~symba_chk.f90 symba_chk.f90 sourcefile~symba_chk.f90->sourcefile~swiftest.f90 sourcefile~symba_chk.f90->sourcefile~module_swiftest.f90 sourcefile~symba_chk.f90->sourcefile~module_symba.f90 sourcefile~symba_chk.f90->sourcefile~module_helio.f90 sourcefile~drift_kepmd.f90 drift_kepmd.f90 sourcefile~drift_kepmd.f90->sourcefile~swiftest.f90 sourcefile~util_hills.f90 util_hills.f90 sourcefile~util_hills.f90->sourcefile~swiftest.f90 sourcefile~util_hills.f90->sourcefile~module_swiftest.f90 sourcefile~drift_kepu_new.f90 drift_kepu_new.f90 sourcefile~drift_kepu_new.f90->sourcefile~swiftest.f90 sourcefile~io_read_hdr.f90 io_read_hdr.f90 sourcefile~io_read_hdr.f90->sourcefile~swiftest.f90 sourcefile~orbel_xv2el.f90 orbel_xv2el.f90 sourcefile~orbel_xv2el.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90->sourcefile~module_swiftest.f90 sourcefile~symba_kick.f90->sourcefile~module_symba.f90 sourcefile~symba_kick.f90->sourcefile~module_helio.f90 sourcefile~discard_sun.f90 discard_sun.f90 sourcefile~discard_sun.f90->sourcefile~swiftest.f90 sourcefile~discard_sun.f90->sourcefile~module_swiftest.f90 sourcefile~io_write_line.f90 io_write_line.f90 sourcefile~io_write_line.f90->sourcefile~swiftest.f90 sourcefile~coord_h2b_tp.f90 coord_h2b_tp.f90 sourcefile~coord_h2b_tp.f90->sourcefile~swiftest.f90 sourcefile~coord_h2b_tp.f90->sourcefile~module_swiftest.f90 sourcefile~drift_kepu_p3solve.f90 drift_kepu_p3solve.f90 sourcefile~drift_kepu_p3solve.f90->sourcefile~swiftest.f90 sourcefile~util_toupper.f90 util_toupper.f90 sourcefile~util_toupper.f90->sourcefile~swiftest.f90 sourcefile~symba_discard_peri_pl.f90 symba_discard_peri_pl.f90 sourcefile~symba_discard_peri_pl.f90->sourcefile~swiftest.f90 sourcefile~symba_discard_peri_pl.f90->sourcefile~module_swiftest.f90 sourcefile~symba_discard_peri_pl.f90->sourcefile~module_symba.f90 sourcefile~symba_discard_peri_pl.f90->sourcefile~module_helio.f90 sourcefile~drift_dan.f90 drift_dan.f90 sourcefile~drift_dan.f90->sourcefile~swiftest.f90 sourcefile~io_write_hdr.f90 io_write_hdr.f90 sourcefile~io_write_hdr.f90->sourcefile~swiftest.f90 sourcefile~symba_step_helio_pl.f90 symba_step_helio_pl.f90 sourcefile~symba_step_helio_pl.f90->sourcefile~swiftest.f90 sourcefile~symba_step_helio_pl.f90->sourcefile~module_swiftest.f90 sourcefile~symba_step_helio_pl.f90->sourcefile~module_symba.f90 sourcefile~symba_step_helio_pl.f90->sourcefile~module_helio.f90 sourcefile~symba_getacch_tp.f90 symba_getacch_tp.f90 sourcefile~symba_getacch_tp.f90->sourcefile~swiftest.f90 sourcefile~symba_getacch_tp.f90->sourcefile~module_swiftest.f90 sourcefile~symba_getacch_tp.f90->sourcefile~module_symba.f90 sourcefile~symba_getacch_tp.f90->sourcefile~module_helio.f90 sourcefile~symba_helio_drift_tp.f90 symba_helio_drift_tp.f90 sourcefile~symba_helio_drift_tp.f90->sourcefile~swiftest.f90 sourcefile~symba_helio_drift_tp.f90->sourcefile~module_swiftest.f90 sourcefile~symba_helio_drift_tp.f90->sourcefile~module_symba.f90 sourcefile~symba_helio_drift_tp.f90->sourcefile~module_helio.f90 sourcefile~helio_kickvb.f90 helio_kickvb.f90 sourcefile~helio_kickvb.f90->sourcefile~swiftest.f90 sourcefile~helio_kickvb.f90->sourcefile~module_swiftest.f90 sourcefile~helio_kickvb.f90->sourcefile~module_helio.f90 sourcefile~module_swifter.f90->sourcefile~swiftest.f90 sourcefile~symba_helio_getacch.f90 symba_helio_getacch.f90 sourcefile~symba_helio_getacch.f90->sourcefile~swiftest.f90 sourcefile~symba_helio_getacch.f90->sourcefile~module_swiftest.f90 sourcefile~symba_helio_getacch.f90->sourcefile~module_symba.f90 sourcefile~symba_helio_getacch.f90->sourcefile~module_helio.f90 sourcefile~symba_helio_drift.f90 symba_helio_drift.f90 sourcefile~symba_helio_drift.f90->sourcefile~swiftest.f90 sourcefile~symba_helio_drift.f90->sourcefile~module_swiftest.f90 sourcefile~symba_helio_drift.f90->sourcefile~module_symba.f90 sourcefile~symba_helio_drift.f90->sourcefile~module_helio.f90 sourcefile~coord_vh2vb_tp.f90 coord_vh2vb_tp.f90 sourcefile~coord_vh2vb_tp.f90->sourcefile~swiftest.f90 sourcefile~coord_vh2vb_tp.f90->sourcefile~module_swiftest.f90 sourcefile~symba_casehitandrun.f90 symba_casehitandrun.f90 sourcefile~symba_casehitandrun.f90->sourcefile~swiftest.f90 sourcefile~symba_casehitandrun.f90->sourcefile~module_swiftest.f90 sourcefile~symba_casehitandrun.f90->sourcefile~module_symba.f90 sourcefile~symba_casehitandrun.f90->sourcefile~module_helio.f90 sourcefile~module_nrutil.f90->sourcefile~swiftest.f90 sourcefile~coord_vb2vh.f90 coord_vb2vh.f90 sourcefile~coord_vb2vh.f90->sourcefile~swiftest.f90 sourcefile~coord_vb2vh.f90->sourcefile~module_swiftest.f90 sourcefile~helio_getacch_int_tp.f90 helio_getacch_int_tp.f90 sourcefile~helio_getacch_int_tp.f90->sourcefile~swiftest.f90 sourcefile~helio_getacch_int_tp.f90->sourcefile~module_swiftest.f90 sourcefile~helio_getacch_int_tp.f90->sourcefile~module_helio.f90 sourcefile~helio_step_pl.f90 helio_step_pl.f90 sourcefile~helio_step_pl.f90->sourcefile~swiftest.f90 sourcefile~helio_step_pl.f90->sourcefile~module_swiftest.f90 sourcefile~helio_step_pl.f90->sourcefile~module_helio.f90 sourcefile~symba_merge_pl.f90 symba_merge_pl.f90 sourcefile~symba_merge_pl.f90->sourcefile~swiftest.f90 sourcefile~symba_merge_pl.f90->sourcefile~module_swiftest.f90 sourcefile~symba_merge_pl.f90->sourcefile~module_symba.f90 sourcefile~symba_merge_pl.f90->sourcefile~module_helio.f90 sourcefile~io_open_fxdr.f90 io_open_fxdr.f90 sourcefile~io_open_fxdr.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90->sourcefile~module_swiftest.f90 sourcefile~io_open.f90 io_open.f90 sourcefile~io_open.f90->sourcefile~swiftest.f90 sourcefile~module_swiftestalloc.f90->sourcefile~swiftest.f90 sourcefile~module_swiftestalloc.f90->sourcefile~module_swiftest.f90 sourcefile~module_swiftestalloc.f90->sourcefile~module_symba.f90 sourcefile~module_swiftestalloc.f90->sourcefile~module_helio.f90 sourcefile~drift_kepu.f90 drift_kepu.f90 sourcefile~drift_kepu.f90->sourcefile~swiftest.f90 sourcefile~symba_peri.f90 symba_peri.f90 sourcefile~symba_peri.f90->sourcefile~swiftest.f90 sourcefile~symba_peri.f90->sourcefile~module_swiftest.f90 sourcefile~symba_peri.f90->sourcefile~module_symba.f90 sourcefile~symba_peri.f90->sourcefile~module_helio.f90 sourcefile~io_write_encounter.f90 io_write_encounter.f90 sourcefile~io_write_encounter.f90->sourcefile~swiftest.f90 sourcefile~symba_discard_sun_pl.f90 symba_discard_sun_pl.f90 sourcefile~symba_discard_sun_pl.f90->sourcefile~swiftest.f90 sourcefile~symba_discard_sun_pl.f90->sourcefile~module_swiftest.f90 sourcefile~io_discard_write_symba.f90 io_discard_write_symba.f90 sourcefile~io_discard_write_symba.f90->sourcefile~swiftest.f90 sourcefile~io_discard_write_symba.f90->sourcefile~module_swiftest.f90 sourcefile~io_discard_write_symba.f90->sourcefile~module_symba.f90 sourcefile~symba_rearray.f90 symba_rearray.f90 sourcefile~symba_rearray.f90->sourcefile~swiftest.f90 sourcefile~symba_rearray.f90->sourcefile~module_swiftest.f90 sourcefile~symba_rearray.f90->sourcefile~module_swiftestalloc.f90 sourcefile~symba_rearray.f90->sourcefile~module_symba.f90 sourcefile~symba_rearray.f90->sourcefile~module_helio.f90 sourcefile~io_dump_param.f90 io_dump_param.f90 sourcefile~io_dump_param.f90->sourcefile~swiftest.f90 sourcefile~helio_getacch.f90 helio_getacch.f90 sourcefile~helio_getacch.f90->sourcefile~swiftest.f90 sourcefile~helio_getacch.f90->sourcefile~module_swiftest.f90 sourcefile~helio_getacch.f90->sourcefile~module_helio.f90 sourcefile~helio_getacch_int.f90 helio_getacch_int.f90 sourcefile~helio_getacch_int.f90->sourcefile~swiftest.f90 sourcefile~helio_getacch_int.f90->sourcefile~module_helio.f90 sourcefile~io_init_tp.f90 io_init_tp.f90 sourcefile~io_init_tp.f90->sourcefile~swiftest.f90 sourcefile~io_init_tp.f90->sourcefile~module_swiftest.f90 sourcefile~io_init_tp.f90->sourcefile~module_symba.f90 sourcefile~io_init_tp.f90->sourcefile~module_helio.f90 sourcefile~obl_acc_tp.f90 obl_acc_tp.f90 sourcefile~obl_acc_tp.f90->sourcefile~swiftest.f90 sourcefile~util_sort_sp.f90 util_sort_sp.f90 sourcefile~util_sort_sp.f90->sourcefile~swiftest.f90 sourcefile~orbel_scget.f90 orbel_scget.f90 sourcefile~orbel_scget.f90->sourcefile~swiftest.f90 sourcefile~util_sort_dp.f90 util_sort_dp.f90 sourcefile~util_sort_dp.f90->sourcefile~swiftest.f90 sourcefile~helio_drift_tp.f90 helio_drift_tp.f90 sourcefile~helio_drift_tp.f90->sourcefile~swiftest.f90 sourcefile~helio_drift_tp.f90->sourcefile~module_swiftest.f90 sourcefile~helio_user_getacch.f90 helio_user_getacch.f90 sourcefile~helio_user_getacch.f90->sourcefile~swiftest.f90 sourcefile~helio_user_getacch.f90->sourcefile~module_helio.f90 sourcefile~helio_kickvb_tp.f90 helio_kickvb_tp.f90 sourcefile~helio_kickvb_tp.f90->sourcefile~swiftest.f90 sourcefile~helio_kickvb_tp.f90->sourcefile~module_swiftest.f90 sourcefile~helio_kickvb_tp.f90->sourcefile~module_helio.f90 sourcefile~python_io_write_frame_tp.f90 python_io_write_frame_tp.f90 sourcefile~python_io_write_frame_tp.f90->sourcefile~swiftest.f90 sourcefile~python_io_write_frame_tp.f90->sourcefile~module_swiftest.f90 sourcefile~python_io_write_frame_tp.f90->sourcefile~module_symba.f90 sourcefile~python_io_write_frame_tp.f90->sourcefile~module_helio.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~io_read_line.f90 io_read_line.f90 sourcefile~io_read_line.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~util_index.f90 util_index.f90 sourcefile~util_index.f90->sourcefile~swiftest.f90 sourcefile~util_index.f90->sourcefile~module_nrutil.f90 sourcefile~io_dump_tp.f90 io_dump_tp.f90 sourcefile~io_dump_tp.f90->sourcefile~swiftest.f90 sourcefile~io_dump_tp.f90->sourcefile~module_swiftest.f90 sourcefile~symba_caseresolve.f90 symba_caseresolve.f90 sourcefile~symba_caseresolve.f90->sourcefile~swiftest.f90 sourcefile~symba_caseresolve.f90->sourcefile~module_swiftest.f90 sourcefile~symba_caseresolve.f90->sourcefile~module_symba.f90 sourcefile~symba_caseresolve.f90->sourcefile~module_helio.f90 sourcefile~symba_energy.f90 symba_energy.f90 sourcefile~symba_energy.f90->sourcefile~swiftest.f90 sourcefile~symba_energy.f90->sourcefile~module_swiftest.f90 sourcefile~symba_user_getacch.f90 symba_user_getacch.f90 sourcefile~symba_user_getacch.f90->sourcefile~swiftest.f90 sourcefile~symba_user_getacch.f90->sourcefile~module_symba.f90 sourcefile~symba_getacch.f90 symba_getacch.f90 sourcefile~symba_getacch.f90->sourcefile~swiftest.f90 sourcefile~symba_getacch.f90->sourcefile~module_swiftest.f90 sourcefile~symba_getacch.f90->sourcefile~module_symba.f90 sourcefile~symba_getacch.f90->sourcefile~module_helio.f90 sourcefile~discard_pl.f90 discard_pl.f90 sourcefile~discard_pl.f90->sourcefile~swiftest.f90 sourcefile~discard_pl.f90->sourcefile~module_swiftest.f90 sourcefile~python_io_write_frame_pl.f90 python_io_write_frame_pl.f90 sourcefile~python_io_write_frame_pl.f90->sourcefile~swiftest.f90 sourcefile~python_io_write_frame_pl.f90->sourcefile~module_swiftest.f90 sourcefile~python_io_write_frame_pl.f90->sourcefile~module_symba.f90 sourcefile~python_io_write_frame_pl.f90->sourcefile~module_helio.f90 sourcefile~symba_discard_merge_pl.f90 symba_discard_merge_pl.f90 sourcefile~symba_discard_merge_pl.f90->sourcefile~swiftest.f90 sourcefile~symba_discard_merge_pl.f90->sourcefile~module_swifter.f90 sourcefile~symba_discard_merge_pl.f90->sourcefile~module_symba.f90 sourcefile~symba_discard_merge_pl.f90->sourcefile~module_helio.f90 sourcefile~rmvs_chk_ind.f90 rmvs_chk_ind.f90 sourcefile~rmvs_chk_ind.f90->sourcefile~swiftest.f90 sourcefile~symba_casesupercatastrophic.f90 symba_casesupercatastrophic.f90 sourcefile~symba_casesupercatastrophic.f90->sourcefile~swiftest.f90 sourcefile~symba_casesupercatastrophic.f90->sourcefile~module_swiftest.f90 sourcefile~symba_casesupercatastrophic.f90->sourcefile~module_symba.f90 sourcefile~symba_casesupercatastrophic.f90->sourcefile~module_helio.f90 sourcefile~drift_kepu_lag.f90 drift_kepu_lag.f90 sourcefile~drift_kepu_lag.f90->sourcefile~swiftest.f90 sourcefile~io_read_param_in.f90 io_read_param_in.f90 sourcefile~io_read_param_in.f90->sourcefile~io.f90 sourcefile~io_get_token.f90 io_get_token.f90 sourcefile~io_get_token.f90->sourcefile~io.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules swiftest Source Code swiftest.f90 Source Code module swiftest !! author: David A. Minton !! graph: false !! !! Basic parameters, definitions, and global type definitions used throughout the Swiftest project !! Adapted from Swifter module_parameters and module_swifter !! Original author David E. Kaufmann implicit none integer , parameter :: I4B = SELECTED_INT_KIND ( 9 ) !! Symbolic name for kind types of 4-byte integers integer , parameter :: I2B = SELECTED_INT_KIND ( 4 ) !! Symbolic name for kind types of 2-byte integers integer , parameter :: I1B = SELECTED_INT_KIND ( 2 ) !! Symbolic name for kind types of 1-byte integers integer , parameter :: SP = KIND ( 1.0 ) !! Symbolic name for kind types of single-precision reals integer , parameter :: DP = KIND ( 1.0D0 ) !! Symbolic name for kind types of double-precision reals integer , parameter :: LGT = KIND (. TRUE .) !! Symbolic name for kind type of default logical real ( DP ), parameter :: PIBY2 = 1.570796326794896619231321691639751442099_DP !! Definition of /(\\pi / 2 real ( DP ), parameter :: PI = 3.141592653589793238462643383279502884197_DP !! Definition of /(\\pi real ( DP ), parameter :: PI3BY2 = 4.712388980384689857693965074919254326296_DP !! Definition of /(3 \\pi / 2 real ( DP ), parameter :: TWOPI = 6.283185307179586476925286766559005768394_DP !! Definition of /(2\\pi) real ( DP ), parameter :: DEGRAD = 18 0.0_DP / PI !! Definition of conversion factor from degrees to radians integer ( I4B ), parameter :: LOWERCASE_BEGIN = IACHAR ( 'a' ) !! ASCII character set parameter for lower to upper conversion - start of lowercase integer ( I4B ), parameter :: LOWERCASE_END = IACHAR ( 'z' ) !! ASCII character set parameter for lower to upper conversion - end of lowercase integer ( I4B ), parameter :: UPPERCASE_OFFSET = IACHAR ( 'A' ) - IACHAR ( 'a' ) !! ASCII character set parameter for lower to upper conversion - offset between upper and lower real ( SP ), parameter :: VERSION_NUMBER = 1.0_SP !! swiftest version !> Symbolic name for swiftest types !integer(I4B), parameter  :: SWIFTEST = 1 !integer(I4B), parameter  :: BS       = 2 !integer(I4B), parameter :: HELIO    = 3 !integer(I4B), parameter :: RA15     = 4 !integer(I4B), parameter :: TU4      = 5 !integer(I4B), parameter :: WHM      = 6 !integer(I4B), parameter :: RMVS     = 7 !integer(I4B), parameter  :: SYMBA    = 8 integer ( I4B ), parameter :: STRMAX = 128 !! Maximum size of character strings CHARACTER ( * ), parameter :: REAL4_TYPE = \"REAL4\" !! Symbolic name for binary output file type real4 CHARACTER ( * ), parameter :: REAL8_TYPE = \"REAL8\" !! Symbolic name for binary output file type real8 CHARACTER ( * ), parameter :: XDR4_TYPE = \"XDR4\" !! Symbolic name for binary output file type XDR4 CHARACTER ( * ), parameter :: XDR8_TYPE = \"XDR8\" !! Symbolic name for binary output file type XDR8 integer ( I4B ), parameter :: EL = 1 !! Symbolic name for binary output file contents for orbital element type integer ( I4B ), parameter :: XV = 2 !! Symbolic name for binary output file contents for cartesian position and velocity type integer ( I4B ), parameter :: FILT = 3 !! Symbolic name for binary output file contents for filtered type ! OPENMP code added by D. Minton ! OpenMP Parameters integer ( I4B ), save :: nthreads = 1 !! Number of OpenMP threads integer ( I4B ), parameter :: NTHERSHOLD = 1000 !! Threshold value for OpenMP loop parallelization integer ( I4B ), parameter :: SUCCESS = 0 !! Symbolic name for function return/flag code for success integer ( I4B ), parameter :: FAILURE = - 1 !! Symbolic name for function return/flag code for failure integer ( I4B ), parameter :: ELLIPSE = - 1 !! Symbolic names for orbit types - ellipse integer ( I4B ), parameter :: PARABOLA = 0 !! Symbolic names for orbit types - parabola integer ( I4B ), parameter :: HYPERBOLA = 1 !! Symbolic names for orbit types - hyperbola !> Symbolic names for body/particle status codes: integer ( I4B ), parameter :: ACTIVE = 0 integer ( I4B ), parameter :: INACTIVE = 1 integer ( I4B ), parameter :: DISCARDED_RMAX = - 1 integer ( I4B ), parameter :: DISCARDED_RMIN = - 2 integer ( I4B ), parameter :: DISCARDED_RMAXU = - 3 integer ( I4B ), parameter :: DISCARDED_PERI = - 4 integer ( I4B ), parameter :: DISCARDED_PLR = - 5 integer ( I4B ), parameter :: DISCARDED_PLQ = - 6 integer ( I4B ), parameter :: DISCARDED_DRIFTERR = - 7 integer ( I4B ), parameter :: MERGED = - 8 integer ( I4B ), parameter :: DISRUPTION = - 9 integer ( I4B ), parameter :: SUPERCATASTROPHIC = - 10 integer ( I4B ), parameter :: GRAZE_AND_MERGE = - 11 integer ( I4B ), parameter :: HIT_AND_RUN = - 12 !>Symbolic names for collisional outcomes from collresolve_resolve: integer ( I4B ), parameter :: COLLRESOLVE_REGIME_MERGE = 1 integer ( I4B ), parameter :: COLLRESOLVE_REGIME_DISRUPTION = 2 integer ( I4B ), parameter :: COLLRESOLVE_REGIME_SUPERCATASTROPHIC = 3 integer ( I4B ), parameter :: COLLRESOLVE_REGIME_GRAZE_AND_MERGE = 4 integer ( I4B ), parameter :: COLLRESOLVE_REGIME_HIT_AND_RUN = 5 !> String labels for body/particle addition/subtraction in discard file CHARACTER ( * ), parameter :: ADD = \"+1\" CHARACTER ( * ), parameter :: SUB = \"-1\" !> Standard file names CHARACTER ( * ), parameter :: DISCARD_FILE = \"discard.out\" CHARACTER ( * ), dimension ( 2 ), parameter :: DUMP_PARAM_FILE = ( / \"dump_param1.dat\" , \"dump_param2.dat\" / ) CHARACTER ( * ), dimension ( 2 ), parameter :: DUMP_PL_FILE = ( / \"dump_pl1.bin\" , \"dump_pl2.bin\" / ) CHARACTER ( * ), dimension ( 2 ), parameter :: DUMP_TP_FILE = ( / \"dump_tp1.bin\" , \"dump_tp2.bin\" / ) CHARACTER ( * ), parameter :: ENERGY_FILE = \"energy.out\" CHARACTER ( * ), parameter :: pl_outfile = \"pl_out.dat\" CHARACTER ( * ), parameter :: tp_outfile = \"tp_out.dat\" !> Integration control parameters: real ( DP ), parameter :: E2MAX = 0.36_DP real ( DP ), parameter :: DM2MAX = 0.16_DP real ( DP ), parameter :: E2DM2MAX = 0.0016_DP real ( DP ), parameter :: DANBYB = 1.0E-13_DP integer ( I2B ), parameter :: NLAG1 = 50 integer ( I2B ), parameter :: NLAG2 = 400 !> Miscellaneous constants: integer ( I4B ), parameter :: NDIM = 3 !! Number of dimensions in our reality integer ( I4B ), parameter :: NDIM2 = 2 * NDIM !! 2x the number of dimensions integer ( I4B ), parameter :: LOOPMAX = 2147483647 !! Maximum loop limit /(2&#94;{31} - 1 real ( DP ), parameter :: TINY = 4.0E-15_DP ! Added by D. Minton real ( DP ) :: MU2GM = - 1.0_DP !! Converts mass units to grams real ( DP ) :: TU2S = - 1.0_DP !! Converts time units to seconds real ( DP ) :: DU2CM = - 1.0_DP !! Converts distance unit to centimeters real ( DP ), parameter :: GC = 6.6743E-8_DP !! Universal gravitational constant in cgs units (from NIST in 2019) !> Added by Carlisle Wishard and Jennifer Pouplin logical , save :: ldiscard = . false . !! If true, then proceed to discard spilled pl and complete discard.out file. logical , save :: ldiscard_tp = . false . !! If true, then proceed to discard spilled tp !>Logical flags to turn on or off various features of the code type feature_list logical :: lextra_force = . false . !! User defined force function turned on logical :: lbig_discard = . false . !! Save big bodies on every discard logical :: lrhill_present = . false . !! Hill's radius is in input file logical :: lclose = . false . !! Turn on close encounters logical :: lfragmentation = . false . !! Do fragmentation modeling instead of simple merger. logical :: lpython = . false . !! Output binary data in Python-friendly format logical :: lenergy = . false . !! Track the total energy of the system logical :: lrotation = . false . !! Include rotation states of big bodies logical :: ltides = . false . !! Include tidal dissipation logical :: lringmoons = . false . !! Turn on the ringmoons code logical :: lpredprey = . false . !! Turn on the predator/prey model for seed growth in ringmoons (experimental) ! Future features not implemented or in development logical :: lgr = . false . !! Turn on GR logical :: lyarkosvsky = . false . !! Turn on Yarkovsky effect logical :: lyorp = . false . !! Turn on YORP effect end type feature_list !> User defined input parameters that are read in from param.in type input_parameters type ( feature_list ) :: feature !! collection of logical flags for various features integer ( I4B ) :: nplmax = - 1 !! maximum allowed number of planets integer ( I4B ) :: ntpmax = - 1 !! maximum allowed number of test particles real ( DP ) :: t0 = 0.0_DP !! integration start time real ( DP ) :: tstop = 0.0_DP !! integration stop time real ( DP ) :: dt = 0.0_DP !! time step character ( STRMAX ) :: inplfile = '' !! name of input file for planets character ( STRMAX ) :: intpfile = '' !! name of input file for test particles character ( STRMAX ) :: in_type = 'ASCII' !! format of input data files integer ( I4B ) :: istep_out = - 1 !! number of time steps between binary outputs character ( STRMAX ) :: outfile = '' !! name of output binary file character ( STRMAX ) :: out_type = XDR4_TYPE !! binary format of output file character ( STRMAX ) :: out_form = 'XV' !! data to write to output file character ( STRMAX ) :: out_stat = 'NEW' !! open status for output binary file integer ( I4B ) :: istep_dump = - 1 !! number of time steps between dumps real ( DP ) :: j2rp2 = 0.0_DP !! J2 * R**2 for the Sun real ( DP ) :: j4rp4 = 0.0_DP !! J4 * R**4 for the Sun real ( DP ) :: rmin = - 1.0_DP !! minimum heliocentric radius for test particle real ( DP ) :: rmax = - 1.0_DP !! maximum heliocentric radius for test particle real ( DP ) :: rmaxu = - 1.0_DP !! maximum unbound heliocentric radius for test particle real ( DP ) :: qmin = - 1.0_DP !! minimum pericenter distance for test particle character ( STRMAX ) :: qmin_coord = 'HELIO' !! coordinate frame to use for qmin real ( DP ) :: qmin_alo = - 1.0_DP !! minimum semimajor axis for qmin real ( DP ) :: qmin_ahi = - 1.0_DP !! maximum semimajor axis for qmin character ( STRMAX ) :: encounter_file = '' !! name of output file for encounters real ( DP ) :: mtiny = 0.0_DP !! smallest mass that is fully gravitating character ( STRMAX ) :: ring_outfile = '' !! name of output file in ring moons real ( DP ) :: MU2GM = - 1.0_DP !! Converts mass units to grams real ( DP ) :: TU2S = - 1.0_DP !! Converts time units to seconds real ( DP ) :: DU2CM = - 1.0_DP !! Converts distance unit to centimeters end type input_parameters !!List of parameters that are input by the user in the param.in file END module swiftest","tags":"","loc":"sourcefile/swiftest.f90.html"},{"title":"module_fxdr.f90 – swiftest","text":"Unit Name   : module_fxdr\n  Unit Type   : module\n  Project     : SWIFTEST\n  Package     : module\n  Language    : Fortran 90/95 Description : Definition of interfaces of functions in the FXDR (Fortran eXternal Data Representation) library Input\n    Arguments : N/A\n    Terminal  : N/A\n    File      : N/A Output\n    Arguments : N/A\n    Terminal  : N/A\n    File      : N/A Invocation  : N/A Notes       : FXDR is a library, written and maintained by David W. Pierce, that enables calls to the XDR (eXternal Data\n                Representation) routines from Fortran. Reference : http://meteora.ucsd.edu/~pierce/fxdr_home_page.html Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ Files dependent on this one sourcefile~~module_fxdr.f90~~AfferentGraph sourcefile~module_fxdr.f90 module_fxdr.f90 sourcefile~io_open_fxdr.f90 io_open_fxdr.f90 sourcefile~io_open_fxdr.f90->sourcefile~module_fxdr.f90 sourcefile~io_write_encounter.f90 io_write_encounter.f90 sourcefile~io_write_encounter.f90->sourcefile~module_fxdr.f90 sourcefile~io_write_line.f90 io_write_line.f90 sourcefile~io_write_line.f90->sourcefile~module_fxdr.f90 sourcefile~io_getn.f90 io_getn.f90 sourcefile~io_getn.f90->sourcefile~module_fxdr.f90 sourcefile~io_read_encounter.f90 io_read_encounter.f90 sourcefile~io_read_encounter.f90->sourcefile~module_fxdr.f90 sourcefile~io_read_hdr.f90 io_read_hdr.f90 sourcefile~io_read_hdr.f90->sourcefile~module_fxdr.f90 sourcefile~io_init_pl.f90 io_init_pl.f90 sourcefile~io_init_pl.f90->sourcefile~module_fxdr.f90 sourcefile~io_write_frame.f90 io_write_frame.f90 sourcefile~io_write_frame.f90->sourcefile~module_fxdr.f90 sourcefile~io_read_line.f90 io_read_line.f90 sourcefile~io_read_line.f90->sourcefile~module_fxdr.f90 sourcefile~io_init_tp.f90 io_init_tp.f90 sourcefile~io_init_tp.f90->sourcefile~module_fxdr.f90 sourcefile~io_dump_tp.f90 io_dump_tp.f90 sourcefile~io_dump_tp.f90->sourcefile~module_fxdr.f90 sourcefile~io_dump_pl.f90 io_dump_pl.f90 sourcefile~io_dump_pl.f90->sourcefile~module_fxdr.f90 sourcefile~io_write_hdr.f90 io_write_hdr.f90 sourcefile~io_write_hdr.f90->sourcefile~module_fxdr.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules module_fxdr Source Code module_fxdr.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : module_fxdr !  Unit Type   : module !  Project     : SWIFTEST !  Package     : module !  Language    : Fortran 90/95 ! !  Description : Definition of interfaces of functions in the FXDR (Fortran eXternal Data Representation) library ! !  Input !    Arguments : N/A !    Terminal  : N/A !    File      : N/A ! !  Output !    Arguments : N/A !    Terminal  : N/A !    File      : N/A ! !  Invocation  : N/A ! !  Notes       : FXDR is a library, written and maintained by David W. Pierce, that enables calls to the XDR (eXternal Data !                Representation) routines from Fortran. ! !                Reference : http://meteora.ucsd.edu/~pierce/fxdr_home_page.html ! !********************************************************************************************************************************** MODULE module_fxdr IMPLICIT NONE INTERFACE FUNCTION initxdr ( filename , mode , returnonerror ) CHARACTER ( * ), INTENT ( IN ) :: filename CHARACTER ( 1 ), INTENT ( IN ) :: mode LOGICAL , INTENT ( IN ) :: returnonerror INTEGER :: initxdr END FUNCTION initxdr END INTERFACE INTERFACE FUNCTION ixdrclose ( ixdr ) INTEGER , INTENT ( IN ) :: ixdr INTEGER :: ixdrclose END FUNCTION ixdrclose END INTERFACE INTERFACE FUNCTION ixdrdmat ( ixdrs , nels , dval ) INTEGER , INTENT ( IN ) :: ixdrs , nels DOUBLE PRECISION , DIMENSION ( nels ), INTENT ( IN ) :: dval INTEGER :: ixdrdmat END FUNCTION ixdrdmat END INTERFACE INTERFACE FUNCTION ixdrdouble ( ixdrs , dval ) INTEGER , INTENT ( IN ) :: ixdrs DOUBLE PRECISION , INTENT ( IN ) :: dval INTEGER :: ixdrdouble END FUNCTION ixdrdouble END INTERFACE INTERFACE FUNCTION ixdrimat ( ixdrs , nels , ival ) INTEGER , INTENT ( IN ) :: ixdrs , nels INTEGER , DIMENSION ( nels ), INTENT ( IN ) :: ival INTEGER :: ixdrimat END FUNCTION ixdrimat END INTERFACE INTERFACE FUNCTION ixdrint ( ixdrs , ival ) INTEGER , INTENT ( IN ) :: ixdrs , ival INTEGER :: ixdrint END FUNCTION ixdrint END INTERFACE INTERFACE FUNCTION ixdrreal ( ixdrs , rval ) INTEGER , INTENT ( IN ) :: ixdrs REAL , INTENT ( IN ) :: rval INTEGER :: ixdrreal END FUNCTION ixdrreal END INTERFACE INTERFACE FUNCTION ixdrrmat ( ixdrs , nels , rval ) INTEGER , INTENT ( IN ) :: ixdrs , nels REAL , DIMENSION ( nels ), INTENT ( IN ) :: rval INTEGER :: ixdrrmat END FUNCTION ixdrrmat END INTERFACE END MODULE module_fxdr !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/module_fxdr.f90.html"},{"title":"module_nrutil.f90 – swiftest","text":"Unit Name   : module_nrutil\n  Unit Type   : module\n  Project     : SWIFTEST\n  Package     : module\n  Language    : Fortran 90/95 Description : Definition of data and utility functions taken from Numerical Recipes in Fortran 90 Input\n    Arguments : N/A\n    Terminal  : N/A\n    File      : N/A Output\n    Arguments : N/A\n    Terminal  : N/A\n    File      : N/A Invocation  : N/A Notes       : Reference: Press, W. H., Teukolsky, S. A., Vetterling, W. T. & Flannery B. P. 1996. Numerical Recipes in\n                           Fortran 90, The Art of Scientific Computing, 2nd Edition, Vol. 2 of Fortran Numerical Recipes,\n                           (Cambridge University Press). Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~module_nrutil.f90~~EfferentGraph sourcefile~module_nrutil.f90 module_nrutil.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~module_nrutil.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~module_nrutil.f90~~AfferentGraph sourcefile~module_nrutil.f90 module_nrutil.f90 sourcefile~util_index.f90 util_index.f90 sourcefile~util_index.f90->sourcefile~module_nrutil.f90 sourcefile~util_resize_pl.f90 util_resize_pl.f90 sourcefile~util_resize_pl.f90->sourcefile~module_nrutil.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules module_nrutil Source Code module_nrutil.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : module_nrutil !  Unit Type   : module !  Project     : SWIFTEST !  Package     : module !  Language    : Fortran 90/95 ! !  Description : Definition of data and utility functions taken from Numerical Recipes in Fortran 90 ! !  Input !    Arguments : N/A !    Terminal  : N/A !    File      : N/A ! !  Output !    Arguments : N/A !    Terminal  : N/A !    File      : N/A ! !  Invocation  : N/A ! !  Notes       : Reference: Press, W. H., Teukolsky, S. A., Vetterling, W. T. & Flannery B. P. 1996. Numerical Recipes in !                           Fortran 90, The Art of Scientific Computing, 2nd Edition, Vol. 2 of Fortran Numerical Recipes, !                           (Cambridge University Press). ! !********************************************************************************************************************************** MODULE module_nrutil USE swiftest IMPLICIT NONE INTEGER ( I4B ), PARAMETER :: NPAR_ARTH = 16 INTEGER ( I4B ), PARAMETER :: NPAR2_ARTH = 8 INTEGER ( I4B ), PARAMETER :: NPAR_CUMSUM = 16 INTERFACE arth MODULE PROCEDURE arth_d , arth_i END INTERFACE INTERFACE cumsum MODULE PROCEDURE cumsum_i END INTERFACE INTERFACE outerdiff MODULE PROCEDURE outerdiff_d , outerdiff_i END INTERFACE INTERFACE outerprod MODULE PROCEDURE outerprod_d END INTERFACE CONTAINS FUNCTION arth_d ( first , increment , n ) INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( DP ), INTENT ( IN ) :: first , increment REAL ( DP ), DIMENSION ( n ) :: arth_d INTEGER ( I4B ) :: k , k2 REAL ( DP ) :: temp IF ( n > 0 ) arth_d ( 1 ) = first IF ( n <= NPAR_ARTH ) THEN DO k = 2 , n arth_d ( k ) = arth_d ( k - 1 ) + increment END DO ELSE DO k = 2 , NPAR2_ARTH arth_d ( k ) = arth_d ( k - 1 ) + increment END DO temp = increment * NPAR2_ARTH k = NPAR2_ARTH DO IF ( k >= n ) EXIT k2 = k + k arth_d ( k + 1 : MIN ( k2 , n )) = temp + arth_d ( 1 : MIN ( k , n - k )) temp = temp + temp k = k2 END DO END IF RETURN END FUNCTION arth_d FUNCTION arth_i ( first , increment , n ) INTEGER ( I4B ), INTENT ( IN ) :: first , increment , n INTEGER ( I4B ), DIMENSION ( n ) :: arth_i INTEGER ( I4B ) :: k , k2 , temp IF ( n > 0 ) arth_i ( 1 ) = first IF ( n <= NPAR_ARTH ) THEN DO k = 2 , n arth_i ( k ) = arth_i ( k - 1 ) + increment END DO ELSE DO k = 2 , NPAR2_ARTH arth_i ( k ) = arth_i ( k - 1 ) + increment END DO temp = increment * NPAR2_ARTH k = NPAR2_ARTH DO IF ( k >= n ) EXIT k2 = k + k arth_i ( k + 1 : MIN ( k2 , n )) = temp + arth_i ( 1 : MIN ( k , n - k )) temp = temp + temp k = k2 END DO END IF RETURN END FUNCTION arth_i RECURSIVE FUNCTION cumsum_i ( arr , seed ) RESULT ( ans ) INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: arr INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: seed INTEGER ( I4B ), DIMENSION ( SIZE ( arr )) :: ans INTEGER ( I4B ) :: n , j , sd n = SIZE ( arr ) IF ( n == 0_I4B ) RETURN sd = 0_I4B IF ( PRESENT ( seed )) sd = seed ans ( 1 ) = arr ( 1 ) + sd IF ( n < NPAR_CUMSUM ) THEN DO j = 2 , n ans ( j ) = ans ( j - 1 ) + arr ( j ) END DO ELSE ans ( 2 : n : 2 ) = cumsum_i ( arr ( 2 : n : 2 ) + arr ( 1 : n - 1 : 2 ), sd ) ans ( 3 : n : 2 ) = ans ( 2 : n - 1 : 2 ) + arr ( 3 : n : 2 ) END IF RETURN END FUNCTION cumsum_i FUNCTION iminloc ( arr ) REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: arr INTEGER ( I4B ), DIMENSION ( 1 ) :: imin INTEGER ( I4B ) :: iminloc imin = MINLOC ( arr (:)) iminloc = imin ( 1 ) RETURN END FUNCTION iminloc FUNCTION outerdiff_d ( a , b ) REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( DP ), DIMENSION ( SIZE ( a ), SIZE ( b )) :: outerdiff_d outerdiff_d = SPREAD ( a , DIM = 2 , NCOPIES = SIZE ( b )) - SPREAD ( b , DIM = 1 , NCOPIES = SIZE ( a )) RETURN END FUNCTION outerdiff_d FUNCTION outerdiff_i ( a , b ) INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: a , b INTEGER ( I4B ), DIMENSION ( SIZE ( a ), SIZE ( b )) :: outerdiff_i outerdiff_i = SPREAD ( a , DIM = 2 , NCOPIES = SIZE ( b )) - SPREAD ( b , DIM = 1 , NCOPIES = SIZE ( a )) RETURN END FUNCTION outerdiff_i FUNCTION outerprod_d ( a , b ) REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( DP ), DIMENSION ( SIZE ( a ), SIZE ( b )) :: outerprod_d outerprod_d = SPREAD ( a , DIM = 2 , NCOPIES = SIZE ( b )) * SPREAD ( b , DIM = 1 , NCOPIES = SIZE ( a )) RETURN END FUNCTION outerprod_d FUNCTION upper_triangle ( j , k , extra ) INTEGER ( I4B ), INTENT ( IN ) :: j , k INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: extra LOGICAL ( LGT ), DIMENSION ( j , k ) :: upper_triangle INTEGER ( I4B ) :: n n = 0 IF ( PRESENT ( extra )) n = extra upper_triangle = ( outerdiff ( arth_i ( 1 , 1 , j ), arth_i ( 1 , 1 , k )) < n ) RETURN END FUNCTION upper_triangle END MODULE module_nrutil !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/module_nrutil.f90.html"},{"title":"module_swifter.f90 – swiftest","text":"Unit Name   : module_swifter\n  Unit Type   : module\n  Project     : SWIFTER\n  Package     : module\n  Language    : Fortran 90/95 Description : Definition of data and structures generic to all integrators Input\n    Arguments : N/A\n    Terminal  : N/A\n    File      : N/A Output\n    Arguments : N/A\n    Terminal  : N/A\n    File      : N/A Invocation  : N/A Notes       : Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~module_swifter.f90~~EfferentGraph sourcefile~module_swifter.f90 module_swifter.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~module_swifter.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~module_swifter.f90~~AfferentGraph sourcefile~module_swifter.f90 module_swifter.f90 sourcefile~symba_discard_merge_pl.f90 symba_discard_merge_pl.f90 sourcefile~symba_discard_merge_pl.f90->sourcefile~module_swifter.f90 sourcefile~symba_merge_tp.f90 symba_merge_tp.f90 sourcefile~symba_merge_tp.f90->sourcefile~module_swifter.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules module_swifter Source Code module_swifter.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : module_swifter !  Unit Type   : module !  Project     : SWIFTER !  Package     : module !  Language    : Fortran 90/95 ! !  Description : Definition of data and structures generic to all integrators ! !  Input !    Arguments : N/A !    Terminal  : N/A !    File      : N/A ! !  Output !    Arguments : N/A !    Terminal  : N/A !    File      : N/A ! !  Invocation  : N/A ! !  Notes       : ! !********************************************************************************************************************************** MODULE module_swifter USE swiftest IMPLICIT NONE ! Added by D. Minton TYPE swifter_ptr_arr TYPE ( swifter_pl ), POINTER :: thisP ! pointer to current swifter planet END TYPE swifter_ptr_arr TYPE swifter_ptr_arr_tp TYPE ( swifter_tp ), POINTER :: thisP ! pointer to current swifter planet END TYPE swifter_ptr_arr_tp !&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94; TYPE swifter_pl INTEGER ( I4B ) :: id ! external identifier INTEGER ( I4B ) :: status ! status REAL ( DP ) :: mass ! mass REAL ( DP ) :: radius ! radius REAL ( DP ) :: rhill ! Hill's sphere radius REAL ( DP ), DIMENSION ( NDIM ) :: xh ! heliocentric position REAL ( DP ), DIMENSION ( NDIM ) :: vh ! heliocentric velocity REAL ( DP ), DIMENSION ( NDIM ) :: xb ! barycentric position REAL ( DP ), DIMENSION ( NDIM ) :: vb ! barycentric velocity TYPE ( swifter_pl ), POINTER :: prevP ! pointer to previous planet TYPE ( swifter_pl ), POINTER :: nextP ! pointer to next planet ! Added by D. Minton ! Used for OpenMP parallelized loops TYPE ( swifter_ptr_arr ), DIMENSION (:), ALLOCATABLE :: swifter_plPA ! Array of pointers to Swifter planet structures !&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94; END TYPE swifter_pl TYPE swifter_tp INTEGER ( I4B ) :: id ! external identifier INTEGER ( I4B ) :: status ! status INTEGER ( I4B ) :: isperi ! perihelion passage flag REAL ( DP ) :: peri ! perihelion distance REAL ( DP ) :: atp ! semimajor axis following perihelion passage REAL ( DP ), DIMENSION ( NDIM ) :: xh ! heliocentric position REAL ( DP ), DIMENSION ( NDIM ) :: vh ! heliocentric velocity REAL ( DP ), DIMENSION ( NDIM ) :: xb ! barycentric position REAL ( DP ), DIMENSION ( NDIM ) :: vb ! barycentric velocity TYPE ( swifter_tp ), POINTER :: prevP ! pointer to previous test particle TYPE ( swifter_tp ), POINTER :: nextP ! pointer to next test particle ! Added by D. Minton ! Used for OpenMP parallelized loops TYPE ( swifter_ptr_arr_tp ), DIMENSION (:), ALLOCATABLE :: swifter_tpPA ! Array of pointers to Swifter planet structures !&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94; END TYPE swifter_tp END MODULE module_swifter !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/module_swifter.f90.html"},{"title":"module_symba.f90 – swiftest","text":"Unit Name   : module_symba\n  Unit Type   : module\n  Project     : SWIFTEST\n  Package     : module\n  Language    : Fortran 90/95 Description : Definition of data and structures specific to the Symplectic Massive Body Algorithm Input\n    Arguments : N/A\n    Terminal  : N/A\n    File      : N/A Output\n    Arguments : N/A\n    Terminal  : N/A\n    File      : N/A Invocation  : N/A Notes       : Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~module_symba.f90~~EfferentGraph sourcefile~module_symba.f90 module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~module_symba.f90~~AfferentGraph sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_discard_pl.f90 symba_discard_pl.f90 sourcefile~symba_discard_pl.f90->sourcefile~module_symba.f90 sourcefile~util_resize_pl.f90 util_resize_pl.f90 sourcefile~util_resize_pl.f90->sourcefile~module_symba.f90 sourcefile~module_swiftestalloc.f90 module_swiftestalloc.f90 sourcefile~util_resize_pl.f90->sourcefile~module_swiftestalloc.f90 sourcefile~symba_step_interp.f90 symba_step_interp.f90 sourcefile~symba_step_interp.f90->sourcefile~module_symba.f90 sourcefile~symba_helio_getacch_int.f90 symba_helio_getacch_int.f90 sourcefile~symba_helio_getacch_int.f90->sourcefile~module_symba.f90 sourcefile~io_discard_write_symba.f90 io_discard_write_symba.f90 sourcefile~io_discard_write_symba.f90->sourcefile~module_symba.f90 sourcefile~symba_casedisruption.f90 symba_casedisruption.f90 sourcefile~symba_casedisruption.f90->sourcefile~module_symba.f90 sourcefile~symba_rearray.f90 symba_rearray.f90 sourcefile~symba_rearray.f90->sourcefile~module_symba.f90 sourcefile~symba_rearray.f90->sourcefile~module_swiftestalloc.f90 sourcefile~helio_lindrift.f90 helio_lindrift.f90 sourcefile~helio_lindrift.f90->sourcefile~module_symba.f90 sourcefile~symba_discard_peri_pl.f90 symba_discard_peri_pl.f90 sourcefile~symba_discard_peri_pl.f90->sourcefile~module_symba.f90 sourcefile~swiftest_symba.f90 swiftest_symba.f90 sourcefile~swiftest_symba.f90->sourcefile~module_symba.f90 sourcefile~io.f90 io.f90 sourcefile~swiftest_symba.f90->sourcefile~io.f90 sourcefile~swiftest_symba.f90->sourcefile~module_swiftestalloc.f90 sourcefile~io_init_tp.f90 io_init_tp.f90 sourcefile~io_init_tp.f90->sourcefile~module_symba.f90 sourcefile~symba_user_getacch_tp.f90 symba_user_getacch_tp.f90 sourcefile~symba_user_getacch_tp.f90->sourcefile~module_symba.f90 sourcefile~helio_lindrift_tp.f90 helio_lindrift_tp.f90 sourcefile~helio_lindrift_tp.f90->sourcefile~module_symba.f90 sourcefile~symba_discard_tp.f90 symba_discard_tp.f90 sourcefile~symba_discard_tp.f90->sourcefile~module_symba.f90 sourcefile~symba_step_helio_pl.f90 symba_step_helio_pl.f90 sourcefile~symba_step_helio_pl.f90->sourcefile~module_symba.f90 sourcefile~symba_getacch_tp.f90 symba_getacch_tp.f90 sourcefile~symba_getacch_tp.f90->sourcefile~module_symba.f90 sourcefile~symba_helio_drift_tp.f90 symba_helio_drift_tp.f90 sourcefile~symba_helio_drift_tp.f90->sourcefile~module_symba.f90 sourcefile~symba_fragmentation.f90 symba_fragmentation.f90 sourcefile~symba_fragmentation.f90->sourcefile~module_symba.f90 sourcefile~symba_helio_getacch.f90 symba_helio_getacch.f90 sourcefile~symba_helio_getacch.f90->sourcefile~module_symba.f90 sourcefile~symba_merge_tp.f90 symba_merge_tp.f90 sourcefile~symba_merge_tp.f90->sourcefile~module_symba.f90 sourcefile~python_io_write_frame_tp.f90 python_io_write_frame_tp.f90 sourcefile~python_io_write_frame_tp.f90->sourcefile~module_symba.f90 sourcefile~symba_helio_drift.f90 symba_helio_drift.f90 sourcefile~symba_helio_drift.f90->sourcefile~module_symba.f90 sourcefile~symba_casehitandrun.f90 symba_casehitandrun.f90 sourcefile~symba_casehitandrun.f90->sourcefile~module_symba.f90 sourcefile~io_init_pl.f90 io_init_pl.f90 sourcefile~io_init_pl.f90->sourcefile~module_symba.f90 sourcefile~symba_step_helio.f90 symba_step_helio.f90 sourcefile~symba_step_helio.f90->sourcefile~module_symba.f90 sourcefile~io_read_pl_in.f90 io_read_pl_in.f90 sourcefile~io_read_pl_in.f90->sourcefile~module_symba.f90 sourcefile~io_read_pl_in.f90->sourcefile~io.f90 sourcefile~io.f90->sourcefile~module_symba.f90 sourcefile~symba_casemerge.f90 symba_casemerge.f90 sourcefile~symba_casemerge.f90->sourcefile~module_symba.f90 sourcefile~symba_caseresolve.f90 symba_caseresolve.f90 sourcefile~symba_caseresolve.f90->sourcefile~module_symba.f90 sourcefile~symba_chk.f90 symba_chk.f90 sourcefile~symba_chk.f90->sourcefile~module_symba.f90 sourcefile~symba_user_getacch.f90 symba_user_getacch.f90 sourcefile~symba_user_getacch.f90->sourcefile~module_symba.f90 sourcefile~symba_reorder_pl.f90 symba_reorder_pl.f90 sourcefile~symba_reorder_pl.f90->sourcefile~module_symba.f90 sourcefile~symba_getacch.f90 symba_getacch.f90 sourcefile~symba_getacch.f90->sourcefile~module_symba.f90 sourcefile~symba_merge_pl.f90 symba_merge_pl.f90 sourcefile~symba_merge_pl.f90->sourcefile~module_symba.f90 sourcefile~symba_step_recur.f90 symba_step_recur.f90 sourcefile~symba_step_recur.f90->sourcefile~module_symba.f90 sourcefile~coord_vh2vb.f90 coord_vh2vb.f90 sourcefile~coord_vh2vb.f90->sourcefile~module_symba.f90 sourcefile~coord_vb2vh_tp.f90 coord_vb2vh_tp.f90 sourcefile~coord_vb2vh_tp.f90->sourcefile~module_symba.f90 sourcefile~python_io_write_frame_pl.f90 python_io_write_frame_pl.f90 sourcefile~python_io_write_frame_pl.f90->sourcefile~module_symba.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~module_symba.f90 sourcefile~symba_discard_merge_pl.f90 symba_discard_merge_pl.f90 sourcefile~symba_discard_merge_pl.f90->sourcefile~module_symba.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~module_symba.f90 sourcefile~module_swiftestalloc.f90->sourcefile~module_symba.f90 sourcefile~symba_casesupercatastrophic.f90 symba_casesupercatastrophic.f90 sourcefile~symba_casesupercatastrophic.f90->sourcefile~module_symba.f90 sourcefile~symba_peri.f90 symba_peri.f90 sourcefile~symba_peri.f90->sourcefile~module_symba.f90 sourcefile~tool_encounter_read.f90 tool_encounter_read.f90 sourcefile~tool_encounter_read.f90->sourcefile~io.f90 sourcefile~io_read_param_in.f90 io_read_param_in.f90 sourcefile~io_read_param_in.f90->sourcefile~io.f90 sourcefile~io_get_token.f90 io_get_token.f90 sourcefile~io_get_token.f90->sourcefile~io.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules module_symba Source Code module_symba.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : module_symba !  Unit Type   : module !  Project     : SWIFTEST !  Package     : module !  Language    : Fortran 90/95 ! !  Description : Definition of data and structures specific to the Symplectic Massive Body Algorithm ! !  Input !    Arguments : N/A !    Terminal  : N/A !    File      : N/A ! !  Output !    Arguments : N/A !    Terminal  : N/A !    File      : N/A ! !  Invocation  : N/A ! !  Notes       : ! !********************************************************************************************************************************** MODULE module_symba USE swiftest USE module_helio IMPLICIT NONE INTEGER ( I4B ), PARAMETER :: NENMAX = 32767 INTEGER ( I4B ), PARAMETER :: NTENC = 3 REAL ( DP ), PARAMETER :: RHSCALE = 6.5_DP REAL ( DP ), PARAMETER :: RSHELL = 0.48075_DP type symba_pl logical ( LGT ), dimension (:), allocatable :: lmerged ! flag indicating whether body has merged with another this time step integer ( I4B ), dimension (:), allocatable :: nplenc ! number of encounters with other planets this time step integer ( I4B ), dimension (:), allocatable :: ntpenc ! number of encounters with test particles this time step integer ( I4B ), dimension (:), allocatable :: levelg ! level at which this body should be moved integer ( I4B ), dimension (:), allocatable :: levelm ! deepest encounter level achieved this time step integer ( I4B ), dimension (:), allocatable :: nchild ! number of children in merger list integer ( I4B ), dimension (:), allocatable :: isperi ! perihelion passage flag real ( DP ), dimension (:), allocatable :: peri ! perihelion distance real ( DP ), dimension (:), allocatable :: atp ! semimajor axis following perihelion passage type ( helio_pl ) :: helio ! HELIO planet structure integer ( I4B ), dimension (:), allocatable :: index_parent ! position of the parent of id integer ( I4B ), dimension (:,:), allocatable :: index_child ! position of the children of id end type symba_pl type symba_tp integer ( I4B ), dimension (:), allocatable :: nplenc ! number of encounters with planets this time step integer ( I4B ), dimension (:), allocatable :: levelg ! level at which this particle should be moved integer ( I4B ), dimension (:), allocatable :: levelm ! deepest encounter level achieved this time step type ( helio_tp ) :: helio ! HELIO test particle structure end type symba_tp type symba_plplenc logical ( LGT ), dimension (:), allocatable :: lvdotr ! relative vdotr flag integer ( I4B ), dimension (:), allocatable :: status ! status of the interaction integer ( I4B ), dimension (:), allocatable :: level ! encounter recursion level integer ( I4B ), dimension (:), allocatable :: index1 ! position of the first planet in encounter integer ( I4B ), dimension (:), allocatable :: index2 ! position of the second planet in encounter integer ( I4B ), dimension (:), allocatable :: enc_child ! the child of the encounter integer ( I4B ), dimension (:), allocatable :: enc_parent ! the child of the encounter end type symba_plplenc type symba_pltpenc logical ( LGT ), dimension (:), allocatable :: lvdotr ! relative vdotr flag integer ( I4B ), dimension (:), allocatable :: status ! status of the interaction integer ( I4B ), dimension (:), allocatable :: level ! encounter recursion level integer ( I4B ), dimension (:), allocatable :: indexpl ! position of the planet in encounter integer ( I4B ), dimension (:), allocatable :: indextp ! position of the test particle in encounter end type symba_pltpenc type symba_merger integer ( I4B ), dimension (:), allocatable :: name ! external identifier integer ( I4B ), dimension (:), allocatable :: index_ps ! position of the particle integer ( I4B ), dimension (:), allocatable :: status ! status integer ( I4B ), dimension (:), allocatable :: ncomp ! number of component bodies in this one during this merger real ( DP ), dimension (:,:), allocatable :: xh ! heliocentric position real ( DP ), dimension (:,:), allocatable :: vh ! heliocentric velocity real ( DP ), dimension (:), allocatable :: mass real ( DP ), dimension (:), allocatable :: radius end type symba_merger END MODULE module_symba !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/module_symba.f90.html"},{"title":"module_helio.f90 – swiftest","text":"Unit Name   : module_helio\n  Unit Type   : module\n  Project     : SWIFTEST\n  Package     : module\n  Language    : Fortran 90/95 Description : Definition of data and structures specific to the Democratic Heliocentric Method Input\n    Arguments : N/A\n    Terminal  : N/A\n    File      : N/A Output\n    Arguments : N/A\n    Terminal  : N/A\n    File      : N/A Invocation  : N/A Notes       : Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~module_helio.f90~~EfferentGraph sourcefile~module_helio.f90 module_helio.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~module_helio.f90~~AfferentGraph sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_discard_pl.f90 symba_discard_pl.f90 sourcefile~symba_discard_pl.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_discard_pl.f90->sourcefile~module_symba.f90 sourcefile~util_resize_pl.f90 util_resize_pl.f90 sourcefile~util_resize_pl.f90->sourcefile~module_helio.f90 sourcefile~util_resize_pl.f90->sourcefile~module_symba.f90 sourcefile~module_swiftestalloc.f90 module_swiftestalloc.f90 sourcefile~util_resize_pl.f90->sourcefile~module_swiftestalloc.f90 sourcefile~symba_step_interp.f90 symba_step_interp.f90 sourcefile~symba_step_interp.f90->sourcefile~module_helio.f90 sourcefile~symba_step_interp.f90->sourcefile~module_symba.f90 sourcefile~symba_helio_getacch_int.f90 symba_helio_getacch_int.f90 sourcefile~symba_helio_getacch_int.f90->sourcefile~module_helio.f90 sourcefile~symba_helio_getacch_int.f90->sourcefile~module_symba.f90 sourcefile~symba_casedisruption.f90 symba_casedisruption.f90 sourcefile~symba_casedisruption.f90->sourcefile~module_helio.f90 sourcefile~symba_casedisruption.f90->sourcefile~module_symba.f90 sourcefile~symba_rearray.f90 symba_rearray.f90 sourcefile~symba_rearray.f90->sourcefile~module_helio.f90 sourcefile~symba_rearray.f90->sourcefile~module_symba.f90 sourcefile~symba_rearray.f90->sourcefile~module_swiftestalloc.f90 sourcefile~helio_getacch.f90 helio_getacch.f90 sourcefile~helio_getacch.f90->sourcefile~module_helio.f90 sourcefile~helio_getacch_int.f90 helio_getacch_int.f90 sourcefile~helio_getacch_int.f90->sourcefile~module_helio.f90 sourcefile~symba_discard_peri_pl.f90 symba_discard_peri_pl.f90 sourcefile~symba_discard_peri_pl.f90->sourcefile~module_helio.f90 sourcefile~symba_discard_peri_pl.f90->sourcefile~module_symba.f90 sourcefile~helio_user_getacch_tp.f90 helio_user_getacch_tp.f90 sourcefile~helio_user_getacch_tp.f90->sourcefile~module_helio.f90 sourcefile~io_init_tp.f90 io_init_tp.f90 sourcefile~io_init_tp.f90->sourcefile~module_helio.f90 sourcefile~io_init_tp.f90->sourcefile~module_symba.f90 sourcefile~symba_discard_tp.f90 symba_discard_tp.f90 sourcefile~symba_discard_tp.f90->sourcefile~module_helio.f90 sourcefile~symba_discard_tp.f90->sourcefile~module_symba.f90 sourcefile~symba_step_helio_pl.f90 symba_step_helio_pl.f90 sourcefile~symba_step_helio_pl.f90->sourcefile~module_helio.f90 sourcefile~symba_step_helio_pl.f90->sourcefile~module_symba.f90 sourcefile~symba_getacch_tp.f90 symba_getacch_tp.f90 sourcefile~symba_getacch_tp.f90->sourcefile~module_helio.f90 sourcefile~symba_getacch_tp.f90->sourcefile~module_symba.f90 sourcefile~symba_helio_drift_tp.f90 symba_helio_drift_tp.f90 sourcefile~symba_helio_drift_tp.f90->sourcefile~module_helio.f90 sourcefile~symba_helio_drift_tp.f90->sourcefile~module_symba.f90 sourcefile~helio_kickvb.f90 helio_kickvb.f90 sourcefile~helio_kickvb.f90->sourcefile~module_helio.f90 sourcefile~symba_fragmentation.f90 symba_fragmentation.f90 sourcefile~symba_fragmentation.f90->sourcefile~module_helio.f90 sourcefile~symba_fragmentation.f90->sourcefile~module_symba.f90 sourcefile~helio_getacch_tp.f90 helio_getacch_tp.f90 sourcefile~helio_getacch_tp.f90->sourcefile~module_helio.f90 sourcefile~symba_helio_getacch.f90 symba_helio_getacch.f90 sourcefile~symba_helio_getacch.f90->sourcefile~module_helio.f90 sourcefile~symba_helio_getacch.f90->sourcefile~module_symba.f90 sourcefile~symba_merge_tp.f90 symba_merge_tp.f90 sourcefile~symba_merge_tp.f90->sourcefile~module_helio.f90 sourcefile~symba_merge_tp.f90->sourcefile~module_symba.f90 sourcefile~helio_step_tp.f90 helio_step_tp.f90 sourcefile~helio_step_tp.f90->sourcefile~module_helio.f90 sourcefile~helio_user_getacch.f90 helio_user_getacch.f90 sourcefile~helio_user_getacch.f90->sourcefile~module_helio.f90 sourcefile~helio_kickvb_tp.f90 helio_kickvb_tp.f90 sourcefile~helio_kickvb_tp.f90->sourcefile~module_helio.f90 sourcefile~python_io_write_frame_tp.f90 python_io_write_frame_tp.f90 sourcefile~python_io_write_frame_tp.f90->sourcefile~module_helio.f90 sourcefile~python_io_write_frame_tp.f90->sourcefile~module_symba.f90 sourcefile~symba_helio_drift.f90 symba_helio_drift.f90 sourcefile~symba_helio_drift.f90->sourcefile~module_helio.f90 sourcefile~symba_helio_drift.f90->sourcefile~module_symba.f90 sourcefile~symba_casehitandrun.f90 symba_casehitandrun.f90 sourcefile~symba_casehitandrun.f90->sourcefile~module_helio.f90 sourcefile~symba_casehitandrun.f90->sourcefile~module_symba.f90 sourcefile~io_init_pl.f90 io_init_pl.f90 sourcefile~io_init_pl.f90->sourcefile~module_helio.f90 sourcefile~io_init_pl.f90->sourcefile~module_symba.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~helio_getacch_int_tp.f90 helio_getacch_int_tp.f90 sourcefile~helio_getacch_int_tp.f90->sourcefile~module_helio.f90 sourcefile~symba_step_helio.f90 symba_step_helio.f90 sourcefile~symba_step_helio.f90->sourcefile~module_helio.f90 sourcefile~symba_step_helio.f90->sourcefile~module_symba.f90 sourcefile~helio_step_pl.f90 helio_step_pl.f90 sourcefile~helio_step_pl.f90->sourcefile~module_helio.f90 sourcefile~symba_casemerge.f90 symba_casemerge.f90 sourcefile~symba_casemerge.f90->sourcefile~module_helio.f90 sourcefile~symba_casemerge.f90->sourcefile~module_symba.f90 sourcefile~symba_caseresolve.f90 symba_caseresolve.f90 sourcefile~symba_caseresolve.f90->sourcefile~module_helio.f90 sourcefile~symba_caseresolve.f90->sourcefile~module_symba.f90 sourcefile~symba_chk.f90 symba_chk.f90 sourcefile~symba_chk.f90->sourcefile~module_helio.f90 sourcefile~symba_chk.f90->sourcefile~module_symba.f90 sourcefile~symba_reorder_pl.f90 symba_reorder_pl.f90 sourcefile~symba_reorder_pl.f90->sourcefile~module_helio.f90 sourcefile~symba_reorder_pl.f90->sourcefile~module_symba.f90 sourcefile~symba_getacch.f90 symba_getacch.f90 sourcefile~symba_getacch.f90->sourcefile~module_helio.f90 sourcefile~symba_getacch.f90->sourcefile~module_symba.f90 sourcefile~symba_merge_pl.f90 symba_merge_pl.f90 sourcefile~symba_merge_pl.f90->sourcefile~module_helio.f90 sourcefile~symba_merge_pl.f90->sourcefile~module_symba.f90 sourcefile~symba_step_recur.f90 symba_step_recur.f90 sourcefile~symba_step_recur.f90->sourcefile~module_helio.f90 sourcefile~symba_step_recur.f90->sourcefile~module_symba.f90 sourcefile~python_io_write_frame_pl.f90 python_io_write_frame_pl.f90 sourcefile~python_io_write_frame_pl.f90->sourcefile~module_helio.f90 sourcefile~python_io_write_frame_pl.f90->sourcefile~module_symba.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~module_helio.f90 sourcefile~symba_kick.f90->sourcefile~module_symba.f90 sourcefile~symba_discard_merge_pl.f90 symba_discard_merge_pl.f90 sourcefile~symba_discard_merge_pl.f90->sourcefile~module_helio.f90 sourcefile~symba_discard_merge_pl.f90->sourcefile~module_symba.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~module_helio.f90 sourcefile~symba_step.f90->sourcefile~module_symba.f90 sourcefile~module_swiftestalloc.f90->sourcefile~module_helio.f90 sourcefile~module_swiftestalloc.f90->sourcefile~module_symba.f90 sourcefile~symba_casesupercatastrophic.f90 symba_casesupercatastrophic.f90 sourcefile~symba_casesupercatastrophic.f90->sourcefile~module_helio.f90 sourcefile~symba_casesupercatastrophic.f90->sourcefile~module_symba.f90 sourcefile~symba_peri.f90 symba_peri.f90 sourcefile~symba_peri.f90->sourcefile~module_helio.f90 sourcefile~symba_peri.f90->sourcefile~module_symba.f90 sourcefile~coord_vh2vb.f90 coord_vh2vb.f90 sourcefile~coord_vh2vb.f90->sourcefile~module_symba.f90 sourcefile~io_discard_write_symba.f90 io_discard_write_symba.f90 sourcefile~io_discard_write_symba.f90->sourcefile~module_symba.f90 sourcefile~coord_vb2vh_tp.f90 coord_vb2vh_tp.f90 sourcefile~coord_vb2vh_tp.f90->sourcefile~module_symba.f90 sourcefile~helio_lindrift.f90 helio_lindrift.f90 sourcefile~helio_lindrift.f90->sourcefile~module_symba.f90 sourcefile~io_read_pl_in.f90 io_read_pl_in.f90 sourcefile~io_read_pl_in.f90->sourcefile~module_symba.f90 sourcefile~io.f90 io.f90 sourcefile~io_read_pl_in.f90->sourcefile~io.f90 sourcefile~io.f90->sourcefile~module_symba.f90 sourcefile~swiftest_symba.f90 swiftest_symba.f90 sourcefile~swiftest_symba.f90->sourcefile~module_symba.f90 sourcefile~swiftest_symba.f90->sourcefile~module_swiftestalloc.f90 sourcefile~swiftest_symba.f90->sourcefile~io.f90 sourcefile~symba_user_getacch.f90 symba_user_getacch.f90 sourcefile~symba_user_getacch.f90->sourcefile~module_symba.f90 sourcefile~symba_user_getacch_tp.f90 symba_user_getacch_tp.f90 sourcefile~symba_user_getacch_tp.f90->sourcefile~module_symba.f90 sourcefile~helio_lindrift_tp.f90 helio_lindrift_tp.f90 sourcefile~helio_lindrift_tp.f90->sourcefile~module_symba.f90 sourcefile~tool_encounter_read.f90 tool_encounter_read.f90 sourcefile~tool_encounter_read.f90->sourcefile~io.f90 sourcefile~io_read_param_in.f90 io_read_param_in.f90 sourcefile~io_read_param_in.f90->sourcefile~io.f90 sourcefile~io_get_token.f90 io_get_token.f90 sourcefile~io_get_token.f90->sourcefile~io.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules module_helio Source Code module_helio.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : module_helio !  Unit Type   : module !  Project     : SWIFTEST !  Package     : module !  Language    : Fortran 90/95 ! !  Description : Definition of data and structures specific to the Democratic Heliocentric Method ! !  Input !    Arguments : N/A !    Terminal  : N/A !    File      : N/A ! !  Output !    Arguments : N/A !    Terminal  : N/A !    File      : N/A ! !  Invocation  : N/A ! !  Notes       : ! !********************************************************************************************************************************** MODULE module_helio USE swiftest USE module_swiftest IMPLICIT NONE type helio_pl real ( DP ), dimension (:,:), allocatable :: ah ! total heliocentric acceleration real ( DP ), dimension (:,:), allocatable :: ahi ! heliocentric acceleration due to interactions type ( swiftest_pl ) :: swiftest ! swifter planet structure end type helio_pl type helio_tp real ( DP ), dimension (:,:), allocatable :: ah ! total heliocentric acceleration real ( DP ), dimension (:,:), allocatable :: ahi ! heliocentric acceleration due to interactions type ( swiftest_tp ) :: swiftest ! swifter test particle structure end type helio_tp END MODULE module_helio !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/module_helio.f90.html"},{"title":"python_io_write_frame_pl.f90 – swiftest","text":"Unit Name   : python_io_write_frame_pl\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : io\n  Language    : Fortran 90/95 Description : Write a frame of Swiftest output to a binary file Input\n    Arguments : t              : time\n                Symba_plA      : Python readable data structure\n                python_outfile : output file name\n                out_stat     : open status for output binary file (either \"APPEND\" or \"NEW\")\n    Terminal  : none\n    File      : none Output\n    Arguments : none\n    Terminal  : error message\n    File      : none Invocation  : CALL python_io_write_frame_pl(t, ring) Notes       : Author(s)   : David A. Minton, Carlisle Wishard, Jennifer Pouplin This file depends on sourcefile~~python_io_write_frame_pl.f90~~EfferentGraph sourcefile~python_io_write_frame_pl.f90 python_io_write_frame_pl.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~python_io_write_frame_pl.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~python_io_write_frame_pl.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~python_io_write_frame_pl.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~python_io_write_frame_pl.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~python_io_write_frame_pl.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines python_io_write_frame_pl Source Code python_io_write_frame_pl.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : python_io_write_frame_pl !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : io !  Language    : Fortran 90/95 ! !  Description : Write a frame of Swiftest output to a binary file ! !  Input !    Arguments : t              : time !                Symba_plA      : Python readable data structure !                python_outfile : output file name !                out_stat     : open status for output binary file (either \"APPEND\" or \"NEW\") !    Terminal  : none !    File      : none ! !  Output !    Arguments : none !    Terminal  : error message !    File      : none ! !  Invocation  : CALL python_io_write_frame_pl(t, ring) ! !  Notes       : ! !********************************************************************************************************************************** !********************************************************************************************************************************** !  Author(s)   : David A. Minton, Carlisle Wishard, Jennifer Pouplin !********************************************************************************************************************************** subroutine python_io_write_frame_pl ( t , symba_plA , npl , out_stat ) ! modules use swiftest use module_swiftest use module_helio use module_symba use module_interfaces , except_this_one => python_io_write_frame_pl implicit none ! arguments real ( DP ), intent ( in ) :: t type ( symba_pl ), intent ( in ) :: symba_plA integer , intent ( in ) :: npl character ( * ), intent ( in ) :: out_stat ! internals logical ( LGT ), save :: lfirst = . true . integer ( I4B ), parameter :: lun = 88 integer ( I4B ) :: ierr integer ( I4B ), save :: iu = lun !real(DP),dimension(count(seeds%active)) :: aseeds, Gmseeds ! executable code if ( lfirst ) then if ( out_stat == \"APPEND\" ) then call io_open ( iu , pl_outfile , out_stat , \"unformatted\" , ierr ) else if ( out_stat == \"NEW\" ) then call io_open ( iu , pl_outfile , out_stat , \"unformatted\" , ierr ) if ( ierr /= 0 ) then write ( * , * ) \"SWIFTEST error:\" write ( * , * ) \"   Binary output file already exists\" call util_exit ( FAILURE ) end if else call io_open ( iu , pl_outfile , \"REPLACE\" , \"UNFORMATTED\" , ierr ) end if if ( ierr /= 0 ) then write ( * , * ) \"SWIFTEST error:\" write ( * , * ) \"   Unable to open binary output file\" call util_exit ( FAILURE ) end if lfirst = . false . else call io_open ( iu , pl_outfile , \"APPEND\" , \"UNFORMATTED\" , ierr ) if ( ierr /= 0 ) then write ( * , * ) \"SWIFTEST error:\" write ( * , * ) \"   Unable to open binary output file for append\" call util_exit ( failure ) end if end if write ( iu , iostat = ierr ) t write ( iu , iostat = ierr ) npl write ( iu , iostat = ierr ) symba_plA % helio % swiftest % name ( 1 : npl ) write ( iu , iostat = ierr ) symba_plA % helio % swiftest % status ( 1 : npl ) write ( iu , iostat = ierr ) symba_plA % helio % swiftest % mass ( 1 : npl ) write ( iu , iostat = ierr ) symba_plA % helio % swiftest % radius ( 1 : npl ) write ( iu , iostat = ierr ) symba_plA % helio % swiftest % rhill ( 1 : npl ) write ( iu , iostat = ierr ) symba_plA % helio % swiftest % xh ( 1 , 1 : npl ) write ( iu , iostat = ierr ) symba_plA % helio % swiftest % xh ( 2 , 1 : npl ) write ( iu , iostat = ierr ) symba_plA % helio % swiftest % xh ( 3 , 1 : npl ) write ( iu , iostat = ierr ) symba_plA % helio % swiftest % vh ( 1 , 1 : npl ) write ( iu , iostat = ierr ) symba_plA % helio % swiftest % vh ( 2 , 1 : npl ) write ( iu , iostat = ierr ) symba_plA % helio % swiftest % vh ( 3 , 1 : npl ) write ( iu , iostat = ierr ) symba_plA % helio % swiftest % xb ( 1 , 1 : npl ) write ( iu , iostat = ierr ) symba_plA % helio % swiftest % xb ( 2 , 1 : npl ) write ( iu , iostat = ierr ) symba_plA % helio % swiftest % xb ( 3 , 1 : npl ) write ( iu , iostat = ierr ) symba_plA % helio % swiftest % vb ( 1 , 1 : npl ) write ( iu , iostat = ierr ) symba_plA % helio % swiftest % vb ( 2 , 1 : npl ) write ( iu , iostat = ierr ) symba_plA % helio % swiftest % vb ( 3 , 1 : npl ) close ( unit = iu , iostat = ierr ) if ( ierr /= 0 ) then write ( * , * ) \"SWIFTEST error:\" write ( * , * ) \"   Unable to close binary output file\" call util_exit ( FAILURE ) end if return end subroutine python_io_write_frame_pl","tags":"","loc":"sourcefile/python_io_write_frame_pl.f90.html"},{"title":"io_read_line.f90 – swiftest","text":"Unit Name   : io_read_line\n  Unit Type   : function\n  Project     : Swifter\n  Package     : io\n  Language    : Fortran 90/95 Description : Read a line (record) from input binary file Input\n    Arguments : iu       : unit number associated with input binary file\n                out_type : format of input binary file\n    Terminal  : none\n    File      : id                  : planet or test particle identifier\n                smass (or MASS)     : optional mass (omitted for massless test particle)\n                sradius (or RADIUS) : optional radius (omitted for massless test particle)\n                svec (or dvec)      : 6-vector of orbital elements or position and velocity components Output\n    Arguments : id       : planet or test particle identifier\n                d1       : first quantity  (semimajor axis (pericentric distance for a parabola) or heliocentric x )\n                d2       : second quantity (eccentricity                                         or heliocentric y )\n                d3       : third quantity  (inclination                                          or heliocentric z )\n                d4       : fourth quantity (longitude of the ascending node                      or heliocentric vx)\n                d5       : fifth quantity  (argument of pericenter                               or heliocentric vy)\n                d6       : sixth quantity  (mean anomaly                                         or heliocentric vz)\n                MASS     : optional mass (omitted for massless test particle)\n                RADIUS   : optional radius (omitted for massless test particle)\n    Terminal  : none\n    File      : none Invocation  : istat = io_read_line(iu, id, d1, d2, d3, d4, d5, d6, out_type, MASS, RADIUS) Notes       : Adapted from Hal Levison's Swift function io_read_line Function returns read error status (0 = OK, nonzero = ERROR) Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~io_read_line.f90~~EfferentGraph sourcefile~io_read_line.f90 io_read_line.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~io_read_line.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io_read_line.f90->sourcefile~swiftest.f90 sourcefile~module_fxdr.f90 module_fxdr.f90 sourcefile~io_read_line.f90->sourcefile~module_fxdr.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Functions io_read_line Source Code io_read_line.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : io_read_line !  Unit Type   : function !  Project     : Swifter !  Package     : io !  Language    : Fortran 90/95 ! !  Description : Read a line (record) from input binary file ! !  Input !    Arguments : iu       : unit number associated with input binary file !                out_type : format of input binary file !    Terminal  : none !    File      : id                  : planet or test particle identifier !                smass (or MASS)     : optional mass (omitted for massless test particle) !                sradius (or RADIUS) : optional radius (omitted for massless test particle) !                svec (or dvec)      : 6-vector of orbital elements or position and velocity components ! !  Output !    Arguments : id       : planet or test particle identifier !                d1       : first quantity  (semimajor axis (pericentric distance for a parabola) or heliocentric x ) !                d2       : second quantity (eccentricity                                         or heliocentric y ) !                d3       : third quantity  (inclination                                          or heliocentric z ) !                d4       : fourth quantity (longitude of the ascending node                      or heliocentric vx) !                d5       : fifth quantity  (argument of pericenter                               or heliocentric vy) !                d6       : sixth quantity  (mean anomaly                                         or heliocentric vz) !                MASS     : optional mass (omitted for massless test particle) !                RADIUS   : optional radius (omitted for massless test particle) !    Terminal  : none !    File      : none ! !  Invocation  : istat = io_read_line(iu, id, d1, d2, d3, d4, d5, d6, out_type, MASS, RADIUS) ! !  Notes       : Adapted from Hal Levison's Swift function io_read_line ! !                Function returns read error status (0 = OK, nonzero = ERROR) ! !********************************************************************************************************************************** FUNCTION io_read_line ( iu , name , d1 , d2 , d3 , d4 , d5 , d6 , out_type , MASS , RADIUS ) ! Modules USE swiftest USE module_fxdr USE module_interfaces , EXCEPT_THIS_ONE => io_read_line IMPLICIT NONE ! Arguments INTEGER ( I4B ) :: io_read_line INTEGER ( I4B ), INTENT ( IN ) :: iu INTEGER ( I4B ), INTENT ( OUT ) :: name REAL ( DP ), INTENT ( OUT ) :: d1 , d2 , d3 , d4 , d5 , d6 REAL ( DP ), OPTIONAL , INTENT ( OUT ) :: MASS , RADIUS CHARACTER ( * ), INTENT ( IN ) :: out_type ! Internals LOGICAL ( LGT ) :: lmass , lradius INTEGER ( I4B ) :: ierr REAL ( SP ) :: smass , sradius REAL ( SP ), DIMENSION ( 6 ) :: svec REAL ( DP ), DIMENSION ( 6 ) :: dvec ! Executable code lmass = PRESENT ( MASS ) IF ( lmass ) THEN lradius = PRESENT ( RADIUS ) IF (. NOT . lradius ) THEN WRITE ( * , * ) \"SWIFTER Error:\" WRITE ( * , * ) \"   Subroutine io_read_line called with optional MASS but without optional RADIUS\" CALL util_exit ( FAILURE ) END IF END IF SELECT CASE ( out_type ) CASE ( REAL4_TYPE ) IF ( lmass ) THEN READ ( iu , IOSTAT = ierr ) name , smass , sradius , svec ELSE READ ( iu , IOSTAT = ierr ) name , svec END IF io_read_line = ierr IF ( ierr /= 0 ) RETURN IF ( lmass ) MASS = smass d1 = svec ( 1 ); d2 = svec ( 2 ); d3 = svec ( 3 ); d4 = svec ( 4 ); d5 = svec ( 5 ); d6 = svec ( 6 ) CASE ( REAL8_TYPE ) IF ( lmass ) THEN READ ( iu , IOSTAT = ierr ) name , MASS , RADIUS , dvec ELSE READ ( iu , IOSTAT = ierr ) name , dvec END IF io_read_line = ierr IF ( ierr /= 0 ) RETURN d1 = dvec ( 1 ); d2 = dvec ( 2 ); d3 = dvec ( 3 ); d4 = dvec ( 4 ); d5 = dvec ( 5 ); d6 = dvec ( 6 ) CASE ( XDR4_TYPE ) ierr = ixdrint ( iu , name ) io_read_line = ierr IF ( ierr /= 0 ) RETURN IF ( lmass ) THEN ierr = ixdrreal ( iu , smass ) io_read_line = ierr IF ( ierr /= 0 ) RETURN MASS = smass ierr = ixdrreal ( iu , sradius ) io_read_line = ierr IF ( ierr /= 0 ) RETURN RADIUS = sradius END IF ierr = ixdrrmat ( iu , 6 , svec ) io_read_line = ierr IF ( ierr /= 0 ) RETURN d1 = svec ( 1 ); d2 = svec ( 2 ); d3 = svec ( 3 ); d4 = svec ( 4 ); d5 = svec ( 5 ); d6 = svec ( 6 ) CASE ( XDR8_TYPE ) ierr = ixdrint ( iu , name ) io_read_line = ierr IF ( ierr /= 0 ) RETURN IF ( lmass ) THEN ierr = ixdrdouble ( iu , MASS ) io_read_line = ierr IF ( ierr /= 0 ) RETURN ierr = ixdrdouble ( iu , RADIUS ) io_read_line = ierr IF ( ierr /= 0 ) RETURN END IF ierr = ixdrdmat ( iu , 6 , dvec ) io_read_line = ierr IF ( ierr /= 0 ) RETURN d1 = dvec ( 1 ); d2 = dvec ( 2 ); d3 = dvec ( 3 ); d4 = dvec ( 4 ); d5 = dvec ( 5 ); d6 = dvec ( 6 ) END SELECT RETURN END FUNCTION io_read_line !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/io_read_line.f90.html"},{"title":"io_init_pl.f90 – swiftest","text":"Unit Name   : io_init_pl\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : io\n  Language    : Fortran 90/95 Description : Read in planet data Input\n    Arguments : inplfile       : name of input file for planets\n                in_type        : format of input data file\n                lclose         : logical flag indicating whether planets' physical radii are present in input file\n                lrhill_present : logical flag indicating whether planets' Hill's sphere radii are present in input file\n                npl            : number of planets\n                swifter_pl1P   : pointer to head of Swifter planet structure linked-list\n    Terminal  : none\n    File      : id             : planet identifier               (all planets)\n                mass           : mass                            (all planets)\n                rhill          : Hill's sphere radius (optional) (if present, all planets except the Sun)\n                radius         : physical radius (optional)      (if present, all planets except the Sun)\n                xh             : heliocentric position           (all planets)\n                vh             : heliocentric velocity           (all planets) Output\n    Arguments : swifter_pl1P   : pointer to head of Swifter planet structure linked-list\n    Terminal  : error message\n    File      : none Invocation  : CALL io_init_pl(inplfile, in_type, lclose, lrhill_present, npl, swifter_pl1P) Notes       : Adapted from Martin Duncan's Swift routine io_init_pl.f Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~io_init_pl.f90~~EfferentGraph sourcefile~io_init_pl.f90 io_init_pl.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~io_init_pl.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~io_init_pl.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~io_init_pl.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~io_init_pl.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io_init_pl.f90->sourcefile~swiftest.f90 sourcefile~module_fxdr.f90 module_fxdr.f90 sourcefile~io_init_pl.f90->sourcefile~module_fxdr.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines io_init_pl Source Code io_init_pl.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : io_init_pl !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : io !  Language    : Fortran 90/95 ! !  Description : Read in planet data ! !  Input !    Arguments : inplfile       : name of input file for planets !                in_type        : format of input data file !                lclose         : logical flag indicating whether planets' physical radii are present in input file !                lrhill_present : logical flag indicating whether planets' Hill's sphere radii are present in input file !                npl            : number of planets !                swifter_pl1P   : pointer to head of Swifter planet structure linked-list !    Terminal  : none !    File      : id             : planet identifier               (all planets) !                mass           : mass                            (all planets) !                rhill          : Hill's sphere radius (optional) (if present, all planets except the Sun) !                radius         : physical radius (optional)      (if present, all planets except the Sun) !                xh             : heliocentric position           (all planets) !                vh             : heliocentric velocity           (all planets) ! !  Output !    Arguments : swifter_pl1P   : pointer to head of Swifter planet structure linked-list !    Terminal  : error message !    File      : none ! !  Invocation  : CALL io_init_pl(inplfile, in_type, lclose, lrhill_present, npl, swifter_pl1P) ! !  Notes       : Adapted from Martin Duncan's Swift routine io_init_pl.f ! !********************************************************************************************************************************** SUBROUTINE io_init_pl ( inplfile , in_type , lclose , lrhill_present , npl , symba_plA ) ! Modules USE swiftest USE module_symba USE module_helio USE module_swiftest USE module_fxdr USE module_interfaces , EXCEPT_THIS_ONE => io_init_pl IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( IN ) :: lclose , lrhill_present INTEGER ( I4B ), INTENT ( IN ) :: npl CHARACTER ( * ), INTENT ( IN ) :: inplfile , in_type TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA ! Internals INTEGER ( I4B ), PARAMETER :: LUN = 7 INTEGER ( I4B ) :: i , iu , ierr , inpl ! Executable code IF ( in_type == \"ASCII\" ) THEN CALL io_open ( LUN , inplfile , \"OLD\" , \"FORMATTED\" , ierr ) READ ( LUN , * ) inpl READ ( LUN , * ) symba_plA % helio % swiftest % name ( 1 ), symba_plA % helio % swiftest % mass ( 1 ) symba_plA % helio % swiftest % rhill ( 1 ) = 0.0_DP symba_plA % helio % swiftest % radius ( 1 ) = 0.0_DP READ ( LUN , * ) symba_plA % helio % swiftest % xh (:, 1 ) READ ( LUN , * ) symba_plA % helio % swiftest % vh (:, 1 ) DO i = 1 , NDIM IF (( symba_plA % helio % swiftest % xh ( i , 1 ) /= 0.0_DP ) . OR . ( symba_plA % helio % swiftest % vh ( i , 1 ) /= 0.0_DP )) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \" Input MUST be in heliocentric coordinates.\" WRITE ( * , * ) \" Position/velocity components of Body 1 are\" WRITE ( * , * ) symba_plA % helio % swiftest % xh (:, 1 ) WRITE ( * , * ) symba_plA % helio % swiftest % vh (:, 1 ) CALL util_exit ( FAILURE ) END IF END DO symba_plA % helio % swiftest % status ( 1 ) = ACTIVE DO i = 2 , npl IF ( lrhill_present ) THEN READ ( LUN , * ) symba_plA % helio % swiftest % name ( i ), symba_plA % helio % swiftest % mass ( i ), & symba_plA % helio % swiftest % rhill ( i ) ELSE READ ( LUN , * ) symba_plA % helio % swiftest % name ( i ), symba_plA % helio % swiftest % mass ( i ) symba_plA % helio % swiftest % rhill ( i ) = 0.0_DP END IF IF ( lclose ) THEN READ ( LUN , * ) symba_plA % helio % swiftest % radius ( i ) ELSE symba_plA % helio % swiftest % radius ( i ) = 0.0_DP END IF READ ( LUN , * ) symba_plA % helio % swiftest % xh (:, i ) READ ( LUN , * ) symba_plA % helio % swiftest % vh (:, i ) symba_plA % helio % swiftest % status ( i ) = ACTIVE END DO CLOSE ( UNIT = LUN ) ELSE CALL io_open_fxdr ( inplfile , \"R\" , . TRUE ., iu , ierr ) ierr = ixdrint ( iu , inpl ) ierr = ixdrint ( iu , symba_plA % helio % swiftest % name ( 1 )) ierr = ixdrdouble ( iu , symba_plA % helio % swiftest % mass ( 1 )) symba_plA % helio % swiftest % rhill ( 1 ) = 0.0_DP symba_plA % helio % swiftest % radius ( 1 ) = 0.0_DP ierr = ixdrdmat ( iu , NDIM , symba_plA % helio % swiftest % xh (:, 1 )) ierr = ixdrdmat ( iu , NDIM , symba_plA % helio % swiftest % vh (:, 1 )) DO i = 1 , NDIM IF (( symba_plA % helio % swiftest % xh ( i , 1 ) /= 0.0_DP ) . OR . & ( symba_plA % helio % swiftest % vh ( i , 1 ) /= 0.0_DP )) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \" Input MUST be in heliocentric coordinates.\" WRITE ( * , * ) \" Position/velocity components of Body 1 are\" WRITE ( * , * ) symba_plA % helio % swiftest % xh (:, 1 ) WRITE ( * , * ) symba_plA % helio % swiftest % vh (:, 1 ) CALL util_exit ( FAILURE ) END IF END DO symba_plA % helio % swiftest % status ( 1 ) = ACTIVE DO i = 2 , npl ierr = ixdrint ( iu , symba_plA % helio % swiftest % name ( i )) ierr = ixdrdouble ( iu , symba_plA % helio % swiftest % mass ( i )) IF ( lrhill_present ) THEN ierr = ixdrdouble ( iu , symba_plA % helio % swiftest % rhill ( i )) ELSE symba_plA % helio % swiftest % rhill ( i ) = 0.0_DP END IF IF ( lclose ) THEN ierr = ixdrdouble ( iu , symba_plA % helio % swiftest % radius ( i )) ELSE symba_plA % helio % swiftest % radius ( i ) = 0.0_DP END IF ierr = ixdrdmat ( iu , NDIM , symba_plA % helio % swiftest % xh (:, i )) ierr = ixdrdmat ( iu , NDIM , symba_plA % helio % swiftest % vh (:, i )) symba_plA % helio % swiftest % status ( i ) = ACTIVE END DO ierr = ixdrclose ( iu ) END IF RETURN END SUBROUTINE io_init_pl !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/io_init_pl.f90.html"},{"title":"io_dump_tp.f90 – swiftest","text":"Unit Name   : io_dump_tp\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : io\n  Language    : Fortran 90/95 Description : Dump test particle data to file Input\n    Arguments : ntp          : number of active test particles\n                swifter_tp1P : pointer to head of active Swifter test particle structure linked-list\n    Terminal  : none\n    File      : none Output\n    Arguments : none\n    Terminal  : error message\n    File      : to dump file\n                ntp          : number of active test particles\n                id           : test particle identifier        (from test particle structure, for each test particle)\n                xh           : heliocentric position           (from test particle structure, for each test particle)\n                vh           : heliocentric velocity           (from test particle structure, for each test particle) Invocation  : CALL io_dump_tp(ntp, swifter_tp1P) Notes       : Adapted from Martin Duncan's Swift routine io_dump_tp.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~io_dump_tp.f90~~EfferentGraph sourcefile~io_dump_tp.f90 io_dump_tp.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~io_dump_tp.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~io_dump_tp.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io_dump_tp.f90->sourcefile~swiftest.f90 sourcefile~module_fxdr.f90 module_fxdr.f90 sourcefile~io_dump_tp.f90->sourcefile~module_fxdr.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines io_dump_tp Source Code io_dump_tp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : io_dump_tp !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : io !  Language    : Fortran 90/95 ! !  Description : Dump test particle data to file ! !  Input !    Arguments : ntp          : number of active test particles !                swifter_tp1P : pointer to head of active Swifter test particle structure linked-list !    Terminal  : none !    File      : none ! !  Output !    Arguments : none !    Terminal  : error message !    File      : to dump file !                ntp          : number of active test particles !                id           : test particle identifier        (from test particle structure, for each test particle) !                xh           : heliocentric position           (from test particle structure, for each test particle) !                vh           : heliocentric velocity           (from test particle structure, for each test particle) ! !  Invocation  : CALL io_dump_tp(ntp, swifter_tp1P) ! !  Notes       : Adapted from Martin Duncan's Swift routine io_dump_tp.f ! !********************************************************************************************************************************** SUBROUTINE io_dump_tp ( ntp , swiftest_tpA ) ! Modules USE swiftest USE module_swiftest USE module_fxdr USE module_interfaces , EXCEPT_THIS_ONE => io_dump_tp IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: ntp TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA ! Internals INTEGER ( I4B ) :: i , iu , ierr INTEGER ( I4B ), SAVE :: idx = 1 ! Executable code CALL io_open_fxdr ( DUMP_TP_FILE ( idx ), \"W\" , . TRUE ., iu , ierr ) IF ( ierr /= 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to open binary dump file \" , TRIM ( DUMP_TP_FILE ( idx )) CALL util_exit ( FAILURE ) END IF ierr = ixdrint ( iu , ntp ) DO i = 1 , ntp ierr = ixdrint ( iu , swiftest_tpA % name ( i )) ierr = ixdrdmat ( iu , NDIM , swiftest_tpA % xh (:, i )) ierr = ixdrdmat ( iu , NDIM , swiftest_tpA % vh (:, i )) END DO ierr = ixdrclose ( iu ) idx = idx + 1 IF ( idx > 2 ) idx = 1 RETURN END SUBROUTINE io_dump_tp !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/io_dump_tp.f90.html"},{"title":"io_read_param_in.f90 – swiftest","text":"This file depends on sourcefile~~io_read_param_in.f90~~EfferentGraph sourcefile~io_read_param_in.f90 io_read_param_in.f90 sourcefile~io.f90 io.f90 sourcefile~io_read_param_in.f90->sourcefile~io.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~io.f90->sourcefile~module_interfaces.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~io.f90->sourcefile~module_symba.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_io_read_param_in Source Code io_read_param_in.f90 Source Code submodule ( io ) s_io_read_param_in contains module procedure io_read_param_in !! author: The Purdue Swiftest Team -  David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Read in parameters for the integration !! !! Adapted from David E. Kaufmann's Swifter routine io_init_param.f90 !! Adapted from Martin Duncan's Swift routine io_init_param.f !$ use omp_lib implicit none ! Internals integer ( I4B ), parameter :: LUN = 7 !! Unit number of input file logical :: t0_set = . false . !! Is the initial time set in the input file? logical :: tstop_set = . false . !! Is the final time set in the input file? logical :: dt_set = . false . !! Is the step size set in the input file? integer ( I4B ) :: ierr = 0 !! Input error code integer ( I4B ) :: ilength , ifirst , ilast !! Variables used to parse input file character ( STRMAX ) :: line !! Line of the input file character ( STRMAX ) :: param_name , param_value !! Input file tokens ! Executable code ! Read in name of parameter file write ( * , * ) \"Parameter data file is \" , trim ( adjustl ( inparfile )) write ( * , * ) \" \" 100 format ( A ) open ( unit = LUN , file = inparfile , status = 'old' , iostat = ierr ) if ( ierr /= 0 ) then write ( * , * ) \"Unable to open file \" , ierr write ( * , * ) inparfile call util_exit ( FAILURE ) end if ! Parse the file line by line, extracting tokens then matching them up with known parameters if possible do read ( LUN , 100 , IOSTAT = ierr , end = 1 ) line line = adjustl ( line ) ilength = len_trim ( line ) if (( ilength /= 0 ) . and . ( line ( 1 : 1 ) /= \"!\" )) then ifirst = 1 ! Read the pair of tokens. The first one is the parameter name, the second is the value. param_name = io_get_token ( line , ilength , ifirst , ilast , ierr ) call util_toupper ( param_name ) ifirst = ilast + 1 param_value = io_get_token ( line , ilength , ifirst , ilast , ierr ) select case ( param_name ) case ( \"NPLMAX\" ) read ( param_value , * ) param % nplmax case ( \"NTPMAX\" ) read ( param_value , * ) param % ntpmax case ( \"T0\" ) read ( param_value , * ) param % t0 t0_set = . true . case ( \"TSTOP\" ) read ( param_value , * ) param % tstop tstop_set = . true . case ( \"DT\" ) read ( param_value , * ) param % dt dt_set = . true . case ( \"PL_IN\" ) param % inplfile = param_value case ( \"TP_IN\" ) param % intpfile = param_value case ( \"IN_TYPE\" ) call util_toupper ( param_value ) param % in_type = param_value case ( \"ISTEP_OUT\" ) read ( param_value , * ) param % istep_out case ( \"BIN_OUT\" ) param % outfile = param_value case ( \"OUT_TYPE\" ) call util_toupper ( param_value ) param % out_type = param_value case ( \"OUT_FORM\" ) call util_toupper ( param_value ) param % out_form = param_value case ( \"OUT_STAT\" ) call util_toupper ( param_value ) param % out_stat = param_value case ( \"ISTEP_DUMP\" ) read ( param_value , * ) param % istep_dump case ( \"J2\" ) read ( param_value , * ) param % j2rp2 case ( \"J4\" ) read ( param_value , * ) param % j4rp4 case ( \"CHK_CLOSE\" ) call util_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % feature % lclose = . true . case ( \"CHK_RMIN\" ) read ( param_value , * ) param % rmin case ( \"CHK_RMAX\" ) read ( param_value , * ) param % rmax case ( \"CHK_EJECT\" ) read ( param_value , * ) param % rmaxu case ( \"CHK_QMIN\" ) read ( param_value , * ) param % qmin case ( \"CHK_QMIN_COORD\" ) call util_toupper ( param_value ) param % qmin_coord = param_value case ( \"CHK_QMIN_RANGE\" ) read ( param_value , * ) param % qmin_alo ifirst = ilast + 1 param_value = io_get_token ( line , ilength , ifirst , ilast , ierr ) read ( param_value , * ) param % qmin_ahi case ( \"ENC_OUT\" ) param % encounter_file = param_value case ( \"EXTRA_FORCE\" ) call util_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % feature % lextra_force = . true . case ( \"BIG_DISCARD\" ) call util_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % feature % lbig_discard = . true . case ( \"RHILL_PRESENT\" ) call util_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == \"T\" ) param % feature % lrhill_present = . true . ! Added by the Purdue Swiftest development group (Minton, Wishard, Populin, and Elliott) case ( \"FRAGMENTATION\" ) call util_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == \"T\" ) param % feature % lfragmentation = . true . case ( \"MU2GM\" ) read ( param_value , * ) param % MU2GM case ( \"TU2S\" ) read ( param_value , * ) param % TU2S case ( \"DU2CM\" ) read ( param_value , * ) param % DU2CM case ( \"MTINY\" ) read ( param_value , * ) param % mtiny case ( \"PYTHON\" ) call util_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % feature % lpython = . true . case ( \"ENERGY\" ) call util_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % feature % lenergy = . true . case ( \"RINGMOONS\" ) call util_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % feature % lringmoons = . true . case ( \"RING_OUTFILE\" ) param % ring_outfile = param_value case ( \"ROTATION\" ) call util_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % feature % lrotation = . true . case default write ( * , * ) \"Unknown parameter -> \" , param_name call util_exit ( FAILURE ) end select end if end do 1 close ( LUN ) write ( * , * ) \"NPLMAX         = \" , param % nplmax write ( * , * ) \"NTPMAX         = \" , param % ntpmax write ( * , * ) \"T0             = \" , param % t0 write ( * , * ) \"TSTOP          = \" , param % tstop write ( * , * ) \"DT             = \" , param % dt write ( * , * ) \"PL_IN          = \" , trim ( adjustl ( param % inplfile )) write ( * , * ) \"TP_IN          = \" , trim ( adjustl ( param % intpfile )) write ( * , * ) \"IN_TYPE        = \" , trim ( adjustl ( param % in_type )) write ( * , * ) \"ISTEP_OUT      = \" , param % istep_out write ( * , * ) \"BIN_OUT        = \" , trim ( adjustl ( param % outfile )) write ( * , * ) \"OUT_TYPE       = \" , trim ( adjustl ( param % out_type )) write ( * , * ) \"OUT_FORM       = \" , trim ( adjustl ( param % out_form )) write ( * , * ) \"OUT_STAT       = \" , trim ( adjustl ( param % out_stat )) write ( * , * ) \"ISTEP_DUMP     = \" , param % istep_dump write ( * , * ) \"J2             = \" , param % j2rp2 write ( * , * ) \"J4             = \" , param % j4rp4 write ( * , * ) \"CHK_CLOSE      = \" , param % feature % lclose write ( * , * ) \"CHK_RMIN       = \" , param % rmin write ( * , * ) \"CHK_RMAX       = \" , param % rmax write ( * , * ) \"CHK_EJECT      = \" , param % rmaxu write ( * , * ) \"CHK_QMIN       = \" , param % qmin write ( * , * ) \"CHK_QMIN_COORD = \" , trim ( adjustl ( param % qmin_coord )) write ( * , * ) \"CHK_QMIN_RANGE = \" , param % qmin_alo , param % qmin_ahi write ( * , * ) \"ENC_OUT        = \" , trim ( adjustl ( param % encounter_file )) write ( * , * ) \"EXTRA_FORCE    = \" , param % feature % lextra_force write ( * , * ) \"BIG_DISCARD    = \" , param % feature % lbig_discard write ( * , * ) \"RHILL_PRESENT  = \" , param % feature % lrhill_present ierr = 0 if ((. not . t0_set ) . or . (. not . tstop_set ) . or . (. not . dt_set )) then write ( * , * ) 'Valid simulation time not set' write ( * , * ) 't0_set:   ' , t0_set write ( * , * ) 'tstop_set:' , tstop_set write ( * , * ) 'dt_set:   ' , dt_set ierr = - 1 end if if ( param % dt <= 0.0_DP ) then write ( * , * ) 'Invalid timestep: ' write ( * , * ) 'dt: ' , param % dt ierr = - 1 end if if ( param % inplfile == \"\" ) then write ( * , * ) 'No valid planet file in input file' ierr = - 1 end if if (( param % in_type /= XDR8_TYPE ) . and . ( param % in_type /= \"ASCII\" )) then write ( * , * ) 'Invalid input file type:' , param % in_type ierr = - 1 end if if (( param % istep_out <= 0 ) . and . ( param % istep_dump <= 0 )) then write ( * , * ) 'Invalid istep' write ( * , * ) 'istep_out:  ' , param % istep_out write ( * , * ) 'istep_dump: ' , param % istep_dump ierr = - 1 end if if (( param % istep_out > 0 ) . and . ( param % outfile == \"\" )) then write ( * , * ) 'invalid outfile' ierr = - 1 end if if ( param % outfile /= \"\" ) then if (( param % out_type /= REAL4_TYPE ) . and . ( param % out_type /= REAL8_TYPE ) . and . & ( param % out_type /= XDR4_TYPE ) . and . ( param % out_type /= XDR8_TYPE )) then write ( * , * ) 'Invalid out_type: ' , param % out_type ierr = - 1 end if if (( param % out_form /= \"EL\" ) . and . ( param % out_form /= \"XV\" ) . and . ( param % out_form /= \"FILT\" )) then write ( * , * ) 'Invalid out_form: ' , param % out_form ierr = - 1 end if if (( param % out_stat /= \"NEW\" ) . and . ( param % out_stat /= \"UNKNOWN\" ) . and . ( param % out_stat /= \"APPEND\" )) then write ( * , * ) 'Invalid out_stat: ' , param % out_stat ierr = - 1 end if end if if (( param % j2rp2 == 0.0_DP ) . and . ( param % j4rp4 /= 0.0_DP )) then write ( * , * ) 'Cannot have j4 without j2' ierr = - 1 end if if ( param % qmin > 0.0_DP ) then if (( param % qmin_coord /= \"HELIO\" ) . and . ( param % qmin_coord /= \"BARY\" )) then write ( * , * ) 'Invalid qmin_coord: ' , param % qmin_coord ierr = - 1 end if if (( param % qmin_alo <= 0.0_DP ) . or . ( param % qmin_ahi <= 0.0_DP )) then write ( * , * ) 'Invalid qmin vals' write ( * , * ) 'qmin_alo: ' , param % qmin_alo write ( * , * ) 'qmin_ahi: ' , param % qmin_ahi ierr = - 1 end if end if ! Added by D. Minton MU2GM = param % MU2GM TU2S = param % TU2S DU2CM = param % DU2CM ! The fragmentation model requires the user to set the unit system explicitly. write ( * , * ) \"FRAGMENTATION  = \" , param % feature % lfragmentation if ( param % feature % lfragmentation ) then write ( * , * ) \"MU2GM          = \" , MU2GM write ( * , * ) \"TU2S           = \" , TU2S write ( * , * ) \"DU2CM          = \" , DU2CM if (( MU2GM < 0.0_DP ) . or . ( TU2S < 0.0_DP ) . or . ( DU2CM < 0.0_DP )) then write ( * , * ) 'Invalid unit conversion factor' write ( * , * ) 'MU2GM: ' , MU2GM write ( * , * ) 'TU2S: ' , TU2S write ( * , * ) 'DU2CM: ' , DU2CM ierr = - 1 end if end if !Added mtiny to the argument list rather than from the terminal if ( param % mtiny < 0.0_DP ) then write ( * , * ) \"Invalid MTINY: \" , param % mtiny ierr = - 1 else write ( * , * ) \"MTINY          = \" , param % mtiny end if if ( param % feature % lpython ) write ( * , * ) \"PYTHON         = \" , param % feature % lpython if ( param % feature % lenergy ) write ( * , * ) \"ENERGY         = \" , param % feature % lenergy if ( param % feature % lringmoons ) write ( * , * ) \"RINGMOONS      = \" , param % feature % lringmoons if ( ierr < 0 ) then write ( * , 100 ) \"Input parameter(s) failed check\" call util_exit ( FAILURE ) end if !> Define the maximum number of threads nthreads = 1 ! In the *serial* case !$ nthreads = omp_get_max_threads() ! In the *parallel* case !$ write(*,'(a)')   ' OpenMP parameters:' !$ write(*,'(a)')   ' ------------------' !$ write(*,'(a,i3,/)') ' Number of threads  = ', nthreads return end procedure io_read_param_in end submodule s_io_read_param_in","tags":"","loc":"sourcefile/io_read_param_in.f90.html"},{"title":"io_dump_param.f90 – swiftest","text":"Unit Name   : io_dump_param\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : io\n  Language    : Fortran 90/95 Description : Dump integration parameters to file Input\n    Arguments : nplmax         : maximum allowed number of planets\n                ntpmax         : maximum allowed number of test particles\n                ntp            : number of active test particles\n                t              : time\n                tstop          : integration stop time\n                dt             : time step\n                in_type        : format of input data files\n                istep_out      : number of time steps between binary outputs\n                outfile        : name of output binary file\n                out_type       : binary format of output file\n                out_form       : data to write to output file\n                istep_dump     : number of time steps between dumps\n                j2rp2          : J2 * R 2 for the Sun\n                j4rp4          : J4 * R 4 for the Sun\n                rmin           : minimum heliocentric radius for test particle\n                rmax           : maximum heliocentric radius for test particle\n                rmaxu          : maximum unbound heliocentric radius for test particle\n                qmin           : minimum pericenter distance for test particle\n                qmin_coord     : coordinate frame to use for qmin\n                qmin_alo       : minimum semimajor axis for qmin\n                qmin_ahi       : maximum semimajor axis for qmin\n                encounter_file : name of output file for encounters\n                mtiny          : mass cutoff \n                feature        : feature list\n    Terminal  : none\n    File      : none Output\n    Arguments : none\n    Terminal  : none\n    File      : (same quantities listed above as input from argument are dumped to file, with the following exceptions)\n                ntp            : number of active test particles                    (NOT WRITTEN)\n                inplfile       : name of corresponding planet data dump file        (WRITTEN)\n                intpfile       : name of corresponding test particle data dump file (WRITTEN)\n                out_stat       : open status for output binary file                 (WRITTEN) Invocation  : CALL io_dump_param(nplmax, ntpmax, ntp, t, tstop, dt, in_type, istep_out, outfile, out_type, out_form,\n                                   istep_dump, j2rp2, j4rp4, rmin, rmax, rmaxu, qmin, qmin_coord, qmin_alo, qmin_ahi,\n                                   encounter_file, lextra_force, lbig_discard, lrhill_present) Notes       : Adapted from Martin Duncan's Swift routine io_dump_param.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~io_dump_param.f90~~EfferentGraph sourcefile~io_dump_param.f90 io_dump_param.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~io_dump_param.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io_dump_param.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines io_dump_param Source Code io_dump_param.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : io_dump_param !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : io !  Language    : Fortran 90/95 ! !  Description : Dump integration parameters to file ! !  Input !    Arguments : nplmax         : maximum allowed number of planets !                ntpmax         : maximum allowed number of test particles !                ntp            : number of active test particles !                t              : time !                tstop          : integration stop time !                dt             : time step !                in_type        : format of input data files !                istep_out      : number of time steps between binary outputs !                outfile        : name of output binary file !                out_type       : binary format of output file !                out_form       : data to write to output file !                istep_dump     : number of time steps between dumps !                j2rp2          : J2 * R**2 for the Sun !                j4rp4          : J4 * R**4 for the Sun !                rmin           : minimum heliocentric radius for test particle !                rmax           : maximum heliocentric radius for test particle !                rmaxu          : maximum unbound heliocentric radius for test particle !                qmin           : minimum pericenter distance for test particle !                qmin_coord     : coordinate frame to use for qmin !                qmin_alo       : minimum semimajor axis for qmin !                qmin_ahi       : maximum semimajor axis for qmin !                encounter_file : name of output file for encounters !                mtiny          : mass cutoff !                feature        : feature list !    Terminal  : none !    File      : none ! !  Output !    Arguments : none !    Terminal  : none !    File      : (same quantities listed above as input from argument are dumped to file, with the following exceptions) !                ntp            : number of active test particles                    (NOT WRITTEN) !                inplfile       : name of corresponding planet data dump file        (WRITTEN) !                intpfile       : name of corresponding test particle data dump file (WRITTEN) !                out_stat       : open status for output binary file                 (WRITTEN) ! !  Invocation  : CALL io_dump_param(nplmax, ntpmax, ntp, t, tstop, dt, in_type, istep_out, outfile, out_type, out_form, !                                   istep_dump, j2rp2, j4rp4, rmin, rmax, rmaxu, qmin, qmin_coord, qmin_alo, qmin_ahi, !                                   encounter_file, lextra_force, lbig_discard, lrhill_present) ! !  Notes       : Adapted from Martin Duncan's Swift routine io_dump_param.f ! !********************************************************************************************************************************** SUBROUTINE io_dump_param ( nplmax , ntpmax , ntp , t , tstop , dt , in_type , istep_out , outfile , out_type , out_form , istep_dump , j2rp2 , & j4rp4 , rmin , rmax , rmaxu , qmin , qmin_coord , qmin_alo , qmin_ahi , encounter_file , & mtiny , feature , ring_outfile ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => io_dump_param IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: nplmax , ntpmax , ntp , istep_out , istep_dump REAL ( DP ), INTENT ( IN ) :: t , tstop , dt , j2rp2 , j4rp4 , rmin , rmax , rmaxu , qmin , qmin_alo , qmin_ahi CHARACTER ( * ), INTENT ( IN ) :: qmin_coord , encounter_file , in_type , outfile , out_type , out_form REAl ( DP ), INTENT ( OUT ), OPTIONAL :: mtiny TYPE ( feature_list ), INTENT ( OUT ) :: feature CHARACTER ( * ), INTENT ( OUT ), OPTIONAL :: ring_outfile ! Internals INTEGER ( I4B ), PARAMETER :: LUN = 7 INTEGER ( I4B ) :: ierr INTEGER ( I4B ), SAVE :: idx = 1 ! Executable code CALL io_open ( LUN , DUMP_PARAM_FILE ( idx ), \"REPLACE\" , \"FORMATTED\" , ierr ) 100 FORMAT ( A20 ) WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"NPLMAX \" WRITE ( LUN , * ) nplmax WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"NTPMAX \" WRITE ( LUN , * ) ntpmax WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"T0 \" WRITE ( LUN , * ) t WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"TSTOP \" WRITE ( LUN , * ) tstop WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"DT \" WRITE ( LUN , * ) dt WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"PL_IN \" WRITE ( LUN , * ) TRIM ( DUMP_PL_FILE ( idx )) IF ( ntp > 0 ) THEN WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"TP_IN \" WRITE ( LUN , * ) TRIM ( DUMP_TP_FILE ( idx )) ELSE WRITE ( LUN , 100 ) \"!TP_IN \" END IF WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"IN_TYPE \" WRITE ( LUN , * ) XDR8_TYPE IF ( istep_out > 0 ) THEN WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"ISTEP_OUT \" WRITE ( LUN , * ) istep_out WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"BIN_OUT \" WRITE ( LUN , * ) TRIM ( outfile ) WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"OUT_TYPE \" WRITE ( LUN , * ) TRIM ( out_type ) WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"OUT_FORM \" WRITE ( LUN , * ) TRIM ( out_form ) WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"OUT_STAT \" WRITE ( LUN , * ) \"APPEND\" ELSE WRITE ( LUN , 100 ) \"!ISTEP_OUT \" WRITE ( LUN , 100 ) \"!BIN_OUT \" WRITE ( LUN , 100 ) \"!OUT_TYPE \" WRITE ( LUN , 100 ) \"!OUT_FORM \" WRITE ( LUN , 100 ) \"!OUT_STAT \" END IF IF ( istep_dump > 0 ) THEN WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"ISTEP_DUMP \" WRITE ( LUN , * ) istep_dump ELSE WRITE ( LUN , 100 ) \"!ISTEP_DUMP \" END IF IF ( j2rp2 /= 0.0_DP ) THEN WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"J2 \" WRITE ( LUN , * ) j2rp2 IF ( j4rp4 /= 0.0_DP ) THEN WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"J4 \" WRITE ( LUN , * ) j4rp4 ELSE WRITE ( LUN , 100 ) \"!J4 \" END IF ELSE WRITE ( LUN , 100 ) \"!J2 \" WRITE ( LUN , 100 ) \"!J4 \" END IF WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"CHK_CLOSE \" IF ( feature % lclose ) THEN WRITE ( LUN , * ) \"YES\" ELSE WRITE ( LUN , * ) \"NO\" END IF WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"CHK_RMIN \" WRITE ( LUN , * ) rmin WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"CHK_RMAX \" WRITE ( LUN , * ) rmax WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"CHK_EJECT \" WRITE ( LUN , * ) rmaxu WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"CHK_QMIN \" WRITE ( LUN , * ) qmin IF ( qmin >= 0.0_DP ) THEN WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"CHK_QMIN_COORD \" WRITE ( LUN , * ) TRIM ( qmin_coord ) WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"CHK_QMIN_RANGE \" WRITE ( LUN , * ) qmin_alo , qmin_ahi ELSE WRITE ( LUN , 100 ) \"!CHK_QMIN_COORD \" WRITE ( LUN , 100 ) \"!CHK_QMIN_RANGE \" END IF WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"ENC_OUT \" WRITE ( LUN , * ) TRIM ( encounter_file ) WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"EXTRA_FORCE \" IF ( feature % lextra_force ) THEN WRITE ( LUN , * ) \"YES\" ELSE WRITE ( LUN , * ) \"NO\" END IF WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"BIG_DISCARD \" IF ( feature % lbig_discard ) THEN WRITE ( LUN , * ) \"YES\" ELSE WRITE ( LUN , * ) \"NO\" END IF WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"RHILL_PRESENT \" IF ( feature % lrhill_present ) THEN WRITE ( LUN , * ) \"YES\" ELSE WRITE ( LUN , * ) \"NO\" END IF WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"MTINY \" WRITE ( LUN , * ) mtiny WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"PYTHON \" IF ( feature % lpython ) THEN WRITE ( LUN , * ) \"YES\" ELSE WRITE ( LUN , * ) \"NO\" END IF CLOSE ( UNIT = LUN ) idx = idx + 1 IF ( idx > 2 ) idx = 1 ! The fragmentation model requires the user to set the unit system explicitly. WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"FRAGMENTATION  = \" WRITE ( LUN , * ) feature % lfragmentation IF ( feature % lfragmentation ) THEN WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"MU2GM          = \" WRITE ( LUN , * ) MU2GM WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"TU2S           = \" WRITE ( LUN , * ) TU2S WRITE ( LUN , 100 , ADVANCE = \"NO\" ) \"DU2CM          = \" WRITE ( LUN , * ) DU2CM IF (( MU2GM < 0.0_DP ) . OR . ( TU2S < 0.0_DP ) . OR . ( DU2CM < 0.0_DP )) ierr = - 1 END IF RETURN END SUBROUTINE io_dump_param !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/io_dump_param.f90.html"},{"title":"python_io_write_frame_tp.f90 – swiftest","text":"Unit Name   : python_io_write_frame_tp\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : io\n  Language    : Fortran 90/95 Description : Write a frame of Swiftest output to a binary file Input\n    Arguments : t              : time\n                Symba_tpA      : Python readable data structure for test particles\n                ntp            : number of test particles \n                python_outfile : output file name\n                out_stat     : open status for output binary file (either \"APPEND\" or \"NEW\")\n    Terminal  : none\n    File      : none Output\n    Arguments : none\n    Terminal  : error message\n    File      : none Invocation  : CALL python_io_write_frame_tp(t, symba_tpA, ntp, tp_outfile, out_stat) Notes       : Author(s)   : David A. Minton, Carlisle Wishard, Jennifer Pouplin This file depends on sourcefile~~python_io_write_frame_tp.f90~~EfferentGraph sourcefile~python_io_write_frame_tp.f90 python_io_write_frame_tp.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~python_io_write_frame_tp.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~python_io_write_frame_tp.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~python_io_write_frame_tp.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~python_io_write_frame_tp.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~python_io_write_frame_tp.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines python_io_write_frame_tp Source Code python_io_write_frame_tp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : python_io_write_frame_tp !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : io !  Language    : Fortran 90/95 ! !  Description : Write a frame of Swiftest output to a binary file ! !  Input !    Arguments : t              : time !                Symba_tpA      : Python readable data structure for test particles !                ntp            : number of test particles !                python_outfile : output file name !                out_stat     : open status for output binary file (either \"APPEND\" or \"NEW\") !    Terminal  : none !    File      : none ! !  Output !    Arguments : none !    Terminal  : error message !    File      : none ! !  Invocation  : CALL python_io_write_frame_tp(t, symba_tpA, ntp, tp_outfile, out_stat) ! !  Notes       : ! !********************************************************************************************************************************** !********************************************************************************************************************************** !  Author(s)   : David A. Minton, Carlisle Wishard, Jennifer Pouplin !********************************************************************************************************************************** subroutine python_io_write_frame_tp ( t , symba_tpA , ntp , out_stat ) ! modules use swiftest use module_swiftest use module_helio use module_symba use module_interfaces , except_this_one => python_io_write_frame_tp implicit none ! arguments real ( DP ), intent ( in ) :: t type ( symba_tp ), intent ( in ) :: symba_tpA integer , intent ( in ) :: ntp character ( * ), intent ( in ) :: out_stat ! internals logical ( LGT ), save :: lfirst = . true . integer ( I4B ), parameter :: lun = 88 integer ( I4B ) :: ierr integer ( I4B ), save :: iu = lun ! executable code if ( lfirst ) then if ( out_stat == \"APPEND\" ) then call io_open ( iu , tp_outfile , out_stat , \"unformatted\" , ierr ) else if ( out_stat == \"NEW\" ) then call io_open ( iu , tp_outfile , out_stat , \"unformatted\" , ierr ) if ( ierr /= 0 ) then write ( * , * ) \"SWIFTEST error:\" write ( * , * ) \" TP  Binary output file already exists\" call util_exit ( FAILURE ) end if else call io_open ( iu , tp_outfile , \"REPLACE\" , \"UNFORMATTED\" , ierr ) end if if ( ierr /= 0 ) then write ( * , * ) \"SWIFTEST error:\" write ( * , * ) \"  Unable to open TP binary output file\" call util_exit ( FAILURE ) end if lfirst = . false . else call io_open ( iu , tp_outfile , \"APPEND\" , \"UNFORMATTED\" , ierr ) if ( ierr /= 0 ) then write ( * , * ) \"SWIFTEST error:\" write ( * , * ) \"   Unable to open TP binary output file for append\" call util_exit ( failure ) end if end if write ( iu , iostat = ierr ) t write ( iu , iostat = ierr ) ntp write ( iu , iostat = ierr ) symba_tpA % helio % swiftest % name ( 1 : ntp ) write ( iu , iostat = ierr ) symba_tpA % helio % swiftest % status ( 1 : ntp ) write ( iu , iostat = ierr ) symba_tpA % helio % swiftest % peri ( 1 : ntp ) write ( iu , iostat = ierr ) symba_tpA % helio % swiftest % atp ( 1 : ntp ) write ( iu , iostat = ierr ) symba_tpA % helio % swiftest % xh ( 1 , 1 : ntp ) write ( iu , iostat = ierr ) symba_tpA % helio % swiftest % xh ( 2 , 1 : ntp ) write ( iu , iostat = ierr ) symba_tpA % helio % swiftest % xh ( 3 , 1 : ntp ) write ( iu , iostat = ierr ) symba_tpA % helio % swiftest % vh ( 1 , 1 : ntp ) write ( iu , iostat = ierr ) symba_tpA % helio % swiftest % vh ( 2 , 1 : ntp ) write ( iu , iostat = ierr ) symba_tpA % helio % swiftest % vh ( 3 , 1 : ntp ) write ( iu , iostat = ierr ) symba_tpA % helio % swiftest % xb ( 1 , 1 : ntp ) write ( iu , iostat = ierr ) symba_tpA % helio % swiftest % xb ( 2 , 1 : ntp ) write ( iu , iostat = ierr ) symba_tpA % helio % swiftest % xb ( 3 , 1 : ntp ) write ( iu , iostat = ierr ) symba_tpA % helio % swiftest % vb ( 1 , 1 : ntp ) write ( iu , iostat = ierr ) symba_tpA % helio % swiftest % vb ( 2 , 1 : ntp ) write ( iu , iostat = ierr ) symba_tpA % helio % swiftest % vb ( 3 , 1 : ntp ) close ( unit = iu , iostat = ierr ) if ( ierr /= 0 ) then write ( * , * ) \"SWIFTEST error:\" write ( * , * ) \"   Unable to close TP binary output file\" call util_exit ( FAILURE ) end if return end subroutine python_io_write_frame_tp","tags":"","loc":"sourcefile/python_io_write_frame_tp.f90.html"},{"title":"io_write_hdr.f90 – swiftest","text":"Unit Name   : io_write_hdr\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : io\n  Language    : Fortran 90/95 Description : Write frame header to output binary file Input\n    Arguments : iu        : unit number associated with output binary file\n                t         : time\n                npl       : number of planets\n                ntp       : number of active test particles\n                iout_form : specifier of data to write to output file (elements / heliocentric coordinates / filtered elements)\n                out_type  : format of output binary file\n    Terminal  : none\n    File      : none Output\n    Arguments : none\n    Terminal  : error message\n    File      : t (or ttmp) : time\n                npl         : number of planets\n                ntp         : number of active test particles\n                iout_form   : specifier of data to write to output file (elements / heliocentric coordinates / filtered elements) Invocation  : CALL io_write_hdr(iu, t, npl, ntp, iout_form, out_type) Notes       : Adapted from Hal Levison's Swift routine io_write_hdr.F Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~io_write_hdr.f90~~EfferentGraph sourcefile~io_write_hdr.f90 io_write_hdr.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~io_write_hdr.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io_write_hdr.f90->sourcefile~swiftest.f90 sourcefile~module_fxdr.f90 module_fxdr.f90 sourcefile~io_write_hdr.f90->sourcefile~module_fxdr.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines io_write_hdr Source Code io_write_hdr.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : io_write_hdr !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : io !  Language    : Fortran 90/95 ! !  Description : Write frame header to output binary file ! !  Input !    Arguments : iu        : unit number associated with output binary file !                t         : time !                npl       : number of planets !                ntp       : number of active test particles !                iout_form : specifier of data to write to output file (elements / heliocentric coordinates / filtered elements) !                out_type  : format of output binary file !    Terminal  : none !    File      : none ! !  Output !    Arguments : none !    Terminal  : error message !    File      : t (or ttmp) : time !                npl         : number of planets !                ntp         : number of active test particles !                iout_form   : specifier of data to write to output file (elements / heliocentric coordinates / filtered elements) ! !  Invocation  : CALL io_write_hdr(iu, t, npl, ntp, iout_form, out_type) ! !  Notes       : Adapted from Hal Levison's Swift routine io_write_hdr.F ! !********************************************************************************************************************************** SUBROUTINE io_write_hdr ( iu , t , npl , ntp , iout_form , out_type ) ! Modules USE swiftest USE module_fxdr USE module_interfaces , EXCEPT_THIS_ONE => io_write_hdr IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: iu , npl , ntp , iout_form REAL ( DP ), INTENT ( IN ) :: t CHARACTER ( * ), INTENT ( IN ) :: out_type ! Internals INTEGER ( I4B ) :: ierr INTEGER ( I4B ), DIMENSION ( 3 ) :: nn REAL ( SP ) :: ttmp ! Executable code ttmp = t nn ( 1 ) = npl nn ( 2 ) = ntp nn ( 3 ) = iout_form SELECT CASE ( out_type ) CASE ( REAL4_TYPE ) WRITE ( iu , IOSTAT = ierr ) ttmp , npl , ntp , iout_form IF ( ierr < 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to write binary file header\" CALL util_exit ( FAILURE ) END IF CASE ( REAL8_TYPE ) WRITE ( iu , IOSTAT = ierr ) t , npl , ntp , iout_form IF ( ierr < 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to write binary file header\" CALL util_exit ( FAILURE ) END IF CASE ( XDR4_TYPE ) ierr = ixdrreal ( iu , ttmp ) IF ( ierr < 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to write binary file header\" CALL util_exit ( FAILURE ) END IF ierr = ixdrimat ( iu , 3 , nn ) IF ( ierr < 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to write binary file header\" CALL util_exit ( FAILURE ) END IF CASE ( XDR8_TYPE ) ierr = ixdrdouble ( iu , t ) IF ( ierr < 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to write binary file header\" CALL util_exit ( FAILURE ) END IF ierr = ixdrimat ( iu , 3 , nn ) IF ( ierr < 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to write binary file header\" CALL util_exit ( FAILURE ) END IF END SELECT RETURN END SUBROUTINE io_write_hdr !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/io_write_hdr.f90.html"},{"title":"io_get_token.f90 – swiftest","text":"This file depends on sourcefile~~io_get_token.f90~~EfferentGraph sourcefile~io_get_token.f90 io_get_token.f90 sourcefile~io.f90 io.f90 sourcefile~io_get_token.f90->sourcefile~io.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~io.f90->sourcefile~module_interfaces.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~io.f90->sourcefile~module_symba.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_io_get_token Source Code io_get_token.f90 Source Code submodule ( io ) s_io_get_token contains module procedure io_get_token !! author: David A. Minton !! !! Retrieves a character token from an input string. Here a token is defined as any set of contiguous non-blank characters not !! beginning with or containing \"!\". If \"!\" is present, any remaining part of the buffer including the \"!\" is ignored !! !! Adapted from Swifter !! Original author David E. Kaufmann implicit none integer ( I4B ) :: i if ( ifirst > ilength ) then ilast = ifirst ierr = - 1 return end if do i = ifirst , ilength if ( buffer ( i : i ) /= \" \" ) exit end do if (( i > ilength ) . or . ( buffer ( i : i ) == \"!\" )) then ifirst = i ilast = i ierr = - 1 return end if ifirst = i do i = ifirst , ilength if (( buffer ( i : i ) == \" \" ) . or . ( buffer ( i : i ) == \"!\" )) exit end do ilast = i - 1 ierr = 0 token = buffer ( ifirst : ilast ) return end procedure io_get_token end submodule s_io_get_token","tags":"","loc":"sourcefile/io_get_token.f90.html"},{"title":"io_open.f90 – swiftest","text":"Unit Name   : io_open\n  Unit Type   : subroutine\n  Project     : Swifter\n  Package     : io\n  Language    : Fortran 90/95 Description : Open a file Input\n    Arguments : iu        : unit number with which to open file\n                fname     : name of file to open\n                fopenstat : status with which to open file\n                fmt       : format string\n    Terminal  : none\n    File      : none Output\n    Arguments : ierr      : open error status (0 = OK, nonzero = ERROR)\n    Terminal  : none\n    File      : none Invocation  : CALL io_open(iu, fname, fopenstat, fmt, ierr) Notes       : Adapted from Hal Levison's Swift routine io_open.F\n                David A. Minton: This subroutine is a classic example of the \"inner-platform effect\" and should be removed. Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~io_open.f90~~EfferentGraph sourcefile~io_open.f90 io_open.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~io_open.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io_open.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines io_open Source Code io_open.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : io_open !  Unit Type   : subroutine !  Project     : Swifter !  Package     : io !  Language    : Fortran 90/95 ! !  Description : Open a file ! !  Input !    Arguments : iu        : unit number with which to open file !                fname     : name of file to open !                fopenstat : status with which to open file !                fmt       : format string !    Terminal  : none !    File      : none ! !  Output !    Arguments : ierr      : open error status (0 = OK, nonzero = ERROR) !    Terminal  : none !    File      : none ! !  Invocation  : CALL io_open(iu, fname, fopenstat, fmt, ierr) ! !  Notes       : Adapted from Hal Levison's Swift routine io_open.F !                David A. Minton: This subroutine is a classic example of the \"inner-platform effect\" and should be removed. !********************************************************************************************************************************** SUBROUTINE io_open ( iu , fname , fopenstat , fmt , ierr ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => io_open IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: iu INTEGER ( I4B ), INTENT ( OUT ) :: ierr CHARACTER ( * ), INTENT ( IN ) :: fname , fopenstat , fmt ! Internals CHARACTER ( STRMAX ) :: fostat ! Executable code fostat = TRIM ( ADJUSTL ( fopenstat )) CALL util_toupper ( fostat ) IF ( fostat == \"APPEND\" ) THEN OPEN ( UNIT = iu , FILE = fname , STATUS = \"OLD\" , POSITION = fostat , FORM = fmt , IOSTAT = ierr ) ELSE OPEN ( UNIT = iu , FILE = fname , STATUS = fostat , FORM = fmt , IOSTAT = ierr ) END IF RETURN END SUBROUTINE io_open !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/io_open.f90.html"},{"title":"io_open_fxdr.f90 – swiftest","text":"Unit Name   : io_open_fxdr\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : io\n  Language    : Fortran 90/95 Description : Open an XDR formatted file using FXDR routines Input\n    Arguments : fname     : name of file to open\n                fopenstat : status with which to open file\n                lflag     : logical flag indicating behavior to exhibit on error (.TRUE. = return, .FALSE. = stop)\n    Terminal  : none\n    File      : none Output\n    Arguments : iu        : unit number of open file\n                ierr      : open error status (0 = OK, nonzero = ERROR)\n    Terminal  : none\n    File      : none Invocation  : CALL io_open_fxdr(fname, fopenstat, lflag, iu, ierr) Notes       : Adapted from Hal Levison's Swift routine io_open_fxdr.F Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~io_open_fxdr.f90~~EfferentGraph sourcefile~io_open_fxdr.f90 io_open_fxdr.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~io_open_fxdr.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io_open_fxdr.f90->sourcefile~swiftest.f90 sourcefile~module_fxdr.f90 module_fxdr.f90 sourcefile~io_open_fxdr.f90->sourcefile~module_fxdr.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines io_open_fxdr Source Code io_open_fxdr.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : io_open_fxdr !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : io !  Language    : Fortran 90/95 ! !  Description : Open an XDR formatted file using FXDR routines ! !  Input !    Arguments : fname     : name of file to open !                fopenstat : status with which to open file !                lflag     : logical flag indicating behavior to exhibit on error (.TRUE. = return, .FALSE. = stop) !    Terminal  : none !    File      : none ! !  Output !    Arguments : iu        : unit number of open file !                ierr      : open error status (0 = OK, nonzero = ERROR) !    Terminal  : none !    File      : none ! !  Invocation  : CALL io_open_fxdr(fname, fopenstat, lflag, iu, ierr) ! !  Notes       : Adapted from Hal Levison's Swift routine io_open_fxdr.F ! !********************************************************************************************************************************** SUBROUTINE io_open_fxdr ( fname , fopenstat , lflag , iu , ierr ) ! Modules USE swiftest USE module_fxdr USE module_interfaces , EXCEPT_THIS_ONE => io_open_fxdr IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( IN ) :: lflag INTEGER ( I4B ), INTENT ( OUT ) :: iu , ierr CHARACTER ( * ), INTENT ( IN ) :: fname CHARACTER ( 1 ), INTENT ( IN ) :: fopenstat ! Executable code iu = initxdr ( fname , fopenstat , lflag ) IF ( iu >= 0 ) THEN ierr = 0 ELSE ierr = iu END IF RETURN END SUBROUTINE io_open_fxdr !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/io_open_fxdr.f90.html"},{"title":"io_init_tp.f90 – swiftest","text":"Unit Name   : io_init_tp\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : io\n  Language    : Fortran 90/95 Description : Read in test particle data Input\n    Arguments : intpfile     : name of input file for test particles\n                in_type      : format of input data file\n                ntp          : number of active test particles\n                swifter_tp1P : pointer to head of active Swifter test particle structure linked-list\n    Terminal  : none\n    File      : id           : test particle identifier (all test particles)\n                xh           : heliocentric position    (all test particles)\n                vh           : heliocentric velocity    (all test particles) Output\n    Arguments : swifter_tp1P : pointer to head of active Swifter test particle structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL io_init_tp(intpfile, in_type, ntp, swifter_tp1P) Notes       : Adapted from Martin Duncan's Swift routine io_init_tp.f Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~io_init_tp.f90~~EfferentGraph sourcefile~io_init_tp.f90 io_init_tp.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~io_init_tp.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~io_init_tp.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~io_init_tp.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~io_init_tp.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io_init_tp.f90->sourcefile~swiftest.f90 sourcefile~module_fxdr.f90 module_fxdr.f90 sourcefile~io_init_tp.f90->sourcefile~module_fxdr.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines io_init_tp Source Code io_init_tp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : io_init_tp !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : io !  Language    : Fortran 90/95 ! !  Description : Read in test particle data ! !  Input !    Arguments : intpfile     : name of input file for test particles !                in_type      : format of input data file !                ntp          : number of active test particles !                swifter_tp1P : pointer to head of active Swifter test particle structure linked-list !    Terminal  : none !    File      : id           : test particle identifier (all test particles) !                xh           : heliocentric position    (all test particles) !                vh           : heliocentric velocity    (all test particles) ! !  Output !    Arguments : swifter_tp1P : pointer to head of active Swifter test particle structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL io_init_tp(intpfile, in_type, ntp, swifter_tp1P) ! !  Notes       : Adapted from Martin Duncan's Swift routine io_init_tp.f ! !********************************************************************************************************************************** SUBROUTINE io_init_tp ( intpfile , in_type , ntp , symba_tpA ) ! Modules USE swiftest USE module_symba USE module_helio USE module_swiftest USE module_fxdr USE module_interfaces , EXCEPT_THIS_ONE => io_init_tp IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: ntp CHARACTER ( * ), INTENT ( IN ) :: intpfile , in_type TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA ! Internals INTEGER ( I4B ), PARAMETER :: LUN = 7 INTEGER ( I4B ) :: i , iu , ierr , intp ! Executable code IF ( ntp == 0 ) RETURN IF ( in_type == \"ASCII\" ) THEN CALL io_open ( LUN , intpfile , \"OLD\" , \"FORMATTED\" , ierr ) READ ( LUN , * ) intp DO i = 1 , ntp READ ( LUN , * ) symba_tpA % helio % swiftest % name ( i ) READ ( LUN , * ) symba_tpA % helio % swiftest % xh (:, i ) READ ( LUN , * ) symba_tpA % helio % swiftest % vh (:, i ) symba_tpA % helio % swiftest % status ( i ) = ACTIVE END DO CLOSE ( UNIT = LUN ) ELSE CALL io_open_fxdr ( intpfile , \"R\" , . TRUE ., iu , ierr ) ierr = ixdrint ( iu , intp ) DO i = 1 , ntp ierr = ixdrint ( iu , symba_tpA % helio % swiftest % name ( i )) ierr = ixdrdmat ( iu , NDIM , symba_tpA % helio % swiftest % xh (:, i )) ierr = ixdrdmat ( iu , NDIM , symba_tpA % helio % swiftest % vh (:, i )) symba_tpA % helio % swiftest % status ( i ) = ACTIVE END DO ierr = ixdrclose ( iu ) END IF RETURN END SUBROUTINE io_init_tp !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/io_init_tp.f90.html"},{"title":"io_dump_pl.f90 – swiftest","text":"Unit Name   : io_dump_pl\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : io\n  Language    : Fortran 90/95 Description : Dump planet data to file Input\n    Arguments : npl            : number of planets\n                swifter_pl1P   : pointer to head of Swifter planet structure linked-list\n                lclose         : logical flag indicating whether to check for planet-test particle encounters\n                lrhill_present : logical flag indicating whether Hill's sphere radii are present in planet data\n    Terminal  : none\n    File      : none Output\n    Arguments : none\n    Terminal  : error message\n    File      : to dump file\n                npl            : number of planets\n                id             : planet identifier     (from planet structure, for each planet)\n                mass           : mass                  (from planet structure, for each planet)\n                rhill          : Hill's sphere radius  (from planet structure, for each planet except the Sun, if lrhill_present)\n                radius         : planet radius         (from planet structure, for each planet except the Sun, if lclose)\n                xh             : heliocentric position (from planet structure, for each planet)\n                vh             : heliocentric velocity (from planet structure, for each planet) Invocation  : CALL io_dump_pl(npl, swifter_pl1P, lclose, lrhill_present) Notes       : Adapted from Martin Duncan's Swift routine io_dump_pl.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~io_dump_pl.f90~~EfferentGraph sourcefile~io_dump_pl.f90 io_dump_pl.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~io_dump_pl.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~io_dump_pl.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io_dump_pl.f90->sourcefile~swiftest.f90 sourcefile~module_fxdr.f90 module_fxdr.f90 sourcefile~io_dump_pl.f90->sourcefile~module_fxdr.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines io_dump_pl Source Code io_dump_pl.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : io_dump_pl !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : io !  Language    : Fortran 90/95 ! !  Description : Dump planet data to file ! !  Input !    Arguments : npl            : number of planets !                swifter_pl1P   : pointer to head of Swifter planet structure linked-list !                lclose         : logical flag indicating whether to check for planet-test particle encounters !                lrhill_present : logical flag indicating whether Hill's sphere radii are present in planet data !    Terminal  : none !    File      : none ! !  Output !    Arguments : none !    Terminal  : error message !    File      : to dump file !                npl            : number of planets !                id             : planet identifier     (from planet structure, for each planet) !                mass           : mass                  (from planet structure, for each planet) !                rhill          : Hill's sphere radius  (from planet structure, for each planet except the Sun, if lrhill_present) !                radius         : planet radius         (from planet structure, for each planet except the Sun, if lclose) !                xh             : heliocentric position (from planet structure, for each planet) !                vh             : heliocentric velocity (from planet structure, for each planet) ! !  Invocation  : CALL io_dump_pl(npl, swifter_pl1P, lclose, lrhill_present) ! !  Notes       : Adapted from Martin Duncan's Swift routine io_dump_pl.f ! !********************************************************************************************************************************** SUBROUTINE io_dump_pl ( npl , swiftest_plA , lclose , lrhill_present ) ! Modules USE swiftest USE module_swiftest USE module_fxdr USE module_interfaces , EXCEPT_THIS_ONE => io_dump_pl IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( IN ) :: lclose , lrhill_present INTEGER ( I4B ), INTENT ( IN ) :: npl TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA ! Internals INTEGER ( I4B ) :: i , iu , ierr INTEGER ( I4B ), SAVE :: idx = 1 ! Executable code CALL io_open_fxdr ( DUMP_PL_FILE ( idx ), \"W\" , . TRUE ., iu , ierr ) IF ( ierr /= 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to open binary dump file \" , TRIM ( DUMP_PL_FILE ( idx )) CALL util_exit ( FAILURE ) END IF ierr = ixdrint ( iu , npl ) ierr = ixdrint ( iu , swiftest_plA % name ( 1 )) ierr = ixdrdouble ( iu , swiftest_plA % mass ( 1 )) ierr = ixdrdmat ( iu , NDIM , swiftest_plA % xh (:, 1 )) ierr = ixdrdmat ( iu , NDIM , swiftest_plA % vh (:, 1 )) DO i = 2 , npl ierr = ixdrint ( iu , swiftest_plA % name ( i )) ierr = ixdrdouble ( iu , swiftest_plA % mass ( i )) IF ( lrhill_present ) ierr = ixdrdouble ( iu , swiftest_plA % rhill ( i )) IF ( lclose ) ierr = ixdrdouble ( iu , swiftest_plA % radius ( i )) ierr = ixdrdmat ( iu , NDIM , swiftest_plA % xh (:, i )) ierr = ixdrdmat ( iu , NDIM , swiftest_plA % vh (:, i )) END DO ierr = ixdrclose ( iu ) idx = idx + 1 IF ( idx > 2 ) idx = 1 RETURN END SUBROUTINE io_dump_pl !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/io_dump_pl.f90.html"},{"title":"io_getn.f90 – swiftest","text":"Unit Name   : io_getn\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : io\n  Language    : Fortran 90/95 Description : Read the number of planets and test particles from respective input files Input\n    Arguments : inplfile : name of input file for planets\n                intpfile : name of input file for test particles\n                in_type  : format of input data files\n                nplmax   : maximum allowed number of planets\n                ntpmax   : maximum allowed number of test particles\n    Terminal  : none\n    File      : npl      : number of planets\n                ntp      : number of active test particles Output\n    Arguments : npl      : number of planets\n                ntp      : number of active test particles\n                nplmax   : maximum allowed number of planets\n                ntpmax   : maximum allowed number of test particles\n    Terminal  : error, warning messages\n    File      : none Invocation  : CALL io_getn(inplfile, intpfile, in_type, npl, nplmax, ntp, ntpmax) Notes       : nplmax (ntpmax) is reset to npl (ntp) if the latter exceeds the former Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~io_getn.f90~~EfferentGraph sourcefile~io_getn.f90 io_getn.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~io_getn.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io_getn.f90->sourcefile~swiftest.f90 sourcefile~module_fxdr.f90 module_fxdr.f90 sourcefile~io_getn.f90->sourcefile~module_fxdr.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines io_getn Source Code io_getn.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : io_getn !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : io !  Language    : Fortran 90/95 ! !  Description : Read the number of planets and test particles from respective input files ! !  Input !    Arguments : inplfile : name of input file for planets !                intpfile : name of input file for test particles !                in_type  : format of input data files !                nplmax   : maximum allowed number of planets !                ntpmax   : maximum allowed number of test particles !    Terminal  : none !    File      : npl      : number of planets !                ntp      : number of active test particles ! !  Output !    Arguments : npl      : number of planets !                ntp      : number of active test particles !                nplmax   : maximum allowed number of planets !                ntpmax   : maximum allowed number of test particles !    Terminal  : error, warning messages !    File      : none ! !  Invocation  : CALL io_getn(inplfile, intpfile, in_type, npl, nplmax, ntp, ntpmax) ! !  Notes       : nplmax (ntpmax) is reset to npl (ntp) if the latter exceeds the former ! !********************************************************************************************************************************** SUBROUTINE io_getn ( inplfile , intpfile , in_type , npl , nplmax , ntp , ntpmax ) ! Modules USE swiftest USE module_fxdr USE module_interfaces , EXCEPT_THIS_ONE => io_getn IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( INOUT ) :: nplmax , ntpmax INTEGER ( I4B ), INTENT ( OUT ) :: npl , ntp CHARACTER ( * ), INTENT ( IN ) :: inplfile , intpfile , in_type ! Internals INTEGER ( I4B ), PARAMETER :: LUN = 7 INTEGER ( I4B ) :: iu , ierr ! Executable code npl = 0 IF ( in_type == \"ASCII\" ) THEN CALL io_open ( LUN , inplfile , \"OLD\" , \"FORMATTED\" , ierr ) READ ( LUN , * ) npl CLOSE ( UNIT = LUN ) ELSE CALL io_open_fxdr ( inplfile , \"R\" , . TRUE ., iu , ierr ) ierr = ixdrint ( iu , npl ) ierr = ixdrclose ( iu ) END IF IF ( npl < 1 ) THEN WRITE ( * , * ) \"Error: the number of planets, \" , npl , \",\" WRITE ( * , * ) \"       must be at least 1\" CALL util_exit ( FAILURE ) ELSE IF (( npl > nplmax ) . AND . . NOT . ( nplmax < 0 )) THEN WRITE ( * , * ) \"Warning: the number of planets, \" , npl , \",\" WRITE ( * , * ) \"         exceeds the specified maximum number of planets, \" , nplmax WRITE ( * , * ) \"         ...resetting nplmax to \" , npl nplmax = npl ELSE IF ( nplmax < 0 ) THEN nplmax = npl END IF ntp = 0 IF ( intpfile /= \"\" ) THEN IF ( in_type == \"ASCII\" ) THEN CALL io_open ( LUN , intpfile , \"OLD\" , \"FORMATTED\" , ierr ) READ ( LUN , * ) ntp CLOSE ( UNIT = LUN ) ELSE CALL io_open_fxdr ( intpfile , \"R\" , . TRUE ., iu , ierr ) ierr = ixdrint ( iu , ntp ) ierr = ixdrclose ( iu ) END IF IF ( ntp < 0 ) THEN WRITE ( * , * ) \"Error: the number of test particles, \" , ntp , \",\" WRITE ( * , * ) \"       must be at least 0\" CALL util_exit ( FAILURE ) ELSE IF (( ntp > ntpmax ) . AND . . NOT . ( ntpmax < 0 )) THEN WRITE ( * , * ) \"Warning: the number of test particles, \" , ntp , \",\" WRITE ( * , * ) \"         exceeds the specified maximum number of test particles, \" , ntpmax WRITE ( * , * ) \"         ...resetting ntpmax to \" , ntp ntpmax = ntp ELSE IF ( ntpmax < 0 ) THEN ntpmax = ntp END IF END IF RETURN END SUBROUTINE io_getn !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/io_getn.f90.html"},{"title":"io_read_encounter.f90 – swiftest","text":"Unit Name   : io_read_encounter\n  Unit Type   : function\n  Project     : Swifter\n  Package     : io\n  Language    : Fortran 90/95 Description : Read close encounter data from input binary file Input\n    Arguments : encounter_file : name of input binary file for encounters\n                out_type       : format of input binary file\n    Terminal  : none\n    File      : t              : time Output\n    Arguments : t              : time\n                id1            : identifier of first planet / particle\n                id2            : identifier of second planet / particle\n                mass1          : mass of first planet / particle\n                mass2          : mass of second planet / particle\n                xh1            : heliocentric position of first planet / particle\n                xh2            : heliocentric position of second planet / particle\n                vh1            : heliocentric velocity of first planet / particle\n                vh2            : heliocentric velocity of second planet / particle\n    Terminal  : error message\n    File      : none Invocation  : istat = io_read_encounter(t, id1, id2, mass1, mass2, xh1, xh2, vh1, vh2, encounter_file, out_type) Notes       : Other than time t, there is no direct file input from this function Function returns read error status (0 = OK, nonzero = ERROR) Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~io_read_encounter.f90~~EfferentGraph sourcefile~io_read_encounter.f90 io_read_encounter.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~io_read_encounter.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io_read_encounter.f90->sourcefile~swiftest.f90 sourcefile~module_fxdr.f90 module_fxdr.f90 sourcefile~io_read_encounter.f90->sourcefile~module_fxdr.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Functions io_read_encounter Source Code io_read_encounter.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : io_read_encounter !  Unit Type   : function !  Project     : Swifter !  Package     : io !  Language    : Fortran 90/95 ! !  Description : Read close encounter data from input binary file ! !  Input !    Arguments : encounter_file : name of input binary file for encounters !                out_type       : format of input binary file !    Terminal  : none !    File      : t              : time ! !  Output !    Arguments : t              : time !                id1            : identifier of first planet / particle !                id2            : identifier of second planet / particle !                mass1          : mass of first planet / particle !                mass2          : mass of second planet / particle !                xh1            : heliocentric position of first planet / particle !                xh2            : heliocentric position of second planet / particle !                vh1            : heliocentric velocity of first planet / particle !                vh2            : heliocentric velocity of second planet / particle !    Terminal  : error message !    File      : none ! !  Invocation  : istat = io_read_encounter(t, id1, id2, mass1, mass2, xh1, xh2, vh1, vh2, encounter_file, out_type) ! !  Notes       : Other than time t, there is no direct file input from this function ! !                Function returns read error status (0 = OK, nonzero = ERROR) ! !********************************************************************************************************************************** FUNCTION io_read_encounter ( t , name1 , name2 , mass1 , mass2 , xh1 , xh2 , vh1 , vh2 , encounter_file , out_type ) ! Modules USE swiftest USE module_fxdr USE module_interfaces , EXCEPT_THIS_ONE => io_read_encounter IMPLICIT NONE ! Arguments INTEGER ( I4B ) :: io_read_encounter INTEGER ( I4B ), INTENT ( OUT ) :: name1 , name2 REAL ( DP ), INTENT ( OUT ) :: t , mass1 , mass2 REAL ( DP ), DIMENSION ( NDIM ), INTENT ( OUT ) :: xh1 , xh2 , vh1 , vh2 CHARACTER ( * ), INTENT ( IN ) :: encounter_file , out_type ! Internals LOGICAL ( LGT ) :: lxdr LOGICAL ( LGT ), SAVE :: lfirst = . TRUE . INTEGER ( I4B ), PARAMETER :: LUN = 30 INTEGER ( I4B ) :: ierr INTEGER ( I4B ), SAVE :: iu = LUN ! Executable code lxdr = (( out_type == XDR4_TYPE ) . OR . ( out_type == XDR8_TYPE )) IF ( lfirst ) THEN IF ( lxdr ) THEN CALL io_open_fxdr ( encounter_file , \"R\" , . TRUE ., iu , ierr ) ELSE CALL io_open ( iu , encounter_file , \"OLD\" , \"UNFORMATTED\" , ierr ) END IF IF ( ierr /= 0 ) THEN WRITE ( * , * ) \"SWIFTER Error:\" WRITE ( * , * ) \"   Unable to open binary encounter file\" CALL util_exit ( FAILURE ) END IF lfirst = . FALSE . END IF IF ( lxdr ) THEN ierr = ixdrdouble ( iu , t ) io_read_encounter = ierr IF ( ierr /= 0 ) THEN ierr = ixdrclose ( iu ) RETURN END IF ierr = io_read_line ( iu , name1 , xh1 ( 1 ), xh1 ( 2 ), xh1 ( 3 ), vh1 ( 1 ), vh1 ( 2 ), vh1 ( 3 ), XDR8_TYPE , MASS = mass1 ) io_read_encounter = ierr IF ( ierr /= 0 ) THEN ierr = ixdrclose ( iu ) RETURN END IF ierr = io_read_line ( iu , name2 , xh2 ( 1 ), xh2 ( 2 ), xh2 ( 3 ), vh2 ( 1 ), vh2 ( 2 ), vh2 ( 3 ), XDR8_TYPE , MASS = mass2 ) io_read_encounter = ierr IF ( ierr /= 0 ) THEN ierr = ixdrclose ( iu ) RETURN END IF ELSE READ ( iu , IOSTAT = ierr ) t io_read_encounter = ierr IF ( ierr /= 0 ) THEN CLOSE ( UNIT = iu , IOSTAT = ierr ) RETURN END IF ierr = io_read_line ( iu , name1 , xh1 ( 1 ), xh1 ( 2 ), xh1 ( 3 ), vh1 ( 1 ), vh1 ( 2 ), vh1 ( 3 ), REAL8_TYPE , MASS = mass1 ) io_read_encounter = ierr IF ( ierr /= 0 ) THEN CLOSE ( UNIT = iu , IOSTAT = ierr ) RETURN END IF ierr = io_read_line ( iu , name2 , xh2 ( 1 ), xh2 ( 2 ), xh2 ( 3 ), vh2 ( 1 ), vh2 ( 2 ), vh2 ( 3 ), REAL8_TYPE , MASS = mass2 ) io_read_encounter = ierr IF ( ierr /= 0 ) THEN CLOSE ( UNIT = iu , IOSTAT = ierr ) RETURN END IF END IF RETURN END FUNCTION io_read_encounter !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/io_read_encounter.f90.html"},{"title":"io_write_encounter.f90 – swiftest","text":"Unit Name   : io_write_encounter\n  Unit Type   : subroutine\n  Project     : Swifter\n  Package     : io\n  Language    : Fortran 90/95 Description : Write close encounter data to output binary file Input\n    Arguments : t              : time\n                id1            : identifier of first planet / particle\n                id2            : identifier of second planet / particle\n                mass1          : mass of first planet / particle\n                mass2          : mass of second planet / particle\n                radius1        : radius of first planet / particle\n                radius2        : radius of second planet / particle\n                xh1            : heliocentric position of first planet / particle\n                xh2            : heliocentric position of second planet / particle\n                vh1            : heliocentric velocity of first planet / particle\n                vh2            : heliocentric velocity of second planet / particle\n                encounter_file : name of output binary file for encounters\n                out_type       : format of output binary file\n    Terminal  : none\n    File      : none Output\n    Arguments : none\n    Terminal  : error message\n    File      : none Invocation  : CALL io_write_encounter(t, id1, id2, mass1, mass2, radius1, radius2, xh1, xh2, vh1, vh2, encounter_file, out_type) Notes       : There is no direct file output from this subroutine Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~io_write_encounter.f90~~EfferentGraph sourcefile~io_write_encounter.f90 io_write_encounter.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~io_write_encounter.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io_write_encounter.f90->sourcefile~swiftest.f90 sourcefile~module_fxdr.f90 module_fxdr.f90 sourcefile~io_write_encounter.f90->sourcefile~module_fxdr.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines io_write_encounter Source Code io_write_encounter.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : io_write_encounter !  Unit Type   : subroutine !  Project     : Swifter !  Package     : io !  Language    : Fortran 90/95 ! !  Description : Write close encounter data to output binary file ! !  Input !    Arguments : t              : time !                id1            : identifier of first planet / particle !                id2            : identifier of second planet / particle !                mass1          : mass of first planet / particle !                mass2          : mass of second planet / particle !                radius1        : radius of first planet / particle !                radius2        : radius of second planet / particle !                xh1            : heliocentric position of first planet / particle !                xh2            : heliocentric position of second planet / particle !                vh1            : heliocentric velocity of first planet / particle !                vh2            : heliocentric velocity of second planet / particle !                encounter_file : name of output binary file for encounters !                out_type       : format of output binary file !    Terminal  : none !    File      : none ! !  Output !    Arguments : none !    Terminal  : error message !    File      : none ! !  Invocation  : CALL io_write_encounter(t, id1, id2, mass1, mass2, radius1, radius2, xh1, xh2, vh1, vh2, encounter_file, out_type) ! !  Notes       : There is no direct file output from this subroutine ! !********************************************************************************************************************************** SUBROUTINE io_write_encounter ( t , name1 , name2 , mass1 , mass2 , radius1 , radius2 , xh1 , xh2 , vh1 , vh2 , encounter_file , out_type ) ! Modules USE swiftest USE module_fxdr USE module_interfaces , EXCEPT_THIS_ONE => io_write_encounter IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: name1 , name2 REAL ( DP ), INTENT ( IN ) :: t , mass1 , mass2 , radius1 , radius2 REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: xh1 , xh2 , vh1 , vh2 CHARACTER ( * ), INTENT ( IN ) :: encounter_file , out_type ! Internals LOGICAL ( LGT ) :: lxdr LOGICAL ( LGT ), SAVE :: lfirst = . TRUE . INTEGER ( I4B ), PARAMETER :: LUN = 30 INTEGER ( I4B ) :: ierr INTEGER ( I4B ), SAVE :: iu = LUN ! Executable code lxdr = (( out_type == XDR4_TYPE ) . OR . ( out_type == XDR8_TYPE )) IF ( lxdr ) THEN CALL io_open_fxdr ( encounter_file , \"A\" , . TRUE ., iu , ierr ) IF (( ierr /= 0 ) . AND . lfirst ) THEN CALL io_open_fxdr ( encounter_file , \"W\" , . TRUE ., iu , ierr ) lfirst = . FALSE . END IF IF ( ierr /= 0 ) THEN WRITE ( * , * ) \"SWIFTER Error:\" WRITE ( * , * ) \"   Unable to open binary encounter file\" CALL util_exit ( FAILURE ) END IF ierr = ixdrdouble ( iu , t ) IF ( ierr < 0 ) THEN WRITE ( * , * ) \"SWIFTER Error:\" WRITE ( * , * ) \"   Unable to write binary file record\" CALL util_exit ( FAILURE ) END IF CALL io_write_line ( iu , name1 , xh1 ( 1 ), xh1 ( 2 ), xh1 ( 3 ), vh1 ( 1 ), vh1 ( 2 ), vh1 ( 3 ), XDR8_TYPE , MASS = mass1 , RADIUS = radius1 ) CALL io_write_line ( iu , name2 , xh2 ( 1 ), xh2 ( 2 ), xh2 ( 3 ), vh2 ( 1 ), vh2 ( 2 ), vh2 ( 3 ), XDR8_TYPE , MASS = mass2 , RADIUS = radius2 ) ierr = ixdrclose ( iu ) ELSE CALL io_open ( iu , encounter_file , \"APPEND\" , \"UNFORMATTED\" , ierr ) IF (( ierr /= 0 ) . AND . lfirst ) THEN CALL io_open ( iu , encounter_file , \"NEW\" , \"UNFORMATTED\" , ierr ) lfirst = . FALSE . END IF IF ( ierr /= 0 ) THEN WRITE ( * , * ) \"SWIFTER Error:\" WRITE ( * , * ) \"   Unable to open binary encounter file\" CALL util_exit ( FAILURE ) END IF WRITE ( iu , IOSTAT = ierr ) t IF ( ierr < 0 ) THEN WRITE ( * , * ) \"SWIFTER Error:\" WRITE ( * , * ) \"   Unable to write binary file record\" CALL util_exit ( FAILURE ) END IF CALL io_write_line ( iu , name1 , xh1 ( 1 ), xh1 ( 2 ), xh1 ( 3 ), vh1 ( 1 ), vh1 ( 2 ), vh1 ( 3 ), REAL8_TYPE , MASS = mass1 , RADIUS = radius1 ) CALL io_write_line ( iu , name2 , xh2 ( 1 ), xh2 ( 2 ), xh2 ( 3 ), vh2 ( 1 ), vh2 ( 2 ), vh2 ( 3 ), REAL8_TYPE , MASS = mass2 , RADIUS = radius2 ) CLOSE ( UNIT = iu , IOSTAT = ierr ) END IF IF ( ierr /= 0 ) THEN WRITE ( * , * ) \"SWIFTER Error:\" WRITE ( * , * ) \"   Unable to close binary encounter file\" CALL util_exit ( FAILURE ) END IF RETURN END SUBROUTINE io_write_encounter !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/io_write_encounter.f90.html"},{"title":"io_write_line.f90 – swiftest","text":"Unit Name   : io_write_line\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : io\n  Language    : Fortran 90/95 Description : Write a line (record) to output binary file Input\n    Arguments : iu       : unit number associated with output binary file\n                id       : planet or test particle identifier\n                d1       : first quantity to write  (semimajor axis (pericentric distance for a parabola) or heliocentric x )\n                d2       : second quantity to write (eccentricity                                         or heliocentric y )\n                d3       : third quantity to write  (inclination                                          or heliocentric z )\n                d4       : fourth quantity to write (longitude of the ascending node                      or heliocentric vx)\n                d5       : fifth quantity to write  (argument of pericenter                               or heliocentric vy)\n                d6       : sixth quantity to write  (mean anomaly                                         or heliocentric vz)\n                out_type : format of output binary file\n                MASS     : optional mass (omitted for massless test particle)\n                RADIUS   : optional radius (omitted for massless test particle; must be present if optional MASS is present)\n    Terminal  : none\n    File      : none Output\n    Arguments : none\n    Terminal  : error message\n    File      : id                   : planet or test particle identifier\n                smass (or dmass)     : optional mass (omitted for massless test particle)\n                sradius (or dradius) : optional radius (omitted for massless test particle)\n                svec (or dvec)       : 6-vector of orbital elements or position and velocity components Invocation  : CALL io_write_line(iu, id, d1, d2, d3, d4, d5, d6, out_type, MASS, RADIUS) Notes       : Adapted from Hal Levison's Swift routine io_write_line.F Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~io_write_line.f90~~EfferentGraph sourcefile~io_write_line.f90 io_write_line.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~io_write_line.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io_write_line.f90->sourcefile~swiftest.f90 sourcefile~module_fxdr.f90 module_fxdr.f90 sourcefile~io_write_line.f90->sourcefile~module_fxdr.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines io_write_line Source Code io_write_line.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : io_write_line !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : io !  Language    : Fortran 90/95 ! !  Description : Write a line (record) to output binary file ! !  Input !    Arguments : iu       : unit number associated with output binary file !                id       : planet or test particle identifier !                d1       : first quantity to write  (semimajor axis (pericentric distance for a parabola) or heliocentric x ) !                d2       : second quantity to write (eccentricity                                         or heliocentric y ) !                d3       : third quantity to write  (inclination                                          or heliocentric z ) !                d4       : fourth quantity to write (longitude of the ascending node                      or heliocentric vx) !                d5       : fifth quantity to write  (argument of pericenter                               or heliocentric vy) !                d6       : sixth quantity to write  (mean anomaly                                         or heliocentric vz) !                out_type : format of output binary file !                MASS     : optional mass (omitted for massless test particle) !                RADIUS   : optional radius (omitted for massless test particle; must be present if optional MASS is present) !    Terminal  : none !    File      : none ! !  Output !    Arguments : none !    Terminal  : error message !    File      : id                   : planet or test particle identifier !                smass (or dmass)     : optional mass (omitted for massless test particle) !                sradius (or dradius) : optional radius (omitted for massless test particle) !                svec (or dvec)       : 6-vector of orbital elements or position and velocity components ! !  Invocation  : CALL io_write_line(iu, id, d1, d2, d3, d4, d5, d6, out_type, MASS, RADIUS) ! !  Notes       : Adapted from Hal Levison's Swift routine io_write_line.F ! !********************************************************************************************************************************** SUBROUTINE io_write_line ( iu , name , d1 , d2 , d3 , d4 , d5 , d6 , out_type , MASS , RADIUS ) ! Modules USE swiftest USE module_fxdr USE module_interfaces , EXCEPT_THIS_ONE => io_write_line IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: iu , name REAL ( DP ), INTENT ( IN ) :: d1 , d2 , d3 , d4 , d5 , d6 REAL ( DP ), OPTIONAL , INTENT ( IN ) :: MASS , RADIUS CHARACTER ( * ), INTENT ( IN ) :: out_type ! Internals INTEGER ( I4B ) :: ierr REAL ( DP ), DIMENSION ( 6 ) :: dvec REAL ( SP ), DIMENSION ( 6 ) :: svec REAL ( SP ) :: smass , sradius LOGICAL ( LGT ) :: lmass , lradius ! Executable code dvec ( 1 ) = d1 ; dvec ( 2 ) = d2 ; dvec ( 3 ) = d3 ; dvec ( 4 ) = d4 ; dvec ( 5 ) = d5 ; dvec ( 6 ) = d6 svec ( 1 ) = d1 ; svec ( 2 ) = d2 ; svec ( 3 ) = d3 ; svec ( 4 ) = d4 ; svec ( 5 ) = d5 ; svec ( 6 ) = d6 lmass = PRESENT ( MASS ) IF ( lmass ) THEN lradius = PRESENT ( RADIUS ) IF (. NOT . lradius ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Subroutine io_write_line called with optional MASS but without optional RADIUS\" CALL util_exit ( FAILURE ) END IF smass = MASS sradius = RADIUS END IF SELECT CASE ( out_type ) CASE ( REAL4_TYPE ) IF ( lmass ) THEN WRITE ( iu , IOSTAT = ierr ) name , smass , sradius , svec ELSE WRITE ( iu , IOSTAT = ierr ) name , svec END IF IF ( ierr < 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to write binary file record\" CALL util_exit ( FAILURE ) END IF CASE ( REAL8_TYPE ) IF ( lmass ) THEN WRITE ( iu , IOSTAT = ierr ) name , MASS , RADIUS , dvec ELSE WRITE ( iu , IOSTAT = ierr ) name , dvec END IF IF ( ierr < 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to write binary file record\" CALL util_exit ( FAILURE ) END IF CASE ( XDR4_TYPE ) ierr = ixdrint ( iu , name ) IF ( ierr < 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to write binary file record\" CALL util_exit ( FAILURE ) END IF IF ( lmass ) THEN ierr = ixdrreal ( iu , smass ) IF ( ierr < 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to write binary file record\" CALL util_exit ( FAILURE ) END IF ierr = ixdrreal ( iu , sradius ) IF ( ierr < 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to write binary file record\" CALL util_exit ( FAILURE ) END IF END IF ierr = ixdrrmat ( iu , 6 , svec ) IF ( ierr < 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to write binary file record\" CALL util_exit ( FAILURE ) END IF CASE ( XDR8_TYPE ) ierr = ixdrint ( iu , name ) IF ( ierr < 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to write binary file record\" CALL util_exit ( FAILURE ) END IF IF ( lmass ) THEN ierr = ixdrdouble ( iu , MASS ) IF ( ierr < 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to write binary file record\" CALL util_exit ( FAILURE ) END IF ierr = ixdrdouble ( iu , RADIUS ) IF ( ierr < 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to write binary file record\" CALL util_exit ( FAILURE ) END IF END IF ierr = ixdrdmat ( iu , 6 , dvec ) IF ( ierr < 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to write binary file record\" CALL util_exit ( FAILURE ) END IF END SELECT RETURN END SUBROUTINE io_write_line !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/io_write_line.f90.html"},{"title":"io_read_hdr.f90 – swiftest","text":"Unit Name   : io_read_hdr\n  Unit Type   : function\n  Project     : Swifter\n  Package     : io\n  Language    : Fortran 90/95 Description : Read frame header from input binary file Input\n    Arguments : iu        : unit number associated with input binary file\n                out_type  : format of input binary file\n    Terminal  : none\n    File      : t (or ttmp) : time\n                npl         : number of planets\n                ntp         : number of active test particles\n                iout_form   : specifier of data contained in input file (elements / heliocentric coordinates / filtered elements) Output\n    Arguments : t         : time\n                npl       : number of planets\n                ntp       : number of active test particles\n                iout_form : specifier of data contained in input file (elements / heliocentric coordinates / filtered elements)\n    Terminal  : none\n    File      : none Invocation  : istat = io_read_hdr(iu, t, npl, ntp, iout_form, out_type) Notes       : Adapted from Hal Levison's Swift routine io_read_hdr.F Function returns read error status (0 = OK, nonzero = ERROR) Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~io_read_hdr.f90~~EfferentGraph sourcefile~io_read_hdr.f90 io_read_hdr.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~io_read_hdr.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io_read_hdr.f90->sourcefile~swiftest.f90 sourcefile~module_fxdr.f90 module_fxdr.f90 sourcefile~io_read_hdr.f90->sourcefile~module_fxdr.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Functions io_read_hdr Source Code io_read_hdr.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : io_read_hdr !  Unit Type   : function !  Project     : Swifter !  Package     : io !  Language    : Fortran 90/95 ! !  Description : Read frame header from input binary file ! !  Input !    Arguments : iu        : unit number associated with input binary file !                out_type  : format of input binary file !    Terminal  : none !    File      : t (or ttmp) : time !                npl         : number of planets !                ntp         : number of active test particles !                iout_form   : specifier of data contained in input file (elements / heliocentric coordinates / filtered elements) ! !  Output !    Arguments : t         : time !                npl       : number of planets !                ntp       : number of active test particles !                iout_form : specifier of data contained in input file (elements / heliocentric coordinates / filtered elements) !    Terminal  : none !    File      : none ! !  Invocation  : istat = io_read_hdr(iu, t, npl, ntp, iout_form, out_type) ! !  Notes       : Adapted from Hal Levison's Swift routine io_read_hdr.F ! !                Function returns read error status (0 = OK, nonzero = ERROR) ! !********************************************************************************************************************************** FUNCTION io_read_hdr ( iu , t , npl , ntp , iout_form , out_type ) ! Modules USE swiftest USE module_fxdr USE module_interfaces , EXCEPT_THIS_ONE => io_read_hdr IMPLICIT NONE ! Arguments INTEGER ( I4B ) :: io_read_hdr INTEGER ( I4B ), INTENT ( IN ) :: iu INTEGER ( I4B ), INTENT ( OUT ) :: npl , ntp , iout_form REAL ( DP ), INTENT ( OUT ) :: t CHARACTER ( * ), INTENT ( IN ) :: out_type ! Internals INTEGER ( I4B ) :: ierr INTEGER ( I4B ), DIMENSION ( 3 ) :: nn REAL ( SP ) :: ttmp ! Executable code SELECT CASE ( out_type ) CASE ( REAL4_TYPE ) READ ( iu , IOSTAT = ierr ) ttmp , npl , ntp , iout_form io_read_hdr = ierr IF ( ierr /= 0 ) RETURN t = ttmp CASE ( REAL8_TYPE ) READ ( iu , IOSTAT = ierr ) t , npl , ntp , iout_form io_read_hdr = ierr CASE ( XDR4_TYPE ) ierr = ixdrreal ( iu , ttmp ) io_read_hdr = ierr IF ( ierr /= 0 ) RETURN t = ttmp ierr = ixdrimat ( iu , 3 , nn ) io_read_hdr = ierr IF ( ierr /= 0 ) RETURN npl = nn ( 1 ) ntp = nn ( 2 ) iout_form = nn ( 3 ) CASE ( XDR8_TYPE ) ierr = ixdrdouble ( iu , t ) io_read_hdr = ierr IF ( ierr /= 0 ) RETURN ierr = ixdrimat ( iu , 3 , nn ) io_read_hdr = ierr IF ( ierr /= 0 ) RETURN npl = nn ( 1 ) ntp = nn ( 2 ) iout_form = nn ( 3 ) END SELECT RETURN END FUNCTION io_read_hdr !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/io_read_hdr.f90.html"},{"title":"io_discard_write_symba.f90 – swiftest","text":"Unit Name   : io_discard_write_symba\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : io\n  Language    : Fortran 90/95 Description : Write out information about discarded and merged planets and test particles in SyMBA Input\n    Arguments : t             : time\n                mtiny         : smallest self-gravitating mass\n                npl           : number of planets\n                nsppl         : number of spilled planets\n                nsptp         : number of spilled test particles\n                nmergeadd     : number of merged planets to add\n                nmergesub     : number of merged planets to subtract\n                symba_pl1P    : pointer to head of SyMBA planet structure linked-list\n                symba_pld1P   : pointer to head of discard SyMBA planet structure linked-list\n                symba_tpd1P   : pointer to head of discard SyMBA test particle structure linked-list\n                mergeadd_list : array of structures of merged planets to add\n                mergesub_list : array of structures of merged planets to subtract\n                fname         : name of file to write\n                lbig_discard  : logical flag indicating whether to dump planet data with discards\n    Terminal  : none\n    File      : none Output\n    Arguments : none\n    Terminal  : error message\n    File      : discard data to discard file Invocation  : CALL io_discard_write_symba(t, mtiny, npl, nsppl, nsptp, nmergeadd, nmergesub, symba_pl1P, symba_pld1P,\n                                            symba_tpd1P, mergeadd_list, mergesub_list, fname, lbig_discard) Notes       : Adapted from Hal Levison's Swift routine io_discard_mass.f and io_discard_merge.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~io_discard_write_symba.f90~~EfferentGraph sourcefile~io_discard_write_symba.f90 io_discard_write_symba.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~io_discard_write_symba.f90->sourcefile~module_swiftest.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~io_discard_write_symba.f90->sourcefile~module_interfaces.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~io_discard_write_symba.f90->sourcefile~module_symba.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io_discard_write_symba.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines io_discard_write_symba Source Code io_discard_write_symba.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : io_discard_write_symba !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : io !  Language    : Fortran 90/95 ! !  Description : Write out information about discarded and merged planets and test particles in SyMBA ! !  Input !    Arguments : t             : time !                mtiny         : smallest self-gravitating mass !                npl           : number of planets !                nsppl         : number of spilled planets !                nsptp         : number of spilled test particles !                nmergeadd     : number of merged planets to add !                nmergesub     : number of merged planets to subtract !                symba_pl1P    : pointer to head of SyMBA planet structure linked-list !                symba_pld1P   : pointer to head of discard SyMBA planet structure linked-list !                symba_tpd1P   : pointer to head of discard SyMBA test particle structure linked-list !                mergeadd_list : array of structures of merged planets to add !                mergesub_list : array of structures of merged planets to subtract !                fname         : name of file to write !                lbig_discard  : logical flag indicating whether to dump planet data with discards !    Terminal  : none !    File      : none ! !  Output !    Arguments : none !    Terminal  : error message !    File      : discard data to discard file ! !  Invocation  : CALL io_discard_write_symba(t, mtiny, npl, nsppl, nsptp, nmergeadd, nmergesub, symba_pl1P, symba_pld1P, !                                            symba_tpd1P, mergeadd_list, mergesub_list, fname, lbig_discard) ! !  Notes       : Adapted from Hal Levison's Swift routine io_discard_mass.f and io_discard_merge.f ! !********************************************************************************************************************************** SUBROUTINE io_discard_write_symba ( t , mtiny , npl , ntp , nsppl , nsptp , nmergeadd , symba_plA , & discard_plA , discard_tpA , mergeadd_list , mergesub_list , fname , lbig_discard ) ! Modules USE swiftest USE module_swiftest USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => io_discard_write_symba IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( IN ) :: lbig_discard INTEGER ( I4B ), INTENT ( IN ) :: npl , ntp , nsppl , nsptp , nmergeadd REAL ( DP ), INTENT ( IN ) :: t , mtiny CHARACTER ( * ), INTENT ( IN ) :: fname TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( swiftest_tp ), INTENT ( INOUT ) :: discard_tpA TYPE ( swiftest_pl ), INTENT ( INOUT ) :: discard_plA TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list ! Internals INTEGER ( I4B ), PARAMETER :: LUN = 40 INTEGER ( I4B ) :: i , index , ncomp , ierr , nplm ! Executable code CALL io_open ( LUN , fname , \"APPEND\" , \"FORMATTED\" , ierr ) IF ( ierr /= 0 ) THEN CALL io_open ( LUN , fname , \"NEW\" , \"FORMATTED\" , ierr ) IF ( ierr /= 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to open discard output file, \" , fname CALL util_exit ( FAILURE ) END IF END IF WRITE ( LUN , 100 ) t , nsppl + nsptp + 2 * nmergeadd , lbig_discard 100 FORMAT ( E23 . 16 , 1 X , I8 , 1 X , L1 ) index = 0 DO i = 1 , nmergeadd WRITE ( LUN , 200 ) ADD , mergeadd_list % name ( i ), mergeadd_list % status ( i ) 200 FORMAT ( A , 2 ( 1 X , I8 )) WRITE ( LUN , 300 ) mergeadd_list % xh (:, i ) 300 FORMAT ( 3 ( E23 . 16 , 1 X )) WRITE ( LUN , 300 ) mergeadd_list % vh (:, i ) ncomp = mergeadd_list % ncomp ( i ) DO index = 1 , ncomp !j=0 -> index=1 !index = index + 1 WRITE ( LUN , 200 ) SUB , mergesub_list % name ( index ), mergesub_list % status ( index ) WRITE ( LUN , 300 ) mergesub_list % xh (:, index ) WRITE ( LUN , 300 ) mergesub_list % vh (:, index ) WRITE ( LUN , 500 ) mergesub_list % name ( index ), mergesub_list % mass ( index ), mergesub_list % radius ( index ) END DO END DO DO i = 1 , nsppl IF ( discard_plA % status ( i ) /= MERGED ) THEN WRITE ( LUN , 200 ) SUB , discard_plA % name ( i ), discard_plA % status ( i ) WRITE ( LUN , 300 ) discard_plA % xh ( 1 , i ), discard_plA % xh ( 2 , i ), discard_plA % xh ( 3 , i ) WRITE ( LUN , 300 ) discard_plA % vh ( 1 , i ), discard_plA % vh ( 2 , i ), discard_plA % vh ( 3 , i ) WRITE ( LUN , 500 ) discard_plA % name ( i ), discard_plA % mass ( i ), discard_plA % radius ( i ) END IF END DO DO i = 1 , nsptp WRITE ( LUN , 200 ) SUB , discard_tpA % name ( i ), discard_tpA % status ( i ) WRITE ( LUN , 300 ) discard_tpA % xh ( 1 , i ), discard_tpA % xh ( 2 , i ), discard_tpA % xh ( 3 , i ) WRITE ( LUN , 300 ) discard_tpA % vh ( 1 , i ), discard_tpA % vh ( 2 , i ), discard_tpA % vh ( 3 , i ) END DO IF ( lbig_discard ) THEN nplm = 0 DO i = 1 , npl IF ( symba_plA % helio % swiftest % mass ( i ) < mtiny ) EXIT nplm = nplm + 1 END DO IF ( nplm > 1 ) THEN WRITE ( LUN , 400 ) nplm 400 FORMAT ( I8 ) DO i = 2 , nplm WRITE ( LUN , 500 ) symba_plA % helio % swiftest % name ( i ), symba_plA % helio % swiftest % mass ( i ),& symba_plA % helio % swiftest % radius ( i ) 500 FORMAT ( I8 , 2 ( 1 X , E23 . 16 )) WRITE ( LUN , 300 ) symba_plA % helio % swiftest % xh (:, i ) WRITE ( LUN , 300 ) symba_plA % helio % swiftest % vh (:, i ) END DO END IF END IF CLOSE ( LUN ) RETURN END SUBROUTINE io_discard_write_symba !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/io_discard_write_symba.f90.html"},{"title":"io.f90 – swiftest","text":"This file depends on sourcefile~~io.f90~~EfferentGraph sourcefile~io.f90 io.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~io.f90->sourcefile~module_interfaces.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~io.f90->sourcefile~module_symba.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~io.f90~~AfferentGraph sourcefile~io.f90 io.f90 sourcefile~tool_encounter_read.f90 tool_encounter_read.f90 sourcefile~tool_encounter_read.f90->sourcefile~io.f90 sourcefile~io_read_param_in.f90 io_read_param_in.f90 sourcefile~io_read_param_in.f90->sourcefile~io.f90 sourcefile~io_read_pl_in.f90 io_read_pl_in.f90 sourcefile~io_read_pl_in.f90->sourcefile~io.f90 sourcefile~io_get_token.f90 io_get_token.f90 sourcefile~io_get_token.f90->sourcefile~io.f90 sourcefile~swiftest_symba.f90 swiftest_symba.f90 sourcefile~swiftest_symba.f90->sourcefile~io.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules io Source Code io.f90 Source Code module io !! author: David A. Minton !! todo: Replace XDR with HDF5 !! !! Module containing all input/output subroutine interface blocks use swiftest !> The following use statements are temporary until Swiftest module structure conversion is complete use module_interfaces use module_symba interface module function io_get_token ( buffer , ilength , ifirst , ilast , ierr ) result ( token ) character ( len =* ), intent ( in ) :: buffer !! Input string buffer integer ( I4B ), intent ( in ) :: ilength !! Length of input buffer string integer ( I4B ), intent ( inout ) :: ifirst !! Index of the buffer at which to start the search for a token integer ( I4B ), intent ( out ) :: ilast !! Index of the buffer at the end of the returned token integer ( I4B ), intent ( out ) :: ierr !! Error code character ( len = len ( buffer )) :: token !! Returned token string end function io_get_token module function io_read_param_in ( inparfile ) result ( param ) character ( * ), intent ( in ) :: inparfile !! Parameter input file name (typically param.in) type ( input_parameters ) :: param !! Output collection of user-defined parameters end function io_read_param_in module function io_read_pl_in ( param , npl , swiftest_plA ) result ( ierr ) type ( input_parameters ), intent ( in ) :: param !! Output collection of user-defined parameters integer ( I4B ), intent ( in ) :: npl !! Number of massive bodies type ( swiftest_pl ), intent ( inout ) :: swiftest_plA !! Swiftest data structure to store massive body initial conditions integer ( I4B ) :: ierr !! Error code end function io_read_pl_in end interface end module io","tags":"","loc":"sourcefile/io.f90.html"},{"title":"io_read_pl_in.f90 – swiftest","text":"This file depends on sourcefile~~io_read_pl_in.f90~~EfferentGraph sourcefile~io_read_pl_in.f90 io_read_pl_in.f90 sourcefile~io.f90 io.f90 sourcefile~io_read_pl_in.f90->sourcefile~io.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~io_read_pl_in.f90->sourcefile~module_symba.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io_read_pl_in.f90->sourcefile~swiftest.f90 sourcefile~io.f90->sourcefile~module_symba.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~io.f90->sourcefile~module_interfaces.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_io_read_pl_in Source Code io_read_pl_in.f90 Source Code submodule ( io ) s_io_read_pl_in contains module procedure io_read_pl_in !! author: The Purdue Swiftest Team -  David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Read in massive body data !! !! Adapted from David E. Kaufmann's Swifter routine io_init_pl.f90 !! Adapted from Martin Duncan's Swift routine io_init_pl.f use swiftest use module_symba !use module_helio !use module_swiftest !use module_fxdr !use module_interfaces implicit none integer ( I4B ), parameter :: LUN = 7 !! Unit number of input file integer ( I4B ) :: i , iu , inpl ierr = 0 open ( unit = LUN , file = param % inplfile , status = 'old' , iostat = ierr ) if ( ierr /= 0 ) then write ( * , * ) 'Error opening massive body initial conditions file ' , trim ( adjustl ( param % inplfile )) return end if read ( LUN , * , iostat = ierr ) inpl read ( LUN , * , iostat = ierr ) swiftest_plA % name ( 1 ), swiftest_plA % mass ( 1 ) swiftest_plA % rhill ( 1 ) = 0.0_dp swiftest_plA % radius ( 1 ) = 0.0_dp read ( LUN , * , iostat = ierr ) swiftest_plA % xh (:, 1 ) read ( LUN , * , iostat = ierr ) swiftest_plA % vh (:, 1 ) if ( ierr /= 0 ) then write ( * , * ) 'Error reading central body values in ' , trim ( adjustl ( param % inplfile )) return end if do i = 1 , NDIM if (( swiftest_plA % xh ( i , 1 ) /= 0.0_dp ) . or . ( swiftest_plA % vh ( i , 1 ) /= 0.0_dp )) then write ( * , * ) \"swiftest error:\" write ( * , * ) \" input must be in heliocentric coordinates.\" write ( * , * ) \" position/velocity components of body 1 are\" write ( * , * ) swiftest_plA % xh (:, 1 ) write ( * , * ) swiftest_plA % vh (:, 1 ) end if end do swiftest_plA % status ( 1 ) = active do i = 2 , npl if ( param % feature % lrhill_present ) then read ( LUN , * , iostat = ierr ) swiftest_plA % name ( i ), swiftest_plA % mass ( i ), swiftest_plA % rhill ( i ) else read ( LUN , * , iostat = ierr ) swiftest_plA % name ( i ), swiftest_plA % mass ( i ) swiftest_plA % rhill ( i ) = 0.0_dp end if if ( ierr /= 0 ) exit if ( param % feature % lclose ) then read ( LUN , * , iostat = ierr ) swiftest_plA % radius ( i ) if ( ierr /= 0 ) exit else swiftest_plA % radius ( i ) = 0.0_dp end if read ( LUN , * , iostat = ierr ) swiftest_plA % xh (:, i ) read ( LUN , * , iostat = ierr ) swiftest_plA % vh (:, i ) if ( ierr /= 0 ) exit swiftest_plA % status ( i ) = active end do close ( unit = LUN ) if ( ierr /= 0 ) then write ( * , * ) 'Error reading in massive body initial conditions from ' , trim ( adjustl ( param % inplfile )) end if return end procedure io_read_pl_in end submodule s_io_read_pl_in","tags":"","loc":"sourcefile/io_read_pl_in.f90.html"},{"title":"io_write_frame.f90 – swiftest","text":"Unit Name   : io_write_frame\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : io\n  Language    : Fortran 90/95 Description : Write a frame (header plus records for each planet and active test particle) to output binary file Input\n    Arguments : t            : time\n                npl          : number of planets\n                ntp          : number of active test particles\n                swiftest_pl1P : pointer to head of swiftest planet structure linked-list\n                swiftest_tp1P : pointer to head of active swiftest test particle structure linked-list\n                outfile      : name of output binary file\n                out_type     : binary format of output file\n                out_form     : data to write to output file (elements / heliocentric coordinates / filtered elements)\n                out_stat     : open status for output binary file\n    Terminal  : none\n    File      : none Output\n    Arguments : none\n    Terminal  : error message\n    File      : none Invocation  : CALL io_write_frame(t, npl, ntp, swiftest_pl1P, swiftest_tp1P, outfile, out_type, out_form, out_stat) Notes       : Adapted from Hal Levison's Swift routine io_write_frame.F There is no direct file output from this subroutine Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~io_write_frame.f90~~EfferentGraph sourcefile~io_write_frame.f90 io_write_frame.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~io_write_frame.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~io_write_frame.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io_write_frame.f90->sourcefile~swiftest.f90 sourcefile~module_fxdr.f90 module_fxdr.f90 sourcefile~io_write_frame.f90->sourcefile~module_fxdr.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines io_write_frame Source Code io_write_frame.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : io_write_frame !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : io !  Language    : Fortran 90/95 ! !  Description : Write a frame (header plus records for each planet and active test particle) to output binary file ! !  Input !    Arguments : t            : time !                npl          : number of planets !                ntp          : number of active test particles !                swiftest_pl1P : pointer to head of swiftest planet structure linked-list !                swiftest_tp1P : pointer to head of active swiftest test particle structure linked-list !                outfile      : name of output binary file !                out_type     : binary format of output file !                out_form     : data to write to output file (elements / heliocentric coordinates / filtered elements) !                out_stat     : open status for output binary file !    Terminal  : none !    File      : none ! !  Output !    Arguments : none !    Terminal  : error message !    File      : none ! !  Invocation  : CALL io_write_frame(t, npl, ntp, swiftest_pl1P, swiftest_tp1P, outfile, out_type, out_form, out_stat) ! !  Notes       : Adapted from Hal Levison's Swift routine io_write_frame.F ! !                There is no direct file output from this subroutine ! !********************************************************************************************************************************** SUBROUTINE io_write_frame ( t , npl , ntp , swiftest_plA , swiftest_tpA , outfile , out_type , out_form , out_stat ) ! Modules USE swiftest USE module_swiftest USE module_fxdr USE module_interfaces , EXCEPT_THIS_ONE => io_write_frame IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl , ntp REAL ( DP ), INTENT ( IN ) :: t CHARACTER ( * ), INTENT ( IN ) :: outfile , out_type , out_form , out_stat TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA TYPE ( swiftest_tp ), INTENT ( INOUT ) :: swiftest_tpA ! Internals LOGICAL ( LGT ) :: lxdr LOGICAL ( LGT ), SAVE :: lfirst = . TRUE . INTEGER ( I4B ), PARAMETER :: LUN = 20 INTEGER ( I4B ) :: i , j , ierr INTEGER ( I4B ), SAVE :: iu = LUN , iout_form = XV REAL ( DP ) :: a , e , inc , capom , omega , capm , mu REAL ( DP ), DIMENSION ( NDIM ) :: xtmp , vtmp ! Executable code lxdr = (( out_type == XDR4_TYPE ) . OR . ( out_type == XDR8_TYPE )) IF ( lfirst ) THEN IF ( out_stat == \"APPEND\" ) THEN IF ( lxdr ) THEN CALL io_open_fxdr ( outfile , \"A\" , . TRUE ., iu , ierr ) ELSE CALL io_open ( iu , outfile , out_stat , \"UNFORMATTED\" , ierr ) END IF ELSE IF ( out_stat == \"NEW\" ) THEN IF ( lxdr ) THEN CALL io_open_fxdr ( outfile , \"R\" , . TRUE ., iu , ierr ) IF ( ierr == 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Binary output file already exists\" CALL util_exit ( FAILURE ) END IF CALL io_open_fxdr ( outfile , \"W\" , . TRUE ., iu , ierr ) ELSE CALL io_open ( iu , outfile , out_stat , \"UNFORMATTED\" , ierr ) IF ( ierr /= 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Binary output file already exists\" CALL util_exit ( FAILURE ) END IF END IF ELSE IF ( lxdr ) THEN CALL io_open_fxdr ( outfile , \"W\" , . TRUE ., iu , ierr ) ELSE CALL io_open ( iu , outfile , \"REPLACE\" , \"UNFORMATTED\" , ierr ) END IF END IF IF ( ierr /= 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to open binary output file\" CALL util_exit ( FAILURE ) END IF SELECT CASE ( out_form ) CASE ( \"EL\" ) iout_form = EL CASE ( \"XV\" ) iout_form = XV CASE ( \"FILT\" ) iout_form = FILT END SELECT lfirst = . FALSE . ELSE IF ( lxdr ) THEN CALL io_open_fxdr ( outfile , \"A\" , . TRUE ., iu , ierr ) ELSE CALL io_open ( iu , outfile , \"APPEND\" , \"UNFORMATTED\" , ierr ) END IF IF ( ierr /= 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to open binary output file for append\" CALL util_exit ( FAILURE ) END IF END IF CALL io_write_hdr ( iu , t , npl , ntp , iout_form , out_type ) SELECT CASE ( iout_form ) CASE ( EL ) DO i = 2 , npl mu = swiftest_plA % mass ( 1 ) + swiftest_plA % mass ( i ) j = swiftest_plA % name ( i ) CALL orbel_xv2el ( swiftest_plA % xh (:, i ), swiftest_plA % vh (:, i ), mu , a , e , inc , capom , omega , capm ) CALL io_write_line ( iu , j , a , e , inc , capom , omega , capm , out_type , & MASS = swiftest_plA % mass ( i ), RADIUS = swiftest_plA % radius ( i )) END DO mu = swiftest_plA % mass ( 1 ) DO i = 1 , ntp j = swiftest_tpA % name ( i ) CALL orbel_xv2el ( swiftest_tpA % xh (:, i ), swiftest_tpA % vh (:, i ), mu , a , e , inc , capom , omega , capm ) CALL io_write_line ( iu , j , a , e , inc , capom , omega , capm , out_type ) END DO CASE ( XV ) DO i = 2 , npl xtmp (:) = swiftest_plA % xh (:, i ) vtmp (:) = swiftest_plA % vh (:, i ) j = swiftest_plA % name ( i ) CALL io_write_line ( iu , j , xtmp ( 1 ), xtmp ( 2 ), xtmp ( 3 ), vtmp ( 1 ), vtmp ( 2 ), vtmp ( 3 ), out_type , & MASS = swiftest_plA % mass ( i ), RADIUS = swiftest_plA % radius ( i )) END DO DO i = 1 , ntp xtmp (:) = swiftest_tpA % xh (:, i ) vtmp (:) = swiftest_tpA % vh (:, i ) j = swiftest_tpA % name ( i ) CALL io_write_line ( iu , j , xtmp ( 1 ), xtmp ( 2 ), xtmp ( 3 ), vtmp ( 1 ), vtmp ( 2 ), vtmp ( 3 ), out_type ) END DO CASE ( FILT ) ! DEK - add code here to handle the case for an OUT_FORM = FILT END SELECT IF ( lxdr ) THEN ierr = ixdrclose ( iu ) ELSE CLOSE ( UNIT = iu , IOSTAT = ierr ) END IF IF ( ierr /= 0 ) THEN WRITE ( * , * ) \"SWIFTEST Error:\" WRITE ( * , * ) \"   Unable to close binary output file\" CALL util_exit ( FAILURE ) END IF RETURN END SUBROUTINE io_write_frame !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann (Checked by Jennifer Pouplin & Carlisle Wishard) ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/io_write_frame.f90.html"},{"title":"drift_kepmd.f90 – swiftest","text":"Unit Name   : drift_kepmd\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : drift\n  Language    : Fortran 90/95 Description : Solve Kepler's equation in difference form for an ellipse for small input dm and eccentricity Input\n    Arguments : dm : increment in mean anomaly\n                es : eccentricity times the sine of eccentric anomaly\n                ec : eccentricity times the cosine of eccentric anomaly\n    Terminal  : none\n    File      : none Output\n    Arguments : x  : solution to Kepler's equation in difference form (x = dE)\n                s  : sine of x\n                c  : cosine of x\n    Terminal  : none\n    File      : none Invocation  : CALL drift_kepmd(dm, es, ec, x, s, c) Notes       : Adapted from Martin Duncan's Swift routine drift_kepmd.f Original disclaimer: built for speed, does not check how well the original equation is solved Can do that in calling routine by checking how close (x - ec*s + es*(1.0 - c) - dm) is to zero Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~drift_kepmd.f90~~EfferentGraph sourcefile~drift_kepmd.f90 drift_kepmd.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~drift_kepmd.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~drift_kepmd.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines drift_kepmd Source Code drift_kepmd.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : drift_kepmd !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : drift !  Language    : Fortran 90/95 ! !  Description : Solve Kepler's equation in difference form for an ellipse for small input dm and eccentricity ! !  Input !    Arguments : dm : increment in mean anomaly !                es : eccentricity times the sine of eccentric anomaly !                ec : eccentricity times the cosine of eccentric anomaly !    Terminal  : none !    File      : none ! !  Output !    Arguments : x  : solution to Kepler's equation in difference form (x = dE) !                s  : sine of x !                c  : cosine of x !    Terminal  : none !    File      : none ! !  Invocation  : CALL drift_kepmd(dm, es, ec, x, s, c) ! !  Notes       : Adapted from Martin Duncan's Swift routine drift_kepmd.f ! !                Original disclaimer: built for speed, does not check how well the original equation is solved !                Can do that in calling routine by checking how close (x - ec*s + es*(1.0 - c) - dm) is to zero ! !********************************************************************************************************************************** SUBROUTINE drift_kepmd ( dm , es , ec , x , s , c ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => drift_kepmd IMPLICIT NONE ! Arguments REAL ( DP ), INTENT ( IN ) :: dm , es , ec REAL ( DP ), INTENT ( OUT ) :: x , s , c ! Internals REAL ( DP ), PARAMETER :: A0 = 3991680 0.0_DP , A1 = 665280 0.0_DP , A2 = 33264 0.0_DP , A3 = 792 0.0_DP , A4 = 11 0.0_DP REAL ( DP ) :: dx , fac1 , fac2 , q , y , f , fp , fpp , fppp ! Executable code fac1 = 1.0_DP / ( 1.0_DP - ec ) q = fac1 * dm fac2 = es * es * fac1 - ec / 3.0_DP x = q * ( 1.0_DP - 0.5_DP * fac1 * q * ( es - q * fac2 )) y = x * x s = x * ( A0 - y * ( A1 - y * ( A2 - y * ( A3 - y * ( A4 - y ))))) / A0 c = SQRT ( 1.0_DP - s * s ) f = x - ec * s + es * ( 1.0_DP - c ) - dm fp = 1.0_DP - ec * c + es * s fpp = ec * s + es * c fppp = ec * c - es * s dx = - f / fp dx = - f / ( fp + dx * fpp / 2.0_DP ) dx = - f / ( fp + dx * fpp / 2.0_DP + dx * dx * fppp / 6.0_DP ) x = x + dx y = x * x s = x * ( A0 - y * ( A1 - y * ( A2 - y * ( A3 - y * ( A4 - y ))))) / A0 c = SQRT ( 1.0_DP - s * s ) RETURN END SUBROUTINE drift_kepmd !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/drift_kepmd.f90.html"},{"title":"drift_kepu_guess.f90 – swiftest","text":"Unit Name   : drift_kepu_guess\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : drift\n  Language    : Fortran 90/95 Description : Compute initial guess for solving Kepler's equation using universal variables Input\n    Arguments : dt    : time step\n                r0    : distance between two bodies\n                mu    : G * (m1 + m2), G = gravitational constant, m1 = mass of central body, m2 = mass of body to drift\n                alpha : twice the binding energy\n                u     : dot product of position and velocity vectors\n    Terminal  : none\n    File      : none Output\n    Arguments : s     : initial guess for the value of the universal variable\n    Terminal  : none\n    File      : none Invocation  : CALL drift_kepu_guess(dt, r0, mu, alpha, u, s) Notes       : Adapted from Hal Levison and Martin Duncan's Swift routine drift_kepu_guess.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~drift_kepu_guess.f90~~EfferentGraph sourcefile~drift_kepu_guess.f90 drift_kepu_guess.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~drift_kepu_guess.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~drift_kepu_guess.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines drift_kepu_guess Source Code drift_kepu_guess.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : drift_kepu_guess !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : drift !  Language    : Fortran 90/95 ! !  Description : Compute initial guess for solving Kepler's equation using universal variables ! !  Input !    Arguments : dt    : time step !                r0    : distance between two bodies !                mu    : G * (m1 + m2), G = gravitational constant, m1 = mass of central body, m2 = mass of body to drift !                alpha : twice the binding energy !                u     : dot product of position and velocity vectors !    Terminal  : none !    File      : none ! !  Output !    Arguments : s     : initial guess for the value of the universal variable !    Terminal  : none !    File      : none ! !  Invocation  : CALL drift_kepu_guess(dt, r0, mu, alpha, u, s) ! !  Notes       : Adapted from Hal Levison and Martin Duncan's Swift routine drift_kepu_guess.f ! !********************************************************************************************************************************** SUBROUTINE drift_kepu_guess ( dt , r0 , mu , alpha , u , s ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => drift_kepu_guess IMPLICIT NONE ! Arguments REAL ( DP ), INTENT ( IN ) :: dt , r0 , mu , alpha , u REAL ( DP ), INTENT ( OUT ) :: s ! Internals INTEGER ( I4B ) :: iflag REAL ( DP ), PARAMETER :: THRESH = 0.4_DP , DANBYK = 0.85_DP REAL ( DP ) :: y , sy , cy , sigma , es , x , a , en , ec , e ! Executable code IF ( alpha > 0.0_DP ) THEN IF ( dt / r0 <= THRESH ) THEN s = dt / r0 - ( dt * dt * u ) / ( 2.0_DP * r0 * r0 * r0 ) ELSE a = mu / alpha en = SQRT ( mu / ( a * a * a )) ec = 1.0_DP - r0 / a es = u / ( en * a * a ) e = SQRT ( ec * ec + es * es ) y = en * dt - es CALL orbel_scget ( y , sy , cy ) sigma = SIGN ( 1.0_DP , es * cy + ec * sy ) x = y + sigma * DANBYK * e s = x / SQRT ( alpha ) END IF ELSE CALL drift_kepu_p3solve ( dt , r0 , mu , alpha , u , s , iflag ) IF ( iflag /= 0 ) s = dt / r0 END IF RETURN END SUBROUTINE drift_kepu_guess !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/drift_kepu_guess.f90.html"},{"title":"drift_kepu_stumpff.f90 – swiftest","text":"Unit Name   : drift_kepu_stumpff\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : drift\n  Language    : Fortran 90/95 Description : Compute Stumpff functions needed for Kepler drift in universal variables Input\n    Arguments : x  : argument of Stumpff functions\n    Terminal  : none\n    File      : none Output\n    Arguments : c0 : zeroth Stumpff function\n                c1 : first Stumpff function\n                c2 : second Stumpff function\n                c3 : third Stumpff function\n    Terminal  : none\n    File      : none Invocation  : CALL drift_kepu_stumpff(x, c0, c1, c2, c3) Notes       : Adapted from Hal Levison's Swift routine drift_kepu_stumpff.f Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 171 - 172. Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~drift_kepu_stumpff.f90~~EfferentGraph sourcefile~drift_kepu_stumpff.f90 drift_kepu_stumpff.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~drift_kepu_stumpff.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~drift_kepu_stumpff.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines drift_kepu_stumpff Source Code drift_kepu_stumpff.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : drift_kepu_stumpff !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : drift !  Language    : Fortran 90/95 ! !  Description : Compute Stumpff functions needed for Kepler drift in universal variables ! !  Input !    Arguments : x  : argument of Stumpff functions !    Terminal  : none !    File      : none ! !  Output !    Arguments : c0 : zeroth Stumpff function !                c1 : first Stumpff function !                c2 : second Stumpff function !                c3 : third Stumpff function !    Terminal  : none !    File      : none ! !  Invocation  : CALL drift_kepu_stumpff(x, c0, c1, c2, c3) ! !  Notes       : Adapted from Hal Levison's Swift routine drift_kepu_stumpff.f ! !                Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 171 - 172. ! !********************************************************************************************************************************** SUBROUTINE drift_kepu_stumpff ( x , c0 , c1 , c2 , c3 ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => drift_kepu_stumpff IMPLICIT NONE ! Arguments REAL ( DP ), INTENT ( INOUT ) :: x REAL ( DP ), INTENT ( OUT ) :: c0 , c1 , c2 , c3 ! Internals INTEGER ( I4B ) :: i , n REAL ( DP ) :: xm ! Executable code n = 0 xm = 0.1_DP DO WHILE ( ABS ( x ) >= xm ) n = n + 1 x = x / 4.0_DP END DO c2 = ( 1.0_DP - x * ( 1.0_DP - x * ( 1.0_DP - x * ( 1.0_DP - x * ( 1.0_DP - x * ( 1.0_DP - x / 18 2.0_DP ) / 13 2.0_DP ) / 9 0.0_DP ) / 5 6.0_DP ) / & 3 0.0_DP ) / 1 2.0_DP ) / 2.0_DP c3 = ( 1.0_DP - x * ( 1.0_DP - x * ( 1.0_DP - x * ( 1.0_DP - x * ( 1.0_DP - x * ( 1.0_DP - x / 21 0.0_DP ) / 15 6.0_DP ) / 11 0.0_DP ) / 7 2.0_DP ) / & 4 2.0_DP ) / 2 0.0_DP ) / 6.0_DP c1 = 1.0_DP - x * c3 c0 = 1.0_DP - x * c2 IF ( n /= 0 ) THEN DO i = n , 1 , - 1 c3 = ( c2 + c0 * c3 ) / 4.0_DP c2 = c1 * c1 / 2.0_DP c1 = c0 * c1 c0 = 2.0_DP * c0 * c0 - 1.0_DP x = x * 4.0_DP END DO END IF RETURN END SUBROUTINE drift_kepu_stumpff !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/drift_kepu_stumpff.f90.html"},{"title":"drift_kepu.f90 – swiftest","text":"Unit Name   : drift_kepu\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : drift\n  Language    : Fortran 90/95 Description : Solve Kepler's equation in universal variables Input\n    Arguments : dt    : time step\n                r0    : distance between two bodies\n                mu    : G * (m1 + m2), G = gravitational constant, m1 = mass of central body, m2 = mass of body to drift\n                alpha : twice the binding energy\n                u     : dot product of position and velocity vectors\n    Terminal  : none\n    File      : none Output\n    Arguments : fp    : first derivative of Kepler's equation with respect to universal variable s\n                c1    : Stumpff function c1 times s\n                c2    : Stumpff function c2 times s 2\n                c3    : Stumpff function c3 times s 3\n                iflag : error status flag for convergence (0 = CONVERGED, nonzero = NOT CONVERGED)\n    Terminal  : none\n    File      : none Invocation  : CALL drift_kepu(dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Notes       : Adapted from Hal Levison's Swift routine drift_kepu.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~drift_kepu.f90~~EfferentGraph sourcefile~drift_kepu.f90 drift_kepu.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~drift_kepu.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~drift_kepu.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines drift_kepu Source Code drift_kepu.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : drift_kepu !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : drift !  Language    : Fortran 90/95 ! !  Description : Solve Kepler's equation in universal variables ! !  Input !    Arguments : dt    : time step !                r0    : distance between two bodies !                mu    : G * (m1 + m2), G = gravitational constant, m1 = mass of central body, m2 = mass of body to drift !                alpha : twice the binding energy !                u     : dot product of position and velocity vectors !    Terminal  : none !    File      : none ! !  Output !    Arguments : fp    : first derivative of Kepler's equation with respect to universal variable s !                c1    : Stumpff function c1 times s !                c2    : Stumpff function c2 times s**2 !                c3    : Stumpff function c3 times s**3 !                iflag : error status flag for convergence (0 = CONVERGED, nonzero = NOT CONVERGED) !    Terminal  : none !    File      : none ! !  Invocation  : CALL drift_kepu(dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) ! !  Notes       : Adapted from Hal Levison's Swift routine drift_kepu.f ! !********************************************************************************************************************************** SUBROUTINE drift_kepu ( dt , r0 , mu , alpha , u , fp , c1 , c2 , c3 , iflag ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => drift_kepu IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( OUT ) :: iflag REAL ( DP ), INTENT ( IN ) :: dt , r0 , mu , alpha , u REAL ( DP ), INTENT ( OUT ) :: fp , c1 , c2 , c3 ! Internals REAL ( DP ) :: s , st , fo , fn ! Executable code CALL drift_kepu_guess ( dt , r0 , mu , alpha , u , s ) st = s CALL drift_kepu_new ( s , dt , r0 , mu , alpha , u , fp , c1 , c2 , c3 , iflag ) IF ( iflag /= 0 ) THEN CALL drift_kepu_fchk ( dt , r0 , mu , alpha , u , st , fo ) CALL drift_kepu_fchk ( dt , r0 , mu , alpha , u , s , fn ) IF ( ABS ( fo ) < ABS ( fn )) s = st CALL drift_kepu_lag ( s , dt , r0 , mu , alpha , u , fp , c1 , c2 , c3 , iflag ) END IF RETURN END SUBROUTINE drift_kepu !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/drift_kepu.f90.html"},{"title":"drift_kepu_new.f90 – swiftest","text":"Unit Name   : drift_kepu_new\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : drift\n  Language    : Fortran 90/95 Description : Solve Kepler's equation in universal variables using Newton's method Input\n    Arguments : s     : universal variable\n                dt    : time step\n                r0    : distance between two bodies\n                mu    : G * (m1 + m2), G = gravitational constant, m1 = mass of central body, m2 = mass of body to drift\n                alpha : twice the binding energy\n                u     : dot product of position and velocity vectors\n    Terminal  : none\n    File      : none Output\n    Arguments : s     : universal variable\n                fp    : first derivative of Kepler's equation in universal variables with respect to s (see Danby, p. 175)\n                c1    : Stumpff function c1 times s\n                c2    : Stumpff function c2 times s 2\n                c3    : Stumpff function c3 times s 3\n                iflag : error status flag for convergence (0 = CONVERGED, nonzero = NOT CONVERGED)\n    Terminal  : none\n    File      : none Invocation  : CALL drift_kepu_new(s, dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Notes       : Adapted from Hal Levison's Swift routine drift_kepu_new.f Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 174 - 175. Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~drift_kepu_new.f90~~EfferentGraph sourcefile~drift_kepu_new.f90 drift_kepu_new.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~drift_kepu_new.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~drift_kepu_new.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines drift_kepu_new Source Code drift_kepu_new.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : drift_kepu_new !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : drift !  Language    : Fortran 90/95 ! !  Description : Solve Kepler's equation in universal variables using Newton's method ! !  Input !    Arguments : s     : universal variable !                dt    : time step !                r0    : distance between two bodies !                mu    : G * (m1 + m2), G = gravitational constant, m1 = mass of central body, m2 = mass of body to drift !                alpha : twice the binding energy !                u     : dot product of position and velocity vectors !    Terminal  : none !    File      : none ! !  Output !    Arguments : s     : universal variable !                fp    : first derivative of Kepler's equation in universal variables with respect to s (see Danby, p. 175) !                c1    : Stumpff function c1 times s !                c2    : Stumpff function c2 times s**2 !                c3    : Stumpff function c3 times s**3 !                iflag : error status flag for convergence (0 = CONVERGED, nonzero = NOT CONVERGED) !    Terminal  : none !    File      : none ! !  Invocation  : CALL drift_kepu_new(s, dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) ! !  Notes       : Adapted from Hal Levison's Swift routine drift_kepu_new.f ! !                Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 174 - 175. ! !********************************************************************************************************************************** SUBROUTINE drift_kepu_new ( s , dt , r0 , mu , alpha , u , fp , c1 , c2 , c3 , iflag ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => drift_kepu_new IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( OUT ) :: iflag REAL ( DP ), INTENT ( IN ) :: dt , r0 , mu , alpha , u REAL ( DP ), INTENT ( INOUT ) :: s REAL ( DP ), INTENT ( OUT ) :: fp , c1 , c2 , c3 ! Internals INTEGER ( I4B ) :: nc REAL ( DP ) :: x , c0 , ds , f , fpp , fppp , fdt ! Executable code DO nc = 0 , 6 x = s * s * alpha CALL drift_kepu_stumpff ( x , c0 , c1 , c2 , c3 ) c1 = c1 * s c2 = c2 * s * s c3 = c3 * s * s * s f = r0 * c1 + u * c2 + mu * c3 - dt fp = r0 * c0 + u * c1 + mu * c2 fpp = ( - r0 * alpha + mu ) * c1 + u * c0 fppp = ( - r0 * alpha + mu ) * c0 - u * alpha * c1 ds = - f / fp ds = - f / ( fp + ds * fpp / 2.0_DP ) ds = - f / ( fp + ds * fpp / 2.0_DP + ds * ds * fppp / 6.0_DP ) s = s + ds fdt = f / dt IF ( fdt * fdt < DANBYB * DANBYB ) THEN iflag = 0 RETURN END IF END DO iflag = 1 RETURN END SUBROUTINE drift_kepu_new !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/drift_kepu_new.f90.html"},{"title":"drift_dan.f90 – swiftest","text":"Unit Name   : drift_dan\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : drift\n  Language    : Fortran 90/95 Description : Perform Kepler drift, solving Kepler's equation in appropriate variables Input\n    Arguments : mu    : G * (m1 + m2), G = gravitational constant, m1 = mass of central body, m2 = mass of body to drift\n                x0    : position of body to drift\n                v0    : velocity of body to drift\n                dt0   : time step\n    Terminal  : none\n    File      : none Output\n    Arguments : x0    : position of body to drift\n                v0    : velocity of body to drift\n                iflag : error status flag for Kepler drift (0 = OK, nonzero = NO CONVERGENCE)\n    Terminal  : none\n    File      : none Invocation  : CALL drift_dan(mu, x0, v0, dt0, iflag) Notes       : Adapted from Hal Levison and Martin Duncan's Swift routine drift_dan.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~drift_dan.f90~~EfferentGraph sourcefile~drift_dan.f90 drift_dan.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~drift_dan.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~drift_dan.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines drift_dan Source Code drift_dan.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : drift_dan !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : drift !  Language    : Fortran 90/95 ! !  Description : Perform Kepler drift, solving Kepler's equation in appropriate variables ! !  Input !    Arguments : mu    : G * (m1 + m2), G = gravitational constant, m1 = mass of central body, m2 = mass of body to drift !                x0    : position of body to drift !                v0    : velocity of body to drift !                dt0   : time step !    Terminal  : none !    File      : none ! !  Output !    Arguments : x0    : position of body to drift !                v0    : velocity of body to drift !                iflag : error status flag for Kepler drift (0 = OK, nonzero = NO CONVERGENCE) !    Terminal  : none !    File      : none ! !  Invocation  : CALL drift_dan(mu, x0, v0, dt0, iflag) ! !  Notes       : Adapted from Hal Levison and Martin Duncan's Swift routine drift_dan.f ! !********************************************************************************************************************************** SUBROUTINE drift_dan ( mu , x0 , v0 , dt0 , iflag ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => drift_dan IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( OUT ) :: iflag REAL ( DP ), INTENT ( IN ) :: mu , dt0 REAL ( DP ), DIMENSION ( NDIM ), INTENT ( INOUT ) :: x0 , v0 ! Internals REAL ( DP ) :: dt , f , g , fdot , gdot , c1 , c2 , c3 , u , alpha , fp , r0 REAL ( DP ) :: v0s , a , asq , en , dm , ec , es , esq , xkep , fchk , s , c REAL ( DP ), DIMENSION ( NDIM ) :: x , v ! Executable code iflag = 0 dt = dt0 r0 = SQRT ( DOT_PRODUCT ( x0 (:), x0 (:))) v0s = DOT_PRODUCT ( v0 (:), v0 (:)) u = DOT_PRODUCT ( x0 (:), v0 (:)) alpha = 2.0_DP * mu / r0 - v0s IF ( alpha > 0.0_DP ) THEN a = mu / alpha asq = a * a en = SQRT ( mu / ( a * asq )) ec = 1.0_DP - r0 / a es = u / ( en * asq ) esq = ec * ec + es * es dm = dt * en - INT ( dt * en / TWOPI ) * TWOPI dt = dm / en IF (( esq < E2MAX ) . AND . ( dm * dm < DM2MAX ) . AND . ( esq * dm * dm < E2DM2MAX )) THEN CALL drift_kepmd ( dm , es , ec , xkep , s , c ) fchk = ( xkep - ec * s + es * ( 1.0_DP - c ) - dm ) ! DEK - original code compared fchk*fchk with DANBYB, but I think it should ! DEK - be compared with DANBYB*DANBYB, and I changed it accordingly - please ! DEK - check with Hal and/or Martin about this IF ( fchk * fchk > DANBYB * DANBYB ) THEN iflag = 1 RETURN END IF fp = 1.0_DP - ec * c + es * s f = a / r0 * ( c - 1.0_DP ) + 1.0_DP g = dt + ( s - xkep ) / en fdot = - ( a / ( r0 * fp )) * en * s gdot = ( c - 1.0_DP ) / fp + 1.0_DP x (:) = x0 (:) * f + v0 (:) * g v (:) = x0 (:) * fdot + v0 (:) * gdot x0 (:) = x (:) v0 (:) = v (:) iflag = 0 RETURN END IF END IF CALL drift_kepu ( dt , r0 , mu , alpha , u , fp , c1 , c2 , c3 , iflag ) IF ( iflag == 0 ) THEN f = 1.0_DP - mu / r0 * c2 g = dt - mu * c3 fdot = - mu / ( fp * r0 ) * c1 gdot = 1.0_DP - mu / fp * c2 x (:) = x0 (:) * f + v0 (:) * g v (:) = x0 (:) * fdot + v0 (:) * gdot x0 (:) = x (:) v0 (:) = v (:) END IF RETURN END SUBROUTINE drift_dan !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/drift_dan.f90.html"},{"title":"drift_kepu_p3solve.f90 – swiftest","text":"Unit Name   : drift_kepu_p3solve\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : drift\n  Language    : Fortran 90/95 Description : Computes real root of cubic involved in setting initial guess for solving Kepler's equation in universal variables Input\n    Arguments : dt    : time step\n                r0    : distance between two bodies\n                mu    : G * (m1 + m2), G = gravitational constant, m1 = mass of central body, m2 = mass of body to drift\n                alpha : twice the binding energy\n                u     : dot product of position and velocity vectors\n    Terminal  : none\n    File      : none Output\n    Arguments : s     : real solution of cubic equation\n                iflag : error status flag for solution (0 = OK, nonzero = ERROR)\n    Terminal  : none\n    File      : none Invocation  : CALL drift_kepu_p3solve(dt, r0, mu, alpha, u, s, iflag) Notes       : Adapted from Martin Duncan's Swift routine drift_kepu_p3solve.f Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 177 - 178. Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~drift_kepu_p3solve.f90~~EfferentGraph sourcefile~drift_kepu_p3solve.f90 drift_kepu_p3solve.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~drift_kepu_p3solve.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~drift_kepu_p3solve.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines drift_kepu_p3solve Source Code drift_kepu_p3solve.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : drift_kepu_p3solve !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : drift !  Language    : Fortran 90/95 ! !  Description : Computes real root of cubic involved in setting initial guess for solving Kepler's equation in universal variables ! !  Input !    Arguments : dt    : time step !                r0    : distance between two bodies !                mu    : G * (m1 + m2), G = gravitational constant, m1 = mass of central body, m2 = mass of body to drift !                alpha : twice the binding energy !                u     : dot product of position and velocity vectors !    Terminal  : none !    File      : none ! !  Output !    Arguments : s     : real solution of cubic equation !                iflag : error status flag for solution (0 = OK, nonzero = ERROR) !    Terminal  : none !    File      : none ! !  Invocation  : CALL drift_kepu_p3solve(dt, r0, mu, alpha, u, s, iflag) ! !  Notes       : Adapted from Martin Duncan's Swift routine drift_kepu_p3solve.f ! !                Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 177 - 178. ! !********************************************************************************************************************************** SUBROUTINE drift_kepu_p3solve ( dt , r0 , mu , alpha , u , s , iflag ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => drift_kepu_p3solve IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( OUT ) :: iflag REAL ( DP ), INTENT ( IN ) :: dt , r0 , mu , alpha , u REAL ( DP ), INTENT ( OUT ) :: s ! Internals REAL ( DP ) :: denom , a0 , a1 , a2 , q , r , sq2 , sq , p1 , p2 ! Executable code denom = ( mu - alpha * r0 ) / 6.0_DP a2 = 0.5_DP * u / denom a1 = r0 / denom a0 = - dt / denom q = ( a1 - a2 * a2 / 3.0_DP ) / 3.0_DP r = ( a1 * a2 - 3.0_DP * a0 ) / 6.0_DP - ( a2 * a2 * a2 ) / 2 7.0_DP sq2 = q * q * q + r * r IF ( sq2 >= 0.0_DP ) THEN sq = SQRT ( sq2 ) IF (( r + sq ) <= 0.0_DP ) THEN p1 = - ( - ( r + sq )) ** ( 1.0_DP / 3.0_DP ) ELSE p1 = ( r + sq ) ** ( 1.0_DP / 3.0_DP ) END IF IF (( r - sq ) <= 0.0_DP ) THEN p2 = - ( - ( r - sq )) ** ( 1.0_DP / 3.0_DP ) ELSE p2 = ( r - sq ) ** ( 1.0_DP / 3.0_DP ) END IF iflag = 0 s = p1 + p2 - a2 / 3.0_DP ELSE iflag = 1 s = 0.0_DP END IF RETURN END SUBROUTINE drift_kepu_p3solve !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/drift_kepu_p3solve.f90.html"},{"title":"drift_one.f90 – swiftest","text":"Unit Name   : drift_one\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : drift\n  Language    : Fortran 90/95 Description : Perform Danby drift for one body, redoing drift with smaller substeps if original accuracy is insufficient Input\n    Arguments : mu    : G * (m1 + m2), G = gravitational constant, m1 = mass of central body, m2 = mass of body to drift\n                x     : position of body to drift\n                v     : velocity of body to drift\n                dt    : time step\n    Terminal  : none\n    File      : none Output\n    Arguments : x     : position of body to drift\n                v     : velocity of body to drift\n                iflag : error status flag for Danby drift (0 = OK, nonzero = ERROR)\n    Terminal  : none\n    File      : none Invocation  : CALL drift_one(mu, x, v, dt, iflag) Notes       : Adapted from Hal Levison and Martin Duncan's Swift routine drift_one.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~drift_one.f90~~EfferentGraph sourcefile~drift_one.f90 drift_one.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~drift_one.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~drift_one.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines drift_one Source Code drift_one.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : drift_one !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : drift !  Language    : Fortran 90/95 ! !  Description : Perform Danby drift for one body, redoing drift with smaller substeps if original accuracy is insufficient ! !  Input !    Arguments : mu    : G * (m1 + m2), G = gravitational constant, m1 = mass of central body, m2 = mass of body to drift !                x     : position of body to drift !                v     : velocity of body to drift !                dt    : time step !    Terminal  : none !    File      : none ! !  Output !    Arguments : x     : position of body to drift !                v     : velocity of body to drift !                iflag : error status flag for Danby drift (0 = OK, nonzero = ERROR) !    Terminal  : none !    File      : none ! !  Invocation  : CALL drift_one(mu, x, v, dt, iflag) ! !  Notes       : Adapted from Hal Levison and Martin Duncan's Swift routine drift_one.f ! !********************************************************************************************************************************** SUBROUTINE drift_one ( mu , x , v , dt , iflag ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => drift_one IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( OUT ) :: iflag REAL ( DP ), INTENT ( IN ) :: mu , dt REAL ( DP ), DIMENSION ( NDIM ), INTENT ( INOUT ) :: x , v ! Internals INTEGER ( I4B ) :: i REAL ( DP ) :: dttmp ! Executable code CALL drift_dan ( mu , x (:), v (:), dt , iflag ) IF ( iflag /= 0 ) THEN dttmp = 0.1_DP * dt DO i = 1 , 10 CALL drift_dan ( mu , x (:), v (:), dttmp , iflag ) IF ( iflag /= 0 ) RETURN END DO END IF RETURN END SUBROUTINE drift_one !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/drift_one.f90.html"},{"title":"drift_kepu_fchk.f90 – swiftest","text":"Unit Name   : drift_kepu_fchk\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : drift\n  Language    : Fortran 90/95 Description : Computes the value of f, the function whose root we are trying to find in universal variables Input\n    Arguments : dt    : time step\n                r0    : distance between two bodies\n                mu    : G * (m1 + m2), G = gravitational constant, m1 = mass of central body, m2 = mass of body to drift\n                alpha : twice the binding energy\n                u     : dot product of position and velocity vectors\n                s     : universal variable (approximate root of f)\n    Terminal  : none\n    File      : none Output\n    Arguments : f     : function value\n    Terminal  : none\n    File      : none Invocation  : CALL drift_kepu_fchk(dt, r0, mu, alpha, u, s, f) Notes       : Adapted from Martin Duncan's Swift routine drift_kepu_fchk.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~drift_kepu_fchk.f90~~EfferentGraph sourcefile~drift_kepu_fchk.f90 drift_kepu_fchk.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~drift_kepu_fchk.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~drift_kepu_fchk.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines drift_kepu_fchk Source Code drift_kepu_fchk.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : drift_kepu_fchk !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : drift !  Language    : Fortran 90/95 ! !  Description : Computes the value of f, the function whose root we are trying to find in universal variables ! !  Input !    Arguments : dt    : time step !                r0    : distance between two bodies !                mu    : G * (m1 + m2), G = gravitational constant, m1 = mass of central body, m2 = mass of body to drift !                alpha : twice the binding energy !                u     : dot product of position and velocity vectors !                s     : universal variable (approximate root of f) !    Terminal  : none !    File      : none ! !  Output !    Arguments : f     : function value !    Terminal  : none !    File      : none ! !  Invocation  : CALL drift_kepu_fchk(dt, r0, mu, alpha, u, s, f) ! !  Notes       : Adapted from Martin Duncan's Swift routine drift_kepu_fchk.f ! !********************************************************************************************************************************** SUBROUTINE drift_kepu_fchk ( dt , r0 , mu , alpha , u , s , f ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => drift_kepu_fchk IMPLICIT NONE ! Arguments REAL ( DP ), INTENT ( IN ) :: dt , r0 , mu , alpha , u , s REAL ( DP ), INTENT ( OUT ) :: f ! Internals REAL ( DP ) :: x , c0 , c1 , c2 , c3 ! Executable code x = s * s * alpha CALL drift_kepu_stumpff ( x , c0 , c1 , c2 , c3 ) c1 = c1 * s c2 = c2 * s * s c3 = c3 * s * s * s f = r0 * c1 + u * c2 + mu * c3 - dt RETURN END SUBROUTINE drift_kepu_fchk !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/drift_kepu_fchk.f90.html"},{"title":"drift_kepu_lag.f90 – swiftest","text":"Unit Name   : drift_kepu_lag\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : drift\n  Language    : Fortran 90/95 Description : Solve Kepler's equation in universal variables using Laguerre's method Input\n    Arguments : s     : universal variable\n                dt    : time step\n                r0    : distance between two bodies\n                mu    : G * (m1 + m2), G = gravitational constant, m1 = mass of central body, m2 = mass of body to drift\n                alpha : twice the binding energy\n                u     : dot product of position and velocity vectors\n    Terminal  : none\n    File      : none Output\n    Arguments : s     : universal variable\n                fp    : first derivative of Kepler's equation in universal variables with respect to s (see Danby, p. 175)\n                c1    : Stumpff function c1 times s\n                c2    : Stumpff function c2 times s 2\n                c3    : Stumpff function c3 times s 3\n                iflag : error status flag for convergence (0 = CONVERGED, nonzero = NOT CONVERGED)\n    Terminal  : none\n    File      : none Invocation  : CALL drift_kepu_lag(s, dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Notes       : Adapted from Hal Levison's Swift routine drift_kepu_lag.f Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 178 - 180. Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~drift_kepu_lag.f90~~EfferentGraph sourcefile~drift_kepu_lag.f90 drift_kepu_lag.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~drift_kepu_lag.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~drift_kepu_lag.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines drift_kepu_lag Source Code drift_kepu_lag.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : drift_kepu_lag !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : drift !  Language    : Fortran 90/95 ! !  Description : Solve Kepler's equation in universal variables using Laguerre's method ! !  Input !    Arguments : s     : universal variable !                dt    : time step !                r0    : distance between two bodies !                mu    : G * (m1 + m2), G = gravitational constant, m1 = mass of central body, m2 = mass of body to drift !                alpha : twice the binding energy !                u     : dot product of position and velocity vectors !    Terminal  : none !    File      : none ! !  Output !    Arguments : s     : universal variable !                fp    : first derivative of Kepler's equation in universal variables with respect to s (see Danby, p. 175) !                c1    : Stumpff function c1 times s !                c2    : Stumpff function c2 times s**2 !                c3    : Stumpff function c3 times s**3 !                iflag : error status flag for convergence (0 = CONVERGED, nonzero = NOT CONVERGED) !    Terminal  : none !    File      : none ! !  Invocation  : CALL drift_kepu_lag(s, dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) ! !  Notes       : Adapted from Hal Levison's Swift routine drift_kepu_lag.f ! !                Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 178 - 180. ! !********************************************************************************************************************************** SUBROUTINE drift_kepu_lag ( s , dt , r0 , mu , alpha , u , fp , c1 , c2 , c3 , iflag ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => drift_kepu_lag IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( OUT ) :: iflag REAL ( DP ), INTENT ( IN ) :: dt , r0 , mu , alpha , u REAL ( DP ), INTENT ( INOUT ) :: s REAL ( DP ), INTENT ( OUT ) :: fp , c1 , c2 , c3 ! Internals INTEGER ( I4B ) :: nc , ncmax REAL ( DP ) :: ln , x , fpp , ds , c0 , f , fdt ! Executable code IF ( alpha < 0.0_DP ) THEN ncmax = NLAG2 ELSE ncmax = NLAG1 END IF ln = 5.0_DP DO nc = 0 , ncmax x = s * s * alpha CALL drift_kepu_stumpff ( x , c0 , c1 , c2 , c3 ) c1 = c1 * s c2 = c2 * s * s c3 = c3 * s * s * s f = r0 * c1 + u * c2 + mu * c3 - dt fp = r0 * c0 + u * c1 + mu * c2 fpp = ( - r0 * alpha + mu ) * c1 + u * c0 ds = - ln * f / ( fp + SIGN ( 1.0_DP , fp ) * SQRT ( ABS (( ln - 1.0_DP ) * ( ln - 1.0_DP ) * fp * fp - ( ln - 1.0_DP ) * ln * f * fpp ))) s = s + ds fdt = f / dt IF ( fdt * fdt < DANBYB * DANBYB ) THEN iflag = 0 RETURN END IF END DO iflag = 2 RETURN END SUBROUTINE drift_kepu_lag !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/drift_kepu_lag.f90.html"},{"title":"symba_discard_peri_pl.f90 – swiftest","text":"Unit Name   : symba_discard_peri_pl\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Check to see if planets should be discarded based on their pericenter distances Input\n    Arguments : t          : time\n                npl        : number of planets\n                symba_pl1P : pointer to head of SyMBA planet structure linked-list\n                msys       : total system mass\n                qmin       : minimum allowed pericenter distance\n                qmin_alo   : minimum semimajor axis for qmin\n                qmin_ahi   : maximum semimajor axis for qmin\n                qmin_coord : coordinate frame for qmin\n                ldiscards  : logical flag indicating whether any planets are discarded\n    Terminal  : none\n    File      : none Output\n    Arguments : symba_pl1P : pointer to head of SyMBA planet structure linked-list\n                ldiscards  : logical flag indicating whether any planets are discarded\n    Terminal  : status message\n    File      : none Invocation  : CALL symba_discard_peri_pl(t, npl, symba_pl1P, msys, qmin, qmin_alo, qmin_ahi, qmin_coord, ldiscards) Notes       : Adapted from Hal Levison's Swift routine discard_mass_peri.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_discard_peri_pl.f90~~EfferentGraph sourcefile~symba_discard_peri_pl.f90 symba_discard_peri_pl.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_discard_peri_pl.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_discard_peri_pl.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_discard_peri_pl.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_discard_peri_pl.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_discard_peri_pl.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_discard_peri_pl Source Code symba_discard_peri_pl.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_discard_peri_pl !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Check to see if planets should be discarded based on their pericenter distances ! !  Input !    Arguments : t          : time !                npl        : number of planets !                symba_pl1P : pointer to head of SyMBA planet structure linked-list !                msys       : total system mass !                qmin       : minimum allowed pericenter distance !                qmin_alo   : minimum semimajor axis for qmin !                qmin_ahi   : maximum semimajor axis for qmin !                qmin_coord : coordinate frame for qmin !                ldiscards  : logical flag indicating whether any planets are discarded !    Terminal  : none !    File      : none ! !  Output !    Arguments : symba_pl1P : pointer to head of SyMBA planet structure linked-list !                ldiscards  : logical flag indicating whether any planets are discarded !    Terminal  : status message !    File      : none ! !  Invocation  : CALL symba_discard_peri_pl(t, npl, symba_pl1P, msys, qmin, qmin_alo, qmin_ahi, qmin_coord, ldiscards) ! !  Notes       : Adapted from Hal Levison's Swift routine discard_mass_peri.f ! !********************************************************************************************************************************** SUBROUTINE symba_discard_peri_pl ( t , npl , symba_plA , msys , qmin , qmin_alo , qmin_ahi , qmin_coord , ldiscards ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_discard_peri_pl IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( INOUT ) :: ldiscards INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: t , msys , qmin , qmin_alo , qmin_ahi CHARACTER ( * ), INTENT ( IN ) :: qmin_coord TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA ! Internals LOGICAL ( LGT ), SAVE :: lfirst = . TRUE . INTEGER ( I4B ) :: i , j , ih REAL ( DP ) :: r2 REAL ( DP ), DIMENSION ( NDIM ) :: dx ! Executable code IF ( lfirst ) THEN CALL symba_peri ( lfirst , npl , symba_plA , msys , qmin_coord ) lfirst = . FALSE . ELSE CALL symba_peri ( lfirst , npl , symba_plA , msys , qmin_coord ) DO i = 2 , npl IF ( symba_plA % helio % swiftest % status ( i ) == ACTIVE ) THEN IF (( symba_plA % isperi ( i ) == 0 ) . AND . ( symba_plA % nplenc ( i ) == 0 )) THEN IF (( symba_plA % atp ( i ) >= qmin_alo ) . AND . ( symba_plA % atp ( i ) <= qmin_ahi ) & . AND . ( symba_plA % peri ( i ) <= qmin )) THEN ldiscards = . TRUE . symba_plA % helio % swiftest % status ( i ) = DISCARDED_PERI WRITE ( * , * ) \"Particle \" , symba_plA % helio % swiftest % name ( i ), & \" perihelion distance too small at t = \" , t END IF END IF END IF END DO END IF RETURN END SUBROUTINE symba_discard_peri_pl !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_discard_peri_pl.f90.html"},{"title":"symba_step_helio_pl.f90 – swiftest","text":"Unit Name   : symba_step_helio_pl\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Step planets ahead in democratic heliocentric coordinates Input\n    Arguments : lfirst       : logical flag indicating whether current invocation is the first\n                lextra_force : logical flag indicating whether to include user-supplied accelerations\n                t            : time\n                npl          : number of planets\n                nplm         : number of planets with mass > mtiny\n                nplmax       : maximum allowed number of planets\n                helio_pl1P   : pointer to head of helio planet structure linked-list\n                j2rp2        : J2 * R 2 for the Sun\n                j4rp4        : J4 * R 4 for the Sun\n                dt           : time step\n    Terminal  : none\n    File      : none Output\n    Arguments : lfirst       : logical flag indicating whether current invocation is the first\n                helio_pl1P   : pointer to head of helio planet structure linked-list\n                xbeg         : heliocentric positions of planets with mass > mtiny prior to Kepler drift\n                xend         : heliocentric positions of planets with mass > mtiny after Kepler drift\n                ptb          : negative barycentric velocity of the Sun prior to the first kick\n                pte          : negative barycentric velocity of the Sun after the second kick\n    Terminal  : none\n    File      : none Invocation  : CALL symba_step_helio_pl(lfirst, lextra_force, t, npl, nplm, nplmax, helio_pl1P, j2rp2, j4rp4, dt, xbeg, xend,\n                                         ptb, pte) Notes       : Adapted from Hal Levison's Swift routines symba5_step_helio.f and helio_step_pl.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_step_helio_pl.f90~~EfferentGraph sourcefile~symba_step_helio_pl.f90 symba_step_helio_pl.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_step_helio_pl.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_step_helio_pl.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_step_helio_pl.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_step_helio_pl.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_step_helio_pl.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_step_helio_pl Source Code symba_step_helio_pl.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_step_helio_pl !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Step planets ahead in democratic heliocentric coordinates ! !  Input !    Arguments : lfirst       : logical flag indicating whether current invocation is the first !                lextra_force : logical flag indicating whether to include user-supplied accelerations !                t            : time !                npl          : number of planets !                nplm         : number of planets with mass > mtiny !                nplmax       : maximum allowed number of planets !                helio_pl1P   : pointer to head of helio planet structure linked-list !                j2rp2        : J2 * R**2 for the Sun !                j4rp4        : J4 * R**4 for the Sun !                dt           : time step !    Terminal  : none !    File      : none ! !  Output !    Arguments : lfirst       : logical flag indicating whether current invocation is the first !                helio_pl1P   : pointer to head of helio planet structure linked-list !                xbeg         : heliocentric positions of planets with mass > mtiny prior to Kepler drift !                xend         : heliocentric positions of planets with mass > mtiny after Kepler drift !                ptb          : negative barycentric velocity of the Sun prior to the first kick !                pte          : negative barycentric velocity of the Sun after the second kick !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_step_helio_pl(lfirst, lextra_force, t, npl, nplm, nplmax, helio_pl1P, j2rp2, j4rp4, dt, xbeg, xend, !                                         ptb, pte) ! !  Notes       : Adapted from Hal Levison's Swift routines symba5_step_helio.f and helio_step_pl.f ! !********************************************************************************************************************************** SUBROUTINE symba_step_helio_pl ( lfirst , lextra_force , t , npl , nplm , nplmax , helio_plA , j2rp2 , j4rp4 , dt , xbeg , xend , ptb , pte ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_step_helio_pl IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( IN ) :: lextra_force LOGICAL ( LGT ), INTENT ( INOUT ) :: lfirst INTEGER ( I4B ), INTENT ( IN ) :: npl , nplm , nplmax REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 , dt REAL ( DP ), DIMENSION ( NDIM , nplm ), INTENT ( OUT ) :: xbeg , xend REAL ( DP ), DIMENSION ( NDIM ), INTENT ( OUT ) :: ptb , pte TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA ! Internals LOGICAL ( LGT ) :: lflag INTEGER ( I4B ) :: i REAL ( DP ) :: dth , msys ! Executable code dth = 0.5_DP * dt lflag = lfirst IF ( lfirst ) THEN CALL coord_vh2vb ( npl , helio_plA % swiftest , msys ) lfirst = . FALSE . END IF CALL helio_lindrift ( npl , helio_plA % swiftest , dth , ptb ) CALL symba_helio_getacch ( lflag , lextra_force , t , npl , nplm , nplmax , helio_plA , j2rp2 , j4rp4 ) lflag = . TRUE . CALL helio_kickvb ( npl , helio_plA , dth ) DO i = 2 , nplm xbeg (:, i ) = helio_plA % swiftest % xh (:, i ) END DO CALL helio_drift ( npl , helio_plA % swiftest , dt ) DO i = 2 , nplm xend (:, i ) = helio_plA % swiftest % xh (:, i ) END DO CALL symba_helio_getacch ( lflag , lextra_force , t + dt , npl , nplm , nplmax , helio_plA , j2rp2 , j4rp4 ) CALL helio_kickvb ( npl , helio_plA , dth ) CALL helio_lindrift ( npl , helio_plA % swiftest , dth , pte ) CALL coord_vb2vh ( npl , helio_plA % swiftest ) RETURN END SUBROUTINE symba_step_helio_pl !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_step_helio_pl.f90.html"},{"title":"symba_casedisruption.f90 – swiftest","text":"Unit Name   : symba_casedisruption\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Merge planets Input\n    Arguments : t            : time\n                npl          : number of planets\n                nsppl        : number of spilled planets\n                symba_pl1P   : pointer to head of SyMBA planet structure linked-list\n                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list\n                nplplenc     : number of planet-planet encounters\n                plplenc_list : array of planet-planet encounter structures\n    Terminal  : none\n    File      : none Output\n    Arguments : npl          : number of planets\n                nsppl        : number of spilled planets\n                symba_pl1P   : pointer to head of SyMBA planet structure linked-list\n                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL symba_casedisruption(t, npl, nsppl, symba_pl1P, symba_pld1P, nplplenc, plplenc_list) Notes       : Adapted from Hal Levison's Swift routine discard_mass_merge.f This file depends on sourcefile~~symba_casedisruption.f90~~EfferentGraph sourcefile~symba_casedisruption.f90 symba_casedisruption.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_casedisruption.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_casedisruption.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_casedisruption.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_casedisruption.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_casedisruption.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_casedisruption Source Code symba_casedisruption.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_casedisruption !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Merge planets ! !  Input !    Arguments : t            : time !                npl          : number of planets !                nsppl        : number of spilled planets !                symba_pl1P   : pointer to head of SyMBA planet structure linked-list !                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list !                nplplenc     : number of planet-planet encounters !                plplenc_list : array of planet-planet encounter structures !    Terminal  : none !    File      : none ! !  Output !    Arguments : npl          : number of planets !                nsppl        : number of spilled planets !                symba_pl1P   : pointer to head of SyMBA planet structure linked-list !                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_casedisruption(t, npl, nsppl, symba_pl1P, symba_pld1P, nplplenc, plplenc_list) ! !  Notes       : Adapted from Hal Levison's Swift routine discard_mass_merge.f ! !********************************************************************************************************************************** SUBROUTINE symba_casedisruption ( t , dt , index_enc , nmergeadd , nmergesub , mergeadd_list , mergesub_list , eoffset , vbs , & symba_plA , nplplenc , plplenc_list , & nplmax , ntpmax , fragmax , mres , rres , m1 , m2 , rad1 , rad2 , x1 , x2 , v1 , v2 ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_casedisruption IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: index_enc , nplmax , ntpmax INTEGER ( I4B ), INTENT ( INOUT ) :: nmergeadd , nmergesub , nplplenc , fragmax REAL ( DP ), INTENT ( IN ) :: t , dt REAL ( DP ), INTENT ( INOUT ) :: eoffset , m1 , m2 , rad1 , rad2 REAL ( DP ), DIMENSION ( 3 ), INTENT ( INOUT ) :: mres , rres REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: vbs REAL ( DP ), DIMENSION ( NDIM ), INTENT ( INOUT ) :: x1 , x2 , v1 , v2 TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA ! Internals INTEGER ( I4B ) :: nfrag , i , k , index1 , index2 INTEGER ( I4B ) :: index1_parent , index2_parent INTEGER ( I4B ) :: name1 , name2 REAL ( DP ) :: mtot , msun , avg_d , d_p1 , d_p2 , semimajor_encounter , e , q , semimajor_inward REAL ( DP ) :: rhill_p1 , rhill_p2 , r_circle , theta , radius1 , radius2 REAL ( DP ) :: m_rem , m_test , mass1 , mass2 , enew , eold REAL ( DP ) :: x_com , y_com , z_com , vx_com , vy_com , vz_com REAL ( DP ) :: x_frag , y_frag , z_frag , vx_frag , vy_frag , vz_frag REAL ( DP ), DIMENSION ( NDIM ) :: vnew , xr , mv ! Executable code ! determine the number of fragments and the SFD nfrag = 3 !this will be determined later from collresolve ! instead of nfrag do a mfrag and that way we calculate the number of appropriate frags for each regime and collision ! or do a % of parents mass minus two biggest fragments split index1 = plplenc_list % index1 ( index_enc ) index2 = plplenc_list % index2 ( index_enc ) index1_parent = symba_plA % index_parent ( index1 ) index2_parent = symba_plA % index_parent ( index2 ) name1 = symba_plA % helio % swiftest % name ( index1 ) name2 = symba_plA % helio % swiftest % name ( index2 ) mass1 = symba_plA % helio % swiftest % mass ( index1 ) mass2 = symba_plA % helio % swiftest % mass ( index2 ) radius1 = symba_plA % helio % swiftest % radius ( index1 ) radius2 = symba_plA % helio % swiftest % radius ( index2 ) ! Find COM x_com = (( x1 ( 1 ) * m1 ) + ( x2 ( 1 ) * m2 )) / ( m1 + m2 ) y_com = (( x1 ( 2 ) * m1 ) + ( x2 ( 2 ) * m2 )) / ( m1 + m2 ) z_com = (( x1 ( 3 ) * m1 ) + ( x2 ( 3 ) * m2 )) / ( m1 + m2 ) vx_com = (( v1 ( 1 ) * m1 ) + ( v2 ( 1 ) * m2 )) / ( m1 + m2 ) vy_com = (( v1 ( 2 ) * m1 ) + ( v2 ( 2 ) * m2 )) / ( m1 + m2 ) vz_com = (( v1 ( 3 ) * m1 ) + ( v2 ( 3 ) * m2 )) / ( m1 + m2 ) ! Find energy pre-frag eold = 0.5_DP * ( m1 * DOT_PRODUCT ( v1 (:), v1 (:)) + m2 * DOT_PRODUCT ( v2 (:), v2 (:))) xr (:) = x2 (:) - x1 (:) eold = eold - ( m1 * m2 / ( SQRT ( DOT_PRODUCT ( xr (:), xr (:))))) WRITE ( * , * ) \"Disruption between particles \" , name1 , \" and \" , name2 , \" at time t = \" , t WRITE ( * , * ) \"Number of fragments added: \" , nfrag ! Add both parents to mergesub_list nmergesub = nmergesub + 1 mergesub_list % name ( nmergesub ) = name1 mergesub_list % status ( nmergesub ) = DISRUPTION mergesub_list % xh (:, nmergesub ) = x1 (:) mergesub_list % vh (:, nmergesub ) = v1 (:) - vbs (:) mergesub_list % mass ( nmergesub ) = mass1 mergesub_list % radius ( nmergesub ) = radius1 nmergesub = nmergesub + 1 mergesub_list % name ( nmergesub ) = name2 mergesub_list % status ( nmergesub ) = DISRUPTION mergesub_list % xh (:, nmergesub ) = x2 (:) mergesub_list % vh (:, nmergesub ) = v2 (:) - vbs (:) mergesub_list % mass ( nmergesub ) = mass2 mergesub_list % radius ( nmergesub ) = radius2 ! go through the encounter list and for particles actively encoutering ! prevent them from having further encounters in this timestep by setting status to MERGED DO k = 1 , nplplenc IF (( plplenc_list % status ( k ) == ACTIVE ) . AND . & (( index1 == plplenc_list % index1 ( k ) . OR . index2 == plplenc_list % index2 ( k )) . OR . & ( index2 == plplenc_list % index1 ( k ) . OR . index1 == plplenc_list % index2 ( k )))) THEN plplenc_list % status ( k ) = MERGED END IF END DO symba_plA % helio % swiftest % status ( index1 ) = DISRUPTION symba_plA % helio % swiftest % status ( index2 ) = DISRUPTION ! Calculate the positions of the new fragments rhill_p1 = symba_plA % helio % swiftest % rhill ( index1_parent ) rhill_p2 = symba_plA % helio % swiftest % rhill ( index2_parent ) r_circle = ( rhill_p1 + rhill_p2 ) / ( 2.0_DP * sin ( PI / nfrag )) theta = ( 2.0_DP * PI ) / nfrag semimajor_inward = (( dt * 3 2.0_DP ) ** 2.0_DP ) ** ( 1.0_DP / 3.0_DP ) CALL orbel_xv2aeq ( x1 , v1 , msun , semimajor_encounter , e , q ) IF ( semimajor_inward > ( semimajor_encounter - r_circle )) THEN WRITE ( * , * ) \"Timestep is too large to resolve fragments.\" STOP ELSE ! Add new fragments to mergeadd_list mtot = 0.0_DP ! running total mass of new fragments mv = 0.0_DP ! running sum of m*v of new fragments to be used in COM calculation DO i = 1 , nfrag nmergeadd = nmergeadd + 1 mergeadd_list % name ( nmergeadd ) = nplmax + ntpmax + fragmax + i mergeadd_list % status ( nmergeadd ) = DISRUPTION mergeadd_list % ncomp ( nmergeadd ) = 2 IF ( i == 1 ) THEN ! first largest particle from collresolve mres[0] rres[0] mergeadd_list % mass ( nmergeadd ) = mres ( 1 ) * GC / ( DU2CM ** 3 / ( MU2GM * TU2S ** 2 )) / MU2GM mergeadd_list % radius ( nmergeadd ) = rres ( 1 ) / DU2CM mtot = mtot + mergeadd_list % mass ( nmergeadd ) END IF IF ( i == 2 ) THEN ! second largest particle from collresolve mres[1] rres[1] mergeadd_list % mass ( nmergeadd ) = mres ( 2 ) * GC / ( DU2CM ** 3 / ( MU2GM * TU2S ** 2 )) / MU2GM mergeadd_list % radius ( nmergeadd ) = rres ( 2 ) / DU2CM mtot = mtot + mergeadd_list % mass ( nmergeadd ) END IF IF ( i > 2 ) THEN ! FIXME all other particles implement eq. 31 LS12 ! FIXME current equation taken from Durda et al 2007 Figure 2 Supercatastrophic: N = (1.5e5)e(-1.3*D) d_p1 = ( 3.0_DP * m1 ) / ( 4.0_DP * PI * ( rad1 ** 3.0_DP )) d_p2 = ( 3.0_DP * m2 ) / ( 4.0_DP * PI * ( rad2 ** 3.0_DP )) avg_d = ( d_p1 + d_p2 ) / 2.0_DP m_rem = ( m1 + m2 ) - ( mres ( 1 ) + mres ( 2 )) * GC / ( DU2CM ** 3 / ( MU2GM * TU2S ** 2 )) / MU2GM m_test = ((( - 1.0_DP / 2.6_DP ) * log ( i / ( 1.5_DP * 1 0.0_DP ** 5 ))) ** 3.0_DP ) * (( 4.0_DP / 3.0_DP ) * PI * avg_d ) IF ( m_test < m_rem ) THEN mergeadd_list % mass ( nmergeadd ) = m_test ELSE mergeadd_list % mass ( nmergeadd ) = ( m1 + m2 ) - mtot END IF mergeadd_list % radius ( nmergeadd ) = (( 3.0_DP * mergeadd_list % mass ( nmergeadd )) / ( 4.0_DP * PI * avg_d )) & ** ( 1.0_DP / 3.0_DP ) mtot = mtot + mergeadd_list % mass ( nmergeadd ) END IF x_frag = ( r_circle * cos ( theta * i )) + x_com y_frag = ( r_circle * sin ( theta * i )) + y_com z_frag = z_com vx_frag = (( 1.0_DP / nfrag ) * ( 1.0_DP / mergeadd_list % mass ( nmergeadd )) * (( m1 * v1 ( 1 )) + ( m2 * v2 ( 1 )))) - vbs ( 1 ) vy_frag = (( 1.0_DP / nfrag ) * ( 1.0_DP / mergeadd_list % mass ( nmergeadd )) * (( m1 * v1 ( 2 )) + ( m2 * v2 ( 2 )))) - vbs ( 2 ) vz_frag = vz_com - vbs ( 3 ) mergeadd_list % xh ( 1 , nmergeadd ) = x_frag mergeadd_list % xh ( 2 , nmergeadd ) = y_frag mergeadd_list % xh ( 3 , nmergeadd ) = z_frag mergeadd_list % vh ( 1 , nmergeadd ) = vx_frag mergeadd_list % vh ( 2 , nmergeadd ) = vy_frag mergeadd_list % vh ( 3 , nmergeadd ) = vz_frag mv = mv + ( mergeadd_list % mass ( nmergeadd ) * mergeadd_list % vh (:, nmergeadd )) END DO END IF ! Calculate energy after frag vnew (:) = mv / mtot ! COM of new fragments enew = 0.5_DP * mtot * DOT_PRODUCT ( vnew (:), vnew (:)) eoffset = eoffset + eold - enew ! Update fragmax to account for new fragments fragmax = fragmax + nfrag RETURN END SUBROUTINE symba_casedisruption","tags":"","loc":"sourcefile/symba_casedisruption.f90.html"},{"title":"symba_rearray.f90 – swiftest","text":"Unit Name   : symba_rearray\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Redo array of pl and tp based on discarded and added pl and tp Arguments\n    INTEGER(I4B), INTENT(INOUT)                      :: npl, ntp, nsppl, nsptp, nmergeadd !change to fragadd\n    TYPE(symba_pl), INTENT(INOUT)                    :: symba_plA\n    TYPE(symba_tp), INTENT(INOUT)                    :: symba_tpA\n   TYPE(swiftest_tp), INTENT(INOUT)                 :: discard_tpA\n    TYPE(swiftest_pl), INTENT(INOUT)                 :: discard_plA\n    TYPE(symba_merger), INTENT(INOUT)                :: mergeadd_list !change to fragadd_list\n    type(feature_list),intent(in)                    :: feature Output\n    Arguments : npl         : number of planets\n    Terminal  : none\n    File      : none Invocation  : CALL symba_rearray(npl, ntp, nsppl, nsptp, symba_plA, symba_tpA, nmergeadd, mergeadd_list, discard_plA, &\n  discard_tpA,feature) Notes       : Adapted from Hal Levison's Swift routine discard_massive5.f This file depends on sourcefile~~symba_rearray.f90~~EfferentGraph sourcefile~symba_rearray.f90 symba_rearray.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_rearray.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_rearray.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_rearray.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_rearray.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftestalloc.f90 module_swiftestalloc.f90 sourcefile~symba_rearray.f90->sourcefile~module_swiftestalloc.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_rearray.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftestalloc.f90->sourcefile~module_swiftest.f90 sourcefile~module_swiftestalloc.f90->sourcefile~module_symba.f90 sourcefile~module_swiftestalloc.f90->sourcefile~module_helio.f90 sourcefile~module_swiftestalloc.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_rearray Source Code symba_rearray.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_rearray !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Redo array of pl and tp based on discarded and added pl and tp ! ! Arguments !    INTEGER(I4B), INTENT(INOUT)                      :: npl, ntp, nsppl, nsptp, nmergeadd !change to fragadd !    TYPE(symba_pl), INTENT(INOUT)                    :: symba_plA !    TYPE(symba_tp), INTENT(INOUT)                    :: symba_tpA !   TYPE(swiftest_tp), INTENT(INOUT)                 :: discard_tpA !    TYPE(swiftest_pl), INTENT(INOUT)                 :: discard_plA !    TYPE(symba_merger), INTENT(INOUT)                :: mergeadd_list !change to fragadd_list !    type(feature_list),intent(in)                    :: feature ! !  Output !    Arguments : npl         : number of planets !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_rearray(npl, ntp, nsppl, nsptp, symba_plA, symba_tpA, nmergeadd, mergeadd_list, discard_plA, & !  discard_tpA,feature) ! ! !  Notes       : Adapted from Hal Levison's Swift routine discard_massive5.f ! !********************************************************************************************************************************** SUBROUTINE symba_rearray ( npl , ntp , nsppl , nsptp , symba_plA , symba_tpA , nmergeadd , mergeadd_list , discard_plA , & discard_tpA , feature ) ! Modules USE swiftest USE module_swiftestalloc USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_rearray IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( INOUT ) :: npl , ntp , nsppl , nsptp , nmergeadd !change to fragadd TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA TYPE ( swiftest_tp ), INTENT ( INOUT ) :: discard_tpA TYPE ( swiftest_pl ), INTENT ( INOUT ) :: discard_plA TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list !change to fragadd_list TYPE ( feature_list ), intent ( in ) :: feature ! Internals INTEGER ( I4B ) :: i , nkpl , nktp , nfrag REAL ( DP ) :: mu , energy , ap , r , v2 LOGICAL , DIMENSION ( npl ) :: discard_l_pl , frag_l_add LOGICAL , DIMENSION ( ntp ) :: discard_l_tp ! Executable code IF ( ldiscard . eqv . . TRUE .) THEN nsppl = 0 nkpl = 0 discard_l_pl ( 1 : npl ) = ( symba_plA % helio % swiftest % status ( 1 : npl ) /= ACTIVE ) nsppl = COUNT ( discard_l_pl ) nkpl = npl - nsppl frag_l_add = [(. FALSE ., i = 1 , npl )] IF ( feature % lfragmentation ) THEN DO i = 1 , npl IF ( mergeadd_list % status ( i ) == DISRUPTION ) THEN frag_l_add ( i ) = . TRUE . ELSE IF ( mergeadd_list % status ( i ) == HIT_AND_RUN ) THEN frag_l_add ( i ) = . TRUE . ELSE IF ( mergeadd_list % status ( i ) == SUPERCATASTROPHIC ) THEN frag_l_add ( i ) = . TRUE . ELSE frag_l_add ( i ) = . FALSE . END IF END DO END IF nfrag = COUNT ( frag_l_add ) CALL swiftest_pl_allocate ( discard_plA , nsppl ) discard_plA % name ( 1 : nsppl ) = PACK ( symba_plA % helio % swiftest % name ( 1 : npl ), discard_l_pl ) discard_plA % status ( 1 : nsppl ) = PACK ( symba_plA % helio % swiftest % status ( 1 : npl ), discard_l_pl ) discard_plA % mass ( 1 : nsppl ) = PACK ( symba_plA % helio % swiftest % mass ( 1 : npl ), discard_l_pl ) discard_plA % radius ( 1 : nsppl ) = PACK ( symba_plA % helio % swiftest % radius ( 1 : npl ), discard_l_pl ) discard_plA % xh ( 1 , 1 : nsppl ) = PACK ( symba_plA % helio % swiftest % xh ( 1 , 1 : npl ), discard_l_pl ) discard_plA % xh ( 2 , 1 : nsppl ) = PACK ( symba_plA % helio % swiftest % xh ( 2 , 1 : npl ), discard_l_pl ) discard_plA % xh ( 3 , 1 : nsppl ) = PACK ( symba_plA % helio % swiftest % xh ( 3 , 1 : npl ), discard_l_pl ) discard_plA % vh ( 1 , 1 : nsppl ) = PACK ( symba_plA % helio % swiftest % vh ( 1 , 1 : npl ), discard_l_pl ) discard_plA % vh ( 2 , 1 : nsppl ) = PACK ( symba_plA % helio % swiftest % vh ( 2 , 1 : npl ), discard_l_pl ) discard_plA % vh ( 3 , 1 : nsppl ) = PACK ( symba_plA % helio % swiftest % vh ( 3 , 1 : npl ), discard_l_pl ) discard_plA % rhill ( 1 : nsppl ) = PACK ( symba_plA % helio % swiftest % rhill ( 1 : npl ), discard_l_pl ) discard_plA % xb ( 1 , 1 : nsppl ) = PACK ( symba_plA % helio % swiftest % xb ( 1 , 1 : npl ), discard_l_pl ) discard_plA % xb ( 2 , 1 : nsppl ) = PACK ( symba_plA % helio % swiftest % xb ( 2 , 1 : npl ), discard_l_pl ) discard_plA % xb ( 3 , 1 : nsppl ) = PACK ( symba_plA % helio % swiftest % xb ( 3 , 1 : npl ), discard_l_pl ) discard_plA % vb ( 1 , 1 : nsppl ) = PACK ( symba_plA % helio % swiftest % vb ( 1 , 1 : npl ), discard_l_pl ) discard_plA % vb ( 2 , 1 : nsppl ) = PACK ( symba_plA % helio % swiftest % vb ( 2 , 1 : npl ), discard_l_pl ) discard_plA % vb ( 3 , 1 : nsppl ) = PACK ( symba_plA % helio % swiftest % vb ( 3 , 1 : npl ), discard_l_pl ) IF ( feature % lfragmentation . AND . ( nkpl + nfrag > npl )) THEN symba_plA % helio % swiftest % name ( 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % name ( 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % status ( 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % status ( 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % mass ( 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % mass ( 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % radius ( 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % radius ( 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % xh ( 1 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % xh ( 1 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % xh ( 2 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % xh ( 2 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % xh ( 3 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % xh ( 3 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % vh ( 1 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % vh ( 1 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % vh ( 2 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % vh ( 2 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % vh ( 3 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % vh ( 3 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % rhill ( 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % rhill ( 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % xb ( 1 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % xb ( 1 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % xb ( 2 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % xb ( 2 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % xb ( 3 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % xb ( 3 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % vb ( 1 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % vb ( 1 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % vb ( 2 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % vb ( 2 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % vb ( 3 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % vb ( 3 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % ah ( 1 , 1 : nkpl ) = PACK ( symba_plA % helio % ah ( 1 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % ah ( 2 , 1 : nkpl ) = PACK ( symba_plA % helio % ah ( 2 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % ah ( 3 , 1 : nkpl ) = PACK ( symba_plA % helio % ah ( 3 , 1 : npl ), . NOT . discard_l_pl ) CALL util_resize_pl ( symba_plA , nkpl + nfrag , npl ) npl = nkpl + nfrag !add fragments symba_plA % helio % swiftest % name ( nkpl + 1 : npl ) = PACK ( mergeadd_list % name ( 1 : nmergeadd ), frag_l_add ) symba_plA % helio % swiftest % status ( nkpl + 1 : npl ) = [( ACTIVE , i = 1 , nfrag )] !array of ACTIVE STATUS symba_plA % helio % swiftest % mass ( nkpl + 1 : npl ) = PACK ( mergeadd_list % mass ( 1 : nmergeadd ), frag_l_add ) symba_plA % helio % swiftest % radius ( nkpl + 1 : npl ) = PACK ( mergeadd_list % radius ( 1 : nmergeadd ), frag_l_add ) symba_plA % helio % swiftest % xh ( 1 , nkpl + 1 : npl ) = PACK ( mergeadd_list % xh ( 1 , 1 : nmergeadd ), frag_l_add ) symba_plA % helio % swiftest % xh ( 2 , nkpl + 1 : npl ) = PACK ( mergeadd_list % xh ( 2 , 1 : nmergeadd ), frag_l_add ) symba_plA % helio % swiftest % xh ( 3 , nkpl + 1 : npl ) = PACK ( mergeadd_list % xh ( 3 , 1 : nmergeadd ), frag_l_add ) symba_plA % helio % swiftest % vh ( 1 , nkpl + 1 : npl ) = PACK ( mergeadd_list % vh ( 1 , 1 : nmergeadd ), frag_l_add ) symba_plA % helio % swiftest % vh ( 2 , nkpl + 1 : npl ) = PACK ( mergeadd_list % vh ( 2 , 1 : nmergeadd ), frag_l_add ) symba_plA % helio % swiftest % vh ( 3 , nkpl + 1 : npl ) = PACK ( mergeadd_list % vh ( 3 , 1 : nmergeadd ), frag_l_add ) DO i = nkpl + 1 , npl mu = symba_plA % helio % swiftest % mass ( 1 ) + symba_plA % helio % swiftest % mass ( i ) r = SQRT ( DOT_PRODUCT ( symba_plA % helio % swiftest % xh (:, i ), symba_plA % helio % swiftest % xh (:, i ))) v2 = DOT_PRODUCT ( symba_plA % helio % swiftest % vh (:, i ), symba_plA % helio % swiftest % vh (:, i )) energy = 0.5_DP * v2 - mu / r ap = - 0.5_DP * mu / energy symba_plA % helio % swiftest % rhill ( i ) = ap * ((( symba_plA % helio % swiftest % mass ( i ) / mu ) / 3.0_DP ) ** ( 1.0_DP / 3.0_DP )) END DO ELSE symba_plA % helio % swiftest % name ( 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % name ( 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % status ( 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % status ( 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % mass ( 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % mass ( 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % radius ( 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % radius ( 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % xh ( 1 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % xh ( 1 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % xh ( 2 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % xh ( 2 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % xh ( 3 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % xh ( 3 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % vh ( 1 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % vh ( 1 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % vh ( 2 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % vh ( 2 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % vh ( 3 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % vh ( 3 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % rhill ( 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % rhill ( 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % xb ( 1 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % xb ( 1 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % xb ( 2 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % xb ( 2 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % xb ( 3 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % xb ( 3 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % vb ( 1 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % vb ( 1 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % vb ( 2 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % vb ( 2 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % swiftest % vb ( 3 , 1 : nkpl ) = PACK ( symba_plA % helio % swiftest % vb ( 3 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % ah ( 1 , 1 : nkpl ) = PACK ( symba_plA % helio % ah ( 1 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % ah ( 2 , 1 : nkpl ) = PACK ( symba_plA % helio % ah ( 2 , 1 : npl ), . NOT . discard_l_pl ) symba_plA % helio % ah ( 3 , 1 : nkpl ) = PACK ( symba_plA % helio % ah ( 3 , 1 : npl ), . NOT . discard_l_pl ) npl = nkpl END IF END IF IF ( ldiscard_tp . eqv . . TRUE .) THEN nktp = 0 nsptp = 0 discard_l_tp ( 1 : ntp ) = ( symba_tpA % helio % swiftest % status ( 1 : ntp ) /= ACTIVE ) nsptp = COUNT ( discard_l_tp ) nktp = ntp - nsptp CALL swiftest_tp_allocate ( discard_tpA , nsptp ) discard_tpA % name ( 1 : nsptp ) = PACK ( symba_tpA % helio % swiftest % name ( 1 : ntp ), discard_l_tp ) discard_tpA % status ( 1 : nsptp ) = PACK ( symba_tpA % helio % swiftest % status ( 1 : ntp ), discard_l_tp ) discard_tpA % xh ( 1 , 1 : nsptp ) = PACK ( symba_tpA % helio % swiftest % xh ( 1 , 1 : ntp ), discard_l_tp ) discard_tpA % xh ( 2 , 1 : nsptp ) = PACK ( symba_tpA % helio % swiftest % xh ( 2 , 1 : ntp ), discard_l_tp ) discard_tpA % xh ( 3 , 1 : nsptp ) = PACK ( symba_tpA % helio % swiftest % xh ( 3 , 1 : ntp ), discard_l_tp ) discard_tpA % vh ( 1 , 1 : nsptp ) = PACK ( symba_tpA % helio % swiftest % vh ( 1 , 1 : ntp ), discard_l_tp ) discard_tpA % vh ( 2 , 1 : nsptp ) = PACK ( symba_tpA % helio % swiftest % vh ( 2 , 1 : ntp ), discard_l_tp ) discard_tpA % vh ( 3 , 1 : nsptp ) = PACK ( symba_tpA % helio % swiftest % vh ( 3 , 1 : ntp ), discard_l_tp ) discard_tpA % isperi ( 1 : nsptp ) = PACK ( symba_tpA % helio % swiftest % isperi ( 1 : ntp ), discard_l_tp ) discard_tpA % peri ( 1 : nsptp ) = PACK ( symba_tpA % helio % swiftest % peri ( 1 : ntp ), discard_l_tp ) discard_tpA % atp ( 1 : nsptp ) = PACK ( symba_tpA % helio % swiftest % atp ( 1 : ntp ), discard_l_tp ) discard_tpA % xb ( 1 , 1 : nsptp ) = PACK ( symba_tpA % helio % swiftest % xb ( 1 , 1 : ntp ), discard_l_tp ) discard_tpA % xb ( 2 , 1 : nsptp ) = PACK ( symba_tpA % helio % swiftest % xb ( 2 , 1 : ntp ), discard_l_tp ) discard_tpA % xb ( 3 , 1 : nsptp ) = PACK ( symba_tpA % helio % swiftest % xb ( 3 , 1 : ntp ), discard_l_tp ) discard_tpA % vb ( 1 , 1 : nsptp ) = PACK ( symba_tpA % helio % swiftest % vb ( 1 , 1 : ntp ), discard_l_tp ) discard_tpA % vb ( 2 , 1 : nsptp ) = PACK ( symba_tpA % helio % swiftest % vb ( 2 , 1 : ntp ), discard_l_tp ) discard_tpA % vb ( 3 , 1 : nsptp ) = PACK ( symba_tpA % helio % swiftest % vb ( 3 , 1 : ntp ), discard_l_tp ) symba_tpA % helio % swiftest % name ( 1 : nktp ) = PACK ( symba_tpA % helio % swiftest % name ( 1 : ntp ), . NOT . discard_l_tp ) symba_tpA % helio % swiftest % status ( 1 : nktp ) = PACK ( symba_tpA % helio % swiftest % status ( 1 : ntp ), . NOT . discard_l_tp ) symba_tpA % helio % swiftest % xh ( 1 , 1 : nktp ) = PACK ( symba_tpA % helio % swiftest % xh ( 1 , 1 : ntp ), . NOT . discard_l_tp ) symba_tpA % helio % swiftest % xh ( 2 , 1 : nktp ) = PACK ( symba_tpA % helio % swiftest % xh ( 2 , 1 : ntp ), . NOT . discard_l_tp ) symba_tpA % helio % swiftest % xh ( 3 , 1 : nktp ) = PACK ( symba_tpA % helio % swiftest % xh ( 3 , 1 : ntp ), . NOT . discard_l_tp ) symba_tpA % helio % swiftest % vh ( 1 , 1 : nktp ) = PACK ( symba_tpA % helio % swiftest % vh ( 1 , 1 : ntp ), . NOT . discard_l_tp ) symba_tpA % helio % swiftest % vh ( 2 , 1 : nktp ) = PACK ( symba_tpA % helio % swiftest % vh ( 2 , 1 : ntp ), . NOT . discard_l_tp ) symba_tpA % helio % swiftest % vh ( 3 , 1 : nktp ) = PACK ( symba_tpA % helio % swiftest % vh ( 3 , 1 : ntp ), . NOT . discard_l_tp ) symba_tpA % helio % swiftest % xb ( 1 , 1 : nktp ) = PACK ( symba_tpA % helio % swiftest % xb ( 1 , 1 : ntp ), . NOT . discard_l_tp ) symba_tpA % helio % swiftest % xb ( 2 , 1 : nktp ) = PACK ( symba_tpA % helio % swiftest % xb ( 2 , 1 : ntp ), . NOT . discard_l_tp ) symba_tpA % helio % swiftest % xb ( 3 , 1 : nktp ) = PACK ( symba_tpA % helio % swiftest % xb ( 3 , 1 : ntp ), . NOT . discard_l_tp ) symba_tpA % helio % swiftest % vb ( 1 , 1 : nktp ) = PACK ( symba_tpA % helio % swiftest % vb ( 1 , 1 : ntp ), . NOT . discard_l_tp ) symba_tpA % helio % swiftest % vb ( 2 , 1 : nktp ) = PACK ( symba_tpA % helio % swiftest % vb ( 2 , 1 : ntp ), . NOT . discard_l_tp ) symba_tpA % helio % swiftest % vb ( 3 , 1 : nktp ) = PACK ( symba_tpA % helio % swiftest % vb ( 3 , 1 : ntp ), . NOT . discard_l_tp ) symba_tpA % helio % swiftest % isperi ( 1 : nktp ) = PACK ( symba_tpA % helio % swiftest % isperi ( 1 : ntp ), . NOT . discard_l_tp ) symba_tpA % helio % swiftest % peri ( 1 : nktp ) = PACK ( symba_tpA % helio % swiftest % peri ( 1 : ntp ), . NOT . discard_l_tp ) symba_tpA % helio % swiftest % atp ( 1 : nktp ) = PACK ( symba_tpA % helio % swiftest % atp ( 1 : ntp ), . NOT . discard_l_tp ) symba_tpA % helio % ah ( 1 , 1 : nktp ) = PACK ( symba_tpA % helio % ah ( 1 , 1 : ntp ), . NOT . discard_l_tp ) symba_tpA % helio % ah ( 2 , 1 : nktp ) = PACK ( symba_tpA % helio % ah ( 2 , 1 : ntp ), . NOT . discard_l_tp ) symba_tpA % helio % ah ( 3 , 1 : nktp ) = PACK ( symba_tpA % helio % ah ( 3 , 1 : ntp ), . NOT . discard_l_tp ) ntp = nktp END IF END SUBROUTINE symba_rearray","tags":"","loc":"sourcefile/symba_rearray.f90.html"},{"title":"symba_user_getacch_tp.f90 – swiftest","text":"Unit Name   : symba_user_getacch_tp\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Add user-supplied heliocentric accelerations to test particles Input\n    Arguments : t          : time\n                ntp        : number of active test particles\n                symba_tp1P : pointer to head of active SyMBA test particle structure linked-list\n    Terminal  : TBS as needed by user\n    File      : TBS as needed by user Output\n    Arguments : symba_tp1P : pointer to head of active SyMBA test particle structure linked-list\n    Terminal  : TBS as needed by user\n    File      : TBS as needed by user Invocation  : CALL symba_user_getacch_tp(t, ntp, symba_tp1P) Notes       : Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_user_getacch_tp.f90~~EfferentGraph sourcefile~symba_user_getacch_tp.f90 symba_user_getacch_tp.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_user_getacch_tp.f90->sourcefile~module_interfaces.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_user_getacch_tp.f90->sourcefile~module_symba.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_user_getacch_tp.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_user_getacch_tp Source Code symba_user_getacch_tp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_user_getacch_tp !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Add user-supplied heliocentric accelerations to test particles ! !  Input !    Arguments : t          : time !                ntp        : number of active test particles !                symba_tp1P : pointer to head of active SyMBA test particle structure linked-list !    Terminal  : TBS as needed by user !    File      : TBS as needed by user ! !  Output !    Arguments : symba_tp1P : pointer to head of active SyMBA test particle structure linked-list !    Terminal  : TBS as needed by user !    File      : TBS as needed by user ! !  Invocation  : CALL symba_user_getacch_tp(t, ntp, symba_tp1P) ! !  Notes       : ! !********************************************************************************************************************************** SUBROUTINE symba_user_getacch_tp ( t , ntp , symba_tpA ) ! Modules USE swiftest USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_user_getacch_tp IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: ntp REAL ( DP ), INTENT ( IN ) :: t TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA ! Internals ! Executable code RETURN END SUBROUTINE symba_user_getacch_tp !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_user_getacch_tp.f90.html"},{"title":"symba_step_recur.f90 – swiftest","text":"Unit Name   : symba_step_recur\n  Unit Type   : recursive subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Step interacting planets and active test particles ahead in democratic heliocentric coordinates at the current\n                recursion level, if applicable, and descend to the next deeper level if necessary Input\n    Arguments : lclose         : logical flag indicating whether to check for mergers\n                t              : time\n                ireci          : input recursion level\n                npl            : number of planets\n                nplm           : number of planets with mass > mtiny\n                ntp            : number of active test particles\n                symba_pl1P     : pointer to head of SyMBA planet structure linked-list\n                symba_tp1P     : pointer to head of active SyMBA test particle structure linked-list\n                dt0            : time step (primary time step for overall integration)\n                eoffset        : energy offset (net energy lost in mergers)\n                nplplenc       : number of planet-planet encounters\n                npltpenc       : number of planet-test particle encounters\n                plplenc_list   : array of planet-planet encounter structures\n                pltpenc_list   : array of planet-test particle encounter structures\n                nmergeadd      : number of merged planets to add\n                nmergesub      : number of merged planets to subtract\n                mergeadd_list  : array of structures of merged planets to add\n                mergesub_list  : array of structures of merged planets to subtract\n                encounter_file : name of output file for encounters\n                out_type       : binary format of output file\n    Terminal  : none\n    File      : none Output\n    Arguments : symba_pl1P     : pointer to head of SyMBA planet structure linked-list\n                symba_tp1P     : pointer to head of active SyMBA test particle structure linked-list\n                eoffset        : energy offset (net energy lost in mergers)\n                plplenc_list   : array of planet-planet encounter structures\n                pltpenc_list   : array of planet-test particle encounter structures\n                nmergeadd      : number of merged planets to add\n                nmergesub      : number of merged planets to subtract\n                mergeadd_list  : array of structures of merged planets to add\n                mergesub_list  : array of structures of merged planets to subtract\n    Terminal  : warning message\n    File      : none Invocation  : CALL symba_step_recur(lclose, t, ireci, npl, nplm, ntp, symba_pl1P, symba_tp1P, dt0, eoffset, nplplenc, npltpenc,\n                                      plplenc_list, pltpenc_list, nmergeadd, nmergesub, mergeadd_list, mergesub_list,\n                                      encounter_file, out_type) Notes       : Adapted from Hal Levison's Swift routine symba5_step_recur.F Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_step_recur.f90~~EfferentGraph sourcefile~symba_step_recur.f90 symba_step_recur.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_step_recur.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_step_recur.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_step_recur.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_step_recur.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_step_recur.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_step_recur Source Code symba_step_recur.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_step_recur !  Unit Type   : recursive subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Step interacting planets and active test particles ahead in democratic heliocentric coordinates at the current !                recursion level, if applicable, and descend to the next deeper level if necessary ! !  Input !    Arguments : lclose         : logical flag indicating whether to check for mergers !                t              : time !                ireci          : input recursion level !                npl            : number of planets !                nplm           : number of planets with mass > mtiny !                ntp            : number of active test particles !                symba_pl1P     : pointer to head of SyMBA planet structure linked-list !                symba_tp1P     : pointer to head of active SyMBA test particle structure linked-list !                dt0            : time step (primary time step for overall integration) !                eoffset        : energy offset (net energy lost in mergers) !                nplplenc       : number of planet-planet encounters !                npltpenc       : number of planet-test particle encounters !                plplenc_list   : array of planet-planet encounter structures !                pltpenc_list   : array of planet-test particle encounter structures !                nmergeadd      : number of merged planets to add !                nmergesub      : number of merged planets to subtract !                mergeadd_list  : array of structures of merged planets to add !                mergesub_list  : array of structures of merged planets to subtract !                encounter_file : name of output file for encounters !                out_type       : binary format of output file !    Terminal  : none !    File      : none ! !  Output !    Arguments : symba_pl1P     : pointer to head of SyMBA planet structure linked-list !                symba_tp1P     : pointer to head of active SyMBA test particle structure linked-list !                eoffset        : energy offset (net energy lost in mergers) !                plplenc_list   : array of planet-planet encounter structures !                pltpenc_list   : array of planet-test particle encounter structures !                nmergeadd      : number of merged planets to add !                nmergesub      : number of merged planets to subtract !                mergeadd_list  : array of structures of merged planets to add !                mergesub_list  : array of structures of merged planets to subtract !    Terminal  : warning message !    File      : none ! !  Invocation  : CALL symba_step_recur(lclose, t, ireci, npl, nplm, ntp, symba_pl1P, symba_tp1P, dt0, eoffset, nplplenc, npltpenc, !                                      plplenc_list, pltpenc_list, nmergeadd, nmergesub, mergeadd_list, mergesub_list, !                                      encounter_file, out_type) ! !  Notes       : Adapted from Hal Levison's Swift routine symba5_step_recur.F ! !********************************************************************************************************************************** RECURSIVE SUBROUTINE symba_step_recur ( lclose , t , ireci , npl , nplm , ntp , symba_plA , symba_tpA , dt0 , eoffset , nplplenc , npltpenc , & plplenc_list , pltpenc_list , nmergeadd , nmergesub , mergeadd_list , mergesub_list , encounter_file , out_type , & nplmax , ntpmax , fragmax , feature ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_step_recur IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( IN ) :: lclose INTEGER ( I4B ), INTENT ( INOUT ) :: ireci , npl , nplm , ntp , nplplenc , npltpenc , nplmax , ntpmax , fragmax INTEGER ( I4B ), INTENT ( INOUT ) :: nmergeadd , nmergesub REAL ( DP ), INTENT ( IN ) :: t , dt0 REAL ( DP ), INTENT ( INOUT ) :: eoffset CHARACTER ( * ), INTENT ( IN ) :: encounter_file , out_type TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list TYPE ( symba_pltpenc ), INTENT ( INOUT ) :: pltpenc_list TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list type ( feature_list ), intent ( in ) :: feature ! Internals LOGICAL ( LGT ) :: lencounter INTEGER ( I4B ) :: i , j , irecp , icflg , index_i , index_j , index_pl , index_tp REAL ( DP ) :: dtl , dth , sgn REAL ( DP ), DIMENSION ( NDIM ) :: xr , vr , vbs ! Executable code dtl = dt0 / ( NTENC ** ireci ) dth = 0.5_DP * dtl IF ( dtl / dt0 < TINY ) THEN WRITE ( * , * ) \"SWIFTEST Warning:\" WRITE ( * , * ) \"   In symba_step_recur, local time step is too small\" WRITE ( * , * ) \"   Roundoff error will be important!\" END IF irecp = ireci + 1 IF ( ireci == 0 ) THEN icflg = 0 DO i = 1 , nplplenc IF (( plplenc_list % status ( i ) == ACTIVE ) . AND . ( plplenc_list % level ( i ) == ireci )) THEN index_i = plplenc_list % index1 ( i ) index_j = plplenc_list % index2 ( i ) xr (:) = symba_plA % helio % swiftest % xh (:, index_j ) - symba_plA % helio % swiftest % xh (:, index_i ) vr (:) = symba_plA % helio % swiftest % vb (:, index_j ) - symba_plA % helio % swiftest % vb (:, index_i ) CALL symba_chk ( xr (:), vr (:), symba_plA % helio % swiftest % rhill ( index_i ), & symba_plA % helio % swiftest % rhill ( index_j ), dtl , irecp , lencounter , & plplenc_list % lvdotr ( i )) IF ( lencounter ) THEN icflg = 1 symba_plA % levelg ( index_i ) = irecp symba_plA % levelm ( index_i ) = MAX ( irecp , symba_plA % levelm ( index_i )) symba_plA % levelg ( index_j ) = irecp symba_plA % levelm ( index_j ) = MAX ( irecp , symba_plA % levelm ( index_j )) plplenc_list % level ( i ) = irecp END IF END IF END DO DO i = 1 , npltpenc IF (( pltpenc_list % status ( i ) == ACTIVE ) . AND . ( pltpenc_list % level ( i ) == ireci )) THEN index_pl = pltpenc_list % indexpl ( i ) index_tp = pltpenc_list % indextp ( i ) xr (:) = symba_tpA % helio % swiftest % xh (:, index_tp ) - symba_plA % helio % swiftest % xh (:, index_pl ) vr (:) = symba_tpA % helio % swiftest % vb (:, index_tp ) - symba_plA % helio % swiftest % vb (:, index_pl ) CALL symba_chk ( xr (:), vr (:), symba_plA % helio % swiftest % rhill ( index_pl ), 0.0_DP , & dtl , irecp , lencounter , pltpenc_list % lvdotr ( i )) IF ( lencounter ) THEN icflg = 1 symba_plA % levelg ( index_pl ) = irecp symba_plA % levelm ( index_pl ) = MAX ( irecp , symba_plA % levelm ( index_pl )) symba_tpA % levelg ( index_tp ) = irecp symba_tpA % levelm ( index_tp ) = MAX ( irecp , symba_tpA % levelm ( index_tp )) pltpenc_list % level ( i ) = irecp END IF END IF END DO lencounter = ( icflg == 1 ) sgn = 1.0_DP CALL symba_kick ( irecp , nplplenc , npltpenc , plplenc_list , pltpenc_list , dth , sgn , symba_plA , symba_tpA ) CALL symba_helio_drift ( ireci , npl , symba_plA , dtl ) IF ( ntp > 0 ) CALL symba_helio_drift_tp ( ireci , ntp , symba_tpA , symba_plA % helio % swiftest % mass ( 1 ), dtl ) IF ( lencounter ) CALL symba_step_recur ( lclose , t , irecp , npl , nplm , ntp , symba_plA , symba_tpA , dt0 , eoffset , nplplenc , & npltpenc , plplenc_list , pltpenc_list , nmergeadd , nmergesub , mergeadd_list , mergesub_list , encounter_file , out_type , & nplmax , ntpmax , fragmax , feature ) sgn = 1.0_DP CALL symba_kick ( irecp , nplplenc , npltpenc , plplenc_list , pltpenc_list , dth , sgn , symba_plA , symba_tpA ) IF ( lclose ) THEN vbs (:) = symba_plA % helio % swiftest % vb (:, 1 ) DO i = 1 , nplplenc index_i = plplenc_list % index1 ( i ) index_j = plplenc_list % index2 ( i ) IF ((( plplenc_list % status ( i ) == ACTIVE ) . AND . & ( symba_plA % levelg ( index_i ) >= ireci ) . AND . & ( symba_plA % levelg ( index_j ) >= ireci ))) THEN ! Create if statement to check for collisions (LS12) or merger depending on flag lfrag in param.in ! Determines collisional regime if lfrag=.TRUE. for close encounter planets ! CALL symba_frag_pl(...) ! Determines if close encounter leads to merger if lfrag=.FALSE. IF ( feature % lfragmentation ) THEN CALL symba_fragmentation ( t , dtl , i , nmergeadd , nmergesub , mergeadd_list , mergesub_list , & eoffset , vbs , encounter_file , out_type , npl , ntp , symba_plA , symba_tpA , & nplplenc , npltpenc , pltpenc_list , plplenc_list , nplmax , ntpmax , fragmax ) ELSE CALL symba_merge_pl ( t , dtl , i , nplplenc , plplenc_list , nmergeadd , nmergesub , mergeadd_list , & mergesub_list , eoffset , vbs , encounter_file , out_type , npl , symba_plA , symba_tpA ) END IF END IF END DO DO i = 1 , npltpenc index_pl = pltpenc_list % indexpl ( i ) index_tp = pltpenc_list % indextp ( i ) IF (( pltpenc_list % status ( i ) == ACTIVE ) . AND . & ( symba_plA % levelg ( index_pl ) >= ireci ) . AND . & ( symba_tpA % levelg ( index_tp ) >= ireci )) THEN CALL symba_merge_tp ( t , dtl , i , npltpenc , pltpenc_list , vbs , encounter_file , out_type , symba_plA , symba_tpA ) !check later END IF END DO END IF DO i = 1 , nplplenc index_i = plplenc_list % index1 ( i ) index_j = plplenc_list % index2 ( i ) IF ( symba_plA % levelg ( index_i ) == irecp ) symba_plA % levelg ( index_i ) = ireci IF ( symba_plA % levelg ( index_j ) == irecp ) symba_plA % levelg ( index_j ) = ireci IF ( plplenc_list % level ( i ) == irecp ) plplenc_list % level ( i ) = ireci END DO DO i = 1 , npltpenc index_pl = pltpenc_list % indexpl ( i ) index_tp = pltpenc_list % indextp ( i ) IF ( symba_plA % levelg ( index_pl ) == irecp ) symba_plA % levelg ( index_pl ) = ireci IF ( symba_tpA % levelg ( index_tp ) == irecp ) symba_tpA % levelg ( index_tp ) = ireci IF ( pltpenc_list % level ( i ) == irecp ) pltpenc_list % level ( i ) = ireci END DO ELSE DO j = 1 , NTENC icflg = 0 DO i = 1 , nplplenc IF (( plplenc_list % status ( i ) == ACTIVE ) . AND . ( plplenc_list % level ( i ) == ireci )) THEN index_i = plplenc_list % index1 ( i ) index_j = plplenc_list % index2 ( i ) xr (:) = symba_plA % helio % swiftest % xh (:, index_j ) - symba_plA % helio % swiftest % xh (:, index_i ) vr (:) = symba_plA % helio % swiftest % vb (:, index_j ) - symba_plA % helio % swiftest % vb (:, index_i ) CALL symba_chk ( xr (:), vr (:), symba_plA % helio % swiftest % rhill ( index_i ), & symba_plA % helio % swiftest % rhill ( index_j ), dtl , irecp , lencounter , & plplenc_list % lvdotr ( i )) IF ( lencounter ) THEN icflg = 1 symba_plA % levelg ( index_i ) = irecp symba_plA % levelm ( index_i ) = MAX ( irecp , symba_plA % levelm ( index_i )) symba_plA % levelg ( index_j ) = irecp symba_plA % levelm ( index_j ) = MAX ( irecp , symba_plA % levelm ( index_j )) plplenc_list % level ( i ) = irecp END IF END IF END DO DO i = 1 , npltpenc IF (( pltpenc_list % status ( i ) == ACTIVE ) . AND . ( pltpenc_list % level ( i ) == ireci )) THEN index_pl = pltpenc_list % indexpl ( i ) index_tp = pltpenc_list % indextp ( i ) xr (:) = symba_tpA % helio % swiftest % xh (:, index_tp ) - symba_plA % helio % swiftest % xh (:, index_pl ) vr (:) = symba_tpA % helio % swiftest % vb (:, index_tp ) - symba_plA % helio % swiftest % vb (:, index_pl ) CALL symba_chk ( xr (:), vr (:), symba_plA % helio % swiftest % rhill ( index_pl ), 0.0_DP , & dtl , irecp , lencounter , pltpenc_list % lvdotr ( i )) IF ( lencounter ) THEN icflg = 1 symba_plA % levelg ( index_pl ) = irecp symba_plA % levelm ( index_pl ) = MAX ( irecp , symba_plA % levelm ( index_pl )) symba_tpA % levelg ( index_tp ) = irecp symba_tpA % levelm ( index_tp ) = MAX ( irecp , symba_tpA % levelm ( index_tp )) pltpenc_list % level ( i ) = irecp END IF END IF END DO lencounter = ( icflg == 1 ) sgn = 1.0_DP CALL symba_kick ( irecp , nplplenc , npltpenc , plplenc_list , pltpenc_list , dth , sgn , symba_plA , symba_tpA ) sgn = - 1.0_DP CALL symba_kick ( irecp , nplplenc , npltpenc , plplenc_list , pltpenc_list , dth , sgn , symba_plA , symba_tpA ) CALL symba_helio_drift ( ireci , npl , symba_plA , dtl ) IF ( ntp > 0 ) CALL symba_helio_drift_tp ( ireci , ntp , symba_tpA , symba_plA % helio % swiftest % mass ( 1 ), dtl ) IF ( lencounter ) CALL symba_step_recur ( lclose , t , irecp , npl , nplm , ntp , symba_plA , symba_tpA , dt0 , eoffset , & nplplenc , npltpenc , plplenc_list , pltpenc_list , nmergeadd , nmergesub , mergeadd_list , mergesub_list , & encounter_file , out_type , nplmax , ntpmax , fragmax , feature ) sgn = 1.0_DP CALL symba_kick ( irecp , nplplenc , npltpenc , plplenc_list , pltpenc_list , dth , sgn , symba_plA , symba_tpA ) sgn = - 1.0_DP CALL symba_kick ( irecp , nplplenc , npltpenc , plplenc_list , pltpenc_list , dth , sgn , symba_plA , symba_tpA ) IF ( lclose ) THEN vbs (:) = symba_plA % helio % swiftest % vb (:, 1 ) DO i = 1 , nplplenc index_i = plplenc_list % index1 ( i ) index_j = plplenc_list % index2 ( i ) IF (( plplenc_list % status ( i ) == ACTIVE ) . AND . & ( symba_plA % levelg ( index_i ) >= ireci ) . AND . & ( symba_plA % levelg ( index_j ) >= ireci )) THEN IF ( feature % lfragmentation ) THEN CALL symba_fragmentation ( t , dtl , i , nmergeadd , nmergesub , mergeadd_list , & mergesub_list , eoffset , vbs , encounter_file , out_type , npl , ntp , & symba_plA , symba_tpA , nplplenc , npltpenc , pltpenc_list , plplenc_list , & nplmax , ntpmax , fragmax ) ELSE CALL symba_merge_pl ( t , dtl , i , nplplenc , plplenc_list , nmergeadd , nmergesub , mergeadd_list , & mergesub_list , eoffset , vbs , encounter_file , out_type , npl , symba_plA , symba_tpA ) END IF END IF END DO DO i = 1 , npltpenc index_pl = pltpenc_list % indexpl ( i ) index_tp = pltpenc_list % indextp ( i ) IF (( pltpenc_list % status ( i ) == ACTIVE ) . AND . & ( symba_plA % levelg ( index_pl ) >= ireci ) . AND . & ( symba_tpA % levelg ( index_tp ) >= ireci )) & CALL symba_merge_tp ( t , dtl , i , npltpenc , pltpenc_list , vbs , encounter_file , out_type , & symba_plA , symba_tpA ) !check that later END DO END IF DO i = 1 , nplplenc index_i = plplenc_list % index1 ( i ) index_j = plplenc_list % index2 ( i ) IF ( symba_plA % levelg ( index_i ) == irecp ) symba_plA % levelg ( index_i ) = ireci IF ( symba_plA % levelg ( index_j ) == irecp ) symba_plA % levelg ( index_j ) = ireci IF ( plplenc_list % level ( i ) == irecp ) plplenc_list % level ( i ) = ireci END DO DO i = 1 , npltpenc index_pl = pltpenc_list % indexpl ( i ) index_tp = pltpenc_list % indextp ( i ) IF ( symba_plA % levelg ( index_pl ) == irecp ) symba_plA % levelg ( index_pl ) = ireci IF ( symba_tpA % levelg ( index_tp ) == irecp ) symba_tpA % levelg ( index_tp ) = ireci IF ( pltpenc_list % level ( i ) == irecp ) pltpenc_list % level ( i ) = ireci END DO END DO END IF RETURN END SUBROUTINE symba_step_recur !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_step_recur.f90.html"},{"title":"symba_user_getacch.f90 – swiftest","text":"Unit Name   : symba_user_getacch\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Add user-supplied heliocentric accelerations to planets Input\n    Arguments : t          : time\n                npl        : number of planets\n                symba_pl1P : pointer to head of SyMBA planet structure linked-list\n    Terminal  : TBS as needed by user\n    File      : TBS as needed by user Output\n    Arguments : symba_pl1P : pointer to head of SyMBA planet structure linked-list\n    Terminal  : TBS as needed by user\n    File      : TBS as needed by user Invocation  : CALL symba_user_getacch(t, npl, symba_pl1P) Notes       : Carlisle was here Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_user_getacch.f90~~EfferentGraph sourcefile~symba_user_getacch.f90 symba_user_getacch.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_user_getacch.f90->sourcefile~module_interfaces.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_user_getacch.f90->sourcefile~module_symba.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_user_getacch.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_user_getacch Source Code symba_user_getacch.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_user_getacch !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Add user-supplied heliocentric accelerations to planets ! !  Input !    Arguments : t          : time !                npl        : number of planets !                symba_pl1P : pointer to head of SyMBA planet structure linked-list !    Terminal  : TBS as needed by user !    File      : TBS as needed by user ! !  Output !    Arguments : symba_pl1P : pointer to head of SyMBA planet structure linked-list !    Terminal  : TBS as needed by user !    File      : TBS as needed by user ! !  Invocation  : CALL symba_user_getacch(t, npl, symba_pl1P) ! !  Notes       : Carlisle was here ! !********************************************************************************************************************************** SUBROUTINE symba_user_getacch ( t , npl , symba_plA ) ! Modules USE swiftest USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_user_getacch IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: t TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA ! Internals ! Executable code RETURN END SUBROUTINE symba_user_getacch !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_user_getacch.f90.html"},{"title":"symba_casehitandrun.f90 – swiftest","text":"Unit Name   : symba_casehitandrun\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Merge planets Input\n    Arguments : t            : time\n                npl          : number of planets\n                nsppl        : number of spilled planets\n                symba_pl1P   : pointer to head of SyMBA planet structure linked-list\n                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list\n                nplplenc     : number of planet-planet encounters\n                plplenc_list : array of planet-planet encounter structures\n    Terminal  : none\n    File      : none Output\n    Arguments : npl          : number of planets\n                nsppl        : number of spilled planets\n                symba_pl1P   : pointer to head of SyMBA planet structure linked-list\n                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL symba_casehitandrun(t, npl, nsppl, symba_pl1P, symba_pld1P, nplplenc, plplenc_list) Notes       : Adapted from Hal Levison's Swift routine discard_mass_merge.f This file depends on sourcefile~~symba_casehitandrun.f90~~EfferentGraph sourcefile~symba_casehitandrun.f90 symba_casehitandrun.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_casehitandrun.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_casehitandrun.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_casehitandrun.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_casehitandrun.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_casehitandrun.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_casehitandrun Source Code symba_casehitandrun.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_casehitandrun !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Merge planets ! !  Input !    Arguments : t            : time !                npl          : number of planets !                nsppl        : number of spilled planets !                symba_pl1P   : pointer to head of SyMBA planet structure linked-list !                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list !                nplplenc     : number of planet-planet encounters !                plplenc_list : array of planet-planet encounter structures !    Terminal  : none !    File      : none ! !  Output !    Arguments : npl          : number of planets !                nsppl        : number of spilled planets !                symba_pl1P   : pointer to head of SyMBA planet structure linked-list !                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_casehitandrun(t, npl, nsppl, symba_pl1P, symba_pld1P, nplplenc, plplenc_list) ! !  Notes       : Adapted from Hal Levison's Swift routine discard_mass_merge.f ! !********************************************************************************************************************************** SUBROUTINE symba_casehitandrun ( t , index_enc , nmergeadd , nmergesub , mergeadd_list , mergesub_list , eoffset , vbs , & symba_plA , nplplenc , plplenc_list , & nplmax , ntpmax , fragmax , mres , rres , m1 , m2 , rad1 , rad2 , x1 , x2 , v1 , v2 ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_casehitandrun IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: index_enc , nplmax , ntpmax INTEGER ( I4B ), INTENT ( INOUT ) :: nmergeadd , nmergesub , nplplenc , fragmax REAL ( DP ), INTENT ( IN ) :: t REAL ( DP ), INTENT ( INOUT ) :: eoffset , m1 , m2 , rad1 , rad2 REAL ( DP ), DIMENSION ( 3 ), INTENT ( INOUT ) :: mres , rres REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: vbs REAL ( DP ), DIMENSION ( NDIM ), INTENT ( INOUT ) :: x1 , x2 , v1 , v2 TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA ! Internals INTEGER ( I4B ) :: nfrag , i , k , index1 , index2 INTEGER ( I4B ) :: index1_parent , index2_parent INTEGER ( I4B ) :: name1 , name2 , index_keep , index_rm REAL ( DP ) :: mtot , d_rm , m_rm , r_rm , vx_rm , vy_rm REAL ( DP ) :: rhill_keep , r_circle , theta , radius1 , radius2 REAL ( DP ) :: m_rem , m_test , mass1 , mass2 , enew , eold REAL ( DP ) :: x_com , y_com , z_com , vx_com , vy_com , vz_com REAL ( DP ) :: x_frag , y_frag , z_frag , vx_frag , vy_frag , vz_frag REAL ( DP ), DIMENSION ( NDIM ) :: vnew , xr , mv ! Executable code nfrag = 4 index1 = plplenc_list % index1 ( index_enc ) index2 = plplenc_list % index2 ( index_enc ) index1_parent = symba_plA % index_parent ( index1 ) index2_parent = symba_plA % index_parent ( index2 ) name1 = symba_plA % helio % swiftest % name ( index1 ) name2 = symba_plA % helio % swiftest % name ( index2 ) mass1 = symba_plA % helio % swiftest % mass ( index1 ) mass2 = symba_plA % helio % swiftest % mass ( index2 ) radius1 = symba_plA % helio % swiftest % radius ( index1 ) radius2 = symba_plA % helio % swiftest % radius ( index2 ) IF ( m2 > m1 ) THEN index_keep = index2 index_rm = index1 ELSE index_keep = index1 index_rm = index2 END IF ! Find COM x_com = (( x1 ( 1 ) * m1 ) + ( x2 ( 1 ) * m2 )) / ( m1 + m2 ) y_com = (( x1 ( 2 ) * m1 ) + ( x2 ( 2 ) * m2 )) / ( m1 + m2 ) z_com = (( x1 ( 3 ) * m1 ) + ( x2 ( 3 ) * m2 )) / ( m1 + m2 ) vx_com = (( v1 ( 1 ) * m1 ) + ( v2 ( 1 ) * m2 )) / ( m1 + m2 ) vy_com = (( v1 ( 2 ) * m1 ) + ( v2 ( 2 ) * m2 )) / ( m1 + m2 ) vz_com = (( v1 ( 3 ) * m1 ) + ( v2 ( 3 ) * m2 )) / ( m1 + m2 ) ! Find energy pre-frag eold = 0.5_DP * ( m1 * DOT_PRODUCT ( v1 (:), v1 (:)) + m2 * DOT_PRODUCT ( v2 (:), v2 (:))) xr (:) = x2 (:) - x1 (:) eold = eold - ( m1 * m2 / ( SQRT ( DOT_PRODUCT ( xr (:), xr (:))))) WRITE ( * , * ) \"Hit and run between particles \" , name1 , \" and \" , name2 , \" at time t = \" , t WRITE ( * , * ) \"Particle \" , index_keep , \" survives; Particle \" , index_rm , \" is fragmented.\" WRITE ( * , * ) \"Number of fragments added: \" , ( nfrag - 1 ) ! Add both parents to mergesub_list nmergesub = nmergesub + 1 mergesub_list % name ( nmergesub ) = name1 mergesub_list % status ( nmergesub ) = HIT_AND_RUN ! possibly change to disruption for new flag in discard.out mergesub_list % xh (:, nmergesub ) = x1 (:) mergesub_list % vh (:, nmergesub ) = v1 (:) - vbs (:) mergesub_list % mass ( nmergesub ) = mass1 mergesub_list % radius ( nmergesub ) = rad1 nmergesub = nmergesub + 1 mergesub_list % name ( nmergesub ) = name2 mergesub_list % status ( nmergesub ) = HIT_AND_RUN mergesub_list % xh (:, nmergesub ) = x2 (:) mergesub_list % vh (:, nmergesub ) = v2 (:) - vbs (:) mergesub_list % mass ( nmergesub ) = mass2 mergesub_list % radius ( nmergesub ) = rad2 ! go through the encounter list and for particles actively encoutering ! prevent them from having further encounters in this timestep by setting status to MERGED DO k = 1 , nplplenc IF (( plplenc_list % status ( k ) == ACTIVE ) . AND . & (( index1 == plplenc_list % index1 ( k ) . OR . index2 == plplenc_list % index2 ( k )) . OR . & ( index2 == plplenc_list % index1 ( k ) . OR . index1 == plplenc_list % index2 ( k )))) THEN plplenc_list % status ( k ) = MERGED END IF END DO symba_plA % helio % swiftest % status ( index1 ) = HIT_AND_RUN symba_plA % helio % swiftest % status ( index2 ) = HIT_AND_RUN ! Calculate the positions of the new fragments rhill_keep = symba_plA % helio % swiftest % rhill ( index_keep ) r_circle = rhill_keep theta = ( 2.0_DP * PI ) / ( nfrag - 1 ) ! Add new fragments to mergeadd_list mtot = 0.0_DP ! running total mass of new fragments mv = 0.0_DP ! running sum of m*v of new fragments to be used in COM calculation DO i = 1 , nfrag nmergeadd = nmergeadd + 1 mergeadd_list % status ( nmergeadd ) = HIT_AND_RUN mergeadd_list % ncomp ( nmergeadd ) = 2 m_rm = symba_plA % helio % swiftest % mass ( index_rm ) r_rm = symba_plA % helio % swiftest % radius ( index_rm ) vx_rm = symba_plA % helio % swiftest % vh ( 1 , index_rm ) vy_rm = symba_plA % helio % swiftest % vh ( 2 , index_rm ) d_rm = ( 3.0_DP * m_rm ) / ( 4.0_DP * PI * ( r_rm ** 3.0_DP )) IF ( i == 1 ) THEN ! first largest particle equal to index_keep mergeadd_list % name ( nmergeadd ) = symba_plA % helio % swiftest % name ( index_keep ) mergeadd_list % mass ( nmergeadd ) = symba_plA % helio % swiftest % mass ( index_keep ) mergeadd_list % radius ( nmergeadd ) = symba_plA % helio % swiftest % radius ( index_keep ) mergeadd_list % xh (:, nmergeadd ) = symba_plA % helio % swiftest % xh (:, index_keep ) mergeadd_list % vh (:, nmergeadd ) = symba_plA % helio % swiftest % vh (:, index_keep ) mtot = mtot + mergeadd_list % mass ( nmergeadd ) END IF IF ( i == 2 ) THEN ! second largest particle from collresolve mres[1] rres[1] mergeadd_list % name ( nmergeadd ) = nplmax + ntpmax + fragmax + i - 1 mergeadd_list % mass ( nmergeadd ) = mres ( 2 ) mergeadd_list % radius ( nmergeadd ) = rres ( 2 ) mtot = mtot + mergeadd_list % mass ( nmergeadd ) END IF IF ( i > 2 ) THEN ! FIXME all other particles implement eq. 31 LS12 ! FIXME current equation taken from Durda et al 2007 Figure 2 Supercatastrophic: N = (1.5e5)e(-1.3*D) mergeadd_list % name ( nmergeadd ) = nplmax + ntpmax + fragmax + i - 1 m_rem = m_rm - mres ( 2 ) m_test = ((( - 1.0_DP / 2.6_DP ) * log ( i / ( 1.5_DP * 1 0.0_DP ** 5 ))) ** 3.0_DP ) * (( 4.0_DP / 3.0_DP ) * PI * d_rm ) IF ( m_test < m_rem ) THEN mergeadd_list % mass ( nmergeadd ) = m_test ELSE mergeadd_list % mass ( nmergeadd ) = ( m1 + m2 ) - mtot END IF mergeadd_list % radius ( nmergeadd ) = (( 3.0_DP * mergeadd_list % mass ( nmergeadd )) / ( 4.0_DP * PI * d_rm )) & ** ( 1.0_DP / 3.0_DP ) mtot = mtot + mergeadd_list % mass ( nmergeadd ) END IF IF ( i > 1 ) THEN x_frag = ( r_circle * cos ( theta * i )) + x_com y_frag = ( r_circle * sin ( theta * i )) + y_com z_frag = z_com vx_frag = (( 1.0_DP / ( nfrag - 1 )) * ( 1.0_DP / mergeadd_list % mass ( nmergeadd )) * (( m_rm * vx_rm ))) - vbs ( 1 ) vy_frag = (( 1.0_DP / ( nfrag - 1 )) * ( 1.0_DP / mergeadd_list % mass ( nmergeadd )) * (( m_rm * vy_rm ))) - vbs ( 2 ) vz_frag = vz_com - vbs ( 3 ) mergeadd_list % xh ( 1 , nmergeadd ) = x_frag mergeadd_list % xh ( 2 , nmergeadd ) = y_frag mergeadd_list % xh ( 3 , nmergeadd ) = z_frag mergeadd_list % vh ( 1 , nmergeadd ) = vx_frag mergeadd_list % vh ( 2 , nmergeadd ) = vy_frag mergeadd_list % vh ( 3 , nmergeadd ) = vz_frag END IF mv = mv + ( mergeadd_list % mass ( nmergeadd ) * mergeadd_list % vh (:, nmergeadd )) END DO ! Calculate energy after frag vnew (:) = mv / mtot ! COM of new fragments enew = 0.5_DP * mtot * DOT_PRODUCT ( vnew (:), vnew (:)) eoffset = eoffset + eold - enew ! Update fragmax to account for new fragments fragmax = fragmax + ( nfrag - 1 ) RETURN END SUBROUTINE symba_casehitandrun","tags":"","loc":"sourcefile/symba_casehitandrun.f90.html"},{"title":"symba_step_helio.f90 – swiftest","text":"Unit Name   : symba_step_helio\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Step planets and test particles ahead in democratic heliocentric coordinates Input\n    Arguments : lfirst       : logical flag indicating whether current invocation is the first\n                lextra_force : logical flag indicating whether to include user-supplied accelerations\n                t            : time\n                npl          : number of planets\n                nplm         : number of planets with mass > mtiny\n                nplmax       : maximum allowed number of planets\n                ntp          : number of active test particles\n                ntpmax       : maximum allowed number of test particles\n                helio_pl1P   : pointer to head of helio planet structure linked-list\n                helio_tp1P   : pointer to head of helio test particle structure linked-list\n                j2rp2        : J2 * R 2 for the Sun\n                j4rp4        : J4 * R 4 for the Sun\n                dt           : time step\n    Terminal  : none\n    File      : none Output\n    Arguments : lfirst       : logical flag indicating whether current invocation is the first\n                helio_pl1P   : pointer to head of helio planet structure linked-list\n                helio_tp1P   : pointer to head of helio test particle structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL symba_step_helio(lfirst, lextra_force, t, npl, nplm, nplmax, ntp, ntpmax, helio_pl1P, helio_tp1P, j2rp2,\n                                      j4rp4, dt) Notes       : Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_step_helio.f90~~EfferentGraph sourcefile~symba_step_helio.f90 symba_step_helio.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_step_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_step_helio.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_step_helio.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_step_helio.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_step_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_step_helio Source Code symba_step_helio.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_step_helio !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Step planets and test particles ahead in democratic heliocentric coordinates ! !  Input !    Arguments : lfirst       : logical flag indicating whether current invocation is the first !                lextra_force : logical flag indicating whether to include user-supplied accelerations !                t            : time !                npl          : number of planets !                nplm         : number of planets with mass > mtiny !                nplmax       : maximum allowed number of planets !                ntp          : number of active test particles !                ntpmax       : maximum allowed number of test particles !                helio_pl1P   : pointer to head of helio planet structure linked-list !                helio_tp1P   : pointer to head of helio test particle structure linked-list !                j2rp2        : J2 * R**2 for the Sun !                j4rp4        : J4 * R**4 for the Sun !                dt           : time step !    Terminal  : none !    File      : none ! !  Output !    Arguments : lfirst       : logical flag indicating whether current invocation is the first !                helio_pl1P   : pointer to head of helio planet structure linked-list !                helio_tp1P   : pointer to head of helio test particle structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_step_helio(lfirst, lextra_force, t, npl, nplm, nplmax, ntp, ntpmax, helio_pl1P, helio_tp1P, j2rp2, !                                      j4rp4, dt) ! !  Notes       : ! !********************************************************************************************************************************** SUBROUTINE symba_step_helio ( lfirst , lextra_force , t , npl , nplm , nplmax , ntp , ntpmax , helio_plA , helio_tpA , j2rp2 , j4rp4 , dt ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_step_helio IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( IN ) :: lextra_force LOGICAL ( LGT ), INTENT ( INOUT ) :: lfirst INTEGER ( I4B ), INTENT ( IN ) :: npl , nplm , nplmax , ntp , ntpmax REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 , dt TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA TYPE ( helio_tp ), INTENT ( INOUT ) :: helio_tpA ! Internals LOGICAL ( LGT ) :: lfirsttp LOGICAL ( LGT ), SAVE :: lmalloc = . TRUE . REAL ( DP ), DIMENSION ( NDIM ) :: ptb , pte REAL ( DP ), DIMENSION (:, :), ALLOCATABLE , SAVE :: xbeg , xend ! Executable code IF ( lmalloc ) THEN ALLOCATE ( xbeg ( NDIM , nplmax ), xend ( NDIM , nplmax )) lmalloc = . FALSE . END IF lfirsttp = lfirst CALL symba_step_helio_pl ( lfirst , lextra_force , t , npl , nplm , nplmax , helio_plA , j2rp2 , j4rp4 , dt , xbeg , xend , ptb , pte ) IF ( ntp > 0 ) CALL helio_step_tp ( lfirsttp , lextra_force , t , nplm , nplmax , ntp , ntpmax , helio_plA , helio_tpA , j2rp2 , j4rp4 , & dt , xbeg , xend , ptb , pte ) RETURN END SUBROUTINE symba_step_helio !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_step_helio.f90.html"},{"title":"symba_discard_sun_pl.f90 – swiftest","text":"Unit Name   : symba_discard_sun_pl\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Check to see if planets should be discarded based on their positions relative to the Sun Input\n    Arguments : t            : time\n                npl          : number of planets\n                msys         : total system mass\n                swifter_pl1P : pointer to head of Swifter planet structure linked-list\n                rmin         : minimum allowed heliocentric radius\n                rmax         : maximum allowed heliocentric radius\n                rmaxu        : maximum allowed heliocentric radius for unbound planets\n                ldiscards    : logical flag indicating whether any planets are discarded\n    Terminal  : none\n    File      : none Output\n    Arguments : swifter_pl1P : pointer to head of Swifter planet structure linked-list\n                ldiscards    : logical flag indicating whether any planets are discarded\n    Terminal  : status message\n    File      : none Invocation  : CALL symba_discard_sun_pl(t, npl, msys, swifter_pl1P, rmin, rmax, rmaxu, ldiscards) Notes       : Adapted from Hal Levison's Swift routine discard_massive5.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_discard_sun_pl.f90~~EfferentGraph sourcefile~symba_discard_sun_pl.f90 symba_discard_sun_pl.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_discard_sun_pl.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_discard_sun_pl.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_discard_sun_pl.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_discard_sun_pl Source Code symba_discard_sun_pl.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_discard_sun_pl !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Check to see if planets should be discarded based on their positions relative to the Sun ! !  Input !    Arguments : t            : time !                npl          : number of planets !                msys         : total system mass !                swifter_pl1P : pointer to head of Swifter planet structure linked-list !                rmin         : minimum allowed heliocentric radius !                rmax         : maximum allowed heliocentric radius !                rmaxu        : maximum allowed heliocentric radius for unbound planets !                ldiscards    : logical flag indicating whether any planets are discarded !    Terminal  : none !    File      : none ! !  Output !    Arguments : swifter_pl1P : pointer to head of Swifter planet structure linked-list !                ldiscards    : logical flag indicating whether any planets are discarded !    Terminal  : status message !    File      : none ! !  Invocation  : CALL symba_discard_sun_pl(t, npl, msys, swifter_pl1P, rmin, rmax, rmaxu, ldiscards) ! !  Notes       : Adapted from Hal Levison's Swift routine discard_massive5.f ! !********************************************************************************************************************************** SUBROUTINE symba_discard_sun_pl ( t , npl , msys , swiftest_plA , rmin , rmax , rmaxu , ldiscards ) ! Modules USE swiftest USE module_swiftest USE module_interfaces , EXCEPT_THIS_ONE => symba_discard_sun_pl IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( INOUT ) :: ldiscards INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: t , msys , rmin , rmax , rmaxu TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA ! Internals INTEGER ( I4B ) :: i REAL ( DP ) :: energy , vb2 , rb2 , rh2 , rmin2 , rmax2 , rmaxu2 ! Executable code rmin2 = rmin * rmin rmax2 = rmax * rmax rmaxu2 = rmaxu * rmaxu DO i = 2 , npl IF ( swiftest_plA % status ( i ) == ACTIVE ) THEN rh2 = DOT_PRODUCT ( swiftest_plA % xh (:, i ), swiftest_plA % xh (:, i )) IF (( rmax >= 0.0_DP ) . AND . ( rh2 > rmax2 )) THEN ldiscards = . TRUE . swiftest_plA % status ( i ) = DISCARDED_RMAX WRITE ( * , * ) \"Particle \" , swiftest_plA % name ( i ), \" too far from Sun at t = \" , t ELSE IF (( rmin >= 0.0_DP ) . AND . ( rh2 < rmin2 )) THEN ldiscards = . TRUE . swiftest_plA % status ( i ) = DISCARDED_RMIN WRITE ( * , * ) \"Particle \" , swiftest_plA % name ( i ), \" too close to Sun at t = \" , t ELSE IF ( rmaxu >= 0.0_DP ) THEN rb2 = DOT_PRODUCT ( swiftest_plA % xb (:, i ), swiftest_plA % xb (:, i )) vb2 = DOT_PRODUCT ( swiftest_plA % vb (:, i ), swiftest_plA % vb (:, i )) energy = 0.5_DP * vb2 - msys / SQRT ( rb2 ) IF (( energy > 0.0_DP ) . AND . ( rb2 > rmaxu2 )) THEN ldiscards = . TRUE . swiftest_plA % status ( i ) = DISCARDED_RMAXU WRITE ( * , * ) \"Particle \" , swiftest_plA % name ( i ), \" is unbound and too far from barycenter at t = \" , t END IF END IF END IF END DO RETURN END SUBROUTINE symba_discard_sun_pl !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_discard_sun_pl.f90.html"},{"title":"symba_reorder_pl.f90 – swiftest","text":"Unit Name   : symba_reorder_pl\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Rearrange SyMBA planet arrays in order of decreasing mass Input\n    Arguments : npl        : number of planets\n                symba_plA  : structure of arrays of SyMBA planet \n    Terminal  : none\n    File      : none Output\n    Arguments : symba_plA : structure of arrays of SyMBA planet \n    Terminal  : none\n    File      : none Invocation  : CALL symba_reorder_pl(npl, symba_plA) Notes       : Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_reorder_pl.f90~~EfferentGraph sourcefile~symba_reorder_pl.f90 symba_reorder_pl.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_reorder_pl.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_reorder_pl.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_reorder_pl.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_reorder_pl.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_reorder_pl.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_reorder_pl Source Code symba_reorder_pl.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_reorder_pl !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Rearrange SyMBA planet arrays in order of decreasing mass ! !  Input !    Arguments : npl        : number of planets !                symba_plA  : structure of arrays of SyMBA planet !    Terminal  : none !    File      : none ! !  Output !    Arguments : symba_plA : structure of arrays of SyMBA planet !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_reorder_pl(npl, symba_plA) ! !  Notes       : ! !********************************************************************************************************************************** SUBROUTINE symba_reorder_pl ( npl , symba_plA ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_reorder_pl IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA ! Internals INTEGER ( I4B ) :: i INTEGER ( I4B ), DIMENSION (:), ALLOCATABLE :: index REAL ( DP ), DIMENSION (:), ALLOCATABLE :: mass REAL ( DP ), DIMENSION (:,:), allocatable :: symba_plwkspA INTEGER ( I4B ), DIMENSION (:,:), allocatable :: symba_plwkspA_id_status ! Executable code ALLOCATE ( index ( npl ), mass ( npl )) ALLOCATE ( symba_plwkspA ( 12 , npl )) ALLOCATE ( symba_plwkspA_id_status ( 2 , npl )) DO i = 1 , npl mass ( i ) = symba_plA % helio % swiftest % mass ( i ) symba_plwkspA_id_status ( 1 , i ) = symba_plA % helio % swiftest % name ( i ) symba_plwkspA_id_status ( 2 , i ) = symba_plA % helio % swiftest % status ( i ) symba_plwkspA ( 1 , i ) = symba_plA % helio % swiftest % mass ( i ) symba_plwkspA ( 2 , i ) = symba_plA % helio % swiftest % radius ( i ) symba_plwkspA ( 3 , i ) = symba_plA % helio % swiftest % xh ( 1 , i ) symba_plwkspA ( 4 , i ) = symba_plA % helio % swiftest % xh ( 2 , i ) symba_plwkspA ( 5 , i ) = symba_plA % helio % swiftest % xh ( 3 , i ) symba_plwkspA ( 6 , i ) = symba_plA % helio % swiftest % vh ( 1 , i ) symba_plwkspA ( 7 , i ) = symba_plA % helio % swiftest % vh ( 2 , i ) symba_plwkspA ( 8 , i ) = symba_plA % helio % swiftest % vh ( 3 , i ) symba_plwkspA ( 9 , i ) = symba_plA % helio % swiftest % rhill ( i ) symba_plwkspA ( 10 , i ) = symba_plA % helio % ah ( 1 , i ) symba_plwkspA ( 11 , i ) = symba_plA % helio % ah ( 2 , i ) symba_plwkspA ( 12 , i ) = symba_plA % helio % ah ( 3 , i ) END DO CALL util_index ( mass , index ) WRITE ( * , * ) \"************ REORDER ***************\" DO i = 1 , npl symba_plA % helio % swiftest % name ( i ) = symba_plwkspA_id_status ( 1 , index ( npl - i + 1 )) symba_plA % helio % swiftest % status ( i ) = symba_plwkspA_id_status ( 2 , index ( npl - i + 1 )) symba_plA % helio % swiftest % mass ( i ) = symba_plwkspA ( 1 , index ( npl - i + 1 )) symba_plA % helio % swiftest % radius ( i ) = symba_plwkspA ( 2 , index ( npl - i + 1 )) symba_plA % helio % swiftest % xh ( 1 , i ) = symba_plwkspA ( 3 , index ( npl - i + 1 )) symba_plA % helio % swiftest % xh ( 2 , i ) = symba_plwkspA ( 4 , index ( npl - i + 1 )) symba_plA % helio % swiftest % xh ( 3 , i ) = symba_plwkspA ( 5 , index ( npl - i + 1 )) symba_plA % helio % swiftest % vh ( 1 , i ) = symba_plwkspA ( 6 , index ( npl - i + 1 )) symba_plA % helio % swiftest % vh ( 2 , i ) = symba_plwkspA ( 7 , index ( npl - i + 1 )) symba_plA % helio % swiftest % vh ( 3 , i ) = symba_plwkspA ( 8 , index ( npl - i + 1 )) symba_plA % helio % swiftest % rhill ( i ) = symba_plwkspA ( 9 , index ( npl - i + 1 )) symba_plA % helio % ah ( 1 , i ) = symba_plwkspA ( 10 , index ( npl - i + 1 )) symba_plA % helio % ah ( 2 , i ) = symba_plwkspA ( 11 , index ( npl - i + 1 )) symba_plA % helio % ah ( 3 , i ) = symba_plwkspA ( 12 , index ( npl - i + 1 )) END DO IF ( ALLOCATED ( symba_plwkspA )) DEALLOCATE ( symba_plwkspA ) IF ( ALLOCATED ( symba_plwkspA_id_status )) DEALLOCATE ( symba_plwkspA_id_status ) IF ( ALLOCATED ( mass )) DEALLOCATE ( mass ) IF ( ALLOCATED ( index )) DEALLOCATE ( index ) RETURN END SUBROUTINE symba_reorder_pl !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_reorder_pl.f90.html"},{"title":"symba_helio_drift.f90 – swiftest","text":"Unit Name   : symba_helio_drift\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Loop through planets and call Danby drift routine Input\n    Arguments : irec       : input recursion level\n                npl        : number of planets\n                symba_pl1P : pointer to head of SyMBA planet structure linked-list\n                dt         : time step\n    Terminal  : none\n    File      : none Output\n    Arguments : symba_pl1P : pointer to head of SyMBA planet structure linked-list\n    Terminal  : error message\n    File      : none Invocation  : CALL symba_helio_drift(irec, npl, symba_pl1P, dt) Notes       : Adapted from Hal Levison's Swift routine symba5_helio_drift.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_helio_drift.f90~~EfferentGraph sourcefile~symba_helio_drift.f90 symba_helio_drift.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_helio_drift.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_helio_drift.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_helio_drift.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_helio_drift.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_helio_drift.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_helio_drift Source Code symba_helio_drift.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_helio_drift !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Loop through planets and call Danby drift routine ! !  Input !    Arguments : irec       : input recursion level !                npl        : number of planets !                symba_pl1P : pointer to head of SyMBA planet structure linked-list !                dt         : time step !    Terminal  : none !    File      : none ! !  Output !    Arguments : symba_pl1P : pointer to head of SyMBA planet structure linked-list !    Terminal  : error message !    File      : none ! !  Invocation  : CALL symba_helio_drift(irec, npl, symba_pl1P, dt) ! !  Notes       : Adapted from Hal Levison's Swift routine symba5_helio_drift.f ! !********************************************************************************************************************************** SUBROUTINE symba_helio_drift ( irec , npl , symba_plA , dt ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_helio_drift IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: irec , npl REAL ( DP ), INTENT ( IN ) :: dt TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA ! Internals INTEGER ( I4B ) :: i , iflag REAL ( DP ) :: mu ! Executable code mu = symba_plA % helio % swiftest % mass ( 1 ) DO i = 2 , npl IF (( symba_plA % levelg ( i ) == irec ) . AND . ( symba_plA % helio % swiftest % status ( i ) == ACTIVE )) THEN CALL drift_one ( mu , symba_plA % helio % swiftest % xh (:, i ), symba_plA % helio % swiftest % vb (:, i ), dt , iflag ) IF ( iflag /= 0 ) THEN WRITE ( * , * ) \" Planet \" , symba_plA % helio % swiftest % name ( i ), \" is lost!!!!!!!!!!\" WRITE ( * , * ) mu , dt WRITE ( * , * ) symba_plA % helio % swiftest % xh (:, i ) WRITE ( * , * ) symba_plA % helio % swiftest % vb (:, i ) WRITE ( * , * ) \" STOPPING \" CALL util_exit ( FAILURE ) END IF END IF END DO RETURN END SUBROUTINE symba_helio_drift !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_helio_drift.f90.html"},{"title":"symba_kick.f90 – swiftest","text":"Unit Name   : symba_kick\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Kick barycentric velocities of planets and active test particles within SyMBA recursion Input\n    Arguments : irec         : input recursion level\n                nplplenc     : number of planet-planet encounters\n                npltpenc     : number of planet-test particle encounters\n                plplenc_list : array of planet-planet encounter structures\n                pltpenc_list : array of planet-test particle encounter structures\n                dt           : time step\n                sgn          : sign to be applied to acceleration\n    Terminal  : none\n    File      : none Output\n    Arguments : plplenc_list : array of planet-planet encounter structures\n                pltpenc_list : array of planet-test particle encounter structures\n    Terminal  : none\n    File      : none Invocation  : CALL symba_kick(irec, nplplenc, npltpenc, plplenc_list, pltpenc_list, dt, sgn) Notes       : Adapted from Hal Levison's Swift routine symba5_kick.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_kick.f90~~EfferentGraph sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_kick.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_kick.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_kick.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_kick.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_kick Source Code symba_kick.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_kick !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Kick barycentric velocities of planets and active test particles within SyMBA recursion ! !  Input !    Arguments : irec         : input recursion level !                nplplenc     : number of planet-planet encounters !                npltpenc     : number of planet-test particle encounters !                plplenc_list : array of planet-planet encounter structures !                pltpenc_list : array of planet-test particle encounter structures !                dt           : time step !                sgn          : sign to be applied to acceleration !    Terminal  : none !    File      : none ! !  Output !    Arguments : plplenc_list : array of planet-planet encounter structures !                pltpenc_list : array of planet-test particle encounter structures !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_kick(irec, nplplenc, npltpenc, plplenc_list, pltpenc_list, dt, sgn) ! !  Notes       : Adapted from Hal Levison's Swift routine symba5_kick.f ! !********************************************************************************************************************************** SUBROUTINE symba_kick ( irec , nplplenc , npltpenc , plplenc_list , pltpenc_list , dt , sgn , symba_plA , symba_tpA ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_kick IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: irec , nplplenc , npltpenc REAL ( DP ), INTENT ( IN ) :: dt , sgn TYPE ( symba_plplenc ), INTENT ( IN ) :: plplenc_list TYPE ( symba_pltpenc ), INTENT ( IN ) :: pltpenc_list TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA ! Internals INTEGER ( I4B ) :: i , irm1 , irecl , index_i , index_j , index_tp , index_pl REAL ( DP ) :: r , rr , ri , ris , rim1 , r2 , ir3 , fac , faci , facj REAL ( DP ), DIMENSION ( NDIM ) :: dx ! Executable code irm1 = irec - 1 IF ( sgn < 0.0_DP ) THEN irecl = irec - 1 ELSE irecl = irec END IF DO i = 1 , nplplenc index_i = plplenc_list % index1 ( i ) index_j = plplenc_list % index2 ( i ) symba_plA % helio % ah (:, index_i ) = ( / 0.0_DP , 0.0_DP , 0.0_DP / ) symba_plA % helio % ah (:, index_j ) = ( / 0.0_DP , 0.0_DP , 0.0_DP / ) END DO DO i = 1 , npltpenc index_tp = pltpenc_list % indextp ( i ) symba_tpA % helio % ah (:, index_tp ) = ( / 0.0_DP , 0.0_DP , 0.0_DP / ) END DO DO i = 1 , nplplenc IF ( plplenc_list % status ( i ) == ACTIVE ) THEN index_i = plplenc_list % index1 ( i ) index_j = plplenc_list % index2 ( i ) IF (( symba_plA % levelg ( index_i ) >= irm1 ) . AND . ( symba_plA % levelg ( index_j ) >= irm1 )) THEN ri = (( symba_plA % helio % swiftest % rhill ( index_i ) & + symba_plA % helio % swiftest % rhill ( index_j )) ** 2 ) * ( RHSCALE ** 2 ) * ( RSHELL ** ( 2 * irecl )) rim1 = ri * ( RSHELL ** 2 ) dx (:) = symba_plA % helio % swiftest % xh (:, index_j ) - symba_plA % helio % swiftest % xh (:, index_i ) r2 = DOT_PRODUCT ( dx (:), dx (:)) IF ( r2 < rim1 ) THEN fac = 0.0_DP ELSE IF ( r2 < ri ) THEN ris = SQRT ( ri ) r = SQRT ( r2 ) rr = ( ris - r ) / ( ris * ( 1.0_DP - RSHELL )) fac = ( r2 ** ( - 1.5_DP )) * ( 1.0_DP - 3.0_DP * ( rr ** 2 ) + 2.0_DP * ( rr ** 3 )) ELSE ir3 = 1.0_DP / ( r2 * SQRT ( r2 )) fac = ir3 END IF faci = fac * symba_plA % helio % swiftest % mass ( index_i ) facj = fac * symba_plA % helio % swiftest % mass ( index_j ) symba_plA % helio % ah (:, index_i ) = symba_plA % helio % ah (:, index_i ) + facj * dx (:) symba_plA % helio % ah (:, index_j ) = symba_plA % helio % ah (:, index_j ) - faci * dx (:) END IF END IF END DO DO i = 1 , npltpenc IF ( pltpenc_list % status ( i ) == ACTIVE ) THEN index_pl = pltpenc_list % indexpl ( i ) index_tp = pltpenc_list % indextp ( i ) IF (( symba_plA % levelg ( index_pl ) >= irm1 ) . AND . ( symba_tpA % levelg ( index_tp ) >= irm1 )) THEN ri = (( symba_plA % helio % swiftest % rhill ( index_pl )) ** 2 ) * ( RHSCALE ** 2 ) * ( RSHELL ** ( 2 * irecl )) rim1 = ri * ( RSHELL ** 2 ) dx (:) = symba_tpA % helio % swiftest % xh (:, index_tp ) - symba_plA % helio % swiftest % xh (:, index_pl ) r2 = DOT_PRODUCT ( dx (:), dx (:)) IF ( r2 < rim1 ) THEN fac = 0.0_DP ELSE IF ( r2 < ri ) THEN ris = SQRT ( ri ) r = SQRT ( r2 ) rr = ( ris - r ) / ( ris * ( 1.0_DP - RSHELL )) fac = ( r2 ** ( - 1.5_DP )) * ( 1.0_DP - 3.0_DP * ( rr ** 2 ) + 2.0_DP * ( rr ** 3 )) ELSE ir3 = 1.0_DP / ( r2 * SQRT ( r2 )) fac = ir3 END IF faci = fac * symba_plA % helio % swiftest % mass ( index_pl ) symba_tpA % helio % ah (:, index_tp ) = symba_tpA % helio % ah (:, index_tp ) - faci * dx (:) END IF END IF END DO DO i = 1 , nplplenc index_i = plplenc_list % index1 ( i ) index_j = plplenc_list % index2 ( i ) symba_plA % helio % swiftest % vb (:, index_i ) = symba_plA % helio % swiftest % vb (:, index_i ) + sgn * dt * symba_plA % helio % ah (:, index_i ) symba_plA % helio % swiftest % vb (:, index_j ) = symba_plA % helio % swiftest % vb (:, index_j ) + sgn * dt * symba_plA % helio % ah (:, index_j ) symba_plA % helio % ah (:, index_i ) = ( / 0.0_DP , 0.0_DP , 0.0_DP / ) symba_plA % helio % ah (:, index_j ) = ( / 0.0_DP , 0.0_DP , 0.0_DP / ) END DO DO i = 1 , npltpenc index_tp = pltpenc_list % indextp ( i ) IF ( symba_tpA % helio % swiftest % status ( index_tp ) == ACTIVE ) & symba_tpA % helio % swiftest % vb (:, index_tp ) = symba_tpA % helio % swiftest % vb (:, index_tp ) + sgn * dt * symba_tpA % helio % ah (:, index_tp ) symba_tpA % helio % ah (:, index_tp ) = ( / 0.0_DP , 0.0_DP , 0.0_DP / ) END DO RETURN END SUBROUTINE symba_kick !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_kick.f90.html"},{"title":"symba_helio_getacch.f90 – swiftest","text":"Unit Name   : symba_helio_getacch\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Compute heliocentric accelerations of planets Input\n    Arguments : lflag        : logical flag indicating whether to recompute direct cross term heliocentric accelerations\n                lextra_force : logical flag indicating whether to include user-supplied accelerations\n                t            : time\n                npl          : number of planets\n                nplm         : number of planets with mass > mtiny\n                nplmax       : maximum allowed number of planets\n                helio_pl1P   : pointer to head of helio planet structure linked-list\n                j2rp2        : J2 * R 2 for the Sun\n                j4rp4        : J4 * R 4 for the Sun\n    Terminal  : none\n    File      : none Output\n    Arguments : helio_pl1P   : pointer to head of helio planet structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL symba_helio_getacch(lflag, lextra_force, t, npl, nplm, nplmax, helio_pl1P, j2rp2, j4rp4) Notes       : Adapted from Hal Levison's Swift routine symba5_helio_getacch.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_helio_getacch.f90~~EfferentGraph sourcefile~symba_helio_getacch.f90 symba_helio_getacch.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_helio_getacch.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_helio_getacch.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_helio_getacch.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_helio_getacch.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_helio_getacch.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_helio_getacch Source Code symba_helio_getacch.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_helio_getacch !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Compute heliocentric accelerations of planets ! !  Input !    Arguments : lflag        : logical flag indicating whether to recompute direct cross term heliocentric accelerations !                lextra_force : logical flag indicating whether to include user-supplied accelerations !                t            : time !                npl          : number of planets !                nplm         : number of planets with mass > mtiny !                nplmax       : maximum allowed number of planets !                helio_pl1P   : pointer to head of helio planet structure linked-list !                j2rp2        : J2 * R**2 for the Sun !                j4rp4        : J4 * R**4 for the Sun !    Terminal  : none !    File      : none ! !  Output !    Arguments : helio_pl1P   : pointer to head of helio planet structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_helio_getacch(lflag, lextra_force, t, npl, nplm, nplmax, helio_pl1P, j2rp2, j4rp4) ! !  Notes       : Adapted from Hal Levison's Swift routine symba5_helio_getacch.f ! !********************************************************************************************************************************** SUBROUTINE symba_helio_getacch ( lflag , lextra_force , t , npl , nplm , nplmax , helio_plA , j2rp2 , j4rp4 ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_helio_getacch IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( IN ) :: lflag , lextra_force INTEGER ( I4B ), INTENT ( IN ) :: npl , nplm , nplmax REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA ! Internals LOGICAL ( LGT ), SAVE :: lmalloc = . TRUE . INTEGER ( I4B ) :: i REAL ( DP ) :: r2 REAL ( DP ), DIMENSION (:), ALLOCATABLE , SAVE :: irh REAL ( DP ), DIMENSION (:, :), ALLOCATABLE , SAVE :: xh , aobl ! Executable code IF ( lflag ) THEN DO i = 2 , npl helio_plA % ahi (:, i ) = ( / 0.0_DP , 0.0_DP , 0.0_DP / ) END DO CALL symba_helio_getacch_int ( npl , nplm , helio_plA ) END IF IF ( j2rp2 /= 0.0_DP ) THEN IF ( lmalloc ) THEN ALLOCATE ( xh ( NDIM , nplmax ), aobl ( NDIM , nplmax ), irh ( nplmax )) lmalloc = . FALSE . END IF DO i = 2 , npl xh (:, i ) = helio_plA % swiftest % xh (:, i ) r2 = DOT_PRODUCT ( xh (:, i ), xh (:, i )) irh ( i ) = 1.0_DP / SQRT ( r2 ) END DO CALL obl_acc ( npl , helio_plA % swiftest , j2rp2 , j4rp4 , xh , irh , aobl ) DO i = 2 , npl helio_plA % ah (:, i ) = helio_plA % ahi (:, i ) + aobl (:, i ) - aobl (:, 1 ) END DO ELSE DO i = 2 , npl helio_plA % ah (:, i ) = helio_plA % ahi (:, i ) END DO END IF IF ( lextra_force ) CALL helio_user_getacch ( t , npl , helio_plA ) RETURN END SUBROUTINE symba_helio_getacch !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_helio_getacch.f90.html"},{"title":"symba_helio_drift_tp.f90 – swiftest","text":"Unit Name   : symba_helio_drift_tp\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Loop through test particles and call Danby drift routine Input\n    Arguments : irec       : input recursion level\n                ntp        : number of active test particles\n                symba_tp1P : pointer to head of active SyMBA test particle structure linked-list\n                mu         : mass of the Sun\n                dt         : time step\n    Terminal  : none\n    File      : none Output\n    Arguments : symba_tp1P : pointer to head of active SyMBA test particle structure linked-list\n    Terminal  : error message\n    File      : none Invocation  : CALL symba_helio_drift_tp(irec, ntp, symba_tp1P, mu, dt) Notes       : Adapted from Hal Levison's Swift routine symba5_helio_drift.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_helio_drift_tp.f90~~EfferentGraph sourcefile~symba_helio_drift_tp.f90 symba_helio_drift_tp.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_helio_drift_tp.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_helio_drift_tp.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_helio_drift_tp.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_helio_drift_tp.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_helio_drift_tp.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_helio_drift_tp Source Code symba_helio_drift_tp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_helio_drift_tp !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Loop through test particles and call Danby drift routine ! !  Input !    Arguments : irec       : input recursion level !                ntp        : number of active test particles !                symba_tp1P : pointer to head of active SyMBA test particle structure linked-list !                mu         : mass of the Sun !                dt         : time step !    Terminal  : none !    File      : none ! !  Output !    Arguments : symba_tp1P : pointer to head of active SyMBA test particle structure linked-list !    Terminal  : error message !    File      : none ! !  Invocation  : CALL symba_helio_drift_tp(irec, ntp, symba_tp1P, mu, dt) ! !  Notes       : Adapted from Hal Levison's Swift routine symba5_helio_drift.f ! !********************************************************************************************************************************** SUBROUTINE symba_helio_drift_tp ( irec , ntp , symba_tpA , mu , dt ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_helio_drift_tp IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: irec , ntp REAL ( DP ), INTENT ( IN ) :: mu , dt TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA ! Internals INTEGER ( I4B ) :: i , iflag ! Executable code DO i = 1 , ntp IF (( symba_tpA % levelg ( i ) == irec ) . AND . ( symba_tpA % helio % swiftest % status ( i ) == ACTIVE )) THEN CALL drift_one ( mu , symba_tpA % helio % swiftest % xh (:, i ), symba_tpA % helio % swiftest % vb (:, i ), dt , iflag ) IF ( iflag /= 0 ) THEN symba_tpA % helio % swiftest % status ( i ) = DISCARDED_DRIFTERR WRITE ( * , * ) \"Particle \" , symba_tpA % helio % swiftest % name ( i ), \" lost due to error in Danby drift\" END IF END IF END DO RETURN END SUBROUTINE symba_helio_drift_tp !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_helio_drift_tp.f90.html"},{"title":"symba_fragmentation.f90 – swiftest","text":"Unit Name   : symba_fragmentation\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Merge planets Input\n    Arguments : t            : time\n                npl          : number of planets\n                nsppl        : number of spilled planets\n                symba_pl1P   : pointer to head of SyMBA planet structure linked-list\n                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list\n                nplplenc     : number of planet-planet encounters\n                plplenc_list : array of planet-planet encounter structures\n    Terminal  : none\n    File      : none Output\n    Arguments : npl          : number of planets\n                nsppl        : number of spilled planets\n                symba_pl1P   : pointer to head of SyMBA planet structure linked-list\n                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL symba_fragmentation(t, npl, nsppl, symba_pl1P, symba_pld1P, nplplenc, plplenc_list) Notes       : Adapted from Hal Levison's Swift routine discard_mass_merge.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_fragmentation.f90~~EfferentGraph sourcefile~symba_fragmentation.f90 symba_fragmentation.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_fragmentation.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_fragmentation.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_fragmentation.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_fragmentation.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_fragmentation.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_fragmentation Source Code symba_fragmentation.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_fragmentation !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Merge planets ! !  Input !    Arguments : t            : time !                npl          : number of planets !                nsppl        : number of spilled planets !                symba_pl1P   : pointer to head of SyMBA planet structure linked-list !                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list !                nplplenc     : number of planet-planet encounters !                plplenc_list : array of planet-planet encounter structures !    Terminal  : none !    File      : none ! !  Output !    Arguments : npl          : number of planets !                nsppl        : number of spilled planets !                symba_pl1P   : pointer to head of SyMBA planet structure linked-list !                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_fragmentation(t, npl, nsppl, symba_pl1P, symba_pld1P, nplplenc, plplenc_list) ! !  Notes       : Adapted from Hal Levison's Swift routine discard_mass_merge.f ! !********************************************************************************************************************************** SUBROUTINE symba_fragmentation ( t , dt , index_enc , nmergeadd , nmergesub , mergeadd_list , mergesub_list , eoffset , vbs , & encounter_file , out_type , npl , ntp , symba_plA , symba_tpA , nplplenc , npltpenc , pltpenc_list , plplenc_list , & nplmax , ntpmax , fragmax ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_fragmentation IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: index_enc , nplmax , ntpmax INTEGER ( I4B ), INTENT ( INOUT ) :: npl , ntp , nmergeadd , nmergesub , nplplenc , npltpenc , fragmax REAL ( DP ), INTENT ( IN ) :: t , dt REAL ( DP ), INTENT ( INOUT ) :: eoffset REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: vbs CHARACTER ( * ), INTENT ( IN ) :: encounter_file , out_type TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list TYPE ( symba_pltpenc ), INTENT ( INOUT ) :: pltpenc_list TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA ! Internals INTEGER ( I4B ) :: model , nres , i REAL ( DP ), DIMENSION ( 3 ) :: mres , rres REAL ( DP ), DIMENSION ( NDIM , 3 ) :: pres , vres INTEGER ( I4B ) :: regime INTEGER ( I4B ) :: index1 , index2 , index1_child , index2_child , index1_parent , index2_parent INTEGER ( I4B ) :: name1 , name2 , index_big1 , index_big2 , stat1 , stat2 REAL ( DP ) :: r2 , rlim , rlim2 , vdotr , tcr2 , dt2 , a , e , q REAL ( DP ) :: rad1 , rad2 , m1 , m2 , GU , den1 , den2 , denchild , mbig , msmall REAL ( DP ) :: m1_cgs , m2_cgs , rad1_cgs , rad2_cgs , mass1 , mass2 , mmax , mtmp , mtot , m1_si , m2_si REAL ( DP ), DIMENSION ( NDIM ) :: xr , vr , x1 , v1 , x2 , v2 REAL ( DP ), DIMENSION ( NDIM ) :: x1_cgs , x2_cgs , v1_cgs , v2_cgs , x1_au , x2_au , v1_auy , v2_auy LOGICAL ( LGT ) :: lfrag_add , lmerge INTEGER ( I4B ), DIMENSION ( npl ) :: array_index1_child , array_index2_child REAL ( DP ) :: MSUN , K2 , m1_msun , m2_msun , rad1_au , rad2_au , AU2CM , year , Mlr , Mslr ! Executable code lmerge = . FALSE . lfrag_add = . FALSE . ! Model 2 is the model for collresolve_resolve (LS12) model = 2 index1 = plplenc_list % index1 ( index_enc ) index2 = plplenc_list % index2 ( index_enc ) rlim = symba_plA % helio % swiftest % radius ( index1 ) + symba_plA % helio % swiftest % radius ( index2 ) xr (:) = symba_plA % helio % swiftest % xh (:, index2 ) - symba_plA % helio % swiftest % xh (:, index1 ) r2 = DOT_PRODUCT ( xr (:), xr (:)) rlim2 = rlim * rlim ! checks if bodies are actively colliding in this time step IF ( rlim2 >= r2 ) THEN lfrag_add = . TRUE . ! if they are not actively colliding in  this time step, !checks if they are going to collide next time step based on velocities and q ELSE vr (:) = symba_plA % helio % swiftest % vb (:, index2 ) - symba_plA % helio % swiftest % vb (:, index1 ) vdotr = DOT_PRODUCT ( xr (:), vr (:)) IF ( plplenc_list % lvdotr ( index_enc ) . AND . ( vdotr > 0.0_DP )) THEN tcr2 = r2 / DOT_PRODUCT ( vr (:), vr (:)) dt2 = dt * dt IF ( tcr2 <= dt2 ) THEN mtot = symba_plA % helio % swiftest % mass ( index1 ) + symba_plA % helio % swiftest % mass ( index2 ) CALL orbel_xv2aeq ( xr (:), vr (:), mtot , a , e , q ) IF ( q < rlim ) lfrag_add = . TRUE . END IF ! if no collision is going to happen, write as close encounter, not  merger IF (. NOT . lfrag_add ) THEN IF ( encounter_file /= \"\" ) THEN name1 = symba_plA % helio % swiftest % name ( index1 ) m1 = symba_plA % helio % swiftest % mass ( index1 ) rad1 = symba_plA % helio % swiftest % radius ( index1 ) x1 (:) = symba_plA % helio % swiftest % xh (:, index1 ) v1 (:) = symba_plA % helio % swiftest % vb (:, index1 ) - vbs (:) name2 = symba_plA % helio % swiftest % name ( index2 ) m2 = symba_plA % helio % swiftest % mass ( index2 ) rad2 = symba_plA % helio % swiftest % radius ( index2 ) x2 (:) = symba_plA % helio % swiftest % xh (:, index2 ) v2 (:) = symba_plA % helio % swiftest % vb (:, index2 ) - vbs (:) CALL io_write_encounter ( t , name1 , name2 , m1 , m2 , rad1 , rad2 , x1 (:), x2 (:), & v1 (:), v2 (:), encounter_file , out_type ) END IF END IF END IF END IF nres = 2 IF ( lfrag_add ) THEN symba_plA % lmerged ( index1 ) = . TRUE . symba_plA % lmerged ( index2 ) = . TRUE . index1_parent = symba_plA % index_parent ( index1 ) m1 = symba_plA % helio % swiftest % mass ( index1_parent ) mass1 = m1 x1 (:) = m1 * symba_plA % helio % swiftest % xh (:, index1_parent ) v1 (:) = m1 * symba_plA % helio % swiftest % vb (:, index1_parent ) mmax = m1 name1 = symba_plA % helio % swiftest % name ( index1_parent ) index_big1 = index1_parent stat1 = symba_plA % helio % swiftest % status ( index1_parent ) array_index1_child ( 1 : npl ) = symba_plA % index_child ( 1 : npl , index1_parent ) den1 = ( m1 ** 2 ) / (( 4.0_DP / 3.0_DP ) * PI * symba_plA % helio % swiftest % radius ( index1_parent ) ** 3 ) DO i = 1 , symba_plA % nchild ( index1_parent ) ! initialize an array of children index1_child = array_index1_child ( i ) mtmp = symba_plA % helio % swiftest % mass ( index1_child ) denchild = ( mtmp ** 2 ) / (( 4.0_DP / 3.0_DP ) * PI * symba_plA % helio % swiftest % radius ( index1_child ) ** 3 ) den1 = den1 + denchild IF ( mtmp > mmax ) THEN mmax = mtmp name1 = symba_plA % helio % swiftest % name ( index1_child ) index_big1 = index1_child stat1 = symba_plA % helio % swiftest % status ( index1_child ) END IF m1 = m1 + mtmp x1 (:) = x1 (:) + mtmp * symba_plA % helio % swiftest % xh (:, index1_child ) v1 (:) = v1 (:) + mtmp * symba_plA % helio % swiftest % vb (:, index1_child ) END DO den1 = den1 / m1 rad1 = (( 3.0_DP * m1 ) / ( den1 * 4.0_DP * PI )) ** ( 1.0_DP / 3.0_DP ) x1 (:) = x1 (:) / m1 v1 (:) = v1 (:) / m1 index2_parent = symba_plA % index_parent ( index2 ) m2 = symba_plA % helio % swiftest % mass ( index2_parent ) mass2 = m2 rad2 = symba_plA % helio % swiftest % radius ( index2_parent ) x2 (:) = m2 * symba_plA % helio % swiftest % xh (:, index2_parent ) v2 (:) = m2 * symba_plA % helio % swiftest % vb (:, index2_parent ) mmax = m2 name2 = symba_plA % helio % swiftest % name ( index2_parent ) index_big2 = index2_parent stat2 = symba_plA % helio % swiftest % status ( index2_parent ) array_index2_child ( 1 : npl ) = symba_plA % index_child ( 1 : npl , index2_parent ) den2 = ( m2 ** 2 ) / (( 4.0_DP / 3.0_DP ) * PI * symba_plA % helio % swiftest % radius ( index2_parent ) ** 3 ) DO i = 1 , symba_plA % nchild ( index2_parent ) index2_child = array_index2_child ( i ) mtmp = symba_plA % helio % swiftest % mass ( index2_child ) denchild = ( mtmp ** 2 ) / (( 4.0_DP / 3.0_DP ) * PI * symba_plA % helio % swiftest % radius ( index2_child ) ** 3 ) den2 = den2 + denchild IF ( mtmp > mmax ) THEN mmax = mtmp name2 = symba_plA % helio % swiftest % name ( index2_child ) index_big2 = index2_child stat2 = symba_plA % helio % swiftest % status ( index2_child ) END IF m2 = m2 + mtmp x2 (:) = x2 (:) + mtmp * symba_plA % helio % swiftest % xh (:, index2_child ) v2 (:) = v2 (:) + mtmp * symba_plA % helio % swiftest % vb (:, index2_child ) END DO den2 = den2 / m2 rad2 = (( 3.0_DP * m2 ) / ( den2 * 4.0_DP * PI )) ** ( 1.0_DP / 3.0_DP ) x2 (:) = x2 (:) / m2 v2 (:) = v2 (:) / m2 GU = GC / ( DU2CM ** 3 / ( MU2GM * TU2S ** 2 )) m1_cgs = ( m1 / GU ) * MU2GM m2_cgs = ( m2 / GU ) * MU2GM MSUN = 1.989e33 !Msun in cgs AU2CM = 1.496e+13 !AU in cgs m1_msun = m1_cgs / MSUN m2_msun = m2_cgs / MSUN K2 = 2.959122082855911e-4 rad1_cgs = ( rad1 ) * DU2CM rad2_cgs = ( rad2 ) * DU2CM rad1_au = rad1_cgs / AU2CM rad2_au = rad2_cgs / AU2CM x1_cgs (:) = x1 (:) * DU2CM x2_cgs (:) = x2 (:) * DU2CM x1_au (:) = x1_cgs (:) / AU2CM x2_au (:) = x2_cgs (:) / AU2CM v1_cgs (:) = v1 (:) * DU2CM / TU2S v2_cgs (:) = v2 (:) * DU2CM / TU2S year = 3.154e7 v1_auy (:) = v1_cgs (:) / AU2CM * ( year ) v2_auy (:) = v2_cgs (:) / AU2CM * ( year ) mres (:) = 0.0_DP rres (:) = 0.0_DP pres (:,:) = 0.0_DP vres (:,:) = 0.0_DP m1_si = m1 / ( GC * 100 0.0_DP ) m2_si = m2 / ( GC * 100 0.0_DP ) ! PROBLEM !WRITE(*,*) \"model: \", model !WRITE(*,*) \"m1_msun: \", m1_msun !WRITE(*,*) \"m2_msun: \", m2_msun !WRITE(*,*) \"rad1_au: \", rad1_au !WRITE(*,*) \"rad2_au: \", rad2_au !WRITE(*,*) \"x1_au: \", x1_au !WRITE(*,*) \"x2_au: \", x2_au !WRITE(*,*) \"v1_auy: \", v1_auy !WRITE(*,*) \"v2_auy: \", v2_auy !WRITE(*,*) \"nres: \", nres !WRITE(*,*) \"mres: \", mres(:) !THIS IS THE PROBLEM !WRITE(*,*) \"rres: \", rres(:) !WRITE(*,*) \"pres: \", pres(:,:) !WRITE(*,*) \"vres: \", vres(:,:) !WRITE(*,*) \"Before collresolve_resolve\" !regime = collresolve_resolve(model,m1_msun,m2_msun,rad1_au,rad2_au,x1_au(:),x2_au(:), v1_auy(:),v2_auy(:), & !nres,mres,rres,pres,vres) regime = collresolve_resolve ( model , m1_si , m2_si , rad1 , rad2 , x1 (:), x2 (:), v1 (:), v2 (:), nres , mres , rres , pres , vres ) ! !IF (m1 > m2) THEN !     m1 = mbig !     m2 = msmall !ELSE !     m2 = mbig !     m1 = msmall !END IF !CALL util_regime(symba_plA, mbig, msmall, regime, Mlr, Mslr) !WRITE(*,*) \"Mlr :\", Mlr, \"Mslr: \", Mslr !WRITE(*,*) \"After collresolve_resolve\" !WRITE(*,*) \"nres: \", nres !WRITE(*,*) \"mres: \", mres(:) !THIS IS THE PROBLEM !WRITE(*,*) \"rres: \", rres(:) !WRITE(*,*) \"pres: \", pres(:,:) !WRITE(*,*) \"vres: \", vres(:,:) !PROBLEM mres (:) = mres (:) * GU * MSUN / MU2GM rres (:) = rres (:) * AU2CM / DU2CM CALL symba_caseresolve ( t , dt , index_enc , nmergeadd , nmergesub , mergeadd_list , mergesub_list , & eoffset , vbs , encounter_file , out_type , npl , ntp , symba_plA , symba_tpA , nplplenc , & npltpenc , pltpenc_list , plplenc_list , regime , nplmax , ntpmax , fragmax , mres , rres , & array_index1_child , array_index2_child , m1 , m2 , rad1 , rad2 , x1 , x2 , v1 , v2 ) END IF RETURN END SUBROUTINE symba_fragmentation !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_fragmentation.f90.html"},{"title":"symba_discard_pl.f90 – swiftest","text":"Unit Name   : symba_discard_pl\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Check to see if planets should be discarded based on their positions or because they are unbound Input\n    Arguments : t           : time\n                npl         : number of planets\n                nplmax      : maximum allowed number of planets\n                nsp         : number of spilled planets\n                symba_pl1P  : pointer to head of SyMBA planet structure linked-list\n                symba_pld1P : pointer to head of discard SyMBA planet structure linked-list\n                rmin        : minimum allowed heliocentric radius\n                rmax        : maximum allowed heliocentric radius\n                rmaxu       : maximum allowed heliocentric radius for unbound planets\n                qmin        : minimum allowed pericenter distance\n                qmin_coord  : coordinate frame for qmin\n                qmin_alo    : minimum semimajor axis for qmin\n                qmin_ahi    : maximum semimajor axis for qmin\n                j2rp2       : J2 * R 2 for the Sun\n                j4rp4       : J4 * R 4 for the Sun\n                eoffset     : energy offset\n    Terminal  : none\n    File      : none Output\n    Arguments : npl         : number of planets\n                nsp         : number of spilled planets\n                symba_pl1P  : pointer to head of SyMBA planet structure linked-list\n                symba_pld1P : pointer to head of discard SyMBA planet structure linked-list\n                eoffset     : energy offset\n    Terminal  : none\n    File      : none Invocation  : CALL symba_discard_pl(t, npl, nplmax, nsp, symba_pl1P, symba_pld1P, rmin, rmax, rmaxu, qmin, qmin_coord,\n                                      qmin_alo, qmin_ahi, j2rp2, j4rp4, eoffset) Notes       : Adapted from Hal Levison's Swift routine discard_massive5.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_discard_pl.f90~~EfferentGraph sourcefile~symba_discard_pl.f90 symba_discard_pl.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_discard_pl.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_discard_pl.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_discard_pl.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_discard_pl.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_discard_pl.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_discard_pl Source Code symba_discard_pl.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_discard_pl !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Check to see if planets should be discarded based on their positions or because they are unbound ! !  Input !    Arguments : t           : time !                npl         : number of planets !                nplmax      : maximum allowed number of planets !                nsp         : number of spilled planets !                symba_pl1P  : pointer to head of SyMBA planet structure linked-list !                symba_pld1P : pointer to head of discard SyMBA planet structure linked-list !                rmin        : minimum allowed heliocentric radius !                rmax        : maximum allowed heliocentric radius !                rmaxu       : maximum allowed heliocentric radius for unbound planets !                qmin        : minimum allowed pericenter distance !                qmin_coord  : coordinate frame for qmin !                qmin_alo    : minimum semimajor axis for qmin !                qmin_ahi    : maximum semimajor axis for qmin !                j2rp2       : J2 * R**2 for the Sun !                j4rp4       : J4 * R**4 for the Sun !                eoffset     : energy offset !    Terminal  : none !    File      : none ! !  Output !    Arguments : npl         : number of planets !                nsp         : number of spilled planets !                symba_pl1P  : pointer to head of SyMBA planet structure linked-list !                symba_pld1P : pointer to head of discard SyMBA planet structure linked-list !                eoffset     : energy offset !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_discard_pl(t, npl, nplmax, nsp, symba_pl1P, symba_pld1P, rmin, rmax, rmaxu, qmin, qmin_coord, !                                      qmin_alo, qmin_ahi, j2rp2, j4rp4, eoffset) ! !  Notes       : Adapted from Hal Levison's Swift routine discard_massive5.f ! !********************************************************************************************************************************** SUBROUTINE symba_discard_pl ( t , npl , nplmax , nsp , symba_plA , rmin , rmax , rmaxu , qmin , qmin_coord , qmin_alo , & qmin_ahi , j2rp2 , j4rp4 , eoffset ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_discard_pl IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: nplmax INTEGER ( I4B ), INTENT ( INOUT ) :: npl , nsp REAL ( DP ), INTENT ( IN ) :: t , rmin , rmax , rmaxu , qmin , qmin_alo , qmin_ahi , j2rp2 , j4rp4 REAL ( DP ), INTENT ( INOUT ) :: eoffset CHARACTER ( * ), INTENT ( IN ) :: qmin_coord TYPE ( symba_pl ) :: symba_plA ! Internals LOGICAL ( LGT ) :: ldiscards INTEGER ( I4B ) :: i REAL ( DP ) :: msys , ke , pe , tei , tef REAL ( DP ), DIMENSION ( NDIM ) :: htot ! Executable code ldiscards = . FALSE . IF (( rmin >= 0.0_DP ) . OR . ( rmax >= 0.0_DP ) . OR . ( rmaxu >= 0.0_DP ) . OR . (( qmin >= 0.0_DP ) . AND . ( qmin_coord == \"BARY\" ))) & CALL coord_h2b ( npl , symba_plA % helio % swiftest , msys ) IF (( rmin >= 0.0_DP ) . OR . ( rmax >= 0.0_DP ) . OR . ( rmaxu >= 0.0_DP )) & CALL symba_discard_sun_pl ( t , npl , msys , symba_plA % helio % swiftest , rmin , rmax , rmaxu , ldiscards ) IF ( qmin >= 0.0_DP ) CALL symba_discard_peri_pl ( t , npl , symba_plA , msys , qmin , qmin_alo , qmin_ahi , qmin_coord , ldiscards ) RETURN END SUBROUTINE symba_discard_pl !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_discard_pl.f90.html"},{"title":"symba_chk.f90 – swiftest","text":"Unit Name   : symba_chk\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Check for an encounter Input\n    Arguments : xr         : position of body 2 relative to body 1\n                vr         : velocity of body 2 relative to body 1\n                rhill1     : Hill sphere radius of body 1\n                rhill2     : Hill sphere radius of body 2\n                dt         : time step\n                irec       : recursion level\n    Terminal  : none\n    File      : none Output\n    Arguments : lencounter : logical flag indicating whether there is an encounter this time step\n                lvdotr     : logical flag indicating whether the two bodies are approaching\n    Terminal  : none\n    File      : none Invocation  : CALL symba_chk(xr, vr, rhill1, rhill2, dt, irec, lencounter, lvdotr) Notes       : Adapted from Hal Levison's Swift routine symba5_chk.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_chk.f90~~EfferentGraph sourcefile~symba_chk.f90 symba_chk.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_chk.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_chk.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_chk.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_chk.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_chk.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_chk Source Code symba_chk.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_chk !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Check for an encounter ! !  Input !    Arguments : xr         : position of body 2 relative to body 1 !                vr         : velocity of body 2 relative to body 1 !                rhill1     : Hill sphere radius of body 1 !                rhill2     : Hill sphere radius of body 2 !                dt         : time step !                irec       : recursion level !    Terminal  : none !    File      : none ! !  Output !    Arguments : lencounter : logical flag indicating whether there is an encounter this time step !                lvdotr     : logical flag indicating whether the two bodies are approaching !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_chk(xr, vr, rhill1, rhill2, dt, irec, lencounter, lvdotr) ! !  Notes       : Adapted from Hal Levison's Swift routine symba5_chk.f ! !********************************************************************************************************************************** SUBROUTINE symba_chk ( xr , vr , rhill1 , rhill2 , dt , irec , lencounter , lvdotr ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_chk IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( OUT ) :: lencounter , lvdotr INTEGER ( I4B ), INTENT ( IN ) :: irec REAL ( DP ), INTENT ( IN ) :: rhill1 , rhill2 , dt REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: xr , vr ! Internals INTEGER ( I4B ) :: iflag REAL ( DP ) :: rcrit , r2crit , vdotr ! Executable code lencounter = . FALSE . rcrit = ( rhill1 + rhill2 ) * RHSCALE * ( RSHELL ** ( irec )) r2crit = rcrit * rcrit CALL rmvs_chk_ind ( xr (:), vr (:), dt , r2crit , iflag ) IF ( iflag /= 0 ) lencounter = . TRUE . vdotr = DOT_PRODUCT ( vr (:), xr (:)) lvdotr = ( vdotr < 0.0_DP ) RETURN END SUBROUTINE symba_chk !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_chk.f90.html"},{"title":"symba_peri.f90 – swiftest","text":"Unit Name   : symba_peri\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Determine system pericenter passages for planets in SyMBA Input\n    Arguments : lfirst     : logical flag indicating whether current invocation is the first\n                npl        : number of planets\n                symba_pl1P : pointer to head of SyMBA planet structure linked-list\n                msys       : total system mass\n                qmin_coord : coordinate frame for qmin\n    Terminal  : none\n    File      : none Output\n    Arguments : symba_pl1P : pointer to head of SyMBA planet structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL symba_peri(lfirst, npl, symba_pl1P, msys, qmin_coord) Notes       : Adapted from Hal Levison's Swift routine util_mass_peri.f If the coordinate system used is barycentric, then this routine assumes that the barycentric coordinates in the planet structures are up-to-date and are not recomputed Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_peri.f90~~EfferentGraph sourcefile~symba_peri.f90 symba_peri.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_peri.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_peri.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_peri.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_peri.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_peri.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_peri Source Code symba_peri.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_peri !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Determine system pericenter passages for planets in SyMBA ! !  Input !    Arguments : lfirst     : logical flag indicating whether current invocation is the first !                npl        : number of planets !                symba_pl1P : pointer to head of SyMBA planet structure linked-list !                msys       : total system mass !                qmin_coord : coordinate frame for qmin !    Terminal  : none !    File      : none ! !  Output !    Arguments : symba_pl1P : pointer to head of SyMBA planet structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_peri(lfirst, npl, symba_pl1P, msys, qmin_coord) ! !  Notes       : Adapted from Hal Levison's Swift routine util_mass_peri.f ! !                If the coordinate system used is barycentric, then this routine assumes that the barycentric coordinates in the !                planet structures are up-to-date and are not recomputed ! !********************************************************************************************************************************** SUBROUTINE symba_peri ( lfirst , npl , symba_plA , msys , qmin_coord ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_peri IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( IN ) :: lfirst INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: msys CHARACTER ( * ), INTENT ( IN ) :: qmin_coord TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA ! Internals INTEGER ( I4B ) :: i REAL ( DP ) :: vdotr , e , mu , msun ! Executable code msun = symba_plA % helio % swiftest % mass ( 1 ) IF ( lfirst ) THEN IF ( qmin_coord == \"HELIO\" ) THEN DO i = 2 , npl IF ( symba_plA % helio % swiftest % status ( i ) == ACTIVE ) THEN vdotr = DOT_PRODUCT ( symba_plA % helio % swiftest % xh (:, i ), symba_plA % helio % swiftest % vh (:, i )) IF ( vdotr > 0.0_DP ) THEN symba_plA % isperi ( i ) = 1 ELSE symba_plA % isperi ( i ) = - 1 END IF END IF END DO ELSE DO i = 2 , npl IF ( symba_plA % helio % swiftest % status ( i ) == ACTIVE ) THEN vdotr = DOT_PRODUCT ( symba_plA % helio % swiftest % xb (:, i ), symba_plA % helio % swiftest % vb (:, i )) IF ( vdotr > 0.0_DP ) THEN symba_plA % isperi ( i ) = 1 ELSE symba_plA % isperi ( i ) = - 1 END IF END IF END DO END IF ELSE IF ( qmin_coord == \"HELIO\" ) THEN DO i = 2 , npl IF ( symba_plA % helio % swiftest % status ( i ) == ACTIVE ) THEN vdotr = DOT_PRODUCT ( symba_plA % helio % swiftest % xh (:, i ), symba_plA % helio % swiftest % vh (:, i )) IF ( symba_plA % isperi ( i ) == - 1 ) THEN IF ( vdotr >= 0.0_DP ) THEN symba_plA % isperi ( i ) = 0 mu = msun + symba_plA % helio % swiftest % mass ( i ) CALL orbel_xv2aeq ( symba_plA % helio % swiftest % xh (:, i ), & symba_plA % helio % swiftest % vh (:, i ), mu , symba_plA % atp ( i ), e , symba_plA % peri ( i )) END IF ELSE IF ( vdotr > 0.0_DP ) THEN symba_plA % isperi ( i ) = 1 ELSE symba_plA % isperi ( i ) = - 1 END IF END IF END IF END DO ELSE DO i = 2 , npl IF ( symba_plA % helio % swiftest % status ( i ) == ACTIVE ) THEN vdotr = DOT_PRODUCT ( symba_plA % helio % swiftest % xb (:, i ), symba_plA % helio % swiftest % vb (:, i )) IF ( symba_plA % isperi ( i ) == - 1 ) THEN IF ( vdotr >= 0.0_DP ) THEN symba_plA % isperi ( i ) = 0 CALL orbel_xv2aeq ( symba_plA % helio % swiftest % xb (:, i ), & symba_plA % helio % swiftest % vb (:, i ), msys , symba_plA % atp ( i ), e , symba_plA % peri ( i )) END IF ELSE IF ( vdotr > 0.0_DP ) THEN symba_plA % isperi ( i ) = 1 ELSE symba_plA % isperi ( i ) = - 1 END IF END IF END IF END DO END IF END IF RETURN END SUBROUTINE symba_peri !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_peri.f90.html"},{"title":"symba_energy.f90 – swiftest","text":"Unit Name   : symba_energy\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Compute total system angular momentum vector and kinetic, potential and total system energy Input\n    Arguments : npl          : number of planets\n                nplmax       : maximum allowed number of planets\n                swiftest_pl1P : pointer to head of Swiftest planet structure linked-list\n                j2rp2        : J2 * R 2 for the Sun\n                j4rp4        : J4 * R 4 for the Sun\n    Terminal  : none\n    File      : none Output\n    Arguments : ke           : kinetic energy\n                pe           : potential energy\n                te           : total energy\n                htot         : angular momentum vector\n    Terminal  : none\n    File      : none Invocation  : CALL symba_energy(npl, nplmax, swiftest_pl1P, j2rp2, j4rp4, ke, pe, te, htot) Notes       : Adapted from Martin Duncan's Swift routine anal_energy.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_energy.f90~~EfferentGraph sourcefile~symba_energy.f90 symba_energy.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_energy.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_energy.f90->sourcefile~module_swiftest.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_energy.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_energy Source Code symba_energy.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_energy !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Compute total system angular momentum vector and kinetic, potential and total system energy ! !  Input !    Arguments : npl          : number of planets !                nplmax       : maximum allowed number of planets !                swiftest_pl1P : pointer to head of Swiftest planet structure linked-list !                j2rp2        : J2 * R**2 for the Sun !                j4rp4        : J4 * R**4 for the Sun !    Terminal  : none !    File      : none ! !  Output !    Arguments : ke           : kinetic energy !                pe           : potential energy !                te           : total energy !                htot         : angular momentum vector !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_energy(npl, nplmax, swiftest_pl1P, j2rp2, j4rp4, ke, pe, te, htot) ! !  Notes       : Adapted from Martin Duncan's Swift routine anal_energy.f ! !********************************************************************************************************************************** SUBROUTINE symba_energy ( npl , swiftest_plA , j2rp2 , j4rp4 , ke , pe , te , htot ) ! Modules USE swiftest USE module_swiftest USE module_interfaces , EXCEPT_THIS_ONE => symba_energy IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl REAL ( DP ), INTENT ( IN ) :: j2rp2 , j4rp4 REAL ( DP ), INTENT ( OUT ) :: ke , pe , te REAL ( DP ), DIMENSION ( NDIM ), INTENT ( OUT ) :: htot TYPE ( swiftest_pl ), INTENT ( INOUT ) :: swiftest_plA ! Internals INTEGER ( I4B ) :: i , j REAL ( DP ) :: mass , msys , r2 , v2 , oblpot REAL ( DP ), DIMENSION ( NDIM ) :: h , x , v , dx REAL ( DP ), DIMENSION ( npl ) :: irh ! Executable code CALL coord_h2b ( npl , swiftest_plA , msys ) htot = ( / 0.0_DP , 0.0_DP , 0.0_DP / ) ke = 0.0_DP pe = 0.0_DP DO i = 1 , npl - 1 x (:) = swiftest_plA % xb (:, i ) v (:) = swiftest_plA % vb (:, i ) mass = swiftest_plA % mass ( i ) h ( 1 ) = mass * ( x ( 2 ) * v ( 3 ) - x ( 3 ) * v ( 2 )) h ( 2 ) = mass * ( x ( 3 ) * v ( 1 ) - x ( 1 ) * v ( 3 )) h ( 3 ) = mass * ( x ( 1 ) * v ( 2 ) - x ( 2 ) * v ( 1 )) htot (:) = htot (:) + h (:) v2 = DOT_PRODUCT ( v (:), v (:)) ke = ke + 0.5_DP * mass * v2 DO j = i + 1 , npl dx (:) = swiftest_plA % xb (:, j ) - x (:) !this is 0 for the removed ps because swiftest_plA%xb(:,j) = swiftest_plA%xb(:,i) r2 = DOT_PRODUCT ( dx (:), dx (:)) !this is 0 for the removed ps IF ( r2 /= 0 ) THEN pe = pe - mass * swiftest_plA % mass ( j ) / SQRT ( r2 ) !DIVISION !!!!!!r2 is 0 for ps 12 which is the removed ps END IF END DO END DO x (:) = swiftest_plA % xb (:, i ) v (:) = swiftest_plA % vb (:, i ) mass = swiftest_plA % mass ( i ) h ( 1 ) = mass * ( x ( 2 ) * v ( 3 ) - x ( 3 ) * v ( 2 )) h ( 2 ) = mass * ( x ( 3 ) * v ( 1 ) - x ( 1 ) * v ( 3 )) h ( 3 ) = mass * ( x ( 1 ) * v ( 2 ) - x ( 2 ) * v ( 1 )) htot (:) = htot (:) + h (:) v2 = DOT_PRODUCT ( v (:), v (:)) ke = ke + 0.5_DP * mass * v2 IF ( j2rp2 /= 0.0_DP ) THEN DO i = 2 , npl r2 = DOT_PRODUCT ( swiftest_plA % xh (:, i ), swiftest_plA % xh (:, i )) irh ( i ) = 1.0_DP / SQRT ( r2 ) END DO CALL obl_pot ( npl , swiftest_plA , j2rp2 , j4rp4 , swiftest_plA % xh (:,:), irh , oblpot ) pe = pe + oblpot END IF te = ke + pe RETURN END SUBROUTINE symba_energy !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_energy.f90.html"},{"title":"symba_getacch_tp.f90 – swiftest","text":"Unit Name   : symba_getacch_tp\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Compute heliocentric accelerations of test particles Input\n    Arguments : lextra_force : logical flag indicating whether to include user-supplied accelerations\n                t            : time\n                npl          : number of planets\n                nplm         : number of planets with mass > mtiny\n                nplmax       : maximum allowed number of planets\n                ntp          : number of active test particles\n                ntpmax       : maximum allowed number of test particles\n                symba_pl1P   : pointer to head of SyMBA planet structure linked-list\n                symba_tp1P   : pointer to head of active SyMBA test particle structure linked-list\n                xh           : heliocentric positions of planets at time t\n                j2rp2        : J2 * R 2 for the Sun\n                j4rp4        : J4 * R 4 for the Sun\n                npltpenc     : number of planet-test particle encounters\n                pltpenc_list : array of planet-test particle encounter structures\n    Terminal  : none\n    File      : none Output\n    Arguments : symba_tp1P   : pointer to head of active SyMBA test particle structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL symba_getacch_tp(lextra_force, t, npl, nplm, nplmax, ntp, ntpmax, symba_pl1P, symba_tp1P, xh, j2rp2, j4rp4,\n                                      npltpenc, pltpenc_list) Notes       : Adapted from Hal Levison's Swift routine symba5_getacch.f Accelerations in an encounter are not included here Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_getacch_tp.f90~~EfferentGraph sourcefile~symba_getacch_tp.f90 symba_getacch_tp.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_getacch_tp.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_getacch_tp.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_getacch_tp.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_getacch_tp.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_getacch_tp.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_getacch_tp Source Code symba_getacch_tp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_getacch_tp !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Compute heliocentric accelerations of test particles ! !  Input !    Arguments : lextra_force : logical flag indicating whether to include user-supplied accelerations !                t            : time !                npl          : number of planets !                nplm         : number of planets with mass > mtiny !                nplmax       : maximum allowed number of planets !                ntp          : number of active test particles !                ntpmax       : maximum allowed number of test particles !                symba_pl1P   : pointer to head of SyMBA planet structure linked-list !                symba_tp1P   : pointer to head of active SyMBA test particle structure linked-list !                xh           : heliocentric positions of planets at time t !                j2rp2        : J2 * R**2 for the Sun !                j4rp4        : J4 * R**4 for the Sun !                npltpenc     : number of planet-test particle encounters !                pltpenc_list : array of planet-test particle encounter structures !    Terminal  : none !    File      : none ! !  Output !    Arguments : symba_tp1P   : pointer to head of active SyMBA test particle structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_getacch_tp(lextra_force, t, npl, nplm, nplmax, ntp, ntpmax, symba_pl1P, symba_tp1P, xh, j2rp2, j4rp4, !                                      npltpenc, pltpenc_list) ! !  Notes       : Adapted from Hal Levison's Swift routine symba5_getacch.f ! !                Accelerations in an encounter are not included here ! !********************************************************************************************************************************** SUBROUTINE symba_getacch_tp ( lextra_force , t , npl , nplm , nplmax , ntp , ntpmax , symba_plA , symba_tpA , xh , j2rp2 , j4rp4 , npltpenc , & pltpenc_list ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_getacch_tp IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( IN ) :: lextra_force INTEGER ( I4B ), INTENT ( IN ) :: npl , nplm , nplmax , ntp , ntpmax , npltpenc REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 REAL ( DP ), DIMENSION ( NDIM , npl ), INTENT ( IN ) :: xh TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA TYPE ( symba_pltpenc ), INTENT ( IN ) :: pltpenc_list ! Internals LOGICAL ( LGT ), SAVE :: lmalloc = . TRUE . INTEGER ( I4B ) :: i , j , index_pl , index_tp REAL ( DP ) :: r2 , fac , mu REAL ( DP ), DIMENSION ( NDIM ) :: dx REAL ( DP ), DIMENSION (:), ALLOCATABLE , SAVE :: irh , irht REAL ( DP ), DIMENSION (:, :), ALLOCATABLE , SAVE :: aobl , xht , aoblt ! Executable code DO i = 1 , ntp symba_tpA % helio % ah (:, i ) = ( / 0.0_DP , 0.0_DP , 0.0_DP / ) IF ( symba_tpA % helio % swiftest % status ( i ) == ACTIVE ) THEN DO j = 2 , nplm dx (:) = symba_tpA % helio % swiftest % xh (:, i ) - xh (:, j ) r2 = DOT_PRODUCT ( dx (:), dx (:)) fac = symba_PlA % helio % swiftest % mass ( j ) / ( r2 * SQRT ( r2 )) symba_tpA % helio % ah (:, i ) = symba_tpA % helio % ah (:, i ) - fac * dx (:) END DO END IF END DO DO i = 1 , npltpenc index_pl = pltpenc_list % indexpl ( i ) index_tp = pltpenc_list % indextp ( i ) IF ( symba_tpA % helio % swiftest % status ( index_tp ) == ACTIVE ) THEN dx (:) = symba_tpA % helio % swiftest % xh (:, index_tp ) - symba_plA % helio % swiftest % xh (:, index_pl ) r2 = DOT_PRODUCT ( dx (:), dx (:)) fac = symba_plA % helio % swiftest % mass ( index_pl ) / ( r2 * SQRT ( r2 )) symba_tpA % helio % ah (:, index_tp ) = symba_tpA % helio % ah (:, index_tp ) + fac * dx (:) END IF END DO IF ( j2rp2 /= 0.0_DP ) THEN IF ( lmalloc ) THEN ALLOCATE ( aobl ( NDIM , nplmax ), irh ( nplmax ), xht ( NDIM , ntpmax ), aoblt ( NDIM , ntpmax ), irht ( ntpmax )) lmalloc = . FALSE . END IF DO i = 2 , npl r2 = DOT_PRODUCT ( xh (:, i ), xh (:, i )) irh ( i ) = 1.0_DP / SQRT ( r2 ) END DO CALL obl_acc ( npl , symba_plA % helio % swiftest , j2rp2 , j4rp4 , symba_plA % helio % swiftest % xh (:,:), irh , aobl ) mu = symba_plA % helio % swiftest % mass ( 1 ) DO i = 1 , ntp xht (:, i ) = symba_tpA % helio % swiftest % xh (:, i ) r2 = DOT_PRODUCT ( xht (:, i ), xht (:, i )) irht ( i ) = 1.0_DP / SQRT ( r2 ) END DO CALL obl_acc_tp ( ntp , xht , j2rp2 , j4rp4 , irht , aoblt , mu ) DO i = 1 , ntp IF ( symba_tpA % helio % swiftest % status ( i ) == ACTIVE ) & symba_tpA % helio % ah (:, i ) = symba_tpA % helio % ah (:, i ) + aoblt (:, i ) - aobl (:, 1 ) END DO END IF IF ( lextra_force ) CALL symba_user_getacch_tp ( t , ntp , symba_tpA ) RETURN END SUBROUTINE symba_getacch_tp !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_getacch_tp.f90.html"},{"title":"symba_casesupercatastrophic.f90 – swiftest","text":"Unit Name   : symba_casesupercatastrophic\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Merge planets Input\n    Arguments : t            : time\n                npl          : number of planets\n                nsppl        : number of spilled planets\n                symba_pl1P   : pointer to head of SyMBA planet structure linked-list\n                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list\n                nplplenc     : number of planet-planet encounters\n                plplenc_list : array of planet-planet encounter structures\n    Terminal  : none\n    File      : none Output\n    Arguments : npl          : number of planets\n                nsppl        : number of spilled planets\n                symba_pl1P   : pointer to head of SyMBA planet structure linked-list\n                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL symba_casesupercatastrophic(t, npl, nsppl, symba_pl1P, symba_pld1P, nplplenc, plplenc_list) Notes       : Adapted from Hal Levison's Swift routine discard_mass_merge.f This file depends on sourcefile~~symba_casesupercatastrophic.f90~~EfferentGraph sourcefile~symba_casesupercatastrophic.f90 symba_casesupercatastrophic.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_casesupercatastrophic.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_casesupercatastrophic.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_casesupercatastrophic.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_casesupercatastrophic.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_casesupercatastrophic.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_casesupercatastrophic Source Code symba_casesupercatastrophic.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_casesupercatastrophic !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Merge planets ! !  Input !    Arguments : t            : time !                npl          : number of planets !                nsppl        : number of spilled planets !                symba_pl1P   : pointer to head of SyMBA planet structure linked-list !                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list !                nplplenc     : number of planet-planet encounters !                plplenc_list : array of planet-planet encounter structures !    Terminal  : none !    File      : none ! !  Output !    Arguments : npl          : number of planets !                nsppl        : number of spilled planets !                symba_pl1P   : pointer to head of SyMBA planet structure linked-list !                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_casesupercatastrophic(t, npl, nsppl, symba_pl1P, symba_pld1P, nplplenc, plplenc_list) ! !  Notes       : Adapted from Hal Levison's Swift routine discard_mass_merge.f ! !********************************************************************************************************************************** SUBROUTINE symba_casesupercatastrophic ( t , dt , index_enc , nmergeadd , nmergesub , mergeadd_list , mergesub_list , eoffset , vbs , & symba_plA , nplplenc , plplenc_list , nplmax , ntpmax , fragmax , mres , rres , m1 , m2 , rad1 , rad2 , x1 , x2 , v1 , v2 ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_casesupercatastrophic IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: index_enc , nplmax , ntpmax INTEGER ( I4B ), INTENT ( INOUT ) :: nmergeadd , nmergesub , nplplenc , fragmax REAL ( DP ), INTENT ( IN ) :: t , dt REAL ( DP ), INTENT ( INOUT ) :: eoffset , m1 , m2 , rad1 , rad2 REAL ( DP ), DIMENSION ( 3 ), INTENT ( INOUT ) :: mres , rres REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: vbs REAL ( DP ), DIMENSION ( NDIM ), INTENT ( INOUT ) :: x1 , x2 , v1 , v2 TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA ! Internals INTEGER ( I4B ) :: nfrag , i , k , index1 , index2 INTEGER ( I4B ) :: index1_parent , index2_parent INTEGER ( I4B ) :: name1 , name2 REAL ( DP ) :: mtot , msun , avg_d , d_p1 , d_p2 , semimajor_encounter , e , q , semimajor_inward REAL ( DP ) :: rhill_p1 , rhill_p2 , r_circle , theta , radius1 , radius2 REAL ( DP ) :: m_rem , m_test , mass1 , mass2 , enew , eold REAL ( DP ) :: x_com , y_com , z_com , vx_com , vy_com , vz_com REAL ( DP ) :: x_frag , y_frag , z_frag , vx_frag , vy_frag , vz_frag , m1m2_10 REAL ( DP ), DIMENSION ( NDIM ) :: vnew , xr , mv ! Executable code ! nfrag should be larger than disruption to account for the majority of mass entering fragments instead of lr and slr nfrag = 10 index1 = plplenc_list % index1 ( index_enc ) index2 = plplenc_list % index2 ( index_enc ) index1_parent = symba_plA % index_parent ( index1 ) index2_parent = symba_plA % index_parent ( index2 ) name1 = symba_plA % helio % swiftest % name ( index1 ) name2 = symba_plA % helio % swiftest % name ( index2 ) msun = symba_plA % helio % swiftest % mass ( 1 ) mass1 = symba_plA % helio % swiftest % mass ( index1 ) mass2 = symba_plA % helio % swiftest % mass ( index2 ) radius1 = symba_plA % helio % swiftest % radius ( index1 ) radius2 = symba_plA % helio % swiftest % radius ( index2 ) ! Find COM x_com = (( x1 ( 1 ) * m1 ) + ( x2 ( 1 ) * m2 )) / ( m1 + m2 ) y_com = (( x1 ( 2 ) * m1 ) + ( x2 ( 2 ) * m2 )) / ( m1 + m2 ) z_com = (( x1 ( 3 ) * m1 ) + ( x2 ( 3 ) * m2 )) / ( m1 + m2 ) vx_com = (( v1 ( 1 ) * m1 ) + ( v2 ( 1 ) * m2 )) / ( m1 + m2 ) vy_com = (( v1 ( 2 ) * m1 ) + ( v2 ( 2 ) * m2 )) / ( m1 + m2 ) vz_com = (( v1 ( 3 ) * m1 ) + ( v2 ( 3 ) * m2 )) / ( m1 + m2 ) ! Find energy pre-frag eold = 0.5_DP * ( m1 * DOT_PRODUCT ( v1 (:), v1 (:)) + m2 * DOT_PRODUCT ( v2 (:), v2 (:))) xr (:) = x2 (:) - x1 (:) eold = eold - ( m1 * m2 / ( SQRT ( DOT_PRODUCT ( xr (:), xr (:))))) WRITE ( * , * ) \"Supercatastrophic disruption between particles \" , name1 , \" and \" , name2 , \" at time t = \" , t WRITE ( * , * ) \"Number of fragments added: \" , nfrag ! Add both parents to mergesub_list nmergesub = nmergesub + 1 mergesub_list % name ( nmergesub ) = name1 mergesub_list % status ( nmergesub ) = SUPERCATASTROPHIC mergesub_list % xh (:, nmergesub ) = x1 (:) mergesub_list % vh (:, nmergesub ) = v1 (:) - vbs (:) mergesub_list % mass ( nmergesub ) = mass1 mergesub_list % radius ( nmergesub ) = radius1 WRITE ( * , * ) \"Name: \" , name1 WRITE ( * , * ) \"Mass: \" , mass1 WRITE ( * , * ) \"Radius: \" , rad1 WRITE ( * , * ) \"Position: \" , x1 (:) WRITE ( * , * ) \"Velocity: \" , v1 (:) - vbs (:) WRITE ( * , * ) \"RHill: \" , symba_plA % helio % swiftest % rhill ( index1 ) nmergesub = nmergesub + 1 mergesub_list % name ( nmergesub ) = name2 mergesub_list % status ( nmergesub ) = SUPERCATASTROPHIC mergesub_list % xh (:, nmergesub ) = x2 (:) mergesub_list % vh (:, nmergesub ) = v2 (:) - vbs (:) mergesub_list % mass ( nmergesub ) = mass2 mergesub_list % radius ( nmergesub ) = radius2 WRITE ( * , * ) \"Name: \" , name2 WRITE ( * , * ) \"Mass: \" , mass2 WRITE ( * , * ) \"Radius: \" , rad2 WRITE ( * , * ) \"Position: \" , x2 (:) WRITE ( * , * ) \"Velocity: \" , v2 (:) - vbs (:) WRITE ( * , * ) \"RHill: \" , symba_plA % helio % swiftest % rhill ( index2 ) ! go through the encounter list and for particles actively encoutering ! prevent them from having further encounters in this timestep by setting status to MERGED DO k = 1 , nplplenc IF (( plplenc_list % status ( k ) == ACTIVE ) . AND . & (( index1 == plplenc_list % index1 ( k ) . OR . index2 == plplenc_list % index2 ( k )) . OR . & ( index2 == plplenc_list % index1 ( k ) . OR . index1 == plplenc_list % index2 ( k )))) THEN plplenc_list % status ( k ) = MERGED END IF END DO symba_plA % helio % swiftest % status ( index1 ) = SUPERCATASTROPHIC symba_plA % helio % swiftest % status ( index2 ) = SUPERCATASTROPHIC ! Calculate the positions of the new fragments rhill_p1 = symba_plA % helio % swiftest % rhill ( index1_parent ) rhill_p2 = symba_plA % helio % swiftest % rhill ( index2_parent ) r_circle = ( rhill_p1 + rhill_p2 ) / ( 2.0_DP * sin ( PI / nfrag )) theta = ( 2.0_DP * PI ) / nfrag semimajor_inward = (( dt * 3 2.0_DP ) ** 2.0_DP ) ** ( 1.0_DP / 3.0_DP ) CALL orbel_xv2aeq ( x1 , v1 , msun , semimajor_encounter , e , q ) IF ( semimajor_inward > ( semimajor_encounter - r_circle )) THEN WRITE ( * , * ) \"Timestep is too large to resolve fragments.\" STOP ELSE ! Add new fragments to mergeadd_list mtot = 0.0_DP ! running total mass of new fragments mv = 0.0_DP ! running sum of m*v of new fragments to be used in COM calculation m1m2_10 = 0.1_DP * ( m1 + m2 ) d_p1 = ( 3.0_DP * m1 ) / ( 4.0_DP * PI * ( rad1 ** 3.0_DP )) d_p2 = ( 3.0_DP * m2 ) / ( 4.0_DP * PI * ( rad2 ** 3.0_DP )) avg_d = ( d_p1 + d_p2 ) / 2.0_DP DO i = 1 , nfrag nmergeadd = nmergeadd + 1 mergeadd_list % name ( nmergeadd ) = nplmax + ntpmax + fragmax + i mergeadd_list % status ( nmergeadd ) = SUPERCATASTROPHIC mergeadd_list % ncomp ( nmergeadd ) = 2 IF ( mres ( 1 ) < m1m2_10 ) THEN mergeadd_list % mass ( nmergeadd ) = m1m2_10 mergeadd_list % radius ( nmergeadd ) = (( 3.0_DP * mergeadd_list % mass ( nmergeadd )) / ( 4.0_DP * PI * avg_d )) & ** ( 1.0_DP / 3.0_DP ) mtot = mtot + mergeadd_list % mass ( nmergeadd ) ELSE IF ( i == 1 ) THEN ! first largest particle from collresolve mres[0] rres[0] mergeadd_list % mass ( nmergeadd ) = mres ( 1 ) mergeadd_list % radius ( nmergeadd ) = rres ( 1 ) mtot = mtot + mergeadd_list % mass ( nmergeadd ) END IF IF ( i > 1 ) THEN ! FIXME all other particles implement eq. 31 LS12 ! FIXME current equation taken from Durda et al 2007 Figure 2 Supercatastrophic: N = (1.5e5)e(-1.3*D) m_rem = ( m1 + m2 ) - ( mres ( 1 ) + mres ( 2 )) m_test = ((( - 1.0_DP / 2.6_DP ) * log ( i / ( 1.5_DP * 1 0.0_DP ** 5 ))) ** 3.0_DP ) * (( 4.0_DP / 3.0_DP ) * PI * avg_d ) IF ( m_test < m_rem ) THEN mergeadd_list % mass ( nmergeadd ) = m_test ELSE mergeadd_list % mass ( nmergeadd ) = ( m1 + m2 ) - mtot END IF mergeadd_list % radius ( nmergeadd ) = (( 3.0_DP * mergeadd_list % mass ( nmergeadd )) / ( 4.0_DP * PI * avg_d )) & ** ( 1.0_DP / 3.0_DP ) mtot = mtot + mergeadd_list % mass ( nmergeadd ) END IF END IF x_frag = ( r_circle * cos ( theta * i )) + x_com y_frag = ( r_circle * sin ( theta * i )) + y_com z_frag = z_com vx_frag = (( 1.0_DP / nfrag ) * ( 1.0_DP / mergeadd_list % mass ( nmergeadd )) * (( m1 * v1 ( 1 )) + ( m2 * v2 ( 1 )))) - vbs ( 1 ) vy_frag = (( 1.0_DP / nfrag ) * ( 1.0_DP / mergeadd_list % mass ( nmergeadd )) * (( m1 * v1 ( 2 )) + ( m2 * v2 ( 2 )))) - vbs ( 2 ) vz_frag = vz_com - vbs ( 3 ) mergeadd_list % xh ( 1 , nmergeadd ) = x_frag mergeadd_list % xh ( 2 , nmergeadd ) = y_frag mergeadd_list % xh ( 3 , nmergeadd ) = z_frag mergeadd_list % vh ( 1 , nmergeadd ) = vx_frag mergeadd_list % vh ( 2 , nmergeadd ) = vy_frag mergeadd_list % vh ( 3 , nmergeadd ) = vz_frag mv = mv + ( mergeadd_list % mass ( nmergeadd ) * mergeadd_list % vh (:, nmergeadd )) !WRITE(*,*) \"mergeadd_list mass: \", mergeadd_list%mass(nmergeadd) !WRITE(*,*) \"mergeadd_list radius: \", mergeadd_list%radius(nmergeadd) !WRITE(*,*) \"mergeadd_list xh: \", mergeadd_list%xh(:,nmergeadd) !WRITE(*,*) \"mergeadd_list vh: \", mergeadd_list%vh(:,nmergeadd) END DO END IF ! Calculate energy after frag vnew (:) = mv / mtot ! COM of new fragments enew = 0.5_DP * mtot * DOT_PRODUCT ( vnew (:), vnew (:)) eoffset = eoffset + eold - enew ! Update fragmax to account for new fragments fragmax = fragmax + nfrag RETURN END SUBROUTINE symba_casesupercatastrophic","tags":"","loc":"sourcefile/symba_casesupercatastrophic.f90.html"},{"title":"symba_merge_pl.f90 – swiftest","text":"Unit Name   : symba_merge_pl\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Check whether or not bodies are colliding or on collision path\n                Set up the merger for symba_discard_merge_pl Input\n    Arguments : t              : time\n                dt             : time step\n                index          : index of planet-planet encounter in array plplenc_list\n                nplplenc       : number of planet-planet encounters\n                plplenc_list   : array of planet-planet encounter structures\n                nmergeadd      : number of merged planets to add\n                nmergesub      : number of merged planets to subtract\n                mergeadd_list  : array of structures of merged planets to add\n                mergesub_list  : array of structures of merged planets to subtract\n                eoffset        : energy offset (net energy lost in mergers)\n                vbs            : barycentric velocity of the Sun\n                encounter_file : name of output file for encounters\n                out_type       : binary format of output file\n    Terminal  : none\n    File      : none Output\n    Arguments : plplenc_list   : array of planet-planet encounter structures\n                nmergeadd      : number of merged planets to add\n                nmergesub      : number of merged planets to subtract\n                mergeadd_list  : array of structures of merged planets to add\n                mergesub_list  : array of structures of merged planets to subtract\n                eoffset        : energy offset (net energy lost in mergers)\n    Terminal  : status message\n    File      : none Invocation  : CALL symba_merge_pl(t, dt, index, nplplenc, plplenc_list, nmergeadd, nmergesub, mergeadd_list, mergesub_list,\n                                    eoffset, vbs, encounter_file, out_type) Notes       : Adapted from Hal Levison's Swift routine symba5_merge.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_merge_pl.f90~~EfferentGraph sourcefile~symba_merge_pl.f90 symba_merge_pl.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_merge_pl.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_merge_pl.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_merge_pl.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_merge_pl.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_merge_pl.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_merge_pl Source Code symba_merge_pl.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_merge_pl !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Check whether or not bodies are colliding or on collision path !                Set up the merger for symba_discard_merge_pl ! ! !  Input !    Arguments : t              : time !                dt             : time step !                index          : index of planet-planet encounter in array plplenc_list !                nplplenc       : number of planet-planet encounters !                plplenc_list   : array of planet-planet encounter structures !                nmergeadd      : number of merged planets to add !                nmergesub      : number of merged planets to subtract !                mergeadd_list  : array of structures of merged planets to add !                mergesub_list  : array of structures of merged planets to subtract !                eoffset        : energy offset (net energy lost in mergers) !                vbs            : barycentric velocity of the Sun !                encounter_file : name of output file for encounters !                out_type       : binary format of output file !    Terminal  : none !    File      : none ! !  Output !    Arguments : plplenc_list   : array of planet-planet encounter structures !                nmergeadd      : number of merged planets to add !                nmergesub      : number of merged planets to subtract !                mergeadd_list  : array of structures of merged planets to add !                mergesub_list  : array of structures of merged planets to subtract !                eoffset        : energy offset (net energy lost in mergers) !    Terminal  : status message !    File      : none ! !  Invocation  : CALL symba_merge_pl(t, dt, index, nplplenc, plplenc_list, nmergeadd, nmergesub, mergeadd_list, mergesub_list, !                                    eoffset, vbs, encounter_file, out_type) ! !  Notes       : Adapted from Hal Levison's Swift routine symba5_merge.f ! !********************************************************************************************************************************** SUBROUTINE symba_merge_pl ( t , dt , index_enc , nplplenc , plplenc_list , nmergeadd , nmergesub , mergeadd_list , mergesub_list , eoffset , & vbs , encounter_file , out_type , npl , symba_plA , symba_tpA ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_merge_pl IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: index_enc , nplplenc INTEGER ( I4B ), INTENT ( INOUT ) :: nmergeadd , nmergesub , npl REAL ( DP ), INTENT ( IN ) :: t , dt REAL ( DP ), INTENT ( INOUT ) :: eoffset REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: vbs CHARACTER ( * ), INTENT ( IN ) :: encounter_file , out_type TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA ! Internals LOGICAL ( LGT ) :: lmerge INTEGER ( I4B ) :: i , j , k , stat1 , stat2 , index1 , index2 , index_keep , index_rm , indexchild INTEGER ( I4B ) :: index1_child , index2_child , index1_parent , index2_parent , index_big1 , index_big2 INTEGER ( I4B ) :: name1 , name2 REAL ( DP ) :: r2 , rlim , rlim2 , vdotr , tcr2 , dt2 , mtot , a , e , q , m1 , m2 , mtmp , mmax REAL ( DP ) :: eold , enew , rad1 , rad2 , mass1 , mass2 REAL ( DP ), DIMENSION ( NDIM ) :: xr , vr , x1 , v1 , x2 , v2 , xnew , vnew INTEGER ( I4B ), DIMENSION ( npl ) :: array_index1_child , array_index2_child , array_keep_child , array_rm_child ! Executable code lmerge = . FALSE . index1 = plplenc_list % index1 ( index_enc ) index2 = plplenc_list % index2 ( index_enc ) rlim = symba_plA % helio % swiftest % radius ( index1 ) + symba_plA % helio % swiftest % radius ( index2 ) xr (:) = symba_plA % helio % swiftest % xh (:, index2 ) - symba_plA % helio % swiftest % xh (:, index1 ) r2 = DOT_PRODUCT ( xr (:), xr (:)) rlim2 = rlim * rlim ! checks if bodies are actively colliding in this time step IF ( rlim2 >= r2 ) THEN lmerge = . TRUE . ! if they are not actively colliding in  this time step, !checks if they are going to collide next time step based on velocities and q ELSE vr (:) = symba_plA % helio % swiftest % vb (:, index2 ) - symba_plA % helio % swiftest % vb (:, index1 ) vdotr = DOT_PRODUCT ( xr (:), vr (:)) IF ( plplenc_list % lvdotr ( index_enc ) . AND . ( vdotr > 0.0_DP )) THEN tcr2 = r2 / DOT_PRODUCT ( vr (:), vr (:)) dt2 = dt * dt IF ( tcr2 <= dt2 ) THEN mtot = symba_plA % helio % swiftest % mass ( index1 ) + symba_plA % helio % swiftest % mass ( index2 ) CALL orbel_xv2aeq ( xr (:), vr (:), mtot , a , e , q ) IF ( q < rlim ) lmerge = . TRUE . END IF ! if no collision is going to happen, write as close encounter, not  merger IF (. NOT . lmerge ) THEN IF ( encounter_file /= \"\" ) THEN name1 = symba_plA % helio % swiftest % name ( index1 ) m1 = symba_plA % helio % swiftest % mass ( index1 ) rad1 = symba_plA % helio % swiftest % radius ( index1 ) x1 (:) = symba_plA % helio % swiftest % xh (:, index1 ) v1 (:) = symba_plA % helio % swiftest % vb (:, index1 ) - vbs (:) name2 = symba_plA % helio % swiftest % name ( index2 ) m2 = symba_plA % helio % swiftest % mass ( index2 ) rad2 = symba_plA % helio % swiftest % radius ( index2 ) x2 (:) = symba_plA % helio % swiftest % xh (:, index2 ) v2 (:) = symba_plA % helio % swiftest % vb (:, index2 ) - vbs (:) CALL io_write_encounter ( t , name1 , name2 , m1 , m2 , rad1 , rad2 , x1 (:), x2 (:), & v1 (:), v2 (:), encounter_file , out_type ) END IF END IF END IF END IF !Set up the merger for symba_discard_merge_pl IF ( lmerge ) THEN symba_plA % lmerged ( index1 ) = . TRUE . symba_plA % lmerged ( index2 ) = . TRUE . index1_parent = symba_plA % index_parent ( index1 ) m1 = symba_plA % helio % swiftest % mass ( index1_parent ) mass1 = m1 rad1 = symba_plA % helio % swiftest % radius ( index1_parent ) x1 (:) = m1 * symba_plA % helio % swiftest % xh (:, index1_parent ) v1 (:) = m1 * symba_plA % helio % swiftest % vb (:, index1_parent ) mmax = m1 name1 = symba_plA % helio % swiftest % name ( index1_parent ) index_big1 = index1_parent stat1 = symba_plA % helio % swiftest % status ( index1_parent ) array_index1_child ( 1 : npl ) = symba_plA % index_child ( 1 : npl , index1_parent ) DO i = 1 , symba_plA % nchild ( index1_parent ) ! initialize an array of children index1_child = array_index1_child ( i ) mtmp = symba_plA % helio % swiftest % mass ( index1_child ) IF ( mtmp > mmax ) THEN mmax = mtmp name1 = symba_plA % helio % swiftest % name ( index1_child ) index_big1 = index1_child stat1 = symba_plA % helio % swiftest % status ( index1_child ) END IF m1 = m1 + mtmp x1 (:) = x1 (:) + mtmp * symba_plA % helio % swiftest % xh (:, index1_child ) v1 (:) = v1 (:) + mtmp * symba_plA % helio % swiftest % vb (:, index1_child ) END DO x1 (:) = x1 (:) / m1 v1 (:) = v1 (:) / m1 index2_parent = symba_plA % index_parent ( index2 ) m2 = symba_plA % helio % swiftest % mass ( index2_parent ) mass2 = m2 rad2 = symba_plA % helio % swiftest % radius ( index2_parent ) x2 (:) = m2 * symba_plA % helio % swiftest % xh (:, index2_parent ) v2 (:) = m2 * symba_plA % helio % swiftest % vb (:, index2_parent ) mmax = m2 name2 = symba_plA % helio % swiftest % name ( index2_parent ) index_big2 = index2_parent stat2 = symba_plA % helio % swiftest % status ( index2_parent ) array_index2_child ( 1 : npl ) = symba_plA % index_child ( 1 : npl , index2_parent ) DO i = 1 , symba_plA % nchild ( index2_parent ) index2_child = array_index2_child ( i ) mtmp = symba_plA % helio % swiftest % mass ( index2_child ) IF ( mtmp > mmax ) THEN mmax = mtmp name2 = symba_plA % helio % swiftest % name ( index2_child ) index_big2 = index2_child stat2 = symba_plA % helio % swiftest % status ( index2_child ) END IF m2 = m2 + mtmp x2 (:) = x2 (:) + mtmp * symba_plA % helio % swiftest % xh (:, index2_child ) v2 (:) = v2 (:) + mtmp * symba_plA % helio % swiftest % vb (:, index2_child ) END DO x2 (:) = x2 (:) / m2 v2 (:) = v2 (:) / m2 mtot = m1 + m2 xnew (:) = ( m1 * x1 (:) + m2 * x2 (:)) / mtot vnew (:) = ( m1 * v1 (:) + m2 * v2 (:)) / mtot WRITE ( * , * ) \"Merging particles \" , name1 , \" and \" , name2 , \" at time t = \" , t nmergesub = nmergesub + 1 mergesub_list % name ( nmergesub ) = name1 mergesub_list % status ( nmergesub ) = MERGED mergesub_list % xh (:, nmergesub ) = x1 (:) mergesub_list % vh (:, nmergesub ) = v1 (:) - vbs (:) mergesub_list % mass ( nmergesub ) = mass1 mergesub_list % radius ( nmergesub ) = rad1 nmergesub = nmergesub + 1 mergesub_list % name ( nmergesub ) = name2 mergesub_list % status ( nmergesub ) = MERGED mergesub_list % xh (:, nmergesub ) = x2 (:) mergesub_list % vh (:, nmergesub ) = v2 (:) - vbs (:) mergesub_list % mass ( nmergesub ) = mass2 mergesub_list % radius ( nmergesub ) = rad2 nmergeadd = nmergeadd + 1 IF ( m2 > m1 ) THEN index_keep = index_big2 index_rm = index_big1 mergeadd_list % name ( nmergeadd ) = name2 mergeadd_list % status ( nmergeadd ) = stat2 ELSE index_keep = index_big1 index_rm = index_big2 mergeadd_list % name ( nmergeadd ) = name1 mergeadd_list % status ( nmergeadd ) = stat1 END IF mergeadd_list % ncomp ( nmergeadd ) = 2 mergeadd_list % xh (:, nmergeadd ) = xnew (:) mergeadd_list % vh (:, nmergeadd ) = vnew (:) - vbs (:) eold = 0.5_DP * ( m1 * DOT_PRODUCT ( v1 (:), v1 (:)) + m2 * DOT_PRODUCT ( v2 (:), v2 (:))) xr (:) = x2 (:) - x1 (:) eold = eold - m1 * m2 / SQRT ( DOT_PRODUCT ( xr (:), xr (:))) enew = 0.5_DP * mtot * DOT_PRODUCT ( vnew (:), vnew (:)) eoffset = eoffset + eold - enew !WRITE(*,*) \"symba_merge_pl.f90 name\", mergeadd_list%name(nmergeadd) !WRITE(*,*) \"symba_merge_pl.f90 xh\", mergeadd_list%xh(:,nmergeadd) !WRITE(*,*) \"symba_merge_pl.f90 vh\", mergeadd_list%vh(:,nmergeadd) !WRITE(*,*) \"symba_merge_pl.f90 eoffset\", eoffset DO k = 1 , nplplenc !go through the encounter list and for particles actively encoutering, get their children IF ( plplenc_list % status ( k ) == ACTIVE ) THEN DO i = 0 , symba_plA % nchild ( index1_parent ) IF ( i == 0 ) THEN index1_child = index1_parent ELSE index1_child = array_index1_child ( i ) END IF DO j = 0 , symba_plA % nchild ( index2_parent ) IF ( j == 0 ) THEN index2_child = index2_parent ELSE index2_child = array_index2_child ( j ) END IF IF (( index1_child == plplenc_list % index1 ( k )) . AND . ( index2_child == plplenc_list % index2 ( k ))) THEN plplenc_list % status ( k ) = MERGED ELSE IF (( index1_child == plplenc_list % index2 ( k )) . AND . ( index2_child == plplenc_list % index1 ( k ))) THEN plplenc_list % status ( k ) = MERGED END IF END DO END DO END IF END DO symba_plA % helio % swiftest % xh (:, index1_parent ) = xnew (:) symba_plA % helio % swiftest % vb (:, index1_parent ) = vnew (:) symba_plA % helio % swiftest % xh (:, index2_parent ) = xnew (:) symba_plA % helio % swiftest % vb (:, index2_parent ) = vnew (:) array_keep_child ( 1 : npl ) = symba_plA % index_child ( 1 : npl , index1_parent ) DO i = 1 , symba_plA % nchild ( index1_parent ) indexchild = array_keep_child ( i ) symba_plA % helio % swiftest % xh (:, indexchild ) = xnew (:) symba_plA % helio % swiftest % vb (:, indexchild ) = vnew (:) END DO symba_plA % index_child (( symba_plA % nchild ( index1_parent ) + 1 ), index1_parent ) = index2_parent array_rm_child ( 1 : npl ) = symba_plA % index_child ( 1 : npl , index2_parent ) symba_plA % index_parent ( index2 ) = index1_parent DO i = 1 , symba_plA % nchild ( index2_parent ) symba_plA % index_parent ( array_rm_child ( i )) = index1_parent indexchild = array_rm_child ( i ) symba_plA % helio % swiftest % xh (:, indexchild ) = xnew (:) symba_plA % helio % swiftest % vb (:, indexchild ) = vnew (:) END DO DO i = 1 , symba_plA % nchild ( index2_parent ) symba_plA % index_child ( symba_plA % nchild ( index1_parent ) + i + 1 , index1_parent ) = array_rm_child ( i ) END DO symba_plA % nchild ( index1_parent ) = symba_plA % nchild ( index1_parent ) + symba_plA % nchild ( index2_parent ) + 1 END IF RETURN END SUBROUTINE symba_merge_pl !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_merge_pl.f90.html"},{"title":"symba_caseresolve.f90 – swiftest","text":"Unit Name   : symba_caseresolve\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Merge planets Input\n    Arguments : t            : time\n                npl          : number of planets\n                nsppl        : number of spilled planets\n                symba_pl1P   : pointer to head of SyMBA planet structure linked-list\n                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list\n                nplplenc     : number of planet-planet encounters\n                plplenc_list : array of planet-planet encounter structures\n    Terminal  : none\n    File      : none Output\n    Arguments : npl          : number of planets\n                nsppl        : number of spilled planets\n                symba_pl1P   : pointer to head of SyMBA planet structure linked-list\n                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL symba_caseresolve(t, npl, nsppl, symba_pl1P, symba_pld1P, nplplenc, plplenc_list) Notes       : Adapted from Hal Levison's Swift routine discard_mass_merge.f This file depends on sourcefile~~symba_caseresolve.f90~~EfferentGraph sourcefile~symba_caseresolve.f90 symba_caseresolve.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_caseresolve.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_caseresolve.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_caseresolve.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_caseresolve.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_caseresolve.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_caseresolve Source Code symba_caseresolve.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_caseresolve !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Merge planets ! !  Input !    Arguments : t            : time !                npl          : number of planets !                nsppl        : number of spilled planets !                symba_pl1P   : pointer to head of SyMBA planet structure linked-list !                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list !                nplplenc     : number of planet-planet encounters !                plplenc_list : array of planet-planet encounter structures !    Terminal  : none !    File      : none ! !  Output !    Arguments : npl          : number of planets !                nsppl        : number of spilled planets !                symba_pl1P   : pointer to head of SyMBA planet structure linked-list !                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_caseresolve(t, npl, nsppl, symba_pl1P, symba_pld1P, nplplenc, plplenc_list) ! !  Notes       : Adapted from Hal Levison's Swift routine discard_mass_merge.f ! !********************************************************************************************************************************** SUBROUTINE symba_caseresolve ( t , dt , index_enc , nmergeadd , nmergesub , mergeadd_list , mergesub_list , eoffset , vbs , & encounter_file , out_type , npl , ntp , symba_plA , symba_tpA , nplplenc , npltpenc , pltpenc_list , plplenc_list , regime , & nplmax , ntpmax , fragmax , mres , rres , array_index1_child , array_index2_child , m1 , m2 , rad1 , rad2 , x1 , x2 , v1 , v2 ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_caseresolve IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: index_enc , nplmax , ntpmax INTEGER ( I4B ), INTENT ( INOUT ) :: npl , ntp , nmergeadd , nmergesub , nplplenc , npltpenc , fragmax REAL ( DP ), INTENT ( IN ) :: t , dt REAL ( DP ), INTENT ( INOUT ) :: eoffset , m1 , m2 , rad1 , rad2 REAL ( DP ), DIMENSION ( 3 ), INTENT ( INOUT ) :: mres , rres REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: vbs REAL ( DP ), DIMENSION ( NDIM ), INTENT ( INOUT ) :: x1 , x2 , v1 , v2 CHARACTER ( * ), INTENT ( IN ) :: encounter_file , out_type TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list TYPE ( symba_pltpenc ), INTENT ( INOUT ) :: pltpenc_list TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA INTEGER ( I4B ), INTENT ( IN ) :: regime INTEGER ( I4B ), DIMENSION ( npl ), INTENT ( INOUT ) :: array_index1_child , array_index2_child ! Internals ! Executable code SELECT CASE ( regime ) CASE ( COLLRESOLVE_REGIME_DISRUPTION ) CALL symba_casedisruption ( t , dt , index_enc , nmergeadd , nmergesub , mergeadd_list , mergesub_list , eoffset , vbs , & symba_plA , nplplenc , plplenc_list , nplmax , ntpmax , fragmax , mres , rres , m1 , m2 , rad1 , rad2 , x1 , x2 , v1 , v2 ) CASE ( COLLRESOLVE_REGIME_SUPERCATASTROPHIC ) CALL symba_casesupercatastrophic ( t , dt , index_enc , nmergeadd , nmergesub , mergeadd_list , mergesub_list , & eoffset , vbs , symba_plA , nplplenc , & plplenc_list , nplmax , ntpmax , fragmax , mres , rres , m1 , m2 , rad1 , & rad2 , x1 , x2 , v1 , v2 ) CASE ( COLLRESOLVE_REGIME_GRAZE_AND_MERGE ) CALL symba_casemerge ( t , dt , index_enc , nmergeadd , nmergesub , mergeadd_list , mergesub_list , eoffset , vbs , & encounter_file , out_type , npl , ntp , symba_plA , symba_tpA , nplplenc , npltpenc , pltpenc_list , plplenc_list , & array_index1_child , array_index2_child , m1 , m2 , rad1 , rad2 , x1 , x2 , v1 , v2 ) CASE ( COLLRESOLVE_REGIME_HIT_AND_RUN ) CALL symba_casehitandrun ( t , index_enc , nmergeadd , nmergesub , mergeadd_list , mergesub_list , eoffset , vbs , & symba_plA , nplplenc , plplenc_list , & nplmax , ntpmax , fragmax , mres , rres , m1 , m2 , rad1 , rad2 , x1 , x2 , v1 , v2 ) CASE ( COLLRESOLVE_REGIME_MERGE ) CALL symba_casemerge ( t , dt , index_enc , nmergeadd , nmergesub , mergeadd_list , mergesub_list , eoffset , vbs , & encounter_file , out_type , npl , ntp , symba_plA , symba_tpA , nplplenc , npltpenc , pltpenc_list , plplenc_list , & array_index1_child , array_index2_child , m1 , m2 , rad1 , rad2 , x1 , x2 , v1 , v2 ) CASE DEFAULT WRITE ( * , * ) \"ERROR IN SYMBA_CASERESOLVE, NO REGIME SELECTED\" END SELECT RETURN END SUBROUTINE symba_caseresolve","tags":"","loc":"sourcefile/symba_caseresolve.f90.html"},{"title":"symba_helio_getacch_int.f90 – swiftest","text":"Unit Name   : symba_helio_getacch_int\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Compute direct cross term heliocentric accelerations of planets Input\n    Arguments : npl        : number of planets\n                nplm       : number of planets with mass > mtiny\n                helio_pl1P : pointer to head of helio planet structure linked-list\n    Terminal  : none\n    File      : none Output\n    Arguments : helio_pl1P : pointer to head of helio planet structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL symba_helio_getacch_int(npl, nplm, helio_pl1P) Notes       : Adapted from Hal Levison's Swift routine symba5_helio_getacch.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_helio_getacch_int.f90~~EfferentGraph sourcefile~symba_helio_getacch_int.f90 symba_helio_getacch_int.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_helio_getacch_int.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_helio_getacch_int.f90->sourcefile~module_interfaces.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_helio_getacch_int.f90->sourcefile~module_symba.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_helio_getacch_int.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_helio_getacch_int Source Code symba_helio_getacch_int.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_helio_getacch_int !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Compute direct cross term heliocentric accelerations of planets ! !  Input !    Arguments : npl        : number of planets !                nplm       : number of planets with mass > mtiny !                helio_pl1P : pointer to head of helio planet structure linked-list !    Terminal  : none !    File      : none ! !  Output !    Arguments : helio_pl1P : pointer to head of helio planet structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_helio_getacch_int(npl, nplm, helio_pl1P) ! !  Notes       : Adapted from Hal Levison's Swift routine symba5_helio_getacch.f ! !********************************************************************************************************************************** SUBROUTINE symba_helio_getacch_int ( npl , nplm , helio_plA ) ! Modules USE swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_helio_getacch_int IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: npl , nplm TYPE ( helio_pl ), INTENT ( INOUT ) :: helio_plA ! Internals INTEGER ( I4B ) :: i , j REAL ( DP ) :: rji2 , irij3 , faci , facj REAL ( DP ), DIMENSION ( NDIM ) :: dx ! Executable code DO i = 2 , nplm DO j = i + 1 , npl dx (:) = helio_plA % swiftest % xh (:, j ) - helio_plA % swiftest % xh (:, i ) rji2 = DOT_PRODUCT ( dx (:), dx (:)) irij3 = 1.0_DP / ( rji2 * SQRT ( rji2 )) faci = helio_plA % swiftest % mass ( i ) * irij3 facj = helio_plA % swiftest % mass ( j ) * irij3 helio_plA % ahi (:, i ) = helio_plA % ahi (:, i ) + facj * dx (:) helio_plA % ahi (:, j ) = helio_plA % ahi (:, j ) - faci * dx (:) END DO END DO RETURN END SUBROUTINE symba_helio_getacch_int !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_helio_getacch_int.f90.html"},{"title":"symba_getacch.f90 – swiftest","text":"Unit Name   : symba_getacch\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Compute heliocentric accelerations of planets Input\n    Arguments : lextra_force : logical flag indicating whether to include user-supplied accelerations\n                t            : time\n                npl          : number of planets\n                nplm         : number of planets with mass > mtiny\n                nplmax       : maximum allowed number of planets\n                symba_pl1P   : pointer to head of SyMBA planet structure linked-list\n                j2rp2        : J2 * R 2 for the Sun\n                j4rp4        : J4 * R 4 for the Sun\n                nplplenc     : number of planet-planet encounters\n                plplenc_list : array of planet-test particle encounter structures\n    Terminal  : none\n    File      : none Output\n    Arguments : symba_pl1P   : pointer to head of SyMBA planet structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL symba_getacch(lextra_force, t, npl, nplm, nplmax, symba_pl1P, j2rp2, j4rp4, nplplenc, plplenc_list) Notes       : Adapted from Hal Levison's Swift routine symba5_getacch.f Accelerations in an encounter are not included here Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_getacch.f90~~EfferentGraph sourcefile~symba_getacch.f90 symba_getacch.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_getacch.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_getacch.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_getacch.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_getacch.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_getacch.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_getacch Source Code symba_getacch.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_getacch !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Compute heliocentric accelerations of planets ! !  Input !    Arguments : lextra_force : logical flag indicating whether to include user-supplied accelerations !                t            : time !                npl          : number of planets !                nplm         : number of planets with mass > mtiny !                nplmax       : maximum allowed number of planets !                symba_pl1P   : pointer to head of SyMBA planet structure linked-list !                j2rp2        : J2 * R**2 for the Sun !                j4rp4        : J4 * R**4 for the Sun !                nplplenc     : number of planet-planet encounters !                plplenc_list : array of planet-test particle encounter structures !    Terminal  : none !    File      : none ! !  Output !    Arguments : symba_pl1P   : pointer to head of SyMBA planet structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_getacch(lextra_force, t, npl, nplm, nplmax, symba_pl1P, j2rp2, j4rp4, nplplenc, plplenc_list) ! !  Notes       : Adapted from Hal Levison's Swift routine symba5_getacch.f ! !                Accelerations in an encounter are not included here ! !********************************************************************************************************************************** SUBROUTINE symba_getacch ( lextra_force , t , npl , nplm , symba_plA , j2rp2 , j4rp4 , nplplenc , plplenc_list ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_getacch IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( IN ) :: lextra_force INTEGER ( I4B ), INTENT ( IN ) :: npl , nplm , nplplenc REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list ! Internals INTEGER ( I4B ) :: i , j , index_i , index_j REAL ( DP ) :: rji2 , irij3 , faci , facj , r2 REAL ( DP ), DIMENSION ( NDIM ) :: dx REAL ( DP ), DIMENSION ( npl ) :: irh REAL ( DP ), DIMENSION ( NDIM , npl ) :: aobl ! Executable code DO i = 2 , npl symba_plA % helio % ah (:, i ) = ( / 0.0_DP , 0.0_DP , 0.0_DP / ) END DO DO i = 2 , nplm DO j = i + 1 , npl IF ((. NOT . symba_plA % lmerged ( i )) . OR . (. NOT . symba_plA % lmerged ( j )) . OR . & ( symba_plA % index_parent ( i ) /= symba_plA % index_parent ( j ))) THEN dx (:) = symba_plA % helio % swiftest % xh (:, j ) - symba_plA % helio % swiftest % xh (:, i ) rji2 = DOT_PRODUCT ( dx (:), dx (:)) irij3 = 1.0_DP / ( rji2 * SQRT ( rji2 )) IF ( irij3 . NE . irij3 ) then WRITE ( * , * ) \"dx==0 for pl: \" , i , \"name:\" , symba_plA % helio % swiftest % name ( i ), & \"and pl:\" , j , \"name:\" , symba_plA % helio % swiftest % name ( j ) WRITE ( * , * ) \"dx==0 for pl: \" , i , \"xh:\" , symba_plA % helio % swiftest % xh ( 1 , i ), & \"and pl:\" , j , \"xh:\" , symba_plA % helio % swiftest % xh ( 1 , j ) WRITE ( * , * ) \"parent pl 1:\" , symba_plA % helio % swiftest % name ( symba_plA % index_parent ( i )) WRITE ( * , * ) \"parent pl 2:\" , symba_plA % helio % swiftest % name ( symba_plA % index_parent ( j )) STOP END IF faci = symba_plA % helio % swiftest % mass ( i ) * irij3 facj = symba_plA % helio % swiftest % mass ( j ) * irij3 symba_plA % helio % ah (:, i ) = symba_plA % helio % ah (:, i ) + facj * dx (:) symba_plA % helio % ah (:, j ) = symba_plA % helio % ah (:, j ) - faci * dx (:) END IF END DO END DO DO i = 1 , nplplenc index_i = plplenc_list % index1 ( i ) index_j = plplenc_list % index2 ( i ) IF ((. NOT . symba_plA % lmerged ( index_i )) . OR . (. NOT . symba_plA % lmerged ( index_j )) & . OR . ( symba_plA % index_parent ( index_i ) /= symba_plA % index_parent ( index_j ))) THEN !need to update parent/children dx (:) = symba_plA % helio % swiftest % xh (:, index_j ) - symba_plA % helio % swiftest % xh (:, index_i ) rji2 = DOT_PRODUCT ( dx (:), dx (:)) irij3 = 1.0_DP / ( rji2 * SQRT ( rji2 )) IF ( irij3 . NE . irij3 ) then WRITE ( * , * ) \"dx==0 for pl: \" , i , \"name:\" , symba_plA % helio % swiftest % name ( i ), & \"and pl:\" , j , \"name:\" , symba_plA % helio % swiftest % name ( j ) WRITE ( * , * ) \"dx==0 for pl: \" , i , \"xh:\" , symba_plA % helio % swiftest % xh ( 1 , i ), & \"and pl:\" , j , \"xh:\" , symba_plA % helio % swiftest % xh ( 1 , j ) WRITE ( * , * ) \"parent pl 1:\" , symba_plA % helio % swiftest % name ( symba_plA % index_parent ( i )) WRITE ( * , * ) \"parent pl 2:\" , symba_plA % helio % swiftest % name ( symba_plA % index_parent ( j )) STOP END IF faci = symba_plA % helio % swiftest % mass ( index_i ) * irij3 facj = symba_plA % helio % swiftest % mass ( index_j ) * irij3 symba_plA % helio % ah (:, index_i ) = symba_plA % helio % ah (:, index_i ) - facj * dx (:) symba_plA % helio % ah (:, index_j ) = symba_plA % helio % ah (:, index_j ) + faci * dx (:) END IF END DO IF ( j2rp2 /= 0.0_DP ) THEN !IF (lmalloc) THEN !ALLOCATE(xh(NDIM, npl),aobl(NDIM, npl), irh(npl)) !lmalloc = .FALSE. !END IF DO i = 2 , npl r2 = DOT_PRODUCT ( symba_plA % helio % swiftest % xh (:, i ), symba_plA % helio % swiftest % xh (:, i )) irh ( i ) = 1.0_DP / SQRT ( r2 ) END DO CALL obl_acc ( npl , symba_plA % helio % swiftest , j2rp2 , j4rp4 , symba_plA % helio % swiftest % xh (:,:), irh , aobl ) DO i = 2 , npl symba_plA % helio % ah (:, i ) = symba_plA % helio % ah (:, i ) + aobl (:, i ) - aobl (:, 1 ) END DO END IF IF ( lextra_force ) CALL symba_user_getacch ( t , npl , symba_plA ) RETURN END SUBROUTINE symba_getacch !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_getacch.f90.html"},{"title":"symba_discard_tp.f90 – swiftest","text":"Unit Name   : symba_discard_tp\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Call discard routine to determine spilled test particles, then remove them from active list Input\n    Arguments : t              : time\n                npl            : number of planets\n                ntp            : number of active test particles\n                nsp            : number of spilled test particles\n                symba_pl1P     : pointer to head of SyMBA planet structure linked-list\n                symba_tp1P     : pointer to head of active SyMBA test particle structure linked-list\n                symba_tpd1P    : pointer to head of discard SyMBA test particle structure linked-list\n                dt             : time step\n                rmin           : minimum allowed heliocentric radius for test particles\n                rmax           : maximum allowed heliocentric radius for test particles\n                rmaxu          : maximum allowed heliocentric radius for unbound test particles\n                qmin           : minimum allowed pericenter distance for test particles\n                qmin_coord     : coordinate frame for qmin\n                qmin_alo       : minimum semimajor axis for qmin\n                qmin_ahi       : maximum semimajor axis for qmin\n                lclose         : logical flag indicating whether to check for close planet-test particle encounters\n                lrhill_present : logical flag indicating whether Hill sphere radii for planets are present\n    Terminal  : none\n    File      : none Output\n    Arguments : ntp            : number of active test particles\n                nsp            : number of spilled test particles\n                symba_tp1P     : pointer to head of active SyMBA test particle structure linked-list\n                symba_tpd1P    : pointer to head of discard SyMBA test particle structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL symba_discard_tp(t, npl, ntp, nsp, symba_pl1P, symba_tp1P, symba_tpd1P, dt, rmin, rmax, rmaxu, qmin,\n                                      qmin_coord, qmin_alo, qmin_ahi, lclose, lrhill_present) Notes       : Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_discard_tp.f90~~EfferentGraph sourcefile~symba_discard_tp.f90 symba_discard_tp.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_discard_tp.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_discard_tp.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_discard_tp.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_discard_tp.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_discard_tp.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_discard_tp Source Code symba_discard_tp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_discard_tp !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Call discard routine to determine spilled test particles, then remove them from active list ! !  Input !    Arguments : t              : time !                npl            : number of planets !                ntp            : number of active test particles !                nsp            : number of spilled test particles !                symba_pl1P     : pointer to head of SyMBA planet structure linked-list !                symba_tp1P     : pointer to head of active SyMBA test particle structure linked-list !                symba_tpd1P    : pointer to head of discard SyMBA test particle structure linked-list !                dt             : time step !                rmin           : minimum allowed heliocentric radius for test particles !                rmax           : maximum allowed heliocentric radius for test particles !                rmaxu          : maximum allowed heliocentric radius for unbound test particles !                qmin           : minimum allowed pericenter distance for test particles !                qmin_coord     : coordinate frame for qmin !                qmin_alo       : minimum semimajor axis for qmin !                qmin_ahi       : maximum semimajor axis for qmin !                lclose         : logical flag indicating whether to check for close planet-test particle encounters !                lrhill_present : logical flag indicating whether Hill sphere radii for planets are present !    Terminal  : none !    File      : none ! !  Output !    Arguments : ntp            : number of active test particles !                nsp            : number of spilled test particles !                symba_tp1P     : pointer to head of active SyMBA test particle structure linked-list !                symba_tpd1P    : pointer to head of discard SyMBA test particle structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_discard_tp(t, npl, ntp, nsp, symba_pl1P, symba_tp1P, symba_tpd1P, dt, rmin, rmax, rmaxu, qmin, !                                      qmin_coord, qmin_alo, qmin_ahi, lclose, lrhill_present) ! !  Notes       : ! !********************************************************************************************************************************** SUBROUTINE symba_discard_tp ( t , npl , ntp , nsp , symba_plA , symba_tpA , dt , rmin , rmax , rmaxu , qmin , qmin_coord , & qmin_alo , qmin_ahi , lclose , lrhill_present ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_discard_tp IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( IN ) :: lclose , lrhill_present INTEGER ( I4B ), INTENT ( IN ) :: npl INTEGER ( I4B ), INTENT ( INOUT ) :: ntp , nsp REAL ( DP ), INTENT ( IN ) :: t , dt , rmin , rmax , rmaxu , qmin , qmin_alo , qmin_ahi CHARACTER ( * ), INTENT ( IN ) :: qmin_coord TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA ! Internals LOGICAL ( LGT ) :: lclosel = . FALSE . INTEGER ( I4B ) :: i ! Executable code CALL discard ( t , dt , npl , ntp , symba_plA % helio % swiftest , symba_tpA % helio % swiftest , rmin , rmax , rmaxu , qmin , & qmin_alo , qmin_ahi , qmin_coord , lclosel , & lrhill_present ) RETURN END SUBROUTINE symba_discard_tp !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_discard_tp.f90.html"},{"title":"symba_step_interp.f90 – swiftest","text":"Unit Name   : symba_step_interp\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Step planets and active test particles ahead in democratic heliocentric coordinates, calling the recursive\n                subroutine to descend to the appropriate level to handle close encounters Input\n    Arguments : lextra_force   : logical flag indicating whether to include user-supplied accelerations\n                lclose         : logical flag indicating whether to check for mergers\n                t              : time\n                npl            : number of planets\n                nplm           : number of planets with mass > mtiny\n                nplmax         : maximum allowed number of planets\n                ntp            : number of active test particles\n                ntpmax         : maximum allowed number of test particles\n                symba_pl1P     : pointer to head of SyMBA planet structure linked-list\n                symba_tp1P     : pointer to head of active SyMBA test particle structure linked-list\n                j2rp2          : J2 * R 2 for the Sun\n                j4rp4          : J4 * R 4 for the Sun\n                dt             : time step\n                eoffset        : energy offset (net energy lost in mergers)\n                mtiny          : smallest self-gravitating mass\n                nplplenc       : number of planet-planet encounters\n                npltpenc       : number of planet-test particle encounters\n                plplenc_list   : array of planet-planet encounter structures\n                pltpenc_list   : array of planet-test particle encounter structures\n                nmergeadd      : number of merged planets to add\n                nmergesub      : number of merged planets to subtract\n                mergeadd_list  : array of structures of merged planets to add\n                mergesub_list  : array of structures of merged planets to subtract\n                encounter_file : name of output file for encounters\n                out_type       : binary format of output file\n    Terminal  : none\n    File      : none Output\n    Arguments : symba_pl1P     : pointer to head of SyMBA planet structure linked-list\n                symba_tp1P     : pointer to head of active SyMBA test particle structure linked-list\n                eoffset        : energy offset (net energy lost in mergers)\n                plplenc_list   : array of planet-planet encounter structures\n                pltpenc_list   : array of planet-test particle encounter structures\n                nmergeadd      : number of merged planets to add\n                nmergesub      : number of merged planets to subtract\n                mergeadd_list  : array of structures of merged planets to add\n                mergesub_list  : array of structures of merged planets to subtract\n    Terminal  : none\n    File      : none Invocation  : CALL symba_step_interp(lextra_force, lclose, t, npl, nplm, nplmax, ntp, ntpmax, symba_pl1P, symba_tp1P, j2rp2,\n                                       j4rp4, dt, eoffset, mtiny, nplplenc, npltpenc, plplenc_list, pltpenc_list, nmergeadd,\n                                       nmergesub, mergeadd_list, mergesub_list, encounter_file, out_type) Notes       : Adapted from Hal Levison's Swift routine symba5_step_interp.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_step_interp.f90~~EfferentGraph sourcefile~symba_step_interp.f90 symba_step_interp.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_step_interp.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_step_interp.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_step_interp.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_step_interp.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_step_interp.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_step_interp Source Code symba_step_interp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_step_interp !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Step planets and active test particles ahead in democratic heliocentric coordinates, calling the recursive !                subroutine to descend to the appropriate level to handle close encounters ! !  Input !    Arguments : lextra_force   : logical flag indicating whether to include user-supplied accelerations !                lclose         : logical flag indicating whether to check for mergers !                t              : time !                npl            : number of planets !                nplm           : number of planets with mass > mtiny !                nplmax         : maximum allowed number of planets !                ntp            : number of active test particles !                ntpmax         : maximum allowed number of test particles !                symba_pl1P     : pointer to head of SyMBA planet structure linked-list !                symba_tp1P     : pointer to head of active SyMBA test particle structure linked-list !                j2rp2          : J2 * R**2 for the Sun !                j4rp4          : J4 * R**4 for the Sun !                dt             : time step !                eoffset        : energy offset (net energy lost in mergers) !                mtiny          : smallest self-gravitating mass !                nplplenc       : number of planet-planet encounters !                npltpenc       : number of planet-test particle encounters !                plplenc_list   : array of planet-planet encounter structures !                pltpenc_list   : array of planet-test particle encounter structures !                nmergeadd      : number of merged planets to add !                nmergesub      : number of merged planets to subtract !                mergeadd_list  : array of structures of merged planets to add !                mergesub_list  : array of structures of merged planets to subtract !                encounter_file : name of output file for encounters !                out_type       : binary format of output file !    Terminal  : none !    File      : none ! !  Output !    Arguments : symba_pl1P     : pointer to head of SyMBA planet structure linked-list !                symba_tp1P     : pointer to head of active SyMBA test particle structure linked-list !                eoffset        : energy offset (net energy lost in mergers) !                plplenc_list   : array of planet-planet encounter structures !                pltpenc_list   : array of planet-test particle encounter structures !                nmergeadd      : number of merged planets to add !                nmergesub      : number of merged planets to subtract !                mergeadd_list  : array of structures of merged planets to add !                mergesub_list  : array of structures of merged planets to subtract !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_step_interp(lextra_force, lclose, t, npl, nplm, nplmax, ntp, ntpmax, symba_pl1P, symba_tp1P, j2rp2, !                                       j4rp4, dt, eoffset, mtiny, nplplenc, npltpenc, plplenc_list, pltpenc_list, nmergeadd, !                                       nmergesub, mergeadd_list, mergesub_list, encounter_file, out_type) ! !  Notes       : Adapted from Hal Levison's Swift routine symba5_step_interp.f ! !********************************************************************************************************************************** SUBROUTINE symba_step_interp ( lextra_force , lclose , t , npl , nplm , nplmax , ntp , ntpmax , symba_plA , symba_tpA , j2rp2 , j4rp4 , dt , & eoffset , nplplenc , npltpenc , plplenc_list , pltpenc_list , nmergeadd , nmergesub , mergeadd_list , mergesub_list , & encounter_file , out_type , fragmax , feature ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_step_interp IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( IN ) :: lextra_force , lclose INTEGER ( I4B ), INTENT ( IN ) :: npl , nplm , nplmax , ntp , ntpmax , nplplenc , npltpenc INTEGER ( I4B ), INTENT ( INOUT ) :: nmergeadd , nmergesub , fragmax REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 , dt REAL ( DP ), INTENT ( INOUT ) :: eoffset CHARACTER ( * ), INTENT ( IN ) :: encounter_file , out_type TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list TYPE ( symba_pltpenc ), INTENT ( INOUT ) :: pltpenc_list TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list type ( feature_list ), intent ( in ) :: feature ! Internals LOGICAL ( LGT ), SAVE :: lmalloc = . TRUE . INTEGER ( I4B ) :: i , irec REAL ( DP ) :: dth , msys REAL ( DP ), DIMENSION ( NDIM ) :: ptb , pte REAL ( DP ), DIMENSION (:, :), ALLOCATABLE , SAVE :: xbeg , xend ! Executable code IF ( lmalloc ) THEN ALLOCATE ( xbeg ( NDIM , nplmax ), xend ( NDIM , nplmax )) lmalloc = . FALSE . END IF dth = 0.5_DP * dt CALL coord_vh2vb ( npl , symba_plA % helio % swiftest , msys ) CALL helio_lindrift ( npl , symba_plA % helio % swiftest , dth , ptb ) IF ( ntp > 0 ) THEN CALL coord_vh2vb_tp ( ntp , symba_tpA % helio % swiftest , - ptb ) CALL helio_lindrift_tp ( ntp , symba_tpA % helio % swiftest , dth , ptb ) DO i = 2 , npl xbeg (:, i ) = symba_plA % helio % swiftest % xh (:, i ) END DO END IF CALL symba_getacch ( lextra_force , t , npl , nplm , symba_plA , j2rp2 , j4rp4 , nplplenc , plplenc_list ) IF ( ntp > 0 ) CALL symba_getacch_tp ( lextra_force , t , npl , nplm , nplmax , ntp , ntpmax , symba_plA , symba_tpA , xbeg , j2rp2 , & j4rp4 , npltpenc , pltpenc_list ) CALL helio_kickvb ( npl , symba_plA % helio , dth ) IF ( ntp > 0 ) CALL helio_kickvb_tp ( ntp , symba_tpA % helio , dth ) irec = - 1 CALL symba_helio_drift ( irec , npl , symba_plA , dt ) IF ( ntp > 0 ) CALL symba_helio_drift_tp ( irec , ntp , symba_tpA , symba_plA % helio % swiftest % mass ( 1 ), dt ) irec = 0 CALL symba_step_recur ( lclose , t , irec , npl , nplm , ntp , symba_plA , symba_tpA , dt , eoffset , nplplenc , npltpenc , & plplenc_list , pltpenc_list , nmergeadd , nmergesub , mergeadd_list , mergesub_list , encounter_file , out_type , & nplmax , ntpmax , fragmax , feature ) IF ( ntp > 0 ) THEN DO i = 2 , npl xend (:, i ) = symba_plA % helio % swiftest % xh (:, i ) END DO END IF CALL symba_getacch ( lextra_force , t + dt , npl , nplm , symba_plA , j2rp2 , j4rp4 , nplplenc , plplenc_list ) IF ( ntp > 0 ) CALL symba_getacch_tp ( lextra_force , t + dt , npl , nplm , nplmax , ntp , ntpmax , symba_plA , symba_tpA , xend , j2rp2 , & j4rp4 , npltpenc , pltpenc_list ) CALL helio_kickvb ( npl , symba_plA % helio , dth ) IF ( ntp > 0 ) CALL helio_kickvb_tp ( ntp , symba_tpA % helio , dth ) CALL coord_vb2vh ( npl , symba_plA % helio % swiftest ) CALL helio_lindrift ( npl , symba_plA % helio % swiftest , dth , pte ) IF ( ntp > 0 ) THEN CALL coord_vb2vh_tp ( ntp , symba_tpA % helio % swiftest , - pte ) CALL helio_lindrift_tp ( ntp , symba_tpA % helio % swiftest , dth , pte ) END IF RETURN END SUBROUTINE symba_step_interp !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_step_interp.f90.html"},{"title":"symba_discard_merge_pl.f90 – swiftest","text":"Unit Name   : symba_discard_merge_pl\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Merge planets Input\n    Arguments : t            : time\n                npl          : number of planets\n                nsppl        : number of spilled planets\n                symba_pl1P   : pointer to head of SyMBA planet structure linked-list\n                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list\n                nplplenc     : number of planet-planet encounters\n                plplenc_list : array of planet-planet encounter structures\n    Terminal  : none\n    File      : none Output\n    Arguments : npl          : number of planets\n                nsppl        : number of spilled planets\n                symba_pl1P   : pointer to head of SyMBA planet structure linked-list\n                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL symba_discard_merge_pl(t, npl, nsppl, symba_pl1P, symba_pld1P, nplplenc, plplenc_list) Notes       : Adapted from Hal Levison's Swift routine discard_mass_merge.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_discard_merge_pl.f90~~EfferentGraph sourcefile~symba_discard_merge_pl.f90 symba_discard_merge_pl.f90 sourcefile~module_swifter.f90 module_swifter.f90 sourcefile~symba_discard_merge_pl.f90->sourcefile~module_swifter.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_discard_merge_pl.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_discard_merge_pl.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_discard_merge_pl.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_discard_merge_pl.f90->sourcefile~swiftest.f90 sourcefile~module_swifter.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_discard_merge_pl Source Code symba_discard_merge_pl.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_discard_merge_pl !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Merge planets ! !  Input !    Arguments : t            : time !                npl          : number of planets !                nsppl        : number of spilled planets !                symba_pl1P   : pointer to head of SyMBA planet structure linked-list !                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list !                nplplenc     : number of planet-planet encounters !                plplenc_list : array of planet-planet encounter structures !    Terminal  : none !    File      : none ! !  Output !    Arguments : npl          : number of planets !                nsppl        : number of spilled planets !                symba_pl1P   : pointer to head of SyMBA planet structure linked-list !                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_discard_merge_pl(t, npl, nsppl, symba_pl1P, symba_pld1P, nplplenc, plplenc_list) ! !  Notes       : Adapted from Hal Levison's Swift routine discard_mass_merge.f ! !********************************************************************************************************************************** SUBROUTINE symba_discard_merge_pl ( t , npl , symba_plA , nplplenc , plplenc_list ) ! Modules USE swiftest USE module_swifter USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_discard_merge_pl IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: nplplenc INTEGER ( I4B ), INTENT ( INOUT ) :: npl REAL ( DP ), INTENT ( IN ) :: t TYPE ( symba_pl ) :: symba_plA TYPE ( symba_plplenc ), INTENT ( IN ) :: plplenc_list ! Internals INTEGER ( I4B ) :: i , j , nchild , indexchild , enc_big , index1 , index2 , indexk REAL ( DP ) :: m , mmax , mtot , r , r3 , mu , energy , ap , v2 , msun REAL ( DP ), DIMENSION ( NDIM ) :: x , v , vbs INTEGER ( I4B ), DIMENSION ( npl ) :: array_child ! Executable code msun = symba_plA % helio % swiftest % mass ( 1 ) vbs (:) = symba_plA % helio % swiftest % vb (:, 1 ) DO i = 1 , nplplenc IF ( plplenc_list % status ( i ) == MERGED ) THEN index1 = plplenc_list % index1 ( i ) index2 = plplenc_list % index2 ( i ) ! This IF statement is for if lfragmentation = FALSE IF (( symba_plA % helio % swiftest % status ( index1 ) == ACTIVE ) . AND . & ( symba_plA % helio % swiftest % status ( index2 ) == ACTIVE )) THEN enc_big = plplenc_list % index1 ( i ) m = symba_plA % helio % swiftest % mass ( enc_big ) r = symba_plA % helio % swiftest % radius ( enc_big ) r3 = r ** 3 mmax = m mtot = m x (:) = m * symba_plA % helio % swiftest % xh (:, enc_big ) v (:) = m * symba_plA % helio % swiftest % vb (:, enc_big ) indexk = enc_big nchild = symba_plA % nchild ( enc_big ) array_child ( 1 : npl ) = symba_plA % index_child ( 1 : npl , enc_big ) DO j = 1 , nchild indexchild = array_child ( j ) m = symba_plA % helio % swiftest % mass ( indexchild ) r = symba_plA % helio % swiftest % radius ( indexchild ) r3 = r3 + r ** 3 mtot = mtot + m x (:) = x (:) + m * symba_plA % helio % swiftest % xh (:, indexchild ) v (:) = v (:) + m * symba_plA % helio % swiftest % vb (:, indexchild ) IF ( m > mmax ) THEN mmax = m indexk = indexchild END IF END DO x (:) = x (:) / mtot v (:) = v (:) / mtot r = r3 ** ( 1.0_DP / 3.0_DP ) symba_plA % helio % swiftest % mass ( indexk ) = mtot symba_plA % helio % swiftest % radius ( indexk ) = r symba_plA % helio % swiftest % xh (:, indexk ) = x (:) symba_plA % helio % swiftest % vb (:, indexk ) = v (:) symba_plA % helio % swiftest % vh (:, indexk ) = v (:) - vbs (:) mu = msun * mtot / ( msun + mtot ) r = SQRT ( DOT_PRODUCT ( x (:), x (:))) v (:) = symba_plA % helio % swiftest % vh (:, indexk ) v2 = DOT_PRODUCT ( v (:), v (:)) energy = - 1.0_DP * msun * mtot / r + 0.5_DP * mu * v2 ap = - 1.0_DP * msun * mtot / ( 2.0_DP * energy ) symba_plA % helio % swiftest % rhill ( indexk ) = ap * ((( mu / msun ) / 3.0_DP ) ** ( 1.0_DP / 3.0_DP )) array_child ( 1 : npl ) = symba_plA % index_child ( 1 : npl , enc_big ) indexchild = enc_big ldiscard = . TRUE . DO j = 0 , nchild IF ( indexchild /= indexk ) THEN symba_plA % helio % swiftest % status ( indexchild ) = MERGED END IF indexchild = array_child ( j + 1 ) END DO ELSE IF (( symba_plA % helio % swiftest % status ( index1 ) == DISRUPTION ) . AND . & ( symba_plA % helio % swiftest % status ( index2 ) == DISRUPTION )) THEN enc_big = plplenc_list % index1 ( i ) nchild = symba_plA % nchild ( enc_big ) array_child ( 1 : npl ) = symba_plA % index_child ( 1 : npl , enc_big ) DO j = 1 , nchild symba_plA % helio % swiftest % status ( array_child ( j )) = INACTIVE END DO ldiscard = . TRUE . ELSE IF (( symba_plA % helio % swiftest % status ( index1 ) == SUPERCATASTROPHIC ) . AND . & ( symba_plA % helio % swiftest % status ( index2 ) == SUPERCATASTROPHIC )) THEN enc_big = plplenc_list % index1 ( i ) nchild = symba_plA % nchild ( enc_big ) array_child ( 1 : npl ) = symba_plA % index_child ( 1 : npl , enc_big ) DO j = 1 , nchild symba_plA % helio % swiftest % status ( array_child ( j )) = INACTIVE END DO ldiscard = . TRUE . ELSE IF (( symba_plA % helio % swiftest % status ( index1 ) == HIT_AND_RUN ) . AND . & ( symba_plA % helio % swiftest % status ( index2 ) == HIT_AND_RUN )) THEN enc_big = plplenc_list % index1 ( i ) nchild = symba_plA % nchild ( enc_big ) array_child ( 1 : npl ) = symba_plA % index_child ( 1 : npl , enc_big ) DO j = 1 , nchild symba_plA % helio % swiftest % status ( array_child ( j )) = INACTIVE END DO ldiscard = . TRUE . ELSE IF (( symba_plA % helio % swiftest % status ( index1 ) == GRAZE_AND_MERGE ) . AND . & ( symba_plA % helio % swiftest % status ( index2 ) == GRAZE_AND_MERGE )) THEN enc_big = plplenc_list % index1 ( i ) nchild = symba_plA % nchild ( enc_big ) array_child ( 1 : npl ) = symba_plA % index_child ( 1 : npl , enc_big ) DO j = 1 , nchild symba_plA % helio % swiftest % status ( array_child ( j )) = INACTIVE END DO ldiscard = . TRUE . END IF END IF END DO RETURN END SUBROUTINE symba_discard_merge_pl !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_discard_merge_pl.f90.html"},{"title":"symba_step.f90 – swiftest","text":"Unit Name   : symba_step\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Step planets and active test particles ahead in democratic heliocentric coordinates, descending the recursive\n                branch if necessary to handle possible close encounters Input\n    Arguments : lfirst         : logical flag indicating whether current invocation is the first\n                lextra_force   : logical flag indicating whether to include user-supplied accelerations\n                lclose         : logical flag indicating whether to check for mergers\n                t              : time\n                npl            : number of planets\n                nplmax         : maximum allowed number of planets\n                ntp            : number of active test particles\n                ntpmax         : maximum allowed number of test particles\n                symba_pl1P     : pointer to head of SyMBA planet structure linked-list\n                symba_tp1P     : pointer to head of active SyMBA test particle structure linked-list\n                j2rp2          : J2 * R 2 for the Sun\n                j4rp4          : J4 * R 4 for the Sun\n                dt             : time step\n                nplplenc       : number of planet-planet encounters\n                npltpenc       : number of planet-test particle encounters\n                plplenc_list   : array of planet-planet encounter structures\n                pltpenc_list   : array of planet-test particle encounter structures\n                nmergeadd      : number of merged planets to add\n                nmergesub      : number of merged planets to subtract\n                mergeadd_list  : array of structures of merged planets to add\n                mergesub_list  : array of structures of merged planets to subtract\n                eoffset        : energy offset (net energy lost in mergers)\n                mtiny          : smallest self-gravitating mass\n                encounter_file : name of output file for encounters\n                out_type       : binary format of output file\n    Terminal  : none\n    File      : none Output\n    Arguments : lfirst         : logical flag indicating whether current invocation is the first\n                symba_pl1P     : pointer to head of SyMBA planet structure linked-list\n                symba_tp1P     : pointer to head of active SyMBA test particle structure linked-list\n                nplplenc       : number of planet-planet encounters\n                npltpenc       : number of planet-test particle encounters\n                plplenc_list   : array of planet-planet encounter structures\n                pltpenc_list   : array of planet-test particle encounter structures\n                nmergeadd      : number of merged planets to add\n                nmergesub      : number of merged planets to subtract\n                mergeadd_list  : array of structures of merged planets to add\n                mergesub_list  : array of structures of merged planets to subtract\n                eoffset        : energy offset (net energy lost in mergers)\n    Terminal  : error message\n    File      : none Invocation  : CALL symba_step(lfirst, lextra_force, lclose, t, npl, nplmax, ntp, ntpmax, symba_pl1P, symba_tp1P, j2rp2, j4rp4,\n                                dt, nplplenc, npltpenc, plplenc_list, pltpenc_list, nmergeadd, nmergesub, mergeadd_list,\n                                mergesub_list, eoffset, mtiny, encounter_file, out_type) Notes       : Adapted from Hal Levison's Swift routine symba5_step_pl.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_step.f90~~EfferentGraph sourcefile~symba_step.f90 symba_step.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_step.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_step.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_step.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_step.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_step Source Code symba_step.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_step !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Step planets and active test particles ahead in democratic heliocentric coordinates, descending the recursive !                branch if necessary to handle possible close encounters ! !  Input !    Arguments : lfirst         : logical flag indicating whether current invocation is the first !                lextra_force   : logical flag indicating whether to include user-supplied accelerations !                lclose         : logical flag indicating whether to check for mergers !                t              : time !                npl            : number of planets !                nplmax         : maximum allowed number of planets !                ntp            : number of active test particles !                ntpmax         : maximum allowed number of test particles !                symba_pl1P     : pointer to head of SyMBA planet structure linked-list !                symba_tp1P     : pointer to head of active SyMBA test particle structure linked-list !                j2rp2          : J2 * R**2 for the Sun !                j4rp4          : J4 * R**4 for the Sun !                dt             : time step !                nplplenc       : number of planet-planet encounters !                npltpenc       : number of planet-test particle encounters !                plplenc_list   : array of planet-planet encounter structures !                pltpenc_list   : array of planet-test particle encounter structures !                nmergeadd      : number of merged planets to add !                nmergesub      : number of merged planets to subtract !                mergeadd_list  : array of structures of merged planets to add !                mergesub_list  : array of structures of merged planets to subtract !                eoffset        : energy offset (net energy lost in mergers) !                mtiny          : smallest self-gravitating mass !                encounter_file : name of output file for encounters !                out_type       : binary format of output file !    Terminal  : none !    File      : none ! !  Output !    Arguments : lfirst         : logical flag indicating whether current invocation is the first !                symba_pl1P     : pointer to head of SyMBA planet structure linked-list !                symba_tp1P     : pointer to head of active SyMBA test particle structure linked-list !                nplplenc       : number of planet-planet encounters !                npltpenc       : number of planet-test particle encounters !                plplenc_list   : array of planet-planet encounter structures !                pltpenc_list   : array of planet-test particle encounter structures !                nmergeadd      : number of merged planets to add !                nmergesub      : number of merged planets to subtract !                mergeadd_list  : array of structures of merged planets to add !                mergesub_list  : array of structures of merged planets to subtract !                eoffset        : energy offset (net energy lost in mergers) !    Terminal  : error message !    File      : none ! !  Invocation  : CALL symba_step(lfirst, lextra_force, lclose, t, npl, nplmax, ntp, ntpmax, symba_pl1P, symba_tp1P, j2rp2, j4rp4, !                                dt, nplplenc, npltpenc, plplenc_list, pltpenc_list, nmergeadd, nmergesub, mergeadd_list, !                                mergesub_list, eoffset, mtiny, encounter_file, out_type) ! !  Notes       : Adapted from Hal Levison's Swift routine symba5_step_pl.f ! !********************************************************************************************************************************** SUBROUTINE symba_step ( lfirst , lextra_force , lclose , t , npl , nplmax , ntp , ntpmax , symba_plA , symba_tpA , j2rp2 , j4rp4 , dt , & nplplenc , npltpenc , plplenc_list , pltpenc_list , nmergeadd , nmergesub , mergeadd_list , mergesub_list , eoffset , mtiny , & encounter_file , out_type , fragmax , feature ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_step IMPLICIT NONE ! Arguments LOGICAL ( LGT ), INTENT ( IN ) :: lextra_force , lclose LOGICAL ( LGT ), INTENT ( INOUT ) :: lfirst INTEGER ( I4B ), INTENT ( IN ) :: npl , nplmax , ntp , ntpmax INTEGER ( I4B ), INTENT ( INOUT ) :: nplplenc , npltpenc , nmergeadd , nmergesub , fragmax REAL ( DP ), INTENT ( IN ) :: t , j2rp2 , j4rp4 , dt , mtiny REAL ( DP ), INTENT ( INOUT ) :: eoffset CHARACTER ( * ), INTENT ( IN ) :: encounter_file , out_type TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list TYPE ( symba_pltpenc ), INTENT ( INOUT ) :: pltpenc_list TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list TYPE ( feature_list ) :: feature ! Derived type containing logical flags to turn on or off various features of the code ! Internals LOGICAL ( LGT ) :: lencounter , lvdotr INTEGER ( I4B ) :: i , j , irec , nplm REAL ( DP ), DIMENSION ( NDIM ) :: xr , vr ! Executable code DO i = 1 , npl symba_plA % nplenc ( i ) = 0 symba_plA % ntpenc ( i ) = 0 symba_plA % levelg ( i ) = - 1 symba_plA % levelm ( i ) = - 1 symba_plA % index_parent ( i ) = i symba_plA % index_child (:, i ) = 0 END DO DO i = 1 , ntp symba_tpA % nplenc ( i ) = 0 symba_tpA % levelg ( i ) = - 1 symba_tpA % levelm ( i ) = - 1 END DO !THERE SHOULD BE SOME PARALLEL BITS IN HERE nplplenc = 0 npltpenc = 0 IF ( symba_plA % helio % swiftest % mass ( 1 ) < mtiny ) THEN nplm = 0 ELSE nplm = 1 END IF irec = 0 ! ALL THIS NEEDS TO BE CHANGED TO THE TREE SEARCH FUNCTION FOR ENCOUNTERS DO i = 2 , npl IF ( symba_plA % helio % swiftest % mass ( i ) < mtiny ) EXIT nplm = nplm + 1 DO j = i + 1 , npl xr (:) = symba_plA % helio % swiftest % xh (:, j ) - symba_plA % helio % swiftest % xh (:, i ) vr (:) = symba_plA % helio % swiftest % vh (:, j ) - symba_plA % helio % swiftest % vh (:, i ) CALL symba_chk ( xr (:), vr (:), symba_plA % helio % swiftest % rhill ( i ), & symba_plA % helio % swiftest % rhill ( j ), dt , irec , lencounter , lvdotr ) IF ( lencounter ) THEN nplplenc = nplplenc + 1 IF ( nplplenc > NENMAX ) THEN WRITE ( * , * ) \"SWIFTER Error:\" WRITE ( * , * ) \"   PL-PL encounter list is full.\" WRITE ( * , * ) \"   STOPPING...\" CALL util_exit ( FAILURE ) END IF plplenc_list % status ( nplplenc ) = ACTIVE plplenc_list % lvdotr ( nplplenc ) = lvdotr plplenc_list % level ( nplplenc ) = irec plplenc_list % index1 ( nplplenc ) = i plplenc_list % index2 ( nplplenc ) = j symba_plA % lmerged ( i ) = . FALSE . symba_plA % nplenc ( i ) = symba_plA % nplenc ( i ) + 1 symba_plA % levelg ( i ) = irec symba_plA % levelm ( i ) = irec symba_plA % nchild ( i ) = 0 symba_plA % lmerged ( j ) = . FALSE . symba_plA % nplenc ( j ) = symba_plA % nplenc ( j ) + 1 symba_plA % levelg ( j ) = irec symba_plA % levelm ( j ) = irec symba_plA % nchild ( j ) = 0 END IF END DO DO j = 1 , ntp xr (:) = symba_tpA % helio % swiftest % xh (:, j ) - symba_plA % helio % swiftest % xh (:, i ) vr (:) = symba_tpA % helio % swiftest % vh (:, j ) - symba_plA % helio % swiftest % vh (:, i ) CALL symba_chk ( xr (:), vr (:), symba_plA % helio % swiftest % rhill ( i ), 0.0_DP , dt , irec , lencounter , lvdotr ) IF ( lencounter ) THEN npltpenc = npltpenc + 1 symba_plA % ntpenc ( i ) = symba_plA % ntpenc ( i ) + 1 symba_plA % levelg ( i ) = irec symba_plA % levelm ( i ) = irec symba_tpA % nplenc ( j ) = symba_tpA % nplenc ( j ) + 1 symba_tpA % levelg ( j ) = irec symba_tpA % levelm ( j ) = irec IF ( npltpenc > NENMAX ) THEN WRITE ( * , * ) \"SWIFTER Error:\" WRITE ( * , * ) \"   PL-TP encounter list is full.\" WRITE ( * , * ) \"   STOPPING...\" CALL util_exit ( FAILURE ) END IF pltpenc_list % status ( npltpenc ) = ACTIVE pltpenc_list % lvdotr ( npltpenc ) = lvdotr pltpenc_list % level ( npltpenc ) = irec pltpenc_list % indexpl ( npltpenc ) = i pltpenc_list % indextp ( npltpenc ) = j END IF END DO END DO ! END OF THINGS THAT NEED TO BE CHANGED IN THE TREE lencounter = (( nplplenc > 0 ) . OR . ( npltpenc > 0 )) IF ( lencounter ) THEN CALL symba_step_interp ( lextra_force , lclose , t , npl , nplm , nplmax , ntp , ntpmax , symba_plA , symba_tpA , j2rp2 , j4rp4 , & dt , eoffset , nplplenc , npltpenc , plplenc_list , pltpenc_list , nmergeadd , nmergesub , mergeadd_list , & mergesub_list , encounter_file , out_type , fragmax , feature ) lfirst = . TRUE . ELSE CALL symba_step_helio ( lfirst , lextra_force , t , npl , nplm , nplmax , ntp , ntpmax , symba_plA % helio , symba_tpA % helio , & j2rp2 , j4rp4 , dt ) END IF RETURN END SUBROUTINE symba_step !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_step.f90.html"},{"title":"symba_merge_tp.f90 – swiftest","text":"Unit Name   : symba_merge_tp\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Check for merger between planet and test particle in SyMBA Input\n    Arguments : t              : time\n                dt             : time step\n                index          : index of planet-test particle encounter in array pltpenc_list\n                npltpenc       : number of planet-test particle encounters\n                pltpenc_list   : array of planet-test particle encounter structures\n                vbs            : barycentric velocity of the Sun\n                encounter_file : name of output file for encounters\n                out_type       : binary format of output file\n    Terminal  : none\n    File      : none Output\n    Arguments : pltpenc_list   : array of planet-test particle encounter structures\n    Terminal  : status message\n    File      : none Invocation  : CALL symba_merge_tp(t, dt, index, npltpenc, pltpenc_list, vbs, encounter_file, out_type) Notes       : Adapted from Hal Levison's Swift routine symba5_merge.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~symba_merge_tp.f90~~EfferentGraph sourcefile~symba_merge_tp.f90 symba_merge_tp.f90 sourcefile~module_swifter.f90 module_swifter.f90 sourcefile~symba_merge_tp.f90->sourcefile~module_swifter.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_merge_tp.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_merge_tp.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_merge_tp.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_merge_tp.f90->sourcefile~swiftest.f90 sourcefile~module_swifter.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_merge_tp Source Code symba_merge_tp.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_merge_tp !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Check for merger between planet and test particle in SyMBA ! !  Input !    Arguments : t              : time !                dt             : time step !                index          : index of planet-test particle encounter in array pltpenc_list !                npltpenc       : number of planet-test particle encounters !                pltpenc_list   : array of planet-test particle encounter structures !                vbs            : barycentric velocity of the Sun !                encounter_file : name of output file for encounters !                out_type       : binary format of output file !    Terminal  : none !    File      : none ! !  Output !    Arguments : pltpenc_list   : array of planet-test particle encounter structures !    Terminal  : status message !    File      : none ! !  Invocation  : CALL symba_merge_tp(t, dt, index, npltpenc, pltpenc_list, vbs, encounter_file, out_type) ! !  Notes       : Adapted from Hal Levison's Swift routine symba5_merge.f ! !********************************************************************************************************************************** SUBROUTINE symba_merge_tp ( t , dt , index_enc , npltpenc , pltpenc_list , vbs , encounter_file , out_type , symba_plA , symba_tpA ) ! Modules USE swiftest USE module_swifter USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_merge_tp IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: index_enc , npltpenc REAL ( DP ), INTENT ( IN ) :: t , dt REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: vbs CHARACTER ( * ), INTENT ( IN ) :: encounter_file , out_type TYPE ( symba_pltpenc ), INTENT ( INOUT ) :: pltpenc_list TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA ! Internals LOGICAL ( LGT ) :: lmerge INTEGER ( I4B ) :: name1 , name2 , indexpl , indextp REAL ( DP ) :: r2 , rlim , rlim2 , vdotr , tcr2 , dt2 , mu , a , e , q , rad1 REAL ( DP ), DIMENSION ( NDIM ) :: xr , vr , xh1 , vh1 , xh2 , vh2 ! Executable code lmerge = . FALSE . indexpl = pltpenc_list % indexpl ( index_enc ) indextp = pltpenc_list % indextp ( index_enc ) rlim = symba_plA % helio % swiftest % radius ( indexpl ) xr (:) = symba_tpA % helio % swiftest % xh (:, indextp ) - symba_plA % helio % swiftest % xh (:, indexpl ) r2 = DOT_PRODUCT ( xr (:), xr (:)) rlim2 = rlim * rlim IF ( rlim2 >= r2 ) THEN lmerge = . TRUE . ELSE vr (:) = symba_tpA % helio % swiftest % vb (:, indextp ) - symba_plA % helio % swiftest % vb (:, indexpl ) vdotr = DOT_PRODUCT ( xr (:), vr (:)) IF ( pltpenc_list % lvdotr ( index_enc ) . AND . ( vdotr > 0.0_DP )) THEN mu = symba_plA % helio % swiftest % mass ( indexpl ) tcr2 = r2 / DOT_PRODUCT ( vr (:), vr (:)) dt2 = dt * dt IF ( tcr2 <= dt2 ) THEN CALL orbel_xv2aeq ( xr (:), vr (:), mu , a , e , q ) IF ( q < rlim ) lmerge = . TRUE . END IF IF (. NOT . lmerge ) THEN IF ( encounter_file /= \"\" ) THEN name1 = symba_plA % helio % swiftest % name ( indexpl ) rad1 = symba_plA % helio % swiftest % radius ( indexpl ) xh1 (:) = symba_plA % helio % swiftest % xh (:, indexpl ) vh1 (:) = symba_plA % helio % swiftest % vb (:, indexpl ) - vbs (:) name2 = symba_tpA % helio % swiftest % name ( indextp ) xh2 (:) = symba_tpA % helio % swiftest % xh (:, indextp ) vh2 (:) = symba_tpA % helio % swiftest % vb (:, indextp ) - vbs (:) CALL io_write_encounter ( t , name1 , name2 , mu , 0.0_DP , rad1 , 0.0_DP , & xh1 (:), xh2 (:), vh1 (:), vh2 (:), encounter_file , out_type ) END IF END IF END IF END IF IF ( lmerge ) THEN pltpenc_list % status ( index_enc ) = MERGED symba_tpA % helio % swiftest % status = DISCARDED_PLR WRITE ( * , * ) \"Particle \" , symba_tpA % helio % swiftest % name , \" too close to Planet \" , & symba_plA % helio % swiftest % name , \" at t = \" , t END IF RETURN END SUBROUTINE symba_merge_tp !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/symba_merge_tp.f90.html"},{"title":"symba_casemerge.f90 – swiftest","text":"Unit Name   : symba_casemerge\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : symba\n  Language    : Fortran 90/95 Description : Merge planets Input\n    Arguments : t            : time\n                npl          : number of planets\n                nsppl        : number of spilled planets\n                symba_pl1P   : pointer to head of SyMBA planet structure linked-list\n                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list\n                nplplenc     : number of planet-planet encounters\n                plplenc_list : array of planet-planet encounter structures\n    Terminal  : none\n    File      : none Output\n    Arguments : npl          : number of planets\n                nsppl        : number of spilled planets\n                symba_pl1P   : pointer to head of SyMBA planet structure linked-list\n                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list\n    Terminal  : none\n    File      : none Invocation  : CALL symba_casemerge(t, npl, nsppl, symba_pl1P, symba_pld1P, nplplenc, plplenc_list) Notes       : Adapted from Hal Levison's Swift routine discard_mass_merge.f This file depends on sourcefile~~symba_casemerge.f90~~EfferentGraph sourcefile~symba_casemerge.f90 symba_casemerge.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~symba_casemerge.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~symba_casemerge.f90->sourcefile~module_symba.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~symba_casemerge.f90->sourcefile~module_helio.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~symba_casemerge.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_casemerge.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines symba_casemerge Source Code symba_casemerge.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : symba_casemerge !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : symba !  Language    : Fortran 90/95 ! !  Description : Merge planets ! !  Input !    Arguments : t            : time !                npl          : number of planets !                nsppl        : number of spilled planets !                symba_pl1P   : pointer to head of SyMBA planet structure linked-list !                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list !                nplplenc     : number of planet-planet encounters !                plplenc_list : array of planet-planet encounter structures !    Terminal  : none !    File      : none ! !  Output !    Arguments : npl          : number of planets !                nsppl        : number of spilled planets !                symba_pl1P   : pointer to head of SyMBA planet structure linked-list !                symba_pld1P  : pointer to head of discard SyMBA planet structure linked-list !    Terminal  : none !    File      : none ! !  Invocation  : CALL symba_casemerge(t, npl, nsppl, symba_pl1P, symba_pld1P, nplplenc, plplenc_list) ! !  Notes       : Adapted from Hal Levison's Swift routine discard_mass_merge.f ! !********************************************************************************************************************************** SUBROUTINE symba_casemerge ( t , dt , index_enc , nmergeadd , nmergesub , mergeadd_list , mergesub_list , eoffset , vbs , & encounter_file , out_type , npl , ntp , symba_plA , symba_tpA , nplplenc , npltpenc , pltpenc_list , plplenc_list , & array_index1_child , array_index2_child , m1 , m2 , rad1 , rad2 , x1 , x2 , v1 , v2 ) ! Modules USE swiftest USE module_swiftest USE module_helio USE module_symba USE module_interfaces , EXCEPT_THIS_ONE => symba_casemerge IMPLICIT NONE ! Arguments INTEGER ( I4B ), INTENT ( IN ) :: index_enc INTEGER ( I4B ), INTENT ( INOUT ) :: npl , ntp , nmergeadd , nmergesub , nplplenc , npltpenc REAL ( DP ), INTENT ( IN ) :: t , dt REAL ( DP ), INTENT ( INOUT ) :: eoffset , m1 , m2 , rad1 , rad2 REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: vbs REAL ( DP ), DIMENSION ( NDIM ), INTENT ( INOUT ) :: x1 , x2 , v1 , v2 CHARACTER ( * ), INTENT ( IN ) :: encounter_file , out_type TYPE ( symba_plplenc ), INTENT ( INOUT ) :: plplenc_list TYPE ( symba_pltpenc ), INTENT ( INOUT ) :: pltpenc_list TYPE ( symba_merger ), INTENT ( INOUT ) :: mergeadd_list , mergesub_list TYPE ( symba_pl ), INTENT ( INOUT ) :: symba_plA TYPE ( symba_tp ), INTENT ( INOUT ) :: symba_tpA INTEGER ( I4B ), DIMENSION ( npl ), INTENT ( INOUT ) :: array_index1_child , array_index2_child ! Internals INTEGER ( I4B ) :: model , nres REAL ( DP ) :: mres , rres , pres , vres INTEGER ( I4B ) :: i , j , k , stat1 , stat2 , index1 , index2 , indexchild INTEGER ( I4B ) :: index1_child , index2_child , index1_parent , index2_parent , index_big1 , index_big2 INTEGER ( I4B ) :: name1 , name2 REAL ( DP ) :: r2 , rlim , rlim2 , vdotr , tcr2 , dt2 , mtot , a , e , q , mtmp , mmax REAL ( DP ) :: eold , enew , mass1 , mass2 REAL ( DP ), DIMENSION ( NDIM ) :: xr , vr , xnew , vnew INTEGER ( I4B ), DIMENSION ( npl ) :: array_keep_child , array_rm_child ! Executable code index1 = plplenc_list % index1 ( index_enc ) index2 = plplenc_list % index2 ( index_enc ) index1_parent = symba_plA % index_parent ( index1 ) index2_parent = symba_plA % index_parent ( index2 ) mtot = m1 + m2 xnew (:) = ( m1 * x1 (:) + m2 * x2 (:)) / mtot vnew (:) = ( m1 * v1 (:) + m2 * v2 (:)) / mtot WRITE ( * , * ) \"Merging particles \" , name1 , \" and \" , name2 , \" at time t = \" , t nmergesub = nmergesub + 1 mergesub_list % name ( nmergesub ) = name1 mergesub_list % status ( nmergesub ) = MERGED mergesub_list % xh (:, nmergesub ) = x1 (:) mergesub_list % vh (:, nmergesub ) = v1 (:) - vbs (:) mergesub_list % mass ( nmergesub ) = mass1 mergesub_list % radius ( nmergesub ) = rad1 nmergesub = nmergesub + 1 mergesub_list % name ( nmergesub ) = name2 mergesub_list % status ( nmergesub ) = MERGED mergesub_list % xh (:, nmergesub ) = x2 (:) mergesub_list % vh (:, nmergesub ) = v2 (:) - vbs (:) mergesub_list % mass ( nmergesub ) = mass2 mergesub_list % radius ( nmergesub ) = rad2 nmergeadd = nmergeadd + 1 IF ( m2 > m1 ) THEN mergeadd_list % name ( nmergeadd ) = name2 mergeadd_list % status ( nmergeadd ) = stat2 ELSE mergeadd_list % name ( nmergeadd ) = name1 mergeadd_list % status ( nmergeadd ) = stat1 END IF mergeadd_list % ncomp ( nmergeadd ) = 2 mergeadd_list % xh (:, nmergeadd ) = xnew (:) mergeadd_list % vh (:, nmergeadd ) = vnew (:) - vbs (:) eold = 0.5_DP * ( m1 * DOT_PRODUCT ( v1 (:), v1 (:)) + m2 * DOT_PRODUCT ( v2 (:), v2 (:))) xr (:) = x2 (:) - x1 (:) eold = eold - m1 * m2 / SQRT ( DOT_PRODUCT ( xr (:), xr (:))) enew = 0.5_DP * mtot * DOT_PRODUCT ( vnew (:), vnew (:)) eoffset = eoffset + eold - enew DO k = 1 , nplplenc IF ( plplenc_list % status ( k ) == ACTIVE ) THEN DO i = 0 , symba_plA % nchild ( index1_parent ) IF ( i == 0 ) THEN index1_child = index1_parent ELSE index1_child = array_index1_child ( i ) END IF DO j = 0 , symba_plA % nchild ( index2_parent ) IF ( j == 0 ) THEN index2_child = index2_parent ELSE index2_child = array_index2_child ( j ) END IF IF (( index1_child == plplenc_list % index1 ( k )) . AND . ( index2_child == plplenc_list % index2 ( k ))) THEN plplenc_list % status ( k ) = MERGED ELSE IF (( index1_child == plplenc_list % index2 ( k )) . AND . & ( index2_child == plplenc_list % index1 ( k ))) THEN plplenc_list % status ( k ) = MERGED END IF END DO END DO END IF END DO symba_plA % helio % swiftest % xh (:, index1_parent ) = xnew (:) symba_plA % helio % swiftest % vb (:, index1_parent ) = vnew (:) symba_plA % helio % swiftest % xh (:, index2_parent ) = xnew (:) symba_plA % helio % swiftest % vb (:, index2_parent ) = vnew (:) ! The children of parent one are the children we are keeping array_keep_child ( 1 : npl ) = symba_plA % index_child ( 1 : npl , index1_parent ) ! Go through the children of the kept parent and add those children to the array of kept children DO i = 1 , symba_plA % nchild ( index1_parent ) indexchild = array_keep_child ( i ) symba_plA % helio % swiftest % xh (:, indexchild ) = xnew (:) symba_plA % helio % swiftest % vb (:, indexchild ) = vnew (:) END DO ! the removed parent is assigned as a new child to the list of children of the kept parent ! gives kept parent a new child symba_plA % index_child (( symba_plA % nchild ( index1_parent ) + 1 ), index1_parent ) = index2_parent array_rm_child ( 1 : npl ) = symba_plA % index_child ( 1 : npl , index2_parent ) ! the parent of the removed parent is assigned to be the kept parent ! gives removed parent a new parent symba_plA % index_parent ( index2 ) = index1_parent ! go through the children of the removed parent and add those children to the array of removed children DO i = 1 , symba_plA % nchild ( index2_parent ) symba_plA % index_parent ( array_rm_child ( i )) = index1_parent indexchild = array_rm_child ( i ) symba_plA % helio % swiftest % xh (:, indexchild ) = xnew (:) symba_plA % helio % swiftest % vb (:, indexchild ) = vnew (:) END DO ! go through the children of the removed parent and add those children to the list of children of the kept parent DO i = 1 , symba_plA % nchild ( index2_parent ) symba_plA % index_child ( symba_plA % nchild ( index1_parent ) + i + 1 , index1_parent ) = array_rm_child ( i ) END DO ! updates the number of children of the kept parent symba_plA % nchild ( index1_parent ) = symba_plA % nchild ( index1_parent ) + symba_plA % nchild ( index2_parent ) + 1 RETURN END SUBROUTINE symba_casemerge","tags":"","loc":"sourcefile/symba_casemerge.f90.html"},{"title":"swiftest_symba.f90 – swiftest","text":"This file depends on sourcefile~~swiftest_symba.f90~~EfferentGraph sourcefile~swiftest_symba.f90 swiftest_symba.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~swiftest_symba.f90->sourcefile~module_swiftest.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~swiftest_symba.f90->sourcefile~module_symba.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~swiftest_symba.f90->sourcefile~module_interfaces.f90 sourcefile~module_swiftestalloc.f90 module_swiftestalloc.f90 sourcefile~swiftest_symba.f90->sourcefile~module_swiftestalloc.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~swiftest_symba.f90->sourcefile~swiftest.f90 sourcefile~io.f90 io.f90 sourcefile~swiftest_symba.f90->sourcefile~io.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_swiftestalloc.f90->sourcefile~module_swiftest.f90 sourcefile~module_swiftestalloc.f90->sourcefile~module_symba.f90 sourcefile~module_swiftestalloc.f90->sourcefile~swiftest.f90 sourcefile~module_swiftestalloc.f90->sourcefile~module_helio.f90 sourcefile~io.f90->sourcefile~module_symba.f90 sourcefile~io.f90->sourcefile~module_interfaces.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs swiftest_symba Source Code swiftest_symba.f90 Source Code program swiftest_symba !! author: The Purdue Swiftest Team -  David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Driver program for the Symplectic Massive Body Algorithm !! !! Adapted from Swifter by David E. Kaufmanna swiftert_symba.f90 !! Adapted from Hal Levison and Martin Duncan's Swift program swift_symba5.f !! Reference: Duncan, M. J., Levison, H. F. & Lee, M. H. 1998. Astron. J., 116, 2067. use io use swiftest !> The following are temporary until the conversion to the new module structure is complete use module_swiftest use module_symba use module_interfaces use module_swiftestalloc implicit none ! Arguments type ( input_parameters ) :: param ! derived type containing user-defined parameters type ( feature_list ) :: feature ! temporary until the parameter derived type conversion is complete integer ( I4B ) :: nplmax ! maximum number of planets integer ( I4B ) :: ntpmax ! maximum number of test particles integer ( I4B ) :: istep_out ! time steps between binary outputs integer ( I4B ) :: istep_dump ! time steps between dumps real ( DP ) :: t0 ! integration start time real ( DP ) :: tstop ! integration stop time real ( DP ) :: dt ! time step real ( DP ) :: j2rp2 ! j2*r&#94;2 term for central body real ( DP ) :: j4rp4 ! j4*r&#94;4 term for central body real ( DP ) :: rmin ! minimum heliocentric radius for test particle real ( DP ) :: rmax ! maximum heliocentric radius for test particle real ( DP ) :: rmaxu ! maximum unbound heliocentric radius for test particle real ( DP ) :: qmin ! minimum pericenter distance for test particle real ( DP ) :: qmin_alo ! minimum semimajor axis for qmin real ( DP ) :: qmin_ahi ! maximum semimajor axis for qmin character ( strmax ) :: qmin_coord ! coordinate frame to use for qmin character ( strmax ) :: encounter_file ! name of output file for encounters character ( strmax ) :: inplfile ! name of input file for planets character ( strmax ) :: intpfile ! name of input file for test particles character ( strmax ) :: in_type ! format of input data files character ( strmax ) :: outfile ! name of output binary file character ( strmax ) :: out_type ! binary format of output file character ( strmax ) :: out_form ! data to write to output file character ( strmax ) :: out_stat ! open status for output binary file ! Internals integer ( I4B ) :: ierr !! Error code logical :: lfirst , lfrag_add integer ( I4B ) :: npl , ntp , ntp0 , nsppl , nsptp , iout , idump , iloop integer ( I4B ) :: nplplenc , npltpenc , nmergeadd , nmergesub , fragmax real ( DP ) :: t , tfrac , tbase , mtiny , ke , pe , te , eoffset real ( DP ), dimension ( ndim ) :: htot character ( strmax ) :: inparfile type ( symba_pl ) :: symba_plA type ( symba_tp ) :: symba_tpA type ( swiftest_tp ) :: discard_tpA type ( swiftest_pl ) :: discard_plA type ( symba_plplenc ) :: plplenc_list type ( symba_pltpenc ) :: pltpenc_list type ( symba_merger ) :: mergeadd_list , mergesub_list integer ( I4B ), parameter :: egyiu = 72 real ( DP ) :: start , finish ! Executable code call cpu_time ( start ) call util_version nthreads = 1 write ( * , 100 , advance = \"no\" ) \"enter name of parameter data file: \" read ( * , 100 ) inparfile 100 format ( a ) inparfile = trim ( adjustl ( inparfile )) ! read in the param.in file and get simulation parameters param = io_read_param_in ( inparfile ) ! temporary until the conversion to the derived type argument list is complete nplmax = param % nplmax ntpmax = param % ntpmax t0 = param % t0 tstop = param % tstop dt = param % dt inplfile = param % inplfile intpfile = param % intpfile in_type = param % in_type istep_out = param % istep_out outfile = param % outfile out_type = param % out_type out_form = param % out_form out_stat = param % out_stat istep_dump = param % istep_dump j2rp2 = param % j2rp2 j4rp4 = param % j4rp4 rmin = param % rmin rmax = param % rmax rmaxu = param % rmaxu qmin = param % qmin qmin_coord = param % qmin_coord qmin_alo = param % qmin_alo qmin_ahi = param % qmin_ahi encounter_file = param % encounter_file mtiny = param % mtiny feature = param % feature !&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94; if (. not . feature % lrhill_present ) then write ( * , * ) \"Swiftest error:\" write ( * , * ) \"   Integrator SyMBA requires massive body Hill sphere radii on input\" call util_exit ( failure ) end if ! read in the total number of bodies from the input files call io_getn ( inplfile , intpfile , in_type , npl , nplmax , ntp , ntpmax ) ! create arrays of data structures big enough to store the number of bodies we are adding call symba_pl_allocate ( symba_plA , npl ) call symba_merger_allocate ( mergeadd_list , 10 * npl ) call symba_merger_allocate ( mergesub_list , npl ) call symba_plplenc_allocate ( plplenc_list , 10 * npl ) call symba_pltpenc_allocate ( pltpenc_list , ntp ) if ( ntp > 0 ) then call symba_tp_allocate ( symba_tpA , ntpmax ) end if ! reads in initial conditions of all massive bodies from input file ierr = io_read_pl_in ( param , npl , symba_plA % helio % swiftest ) if ( ierr /= 0 ) call util_exit ( FAILURE ) ! reorder by mass call symba_reorder_pl ( npl , symba_plA ) call io_init_tp ( intpfile , in_type , ntp , symba_tpA ) call util_valid ( npl , ntp , symba_plA % helio % swiftest , symba_tpA % helio % swiftest ) lfirst = . true . ntp0 = ntp t = t0 tbase = t0 iloop = 0 iout = istep_out idump = istep_dump nmergeadd = 0 nmergesub = 0 nsppl = 0 nsptp = 0 eoffset = 0.0_DP fragmax = 0 if ( istep_out > 0 ) then call io_write_frame ( t , npl , ntp , symba_plA % helio % swiftest , symba_tpA % helio % swiftest , outfile , & out_type , out_form , out_stat ) if ( feature % lpython ) then call python_io_write_frame_pl ( t , symba_plA , npl , out_stat ) if ( ntp > 0 ) call python_io_write_frame_tp ( t , symba_tpA , ntp , out_stat ) end if end if if ( out_stat == \"old\" ) then open ( unit = egyiu , file = energy_file , form = \"formatted\" , status = \"old\" , action = \"write\" , position = \"append\" ) else open ( unit = egyiu , file = energy_file , form = \"formatted\" , status = \"replace\" , action = \"write\" ) end if 300 format ( 7 ( 1 x , e23 . 16 )) write ( * , * ) \" *************** Main Loop *************** \" if ( feature % lenergy ) then call symba_energy ( npl , symba_plA % helio % swiftest , j2rp2 , j4rp4 , ke , pe , te , htot ) write ( egyiu , 300 ) t , ke , pe , te , htot end if call symba_energy ( npl , symba_plA % helio % swiftest , j2rp2 , j4rp4 , ke , pe , te , htot ) do while (( t < tstop ) . and . (( ntp0 == 0 ) . or . ( ntp > 0 ))) call symba_step ( lfirst , feature % lextra_force , feature % lclose , t , npl , nplmax , ntp , ntpmax , symba_plA , symba_tpA , j2rp2 , & j4rp4 , dt , nplplenc , npltpenc , plplenc_list , pltpenc_list , nmergeadd , nmergesub , mergeadd_list , mergesub_list , & eoffset , mtiny , encounter_file , out_type , fragmax , feature ) iloop = iloop + 1 if ( iloop == loopmax ) then tbase = tbase + iloop * dt iloop = 0 end if t = tbase + iloop * dt ldiscard = . false . ldiscard_tp = . false . lfrag_add = . false . call symba_discard_merge_pl ( t , npl , symba_plA , nplplenc , plplenc_list ) ! check this call symba_discard_pl ( t , npl , nplmax , nsppl , symba_plA , rmin , rmax , rmaxu , qmin , qmin_coord , qmin_alo , & ! check this qmin_ahi , j2rp2 , j4rp4 , eoffset ) call symba_discard_tp ( t , npl , ntp , nsptp , symba_plA , symba_tpA , dt , rmin , rmax , rmaxu , qmin , qmin_coord , & ! check this qmin_alo , qmin_ahi , feature % lclose , feature % lrhill_present ) if (( ldiscard . eqv . . true .) . or . ( ldiscard_tp . eqv . . true .) . or . ( lfrag_add . eqv . . true .)) then call symba_rearray ( npl , ntp , nsppl , nsptp , symba_plA , symba_tpA , nmergeadd , mergeadd_list , discard_plA , & discard_tpA , feature ) if (( ldiscard . eqv . . true .) . or . ( ldiscard_tp . eqv . . true .)) then call io_discard_write_symba ( t , mtiny , npl , ntp , nsppl , nsptp , nmergeadd , symba_plA , & discard_plA , discard_tpA , mergeadd_list , mergesub_list , discard_file , feature % lbig_discard ) nmergeadd = 0 nmergesub = 0 nsppl = 0 nsptp = 0 end if if ( feature % lenergy ) then call symba_energy ( npl , symba_plA % helio % swiftest , j2rp2 , j4rp4 , ke , pe , te , htot ) write ( egyiu , 300 ) t , ke , pe , te , htot end if end if if ( istep_out > 0 ) then iout = iout - 1 if ( iout == 0 ) then call io_write_frame ( t , npl , ntp , symba_plA % helio % swiftest , symba_tpA % helio % swiftest , outfile , out_type , & out_form , out_stat ) iout = istep_out if ( feature % lpython ) then call python_io_write_frame_pl ( t , symba_plA , npl , out_stat = \"append\" ) if ( ntp > 0 ) call python_io_write_frame_tp ( t , symba_tpA , ntp , out_stat = \"append\" ) end if if ( feature % lenergy ) then call symba_energy ( npl , symba_plA % helio % swiftest , j2rp2 , j4rp4 , ke , pe , te , htot ) write ( egyiu , 300 ) t , ke , pe , te , htot end if call symba_energy ( npl , symba_plA % helio % swiftest , j2rp2 , j4rp4 , ke , pe , te , htot ) end if end if if ( istep_dump > 0 ) then idump = idump - 1 if ( idump == 0 ) then tfrac = ( t - t0 ) / ( tstop - t0 ) write ( * , 200 ) t , tfrac , npl , ntp 200 format ( \" Time = \" , es12 . 5 , \"; fraction done = \" , f5 . 3 , \"; number of active pl, tp = \" , i5 , \", \" , i5 ) call io_dump_param ( nplmax , ntpmax , ntp , t , tstop , dt , in_type , istep_out , outfile , out_type , out_form , & istep_dump , j2rp2 , j4rp4 , rmin , rmax , rmaxu , qmin , qmin_coord , qmin_alo , qmin_ahi , & encounter_file , mtiny , feature ) call io_dump_pl ( npl , symba_plA % helio % swiftest , feature % lclose , feature % lrhill_present ) if ( ntp > 0 ) call io_dump_tp ( ntp , symba_tpA % helio % swiftest ) idump = istep_dump end if end if plplenc_list % lvdotr (:) = . false . plplenc_list % status (:) = 0 plplenc_list % level (:) = 0 plplenc_list % index1 (:) = 0 plplenc_list % index2 (:) = 0 plplenc_list % enc_child (:) = 0 plplenc_list % enc_parent (:) = 0 pltpenc_list % lvdotr (:) = . false . pltpenc_list % status (:) = 0 pltpenc_list % level (:) = 0 pltpenc_list % indexpl (:) = 0 pltpenc_list % indextp (:) = 0 mergeadd_list % name (:) = 0 mergeadd_list % index_ps (:) = 0 mergeadd_list % status (:) = 0 mergeadd_list % ncomp (:) = 0 mergeadd_list % xh (:,:) = 0 mergeadd_list % vh (:,:) = 0 mergeadd_list % mass (:) = 0 mergeadd_list % radius (:) = 0 mergesub_list % name (:) = 0 mergesub_list % index_ps (:) = 0 mergesub_list % status (:) = 0 mergesub_list % ncomp (:) = 0 mergesub_list % xh (:,:) = 0 mergesub_list % vh (:,:) = 0 mergesub_list % mass (:) = 0 mergesub_list % radius (:) = 0 if ( allocated ( discard_plA % name )) call swiftest_pl_deallocate ( discard_plA ) if ( allocated ( discard_tpA % name )) call swiftest_tp_deallocate ( discard_tpA ) end do call io_dump_param ( nplmax , ntpmax , ntp , t , tstop , dt , in_type , istep_out , outfile , out_type , out_form , istep_dump , j2rp2 , & j4rp4 , rmin , rmax , rmaxu , qmin , qmin_coord , qmin_alo , qmin_ahi , encounter_file , & mtiny , feature ) call io_dump_pl ( npl , symba_plA % helio % swiftest , feature % lclose , feature % lrhill_present ) if ( ntp > 0 ) call io_dump_tp ( ntp , symba_tpA % helio % swiftest ) if ( feature % lenergy ) then call symba_energy ( npl , symba_plA % helio % swiftest , j2rp2 , j4rp4 , ke , pe , te , htot ) write ( egyiu , 300 ) t , ke , pe , te , htot close ( egyiu ) end if call symba_pl_deallocate ( symba_plA ) call symba_merger_deallocate ( mergeadd_list ) call symba_merger_deallocate ( mergesub_list ) call symba_plplenc_deallocate ( plplenc_list ) call symba_pltpenc_deallocate ( pltpenc_list ) if ( ntp > 0 ) then call symba_tp_deallocate ( symba_tpA ) end if call cpu_time ( finish ) write ( * , * ) 'Time: ' , finish - start call util_exit ( SUCCESS ) stop end program swiftest_symba","tags":"","loc":"sourcefile/swiftest_symba.f90.html"},{"title":"tool_encounter_read.f90 – swiftest","text":"Unit Name   : \n  Unit Type   : \n  Project     : SWIFTER\n  Package     :\n  Language    : Fortran 90/95 Description : Input\n    Arguments :\n    Terminal  :\n    File      : Output\n    Arguments :\n    Terminal  :\n    File      : Invocation  : Notes       : Author(s)   : Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~tool_encounter_read.f90~~EfferentGraph sourcefile~tool_encounter_read.f90 tool_encounter_read.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~tool_encounter_read.f90->sourcefile~swiftest.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~tool_encounter_read.f90->sourcefile~module_interfaces.f90 sourcefile~io.f90 io.f90 sourcefile~tool_encounter_read.f90->sourcefile~io.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~io.f90->sourcefile~module_interfaces.f90 sourcefile~module_symba.f90 module_symba.f90 sourcefile~io.f90->sourcefile~module_symba.f90 sourcefile~module_symba.f90->sourcefile~swiftest.f90 sourcefile~module_helio.f90 module_helio.f90 sourcefile~module_symba.f90->sourcefile~module_helio.f90 sourcefile~module_helio.f90->sourcefile~swiftest.f90 sourcefile~module_swiftest.f90 module_swiftest.f90 sourcefile~module_helio.f90->sourcefile~module_swiftest.f90 sourcefile~module_swiftest.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs tool_encounter_read Source Code tool_encounter_read.f90 Source Code !****************************************************************************** ! !  Unit Name   : !  Unit Type   : !  Project     : SWIFTER !  Package     : !  Language    : Fortran 90/95 ! !  Description : ! !  Input !    Arguments : !    Terminal  : !    File      : ! !  Output !    Arguments : !    Terminal  : !    File      : ! !  Invocation  : ! !  Notes       : ! !****************************************************************************** PROGRAM tool_encounter_read ! Modules USE swiftest USE module_interfaces use io IMPLICIT NONE ! Arguments type ( input_parameters ) :: param ! derived type containing user-defined parameters type ( feature_list ) :: feature ! temporary until the parameter derived type conversion is complete INTEGER ( I4B ) :: nplmax ! Maximum number of planets INTEGER ( I4B ) :: ntpmax ! Maximum number of test particles INTEGER ( I4B ) :: istep_out ! Time steps between binary outputs INTEGER ( I4B ) :: istep_dump ! Time steps between dumps REAL ( DP ) :: t0 ! Integration start time REAL ( DP ) :: tstop ! Integration stop time REAL ( DP ) :: dt ! Time step REAL ( DP ) :: j2rp2 ! J2*R&#94;2 term for central body REAL ( DP ) :: j4rp4 ! J4*R&#94;4 term for central body REAL ( DP ) :: rmin ! Minimum heliocentric radius for test particle REAL ( DP ) :: rmax ! Maximum heliocentric radius for test particle REAL ( DP ) :: rmaxu ! Maximum unbound heliocentric radius for test particle REAL ( DP ) :: qmin ! Minimum pericenter distance for test particle REAL ( DP ) :: qmin_alo ! Minimum semimajor axis for qmin REAL ( DP ) :: qmin_ahi ! Maximum semimajor axis for qmin REAL ( DP ) :: mtiny ! Mass cutoff CHARACTER ( STRMAX ) :: qmin_coord ! Coordinate frame to use for qmin CHARACTER ( STRMAX ) :: encounter_file ! Name of output file for encounters CHARACTER ( STRMAX ) :: inplfile ! Name of input file for planets CHARACTER ( STRMAX ) :: intpfile ! Name of input file for test particles CHARACTER ( STRMAX ) :: in_type ! Format of input data files CHARACTER ( STRMAX ) :: outfile ! Name of output binary file CHARACTER ( STRMAX ) :: out_type ! Binary format of output file CHARACTER ( STRMAX ) :: out_form ! Data to write to output file CHARACTER ( STRMAX ) :: out_stat ! Open status for output binary file ! Internals INTEGER ( I4B ) :: i , ierr , id1 , id2 REAL ( DP ) :: t , mass1 , mass2 REAL ( DP ), DIMENSION ( NDIM ) :: xh1 , xh2 , vh1 , vh2 CHARACTER ( STRMAX ) :: inparfile ! Executable code WRITE ( * , 100 , ADVANCE = \"NO\" ) \"Enter name of parameter data file: \" READ ( * , 100 ) inparfile 100 FORMAT ( A ) inparfile = TRIM ( ADJUSTL ( inparfile )) param = io_read_param_in ( inparfile ) ! temporary until the conversion to the derived type argument list is complete nplmax = param % nplmax ntpmax = param % ntpmax t0 = param % t0 tstop = param % tstop dt = param % dt inplfile = param % inplfile intpfile = param % intpfile in_type = param % in_type istep_out = param % istep_out outfile = param % outfile out_type = param % out_type out_form = param % out_form out_stat = param % out_stat istep_dump = param % istep_dump j2rp2 = param % j2rp2 j4rp4 = param % j4rp4 rmin = param % rmin rmax = param % rmax rmaxu = param % rmaxu qmin = param % qmin qmin_coord = param % qmin_coord qmin_alo = param % qmin_alo qmin_ahi = param % qmin_ahi encounter_file = param % encounter_file mtiny = param % mtiny feature = param % feature !&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94;&#94; ierr = 0 i = 0 DO ierr = io_read_encounter ( t , id1 , id2 , mass1 , mass2 , xh1 , xh2 , vh1 , vh2 , encounter_file , out_type ) IF ( ierr /= 0 ) EXIT i = i + 1 WRITE ( * , * ) \"Encounter #\" , i WRITE ( * , * ) \"Time = \" , t WRITE ( * , * ) \" Body1: \" , id1 , mass1 , xh1 , vh1 WRITE ( * , * ) \" Body2: \" , id2 , mass2 , xh2 , vh2 END DO CALL util_exit ( SUCCESS ) STOP END PROGRAM tool_encounter_read !****************************************************************************** ! !  Author(s)   : ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !******************************************************************************","tags":"","loc":"sourcefile/tool_encounter_read.f90.html"},{"title":"rmvs_chk_ind.f90 – swiftest","text":"Unit Name   : rmvs_chk_ind\n  Unit Type   : subroutine\n  Project     : Swiftest\n  Package     : rmvs\n  Language    : Fortran 90/95 Description : Determine whether a test particle and planet are having or will have an encounter within the next time step Input\n    Arguments : xr     : relative position\n                vr     : relative velocity\n                dt     : time step\n                r2crit : square of the radius of the encounter region\n    Terminal  : none\n    File      : none Output\n    Arguments : iflag  : flag indicating encounter ( 1 ) or no encounter ( 0 )\n    Terminal  : none\n    File      : none Invocation  : CALL rmvs_chk_ind(xr, vr, dt, r2crit, iflag) Notes       : Adapted from Hal Levison's Swift routine rmvs_chk_ind.f Author(s)   : David E. Kaufmann Revision Control System (RCS) Information Source File : $RCSfile$\n  Full Path   : $Source$\n  Revision    : $Revision$\n  Date        : $Date$\n  Programmer  : $Author$\n  Locked By   : $Locker$\n  State       : $State$ Modification History: $Log$ This file depends on sourcefile~~rmvs_chk_ind.f90~~EfferentGraph sourcefile~rmvs_chk_ind.f90 rmvs_chk_ind.f90 sourcefile~module_interfaces.f90 module_interfaces.f90 sourcefile~rmvs_chk_ind.f90->sourcefile~module_interfaces.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~rmvs_chk_ind.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines rmvs_chk_ind Source Code rmvs_chk_ind.f90 Source Code !********************************************************************************************************************************** ! !  Unit Name   : rmvs_chk_ind !  Unit Type   : subroutine !  Project     : Swiftest !  Package     : rmvs !  Language    : Fortran 90/95 ! !  Description : Determine whether a test particle and planet are having or will have an encounter within the next time step ! !  Input !    Arguments : xr     : relative position !                vr     : relative velocity !                dt     : time step !                r2crit : square of the radius of the encounter region !    Terminal  : none !    File      : none ! !  Output !    Arguments : iflag  : flag indicating encounter ( 1 ) or no encounter ( 0 ) !    Terminal  : none !    File      : none ! !  Invocation  : CALL rmvs_chk_ind(xr, vr, dt, r2crit, iflag) ! !  Notes       : Adapted from Hal Levison's Swift routine rmvs_chk_ind.f ! !********************************************************************************************************************************** SUBROUTINE rmvs_chk_ind ( xr , vr , dt , r2crit , iflag ) ! Modules USE swiftest USE module_interfaces , EXCEPT_THIS_ONE => rmvs_chk_ind IMPLICIT NONE ! Arguments REAL ( DP ), INTENT ( IN ) :: dt , r2crit REAL ( DP ), DIMENSION ( NDIM ), INTENT ( IN ) :: xr , vr INTEGER ( I4B ), INTENT ( OUT ) :: iflag ! Internals REAL ( DP ) :: r2 , v2 , vdotr , tmin , r2min ! Executable code iflag = 0 r2 = DOT_PRODUCT ( xr (:), xr (:)) IF ( r2 < r2crit ) THEN iflag = 1 ELSE vdotr = DOT_PRODUCT ( vr (:), xr (:)) IF ( vdotr < 0.0_DP ) THEN v2 = DOT_PRODUCT ( vr (:), vr (:)) tmin = - vdotr / v2 IF ( tmin < dt ) THEN r2min = r2 - vdotr * vdotr / v2 ELSE r2min = r2 + 2.0_DP * vdotr * dt + v2 * dt * dt END IF r2min = MIN ( r2min , r2 ) IF ( r2min <= r2crit ) iflag = 1 END IF END IF RETURN END SUBROUTINE rmvs_chk_ind !********************************************************************************************************************************** ! !  Author(s)   : David E. Kaufmann ! !  Revision Control System (RCS) Information ! !  Source File : $RCSfile$ !  Full Path   : $Source$ !  Revision    : $Revision$ !  Date        : $Date$ !  Programmer  : $Author$ !  Locked By   : $Locker$ !  State       : $State$ ! !  Modification History: ! !  $Log$ !**********************************************************************************************************************************","tags":"","loc":"sourcefile/rmvs_chk_ind.f90.html"},{"title":"swiftest_pl – swiftest ","text":"type, public :: swiftest_pl Inherited by type~~swiftest_pl~~InheritedByGraph type~swiftest_pl swiftest_pl type~helio_pl helio_pl type~helio_pl->type~swiftest_pl swiftest type~symba_pl symba_pl type~symba_pl->type~helio_pl helio Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables name status mass radius rhill xh vh xb vb Components Type Visibility Attributes Name Initial integer(kind=I4B), public, dimension(:), allocatable :: name integer(kind=I4B), public, dimension(:), allocatable :: status real(kind=DP), public, dimension(:), allocatable :: mass real(kind=DP), public, dimension(:), allocatable :: radius real(kind=DP), public, dimension(:), allocatable :: rhill real(kind=DP), public, dimension(:,:), allocatable :: xh real(kind=DP), public, dimension(:,:), allocatable :: vh real(kind=DP), public, dimension(:,:), allocatable :: xb real(kind=DP), public, dimension(:,:), allocatable :: vb","tags":"","loc":"type/swiftest_pl.html"},{"title":"swiftest_tp – swiftest ","text":"type, public :: swiftest_tp Inherited by type~~swiftest_tp~~InheritedByGraph type~swiftest_tp swiftest_tp type~helio_tp helio_tp type~helio_tp->type~swiftest_tp swiftest type~symba_tp symba_tp type~symba_tp->type~helio_tp helio Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables name status isperi peri atp xh vh xb vb Components Type Visibility Attributes Name Initial integer(kind=I4B), public, dimension(:), allocatable :: name integer(kind=I4B), public, dimension(:), allocatable :: status integer(kind=I4B), public, dimension(:), allocatable :: isperi real(kind=DP), public, dimension(:), allocatable :: peri real(kind=DP), public, dimension(:), allocatable :: atp real(kind=DP), public, dimension(:,:), allocatable :: xh real(kind=DP), public, dimension(:,:), allocatable :: vh real(kind=DP), public, dimension(:,:), allocatable :: xb real(kind=DP), public, dimension(:,:), allocatable :: vb","tags":"","loc":"type/swiftest_tp.html"},{"title":"feature_list – swiftest ","text":"type, public :: feature_list Logical flags to turn on or off various features of the code Inherited by type~~feature_list~~InheritedByGraph type~feature_list feature_list type~input_parameters input_parameters type~input_parameters->type~feature_list feature Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lextra_force lbig_discard lrhill_present lclose lfragmentation lpython lenergy lrotation ltides lringmoons lpredprey lgr lyarkosvsky lyorp Components Type Visibility Attributes Name Initial logical, public :: lextra_force = .false. User defined force function turned on logical, public :: lbig_discard = .false. Save big bodies on every discard logical, public :: lrhill_present = .false. Hill's radius is in input file logical, public :: lclose = .false. Turn on close encounters logical, public :: lfragmentation = .false. Do fragmentation modeling instead of simple merger. logical, public :: lpython = .false. Output binary data in Python-friendly format logical, public :: lenergy = .false. Track the total energy of the system logical, public :: lrotation = .false. Include rotation states of big bodies logical, public :: ltides = .false. Include tidal dissipation logical, public :: lringmoons = .false. Turn on the ringmoons code logical, public :: lpredprey = .false. Turn on the predator/prey model for seed growth in ringmoons (experimental) logical, public :: lgr = .false. Turn on GR logical, public :: lyarkosvsky = .false. Turn on Yarkovsky effect logical, public :: lyorp = .false. Turn on YORP effect","tags":"","loc":"type/feature_list.html"},{"title":"input_parameters – swiftest ","text":"type, public :: input_parameters User defined input parameters that are read in from param.in Inherits type~~input_parameters~~InheritsGraph type~input_parameters input_parameters type~feature_list feature_list type~input_parameters->type~feature_list feature Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables feature nplmax ntpmax t0 tstop dt inplfile intpfile in_type istep_out outfile out_type out_form out_stat istep_dump j2rp2 j4rp4 rmin rmax rmaxu qmin qmin_coord qmin_alo qmin_ahi encounter_file mtiny ring_outfile MU2GM TU2S DU2CM Components Type Visibility Attributes Name Initial type( feature_list ), public :: feature collection of logical flags for various features integer(kind=I4B), public :: nplmax = -1 maximum allowed number of planets integer(kind=I4B), public :: ntpmax = -1 maximum allowed number of test particles real(kind=DP), public :: t0 = 0.0_DP integration start time real(kind=DP), public :: tstop = 0.0_DP integration stop time real(kind=DP), public :: dt = 0.0_DP time step character(len=STRMAX), public :: inplfile = '' name of input file for planets character(len=STRMAX), public :: intpfile = '' name of input file for test particles character(len=STRMAX), public :: in_type = 'ASCII' format of input data files integer(kind=I4B), public :: istep_out = -1 number of time steps between binary outputs character(len=STRMAX), public :: outfile = '' name of output binary file character(len=STRMAX), public :: out_type = XDR4_TYPE binary format of output file character(len=STRMAX), public :: out_form = 'XV' data to write to output file character(len=STRMAX), public :: out_stat = 'NEW' open status for output binary file integer(kind=I4B), public :: istep_dump = -1 number of time steps between dumps real(kind=DP), public :: j2rp2 = 0.0_DP J2 * R**2 for the Sun real(kind=DP), public :: j4rp4 = 0.0_DP J4 * R**4 for the Sun real(kind=DP), public :: rmin = -1.0_DP minimum heliocentric radius for test particle real(kind=DP), public :: rmax = -1.0_DP maximum heliocentric radius for test particle real(kind=DP), public :: rmaxu = -1.0_DP maximum unbound heliocentric radius for test particle real(kind=DP), public :: qmin = -1.0_DP minimum pericenter distance for test particle character(len=STRMAX), public :: qmin_coord = 'HELIO' coordinate frame to use for qmin real(kind=DP), public :: qmin_alo = -1.0_DP minimum semimajor axis for qmin real(kind=DP), public :: qmin_ahi = -1.0_DP maximum semimajor axis for qmin character(len=STRMAX), public :: encounter_file = '' name of output file for encounters real(kind=DP), public :: mtiny = 0.0_DP smallest mass that is fully gravitating character(len=STRMAX), public :: ring_outfile = '' name of output file in ring moons real(kind=DP), public :: MU2GM = -1.0_DP Converts mass units to grams real(kind=DP), public :: TU2S = -1.0_DP Converts time units to seconds real(kind=DP), public :: DU2CM = -1.0_DP Converts distance unit to centimeters","tags":"","loc":"type/input_parameters.html"},{"title":"swifter_ptr_arr – swiftest ","text":"type, public :: swifter_ptr_arr Inherits type~~swifter_ptr_arr~~InheritsGraph type~swifter_ptr_arr swifter_ptr_arr type~swifter_pl swifter_pl type~swifter_ptr_arr->type~swifter_pl thisP type~swifter_pl->type~swifter_ptr_arr swifter_plPA type~swifter_pl->type~swifter_pl prevP, nextP Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~swifter_ptr_arr~~InheritedByGraph type~swifter_ptr_arr swifter_ptr_arr type~swifter_pl swifter_pl type~swifter_ptr_arr->type~swifter_pl thisP type~swifter_pl->type~swifter_ptr_arr swifter_plPA type~swifter_pl->type~swifter_pl prevP, nextP Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thisP Components Type Visibility Attributes Name Initial type( swifter_pl ), public, POINTER :: thisP","tags":"","loc":"type/swifter_ptr_arr.html"},{"title":"swifter_ptr_arr_tp – swiftest ","text":"type, public :: swifter_ptr_arr_tp Inherits type~~swifter_ptr_arr_tp~~InheritsGraph type~swifter_ptr_arr_tp swifter_ptr_arr_tp type~swifter_tp swifter_tp type~swifter_ptr_arr_tp->type~swifter_tp thisP type~swifter_tp->type~swifter_ptr_arr_tp swifter_tpPA type~swifter_tp->type~swifter_tp prevP, nextP Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~swifter_ptr_arr_tp~~InheritedByGraph type~swifter_ptr_arr_tp swifter_ptr_arr_tp type~swifter_tp swifter_tp type~swifter_ptr_arr_tp->type~swifter_tp thisP type~swifter_tp->type~swifter_ptr_arr_tp swifter_tpPA type~swifter_tp->type~swifter_tp prevP, nextP Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thisP Components Type Visibility Attributes Name Initial type( swifter_tp ), public, POINTER :: thisP","tags":"","loc":"type/swifter_ptr_arr_tp.html"},{"title":"swifter_pl – swiftest ","text":"type, public :: swifter_pl Inherits type~~swifter_pl~~InheritsGraph type~swifter_pl swifter_pl type~swifter_pl->type~swifter_pl prevP, nextP type~swifter_ptr_arr swifter_ptr_arr type~swifter_pl->type~swifter_ptr_arr swifter_plPA type~swifter_ptr_arr->type~swifter_pl thisP Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~swifter_pl~~InheritedByGraph type~swifter_pl swifter_pl type~swifter_pl->type~swifter_pl prevP, nextP type~swifter_ptr_arr swifter_ptr_arr type~swifter_pl->type~swifter_ptr_arr swifter_plPA type~swifter_ptr_arr->type~swifter_pl thisP Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables id status mass radius rhill xh vh xb vb prevP nextP swifter_plPA Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: id integer(kind=I4B), public :: status real(kind=DP), public :: mass real(kind=DP), public :: radius real(kind=DP), public :: rhill real(kind=DP), public, DIMENSION(NDIM) :: xh real(kind=DP), public, DIMENSION(NDIM) :: vh real(kind=DP), public, DIMENSION(NDIM) :: xb real(kind=DP), public, DIMENSION(NDIM) :: vb type( swifter_pl ), public, POINTER :: prevP type( swifter_pl ), public, POINTER :: nextP type( swifter_ptr_arr ), public, DIMENSION(:), ALLOCATABLE :: swifter_plPA","tags":"","loc":"type/swifter_pl.html"},{"title":"swifter_tp – swiftest ","text":"type, public :: swifter_tp Inherits type~~swifter_tp~~InheritsGraph type~swifter_tp swifter_tp type~swifter_tp->type~swifter_tp prevP, nextP type~swifter_ptr_arr_tp swifter_ptr_arr_tp type~swifter_tp->type~swifter_ptr_arr_tp swifter_tpPA type~swifter_ptr_arr_tp->type~swifter_tp thisP Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~swifter_tp~~InheritedByGraph type~swifter_tp swifter_tp type~swifter_tp->type~swifter_tp prevP, nextP type~swifter_ptr_arr_tp swifter_ptr_arr_tp type~swifter_tp->type~swifter_ptr_arr_tp swifter_tpPA type~swifter_ptr_arr_tp->type~swifter_tp thisP Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables id status isperi peri atp xh vh xb vb prevP nextP swifter_tpPA Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: id integer(kind=I4B), public :: status integer(kind=I4B), public :: isperi real(kind=DP), public :: peri real(kind=DP), public :: atp real(kind=DP), public, DIMENSION(NDIM) :: xh real(kind=DP), public, DIMENSION(NDIM) :: vh real(kind=DP), public, DIMENSION(NDIM) :: xb real(kind=DP), public, DIMENSION(NDIM) :: vb type( swifter_tp ), public, POINTER :: prevP type( swifter_tp ), public, POINTER :: nextP type( swifter_ptr_arr_tp ), public, DIMENSION(:), ALLOCATABLE :: swifter_tpPA","tags":"","loc":"type/swifter_tp.html"},{"title":"symba_pl – swiftest ","text":"type, public :: symba_pl Inherits type~~symba_pl~~InheritsGraph type~symba_pl symba_pl type~helio_pl helio_pl type~symba_pl->type~helio_pl helio type~swiftest_pl swiftest_pl type~helio_pl->type~swiftest_pl swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lmerged nplenc ntpenc levelg levelm nchild isperi peri atp helio index_parent index_child Components Type Visibility Attributes Name Initial logical(kind=LGT), public, dimension(:), allocatable :: lmerged integer(kind=I4B), public, dimension(:), allocatable :: nplenc integer(kind=I4B), public, dimension(:), allocatable :: ntpenc integer(kind=I4B), public, dimension(:), allocatable :: levelg integer(kind=I4B), public, dimension(:), allocatable :: levelm integer(kind=I4B), public, dimension(:), allocatable :: nchild integer(kind=I4B), public, dimension(:), allocatable :: isperi real(kind=DP), public, dimension(:), allocatable :: peri real(kind=DP), public, dimension(:), allocatable :: atp type( helio_pl ), public :: helio integer(kind=I4B), public, dimension(:), allocatable :: index_parent integer(kind=I4B), public, dimension(:,:), allocatable :: index_child","tags":"","loc":"type/symba_pl.html"},{"title":"symba_tp – swiftest ","text":"type, public :: symba_tp Inherits type~~symba_tp~~InheritsGraph type~symba_tp symba_tp type~helio_tp helio_tp type~symba_tp->type~helio_tp helio type~swiftest_tp swiftest_tp type~helio_tp->type~swiftest_tp swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nplenc levelg levelm helio Components Type Visibility Attributes Name Initial integer(kind=I4B), public, dimension(:), allocatable :: nplenc integer(kind=I4B), public, dimension(:), allocatable :: levelg integer(kind=I4B), public, dimension(:), allocatable :: levelm type( helio_tp ), public :: helio","tags":"","loc":"type/symba_tp.html"},{"title":"symba_plplenc – swiftest ","text":"type, public :: symba_plplenc Contents Variables lvdotr status level index1 index2 enc_child enc_parent Components Type Visibility Attributes Name Initial logical(kind=LGT), public, dimension(:), allocatable :: lvdotr integer(kind=I4B), public, dimension(:), allocatable :: status integer(kind=I4B), public, dimension(:), allocatable :: level integer(kind=I4B), public, dimension(:), allocatable :: index1 integer(kind=I4B), public, dimension(:), allocatable :: index2 integer(kind=I4B), public, dimension(:), allocatable :: enc_child integer(kind=I4B), public, dimension(:), allocatable :: enc_parent","tags":"","loc":"type/symba_plplenc.html"},{"title":"symba_pltpenc – swiftest ","text":"type, public :: symba_pltpenc Contents Variables lvdotr status level indexpl indextp Components Type Visibility Attributes Name Initial logical(kind=LGT), public, dimension(:), allocatable :: lvdotr integer(kind=I4B), public, dimension(:), allocatable :: status integer(kind=I4B), public, dimension(:), allocatable :: level integer(kind=I4B), public, dimension(:), allocatable :: indexpl integer(kind=I4B), public, dimension(:), allocatable :: indextp","tags":"","loc":"type/symba_pltpenc.html"},{"title":"symba_merger – swiftest ","text":"type, public :: symba_merger Contents Variables name index_ps status ncomp xh vh mass radius Components Type Visibility Attributes Name Initial integer(kind=I4B), public, dimension(:), allocatable :: name integer(kind=I4B), public, dimension(:), allocatable :: index_ps integer(kind=I4B), public, dimension(:), allocatable :: status integer(kind=I4B), public, dimension(:), allocatable :: ncomp real(kind=DP), public, dimension(:,:), allocatable :: xh real(kind=DP), public, dimension(:,:), allocatable :: vh real(kind=DP), public, dimension(:), allocatable :: mass real(kind=DP), public, dimension(:), allocatable :: radius","tags":"","loc":"type/symba_merger.html"},{"title":"helio_pl – swiftest ","text":"type, public :: helio_pl Inherits type~~helio_pl~~InheritsGraph type~helio_pl helio_pl type~swiftest_pl swiftest_pl type~helio_pl->type~swiftest_pl swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~helio_pl~~InheritedByGraph type~helio_pl helio_pl type~symba_pl symba_pl type~symba_pl->type~helio_pl helio Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables ah ahi swiftest Components Type Visibility Attributes Name Initial real(kind=DP), public, dimension(:,:), allocatable :: ah real(kind=DP), public, dimension(:,:), allocatable :: ahi type( swiftest_pl ), public :: swiftest","tags":"","loc":"type/helio_pl.html"},{"title":"helio_tp – swiftest ","text":"type, public :: helio_tp Inherits type~~helio_tp~~InheritsGraph type~helio_tp helio_tp type~swiftest_tp swiftest_tp type~helio_tp->type~swiftest_tp swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~helio_tp~~InheritedByGraph type~helio_tp helio_tp type~symba_tp symba_tp type~symba_tp->type~helio_tp helio Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables ah ahi swiftest Components Type Visibility Attributes Name Initial real(kind=DP), public, dimension(:,:), allocatable :: ah real(kind=DP), public, dimension(:,:), allocatable :: ahi type( swiftest_tp ), public :: swiftest","tags":"","loc":"type/helio_tp.html"},{"title":"obl_acc – swiftest","text":"subroutine obl_acc(npl, swiftest_plA, j2rp2, j4rp4, xh, irh, aobl) Uses swiftest module_swiftest module_interfaces proc~~obl_acc~~UsesGraph proc~obl_acc obl_acc module~module_swiftest module_swiftest proc~obl_acc->module~module_swiftest module~swiftest swiftest proc~obl_acc->module~swiftest module~module_interfaces module_interfaces proc~obl_acc->module~module_interfaces module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type( swiftest_pl ), intent(inout) :: swiftest_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in), DIMENSION(NDIM, npl) :: xh real(kind=DP), intent(in), DIMENSION(npl) :: irh real(kind=DP), intent(out), DIMENSION(NDIM, npl) :: aobl Contents None","tags":"","loc":"proc/obl_acc.html"},{"title":"obl_acc_tp – swiftest","text":"subroutine obl_acc_tp(ntp, xht, j2rp2, j4rp4, irht, aoblt, msun) Uses swiftest module_interfaces proc~~obl_acc_tp~~UsesGraph proc~obl_acc_tp obl_acc_tp module~swiftest swiftest proc~obl_acc_tp->module~swiftest module~module_interfaces module_interfaces proc~obl_acc_tp->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp real(kind=DP), intent(in), DIMENSION(NDIM, ntp) :: xht real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in), DIMENSION(ntp) :: irht real(kind=DP), intent(out), DIMENSION(NDIM, ntp) :: aoblt real(kind=DP), intent(in) :: msun Contents None","tags":"","loc":"proc/obl_acc_tp.html"},{"title":"obl_pot – swiftest","text":"subroutine obl_pot(npl, swiftest_plA, j2rp2, j4rp4, xh, irh, oblpot) Uses swiftest module_swiftest module_interfaces proc~~obl_pot~~UsesGraph proc~obl_pot obl_pot module~module_swiftest module_swiftest proc~obl_pot->module~module_swiftest module~swiftest swiftest proc~obl_pot->module~swiftest module~module_interfaces module_interfaces proc~obl_pot->module~module_interfaces module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type( swiftest_pl ), intent(inout) :: swiftest_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in), DIMENSION(NDIM, npl) :: xh real(kind=DP), intent(in), DIMENSION(npl) :: irh real(kind=DP), intent(out) :: oblpot Contents None","tags":"","loc":"proc/obl_pot.html"},{"title":"orbel_scget – swiftest","text":"subroutine orbel_scget(angle, sx, cx) Uses swiftest module_interfaces proc~~orbel_scget~~UsesGraph proc~orbel_scget orbel_scget module~swiftest swiftest proc~orbel_scget->module~swiftest module~module_interfaces module_interfaces proc~orbel_scget->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: angle real(kind=DP), intent(out) :: sx real(kind=DP), intent(out) :: cx Contents None","tags":"","loc":"proc/orbel_scget.html"},{"title":"orbel_xv2el – swiftest","text":"subroutine orbel_xv2el(x, v, mu, a, e, inc, capom, omega, capm) Uses swiftest module_interfaces proc~~orbel_xv2el~~UsesGraph proc~orbel_xv2el orbel_xv2el module~swiftest swiftest proc~orbel_xv2el->module~swiftest module~module_interfaces module_interfaces proc~orbel_xv2el->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(NDIM) :: x real(kind=DP), intent(in), DIMENSION(NDIM) :: v real(kind=DP), intent(in) :: mu real(kind=DP), intent(out) :: a real(kind=DP), intent(out) :: e real(kind=DP), intent(out) :: inc real(kind=DP), intent(out) :: capom real(kind=DP), intent(out) :: omega real(kind=DP), intent(out) :: capm Contents None","tags":"","loc":"proc/orbel_xv2el.html"},{"title":"orbel_xv2aqt – swiftest","text":"subroutine orbel_xv2aqt(x, v, mu, a, q, capm, tperi) Uses swiftest module_interfaces proc~~orbel_xv2aqt~~UsesGraph proc~orbel_xv2aqt orbel_xv2aqt module~swiftest swiftest proc~orbel_xv2aqt->module~swiftest module~module_interfaces module_interfaces proc~orbel_xv2aqt->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(NDIM) :: x real(kind=DP), intent(in), DIMENSION(NDIM) :: v real(kind=DP), intent(in) :: mu real(kind=DP), intent(out) :: a real(kind=DP), intent(out) :: q real(kind=DP), intent(out) :: capm real(kind=DP), intent(out) :: tperi Contents None","tags":"","loc":"proc/orbel_xv2aqt.html"},{"title":"orbel_xv2aeq – swiftest","text":"subroutine orbel_xv2aeq(x, v, mu, a, e, q) Uses swiftest module_interfaces proc~~orbel_xv2aeq~~UsesGraph proc~orbel_xv2aeq orbel_xv2aeq module~swiftest swiftest proc~orbel_xv2aeq->module~swiftest module~module_interfaces module_interfaces proc~orbel_xv2aeq->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(NDIM) :: x real(kind=DP), intent(in), DIMENSION(NDIM) :: v real(kind=DP), intent(in) :: mu real(kind=DP), intent(out) :: a real(kind=DP), intent(out) :: e real(kind=DP), intent(out) :: q Contents None","tags":"","loc":"proc/orbel_xv2aeq.html"},{"title":"coord_vh2vb_tp – swiftest","text":"subroutine coord_vh2vb_tp(ntp, swiftest_tpA, vs) Uses swiftest module_swiftest module_interfaces proc~~coord_vh2vb_tp~~UsesGraph proc~coord_vh2vb_tp coord_vh2vb_tp module~module_swiftest module_swiftest proc~coord_vh2vb_tp->module~module_swiftest module~swiftest swiftest proc~coord_vh2vb_tp->module~swiftest module~module_interfaces module_interfaces proc~coord_vh2vb_tp->module~module_interfaces module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp type( swiftest_tp ), intent(inout) :: swiftest_tpA real(kind=DP), intent(in), DIMENSION(NDIM) :: vs Contents None","tags":"","loc":"proc/coord_vh2vb_tp.html"},{"title":"coord_h2b – swiftest","text":"subroutine coord_h2b(npl, swiftest_plA, msys) Uses swiftest module_swiftest module_interfaces proc~~coord_h2b~~UsesGraph proc~coord_h2b coord_h2b module~module_swiftest module_swiftest proc~coord_h2b->module~module_swiftest module~swiftest swiftest proc~coord_h2b->module~swiftest module~module_interfaces module_interfaces proc~coord_h2b->module~module_interfaces module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type( swiftest_pl ), intent(inout) :: swiftest_plA real(kind=DP), intent(out) :: msys Contents None","tags":"","loc":"proc/coord_h2b.html"},{"title":"coord_vb2vh_tp – swiftest","text":"subroutine coord_vb2vh_tp(ntp, swiftest_tpA, vs) Uses swiftest module_swiftest module_symba module_interfaces proc~~coord_vb2vh_tp~~UsesGraph proc~coord_vb2vh_tp coord_vb2vh_tp module~module_swiftest module_swiftest proc~coord_vb2vh_tp->module~module_swiftest module~module_symba module_symba proc~coord_vb2vh_tp->module~module_symba module~swiftest swiftest proc~coord_vb2vh_tp->module~swiftest module~module_interfaces module_interfaces proc~coord_vb2vh_tp->module~module_interfaces module~module_swiftest->module~swiftest module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~module_swiftest module~module_helio->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp type( swiftest_tp ), intent(inout) :: swiftest_tpA real(kind=DP), intent(in), DIMENSION(NDIM) :: vs Contents None","tags":"","loc":"proc/coord_vb2vh_tp.html"},{"title":"coord_vh2vb – swiftest","text":"subroutine coord_vh2vb(npl, swiftest_plA, msys) Uses swiftest module_swiftest module_symba module_interfaces proc~~coord_vh2vb~~UsesGraph proc~coord_vh2vb coord_vh2vb module~module_swiftest module_swiftest proc~coord_vh2vb->module~module_swiftest module~module_symba module_symba proc~coord_vh2vb->module~module_symba module~swiftest swiftest proc~coord_vh2vb->module~swiftest module~module_interfaces module_interfaces proc~coord_vh2vb->module~module_interfaces module~module_swiftest->module~swiftest module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~module_swiftest module~module_helio->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type( swiftest_pl ), intent(inout) :: swiftest_plA real(kind=DP), intent(out) :: msys Contents None","tags":"","loc":"proc/coord_vh2vb.html"},{"title":"coord_vb2vh – swiftest","text":"subroutine coord_vb2vh(npl, swiftest_plA) Uses swiftest module_swiftest module_interfaces proc~~coord_vb2vh~~UsesGraph proc~coord_vb2vh coord_vb2vh module~module_swiftest module_swiftest proc~coord_vb2vh->module~module_swiftest module~swiftest swiftest proc~coord_vb2vh->module~swiftest module~module_interfaces module_interfaces proc~coord_vb2vh->module~module_interfaces module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type( swiftest_pl ), intent(inout) :: swiftest_plA Contents None","tags":"","loc":"proc/coord_vb2vh.html"},{"title":"coord_h2b_tp – swiftest","text":"subroutine coord_h2b_tp(ntp, swiftest_tpA, swiftest_plA) Uses swiftest module_swiftest module_interfaces proc~~coord_h2b_tp~~UsesGraph proc~coord_h2b_tp coord_h2b_tp module~module_swiftest module_swiftest proc~coord_h2b_tp->module~module_swiftest module~swiftest swiftest proc~coord_h2b_tp->module~swiftest module~module_interfaces module_interfaces proc~coord_h2b_tp->module~module_interfaces module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp type( swiftest_tp ), intent(inout) :: swiftest_tpA type( swiftest_pl ), intent(inout) :: swiftest_plA Contents None","tags":"","loc":"proc/coord_h2b_tp.html"},{"title":"util_peri – swiftest","text":"subroutine util_peri(lfirst, ntp, swiftest_tpA, mu, msys, qmin_coord) Uses swiftest module_swiftest module_interfaces proc~~util_peri~~UsesGraph proc~util_peri util_peri module~module_swiftest module_swiftest proc~util_peri->module~module_swiftest module~swiftest swiftest proc~util_peri->module~swiftest module~module_interfaces module_interfaces proc~util_peri->module~module_interfaces module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lfirst integer(kind=I4B), intent(in) :: ntp type( swiftest_tp ), intent(inout) :: swiftest_tpA real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: msys character(len=*), intent(in) :: qmin_coord Calls proc~~util_peri~~CallsGraph proc~util_peri util_peri interface~orbel_xv2aeq orbel_xv2aeq proc~util_peri->interface~orbel_xv2aeq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_peri.html"},{"title":"util_hills – swiftest","text":"subroutine util_hills(npl, swiftest_plA) Uses swiftest module_swiftest module_interfaces proc~~util_hills~~UsesGraph proc~util_hills util_hills module~module_swiftest module_swiftest proc~util_hills->module~module_swiftest module~swiftest swiftest proc~util_hills->module~swiftest module~module_interfaces module_interfaces proc~util_hills->module~module_interfaces module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type( swiftest_pl ), intent(inout) :: swiftest_plA Contents None","tags":"","loc":"proc/util_hills.html"},{"title":"util_sort_dp – swiftest","text":"subroutine util_sort_dp(arr) Uses swiftest module_interfaces proc~~util_sort_dp~~UsesGraph proc~util_sort_dp util_sort_dp module~swiftest swiftest proc~util_sort_dp->module~swiftest module~module_interfaces module_interfaces proc~util_sort_dp->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), DIMENSION(:) :: arr Calls proc~~util_sort_dp~~CallsGraph proc~util_sort_dp util_sort_dp interface~util_exit util_exit proc~util_sort_dp->interface~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_sort_dp.html"},{"title":"util_toupper – swiftest","text":"subroutine util_toupper(string) Uses swiftest module_interfaces proc~~util_toupper~~UsesGraph proc~util_toupper util_toupper module~swiftest swiftest proc~util_toupper->module~swiftest module~module_interfaces module_interfaces proc~util_toupper->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string Contents None","tags":"","loc":"proc/util_toupper.html"},{"title":"util_resize_pl – swiftest","text":"subroutine util_resize_pl(symba_plA, npl_new, npl_old) Uses swiftest module_symba module_swiftest module_helio module_nrutil module_swiftestalloc module_interfaces proc~~util_resize_pl~~UsesGraph proc~util_resize_pl util_resize_pl module~module_helio module_helio proc~util_resize_pl->module~module_helio module~module_nrutil module_nrutil proc~util_resize_pl->module~module_nrutil module~module_symba module_symba proc~util_resize_pl->module~module_symba module~module_interfaces module_interfaces proc~util_resize_pl->module~module_interfaces module~swiftest swiftest proc~util_resize_pl->module~swiftest module~module_swiftest module_swiftest proc~util_resize_pl->module~module_swiftest module~module_swiftestalloc module_swiftestalloc proc~util_resize_pl->module~module_swiftestalloc module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_nrutil->module~swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest module~module_swiftestalloc->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( symba_pl ), intent(inout) :: symba_plA integer(kind=I4B), intent(in) :: npl_new integer(kind=I4B), intent(in) :: npl_old Calls proc~~util_resize_pl~~CallsGraph proc~util_resize_pl util_resize_pl proc~symba_pl_allocate symba_pl_allocate proc~util_resize_pl->proc~symba_pl_allocate proc~symba_pl_deallocate symba_pl_deallocate proc~util_resize_pl->proc~symba_pl_deallocate proc~helio_pl_allocate helio_pl_allocate proc~symba_pl_allocate->proc~helio_pl_allocate proc~helio_pl_deallocate helio_pl_deallocate proc~symba_pl_deallocate->proc~helio_pl_deallocate proc~swiftest_pl_allocate swiftest_pl_allocate proc~helio_pl_allocate->proc~swiftest_pl_allocate proc~swiftest_pl_deallocate swiftest_pl_deallocate proc~helio_pl_deallocate->proc~swiftest_pl_deallocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_resize_pl.html"},{"title":"util_index – swiftest","text":"subroutine util_index(arr, index) Uses swiftest module_nrutil module_interfaces proc~~util_index~~UsesGraph proc~util_index util_index module~module_nrutil module_nrutil proc~util_index->module~module_nrutil module~swiftest swiftest proc~util_index->module~swiftest module~module_interfaces module_interfaces proc~util_index->module~module_interfaces module~module_nrutil->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: arr integer(kind=I4B), intent(out), DIMENSION(:) :: index Calls proc~~util_index~~CallsGraph proc~util_index util_index interface~util_exit util_exit proc~util_index->interface~util_exit interface~arth arth proc~util_index->interface~arth proc~arth_d arth_d interface~arth->proc~arth_d proc~arth_i arth_i interface~arth->proc~arth_i Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_index.html"},{"title":"util_version – swiftest","text":"subroutine util_version() Uses swiftest module_interfaces proc~~util_version~~UsesGraph proc~util_version util_version module~swiftest swiftest proc~util_version->module~swiftest module~module_interfaces module_interfaces proc~util_version->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Contents None","tags":"","loc":"proc/util_version.html"},{"title":"util_sort_sp – swiftest","text":"subroutine util_sort_sp(arr) Uses swiftest module_interfaces proc~~util_sort_sp~~UsesGraph proc~util_sort_sp util_sort_sp module~swiftest swiftest proc~util_sort_sp->module~swiftest module~module_interfaces module_interfaces proc~util_sort_sp->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: arr Calls proc~~util_sort_sp~~CallsGraph proc~util_sort_sp util_sort_sp interface~util_exit util_exit proc~util_sort_sp->interface~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_sort_sp.html"},{"title":"util_valid – swiftest","text":"subroutine util_valid(npl, ntp, swiftest_plA, swiftest_tpA) Uses swiftest module_swiftest module_interfaces proc~~util_valid~~UsesGraph proc~util_valid util_valid module~module_swiftest module_swiftest proc~util_valid->module~module_swiftest module~swiftest swiftest proc~util_valid->module~swiftest module~module_interfaces module_interfaces proc~util_valid->module~module_interfaces module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp type( swiftest_pl ), intent(inout) :: swiftest_plA type( swiftest_tp ), intent(inout) :: swiftest_tpA Calls proc~~util_valid~~CallsGraph proc~util_valid util_valid interface~util_sort util_sort proc~util_valid->interface~util_sort interface~util_exit util_exit proc~util_valid->interface~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_valid.html"},{"title":"util_exit – swiftest","text":"subroutine util_exit(code) Uses swiftest module_interfaces proc~~util_exit~~UsesGraph proc~util_exit util_exit module~swiftest swiftest proc~util_exit->module~swiftest module~module_interfaces module_interfaces proc~util_exit->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: code Contents None","tags":"","loc":"proc/util_exit.html"},{"title":"util_sort_i4b – swiftest","text":"subroutine util_sort_i4b(arr) Uses swiftest module_interfaces proc~~util_sort_i4b~~UsesGraph proc~util_sort_i4b util_sort_i4b module~swiftest swiftest proc~util_sort_i4b->module~swiftest module~module_interfaces module_interfaces proc~util_sort_i4b->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), DIMENSION(:) :: arr Calls proc~~util_sort_i4b~~CallsGraph proc~util_sort_i4b util_sort_i4b interface~util_exit util_exit proc~util_sort_i4b->interface~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_sort_i4b.html"},{"title":"util_kahan_sum – swiftest","text":"function util_kahan_sum(xsum_current, xi, xerror) result(xsum_new) Uses swiftest module_interfaces proc~~util_kahan_sum~~UsesGraph proc~util_kahan_sum util_kahan_sum module~swiftest swiftest proc~util_kahan_sum->module~swiftest module~module_interfaces module_interfaces proc~util_kahan_sum->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xsum_current real(kind=dp), intent(in) :: xi real(kind=dp), intent(inout) :: xerror Return Value real(kind=dp) Contents None","tags":"","loc":"proc/util_kahan_sum.html"},{"title":"discard_pl_close – swiftest","text":"subroutine discard_pl_close(dx, dv, dt, r2crit, iflag, r2min) Uses swiftest module_interfaces proc~~discard_pl_close~~UsesGraph proc~discard_pl_close discard_pl_close module~swiftest swiftest proc~discard_pl_close->module~swiftest module~module_interfaces module_interfaces proc~discard_pl_close->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(NDIM) :: dx real(kind=DP), intent(in), DIMENSION(NDIM) :: dv real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r2crit integer(kind=I4B), intent(out) :: iflag real(kind=DP), intent(out) :: r2min Contents None","tags":"","loc":"proc/discard_pl_close.html"},{"title":"discard_sun – swiftest","text":"subroutine discard_sun(t, ntp, msys, swiftest_tpA, rmin, rmax, rmaxu) Uses swiftest module_swiftest module_interfaces proc~~discard_sun~~UsesGraph proc~discard_sun discard_sun module~module_swiftest module_swiftest proc~discard_sun->module~module_swiftest module~swiftest swiftest proc~discard_sun->module~swiftest module~module_interfaces module_interfaces proc~discard_sun->module~module_interfaces module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: ntp real(kind=DP), intent(in) :: msys type( swiftest_tp ), intent(inout) :: swiftest_tpA real(kind=DP), intent(in) :: rmin real(kind=DP), intent(in) :: rmax real(kind=DP), intent(in) :: rmaxu Contents None","tags":"","loc":"proc/discard_sun.html"},{"title":"discard_pl – swiftest","text":"subroutine discard_pl(t, dt, npl, ntp, swiftest_plA, swiftest_tpA) Uses swiftest module_swiftest module_interfaces proc~~discard_pl~~UsesGraph proc~discard_pl discard_pl module~module_swiftest module_swiftest proc~discard_pl->module~module_swiftest module~swiftest swiftest proc~discard_pl->module~swiftest module~module_interfaces module_interfaces proc~discard_pl->module~module_interfaces module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp type( swiftest_pl ), intent(inout) :: swiftest_plA type( swiftest_tp ), intent(inout) :: swiftest_tpA Contents None","tags":"","loc":"proc/discard_pl.html"},{"title":"discard – swiftest","text":"subroutine discard(t, dt, npl, ntp, swiftest_plA, swiftest_tpA, rmin, rmax, rmaxu, qmin, qmin_alo, qmin_ahi, qmin_coord, lclose, lrhill_present) Uses swiftest module_swiftest module_interfaces proc~~discard~~UsesGraph proc~discard discard module~module_swiftest module_swiftest proc~discard->module~module_swiftest module~swiftest swiftest proc~discard->module~swiftest module~module_interfaces module_interfaces proc~discard->module~module_interfaces module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp type( swiftest_pl ), intent(inout) :: swiftest_plA type( swiftest_tp ), intent(inout) :: swiftest_tpA real(kind=DP), intent(in) :: rmin real(kind=DP), intent(in) :: rmax real(kind=DP), intent(in) :: rmaxu real(kind=DP), intent(in) :: qmin real(kind=DP), intent(in) :: qmin_alo real(kind=DP), intent(in) :: qmin_ahi character(len=*), intent(in) :: qmin_coord logical(kind=LGT), intent(in) :: lclose logical(kind=LGT), intent(in) :: lrhill_present Calls proc~~discard~~CallsGraph proc~discard discard interface~coord_h2b_tp coord_h2b_tp proc~discard->interface~coord_h2b_tp interface~coord_h2b coord_h2b proc~discard->interface~coord_h2b Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/discard.html"},{"title":"discard_peri – swiftest","text":"subroutine discard_peri(t, npl, ntp, swiftest_plA, swiftest_tpA, msys, qmin, qmin_alo, qmin_ahi, qmin_coord, lrhill_present) Uses swiftest module_swiftest module_interfaces proc~~discard_peri~~UsesGraph proc~discard_peri discard_peri module~module_swiftest module_swiftest proc~discard_peri->module~module_swiftest module~swiftest swiftest proc~discard_peri->module~swiftest module~module_interfaces module_interfaces proc~discard_peri->module~module_interfaces module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp type( swiftest_pl ), intent(inout) :: swiftest_plA type( swiftest_tp ), intent(inout) :: swiftest_tpA real(kind=DP), intent(in) :: msys real(kind=DP), intent(in) :: qmin real(kind=DP), intent(in) :: qmin_alo real(kind=DP), intent(in) :: qmin_ahi character(len=*), intent(in) :: qmin_coord logical(kind=LGT), intent(in) :: lrhill_present Calls proc~~discard_peri~~CallsGraph proc~discard_peri discard_peri interface~util_peri util_peri proc~discard_peri->interface~util_peri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/discard_peri.html"},{"title":"helio_getacch – swiftest","text":"subroutine helio_getacch(lflag, lextra_force, t, npl, nplmax, helio_plA, j2rp2, j4rp4) Uses swiftest module_swiftest module_helio module_interfaces proc~~helio_getacch~~UsesGraph proc~helio_getacch helio_getacch module~module_swiftest module_swiftest proc~helio_getacch->module~module_swiftest module~module_helio module_helio proc~helio_getacch->module~module_helio module~swiftest swiftest proc~helio_getacch->module~swiftest module~module_interfaces module_interfaces proc~helio_getacch->module~module_interfaces module~module_swiftest->module~swiftest module~module_helio->module~module_swiftest module~module_helio->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lflag logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplmax type( helio_pl ), intent(inout) :: helio_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 Calls proc~~helio_getacch~~CallsGraph proc~helio_getacch helio_getacch interface~helio_getacch_int helio_getacch_int proc~helio_getacch->interface~helio_getacch_int interface~obl_acc obl_acc proc~helio_getacch->interface~obl_acc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_getacch.html"},{"title":"helio_user_getacch – swiftest","text":"subroutine helio_user_getacch(t, npl, helio_plA) Uses swiftest module_helio module_interfaces proc~~helio_user_getacch~~UsesGraph proc~helio_user_getacch helio_user_getacch module~module_helio module_helio proc~helio_user_getacch->module~module_helio module~swiftest swiftest proc~helio_user_getacch->module~swiftest module~module_interfaces module_interfaces proc~helio_user_getacch->module~module_interfaces module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl type( helio_pl ), intent(inout) :: helio_plA Contents None","tags":"","loc":"proc/helio_user_getacch.html"},{"title":"helio_getacch_int – swiftest","text":"subroutine helio_getacch_int(npl, helio_plA) Uses swiftest module_helio module_interfaces proc~~helio_getacch_int~~UsesGraph proc~helio_getacch_int helio_getacch_int module~module_helio module_helio proc~helio_getacch_int->module~module_helio module~swiftest swiftest proc~helio_getacch_int->module~swiftest module~module_interfaces module_interfaces proc~helio_getacch_int->module~module_interfaces module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type( helio_pl ), intent(inout) :: helio_plA Contents None","tags":"","loc":"proc/helio_getacch_int.html"},{"title":"helio_getacch_int_tp – swiftest","text":"subroutine helio_getacch_int_tp(npl, ntp, swiftest_plA, helio_tpA) Uses swiftest module_swiftest module_helio module_interfaces proc~~helio_getacch_int_tp~~UsesGraph proc~helio_getacch_int_tp helio_getacch_int_tp module~module_swiftest module_swiftest proc~helio_getacch_int_tp->module~module_swiftest module~module_helio module_helio proc~helio_getacch_int_tp->module~module_helio module~swiftest swiftest proc~helio_getacch_int_tp->module~swiftest module~module_interfaces module_interfaces proc~helio_getacch_int_tp->module~module_interfaces module~module_swiftest->module~swiftest module~module_helio->module~module_swiftest module~module_helio->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp type( swiftest_pl ), intent(inout) :: swiftest_plA type( helio_tp ), intent(inout) :: helio_tpA Contents None","tags":"","loc":"proc/helio_getacch_int_tp.html"},{"title":"helio_kickvb – swiftest","text":"subroutine helio_kickvb(npl, helio_plA, dt) Uses swiftest module_swiftest module_helio module_interfaces proc~~helio_kickvb~~UsesGraph proc~helio_kickvb helio_kickvb module~module_swiftest module_swiftest proc~helio_kickvb->module~module_swiftest module~module_helio module_helio proc~helio_kickvb->module~module_helio module~swiftest swiftest proc~helio_kickvb->module~swiftest module~module_interfaces module_interfaces proc~helio_kickvb->module~module_interfaces module~module_swiftest->module~swiftest module~module_helio->module~module_swiftest module~module_helio->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type( helio_pl ), intent(inout) :: helio_plA real(kind=DP), intent(in) :: dt Contents None","tags":"","loc":"proc/helio_kickvb.html"},{"title":"helio_kickvb_tp – swiftest","text":"subroutine helio_kickvb_tp(ntp, helio_tpA, dt) Uses swiftest module_swiftest module_helio module_interfaces proc~~helio_kickvb_tp~~UsesGraph proc~helio_kickvb_tp helio_kickvb_tp module~module_swiftest module_swiftest proc~helio_kickvb_tp->module~module_swiftest module~module_helio module_helio proc~helio_kickvb_tp->module~module_helio module~swiftest swiftest proc~helio_kickvb_tp->module~swiftest module~module_interfaces module_interfaces proc~helio_kickvb_tp->module~module_interfaces module~module_swiftest->module~swiftest module~module_helio->module~module_swiftest module~module_helio->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp type( helio_tp ), intent(inout) :: helio_tpA real(kind=DP), intent(in) :: dt Contents None","tags":"","loc":"proc/helio_kickvb_tp.html"},{"title":"helio_lindrift_tp – swiftest","text":"subroutine helio_lindrift_tp(ntp, swiftest_tpA, dt, pt) Uses swiftest module_swiftest module_symba module_interfaces proc~~helio_lindrift_tp~~UsesGraph proc~helio_lindrift_tp helio_lindrift_tp module~module_swiftest module_swiftest proc~helio_lindrift_tp->module~module_swiftest module~module_symba module_symba proc~helio_lindrift_tp->module~module_symba module~swiftest swiftest proc~helio_lindrift_tp->module~swiftest module~module_interfaces module_interfaces proc~helio_lindrift_tp->module~module_interfaces module~module_swiftest->module~swiftest module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~module_swiftest module~module_helio->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp type( swiftest_tp ), intent(inout) :: swiftest_tpA real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), DIMENSION(NDIM) :: pt Contents None","tags":"","loc":"proc/helio_lindrift_tp.html"},{"title":"helio_step_pl – swiftest","text":"subroutine helio_step_pl(lfirst, lextra_force, t, npl, nplmax, helio_plA, j2rp2, j4rp4, dt, xbeg, xend, ptb, pte) Uses swiftest module_swiftest module_helio module_interfaces proc~~helio_step_pl~~UsesGraph proc~helio_step_pl helio_step_pl module~module_swiftest module_swiftest proc~helio_step_pl->module~module_swiftest module~module_helio module_helio proc~helio_step_pl->module~module_helio module~swiftest swiftest proc~helio_step_pl->module~swiftest module~module_interfaces module_interfaces proc~helio_step_pl->module~module_interfaces module~module_swiftest->module~swiftest module~module_helio->module~module_swiftest module~module_helio->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(inout) :: lfirst logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplmax type( helio_pl ), intent(inout) :: helio_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: dt real(kind=DP), intent(out), DIMENSION(NDIM, npl) :: xbeg real(kind=DP), intent(out), DIMENSION(NDIM, npl) :: xend real(kind=DP), intent(out), DIMENSION(NDIM) :: ptb real(kind=DP), intent(out), DIMENSION(NDIM) :: pte Calls proc~~helio_step_pl~~CallsGraph proc~helio_step_pl helio_step_pl interface~helio_kickvb helio_kickvb proc~helio_step_pl->interface~helio_kickvb interface~coord_vb2vh coord_vb2vh proc~helio_step_pl->interface~coord_vb2vh interface~helio_drift helio_drift proc~helio_step_pl->interface~helio_drift interface~helio_getacch helio_getacch proc~helio_step_pl->interface~helio_getacch interface~coord_vh2vb coord_vh2vb proc~helio_step_pl->interface~coord_vh2vb interface~helio_lindrift helio_lindrift proc~helio_step_pl->interface~helio_lindrift Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_step_pl.html"},{"title":"helio_drift_tp – swiftest","text":"subroutine helio_drift_tp(ntp, swiftest_tpA, mu, dt) Uses swiftest module_swiftest module_interfaces proc~~helio_drift_tp~~UsesGraph proc~helio_drift_tp helio_drift_tp module~module_swiftest module_swiftest proc~helio_drift_tp->module~module_swiftest module~swiftest swiftest proc~helio_drift_tp->module~swiftest module~module_interfaces module_interfaces proc~helio_drift_tp->module~module_interfaces module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp type( swiftest_tp ), intent(inout) :: swiftest_tpA real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: dt Calls proc~~helio_drift_tp~~CallsGraph proc~helio_drift_tp helio_drift_tp interface~drift_one drift_one proc~helio_drift_tp->interface~drift_one Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_drift_tp.html"},{"title":"helio_step_tp – swiftest","text":"subroutine helio_step_tp(lfirsttp, lextra_force, t, npl, nplmax, ntp, ntpmax, helio_plA, helio_tpA, j2rp2, j4rp4, dt, xbeg, xend, ptb, pte) Uses swiftest module_swiftest module_helio module_interfaces proc~~helio_step_tp~~UsesGraph proc~helio_step_tp helio_step_tp module~module_swiftest module_swiftest proc~helio_step_tp->module~module_swiftest module~module_helio module_helio proc~helio_step_tp->module~module_helio module~swiftest swiftest proc~helio_step_tp->module~swiftest module~module_interfaces module_interfaces proc~helio_step_tp->module~module_interfaces module~module_swiftest->module~swiftest module~module_helio->module~module_swiftest module~module_helio->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(inout) :: lfirsttp logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: ntpmax type( helio_pl ), intent(inout) :: helio_plA type( helio_tp ), intent(inout) :: helio_tpA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), DIMENSION(NDIM, npl) :: xbeg real(kind=DP), intent(in), DIMENSION(NDIM, npl) :: xend real(kind=DP), intent(in), DIMENSION(NDIM) :: ptb real(kind=DP), intent(in), DIMENSION(NDIM) :: pte Calls proc~~helio_step_tp~~CallsGraph proc~helio_step_tp helio_step_tp interface~helio_drift_tp helio_drift_tp proc~helio_step_tp->interface~helio_drift_tp interface~helio_kickvb_tp helio_kickvb_tp proc~helio_step_tp->interface~helio_kickvb_tp interface~coord_vh2vb_tp coord_vh2vb_tp proc~helio_step_tp->interface~coord_vh2vb_tp interface~helio_lindrift_tp helio_lindrift_tp proc~helio_step_tp->interface~helio_lindrift_tp interface~helio_getacch_tp helio_getacch_tp proc~helio_step_tp->interface~helio_getacch_tp interface~coord_vb2vh_tp coord_vb2vh_tp proc~helio_step_tp->interface~coord_vb2vh_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_step_tp.html"},{"title":"helio_lindrift – swiftest","text":"subroutine helio_lindrift(npl, swiftest_plA, dt, pt) Uses swiftest module_swiftest module_symba module_interfaces proc~~helio_lindrift~~UsesGraph proc~helio_lindrift helio_lindrift module~module_swiftest module_swiftest proc~helio_lindrift->module~module_swiftest module~module_symba module_symba proc~helio_lindrift->module~module_symba module~swiftest swiftest proc~helio_lindrift->module~swiftest module~module_interfaces module_interfaces proc~helio_lindrift->module~module_interfaces module~module_swiftest->module~swiftest module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~module_swiftest module~module_helio->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type( swiftest_pl ), intent(inout) :: swiftest_plA real(kind=DP), intent(in) :: dt real(kind=DP), intent(out), DIMENSION(NDIM) :: pt Contents None","tags":"","loc":"proc/helio_lindrift.html"},{"title":"helio_drift – swiftest","text":"subroutine helio_drift(npl, swiftest_plA, dt) Uses swiftest module_swiftest module_interfaces proc~~helio_drift~~UsesGraph proc~helio_drift helio_drift module~module_swiftest module_swiftest proc~helio_drift->module~module_swiftest module~swiftest swiftest proc~helio_drift->module~swiftest module~module_interfaces module_interfaces proc~helio_drift->module~module_interfaces module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type( swiftest_pl ), intent(inout) :: swiftest_plA real(kind=DP), intent(in) :: dt Calls proc~~helio_drift~~CallsGraph proc~helio_drift helio_drift interface~drift_one drift_one proc~helio_drift->interface~drift_one interface~util_exit util_exit proc~helio_drift->interface~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_drift.html"},{"title":"helio_getacch_tp – swiftest","text":"subroutine helio_getacch_tp(lflag, lextra_force, t, npl, nplmax, ntp, ntpmax, helio_plA, helio_tpA, xh, j2rp2, j4rp4) Uses swiftest module_swiftest module_helio module_interfaces proc~~helio_getacch_tp~~UsesGraph proc~helio_getacch_tp helio_getacch_tp module~module_swiftest module_swiftest proc~helio_getacch_tp->module~module_swiftest module~module_helio module_helio proc~helio_getacch_tp->module~module_helio module~swiftest swiftest proc~helio_getacch_tp->module~swiftest module~module_interfaces module_interfaces proc~helio_getacch_tp->module~module_interfaces module~module_swiftest->module~swiftest module~module_helio->module~module_swiftest module~module_helio->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lflag logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: ntpmax type( helio_pl ), intent(inout) :: helio_plA type( helio_tp ), intent(inout) :: helio_tpA real(kind=DP), intent(in), DIMENSION(NDIM, npl) :: xh real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 Calls proc~~helio_getacch_tp~~CallsGraph proc~helio_getacch_tp helio_getacch_tp interface~obl_acc obl_acc proc~helio_getacch_tp->interface~obl_acc interface~obl_acc_tp obl_acc_tp proc~helio_getacch_tp->interface~obl_acc_tp interface~helio_getacch_int_tp helio_getacch_int_tp proc~helio_getacch_tp->interface~helio_getacch_int_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_getacch_tp.html"},{"title":"helio_user_getacch_tp – swiftest","text":"subroutine helio_user_getacch_tp(t, ntp, helio_tpA) Uses swiftest module_helio module_interfaces proc~~helio_user_getacch_tp~~UsesGraph proc~helio_user_getacch_tp helio_user_getacch_tp module~module_helio module_helio proc~helio_user_getacch_tp->module~module_helio module~swiftest swiftest proc~helio_user_getacch_tp->module~swiftest module~module_interfaces module_interfaces proc~helio_user_getacch_tp->module~module_interfaces module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: ntp type( helio_tp ), intent(inout) :: helio_tpA Contents None","tags":"","loc":"proc/helio_user_getacch_tp.html"},{"title":"python_io_write_frame_pl – swiftest","text":"subroutine python_io_write_frame_pl(t, symba_plA, npl, out_stat) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~python_io_write_frame_pl~~UsesGraph proc~python_io_write_frame_pl python_io_write_frame_pl module~module_helio module_helio proc~python_io_write_frame_pl->module~module_helio module~module_symba module_symba proc~python_io_write_frame_pl->module~module_symba module~module_interfaces module_interfaces proc~python_io_write_frame_pl->module~module_interfaces module~swiftest swiftest proc~python_io_write_frame_pl->module~swiftest module~module_swiftest module_swiftest proc~python_io_write_frame_pl->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t type( symba_pl ), intent(in) :: symba_plA integer, intent(in) :: npl character(len=*), intent(in) :: out_stat Calls proc~~python_io_write_frame_pl~~CallsGraph proc~python_io_write_frame_pl python_io_write_frame_pl interface~util_exit util_exit proc~python_io_write_frame_pl->interface~util_exit interface~io_open io_open proc~python_io_write_frame_pl->interface~io_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/python_io_write_frame_pl.html"},{"title":"io_read_line – swiftest","text":"function io_read_line(iu, name, d1, d2, d3, d4, d5, d6, out_type, MASS, RADIUS) Uses swiftest module_fxdr module_interfaces proc~~io_read_line~~UsesGraph proc~io_read_line io_read_line module~module_fxdr module_fxdr proc~io_read_line->module~module_fxdr module~swiftest swiftest proc~io_read_line->module~swiftest module~module_interfaces module_interfaces proc~io_read_line->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu integer(kind=I4B), intent(out) :: name real(kind=DP), intent(out) :: d1 real(kind=DP), intent(out) :: d2 real(kind=DP), intent(out) :: d3 real(kind=DP), intent(out) :: d4 real(kind=DP), intent(out) :: d5 real(kind=DP), intent(out) :: d6 character(len=*), intent(in) :: out_type real(kind=DP), intent(out), optional :: MASS real(kind=DP), intent(out), optional :: RADIUS Return Value integer(kind=I4B) Calls proc~~io_read_line~~CallsGraph proc~io_read_line io_read_line interface~ixdrreal ixdrreal proc~io_read_line->interface~ixdrreal interface~ixdrint ixdrint proc~io_read_line->interface~ixdrint interface~ixdrdouble ixdrdouble proc~io_read_line->interface~ixdrdouble interface~util_exit util_exit proc~io_read_line->interface~util_exit interface~ixdrdmat ixdrdmat proc~io_read_line->interface~ixdrdmat interface~ixdrrmat ixdrrmat proc~io_read_line->interface~ixdrrmat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_line.html"},{"title":"io_init_pl – swiftest","text":"subroutine io_init_pl(inplfile, in_type, lclose, lrhill_present, npl, symba_plA) Uses swiftest module_symba module_helio module_swiftest module_fxdr module_interfaces proc~~io_init_pl~~UsesGraph proc~io_init_pl io_init_pl module~module_helio module_helio proc~io_init_pl->module~module_helio module~module_symba module_symba proc~io_init_pl->module~module_symba module~module_interfaces module_interfaces proc~io_init_pl->module~module_interfaces module~module_fxdr module_fxdr proc~io_init_pl->module~module_fxdr module~swiftest swiftest proc~io_init_pl->module~swiftest module~module_swiftest module_swiftest proc~io_init_pl->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: inplfile character(len=*), intent(in) :: in_type logical(kind=LGT), intent(in) :: lclose logical(kind=LGT), intent(in) :: lrhill_present integer(kind=I4B), intent(in) :: npl type( symba_pl ), intent(inout) :: symba_plA Calls proc~~io_init_pl~~CallsGraph proc~io_init_pl io_init_pl interface~ixdrclose ixdrclose proc~io_init_pl->interface~ixdrclose interface~ixdrdouble ixdrdouble proc~io_init_pl->interface~ixdrdouble interface~ixdrint ixdrint proc~io_init_pl->interface~ixdrint interface~util_exit util_exit proc~io_init_pl->interface~util_exit interface~io_open_fxdr io_open_fxdr proc~io_init_pl->interface~io_open_fxdr interface~io_open io_open proc~io_init_pl->interface~io_open interface~ixdrdmat ixdrdmat proc~io_init_pl->interface~ixdrdmat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_init_pl.html"},{"title":"io_dump_tp – swiftest","text":"subroutine io_dump_tp(ntp, swiftest_tpA) Uses swiftest module_swiftest module_fxdr module_interfaces proc~~io_dump_tp~~UsesGraph proc~io_dump_tp io_dump_tp module~module_swiftest module_swiftest proc~io_dump_tp->module~module_swiftest module~module_fxdr module_fxdr proc~io_dump_tp->module~module_fxdr module~swiftest swiftest proc~io_dump_tp->module~swiftest module~module_interfaces module_interfaces proc~io_dump_tp->module~module_interfaces module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp type( swiftest_tp ), intent(inout) :: swiftest_tpA Calls proc~~io_dump_tp~~CallsGraph proc~io_dump_tp io_dump_tp interface~ixdrclose ixdrclose proc~io_dump_tp->interface~ixdrclose interface~ixdrint ixdrint proc~io_dump_tp->interface~ixdrint dump_tp_file dump_tp_file proc~io_dump_tp->dump_tp_file interface~util_exit util_exit proc~io_dump_tp->interface~util_exit interface~ixdrdmat ixdrdmat proc~io_dump_tp->interface~ixdrdmat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_dump_tp.html"},{"title":"io_dump_param – swiftest","text":"subroutine io_dump_param(nplmax, ntpmax, ntp, t, tstop, dt, in_type, istep_out, outfile, out_type, out_form, istep_dump, j2rp2, j4rp4, rmin, rmax, rmaxu, qmin, qmin_coord, qmin_alo, qmin_ahi, encounter_file, mtiny, feature, ring_outfile) Uses swiftest module_interfaces proc~~io_dump_param~~UsesGraph proc~io_dump_param io_dump_param module~swiftest swiftest proc~io_dump_param->module~swiftest module~module_interfaces module_interfaces proc~io_dump_param->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntpmax integer(kind=I4B), intent(in) :: ntp real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: tstop real(kind=DP), intent(in) :: dt character(len=*), intent(in) :: in_type integer(kind=I4B), intent(in) :: istep_out character(len=*), intent(in) :: outfile character(len=*), intent(in) :: out_type character(len=*), intent(in) :: out_form integer(kind=I4B), intent(in) :: istep_dump real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: rmin real(kind=DP), intent(in) :: rmax real(kind=DP), intent(in) :: rmaxu real(kind=DP), intent(in) :: qmin character(len=*), intent(in) :: qmin_coord real(kind=DP), intent(in) :: qmin_alo real(kind=DP), intent(in) :: qmin_ahi character(len=*), intent(in) :: encounter_file real(kind=DP), intent(out), optional :: mtiny type( feature_list ), intent(out) :: feature character(len=*), intent(out), optional :: ring_outfile Calls proc~~io_dump_param~~CallsGraph proc~io_dump_param io_dump_param dump_tp_file dump_tp_file proc~io_dump_param->dump_tp_file dump_param_file dump_param_file proc~io_dump_param->dump_param_file dump_pl_file dump_pl_file proc~io_dump_param->dump_pl_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_dump_param.html"},{"title":"python_io_write_frame_tp – swiftest","text":"subroutine python_io_write_frame_tp(t, symba_tpA, ntp, out_stat) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~python_io_write_frame_tp~~UsesGraph proc~python_io_write_frame_tp python_io_write_frame_tp module~module_helio module_helio proc~python_io_write_frame_tp->module~module_helio module~module_symba module_symba proc~python_io_write_frame_tp->module~module_symba module~module_interfaces module_interfaces proc~python_io_write_frame_tp->module~module_interfaces module~swiftest swiftest proc~python_io_write_frame_tp->module~swiftest module~module_swiftest module_swiftest proc~python_io_write_frame_tp->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t type( symba_tp ), intent(in) :: symba_tpA integer, intent(in) :: ntp character(len=*), intent(in) :: out_stat Calls proc~~python_io_write_frame_tp~~CallsGraph proc~python_io_write_frame_tp python_io_write_frame_tp interface~util_exit util_exit proc~python_io_write_frame_tp->interface~util_exit interface~io_open io_open proc~python_io_write_frame_tp->interface~io_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/python_io_write_frame_tp.html"},{"title":"io_write_hdr – swiftest","text":"subroutine io_write_hdr(iu, t, npl, ntp, iout_form, out_type) Uses swiftest module_fxdr module_interfaces proc~~io_write_hdr~~UsesGraph proc~io_write_hdr io_write_hdr module~module_fxdr module_fxdr proc~io_write_hdr->module~module_fxdr module~swiftest swiftest proc~io_write_hdr->module~swiftest module~module_interfaces module_interfaces proc~io_write_hdr->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: iout_form character(len=*), intent(in) :: out_type Calls proc~~io_write_hdr~~CallsGraph proc~io_write_hdr io_write_hdr interface~ixdrreal ixdrreal proc~io_write_hdr->interface~ixdrreal interface~ixdrimat ixdrimat proc~io_write_hdr->interface~ixdrimat interface~util_exit util_exit proc~io_write_hdr->interface~util_exit interface~ixdrdouble ixdrdouble proc~io_write_hdr->interface~ixdrdouble Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_write_hdr.html"},{"title":"io_open – swiftest","text":"subroutine io_open(iu, fname, fopenstat, fmt, ierr) Uses swiftest module_interfaces proc~~io_open~~UsesGraph proc~io_open io_open module~swiftest swiftest proc~io_open->module~swiftest module~module_interfaces module_interfaces proc~io_open->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu character(len=*), intent(in) :: fname character(len=*), intent(in) :: fopenstat character(len=*), intent(in) :: fmt integer(kind=I4B), intent(out) :: ierr Calls proc~~io_open~~CallsGraph proc~io_open io_open interface~util_toupper util_toupper proc~io_open->interface~util_toupper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_open.html"},{"title":"io_open_fxdr – swiftest","text":"subroutine io_open_fxdr(fname, fopenstat, lflag, iu, ierr) Uses swiftest module_fxdr module_interfaces proc~~io_open_fxdr~~UsesGraph proc~io_open_fxdr io_open_fxdr module~module_fxdr module_fxdr proc~io_open_fxdr->module~module_fxdr module~swiftest swiftest proc~io_open_fxdr->module~swiftest module~module_interfaces module_interfaces proc~io_open_fxdr->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname character(len=1), intent(in) :: fopenstat logical(kind=LGT), intent(in) :: lflag integer(kind=I4B), intent(out) :: iu integer(kind=I4B), intent(out) :: ierr Calls proc~~io_open_fxdr~~CallsGraph proc~io_open_fxdr io_open_fxdr interface~initxdr initxdr proc~io_open_fxdr->interface~initxdr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_open_fxdr.html"},{"title":"io_init_tp – swiftest","text":"subroutine io_init_tp(intpfile, in_type, ntp, symba_tpA) Uses swiftest module_symba module_helio module_swiftest module_fxdr module_interfaces proc~~io_init_tp~~UsesGraph proc~io_init_tp io_init_tp module~module_helio module_helio proc~io_init_tp->module~module_helio module~module_symba module_symba proc~io_init_tp->module~module_symba module~module_interfaces module_interfaces proc~io_init_tp->module~module_interfaces module~module_fxdr module_fxdr proc~io_init_tp->module~module_fxdr module~swiftest swiftest proc~io_init_tp->module~swiftest module~module_swiftest module_swiftest proc~io_init_tp->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: intpfile character(len=*), intent(in) :: in_type integer(kind=I4B), intent(in) :: ntp type( symba_tp ), intent(inout) :: symba_tpA Calls proc~~io_init_tp~~CallsGraph proc~io_init_tp io_init_tp interface~ixdrclose ixdrclose proc~io_init_tp->interface~ixdrclose interface~ixdrint ixdrint proc~io_init_tp->interface~ixdrint interface~io_open_fxdr io_open_fxdr proc~io_init_tp->interface~io_open_fxdr interface~io_open io_open proc~io_init_tp->interface~io_open interface~ixdrdmat ixdrdmat proc~io_init_tp->interface~ixdrdmat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_init_tp.html"},{"title":"io_dump_pl – swiftest","text":"subroutine io_dump_pl(npl, swiftest_plA, lclose, lrhill_present) Uses swiftest module_swiftest module_fxdr module_interfaces proc~~io_dump_pl~~UsesGraph proc~io_dump_pl io_dump_pl module~module_swiftest module_swiftest proc~io_dump_pl->module~module_swiftest module~module_fxdr module_fxdr proc~io_dump_pl->module~module_fxdr module~swiftest swiftest proc~io_dump_pl->module~swiftest module~module_interfaces module_interfaces proc~io_dump_pl->module~module_interfaces module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type( swiftest_pl ), intent(inout) :: swiftest_plA logical(kind=LGT), intent(in) :: lclose logical(kind=LGT), intent(in) :: lrhill_present Calls proc~~io_dump_pl~~CallsGraph proc~io_dump_pl io_dump_pl interface~ixdrclose ixdrclose proc~io_dump_pl->interface~ixdrclose interface~ixdrint ixdrint proc~io_dump_pl->interface~ixdrint dump_pl_file dump_pl_file proc~io_dump_pl->dump_pl_file interface~ixdrdouble ixdrdouble proc~io_dump_pl->interface~ixdrdouble interface~util_exit util_exit proc~io_dump_pl->interface~util_exit interface~ixdrdmat ixdrdmat proc~io_dump_pl->interface~ixdrdmat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_dump_pl.html"},{"title":"io_getn – swiftest","text":"subroutine io_getn(inplfile, intpfile, in_type, npl, nplmax, ntp, ntpmax) Uses swiftest module_fxdr module_interfaces proc~~io_getn~~UsesGraph proc~io_getn io_getn module~module_fxdr module_fxdr proc~io_getn->module~module_fxdr module~swiftest swiftest proc~io_getn->module~swiftest module~module_interfaces module_interfaces proc~io_getn->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: inplfile character(len=*), intent(in) :: intpfile character(len=*), intent(in) :: in_type integer(kind=I4B), intent(out) :: npl integer(kind=I4B), intent(inout) :: nplmax integer(kind=I4B), intent(out) :: ntp integer(kind=I4B), intent(inout) :: ntpmax Calls proc~~io_getn~~CallsGraph proc~io_getn io_getn interface~ixdrclose ixdrclose proc~io_getn->interface~ixdrclose interface~ixdrint ixdrint proc~io_getn->interface~ixdrint interface~util_exit util_exit proc~io_getn->interface~util_exit interface~io_open_fxdr io_open_fxdr proc~io_getn->interface~io_open_fxdr interface~io_open io_open proc~io_getn->interface~io_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_getn.html"},{"title":"io_read_encounter – swiftest","text":"function io_read_encounter(t, name1, name2, mass1, mass2, xh1, xh2, vh1, vh2, encounter_file, out_type) Uses swiftest module_fxdr module_interfaces proc~~io_read_encounter~~UsesGraph proc~io_read_encounter io_read_encounter module~module_fxdr module_fxdr proc~io_read_encounter->module~module_fxdr module~swiftest swiftest proc~io_read_encounter->module~swiftest module~module_interfaces module_interfaces proc~io_read_encounter->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(out) :: t integer(kind=I4B), intent(out) :: name1 integer(kind=I4B), intent(out) :: name2 real(kind=DP), intent(out) :: mass1 real(kind=DP), intent(out) :: mass2 real(kind=DP), intent(out), DIMENSION(NDIM) :: xh1 real(kind=DP), intent(out), DIMENSION(NDIM) :: xh2 real(kind=DP), intent(out), DIMENSION(NDIM) :: vh1 real(kind=DP), intent(out), DIMENSION(NDIM) :: vh2 character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type Return Value integer(kind=I4B) Calls proc~~io_read_encounter~~CallsGraph proc~io_read_encounter io_read_encounter interface~ixdrclose ixdrclose proc~io_read_encounter->interface~ixdrclose interface~ixdrdouble ixdrdouble proc~io_read_encounter->interface~ixdrdouble interface~io_read_line io_read_line proc~io_read_encounter->interface~io_read_line interface~util_exit util_exit proc~io_read_encounter->interface~util_exit interface~io_open_fxdr io_open_fxdr proc~io_read_encounter->interface~io_open_fxdr interface~io_open io_open proc~io_read_encounter->interface~io_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_encounter.html"},{"title":"io_write_encounter – swiftest","text":"subroutine io_write_encounter(t, name1, name2, mass1, mass2, radius1, radius2, xh1, xh2, vh1, vh2, encounter_file, out_type) Uses swiftest module_fxdr module_interfaces proc~~io_write_encounter~~UsesGraph proc~io_write_encounter io_write_encounter module~module_fxdr module_fxdr proc~io_write_encounter->module~module_fxdr module~swiftest swiftest proc~io_write_encounter->module~swiftest module~module_interfaces module_interfaces proc~io_write_encounter->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: name1 integer(kind=I4B), intent(in) :: name2 real(kind=DP), intent(in) :: mass1 real(kind=DP), intent(in) :: mass2 real(kind=DP), intent(in) :: radius1 real(kind=DP), intent(in) :: radius2 real(kind=DP), intent(in), DIMENSION(NDIM) :: xh1 real(kind=DP), intent(in), DIMENSION(NDIM) :: xh2 real(kind=DP), intent(in), DIMENSION(NDIM) :: vh1 real(kind=DP), intent(in), DIMENSION(NDIM) :: vh2 character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type Calls proc~~io_write_encounter~~CallsGraph proc~io_write_encounter io_write_encounter interface~ixdrclose ixdrclose proc~io_write_encounter->interface~ixdrclose interface~ixdrdouble ixdrdouble proc~io_write_encounter->interface~ixdrdouble interface~util_exit util_exit proc~io_write_encounter->interface~util_exit interface~io_open_fxdr io_open_fxdr proc~io_write_encounter->interface~io_open_fxdr interface~io_open io_open proc~io_write_encounter->interface~io_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_write_encounter.html"},{"title":"io_write_line – swiftest","text":"subroutine io_write_line(iu, name, d1, d2, d3, d4, d5, d6, out_type, MASS, RADIUS) Uses swiftest module_fxdr module_interfaces proc~~io_write_line~~UsesGraph proc~io_write_line io_write_line module~module_fxdr module_fxdr proc~io_write_line->module~module_fxdr module~swiftest swiftest proc~io_write_line->module~swiftest module~module_interfaces module_interfaces proc~io_write_line->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu integer(kind=I4B), intent(in) :: name real(kind=DP), intent(in) :: d1 real(kind=DP), intent(in) :: d2 real(kind=DP), intent(in) :: d3 real(kind=DP), intent(in) :: d4 real(kind=DP), intent(in) :: d5 real(kind=DP), intent(in) :: d6 character(len=*), intent(in) :: out_type real(kind=DP), intent(in), optional :: MASS real(kind=DP), intent(in), optional :: RADIUS Calls proc~~io_write_line~~CallsGraph proc~io_write_line io_write_line interface~ixdrreal ixdrreal proc~io_write_line->interface~ixdrreal interface~ixdrint ixdrint proc~io_write_line->interface~ixdrint interface~ixdrdouble ixdrdouble proc~io_write_line->interface~ixdrdouble interface~util_exit util_exit proc~io_write_line->interface~util_exit interface~ixdrdmat ixdrdmat proc~io_write_line->interface~ixdrdmat interface~ixdrrmat ixdrrmat proc~io_write_line->interface~ixdrrmat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_write_line.html"},{"title":"io_read_hdr – swiftest","text":"function io_read_hdr(iu, t, npl, ntp, iout_form, out_type) Uses swiftest module_fxdr module_interfaces proc~~io_read_hdr~~UsesGraph proc~io_read_hdr io_read_hdr module~module_fxdr module_fxdr proc~io_read_hdr->module~module_fxdr module~swiftest swiftest proc~io_read_hdr->module~swiftest module~module_interfaces module_interfaces proc~io_read_hdr->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu real(kind=DP), intent(out) :: t integer(kind=I4B), intent(out) :: npl integer(kind=I4B), intent(out) :: ntp integer(kind=I4B), intent(out) :: iout_form character(len=*), intent(in) :: out_type Return Value integer(kind=I4B) Calls proc~~io_read_hdr~~CallsGraph proc~io_read_hdr io_read_hdr interface~ixdrreal ixdrreal proc~io_read_hdr->interface~ixdrreal interface~ixdrimat ixdrimat proc~io_read_hdr->interface~ixdrimat interface~ixdrdouble ixdrdouble proc~io_read_hdr->interface~ixdrdouble Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_hdr.html"},{"title":"io_discard_write_symba – swiftest","text":"subroutine io_discard_write_symba(t, mtiny, npl, ntp, nsppl, nsptp, nmergeadd, symba_plA, discard_plA, discard_tpA, mergeadd_list, mergesub_list, fname, lbig_discard) Uses swiftest module_swiftest module_symba module_interfaces proc~~io_discard_write_symba~~UsesGraph proc~io_discard_write_symba io_discard_write_symba module~module_swiftest module_swiftest proc~io_discard_write_symba->module~module_swiftest module~module_symba module_symba proc~io_discard_write_symba->module~module_symba module~swiftest swiftest proc~io_discard_write_symba->module~swiftest module~module_interfaces module_interfaces proc~io_discard_write_symba->module~module_interfaces module~module_swiftest->module~swiftest module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~module_swiftest module~module_helio->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: mtiny integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: nsppl integer(kind=I4B), intent(in) :: nsptp integer(kind=I4B), intent(in) :: nmergeadd type( symba_pl ), intent(inout) :: symba_plA type( swiftest_pl ), intent(inout) :: discard_plA type( swiftest_tp ), intent(inout) :: discard_tpA type( symba_merger ), intent(inout) :: mergeadd_list type( symba_merger ), intent(inout) :: mergesub_list character(len=*), intent(in) :: fname logical(kind=LGT), intent(in) :: lbig_discard Calls proc~~io_discard_write_symba~~CallsGraph proc~io_discard_write_symba io_discard_write_symba 2 2 proc~io_discard_write_symba->2 interface~util_exit util_exit proc~io_discard_write_symba->interface~util_exit interface~io_open io_open proc~io_discard_write_symba->interface~io_open 3 3 proc~io_discard_write_symba->3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_discard_write_symba.html"},{"title":"io_write_frame – swiftest","text":"subroutine io_write_frame(t, npl, ntp, swiftest_plA, swiftest_tpA, outfile, out_type, out_form, out_stat) Uses swiftest module_swiftest module_fxdr module_interfaces proc~~io_write_frame~~UsesGraph proc~io_write_frame io_write_frame module~module_swiftest module_swiftest proc~io_write_frame->module~module_swiftest module~module_fxdr module_fxdr proc~io_write_frame->module~module_fxdr module~swiftest swiftest proc~io_write_frame->module~swiftest module~module_interfaces module_interfaces proc~io_write_frame->module~module_interfaces module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp type( swiftest_pl ), intent(inout) :: swiftest_plA type( swiftest_tp ), intent(inout) :: swiftest_tpA character(len=*), intent(in) :: outfile character(len=*), intent(in) :: out_type character(len=*), intent(in) :: out_form character(len=*), intent(in) :: out_stat Calls proc~~io_write_frame~~CallsGraph proc~io_write_frame io_write_frame interface~orbel_xv2el orbel_xv2el proc~io_write_frame->interface~orbel_xv2el interface~io_write_hdr io_write_hdr proc~io_write_frame->interface~io_write_hdr interface~ixdrclose ixdrclose proc~io_write_frame->interface~ixdrclose interface~io_write_line io_write_line proc~io_write_frame->interface~io_write_line interface~util_exit util_exit proc~io_write_frame->interface~util_exit interface~io_open_fxdr io_open_fxdr proc~io_write_frame->interface~io_open_fxdr interface~io_open io_open proc~io_write_frame->interface~io_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_write_frame.html"},{"title":"drift_kepmd – swiftest","text":"subroutine drift_kepmd(dm, es, ec, x, s, c) Uses swiftest module_interfaces proc~~drift_kepmd~~UsesGraph proc~drift_kepmd drift_kepmd module~swiftest swiftest proc~drift_kepmd->module~swiftest module~module_interfaces module_interfaces proc~drift_kepmd->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dm real(kind=DP), intent(in) :: es real(kind=DP), intent(in) :: ec real(kind=DP), intent(out) :: x real(kind=DP), intent(out) :: s real(kind=DP), intent(out) :: c Contents None","tags":"","loc":"proc/drift_kepmd.html"},{"title":"drift_kepu_guess – swiftest","text":"subroutine drift_kepu_guess(dt, r0, mu, alpha, u, s) Uses swiftest module_interfaces proc~~drift_kepu_guess~~UsesGraph proc~drift_kepu_guess drift_kepu_guess module~swiftest swiftest proc~drift_kepu_guess->module~swiftest module~module_interfaces module_interfaces proc~drift_kepu_guess->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: s Calls proc~~drift_kepu_guess~~CallsGraph proc~drift_kepu_guess drift_kepu_guess interface~orbel_scget orbel_scget proc~drift_kepu_guess->interface~orbel_scget interface~drift_kepu_p3solve drift_kepu_p3solve proc~drift_kepu_guess->interface~drift_kepu_p3solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_kepu_guess.html"},{"title":"drift_kepu_stumpff – swiftest","text":"subroutine drift_kepu_stumpff(x, c0, c1, c2, c3) Uses swiftest module_interfaces proc~~drift_kepu_stumpff~~UsesGraph proc~drift_kepu_stumpff drift_kepu_stumpff module~swiftest swiftest proc~drift_kepu_stumpff->module~swiftest module~module_interfaces module_interfaces proc~drift_kepu_stumpff->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout) :: x real(kind=DP), intent(out) :: c0 real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 Contents None","tags":"","loc":"proc/drift_kepu_stumpff.html"},{"title":"drift_kepu – swiftest","text":"subroutine drift_kepu(dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Uses swiftest module_interfaces proc~~drift_kepu~~UsesGraph proc~drift_kepu drift_kepu module~swiftest swiftest proc~drift_kepu->module~swiftest module~module_interfaces module_interfaces proc~drift_kepu->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: fp real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 integer(kind=I4B), intent(out) :: iflag Calls proc~~drift_kepu~~CallsGraph proc~drift_kepu drift_kepu interface~drift_kepu_new drift_kepu_new proc~drift_kepu->interface~drift_kepu_new interface~drift_kepu_guess drift_kepu_guess proc~drift_kepu->interface~drift_kepu_guess interface~drift_kepu_fchk drift_kepu_fchk proc~drift_kepu->interface~drift_kepu_fchk interface~drift_kepu_lag drift_kepu_lag proc~drift_kepu->interface~drift_kepu_lag Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_kepu.html"},{"title":"drift_kepu_new – swiftest","text":"subroutine drift_kepu_new(s, dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Uses swiftest module_interfaces proc~~drift_kepu_new~~UsesGraph proc~drift_kepu_new drift_kepu_new module~swiftest swiftest proc~drift_kepu_new->module~swiftest module~module_interfaces module_interfaces proc~drift_kepu_new->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout) :: s real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: fp real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 integer(kind=I4B), intent(out) :: iflag Calls proc~~drift_kepu_new~~CallsGraph proc~drift_kepu_new drift_kepu_new interface~drift_kepu_stumpff drift_kepu_stumpff proc~drift_kepu_new->interface~drift_kepu_stumpff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_kepu_new.html"},{"title":"drift_dan – swiftest","text":"subroutine drift_dan(mu, x0, v0, dt0, iflag) Uses swiftest module_interfaces proc~~drift_dan~~UsesGraph proc~drift_dan drift_dan module~swiftest swiftest proc~drift_dan->module~swiftest module~module_interfaces module_interfaces proc~drift_dan->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu real(kind=DP), intent(inout), DIMENSION(NDIM) :: x0 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v0 real(kind=DP), intent(in) :: dt0 integer(kind=I4B), intent(out) :: iflag Calls proc~~drift_dan~~CallsGraph proc~drift_dan drift_dan interface~drift_kepu drift_kepu proc~drift_dan->interface~drift_kepu interface~drift_kepmd drift_kepmd proc~drift_dan->interface~drift_kepmd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_dan.html"},{"title":"drift_kepu_p3solve – swiftest","text":"subroutine drift_kepu_p3solve(dt, r0, mu, alpha, u, s, iflag) Uses swiftest module_interfaces proc~~drift_kepu_p3solve~~UsesGraph proc~drift_kepu_p3solve drift_kepu_p3solve module~swiftest swiftest proc~drift_kepu_p3solve->module~swiftest module~module_interfaces module_interfaces proc~drift_kepu_p3solve->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: s integer(kind=I4B), intent(out) :: iflag Contents None","tags":"","loc":"proc/drift_kepu_p3solve.html"},{"title":"drift_one – swiftest","text":"subroutine drift_one(mu, x, v, dt, iflag) Uses swiftest module_interfaces proc~~drift_one~~UsesGraph proc~drift_one drift_one module~swiftest swiftest proc~drift_one->module~swiftest module~module_interfaces module_interfaces proc~drift_one->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu real(kind=DP), intent(inout), DIMENSION(NDIM) :: x real(kind=DP), intent(inout), DIMENSION(NDIM) :: v real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(out) :: iflag Contents None","tags":"","loc":"proc/drift_one.html"},{"title":"drift_kepu_fchk – swiftest","text":"subroutine drift_kepu_fchk(dt, r0, mu, alpha, u, s, f) Uses swiftest module_interfaces proc~~drift_kepu_fchk~~UsesGraph proc~drift_kepu_fchk drift_kepu_fchk module~swiftest swiftest proc~drift_kepu_fchk->module~swiftest module~module_interfaces module_interfaces proc~drift_kepu_fchk->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(in) :: s real(kind=DP), intent(out) :: f Calls proc~~drift_kepu_fchk~~CallsGraph proc~drift_kepu_fchk drift_kepu_fchk interface~drift_kepu_stumpff drift_kepu_stumpff proc~drift_kepu_fchk->interface~drift_kepu_stumpff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_kepu_fchk.html"},{"title":"drift_kepu_lag – swiftest","text":"subroutine drift_kepu_lag(s, dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Uses swiftest module_interfaces proc~~drift_kepu_lag~~UsesGraph proc~drift_kepu_lag drift_kepu_lag module~swiftest swiftest proc~drift_kepu_lag->module~swiftest module~module_interfaces module_interfaces proc~drift_kepu_lag->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout) :: s real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: fp real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 integer(kind=I4B), intent(out) :: iflag Calls proc~~drift_kepu_lag~~CallsGraph proc~drift_kepu_lag drift_kepu_lag interface~drift_kepu_stumpff drift_kepu_stumpff proc~drift_kepu_lag->interface~drift_kepu_stumpff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_kepu_lag.html"},{"title":"symba_discard_peri_pl – swiftest","text":"subroutine symba_discard_peri_pl(t, npl, symba_plA, msys, qmin, qmin_alo, qmin_ahi, qmin_coord, ldiscards) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_discard_peri_pl~~UsesGraph proc~symba_discard_peri_pl symba_discard_peri_pl module~module_helio module_helio proc~symba_discard_peri_pl->module~module_helio module~module_symba module_symba proc~symba_discard_peri_pl->module~module_symba module~module_interfaces module_interfaces proc~symba_discard_peri_pl->module~module_interfaces module~swiftest swiftest proc~symba_discard_peri_pl->module~swiftest module~module_swiftest module_swiftest proc~symba_discard_peri_pl->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl type( symba_pl ), intent(inout) :: symba_plA real(kind=DP), intent(in) :: msys real(kind=DP), intent(in) :: qmin real(kind=DP), intent(in) :: qmin_alo real(kind=DP), intent(in) :: qmin_ahi character(len=*), intent(in) :: qmin_coord logical(kind=LGT), intent(inout) :: ldiscards Calls proc~~symba_discard_peri_pl~~CallsGraph proc~symba_discard_peri_pl symba_discard_peri_pl interface~symba_peri symba_peri proc~symba_discard_peri_pl->interface~symba_peri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_discard_peri_pl.html"},{"title":"symba_step_helio_pl – swiftest","text":"subroutine symba_step_helio_pl(lfirst, lextra_force, t, npl, nplm, nplmax, helio_plA, j2rp2, j4rp4, dt, xbeg, xend, ptb, pte) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_step_helio_pl~~UsesGraph proc~symba_step_helio_pl symba_step_helio_pl module~module_helio module_helio proc~symba_step_helio_pl->module~module_helio module~module_symba module_symba proc~symba_step_helio_pl->module~module_symba module~module_interfaces module_interfaces proc~symba_step_helio_pl->module~module_interfaces module~swiftest swiftest proc~symba_step_helio_pl->module~swiftest module~module_swiftest module_swiftest proc~symba_step_helio_pl->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(inout) :: lfirst logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm integer(kind=I4B), intent(in) :: nplmax type( helio_pl ), intent(inout) :: helio_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: dt real(kind=DP), intent(out), DIMENSION(NDIM, nplm) :: xbeg real(kind=DP), intent(out), DIMENSION(NDIM, nplm) :: xend real(kind=DP), intent(out), DIMENSION(NDIM) :: ptb real(kind=DP), intent(out), DIMENSION(NDIM) :: pte Calls proc~~symba_step_helio_pl~~CallsGraph proc~symba_step_helio_pl symba_step_helio_pl interface~helio_kickvb helio_kickvb proc~symba_step_helio_pl->interface~helio_kickvb interface~coord_vb2vh coord_vb2vh proc~symba_step_helio_pl->interface~coord_vb2vh interface~helio_drift helio_drift proc~symba_step_helio_pl->interface~helio_drift interface~coord_vh2vb coord_vh2vb proc~symba_step_helio_pl->interface~coord_vh2vb interface~helio_lindrift helio_lindrift proc~symba_step_helio_pl->interface~helio_lindrift interface~symba_helio_getacch symba_helio_getacch proc~symba_step_helio_pl->interface~symba_helio_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_step_helio_pl.html"},{"title":"symba_casedisruption – swiftest","text":"subroutine symba_casedisruption(t, dt, index_enc, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, vbs, symba_plA, nplplenc, plplenc_list, nplmax, ntpmax, fragmax, mres, rres, m1, m2, rad1, rad2, x1, x2, v1, v2) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_casedisruption~~UsesGraph proc~symba_casedisruption symba_casedisruption module~module_helio module_helio proc~symba_casedisruption->module~module_helio module~module_symba module_symba proc~symba_casedisruption->module~module_symba module~module_interfaces module_interfaces proc~symba_casedisruption->module~module_interfaces module~swiftest swiftest proc~symba_casedisruption->module~swiftest module~module_swiftest module_swiftest proc~symba_casedisruption->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type( symba_merger ), intent(inout) :: mergeadd_list type( symba_merger ), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs type( symba_pl ), intent(inout) :: symba_plA integer(kind=I4B), intent(inout) :: nplplenc type( symba_plplenc ), intent(inout) :: plplenc_list integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntpmax integer(kind=I4B), intent(inout) :: fragmax real(kind=DP), intent(inout), DIMENSION(3) :: mres real(kind=DP), intent(inout), DIMENSION(3) :: rres real(kind=DP), intent(inout) :: m1 real(kind=DP), intent(inout) :: m2 real(kind=DP), intent(inout) :: rad1 real(kind=DP), intent(inout) :: rad2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v2 Calls proc~~symba_casedisruption~~CallsGraph proc~symba_casedisruption symba_casedisruption interface~orbel_xv2aeq orbel_xv2aeq proc~symba_casedisruption->interface~orbel_xv2aeq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_casedisruption.html"},{"title":"symba_rearray – swiftest","text":"subroutine symba_rearray(npl, ntp, nsppl, nsptp, symba_plA, symba_tpA, nmergeadd, mergeadd_list, discard_plA, discard_tpA, feature) Uses swiftest module_swiftestalloc module_swiftest module_helio module_symba module_interfaces proc~~symba_rearray~~UsesGraph proc~symba_rearray symba_rearray module~module_helio module_helio proc~symba_rearray->module~module_helio module~module_symba module_symba proc~symba_rearray->module~module_symba module~module_interfaces module_interfaces proc~symba_rearray->module~module_interfaces module~swiftest swiftest proc~symba_rearray->module~swiftest module~module_swiftest module_swiftest proc~symba_rearray->module~module_swiftest module~module_swiftestalloc module_swiftestalloc proc~symba_rearray->module~module_swiftestalloc module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest module~module_swiftestalloc->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: npl integer(kind=I4B), intent(inout) :: ntp integer(kind=I4B), intent(inout) :: nsppl integer(kind=I4B), intent(inout) :: nsptp type( symba_pl ), intent(inout) :: symba_plA type( symba_tp ), intent(inout) :: symba_tpA integer(kind=I4B), intent(inout) :: nmergeadd type( symba_merger ), intent(inout) :: mergeadd_list type( swiftest_pl ), intent(inout) :: discard_plA type( swiftest_tp ), intent(inout) :: discard_tpA type( feature_list ), intent(in) :: feature Calls proc~~symba_rearray~~CallsGraph proc~symba_rearray symba_rearray interface~util_resize_pl util_resize_pl proc~symba_rearray->interface~util_resize_pl proc~swiftest_tp_allocate swiftest_tp_allocate proc~symba_rearray->proc~swiftest_tp_allocate proc~swiftest_pl_allocate swiftest_pl_allocate proc~symba_rearray->proc~swiftest_pl_allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_rearray.html"},{"title":"symba_user_getacch_tp – swiftest","text":"subroutine symba_user_getacch_tp(t, ntp, symba_tpA) Uses swiftest module_symba module_interfaces proc~~symba_user_getacch_tp~~UsesGraph proc~symba_user_getacch_tp symba_user_getacch_tp module~module_symba module_symba proc~symba_user_getacch_tp->module~module_symba module~swiftest swiftest proc~symba_user_getacch_tp->module~swiftest module~module_interfaces module_interfaces proc~symba_user_getacch_tp->module~module_interfaces module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: ntp type( symba_tp ), intent(inout) :: symba_tpA Contents None","tags":"","loc":"proc/symba_user_getacch_tp.html"},{"title":"symba_step_recur – swiftest","text":"subroutine symba_step_recur(lclose, t, ireci, npl, nplm, ntp, symba_plA, symba_tpA, dt0, eoffset, nplplenc, npltpenc, plplenc_list, pltpenc_list, nmergeadd, nmergesub, mergeadd_list, mergesub_list, encounter_file, out_type, nplmax, ntpmax, fragmax, feature) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_step_recur~~UsesGraph proc~symba_step_recur symba_step_recur module~module_helio module_helio proc~symba_step_recur->module~module_helio module~module_symba module_symba proc~symba_step_recur->module~module_symba module~module_interfaces module_interfaces proc~symba_step_recur->module~module_interfaces module~swiftest swiftest proc~symba_step_recur->module~swiftest module~module_swiftest module_swiftest proc~symba_step_recur->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lclose real(kind=DP), intent(in) :: t integer(kind=I4B), intent(inout) :: ireci integer(kind=I4B), intent(inout) :: npl integer(kind=I4B), intent(inout) :: nplm integer(kind=I4B), intent(inout) :: ntp type( symba_pl ), intent(inout) :: symba_plA type( symba_tp ), intent(inout) :: symba_tpA real(kind=DP), intent(in) :: dt0 real(kind=DP), intent(inout) :: eoffset integer(kind=I4B), intent(inout) :: nplplenc integer(kind=I4B), intent(inout) :: npltpenc type( symba_plplenc ), intent(inout) :: plplenc_list type( symba_pltpenc ), intent(inout) :: pltpenc_list integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type( symba_merger ), intent(inout) :: mergeadd_list type( symba_merger ), intent(inout) :: mergesub_list character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type integer(kind=I4B), intent(inout) :: nplmax integer(kind=I4B), intent(inout) :: ntpmax integer(kind=I4B), intent(inout) :: fragmax type( feature_list ), intent(in) :: feature Calls proc~~symba_step_recur~~CallsGraph proc~symba_step_recur symba_step_recur interface~symba_merge_tp symba_merge_tp proc~symba_step_recur->interface~symba_merge_tp interface~symba_merge_pl symba_merge_pl proc~symba_step_recur->interface~symba_merge_pl interface~symba_kick symba_kick proc~symba_step_recur->interface~symba_kick interface~symba_helio_drift symba_helio_drift proc~symba_step_recur->interface~symba_helio_drift interface~symba_fragmentation symba_fragmentation proc~symba_step_recur->interface~symba_fragmentation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_step_recur.html"},{"title":"symba_user_getacch – swiftest","text":"subroutine symba_user_getacch(t, npl, symba_plA) Uses swiftest module_symba module_interfaces proc~~symba_user_getacch~~UsesGraph proc~symba_user_getacch symba_user_getacch module~module_symba module_symba proc~symba_user_getacch->module~module_symba module~swiftest swiftest proc~symba_user_getacch->module~swiftest module~module_interfaces module_interfaces proc~symba_user_getacch->module~module_interfaces module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl type( symba_pl ), intent(inout) :: symba_plA Contents None","tags":"","loc":"proc/symba_user_getacch.html"},{"title":"symba_casehitandrun – swiftest","text":"subroutine symba_casehitandrun(t, index_enc, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, vbs, symba_plA, nplplenc, plplenc_list, nplmax, ntpmax, fragmax, mres, rres, m1, m2, rad1, rad2, x1, x2, v1, v2) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_casehitandrun~~UsesGraph proc~symba_casehitandrun symba_casehitandrun module~module_helio module_helio proc~symba_casehitandrun->module~module_helio module~module_symba module_symba proc~symba_casehitandrun->module~module_symba module~module_interfaces module_interfaces proc~symba_casehitandrun->module~module_interfaces module~swiftest swiftest proc~symba_casehitandrun->module~swiftest module~module_swiftest module_swiftest proc~symba_casehitandrun->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type( symba_merger ), intent(inout) :: mergeadd_list type( symba_merger ), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs type( symba_pl ), intent(inout) :: symba_plA integer(kind=I4B), intent(inout) :: nplplenc type( symba_plplenc ), intent(inout) :: plplenc_list integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntpmax integer(kind=I4B), intent(inout) :: fragmax real(kind=DP), intent(inout), DIMENSION(3) :: mres real(kind=DP), intent(inout), DIMENSION(3) :: rres real(kind=DP), intent(inout) :: m1 real(kind=DP), intent(inout) :: m2 real(kind=DP), intent(inout) :: rad1 real(kind=DP), intent(inout) :: rad2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v2 Contents None","tags":"","loc":"proc/symba_casehitandrun.html"},{"title":"symba_step_helio – swiftest","text":"subroutine symba_step_helio(lfirst, lextra_force, t, npl, nplm, nplmax, ntp, ntpmax, helio_plA, helio_tpA, j2rp2, j4rp4, dt) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_step_helio~~UsesGraph proc~symba_step_helio symba_step_helio module~module_helio module_helio proc~symba_step_helio->module~module_helio module~module_symba module_symba proc~symba_step_helio->module~module_symba module~module_interfaces module_interfaces proc~symba_step_helio->module~module_interfaces module~swiftest swiftest proc~symba_step_helio->module~swiftest module~module_swiftest module_swiftest proc~symba_step_helio->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(inout) :: lfirst logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: ntpmax type( helio_pl ), intent(inout) :: helio_plA type( helio_tp ), intent(inout) :: helio_tpA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: dt Calls proc~~symba_step_helio~~CallsGraph proc~symba_step_helio symba_step_helio interface~symba_step_helio_pl symba_step_helio_pl proc~symba_step_helio->interface~symba_step_helio_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_step_helio.html"},{"title":"symba_discard_sun_pl – swiftest","text":"subroutine symba_discard_sun_pl(t, npl, msys, swiftest_plA, rmin, rmax, rmaxu, ldiscards) Uses swiftest module_swiftest module_interfaces proc~~symba_discard_sun_pl~~UsesGraph proc~symba_discard_sun_pl symba_discard_sun_pl module~module_swiftest module_swiftest proc~symba_discard_sun_pl->module~module_swiftest module~swiftest swiftest proc~symba_discard_sun_pl->module~swiftest module~module_interfaces module_interfaces proc~symba_discard_sun_pl->module~module_interfaces module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl real(kind=DP), intent(in) :: msys type( swiftest_pl ), intent(inout) :: swiftest_plA real(kind=DP), intent(in) :: rmin real(kind=DP), intent(in) :: rmax real(kind=DP), intent(in) :: rmaxu logical(kind=LGT), intent(inout) :: ldiscards Contents None","tags":"","loc":"proc/symba_discard_sun_pl.html"},{"title":"symba_reorder_pl – swiftest","text":"subroutine symba_reorder_pl(npl, symba_plA) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_reorder_pl~~UsesGraph proc~symba_reorder_pl symba_reorder_pl module~module_helio module_helio proc~symba_reorder_pl->module~module_helio module~module_symba module_symba proc~symba_reorder_pl->module~module_symba module~module_interfaces module_interfaces proc~symba_reorder_pl->module~module_interfaces module~swiftest swiftest proc~symba_reorder_pl->module~swiftest module~module_swiftest module_swiftest proc~symba_reorder_pl->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type( symba_pl ), intent(inout) :: symba_plA Calls proc~~symba_reorder_pl~~CallsGraph proc~symba_reorder_pl symba_reorder_pl interface~util_index util_index proc~symba_reorder_pl->interface~util_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_reorder_pl.html"},{"title":"symba_helio_drift – swiftest","text":"subroutine symba_helio_drift(irec, npl, symba_plA, dt) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_helio_drift~~UsesGraph proc~symba_helio_drift symba_helio_drift module~module_helio module_helio proc~symba_helio_drift->module~module_helio module~module_symba module_symba proc~symba_helio_drift->module~module_symba module~module_interfaces module_interfaces proc~symba_helio_drift->module~module_interfaces module~swiftest swiftest proc~symba_helio_drift->module~swiftest module~module_swiftest module_swiftest proc~symba_helio_drift->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: irec integer(kind=I4B), intent(in) :: npl type( symba_pl ), intent(inout) :: symba_plA real(kind=DP), intent(in) :: dt Calls proc~~symba_helio_drift~~CallsGraph proc~symba_helio_drift symba_helio_drift interface~drift_one drift_one proc~symba_helio_drift->interface~drift_one interface~util_exit util_exit proc~symba_helio_drift->interface~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_helio_drift.html"},{"title":"symba_kick – swiftest","text":"subroutine symba_kick(irec, nplplenc, npltpenc, plplenc_list, pltpenc_list, dt, sgn, symba_plA, symba_tpA) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_kick~~UsesGraph proc~symba_kick symba_kick module~module_helio module_helio proc~symba_kick->module~module_helio module~module_symba module_symba proc~symba_kick->module~module_symba module~module_interfaces module_interfaces proc~symba_kick->module~module_interfaces module~swiftest swiftest proc~symba_kick->module~swiftest module~module_swiftest module_swiftest proc~symba_kick->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: irec integer(kind=I4B), intent(in) :: nplplenc integer(kind=I4B), intent(in) :: npltpenc type( symba_plplenc ), intent(in) :: plplenc_list type( symba_pltpenc ), intent(in) :: pltpenc_list real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: sgn type( symba_pl ), intent(inout) :: symba_plA type( symba_tp ), intent(inout) :: symba_tpA Contents None","tags":"","loc":"proc/symba_kick.html"},{"title":"symba_helio_getacch – swiftest","text":"subroutine symba_helio_getacch(lflag, lextra_force, t, npl, nplm, nplmax, helio_plA, j2rp2, j4rp4) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_helio_getacch~~UsesGraph proc~symba_helio_getacch symba_helio_getacch module~module_helio module_helio proc~symba_helio_getacch->module~module_helio module~module_symba module_symba proc~symba_helio_getacch->module~module_symba module~module_interfaces module_interfaces proc~symba_helio_getacch->module~module_interfaces module~swiftest swiftest proc~symba_helio_getacch->module~swiftest module~module_swiftest module_swiftest proc~symba_helio_getacch->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lflag logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm integer(kind=I4B), intent(in) :: nplmax type( helio_pl ), intent(inout) :: helio_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 Calls proc~~symba_helio_getacch~~CallsGraph proc~symba_helio_getacch symba_helio_getacch interface~symba_helio_getacch_int symba_helio_getacch_int proc~symba_helio_getacch->interface~symba_helio_getacch_int interface~obl_acc obl_acc proc~symba_helio_getacch->interface~obl_acc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_helio_getacch.html"},{"title":"symba_helio_drift_tp – swiftest","text":"subroutine symba_helio_drift_tp(irec, ntp, symba_tpA, mu, dt) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_helio_drift_tp~~UsesGraph proc~symba_helio_drift_tp symba_helio_drift_tp module~module_helio module_helio proc~symba_helio_drift_tp->module~module_helio module~module_symba module_symba proc~symba_helio_drift_tp->module~module_symba module~module_interfaces module_interfaces proc~symba_helio_drift_tp->module~module_interfaces module~swiftest swiftest proc~symba_helio_drift_tp->module~swiftest module~module_swiftest module_swiftest proc~symba_helio_drift_tp->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: irec integer(kind=I4B), intent(in) :: ntp type( symba_tp ), intent(inout) :: symba_tpA real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: dt Calls proc~~symba_helio_drift_tp~~CallsGraph proc~symba_helio_drift_tp symba_helio_drift_tp interface~drift_one drift_one proc~symba_helio_drift_tp->interface~drift_one Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_helio_drift_tp.html"},{"title":"symba_fragmentation – swiftest","text":"subroutine symba_fragmentation(t, dt, index_enc, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, vbs, encounter_file, out_type, npl, ntp, symba_plA, symba_tpA, nplplenc, npltpenc, pltpenc_list, plplenc_list, nplmax, ntpmax, fragmax) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_fragmentation~~UsesGraph proc~symba_fragmentation symba_fragmentation module~module_helio module_helio proc~symba_fragmentation->module~module_helio module~module_symba module_symba proc~symba_fragmentation->module~module_symba module~module_interfaces module_interfaces proc~symba_fragmentation->module~module_interfaces module~swiftest swiftest proc~symba_fragmentation->module~swiftest module~module_swiftest module_swiftest proc~symba_fragmentation->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type( symba_merger ), intent(inout) :: mergeadd_list type( symba_merger ), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type integer(kind=I4B), intent(inout) :: npl integer(kind=I4B), intent(inout) :: ntp type( symba_pl ), intent(inout) :: symba_plA type( symba_tp ), intent(inout) :: symba_tpA integer(kind=I4B), intent(inout) :: nplplenc integer(kind=I4B), intent(inout) :: npltpenc type( symba_pltpenc ), intent(inout) :: pltpenc_list type( symba_plplenc ), intent(inout) :: plplenc_list integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntpmax integer(kind=I4B), intent(inout) :: fragmax Calls proc~~symba_fragmentation~~CallsGraph proc~symba_fragmentation symba_fragmentation interface~symba_caseresolve symba_caseresolve proc~symba_fragmentation->interface~symba_caseresolve interface~collresolve_resolve collresolve_resolve proc~symba_fragmentation->interface~collresolve_resolve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_fragmentation.html"},{"title":"symba_discard_pl – swiftest","text":"subroutine symba_discard_pl(t, npl, nplmax, nsp, symba_plA, rmin, rmax, rmaxu, qmin, qmin_coord, qmin_alo, qmin_ahi, j2rp2, j4rp4, eoffset) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_discard_pl~~UsesGraph proc~symba_discard_pl symba_discard_pl module~module_helio module_helio proc~symba_discard_pl->module~module_helio module~module_symba module_symba proc~symba_discard_pl->module~module_symba module~module_interfaces module_interfaces proc~symba_discard_pl->module~module_interfaces module~swiftest swiftest proc~symba_discard_pl->module~swiftest module~module_swiftest module_swiftest proc~symba_discard_pl->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(inout) :: npl integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(inout) :: nsp type( symba_pl ) :: symba_plA real(kind=DP), intent(in) :: rmin real(kind=DP), intent(in) :: rmax real(kind=DP), intent(in) :: rmaxu real(kind=DP), intent(in) :: qmin character(len=*), intent(in) :: qmin_coord real(kind=DP), intent(in) :: qmin_alo real(kind=DP), intent(in) :: qmin_ahi real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(inout) :: eoffset Contents None","tags":"","loc":"proc/symba_discard_pl.html"},{"title":"symba_chk – swiftest","text":"subroutine symba_chk(xr, vr, rhill1, rhill2, dt, irec, lencounter, lvdotr) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_chk~~UsesGraph proc~symba_chk symba_chk module~module_helio module_helio proc~symba_chk->module~module_helio module~module_symba module_symba proc~symba_chk->module~module_symba module~module_interfaces module_interfaces proc~symba_chk->module~module_interfaces module~swiftest swiftest proc~symba_chk->module~swiftest module~module_swiftest module_swiftest proc~symba_chk->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: xr real(kind=DP), intent(in), DIMENSION(:) :: vr real(kind=DP), intent(in) :: rhill1 real(kind=DP), intent(in) :: rhill2 real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: irec logical(kind=LGT), intent(out) :: lencounter logical(kind=LGT), intent(out) :: lvdotr Contents None","tags":"","loc":"proc/symba_chk.html"},{"title":"symba_peri – swiftest","text":"subroutine symba_peri(lfirst, npl, symba_plA, msys, qmin_coord) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_peri~~UsesGraph proc~symba_peri symba_peri module~module_helio module_helio proc~symba_peri->module~module_helio module~module_symba module_symba proc~symba_peri->module~module_symba module~module_interfaces module_interfaces proc~symba_peri->module~module_interfaces module~swiftest swiftest proc~symba_peri->module~swiftest module~module_swiftest module_swiftest proc~symba_peri->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lfirst integer(kind=I4B), intent(in) :: npl type( symba_pl ), intent(inout) :: symba_plA real(kind=DP), intent(in) :: msys character(len=*), intent(in) :: qmin_coord Calls proc~~symba_peri~~CallsGraph proc~symba_peri symba_peri interface~orbel_xv2aeq orbel_xv2aeq proc~symba_peri->interface~orbel_xv2aeq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_peri.html"},{"title":"symba_energy – swiftest","text":"subroutine symba_energy(npl, swiftest_plA, j2rp2, j4rp4, ke, pe, te, htot) Uses swiftest module_swiftest module_interfaces proc~~symba_energy~~UsesGraph proc~symba_energy symba_energy module~module_swiftest module_swiftest proc~symba_energy->module~module_swiftest module~swiftest swiftest proc~symba_energy->module~swiftest module~module_interfaces module_interfaces proc~symba_energy->module~module_interfaces module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type( swiftest_pl ), intent(inout) :: swiftest_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(out) :: ke real(kind=DP), intent(out) :: pe real(kind=DP), intent(out) :: te real(kind=DP), intent(out), DIMENSION(NDIM) :: htot Calls proc~~symba_energy~~CallsGraph proc~symba_energy symba_energy interface~coord_h2b coord_h2b proc~symba_energy->interface~coord_h2b interface~obl_pot obl_pot proc~symba_energy->interface~obl_pot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_energy.html"},{"title":"symba_getacch_tp – swiftest","text":"subroutine symba_getacch_tp(lextra_force, t, npl, nplm, nplmax, ntp, ntpmax, symba_plA, symba_tpA, xh, j2rp2, j4rp4, npltpenc, pltpenc_list) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_getacch_tp~~UsesGraph proc~symba_getacch_tp symba_getacch_tp module~module_helio module_helio proc~symba_getacch_tp->module~module_helio module~module_symba module_symba proc~symba_getacch_tp->module~module_symba module~module_interfaces module_interfaces proc~symba_getacch_tp->module~module_interfaces module~swiftest swiftest proc~symba_getacch_tp->module~swiftest module~module_swiftest module_swiftest proc~symba_getacch_tp->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: ntpmax type( symba_pl ), intent(inout) :: symba_plA type( symba_tp ), intent(inout) :: symba_tpA real(kind=DP), intent(in), DIMENSION(NDIM, npl) :: xh real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 integer(kind=I4B), intent(in) :: npltpenc type( symba_pltpenc ), intent(in) :: pltpenc_list Calls proc~~symba_getacch_tp~~CallsGraph proc~symba_getacch_tp symba_getacch_tp interface~obl_acc obl_acc proc~symba_getacch_tp->interface~obl_acc interface~obl_acc_tp obl_acc_tp proc~symba_getacch_tp->interface~obl_acc_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_getacch_tp.html"},{"title":"symba_casesupercatastrophic – swiftest","text":"subroutine symba_casesupercatastrophic(t, dt, index_enc, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, vbs, symba_plA, nplplenc, plplenc_list, nplmax, ntpmax, fragmax, mres, rres, m1, m2, rad1, rad2, x1, x2, v1, v2) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_casesupercatastrophic~~UsesGraph proc~symba_casesupercatastrophic symba_casesupercatastrophic module~module_helio module_helio proc~symba_casesupercatastrophic->module~module_helio module~module_symba module_symba proc~symba_casesupercatastrophic->module~module_symba module~module_interfaces module_interfaces proc~symba_casesupercatastrophic->module~module_interfaces module~swiftest swiftest proc~symba_casesupercatastrophic->module~swiftest module~module_swiftest module_swiftest proc~symba_casesupercatastrophic->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type( symba_merger ), intent(inout) :: mergeadd_list type( symba_merger ), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs type( symba_pl ), intent(inout) :: symba_plA integer(kind=I4B), intent(inout) :: nplplenc type( symba_plplenc ), intent(inout) :: plplenc_list integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntpmax integer(kind=I4B), intent(inout) :: fragmax real(kind=DP), intent(inout), DIMENSION(3) :: mres real(kind=DP), intent(inout), DIMENSION(3) :: rres real(kind=DP), intent(inout) :: m1 real(kind=DP), intent(inout) :: m2 real(kind=DP), intent(inout) :: rad1 real(kind=DP), intent(inout) :: rad2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v2 Calls proc~~symba_casesupercatastrophic~~CallsGraph proc~symba_casesupercatastrophic symba_casesupercatastrophic interface~orbel_xv2aeq orbel_xv2aeq proc~symba_casesupercatastrophic->interface~orbel_xv2aeq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_casesupercatastrophic.html"},{"title":"symba_merge_pl – swiftest","text":"subroutine symba_merge_pl(t, dt, index_enc, nplplenc, plplenc_list, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, vbs, encounter_file, out_type, npl, symba_plA, symba_tpA) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_merge_pl~~UsesGraph proc~symba_merge_pl symba_merge_pl module~module_helio module_helio proc~symba_merge_pl->module~module_helio module~module_symba module_symba proc~symba_merge_pl->module~module_symba module~module_interfaces module_interfaces proc~symba_merge_pl->module~module_interfaces module~swiftest swiftest proc~symba_merge_pl->module~swiftest module~module_swiftest module_swiftest proc~symba_merge_pl->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(in) :: nplplenc type( symba_plplenc ), intent(inout) :: plplenc_list integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type( symba_merger ), intent(inout) :: mergeadd_list type( symba_merger ), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type integer(kind=I4B), intent(inout) :: npl type( symba_pl ), intent(inout) :: symba_plA type( symba_tp ), intent(inout) :: symba_tpA Contents None","tags":"","loc":"proc/symba_merge_pl.html"},{"title":"symba_caseresolve – swiftest","text":"subroutine symba_caseresolve(t, dt, index_enc, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, vbs, encounter_file, out_type, npl, ntp, symba_plA, symba_tpA, nplplenc, npltpenc, pltpenc_list, plplenc_list, regime, nplmax, ntpmax, fragmax, mres, rres, array_index1_child, array_index2_child, m1, m2, rad1, rad2, x1, x2, v1, v2) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_caseresolve~~UsesGraph proc~symba_caseresolve symba_caseresolve module~module_helio module_helio proc~symba_caseresolve->module~module_helio module~module_symba module_symba proc~symba_caseresolve->module~module_symba module~module_interfaces module_interfaces proc~symba_caseresolve->module~module_interfaces module~swiftest swiftest proc~symba_caseresolve->module~swiftest module~module_swiftest module_swiftest proc~symba_caseresolve->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type( symba_merger ), intent(inout) :: mergeadd_list type( symba_merger ), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type integer(kind=I4B), intent(inout) :: npl integer(kind=I4B), intent(inout) :: ntp type( symba_pl ), intent(inout) :: symba_plA type( symba_tp ), intent(inout) :: symba_tpA integer(kind=I4B), intent(inout) :: nplplenc integer(kind=I4B), intent(inout) :: npltpenc type( symba_pltpenc ), intent(inout) :: pltpenc_list type( symba_plplenc ), intent(inout) :: plplenc_list integer(kind=I4B), intent(in) :: regime integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntpmax integer(kind=I4B), intent(inout) :: fragmax real(kind=DP), intent(inout), DIMENSION(3) :: mres real(kind=DP), intent(inout), DIMENSION(3) :: rres integer(kind=I4B), intent(inout), DIMENSION(npl) :: array_index1_child integer(kind=I4B), intent(inout), DIMENSION(npl) :: array_index2_child real(kind=DP), intent(inout) :: m1 real(kind=DP), intent(inout) :: m2 real(kind=DP), intent(inout) :: rad1 real(kind=DP), intent(inout) :: rad2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v2 Calls proc~~symba_caseresolve~~CallsGraph proc~symba_caseresolve symba_caseresolve interface~symba_casemerge symba_casemerge proc~symba_caseresolve->interface~symba_casemerge interface~symba_casesupercatastrophic symba_casesupercatastrophic proc~symba_caseresolve->interface~symba_casesupercatastrophic interface~symba_casehitandrun symba_casehitandrun proc~symba_caseresolve->interface~symba_casehitandrun interface~symba_casedisruption symba_casedisruption proc~symba_caseresolve->interface~symba_casedisruption Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_caseresolve.html"},{"title":"symba_helio_getacch_int – swiftest","text":"subroutine symba_helio_getacch_int(npl, nplm, helio_plA) Uses swiftest module_helio module_symba module_interfaces proc~~symba_helio_getacch_int~~UsesGraph proc~symba_helio_getacch_int symba_helio_getacch_int module~module_helio module_helio proc~symba_helio_getacch_int->module~module_helio module~module_symba module_symba proc~symba_helio_getacch_int->module~module_symba module~swiftest swiftest proc~symba_helio_getacch_int->module~swiftest module~module_interfaces module_interfaces proc~symba_helio_getacch_int->module~module_interfaces module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm type( helio_pl ), intent(inout) :: helio_plA Contents None","tags":"","loc":"proc/symba_helio_getacch_int.html"},{"title":"symba_getacch – swiftest","text":"subroutine symba_getacch(lextra_force, t, npl, nplm, symba_plA, j2rp2, j4rp4, nplplenc, plplenc_list) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_getacch~~UsesGraph proc~symba_getacch symba_getacch module~module_helio module_helio proc~symba_getacch->module~module_helio module~module_symba module_symba proc~symba_getacch->module~module_symba module~module_interfaces module_interfaces proc~symba_getacch->module~module_interfaces module~swiftest swiftest proc~symba_getacch->module~swiftest module~module_swiftest module_swiftest proc~symba_getacch->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm type( symba_pl ), intent(inout) :: symba_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 integer(kind=I4B), intent(in) :: nplplenc type( symba_plplenc ), intent(inout) :: plplenc_list Calls proc~~symba_getacch~~CallsGraph proc~symba_getacch symba_getacch interface~obl_acc obl_acc proc~symba_getacch->interface~obl_acc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_getacch.html"},{"title":"symba_discard_tp – swiftest","text":"subroutine symba_discard_tp(t, npl, ntp, nsp, symba_plA, symba_tpA, dt, rmin, rmax, rmaxu, qmin, qmin_coord, qmin_alo, qmin_ahi, lclose, lrhill_present) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_discard_tp~~UsesGraph proc~symba_discard_tp symba_discard_tp module~module_helio module_helio proc~symba_discard_tp->module~module_helio module~module_symba module_symba proc~symba_discard_tp->module~module_symba module~module_interfaces module_interfaces proc~symba_discard_tp->module~module_interfaces module~swiftest swiftest proc~symba_discard_tp->module~swiftest module~module_swiftest module_swiftest proc~symba_discard_tp->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(inout) :: ntp integer(kind=I4B), intent(inout) :: nsp type( symba_pl ), intent(inout) :: symba_plA type( symba_tp ), intent(inout) :: symba_tpA real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: rmin real(kind=DP), intent(in) :: rmax real(kind=DP), intent(in) :: rmaxu real(kind=DP), intent(in) :: qmin character(len=*), intent(in) :: qmin_coord real(kind=DP), intent(in) :: qmin_alo real(kind=DP), intent(in) :: qmin_ahi logical(kind=LGT), intent(in) :: lclose logical(kind=LGT), intent(in) :: lrhill_present Calls proc~~symba_discard_tp~~CallsGraph proc~symba_discard_tp symba_discard_tp interface~discard discard proc~symba_discard_tp->interface~discard Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_discard_tp.html"},{"title":"symba_step_interp – swiftest","text":"subroutine symba_step_interp(lextra_force, lclose, t, npl, nplm, nplmax, ntp, ntpmax, symba_plA, symba_tpA, j2rp2, j4rp4, dt, eoffset, nplplenc, npltpenc, plplenc_list, pltpenc_list, nmergeadd, nmergesub, mergeadd_list, mergesub_list, encounter_file, out_type, fragmax, feature) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_step_interp~~UsesGraph proc~symba_step_interp symba_step_interp module~module_helio module_helio proc~symba_step_interp->module~module_helio module~module_symba module_symba proc~symba_step_interp->module~module_symba module~module_interfaces module_interfaces proc~symba_step_interp->module~module_interfaces module~swiftest swiftest proc~symba_step_interp->module~swiftest module~module_swiftest module_swiftest proc~symba_step_interp->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lextra_force logical(kind=LGT), intent(in) :: lclose real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: ntpmax type( symba_pl ), intent(inout) :: symba_plA type( symba_tp ), intent(inout) :: symba_tpA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: dt real(kind=DP), intent(inout) :: eoffset integer(kind=I4B), intent(in) :: nplplenc integer(kind=I4B), intent(in) :: npltpenc type( symba_plplenc ), intent(inout) :: plplenc_list type( symba_pltpenc ), intent(inout) :: pltpenc_list integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type( symba_merger ), intent(inout) :: mergeadd_list type( symba_merger ), intent(inout) :: mergesub_list character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type integer(kind=I4B), intent(inout) :: fragmax type( feature_list ), intent(in) :: feature Calls proc~~symba_step_interp~~CallsGraph proc~symba_step_interp symba_step_interp interface~helio_kickvb helio_kickvb proc~symba_step_interp->interface~helio_kickvb interface~symba_step_recur symba_step_recur proc~symba_step_interp->interface~symba_step_recur interface~symba_getacch symba_getacch proc~symba_step_interp->interface~symba_getacch interface~coord_vb2vh coord_vb2vh proc~symba_step_interp->interface~coord_vb2vh interface~coord_vh2vb_tp coord_vh2vb_tp proc~symba_step_interp->interface~coord_vh2vb_tp interface~helio_lindrift_tp helio_lindrift_tp proc~symba_step_interp->interface~helio_lindrift_tp interface~symba_helio_drift symba_helio_drift proc~symba_step_interp->interface~symba_helio_drift interface~coord_vh2vb coord_vh2vb proc~symba_step_interp->interface~coord_vh2vb interface~helio_lindrift helio_lindrift proc~symba_step_interp->interface~helio_lindrift interface~coord_vb2vh_tp coord_vb2vh_tp proc~symba_step_interp->interface~coord_vb2vh_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_step_interp.html"},{"title":"symba_discard_merge_pl – swiftest","text":"subroutine symba_discard_merge_pl(t, npl, symba_plA, nplplenc, plplenc_list) Uses swiftest module_swifter module_helio module_symba module_interfaces proc~~symba_discard_merge_pl~~UsesGraph proc~symba_discard_merge_pl symba_discard_merge_pl module~module_helio module_helio proc~symba_discard_merge_pl->module~module_helio module~module_swifter module_swifter proc~symba_discard_merge_pl->module~module_swifter module~module_symba module_symba proc~symba_discard_merge_pl->module~module_symba module~module_interfaces module_interfaces proc~symba_discard_merge_pl->module~module_interfaces module~swiftest swiftest proc~symba_discard_merge_pl->module~swiftest module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swifter->module~swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(inout) :: npl type( symba_pl ) :: symba_plA integer(kind=I4B), intent(in) :: nplplenc type( symba_plplenc ), intent(in) :: plplenc_list Contents None","tags":"","loc":"proc/symba_discard_merge_pl.html"},{"title":"symba_step – swiftest","text":"subroutine symba_step(lfirst, lextra_force, lclose, t, npl, nplmax, ntp, ntpmax, symba_plA, symba_tpA, j2rp2, j4rp4, dt, nplplenc, npltpenc, plplenc_list, pltpenc_list, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, mtiny, encounter_file, out_type, fragmax, feature) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_step~~UsesGraph proc~symba_step symba_step module~module_helio module_helio proc~symba_step->module~module_helio module~module_symba module_symba proc~symba_step->module~module_symba module~module_interfaces module_interfaces proc~symba_step->module~module_interfaces module~swiftest swiftest proc~symba_step->module~swiftest module~module_swiftest module_swiftest proc~symba_step->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(inout) :: lfirst logical(kind=LGT), intent(in) :: lextra_force logical(kind=LGT), intent(in) :: lclose real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: ntpmax type( symba_pl ), intent(inout) :: symba_plA type( symba_tp ), intent(inout) :: symba_tpA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(inout) :: nplplenc integer(kind=I4B), intent(inout) :: npltpenc type( symba_plplenc ), intent(inout) :: plplenc_list type( symba_pltpenc ), intent(inout) :: pltpenc_list integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type( symba_merger ), intent(inout) :: mergeadd_list type( symba_merger ), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in) :: mtiny character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type integer(kind=I4B), intent(inout) :: fragmax type( feature_list ) :: feature Calls proc~~symba_step~~CallsGraph proc~symba_step symba_step interface~symba_step_interp symba_step_interp proc~symba_step->interface~symba_step_interp interface~symba_step_helio symba_step_helio proc~symba_step->interface~symba_step_helio interface~util_exit util_exit proc~symba_step->interface~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_step.html"},{"title":"symba_merge_tp – swiftest","text":"subroutine symba_merge_tp(t, dt, index_enc, npltpenc, pltpenc_list, vbs, encounter_file, out_type, symba_plA, symba_tpA) Uses swiftest module_swifter module_helio module_symba module_interfaces proc~~symba_merge_tp~~UsesGraph proc~symba_merge_tp symba_merge_tp module~module_helio module_helio proc~symba_merge_tp->module~module_helio module~module_swifter module_swifter proc~symba_merge_tp->module~module_swifter module~module_symba module_symba proc~symba_merge_tp->module~module_symba module~module_interfaces module_interfaces proc~symba_merge_tp->module~module_interfaces module~swiftest swiftest proc~symba_merge_tp->module~swiftest module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swifter->module~swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(in) :: npltpenc type( symba_pltpenc ), intent(inout) :: pltpenc_list real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type type( symba_pl ), intent(inout) :: symba_plA type( symba_tp ), intent(inout) :: symba_tpA Contents None","tags":"","loc":"proc/symba_merge_tp.html"},{"title":"symba_casemerge – swiftest","text":"subroutine symba_casemerge(t, dt, index_enc, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, vbs, encounter_file, out_type, npl, ntp, symba_plA, symba_tpA, nplplenc, npltpenc, pltpenc_list, plplenc_list, array_index1_child, array_index2_child, m1, m2, rad1, rad2, x1, x2, v1, v2) Uses swiftest module_swiftest module_helio module_symba module_interfaces proc~~symba_casemerge~~UsesGraph proc~symba_casemerge symba_casemerge module~module_helio module_helio proc~symba_casemerge->module~module_helio module~module_symba module_symba proc~symba_casemerge->module~module_symba module~module_interfaces module_interfaces proc~symba_casemerge->module~module_interfaces module~swiftest swiftest proc~symba_casemerge->module~swiftest module~module_swiftest module_swiftest proc~symba_casemerge->module~module_swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest module~module_symba->module~module_helio module~module_symba->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type( symba_merger ), intent(inout) :: mergeadd_list type( symba_merger ), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type integer(kind=I4B), intent(inout) :: npl integer(kind=I4B), intent(inout) :: ntp type( symba_pl ), intent(inout) :: symba_plA type( symba_tp ), intent(inout) :: symba_tpA integer(kind=I4B), intent(inout) :: nplplenc integer(kind=I4B), intent(inout) :: npltpenc type( symba_pltpenc ), intent(inout) :: pltpenc_list type( symba_plplenc ), intent(inout) :: plplenc_list integer(kind=I4B), intent(inout), DIMENSION(npl) :: array_index1_child integer(kind=I4B), intent(inout), DIMENSION(npl) :: array_index2_child real(kind=DP), intent(inout) :: m1 real(kind=DP), intent(inout) :: m2 real(kind=DP), intent(inout) :: rad1 real(kind=DP), intent(inout) :: rad2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v2 Contents None","tags":"","loc":"proc/symba_casemerge.html"},{"title":"rmvs_chk_ind – swiftest","text":"subroutine rmvs_chk_ind(xr, vr, dt, r2crit, iflag) Uses swiftest module_interfaces proc~~rmvs_chk_ind~~UsesGraph proc~rmvs_chk_ind rmvs_chk_ind module~swiftest swiftest proc~rmvs_chk_ind->module~swiftest module~module_interfaces module_interfaces proc~rmvs_chk_ind->module~module_interfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(NDIM) :: xr real(kind=DP), intent(in), DIMENSION(NDIM) :: vr real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r2crit integer(kind=I4B), intent(out) :: iflag Contents None","tags":"","loc":"proc/rmvs_chk_ind.html"},{"title":"coord_h2b – swiftest","text":"interface Called by interface~~coord_h2b~~CalledByGraph interface~coord_h2b coord_h2b proc~discard discard proc~discard->interface~coord_h2b proc~symba_energy symba_energy proc~symba_energy->interface~coord_h2b Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine coord_h2b(npl, swiftest_plA, msys) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(swiftest_pl), intent(inout) :: swiftest_plA real(kind=DP), intent(out) :: msys","tags":"","loc":"interface/coord_h2b.html"},{"title":"coord_h2b_tp – swiftest","text":"interface Called by interface~~coord_h2b_tp~~CalledByGraph interface~coord_h2b_tp coord_h2b_tp proc~discard discard proc~discard->interface~coord_h2b_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine coord_h2b_tp(ntp, swiftest_tpA, swiftest_plA) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp type(swiftest_tp), intent(inout) :: swiftest_tpA type(swiftest_pl), intent(inout) :: swiftest_plA","tags":"","loc":"interface/coord_h2b_tp.html"},{"title":"coord_vb2vh – swiftest","text":"interface Called by interface~~coord_vb2vh~~CalledByGraph interface~coord_vb2vh coord_vb2vh proc~symba_step_interp symba_step_interp proc~symba_step_interp->interface~coord_vb2vh proc~symba_step_helio_pl symba_step_helio_pl proc~symba_step_helio_pl->interface~coord_vb2vh proc~helio_step_pl helio_step_pl proc~helio_step_pl->interface~coord_vb2vh Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine coord_vb2vh(npl, swiftest_plA) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(swiftest_pl), intent(inout) :: swiftest_plA","tags":"","loc":"interface/coord_vb2vh.html"},{"title":"coord_vb2vh_tp – swiftest","text":"interface Called by interface~~coord_vb2vh_tp~~CalledByGraph interface~coord_vb2vh_tp coord_vb2vh_tp proc~symba_step_interp symba_step_interp proc~symba_step_interp->interface~coord_vb2vh_tp proc~helio_step_tp helio_step_tp proc~helio_step_tp->interface~coord_vb2vh_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine coord_vb2vh_tp(ntp, swiftest_tpA, vs) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp type(swiftest_tp), intent(inout) :: swiftest_tpA real(kind=DP), intent(in), DIMENSION(NDIM) :: vs","tags":"","loc":"interface/coord_vb2vh_tp.html"},{"title":"coord_vh2vb – swiftest","text":"interface Called by interface~~coord_vh2vb~~CalledByGraph interface~coord_vh2vb coord_vh2vb proc~symba_step_interp symba_step_interp proc~symba_step_interp->interface~coord_vh2vb proc~symba_step_helio_pl symba_step_helio_pl proc~symba_step_helio_pl->interface~coord_vh2vb proc~helio_step_pl helio_step_pl proc~helio_step_pl->interface~coord_vh2vb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine coord_vh2vb(npl, swiftest_plA, msys) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(swiftest_pl), intent(inout) :: swiftest_plA real(kind=DP), intent(out) :: msys","tags":"","loc":"interface/coord_vh2vb.html"},{"title":"coord_vh2vb_tp – swiftest","text":"interface Called by interface~~coord_vh2vb_tp~~CalledByGraph interface~coord_vh2vb_tp coord_vh2vb_tp proc~symba_step_interp symba_step_interp proc~symba_step_interp->interface~coord_vh2vb_tp proc~helio_step_tp helio_step_tp proc~helio_step_tp->interface~coord_vh2vb_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine coord_vh2vb_tp(ntp, swiftest_tpA, vs) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp type(swiftest_tp), intent(inout) :: swiftest_tpA real(kind=DP), intent(in), DIMENSION(NDIM) :: vs","tags":"","loc":"interface/coord_vh2vb_tp.html"},{"title":"discard – swiftest","text":"interface Called by interface~~discard~~CalledByGraph interface~discard discard proc~symba_discard_tp symba_discard_tp proc~symba_discard_tp->interface~discard Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine discard(t, dt, npl, ntp, swiftest_plA, swiftest_tpA, rmin, rmax, rmaxu, qmin, qmin_alo, qmin_ahi, qmin_coord, lclose, lrhill_present) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp type(swiftest_pl), intent(inout) :: swiftest_plA type(swiftest_tp), intent(inout) :: swiftest_tpA real(kind=DP), intent(in) :: rmin real(kind=DP), intent(in) :: rmax real(kind=DP), intent(in) :: rmaxu real(kind=DP), intent(in) :: qmin real(kind=DP), intent(in) :: qmin_alo real(kind=DP), intent(in) :: qmin_ahi character(len=*), intent(in) :: qmin_coord logical(kind=LGT), intent(in) :: lclose logical(kind=LGT), intent(in) :: lrhill_present","tags":"","loc":"interface/discard.html"},{"title":"discard_peri – swiftest","text":"interface public subroutine discard_peri(t, npl, ntp, swiftest_plA, swiftest_tpA, msys, qmin, qmin_alo, qmin_ahi, qmin_coord, lrhill_present) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp type(swiftest_pl), intent(inout) :: swiftest_plA type(swiftest_tp), intent(inout) :: swiftest_tpA real(kind=DP), intent(in) :: msys real(kind=DP), intent(in) :: qmin real(kind=DP), intent(in) :: qmin_alo real(kind=DP), intent(in) :: qmin_ahi character(len=*), intent(in) :: qmin_coord logical(kind=LGT), intent(in) :: lrhill_present","tags":"","loc":"interface/discard_peri.html"},{"title":"discard_pl_close – swiftest","text":"interface public subroutine discard_pl_close(dx, dv, dt, r2crit, iflag, r2min) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(NDIM) :: dx real(kind=DP), intent(in), DIMENSION(NDIM) :: dv real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r2crit integer(kind=I4B), intent(out) :: iflag real(kind=DP), intent(out) :: r2min","tags":"","loc":"interface/discard_pl_close.html"},{"title":"discard_pl – swiftest","text":"interface public subroutine discard_pl(t, dt, npl, ntp, swiftest_plA, swiftest_tpA) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp type(swiftest_pl), intent(inout) :: swiftest_plA type(swiftest_tp), intent(inout) :: swiftest_tpA","tags":"","loc":"interface/discard_pl.html"},{"title":"discard_sun – swiftest","text":"interface public subroutine discard_sun(t, ntp, msys, swifter_tpA, rmin, rmax, rmaxu) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: ntp real(kind=DP), intent(in) :: msys type(swiftest_tp), intent(inout) :: swifter_tpA real(kind=DP), intent(in) :: rmin real(kind=DP), intent(in) :: rmax real(kind=DP), intent(in) :: rmaxu","tags":"","loc":"interface/discard_sun.html"},{"title":"drift_dan – swiftest","text":"interface public subroutine drift_dan(mu, x0, v0, dt0, iflag) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu real(kind=DP), intent(inout), DIMENSION(NDIM) :: x0 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v0 real(kind=DP), intent(in) :: dt0 integer(kind=I4B), intent(out) :: iflag","tags":"","loc":"interface/drift_dan.html"},{"title":"drift_kepmd – swiftest","text":"interface Called by interface~~drift_kepmd~~CalledByGraph interface~drift_kepmd drift_kepmd proc~drift_dan drift_dan proc~drift_dan->interface~drift_kepmd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine drift_kepmd(dm, es, ec, x, s, c) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dm real(kind=DP), intent(in) :: es real(kind=DP), intent(in) :: ec real(kind=DP), intent(out) :: x real(kind=DP), intent(out) :: s real(kind=DP), intent(out) :: c","tags":"","loc":"interface/drift_kepmd.html"},{"title":"drift_kepu – swiftest","text":"interface Called by interface~~drift_kepu~~CalledByGraph interface~drift_kepu drift_kepu proc~drift_dan drift_dan proc~drift_dan->interface~drift_kepu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine drift_kepu(dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: fp real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 integer(kind=I4B), intent(out) :: iflag","tags":"","loc":"interface/drift_kepu.html"},{"title":"drift_kepu_fchk – swiftest","text":"interface Called by interface~~drift_kepu_fchk~~CalledByGraph interface~drift_kepu_fchk drift_kepu_fchk proc~drift_kepu drift_kepu proc~drift_kepu->interface~drift_kepu_fchk Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine drift_kepu_fchk(dt, r0, mu, alpha, u, s, f) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(in) :: s real(kind=DP), intent(out) :: f","tags":"","loc":"interface/drift_kepu_fchk.html"},{"title":"drift_kepu_guess – swiftest","text":"interface Called by interface~~drift_kepu_guess~~CalledByGraph interface~drift_kepu_guess drift_kepu_guess proc~drift_kepu drift_kepu proc~drift_kepu->interface~drift_kepu_guess Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine drift_kepu_guess(dt, r0, mu, alpha, u, s) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: s","tags":"","loc":"interface/drift_kepu_guess.html"},{"title":"drift_kepu_lag – swiftest","text":"interface Called by interface~~drift_kepu_lag~~CalledByGraph interface~drift_kepu_lag drift_kepu_lag proc~drift_kepu drift_kepu proc~drift_kepu->interface~drift_kepu_lag Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine drift_kepu_lag(s, dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout) :: s real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: fp real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 integer(kind=I4B), intent(out) :: iflag","tags":"","loc":"interface/drift_kepu_lag.html"},{"title":"drift_kepu_new – swiftest","text":"interface Called by interface~~drift_kepu_new~~CalledByGraph interface~drift_kepu_new drift_kepu_new proc~drift_kepu drift_kepu proc~drift_kepu->interface~drift_kepu_new Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine drift_kepu_new(s, dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout) :: s real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: fp real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 integer(kind=I4B), intent(out) :: iflag","tags":"","loc":"interface/drift_kepu_new.html"},{"title":"drift_kepu_p3solve – swiftest","text":"interface Called by interface~~drift_kepu_p3solve~~CalledByGraph interface~drift_kepu_p3solve drift_kepu_p3solve proc~drift_kepu_guess drift_kepu_guess proc~drift_kepu_guess->interface~drift_kepu_p3solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine drift_kepu_p3solve(dt, r0, mu, alpha, u, s, iflag) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: s integer(kind=I4B), intent(out) :: iflag","tags":"","loc":"interface/drift_kepu_p3solve.html"},{"title":"drift_kepu_stumpff – swiftest","text":"interface Called by interface~~drift_kepu_stumpff~~CalledByGraph interface~drift_kepu_stumpff drift_kepu_stumpff proc~drift_kepu_new drift_kepu_new proc~drift_kepu_new->interface~drift_kepu_stumpff proc~drift_kepu_fchk drift_kepu_fchk proc~drift_kepu_fchk->interface~drift_kepu_stumpff proc~drift_kepu_lag drift_kepu_lag proc~drift_kepu_lag->interface~drift_kepu_stumpff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine drift_kepu_stumpff(x, c0, c1, c2, c3) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout) :: x real(kind=DP), intent(out) :: c0 real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3","tags":"","loc":"interface/drift_kepu_stumpff.html"},{"title":"drift_one – swiftest","text":"interface Called by interface~~drift_one~~CalledByGraph interface~drift_one drift_one proc~helio_drift helio_drift proc~helio_drift->interface~drift_one proc~helio_drift_tp helio_drift_tp proc~helio_drift_tp->interface~drift_one proc~symba_helio_drift_tp symba_helio_drift_tp proc~symba_helio_drift_tp->interface~drift_one proc~symba_helio_drift symba_helio_drift proc~symba_helio_drift->interface~drift_one Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine drift_one(mu, x, v, dt, iflag) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu real(kind=DP), intent(inout), DIMENSION(NDIM) :: x real(kind=DP), intent(inout), DIMENSION(NDIM) :: v real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(out) :: iflag","tags":"","loc":"interface/drift_one.html"},{"title":"helio_drift – swiftest","text":"interface Called by interface~~helio_drift~~CalledByGraph interface~helio_drift helio_drift proc~symba_step_helio_pl symba_step_helio_pl proc~symba_step_helio_pl->interface~helio_drift proc~helio_step_pl helio_step_pl proc~helio_step_pl->interface~helio_drift Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine helio_drift(npl, swiftest_plA, dt) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(swiftest_pl), intent(inout) :: swiftest_plA real(kind=DP), intent(in) :: dt","tags":"","loc":"interface/helio_drift.html"},{"title":"helio_drift_tp – swiftest","text":"interface Called by interface~~helio_drift_tp~~CalledByGraph interface~helio_drift_tp helio_drift_tp proc~helio_step_tp helio_step_tp proc~helio_step_tp->interface~helio_drift_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine helio_drift_tp(ntp, swiftest_tpA, mu, dt) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp type(swiftest_tp), intent(inout) :: swiftest_tpA real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: dt","tags":"","loc":"interface/helio_drift_tp.html"},{"title":"helio_getacch – swiftest","text":"interface Called by interface~~helio_getacch~~CalledByGraph interface~helio_getacch helio_getacch proc~helio_step_pl helio_step_pl proc~helio_step_pl->interface~helio_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine helio_getacch(lflag, lextra_force, t, npl, nplmax, helio_plA, j2rp2, j4rp4) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lflag logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplmax type(helio_pl), intent(inout) :: helio_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4","tags":"","loc":"interface/helio_getacch.html"},{"title":"helio_getacch_int – swiftest","text":"interface Called by interface~~helio_getacch_int~~CalledByGraph interface~helio_getacch_int helio_getacch_int proc~helio_getacch helio_getacch proc~helio_getacch->interface~helio_getacch_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine helio_getacch_int(npl, helio_plA) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(helio_pl), intent(inout) :: helio_plA","tags":"","loc":"interface/helio_getacch_int.html"},{"title":"helio_getacch_int_tp – swiftest","text":"interface Called by interface~~helio_getacch_int_tp~~CalledByGraph interface~helio_getacch_int_tp helio_getacch_int_tp proc~helio_getacch_tp helio_getacch_tp proc~helio_getacch_tp->interface~helio_getacch_int_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine helio_getacch_int_tp(npl, ntp, swiftest_plA, helio_tpA) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp type(swiftest_pl), intent(inout) :: swiftest_plA type(helio_tp), intent(inout) :: helio_tpA","tags":"","loc":"interface/helio_getacch_int_tp.html"},{"title":"helio_getacch_tp – swiftest","text":"interface Called by interface~~helio_getacch_tp~~CalledByGraph interface~helio_getacch_tp helio_getacch_tp proc~helio_step_tp helio_step_tp proc~helio_step_tp->interface~helio_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine helio_getacch_tp(lflag, lextra_force, t, npl, nplmax, ntp, ntpmax, helio_plA, helio_tpA, xh, j2rp2, j4rp4) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lflag logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: ntpmax type(helio_pl), intent(inout) :: helio_plA type(helio_tp), intent(inout) :: helio_tpA real(kind=DP), intent(in), DIMENSION(NDIM, npl) :: xh real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4","tags":"","loc":"interface/helio_getacch_tp.html"},{"title":"helio_kickvb – swiftest","text":"interface Called by interface~~helio_kickvb~~CalledByGraph interface~helio_kickvb helio_kickvb proc~symba_step_interp symba_step_interp proc~symba_step_interp->interface~helio_kickvb proc~symba_step_helio_pl symba_step_helio_pl proc~symba_step_helio_pl->interface~helio_kickvb proc~helio_step_pl helio_step_pl proc~helio_step_pl->interface~helio_kickvb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine helio_kickvb(npl, helio_plA, dt) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(helio_pl), intent(inout) :: helio_plA real(kind=DP), intent(in) :: dt","tags":"","loc":"interface/helio_kickvb.html"},{"title":"helio_kickvb_tp – swiftest","text":"interface Called by interface~~helio_kickvb_tp~~CalledByGraph interface~helio_kickvb_tp helio_kickvb_tp proc~helio_step_tp helio_step_tp proc~helio_step_tp->interface~helio_kickvb_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine helio_kickvb_tp(ntp, helio_tpA, dt) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp type(helio_tp), intent(inout) :: helio_tpA real(kind=DP), intent(in) :: dt","tags":"","loc":"interface/helio_kickvb_tp.html"},{"title":"helio_lindrift – swiftest","text":"interface Called by interface~~helio_lindrift~~CalledByGraph interface~helio_lindrift helio_lindrift proc~symba_step_interp symba_step_interp proc~symba_step_interp->interface~helio_lindrift proc~symba_step_helio_pl symba_step_helio_pl proc~symba_step_helio_pl->interface~helio_lindrift proc~helio_step_pl helio_step_pl proc~helio_step_pl->interface~helio_lindrift Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine helio_lindrift(npl, swiftest_plA, dt, pt) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(swiftest_pl), intent(inout) :: swiftest_plA real(kind=DP), intent(in) :: dt real(kind=DP), intent(out), DIMENSION(NDIM) :: pt","tags":"","loc":"interface/helio_lindrift.html"},{"title":"helio_lindrift_tp – swiftest","text":"interface Called by interface~~helio_lindrift_tp~~CalledByGraph interface~helio_lindrift_tp helio_lindrift_tp proc~symba_step_interp symba_step_interp proc~symba_step_interp->interface~helio_lindrift_tp proc~helio_step_tp helio_step_tp proc~helio_step_tp->interface~helio_lindrift_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine helio_lindrift_tp(ntp, swiftest_tpA, dt, pt) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp type(swiftest_tp), intent(inout) :: swiftest_tpA real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), DIMENSION(NDIM) :: pt","tags":"","loc":"interface/helio_lindrift_tp.html"},{"title":"helio_step – swiftest","text":"interface public subroutine helio_step(lfirst, lextra_force, t, npl, nplmax, ntp, ntpmax, helio_plA, helio_tpA, j2rp2, j4rp4, dt) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(inout) :: lfirst logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: ntpmax type(helio_pl), intent(inout) :: helio_plA type(helio_tp), intent(inout) :: helio_tpA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: dt","tags":"","loc":"interface/helio_step.html"},{"title":"helio_step_pl – swiftest","text":"interface public subroutine helio_step_pl(lfirst, lextra_force, t, npl, nplmax, helio_plA, j2rp2, j4rp4, dt, xbeg, xend, ptb, pte) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(inout) :: lfirst logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplmax type(helio_pl), intent(inout) :: helio_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: dt real(kind=DP), intent(out), DIMENSION(NDIM, npl) :: xbeg real(kind=DP), intent(out), DIMENSION(NDIM, npl) :: xend real(kind=DP), intent(out), DIMENSION(NDIM) :: ptb real(kind=DP), intent(out), DIMENSION(NDIM) :: pte","tags":"","loc":"interface/helio_step_pl.html"},{"title":"helio_step_tp – swiftest","text":"interface public subroutine helio_step_tp(lfirsttp, lextra_force, t, npl, nplmax, ntp, ntpmax, helio_plA, helio_tpA, j2rp2, j4rp4, dt, xbeg, xend, ptb, pte) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(inout) :: lfirsttp logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: ntpmax type(helio_pl), intent(inout) :: helio_plA type(helio_tp), intent(inout) :: helio_tpA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), DIMENSION(NDIM, npl) :: xbeg real(kind=DP), intent(in), DIMENSION(NDIM, npl) :: xend real(kind=DP), intent(in), DIMENSION(NDIM) :: ptb real(kind=DP), intent(in), DIMENSION(NDIM) :: pte","tags":"","loc":"interface/helio_step_tp.html"},{"title":"helio_user_getacch – swiftest","text":"interface public subroutine helio_user_getacch(t, npl, helio_plA) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl type(helio_pl), intent(inout) :: helio_plA","tags":"","loc":"interface/helio_user_getacch.html"},{"title":"helio_user_getacch_tp – swiftest","text":"interface public subroutine helio_user_getacch_tp(t, ntp, helio_tpA) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: ntp type(helio_tp), intent(inout) :: helio_tpA","tags":"","loc":"interface/helio_user_getacch_tp.html"},{"title":"io_discard_write_symba – swiftest","text":"interface Called by interface~~io_discard_write_symba~~CalledByGraph interface~io_discard_write_symba io_discard_write_symba program~swiftest_symba swiftest_symba program~swiftest_symba->interface~io_discard_write_symba Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine io_discard_write_symba(t, mtiny, npl, ntp, nsppl, nsptp, nmergeadd, symba_plA, discard_plA, discard_tpA, mergeadd_list, mergesub_list, fname, lbig_discard) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: mtiny integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: nsppl integer(kind=I4B), intent(in) :: nsptp integer(kind=I4B), intent(in) :: nmergeadd type(symba_pl), intent(inout) :: symba_plA type(swiftest_pl), intent(inout) :: discard_plA type(swiftest_tp), intent(inout) :: discard_tpA type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list character(len=*), intent(in) :: fname logical(kind=LGT), intent(in) :: lbig_discard","tags":"","loc":"interface/io_discard_write_symba.html"},{"title":"io_dump_param – swiftest","text":"interface Called by interface~~io_dump_param~~CalledByGraph interface~io_dump_param io_dump_param program~swiftest_symba swiftest_symba program~swiftest_symba->interface~io_dump_param Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine io_dump_param(nplmax, ntpmax, ntp, t, tstop, dt, in_type, istep_out, outfile, out_type, out_form, istep_dump, j2rp2, j4rp4, rmin, rmax, rmaxu, qmin, qmin_coord, qmin_alo, qmin_ahi, encounter_file, mtiny, feature, ring_outfile) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntpmax integer(kind=I4B), intent(in) :: ntp real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: tstop real(kind=DP), intent(in) :: dt character(len=*), intent(in) :: in_type integer(kind=I4B), intent(in) :: istep_out character(len=*), intent(in) :: outfile character(len=*), intent(in) :: out_type character(len=*), intent(in) :: out_form integer(kind=I4B), intent(in) :: istep_dump real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: rmin real(kind=DP), intent(in) :: rmax real(kind=DP), intent(in) :: rmaxu real(kind=DP), intent(in) :: qmin character(len=*), intent(in) :: qmin_coord real(kind=DP), intent(in) :: qmin_alo real(kind=DP), intent(in) :: qmin_ahi character(len=*), intent(in) :: encounter_file real(kind=DP), intent(in), optional :: mtiny type(feature_list), intent(in) :: feature character(len=*), intent(in), optional :: ring_outfile","tags":"","loc":"interface/io_dump_param.html"},{"title":"io_dump_pl – swiftest","text":"interface Called by interface~~io_dump_pl~~CalledByGraph interface~io_dump_pl io_dump_pl program~swiftest_symba swiftest_symba program~swiftest_symba->interface~io_dump_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine io_dump_pl(npl, swiftest_plA, lclose, lrhill_present) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(swiftest_pl), intent(inout) :: swiftest_plA logical(kind=LGT), intent(in) :: lclose logical(kind=LGT), intent(in) :: lrhill_present","tags":"","loc":"interface/io_dump_pl.html"},{"title":"io_dump_tp – swiftest","text":"interface public subroutine io_dump_tp(ntp, swiftest_tpA) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp type(swiftest_tp), intent(inout) :: swiftest_tpA","tags":"","loc":"interface/io_dump_tp.html"},{"title":"io_getn – swiftest","text":"interface Called by interface~~io_getn~~CalledByGraph interface~io_getn io_getn program~swiftest_symba swiftest_symba program~swiftest_symba->interface~io_getn Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine io_getn(inplfile, intpfile, in_type, npl, nplmax, ntp, ntpmax) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: inplfile character(len=*), intent(in) :: intpfile character(len=*), intent(in) :: in_type integer(kind=I4B), intent(out) :: npl integer(kind=I4B), intent(inout) :: nplmax integer(kind=I4B), intent(out) :: ntp integer(kind=I4B), intent(inout) :: ntpmax","tags":"","loc":"interface/io_getn.html"},{"title":"io_init_pl – swiftest","text":"interface public subroutine io_init_pl(inplfile, in_type, lclose, lrhill_present, npl, symba_plA) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: inplfile character(len=*), intent(in) :: in_type logical(kind=LGT), intent(in) :: lclose logical(kind=LGT), intent(in) :: lrhill_present integer(kind=I4B), intent(in) :: npl type(symba_pl), intent(inout) :: symba_plA","tags":"","loc":"interface/io_init_pl.html"},{"title":"io_init_tp – swiftest","text":"interface Called by interface~~io_init_tp~~CalledByGraph interface~io_init_tp io_init_tp program~swiftest_symba swiftest_symba program~swiftest_symba->interface~io_init_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine io_init_tp(intpfile, in_type, ntp, symba_tpA) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: intpfile character(len=*), intent(in) :: in_type integer(kind=I4B), intent(in) :: ntp type(symba_tp), intent(inout) :: symba_tpA","tags":"","loc":"interface/io_init_tp.html"},{"title":"io_open – swiftest","text":"interface Called by interface~~io_open~~CalledByGraph interface~io_open io_open proc~io_getn io_getn proc~io_getn->interface~io_open proc~io_write_frame io_write_frame proc~io_write_frame->interface~io_open proc~io_read_encounter io_read_encounter proc~io_read_encounter->interface~io_open proc~io_init_pl io_init_pl proc~io_init_pl->interface~io_open proc~io_init_tp io_init_tp proc~io_init_tp->interface~io_open proc~python_io_write_frame_tp python_io_write_frame_tp proc~python_io_write_frame_tp->interface~io_open proc~io_discard_write_symba io_discard_write_symba proc~io_discard_write_symba->interface~io_open proc~python_io_write_frame_pl python_io_write_frame_pl proc~python_io_write_frame_pl->interface~io_open proc~io_write_encounter io_write_encounter proc~io_write_encounter->interface~io_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine io_open(iu, fname, fopenstat, fmt, ierr) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu character(len=*), intent(in) :: fname character(len=*), intent(in) :: fopenstat character(len=*), intent(in) :: fmt integer(kind=I4B), intent(out) :: ierr","tags":"","loc":"interface/io_open.html"},{"title":"io_open_fxdr – swiftest","text":"interface Called by interface~~io_open_fxdr~~CalledByGraph interface~io_open_fxdr io_open_fxdr proc~io_getn io_getn proc~io_getn->interface~io_open_fxdr proc~io_write_frame io_write_frame proc~io_write_frame->interface~io_open_fxdr proc~io_read_encounter io_read_encounter proc~io_read_encounter->interface~io_open_fxdr proc~io_init_pl io_init_pl proc~io_init_pl->interface~io_open_fxdr proc~io_init_tp io_init_tp proc~io_init_tp->interface~io_open_fxdr proc~io_write_encounter io_write_encounter proc~io_write_encounter->interface~io_open_fxdr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine io_open_fxdr(fname, fopenstat, lflag, iu, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname character(len=1), intent(in) :: fopenstat logical(kind=LGT), intent(in) :: lflag integer(kind=I4B), intent(out) :: iu integer(kind=I4B), intent(out) :: ierr","tags":"","loc":"interface/io_open_fxdr.html"},{"title":"io_read_encounter – swiftest","text":"interface Called by interface~~io_read_encounter~~CalledByGraph interface~io_read_encounter io_read_encounter program~tool_encounter_read tool_encounter_read program~tool_encounter_read->interface~io_read_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function io_read_encounter(t, name1, name2, mass1, mass2, xh1, xh2, vh1, vh2, encounter_file, out_type) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(out) :: t integer(kind=I4B), intent(out) :: name1 integer(kind=I4B), intent(out) :: name2 real(kind=DP), intent(out) :: mass1 real(kind=DP), intent(out) :: mass2 real(kind=DP), intent(out), DIMENSION(NDIM) :: xh1 real(kind=DP), intent(out), DIMENSION(NDIM) :: xh2 real(kind=DP), intent(out), DIMENSION(NDIM) :: vh1 real(kind=DP), intent(out), DIMENSION(NDIM) :: vh2 character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type Return Value integer(kind=I4B)","tags":"","loc":"interface/io_read_encounter.html"},{"title":"io_read_hdr – swiftest","text":"interface public function io_read_hdr(iu, t, npl, ntp, iout_form, out_type) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu real(kind=DP), intent(out) :: t integer(kind=I4B), intent(out) :: npl integer(kind=I4B), intent(out) :: ntp integer(kind=I4B), intent(out) :: iout_form character(len=*), intent(in) :: out_type Return Value integer(kind=I4B)","tags":"","loc":"interface/io_read_hdr.html"},{"title":"io_read_line – swiftest","text":"interface Called by interface~~io_read_line~~CalledByGraph interface~io_read_line io_read_line proc~io_read_encounter io_read_encounter proc~io_read_encounter->interface~io_read_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function io_read_line(iu, name, d1, d2, d3, d4, d5, d6, out_type, MASS, RADIUS) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu integer(kind=I4B), intent(out) :: name real(kind=DP), intent(out) :: d1 real(kind=DP), intent(out) :: d2 real(kind=DP), intent(out) :: d3 real(kind=DP), intent(out) :: d4 real(kind=DP), intent(out) :: d5 real(kind=DP), intent(out) :: d6 character(len=*), intent(in) :: out_type real(kind=DP), intent(out), optional :: MASS real(kind=DP), intent(out), optional :: RADIUS Return Value integer(kind=I4B)","tags":"","loc":"interface/io_read_line.html"},{"title":"io_write_encounter – swiftest","text":"interface public subroutine io_write_encounter(t, name1, name2, mass1, mass2, radius1, radius2, xh1, xh2, vh1, vh2, encounter_file, out_type) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: name1 integer(kind=I4B), intent(in) :: name2 real(kind=DP), intent(in) :: mass1 real(kind=DP), intent(in) :: mass2 real(kind=DP), intent(in) :: radius1 real(kind=DP), intent(in) :: radius2 real(kind=DP), intent(in), DIMENSION(NDIM) :: xh1 real(kind=DP), intent(in), DIMENSION(NDIM) :: xh2 real(kind=DP), intent(in), DIMENSION(NDIM) :: vh1 real(kind=DP), intent(in), DIMENSION(NDIM) :: vh2 character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type","tags":"","loc":"interface/io_write_encounter.html"},{"title":"io_write_frame – swiftest","text":"interface Called by interface~~io_write_frame~~CalledByGraph interface~io_write_frame io_write_frame program~swiftest_symba swiftest_symba program~swiftest_symba->interface~io_write_frame Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine io_write_frame(t, npl, ntp, swiftest_plA, swiftest_tpA, outfile, out_type, out_form, out_stat) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp type(swiftest_pl), intent(inout) :: swiftest_plA type(swiftest_tp), intent(inout) :: swiftest_tpA character(len=*), intent(in) :: outfile character(len=*), intent(in) :: out_type character(len=*), intent(in) :: out_form character(len=*), intent(in) :: out_stat","tags":"","loc":"interface/io_write_frame.html"},{"title":"io_write_hdr – swiftest","text":"interface Called by interface~~io_write_hdr~~CalledByGraph interface~io_write_hdr io_write_hdr proc~io_write_frame io_write_frame proc~io_write_frame->interface~io_write_hdr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine io_write_hdr(iu, t, npl, ntp, iout_form, out_type) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: iout_form character(len=*), intent(in) :: out_type","tags":"","loc":"interface/io_write_hdr.html"},{"title":"io_write_line – swiftest","text":"interface Called by interface~~io_write_line~~CalledByGraph interface~io_write_line io_write_line proc~io_write_frame io_write_frame proc~io_write_frame->interface~io_write_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine io_write_line(iu, name, d1, d2, d3, d4, d5, d6, out_type, MASS, RADIUS) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu integer(kind=I4B), intent(in) :: name real(kind=DP), intent(in) :: d1 real(kind=DP), intent(in) :: d2 real(kind=DP), intent(in) :: d3 real(kind=DP), intent(in) :: d4 real(kind=DP), intent(in) :: d5 real(kind=DP), intent(in) :: d6 character(len=*), intent(in) :: out_type real(kind=DP), intent(in), optional :: MASS real(kind=DP), intent(in), optional :: RADIUS","tags":"","loc":"interface/io_write_line.html"},{"title":"obl_acc – swiftest","text":"interface Called by interface~~obl_acc~~CalledByGraph interface~obl_acc obl_acc proc~helio_getacch_tp helio_getacch_tp proc~helio_getacch_tp->interface~obl_acc proc~helio_getacch helio_getacch proc~helio_getacch->interface~obl_acc proc~symba_getacch_tp symba_getacch_tp proc~symba_getacch_tp->interface~obl_acc proc~symba_helio_getacch symba_helio_getacch proc~symba_helio_getacch->interface~obl_acc proc~symba_getacch symba_getacch proc~symba_getacch->interface~obl_acc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine obl_acc(npl, swiftest_plA, j2rp2, j4rp4, xh, irh, aobl) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(swiftest_pl), intent(inout) :: swiftest_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in), DIMENSION(NDIM, npl) :: xh real(kind=DP), intent(in), DIMENSION(npl) :: irh real(kind=DP), intent(out), DIMENSION(NDIM, npl) :: aobl","tags":"","loc":"interface/obl_acc.html"},{"title":"obl_acc_tp – swiftest","text":"interface Called by interface~~obl_acc_tp~~CalledByGraph interface~obl_acc_tp obl_acc_tp proc~helio_getacch_tp helio_getacch_tp proc~helio_getacch_tp->interface~obl_acc_tp proc~symba_getacch_tp symba_getacch_tp proc~symba_getacch_tp->interface~obl_acc_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine obl_acc_tp(ntp, xht, j2rp2, j4rp4, irht, aoblt, msun) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp real(kind=DP), intent(in), DIMENSION(NDIM, ntp) :: xht real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in), DIMENSION(ntp) :: irht real(kind=DP), intent(out), DIMENSION(NDIM, ntp) :: aoblt real(kind=DP), intent(in) :: msun","tags":"","loc":"interface/obl_acc_tp.html"},{"title":"obl_pot – swiftest","text":"interface Called by interface~~obl_pot~~CalledByGraph interface~obl_pot obl_pot proc~symba_energy symba_energy proc~symba_energy->interface~obl_pot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine obl_pot(npl, swiftest_plA, j2rp2, j4rp4, xh, irh, oblpot) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(swiftest_pl), intent(inout) :: swiftest_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in), DIMENSION(NDIM, npl) :: xh real(kind=DP), intent(in), DIMENSION(npl) :: irh real(kind=DP), intent(out) :: oblpot","tags":"","loc":"interface/obl_pot.html"},{"title":"orbel_scget – swiftest","text":"interface Called by interface~~orbel_scget~~CalledByGraph interface~orbel_scget orbel_scget proc~drift_kepu_guess drift_kepu_guess proc~drift_kepu_guess->interface~orbel_scget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine orbel_scget(angle, sx, cx) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: angle real(kind=DP), intent(out) :: sx real(kind=DP), intent(out) :: cx","tags":"","loc":"interface/orbel_scget.html"},{"title":"orbel_xv2aeq – swiftest","text":"interface Called by interface~~orbel_xv2aeq~~CalledByGraph interface~orbel_xv2aeq orbel_xv2aeq proc~symba_casedisruption symba_casedisruption proc~symba_casedisruption->interface~orbel_xv2aeq proc~util_peri util_peri proc~util_peri->interface~orbel_xv2aeq proc~symba_casesupercatastrophic symba_casesupercatastrophic proc~symba_casesupercatastrophic->interface~orbel_xv2aeq proc~symba_peri symba_peri proc~symba_peri->interface~orbel_xv2aeq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine orbel_xv2aeq(x, v, mu, a, e, q) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(NDIM) :: x real(kind=DP), intent(in), DIMENSION(NDIM) :: v real(kind=DP), intent(in) :: mu real(kind=DP), intent(out) :: a real(kind=DP), intent(out) :: e real(kind=DP), intent(out) :: q","tags":"","loc":"interface/orbel_xv2aeq.html"},{"title":"orbel_xv2aqt – swiftest","text":"interface public subroutine orbel_xv2aqt(x, v, mu, a, q, capm, tperi) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(NDIM) :: x real(kind=DP), intent(in), DIMENSION(NDIM) :: v real(kind=DP), intent(in) :: mu real(kind=DP), intent(out) :: a real(kind=DP), intent(out) :: q real(kind=DP), intent(out) :: capm real(kind=DP), intent(out) :: tperi","tags":"","loc":"interface/orbel_xv2aqt.html"},{"title":"orbel_xv2el – swiftest","text":"interface Called by interface~~orbel_xv2el~~CalledByGraph interface~orbel_xv2el orbel_xv2el proc~io_write_frame io_write_frame proc~io_write_frame->interface~orbel_xv2el Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine orbel_xv2el(x, v, mu, a, e, inc, capom, omega, capm) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(NDIM) :: x real(kind=DP), intent(in), DIMENSION(NDIM) :: v real(kind=DP), intent(in) :: mu real(kind=DP), intent(out) :: a real(kind=DP), intent(out) :: e real(kind=DP), intent(out) :: inc real(kind=DP), intent(out) :: capom real(kind=DP), intent(out) :: omega real(kind=DP), intent(out) :: capm","tags":"","loc":"interface/orbel_xv2el.html"},{"title":"python_io_write_frame_pl – swiftest","text":"interface Called by interface~~python_io_write_frame_pl~~CalledByGraph interface~python_io_write_frame_pl python_io_write_frame_pl program~swiftest_symba swiftest_symba program~swiftest_symba->interface~python_io_write_frame_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine python_io_write_frame_pl(t, symba_plA, npl, out_stat) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t type(symba_pl), intent(in) :: symba_plA integer, intent(in) :: npl character(len=*), intent(in) :: out_stat","tags":"","loc":"interface/python_io_write_frame_pl.html"},{"title":"python_io_write_frame_tp – swiftest","text":"interface public subroutine python_io_write_frame_tp(t, symba_tpA, ntp, out_stat) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t type(symba_tp), intent(in) :: symba_tpA integer, intent(in) :: ntp character(len=*), intent(in) :: out_stat","tags":"","loc":"interface/python_io_write_frame_tp.html"},{"title":"rmvs_chk_ind – swiftest","text":"interface public subroutine rmvs_chk_ind(xr, vr, dt, r2crit, iflag) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(NDIM) :: xr real(kind=DP), intent(in), DIMENSION(NDIM) :: vr real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r2crit integer(kind=I4B), intent(out) :: iflag","tags":"","loc":"interface/rmvs_chk_ind.html"},{"title":"symba_casedisruption – swiftest","text":"interface Called by interface~~symba_casedisruption~~CalledByGraph interface~symba_casedisruption symba_casedisruption proc~symba_caseresolve symba_caseresolve proc~symba_caseresolve->interface~symba_casedisruption Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_casedisruption(t, dt, index_enc, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, vbs, symba_plA, nplplenc, plplenc_list, nplmax, ntpmax, fragmax, mres, rres, m1, m2, rad1, rad2, x1, x2, v1, v2) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs type(symba_pl), intent(inout) :: symba_plA integer(kind=I4B), intent(inout) :: nplplenc type(symba_plplenc), intent(inout) :: plplenc_list integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntpmax integer(kind=I4B), intent(inout) :: fragmax real(kind=DP), intent(inout), DIMENSION(3) :: mres real(kind=DP), intent(inout), DIMENSION(3) :: rres real(kind=DP), intent(inout) :: m1 real(kind=DP), intent(inout) :: m2 real(kind=DP), intent(inout) :: rad1 real(kind=DP), intent(inout) :: rad2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v2","tags":"","loc":"interface/symba_casedisruption.html"},{"title":"symba_casehitandrun – swiftest","text":"interface Called by interface~~symba_casehitandrun~~CalledByGraph interface~symba_casehitandrun symba_casehitandrun proc~symba_caseresolve symba_caseresolve proc~symba_caseresolve->interface~symba_casehitandrun Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_casehitandrun(t, index_enc, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, vbs, symba_plA, nplplenc, plplenc_list, nplmax, ntpmax, fragmax, mres, rres, m1, m2, rad1, rad2, x1, x2, v1, v2) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs type(symba_pl), intent(inout) :: symba_plA integer(kind=I4B), intent(inout) :: nplplenc type(symba_plplenc), intent(inout) :: plplenc_list integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntpmax integer(kind=I4B), intent(inout) :: fragmax real(kind=DP), intent(inout), DIMENSION(3) :: mres real(kind=DP), intent(inout), DIMENSION(3) :: rres real(kind=DP), intent(inout) :: m1 real(kind=DP), intent(inout) :: m2 real(kind=DP), intent(inout) :: rad1 real(kind=DP), intent(inout) :: rad2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v2","tags":"","loc":"interface/symba_casehitandrun.html"},{"title":"symba_casemerge – swiftest","text":"interface Called by interface~~symba_casemerge~~CalledByGraph interface~symba_casemerge symba_casemerge proc~symba_caseresolve symba_caseresolve proc~symba_caseresolve->interface~symba_casemerge Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_casemerge(t, dt, index_enc, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, vbs, encounter_file, out_type, npl, ntp, symba_plA, symba_tpA, nplplenc, npltpenc, pltpenc_list, plplenc_list, array_index1_child, array_index2_child, m1, m2, rad1, rad2, x1, x2, v1, v2) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type integer(kind=I4B), intent(inout) :: npl integer(kind=I4B), intent(inout) :: ntp type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA integer(kind=I4B), intent(inout) :: nplplenc integer(kind=I4B), intent(inout) :: npltpenc type(symba_pltpenc), intent(inout) :: pltpenc_list type(symba_plplenc), intent(inout) :: plplenc_list integer(kind=I4B), intent(inout), DIMENSION(npl) :: array_index1_child integer(kind=I4B), intent(inout), DIMENSION(npl) :: array_index2_child real(kind=DP), intent(inout) :: m1 real(kind=DP), intent(inout) :: m2 real(kind=DP), intent(inout) :: rad1 real(kind=DP), intent(inout) :: rad2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v2","tags":"","loc":"interface/symba_casemerge.html"},{"title":"symba_caseresolve – swiftest","text":"interface Called by interface~~symba_caseresolve~~CalledByGraph interface~symba_caseresolve symba_caseresolve proc~symba_fragmentation symba_fragmentation proc~symba_fragmentation->interface~symba_caseresolve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_caseresolve(t, dt, index_enc, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, vbs, encounter_file, out_type, npl, ntp, symba_plA, symba_tpA, nplplenc, npltpenc, pltpenc_list, plplenc_list, regime, nplmax, ntpmax, fragmax, mres, rres, array_index1_child, array_index2_child, m1, m2, rad1, rad2, x1, x2, v1, v2) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type integer(kind=I4B), intent(inout) :: npl integer(kind=I4B), intent(inout) :: ntp type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA integer(kind=I4B), intent(inout) :: nplplenc integer(kind=I4B), intent(inout) :: npltpenc type(symba_pltpenc), intent(inout) :: pltpenc_list type(symba_plplenc), intent(inout) :: plplenc_list integer(kind=I4B), intent(in) :: regime integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntpmax integer(kind=I4B), intent(inout) :: fragmax real(kind=DP), intent(inout), DIMENSION(3) :: mres real(kind=DP), intent(inout), DIMENSION(3) :: rres integer(kind=I4B), intent(inout), DIMENSION(npl) :: array_index1_child integer(kind=I4B), intent(inout), DIMENSION(npl) :: array_index2_child real(kind=DP), intent(inout) :: m1 real(kind=DP), intent(inout) :: m2 real(kind=DP), intent(inout) :: rad1 real(kind=DP), intent(inout) :: rad2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v2","tags":"","loc":"interface/symba_caseresolve.html"},{"title":"symba_casesupercatastrophic – swiftest","text":"interface Called by interface~~symba_casesupercatastrophic~~CalledByGraph interface~symba_casesupercatastrophic symba_casesupercatastrophic proc~symba_caseresolve symba_caseresolve proc~symba_caseresolve->interface~symba_casesupercatastrophic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_casesupercatastrophic(t, dt, index_enc, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, vbs, symba_plA, nplplenc, plplenc_list, nplmax, ntpmax, fragmax, mres, rres, m1, m2, rad1, rad2, x1, x2, v1, v2) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs type(symba_pl), intent(inout) :: symba_plA integer(kind=I4B), intent(inout) :: nplplenc type(symba_plplenc), intent(inout) :: plplenc_list integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntpmax integer(kind=I4B), intent(inout) :: fragmax real(kind=DP), intent(inout), DIMENSION(3) :: mres real(kind=DP), intent(inout), DIMENSION(3) :: rres real(kind=DP), intent(inout) :: m1 real(kind=DP), intent(inout) :: m2 real(kind=DP), intent(inout) :: rad1 real(kind=DP), intent(inout) :: rad2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v2","tags":"","loc":"interface/symba_casesupercatastrophic.html"},{"title":"symba_chk – swiftest","text":"interface public subroutine symba_chk(xr, vr, rhill1, rhill2, dt, irec, lencounter, lvdotr) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: xr real(kind=DP), intent(in), DIMENSION(:) :: vr real(kind=DP), intent(in) :: rhill1 real(kind=DP), intent(in) :: rhill2 real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: irec logical(kind=LGT), intent(out) :: lencounter logical(kind=LGT), intent(out) :: lvdotr","tags":"","loc":"interface/symba_chk.html"},{"title":"symba_discard_merge_pl – swiftest","text":"interface Called by interface~~symba_discard_merge_pl~~CalledByGraph interface~symba_discard_merge_pl symba_discard_merge_pl program~swiftest_symba swiftest_symba program~swiftest_symba->interface~symba_discard_merge_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_discard_merge_pl(t, npl, symba_plA, nplplenc, plplenc_list) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(inout) :: npl type(symba_pl) :: symba_plA integer(kind=I4B), intent(in) :: nplplenc type(symba_plplenc), intent(in) :: plplenc_list","tags":"","loc":"interface/symba_discard_merge_pl.html"},{"title":"symba_discard_peri_pl – swiftest","text":"interface public subroutine symba_discard_peri_pl(t, npl, symba_plA, msys, qmin, qmin_alo, qmin_ahi, qmin_coord, ldiscards) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl type(symba_pl), intent(inout) :: symba_plA real(kind=DP), intent(in) :: msys real(kind=DP), intent(in) :: qmin real(kind=DP), intent(in) :: qmin_alo real(kind=DP), intent(in) :: qmin_ahi character(len=*), intent(in) :: qmin_coord logical(kind=LGT), intent(inout) :: ldiscards","tags":"","loc":"interface/symba_discard_peri_pl.html"},{"title":"symba_discard_pl – swiftest","text":"interface Called by interface~~symba_discard_pl~~CalledByGraph interface~symba_discard_pl symba_discard_pl program~swiftest_symba swiftest_symba program~swiftest_symba->interface~symba_discard_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_discard_pl(t, npl, nplmax, nsp, symba_plA, rmin, rmax, rmaxu, qmin, qmin_coord, qmin_alo, qmin_ahi, j2rp2, j4rp4, eoffset) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(inout) :: npl integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(inout) :: nsp type(symba_pl), intent(inout) :: symba_plA real(kind=DP), intent(in) :: rmin real(kind=DP), intent(in) :: rmax real(kind=DP), intent(in) :: rmaxu real(kind=DP), intent(in) :: qmin character(len=*), intent(in) :: qmin_coord real(kind=DP), intent(in) :: qmin_alo real(kind=DP), intent(in) :: qmin_ahi real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(inout) :: eoffset","tags":"","loc":"interface/symba_discard_pl.html"},{"title":"symba_discard_sun_pl – swiftest","text":"interface public subroutine symba_discard_sun_pl(t, npl, msys, swiftest_plA, rmin, rmax, rmaxu, ldiscards) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl real(kind=DP), intent(in) :: msys type(swiftest_pl), intent(inout) :: swiftest_plA real(kind=DP), intent(in) :: rmin real(kind=DP), intent(in) :: rmax real(kind=DP), intent(in) :: rmaxu logical(kind=LGT), intent(inout) :: ldiscards","tags":"","loc":"interface/symba_discard_sun_pl.html"},{"title":"symba_discard_tp – swiftest","text":"interface Called by interface~~symba_discard_tp~~CalledByGraph interface~symba_discard_tp symba_discard_tp program~swiftest_symba swiftest_symba program~swiftest_symba->interface~symba_discard_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_discard_tp(t, npl, ntp, nsp, symba_plA, symba_tpA, dt, rmin, rmax, rmaxu, qmin, qmin_coord, qmin_alo, qmin_ahi, lclose, lrhill_present) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(inout) :: ntp integer(kind=I4B), intent(inout) :: nsp type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: rmin real(kind=DP), intent(in) :: rmax real(kind=DP), intent(in) :: rmaxu real(kind=DP), intent(in) :: qmin character(len=*), intent(in) :: qmin_coord real(kind=DP), intent(in) :: qmin_alo real(kind=DP), intent(in) :: qmin_ahi logical(kind=LGT), intent(in) :: lclose logical(kind=LGT), intent(in) :: lrhill_present","tags":"","loc":"interface/symba_discard_tp.html"},{"title":"symba_energy – swiftest","text":"interface Called by interface~~symba_energy~~CalledByGraph interface~symba_energy symba_energy program~swiftest_symba swiftest_symba program~swiftest_symba->interface~symba_energy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_energy(npl, swiftest_plA, j2rp2, j4rp4, ke, pe, te, htot) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(swiftest_pl), intent(inout) :: swiftest_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(out) :: ke real(kind=DP), intent(out) :: pe real(kind=DP), intent(out) :: te real(kind=DP), intent(out), DIMENSION(NDIM) :: htot","tags":"","loc":"interface/symba_energy.html"},{"title":"symba_fragmentation – swiftest","text":"interface Called by interface~~symba_fragmentation~~CalledByGraph interface~symba_fragmentation symba_fragmentation proc~symba_step_recur symba_step_recur proc~symba_step_recur->interface~symba_fragmentation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_fragmentation(t, dt, index_enc, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, vbs, encounter_file, out_type, npl, ntp, symba_plA, symba_tpA, nplplenc, npltpenc, pltpenc_list, plplenc_list, nplmax, ntpmax, fragmax) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type integer(kind=I4B), intent(inout) :: npl integer(kind=I4B), intent(inout) :: ntp type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA integer(kind=I4B), intent(inout) :: nplplenc integer(kind=I4B), intent(inout) :: npltpenc type(symba_pltpenc), intent(inout) :: pltpenc_list type(symba_plplenc), intent(inout) :: plplenc_list integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntpmax integer(kind=I4B), intent(inout) :: fragmax","tags":"","loc":"interface/symba_fragmentation.html"},{"title":"symba_getacch – swiftest","text":"interface Called by interface~~symba_getacch~~CalledByGraph interface~symba_getacch symba_getacch proc~symba_step_interp symba_step_interp proc~symba_step_interp->interface~symba_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_getacch(lextra_force, t, npl, nplm, symba_plA, j2rp2, j4rp4, nplplenc, plplenc_list) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm type(symba_pl), intent(inout) :: symba_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 integer(kind=I4B), intent(in) :: nplplenc type(symba_plplenc), intent(in) :: plplenc_list","tags":"","loc":"interface/symba_getacch.html"},{"title":"symba_getacch_tp – swiftest","text":"interface public subroutine symba_getacch_tp(lextra_force, t, npl, nplm, nplmax, ntp, ntpmax, symba_plA, symba_tpA, xh, j2rp2, j4rp4, npltpenc, pltpenc_list) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: ntpmax type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA real(kind=DP), intent(in), DIMENSION(NDIM, npl) :: xh real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 integer(kind=I4B), intent(in) :: npltpenc type(symba_pltpenc), intent(in) :: pltpenc_list","tags":"","loc":"interface/symba_getacch_tp.html"},{"title":"symba_helio_drift – swiftest","text":"interface Called by interface~~symba_helio_drift~~CalledByGraph interface~symba_helio_drift symba_helio_drift proc~symba_step_interp symba_step_interp proc~symba_step_interp->interface~symba_helio_drift proc~symba_step_recur symba_step_recur proc~symba_step_recur->interface~symba_helio_drift Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_helio_drift(irec, npl, symba_plA, dt) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: irec integer(kind=I4B), intent(in) :: npl type(symba_pl), intent(inout) :: symba_plA real(kind=DP), intent(in) :: dt","tags":"","loc":"interface/symba_helio_drift.html"},{"title":"symba_helio_drift_tp – swiftest","text":"interface public subroutine symba_helio_drift_tp(irec, ntp, symba_tpA, mu, dt) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: irec integer(kind=I4B), intent(in) :: ntp type(symba_tp), intent(inout) :: symba_tpA real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: dt","tags":"","loc":"interface/symba_helio_drift_tp.html"},{"title":"symba_helio_getacch – swiftest","text":"interface Called by interface~~symba_helio_getacch~~CalledByGraph interface~symba_helio_getacch symba_helio_getacch proc~symba_step_helio_pl symba_step_helio_pl proc~symba_step_helio_pl->interface~symba_helio_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_helio_getacch(lflag, lextra_force, t, npl, nplm, nplmax, helio_plA, j2rp2, j4rp4) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lflag logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm integer(kind=I4B), intent(in) :: nplmax type(helio_pl), intent(inout) :: helio_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4","tags":"","loc":"interface/symba_helio_getacch.html"},{"title":"symba_helio_getacch_int – swiftest","text":"interface Called by interface~~symba_helio_getacch_int~~CalledByGraph interface~symba_helio_getacch_int symba_helio_getacch_int proc~symba_helio_getacch symba_helio_getacch proc~symba_helio_getacch->interface~symba_helio_getacch_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_helio_getacch_int(npl, nplm, helio_plA) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm type(helio_pl), intent(inout) :: helio_plA","tags":"","loc":"interface/symba_helio_getacch_int.html"},{"title":"symba_kick – swiftest","text":"interface Called by interface~~symba_kick~~CalledByGraph interface~symba_kick symba_kick proc~symba_step_recur symba_step_recur proc~symba_step_recur->interface~symba_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_kick(irec, nplplenc, npltpenc, plplenc_list, pltpenc_list, dt, sgn, symba_plA, symba_tpA) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: irec integer(kind=I4B), intent(in) :: nplplenc integer(kind=I4B), intent(in) :: npltpenc type(symba_plplenc), intent(in) :: plplenc_list type(symba_pltpenc), intent(in) :: pltpenc_list real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: sgn type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA","tags":"","loc":"interface/symba_kick.html"},{"title":"symba_merge_pl – swiftest","text":"interface Called by interface~~symba_merge_pl~~CalledByGraph interface~symba_merge_pl symba_merge_pl proc~symba_step_recur symba_step_recur proc~symba_step_recur->interface~symba_merge_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_merge_pl(t, dt, index_enc, nplplenc, plplenc_list, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, vbs, encounter_file, out_type, npl, symba_plA, symba_tpA) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(in) :: nplplenc type(symba_plplenc), intent(inout) :: plplenc_list integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type integer(kind=I4B), intent(inout) :: npl type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA","tags":"","loc":"interface/symba_merge_pl.html"},{"title":"symba_merge_tp – swiftest","text":"interface Called by interface~~symba_merge_tp~~CalledByGraph interface~symba_merge_tp symba_merge_tp proc~symba_step_recur symba_step_recur proc~symba_step_recur->interface~symba_merge_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_merge_tp(t, dt, index_enc, npltpenc, pltpenc_list, vbs, encounter_file, out_type, symba_plA, symba_tpA) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(in) :: npltpenc type(symba_pltpenc), intent(inout) :: pltpenc_list real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA","tags":"","loc":"interface/symba_merge_tp.html"},{"title":"symba_peri – swiftest","text":"interface Called by interface~~symba_peri~~CalledByGraph interface~symba_peri symba_peri proc~symba_discard_peri_pl symba_discard_peri_pl proc~symba_discard_peri_pl->interface~symba_peri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_peri(lfirst, npl, symba_plA, msys, qmin_coord) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lfirst integer(kind=I4B), intent(in) :: npl type(symba_pl), intent(inout) :: symba_plA real(kind=DP), intent(in) :: msys character(len=*), intent(in) :: qmin_coord","tags":"","loc":"interface/symba_peri.html"},{"title":"symba_rearray – swiftest","text":"interface Called by interface~~symba_rearray~~CalledByGraph interface~symba_rearray symba_rearray program~swiftest_symba swiftest_symba program~swiftest_symba->interface~symba_rearray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_rearray(npl, ntp, nsppl, nsptp, symba_plA, symba_tpA, nmergeadd, mergeadd_list, discard_plA, discard_tpA, feature) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: npl integer(kind=I4B), intent(inout) :: ntp integer(kind=I4B), intent(inout) :: nsppl integer(kind=I4B), intent(inout) :: nsptp type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA integer(kind=I4B), intent(inout) :: nmergeadd type(symba_merger), intent(inout) :: mergeadd_list type(swiftest_pl), intent(inout) :: discard_plA type(swiftest_tp), intent(inout) :: discard_tpA type(feature_list), intent(in) :: feature","tags":"","loc":"interface/symba_rearray.html"},{"title":"symba_reorder_pl – swiftest","text":"interface Called by interface~~symba_reorder_pl~~CalledByGraph interface~symba_reorder_pl symba_reorder_pl program~swiftest_symba swiftest_symba program~swiftest_symba->interface~symba_reorder_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_reorder_pl(npl, symba_plA) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(symba_pl), intent(inout) :: symba_plA","tags":"","loc":"interface/symba_reorder_pl.html"},{"title":"symba_setup – swiftest","text":"interface public subroutine symba_setup(npl, ntp, symba_plA, symba_tpA, symba_pl1P, symba_tp1P, swiftest_pl1P, swiftest_tp1P) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA type(symba_pl), POINTER :: symba_pl1P type(symba_tp), POINTER :: symba_tp1P type(swiftest_pl), POINTER :: swiftest_pl1P type(swiftest_tp), POINTER :: swiftest_tp1P","tags":"","loc":"interface/symba_setup.html"},{"title":"symba_step – swiftest","text":"interface Called by interface~~symba_step~~CalledByGraph interface~symba_step symba_step program~swiftest_symba swiftest_symba program~swiftest_symba->interface~symba_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_step(lfirst, lextra_force, lclose, t, npl, nplmax, ntp, ntpmax, symba_plA, symba_tpA, j2rp2, j4rp4, dt, nplplenc, npltpenc, plplenc_list, pltpenc_list, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, mtiny, encounter_file, out_type, fragmax, feature) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(inout) :: lfirst logical(kind=LGT), intent(in) :: lextra_force logical(kind=LGT), intent(in) :: lclose real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: ntpmax type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(inout) :: nplplenc integer(kind=I4B), intent(inout) :: npltpenc type(symba_plplenc), intent(inout) :: plplenc_list type(symba_pltpenc), intent(inout) :: pltpenc_list integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in) :: mtiny character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type integer(kind=I4B), intent(inout) :: fragmax type(feature_list) :: feature","tags":"","loc":"interface/symba_step.html"},{"title":"symba_step_helio – swiftest","text":"interface Called by interface~~symba_step_helio~~CalledByGraph interface~symba_step_helio symba_step_helio proc~symba_step symba_step proc~symba_step->interface~symba_step_helio Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_step_helio(lfirst, lextra_force, t, npl, nplm, nplmax, ntp, ntpmax, helio_plA, helio_tpA, j2rp2, j4rp4, dt) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(inout) :: lfirst logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: ntpmax type(helio_pl), intent(inout) :: helio_plA type(helio_tp), intent(inout) :: helio_tpA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: dt","tags":"","loc":"interface/symba_step_helio.html"},{"title":"symba_step_helio_pl – swiftest","text":"interface Called by interface~~symba_step_helio_pl~~CalledByGraph interface~symba_step_helio_pl symba_step_helio_pl proc~symba_step_helio symba_step_helio proc~symba_step_helio->interface~symba_step_helio_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_step_helio_pl(lfirst, lextra_force, t, npl, nplm, nplmax, helio_plA, j2rp2, j4rp4, dt, xbeg, xend, ptb, pte) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(inout) :: lfirst logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm integer(kind=I4B), intent(in) :: nplmax type(helio_pl), intent(inout) :: helio_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: dt real(kind=DP), intent(out), DIMENSION(NDIM, nplm) :: xbeg real(kind=DP), intent(out), DIMENSION(NDIM, nplm) :: xend real(kind=DP), intent(out), DIMENSION(NDIM) :: ptb real(kind=DP), intent(out), DIMENSION(NDIM) :: pte","tags":"","loc":"interface/symba_step_helio_pl.html"},{"title":"symba_step_interp – swiftest","text":"interface Called by interface~~symba_step_interp~~CalledByGraph interface~symba_step_interp symba_step_interp proc~symba_step symba_step proc~symba_step->interface~symba_step_interp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_step_interp(lextra_force, lclose, t, npl, nplm, nplmax, ntp, ntpmax, symba_plA, symba_tpA, j2rp2, j4rp4, dt, eoffset, nplplenc, npltpenc, plplenc_list, pltpenc_list, nmergeadd, nmergesub, mergeadd_list, mergesub_list, encounter_file, out_type, fragmax, feature) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lextra_force logical(kind=LGT), intent(in) :: lclose real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: ntpmax type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: dt real(kind=DP), intent(inout) :: eoffset integer(kind=I4B), intent(in) :: nplplenc integer(kind=I4B), intent(in) :: npltpenc type(symba_plplenc), intent(inout) :: plplenc_list type(symba_pltpenc), intent(inout) :: pltpenc_list integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type integer(kind=I4B), intent(inout) :: fragmax type(feature_list), intent(in) :: feature","tags":"","loc":"interface/symba_step_interp.html"},{"title":"symba_step_recur – swiftest","text":"interface Called by interface~~symba_step_recur~~CalledByGraph interface~symba_step_recur symba_step_recur proc~symba_step_interp symba_step_interp proc~symba_step_interp->interface~symba_step_recur Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine symba_step_recur(lclose, t, ireci, npl, nplm, ntp, symba_plA, symba_tpA, dt0, eoffset, nplplenc, npltpenc, plplenc_list, pltpenc_list, nmergeadd, nmergesub, mergeadd_list, mergesub_list, encounter_file, out_type, nplmax, ntpmax, fragmax, feature) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lclose real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: ireci integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm integer(kind=I4B), intent(in) :: ntp type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA real(kind=DP), intent(in) :: dt0 real(kind=DP), intent(inout) :: eoffset integer(kind=I4B), intent(in) :: nplplenc integer(kind=I4B), intent(in) :: npltpenc type(symba_plplenc), intent(inout) :: plplenc_list type(symba_pltpenc), intent(inout) :: pltpenc_list integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntpmax integer(kind=I4B), intent(in) :: fragmax type(feature_list), intent(in) :: feature","tags":"","loc":"interface/symba_step_recur.html"},{"title":"symba_user_getacch – swiftest","text":"interface public subroutine symba_user_getacch(t, npl, symba_plA) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl type(symba_pl), intent(inout) :: symba_plA","tags":"","loc":"interface/symba_user_getacch.html"},{"title":"symba_user_getacch_tp – swiftest","text":"interface public subroutine symba_user_getacch_tp(t, ntp, symba_tpA) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: ntp type(symba_tp), intent(inout) :: symba_tpA","tags":"","loc":"interface/symba_user_getacch_tp.html"},{"title":"util_exit – swiftest","text":"interface Called by interface~~util_exit~~CalledByGraph interface~util_exit util_exit proc~helio_drift helio_drift proc~helio_drift->interface~util_exit proc~util_sort_sp util_sort_sp proc~util_sort_sp->interface~util_exit proc~io_discard_write_symba io_discard_write_symba proc~io_discard_write_symba->interface~util_exit proc~io_dump_tp io_dump_tp proc~io_dump_tp->interface~util_exit proc~io_write_frame io_write_frame proc~io_write_frame->interface~util_exit proc~util_sort_i4b util_sort_i4b proc~util_sort_i4b->interface~util_exit proc~symba_step symba_step proc~symba_step->interface~util_exit proc~io_read_encounter io_read_encounter proc~io_read_encounter->interface~util_exit proc~util_valid util_valid proc~util_valid->interface~util_exit proc~util_sort_dp util_sort_dp proc~util_sort_dp->interface~util_exit proc~python_io_write_frame_pl python_io_write_frame_pl proc~python_io_write_frame_pl->interface~util_exit program~tool_encounter_read tool_encounter_read program~tool_encounter_read->interface~util_exit interface~io_read_param_in io_read_param_in program~tool_encounter_read->interface~io_read_param_in proc~io_getn io_getn proc~io_getn->interface~util_exit proc~io_init_pl io_init_pl proc~io_init_pl->interface~util_exit proc~io_read_line io_read_line proc~io_read_line->interface~util_exit proc~symba_helio_drift symba_helio_drift proc~symba_helio_drift->interface~util_exit program~swiftest_symba swiftest_symba program~swiftest_symba->interface~util_exit program~swiftest_symba->interface~io_read_param_in proc~io_read_param_in io_read_param_in proc~io_read_param_in->interface~util_exit proc~io_write_line io_write_line proc~io_write_line->interface~util_exit proc~util_index util_index proc~util_index->interface~util_exit proc~io_dump_pl io_dump_pl proc~io_dump_pl->interface~util_exit proc~python_io_write_frame_tp python_io_write_frame_tp proc~python_io_write_frame_tp->interface~util_exit proc~io_write_hdr io_write_hdr proc~io_write_hdr->interface~util_exit proc~io_write_encounter io_write_encounter proc~io_write_encounter->interface~util_exit interface~io_read_param_in->proc~io_read_param_in Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine util_exit(code) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: code","tags":"","loc":"interface/util_exit.html"},{"title":"util_hills – swiftest","text":"interface public subroutine util_hills(npl, swiftest_plA) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(swiftest_pl), intent(inout) :: swiftest_plA","tags":"","loc":"interface/util_hills.html"},{"title":"util_index – swiftest","text":"interface Called by interface~~util_index~~CalledByGraph interface~util_index util_index proc~symba_reorder_pl symba_reorder_pl proc~symba_reorder_pl->interface~util_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine util_index(arr, index) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: arr integer(kind=I4B), intent(out), DIMENSION(:) :: index","tags":"","loc":"interface/util_index.html"},{"title":"util_peri – swiftest","text":"interface Called by interface~~util_peri~~CalledByGraph interface~util_peri util_peri proc~discard_peri discard_peri proc~discard_peri->interface~util_peri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine util_peri(lfirst, ntp, swiftest_tpA, mu, msys, qmin_coord) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lfirst integer(kind=I4B), intent(in) :: ntp type(swiftest_tp), intent(inout) :: swiftest_tpA real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: msys character(len=*), intent(in) :: qmin_coord","tags":"","loc":"interface/util_peri.html"},{"title":"util_resize_pl – swiftest","text":"interface Called by interface~~util_resize_pl~~CalledByGraph interface~util_resize_pl util_resize_pl proc~symba_rearray symba_rearray proc~symba_rearray->interface~util_resize_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine util_resize_pl(symba_plA, npl_new, npl_old) Arguments Type Intent Optional Attributes Name type(symba_pl), intent(inout) :: symba_plA integer(kind=I4B), intent(in) :: npl_new integer(kind=I4B), intent(in) :: npl_old","tags":"","loc":"interface/util_resize_pl.html"},{"title":"util_sort – swiftest","text":"public interface util_sort Called by interface~~util_sort~~CalledByGraph interface~util_sort util_sort proc~util_valid util_valid proc~util_valid->interface~util_sort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines util_sort_i4b util_sort_sp util_sort_dp Subroutines public subroutine util_sort_i4b(arr) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), DIMENSION(:) :: arr public subroutine util_sort_sp(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: arr public subroutine util_sort_dp(arr) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), DIMENSION(:) :: arr","tags":"","loc":"interface/util_sort.html"},{"title":"util_toupper – swiftest","text":"interface Called by interface~~util_toupper~~CalledByGraph interface~util_toupper util_toupper proc~io_open io_open proc~io_open->interface~util_toupper proc~io_read_param_in io_read_param_in proc~io_read_param_in->interface~util_toupper interface~io_read_param_in io_read_param_in interface~io_read_param_in->proc~io_read_param_in program~swiftest_symba swiftest_symba program~swiftest_symba->interface~io_read_param_in program~tool_encounter_read tool_encounter_read program~tool_encounter_read->interface~io_read_param_in Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine util_toupper(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string","tags":"","loc":"interface/util_toupper.html"},{"title":"util_valid – swiftest","text":"interface Called by interface~~util_valid~~CalledByGraph interface~util_valid util_valid program~swiftest_symba swiftest_symba program~swiftest_symba->interface~util_valid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine util_valid(npl, ntp, swiftest_plA, swiftest_tpA) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp type(swiftest_pl), intent(inout) :: swiftest_plA type(swiftest_tp), intent(inout) :: swiftest_tpA","tags":"","loc":"interface/util_valid.html"},{"title":"util_version – swiftest","text":"interface Called by interface~~util_version~~CalledByGraph interface~util_version util_version program~swiftest_symba swiftest_symba program~swiftest_symba->interface~util_version Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine util_version() Arguments None","tags":"","loc":"interface/util_version.html"},{"title":"util_kahan_sum – swiftest","text":"interface public function util_kahan_sum(xsum_current, xi, xerror) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: xsum_current real(kind=DP), intent(in) :: xi real(kind=DP), intent(inout) :: xerror Return Value real(kind=DP)","tags":"","loc":"interface/util_kahan_sum.html"},{"title":"collresolve_resolve – swiftest","text":"interface Called by interface~~collresolve_resolve~~CalledByGraph interface~collresolve_resolve collresolve_resolve proc~symba_fragmentation symba_fragmentation proc~symba_fragmentation->interface~collresolve_resolve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function collresolve_resolve(model, m1, m2, r1, r2, p1, p2, v1, v2, n, mres, rres, pres, vres) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: model real(kind=DP), intent(in) :: m1 real(kind=DP), intent(in) :: m2 real(kind=DP), intent(in) :: r1 real(kind=DP), intent(in) :: r2 real(kind=DP), intent(in), DIMENSION(3) :: p1 real(kind=DP), intent(in), DIMENSION(3) :: p2 real(kind=DP), intent(in), DIMENSION(3) :: v1 real(kind=DP), intent(in), DIMENSION(3) :: v2 integer, intent(in) :: n real(kind=DP), intent(out), DIMENSION(n+1) :: mres real(kind=DP), intent(out), DIMENSION(n+1) :: rres real(kind=DP), intent(out), DIMENSION(3,n+1) :: pres real(kind=DP), intent(out), DIMENSION(3,n+1) :: vres Return Value integer(kind=I4B)","tags":"","loc":"interface/collresolve_resolve.html"},{"title":"util_regime – swiftest","text":"interface public subroutine util_regime(symba_plA, index1, index2, regime, Mlr, Mslr) Arguments Type Intent Optional Attributes Name type(symba_pl), intent(inout) :: symba_plA integer(kind=I4B), intent(in) :: index1 integer(kind=I4B), intent(in) :: index2 integer(kind=I4B), intent(out) :: regime real(kind=DP), intent(out) :: Mlr real(kind=DP), intent(out) :: Mslr","tags":"","loc":"interface/util_regime.html"},{"title":"swiftest_pl_allocate – swiftest","text":"public subroutine swiftest_pl_allocate(swiftest_plA, npl) Uses swiftest module_swiftest proc~~swiftest_pl_allocate~~UsesGraph proc~swiftest_pl_allocate swiftest_pl_allocate module~module_swiftest module_swiftest proc~swiftest_pl_allocate->module~module_swiftest module~swiftest swiftest proc~swiftest_pl_allocate->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( swiftest_pl ), intent(inout) :: swiftest_plA integer(kind=I4B), intent(in) :: npl Called by proc~~swiftest_pl_allocate~~CalledByGraph proc~swiftest_pl_allocate swiftest_pl_allocate proc~helio_pl_allocate helio_pl_allocate proc~helio_pl_allocate->proc~swiftest_pl_allocate proc~symba_rearray symba_rearray proc~symba_rearray->proc~swiftest_pl_allocate proc~symba_pl_allocate symba_pl_allocate proc~symba_pl_allocate->proc~helio_pl_allocate proc~util_resize_pl util_resize_pl proc~util_resize_pl->proc~symba_pl_allocate program~swiftest_symba swiftest_symba program~swiftest_symba->proc~symba_pl_allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/swiftest_pl_allocate.html"},{"title":"helio_pl_allocate – swiftest","text":"public subroutine helio_pl_allocate(helio_plA, npl) Uses swiftest module_helio proc~~helio_pl_allocate~~UsesGraph proc~helio_pl_allocate helio_pl_allocate module~module_helio module_helio proc~helio_pl_allocate->module~module_helio module~swiftest swiftest proc~helio_pl_allocate->module~swiftest module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( helio_pl ), intent(inout) :: helio_plA integer(kind=I4B), intent(in) :: npl Calls proc~~helio_pl_allocate~~CallsGraph proc~helio_pl_allocate helio_pl_allocate proc~swiftest_pl_allocate swiftest_pl_allocate proc~helio_pl_allocate->proc~swiftest_pl_allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helio_pl_allocate~~CalledByGraph proc~helio_pl_allocate helio_pl_allocate proc~symba_pl_allocate symba_pl_allocate proc~symba_pl_allocate->proc~helio_pl_allocate proc~util_resize_pl util_resize_pl proc~util_resize_pl->proc~symba_pl_allocate program~swiftest_symba swiftest_symba program~swiftest_symba->proc~symba_pl_allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_pl_allocate.html"},{"title":"symba_pl_allocate – swiftest","text":"public subroutine symba_pl_allocate(symba_plA, npl) Uses swiftest module_symba proc~~symba_pl_allocate~~UsesGraph proc~symba_pl_allocate symba_pl_allocate module~module_symba module_symba proc~symba_pl_allocate->module~module_symba module~swiftest swiftest proc~symba_pl_allocate->module~swiftest module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( symba_pl ), intent(inout) :: symba_plA integer(kind=I4B), intent(in) :: npl Calls proc~~symba_pl_allocate~~CallsGraph proc~symba_pl_allocate symba_pl_allocate proc~helio_pl_allocate helio_pl_allocate proc~symba_pl_allocate->proc~helio_pl_allocate proc~swiftest_pl_allocate swiftest_pl_allocate proc~helio_pl_allocate->proc~swiftest_pl_allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_pl_allocate~~CalledByGraph proc~symba_pl_allocate symba_pl_allocate proc~util_resize_pl util_resize_pl proc~util_resize_pl->proc~symba_pl_allocate program~swiftest_symba swiftest_symba program~swiftest_symba->proc~symba_pl_allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_pl_allocate.html"},{"title":"symba_plplenc_allocate – swiftest","text":"public subroutine symba_plplenc_allocate(plplenc_list, nplplenc) Uses swiftest module_symba proc~~symba_plplenc_allocate~~UsesGraph proc~symba_plplenc_allocate symba_plplenc_allocate module~module_symba module_symba proc~symba_plplenc_allocate->module~module_symba module~swiftest swiftest proc~symba_plplenc_allocate->module~swiftest module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( symba_plplenc ), intent(inout) :: plplenc_list integer(kind=I4B), intent(in) :: nplplenc Called by proc~~symba_plplenc_allocate~~CalledByGraph proc~symba_plplenc_allocate symba_plplenc_allocate program~swiftest_symba swiftest_symba program~swiftest_symba->proc~symba_plplenc_allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_plplenc_allocate.html"},{"title":"symba_merger_allocate – swiftest","text":"public subroutine symba_merger_allocate(mergeadd_list, nmergeadd) Uses swiftest module_symba proc~~symba_merger_allocate~~UsesGraph proc~symba_merger_allocate symba_merger_allocate module~module_symba module_symba proc~symba_merger_allocate->module~module_symba module~swiftest swiftest proc~symba_merger_allocate->module~swiftest module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( symba_merger ), intent(inout) :: mergeadd_list integer(kind=I4B), intent(in) :: nmergeadd Called by proc~~symba_merger_allocate~~CalledByGraph proc~symba_merger_allocate symba_merger_allocate program~swiftest_symba swiftest_symba program~swiftest_symba->proc~symba_merger_allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_merger_allocate.html"},{"title":"swiftest_tp_allocate – swiftest","text":"public subroutine swiftest_tp_allocate(swiftest_tpA, ntp) Uses swiftest module_swiftest proc~~swiftest_tp_allocate~~UsesGraph proc~swiftest_tp_allocate swiftest_tp_allocate module~module_swiftest module_swiftest proc~swiftest_tp_allocate->module~module_swiftest module~swiftest swiftest proc~swiftest_tp_allocate->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( swiftest_tp ), intent(inout) :: swiftest_tpA integer(kind=I4B), intent(in) :: ntp Called by proc~~swiftest_tp_allocate~~CalledByGraph proc~swiftest_tp_allocate swiftest_tp_allocate proc~helio_tp_allocate helio_tp_allocate proc~helio_tp_allocate->proc~swiftest_tp_allocate proc~symba_rearray symba_rearray proc~symba_rearray->proc~swiftest_tp_allocate proc~symba_tp_allocate symba_tp_allocate proc~symba_tp_allocate->proc~helio_tp_allocate program~swiftest_symba swiftest_symba program~swiftest_symba->proc~symba_tp_allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/swiftest_tp_allocate.html"},{"title":"helio_tp_allocate – swiftest","text":"public subroutine helio_tp_allocate(helio_tpA, ntp) Uses swiftest module_helio proc~~helio_tp_allocate~~UsesGraph proc~helio_tp_allocate helio_tp_allocate module~module_helio module_helio proc~helio_tp_allocate->module~module_helio module~swiftest swiftest proc~helio_tp_allocate->module~swiftest module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( helio_tp ), intent(inout) :: helio_tpA integer(kind=I4B), intent(in) :: ntp Calls proc~~helio_tp_allocate~~CallsGraph proc~helio_tp_allocate helio_tp_allocate proc~swiftest_tp_allocate swiftest_tp_allocate proc~helio_tp_allocate->proc~swiftest_tp_allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helio_tp_allocate~~CalledByGraph proc~helio_tp_allocate helio_tp_allocate proc~symba_tp_allocate symba_tp_allocate proc~symba_tp_allocate->proc~helio_tp_allocate program~swiftest_symba swiftest_symba program~swiftest_symba->proc~symba_tp_allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_tp_allocate.html"},{"title":"symba_tp_allocate – swiftest","text":"public subroutine symba_tp_allocate(symba_tpA, ntp) Uses swiftest module_symba proc~~symba_tp_allocate~~UsesGraph proc~symba_tp_allocate symba_tp_allocate module~module_symba module_symba proc~symba_tp_allocate->module~module_symba module~swiftest swiftest proc~symba_tp_allocate->module~swiftest module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( symba_tp ), intent(inout) :: symba_tpA integer(kind=I4B), intent(in) :: ntp Calls proc~~symba_tp_allocate~~CallsGraph proc~symba_tp_allocate symba_tp_allocate proc~helio_tp_allocate helio_tp_allocate proc~symba_tp_allocate->proc~helio_tp_allocate proc~swiftest_tp_allocate swiftest_tp_allocate proc~helio_tp_allocate->proc~swiftest_tp_allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_tp_allocate~~CalledByGraph proc~symba_tp_allocate symba_tp_allocate program~swiftest_symba swiftest_symba program~swiftest_symba->proc~symba_tp_allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_tp_allocate.html"},{"title":"symba_pltpenc_allocate – swiftest","text":"public subroutine symba_pltpenc_allocate(pltpenc_list, npltpenc) Uses swiftest module_symba proc~~symba_pltpenc_allocate~~UsesGraph proc~symba_pltpenc_allocate symba_pltpenc_allocate module~module_symba module_symba proc~symba_pltpenc_allocate->module~module_symba module~swiftest swiftest proc~symba_pltpenc_allocate->module~swiftest module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( symba_pltpenc ), intent(inout) :: pltpenc_list integer(kind=I4B), intent(in) :: npltpenc Called by proc~~symba_pltpenc_allocate~~CalledByGraph proc~symba_pltpenc_allocate symba_pltpenc_allocate program~swiftest_symba swiftest_symba program~swiftest_symba->proc~symba_pltpenc_allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_pltpenc_allocate.html"},{"title":"swiftest_pl_deallocate – swiftest","text":"public subroutine swiftest_pl_deallocate(swiftest_plA) Uses swiftest module_swiftest proc~~swiftest_pl_deallocate~~UsesGraph proc~swiftest_pl_deallocate swiftest_pl_deallocate module~module_swiftest module_swiftest proc~swiftest_pl_deallocate->module~module_swiftest module~swiftest swiftest proc~swiftest_pl_deallocate->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( swiftest_pl ), intent(inout) :: swiftest_plA Called by proc~~swiftest_pl_deallocate~~CalledByGraph proc~swiftest_pl_deallocate swiftest_pl_deallocate proc~helio_pl_deallocate helio_pl_deallocate proc~helio_pl_deallocate->proc~swiftest_pl_deallocate proc~symba_pl_deallocate symba_pl_deallocate proc~symba_pl_deallocate->proc~helio_pl_deallocate proc~util_resize_pl util_resize_pl proc~util_resize_pl->proc~symba_pl_deallocate program~swiftest_symba swiftest_symba program~swiftest_symba->proc~symba_pl_deallocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/swiftest_pl_deallocate.html"},{"title":"helio_pl_deallocate – swiftest","text":"public subroutine helio_pl_deallocate(helio_plA) Uses swiftest module_helio proc~~helio_pl_deallocate~~UsesGraph proc~helio_pl_deallocate helio_pl_deallocate module~module_helio module_helio proc~helio_pl_deallocate->module~module_helio module~swiftest swiftest proc~helio_pl_deallocate->module~swiftest module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( helio_pl ), intent(inout) :: helio_plA Calls proc~~helio_pl_deallocate~~CallsGraph proc~helio_pl_deallocate helio_pl_deallocate proc~swiftest_pl_deallocate swiftest_pl_deallocate proc~helio_pl_deallocate->proc~swiftest_pl_deallocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helio_pl_deallocate~~CalledByGraph proc~helio_pl_deallocate helio_pl_deallocate proc~symba_pl_deallocate symba_pl_deallocate proc~symba_pl_deallocate->proc~helio_pl_deallocate proc~util_resize_pl util_resize_pl proc~util_resize_pl->proc~symba_pl_deallocate program~swiftest_symba swiftest_symba program~swiftest_symba->proc~symba_pl_deallocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_pl_deallocate.html"},{"title":"symba_pl_deallocate – swiftest","text":"public subroutine symba_pl_deallocate(symba_plA) Uses swiftest module_symba proc~~symba_pl_deallocate~~UsesGraph proc~symba_pl_deallocate symba_pl_deallocate module~module_symba module_symba proc~symba_pl_deallocate->module~module_symba module~swiftest swiftest proc~symba_pl_deallocate->module~swiftest module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( symba_pl ), intent(inout) :: symba_plA Calls proc~~symba_pl_deallocate~~CallsGraph proc~symba_pl_deallocate symba_pl_deallocate proc~helio_pl_deallocate helio_pl_deallocate proc~symba_pl_deallocate->proc~helio_pl_deallocate proc~swiftest_pl_deallocate swiftest_pl_deallocate proc~helio_pl_deallocate->proc~swiftest_pl_deallocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_pl_deallocate~~CalledByGraph proc~symba_pl_deallocate symba_pl_deallocate proc~util_resize_pl util_resize_pl proc~util_resize_pl->proc~symba_pl_deallocate program~swiftest_symba swiftest_symba program~swiftest_symba->proc~symba_pl_deallocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_pl_deallocate.html"},{"title":"symba_plplenc_deallocate – swiftest","text":"public subroutine symba_plplenc_deallocate(plplenc_list) Uses swiftest module_symba proc~~symba_plplenc_deallocate~~UsesGraph proc~symba_plplenc_deallocate symba_plplenc_deallocate module~module_symba module_symba proc~symba_plplenc_deallocate->module~module_symba module~swiftest swiftest proc~symba_plplenc_deallocate->module~swiftest module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( symba_plplenc ), intent(inout) :: plplenc_list Called by proc~~symba_plplenc_deallocate~~CalledByGraph proc~symba_plplenc_deallocate symba_plplenc_deallocate program~swiftest_symba swiftest_symba program~swiftest_symba->proc~symba_plplenc_deallocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_plplenc_deallocate.html"},{"title":"symba_merger_deallocate – swiftest","text":"public subroutine symba_merger_deallocate(mergeadd_list) Uses swiftest module_symba proc~~symba_merger_deallocate~~UsesGraph proc~symba_merger_deallocate symba_merger_deallocate module~module_symba module_symba proc~symba_merger_deallocate->module~module_symba module~swiftest swiftest proc~symba_merger_deallocate->module~swiftest module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( symba_merger ), intent(inout) :: mergeadd_list Called by proc~~symba_merger_deallocate~~CalledByGraph proc~symba_merger_deallocate symba_merger_deallocate program~swiftest_symba swiftest_symba program~swiftest_symba->proc~symba_merger_deallocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_merger_deallocate.html"},{"title":"swiftest_tp_deallocate – swiftest","text":"public subroutine swiftest_tp_deallocate(swiftest_tpA) Uses swiftest module_swiftest proc~~swiftest_tp_deallocate~~UsesGraph proc~swiftest_tp_deallocate swiftest_tp_deallocate module~module_swiftest module_swiftest proc~swiftest_tp_deallocate->module~module_swiftest module~swiftest swiftest proc~swiftest_tp_deallocate->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( swiftest_tp ), intent(inout) :: swiftest_tpA Called by proc~~swiftest_tp_deallocate~~CalledByGraph proc~swiftest_tp_deallocate swiftest_tp_deallocate proc~helio_tp_deallocate helio_tp_deallocate proc~helio_tp_deallocate->proc~swiftest_tp_deallocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/swiftest_tp_deallocate.html"},{"title":"helio_tp_deallocate – swiftest","text":"public subroutine helio_tp_deallocate(helio_tpA) Uses swiftest module_helio proc~~helio_tp_deallocate~~UsesGraph proc~helio_tp_deallocate helio_tp_deallocate module~module_helio module_helio proc~helio_tp_deallocate->module~module_helio module~swiftest swiftest proc~helio_tp_deallocate->module~swiftest module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( helio_tp ), intent(inout) :: helio_tpA Calls proc~~helio_tp_deallocate~~CallsGraph proc~helio_tp_deallocate helio_tp_deallocate proc~swiftest_tp_deallocate swiftest_tp_deallocate proc~helio_tp_deallocate->proc~swiftest_tp_deallocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_tp_deallocate.html"},{"title":"symba_tp_deallocate – swiftest","text":"public subroutine symba_tp_deallocate(symba_tpA) Uses swiftest module_symba proc~~symba_tp_deallocate~~UsesGraph proc~symba_tp_deallocate symba_tp_deallocate module~module_symba module_symba proc~symba_tp_deallocate->module~module_symba module~swiftest swiftest proc~symba_tp_deallocate->module~swiftest module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( symba_tp ), intent(inout) :: symba_tpA Called by proc~~symba_tp_deallocate~~CalledByGraph proc~symba_tp_deallocate symba_tp_deallocate program~swiftest_symba swiftest_symba program~swiftest_symba->proc~symba_tp_deallocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_tp_deallocate.html"},{"title":"symba_pltpenc_deallocate – swiftest","text":"public subroutine symba_pltpenc_deallocate(pltpenc_list) Uses swiftest module_symba proc~~symba_pltpenc_deallocate~~UsesGraph proc~symba_pltpenc_deallocate symba_pltpenc_deallocate module~module_symba module_symba proc~symba_pltpenc_deallocate->module~module_symba module~swiftest swiftest proc~symba_pltpenc_deallocate->module~swiftest module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( symba_pltpenc ), intent(inout) :: pltpenc_list Called by proc~~symba_pltpenc_deallocate~~CalledByGraph proc~symba_pltpenc_deallocate symba_pltpenc_deallocate program~swiftest_symba swiftest_symba program~swiftest_symba->proc~symba_pltpenc_deallocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_pltpenc_deallocate.html"},{"title":"initxdr – swiftest","text":"interface Called by interface~~initxdr~~CalledByGraph interface~initxdr initxdr proc~io_open_fxdr io_open_fxdr proc~io_open_fxdr->interface~initxdr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function initxdr(filename, mode, returnonerror) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=1), intent(in) :: mode logical, intent(in) :: returnonerror Return Value integer","tags":"","loc":"interface/initxdr.html"},{"title":"ixdrclose – swiftest","text":"interface Called by interface~~ixdrclose~~CalledByGraph interface~ixdrclose ixdrclose proc~io_getn io_getn proc~io_getn->interface~ixdrclose proc~io_dump_pl io_dump_pl proc~io_dump_pl->interface~ixdrclose proc~io_write_frame io_write_frame proc~io_write_frame->interface~ixdrclose proc~io_read_encounter io_read_encounter proc~io_read_encounter->interface~ixdrclose proc~io_init_pl io_init_pl proc~io_init_pl->interface~ixdrclose proc~io_init_tp io_init_tp proc~io_init_tp->interface~ixdrclose proc~io_write_encounter io_write_encounter proc~io_write_encounter->interface~ixdrclose proc~io_dump_tp io_dump_tp proc~io_dump_tp->interface~ixdrclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function ixdrclose(ixdr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ixdr Return Value integer","tags":"","loc":"interface/ixdrclose.html"},{"title":"ixdrdmat – swiftest","text":"interface Called by interface~~ixdrdmat~~CalledByGraph interface~ixdrdmat ixdrdmat proc~io_dump_pl io_dump_pl proc~io_dump_pl->interface~ixdrdmat proc~io_init_pl io_init_pl proc~io_init_pl->interface~ixdrdmat proc~io_read_line io_read_line proc~io_read_line->interface~ixdrdmat proc~io_init_tp io_init_tp proc~io_init_tp->interface~ixdrdmat proc~io_write_line io_write_line proc~io_write_line->interface~ixdrdmat proc~io_dump_tp io_dump_tp proc~io_dump_tp->interface~ixdrdmat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function ixdrdmat(ixdrs, nels, dval) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ixdrs integer, intent(in) :: nels double precision, intent(in), DIMENSION(nels) :: dval Return Value integer","tags":"","loc":"interface/ixdrdmat.html"},{"title":"ixdrdouble – swiftest","text":"interface Called by interface~~ixdrdouble~~CalledByGraph interface~ixdrdouble ixdrdouble proc~io_dump_pl io_dump_pl proc~io_dump_pl->interface~ixdrdouble proc~io_read_encounter io_read_encounter proc~io_read_encounter->interface~ixdrdouble proc~io_init_pl io_init_pl proc~io_init_pl->interface~ixdrdouble proc~io_read_hdr io_read_hdr proc~io_read_hdr->interface~ixdrdouble proc~io_read_line io_read_line proc~io_read_line->interface~ixdrdouble proc~io_write_line io_write_line proc~io_write_line->interface~ixdrdouble proc~io_write_hdr io_write_hdr proc~io_write_hdr->interface~ixdrdouble proc~io_write_encounter io_write_encounter proc~io_write_encounter->interface~ixdrdouble Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function ixdrdouble(ixdrs, dval) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ixdrs double precision, intent(in) :: dval Return Value integer","tags":"","loc":"interface/ixdrdouble.html"},{"title":"ixdrimat – swiftest","text":"interface Called by interface~~ixdrimat~~CalledByGraph interface~ixdrimat ixdrimat proc~io_write_hdr io_write_hdr proc~io_write_hdr->interface~ixdrimat proc~io_read_hdr io_read_hdr proc~io_read_hdr->interface~ixdrimat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function ixdrimat(ixdrs, nels, ival) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ixdrs integer, intent(in) :: nels integer, intent(in), DIMENSION(nels) :: ival Return Value integer","tags":"","loc":"interface/ixdrimat.html"},{"title":"ixdrint – swiftest","text":"interface Called by interface~~ixdrint~~CalledByGraph interface~ixdrint ixdrint proc~io_getn io_getn proc~io_getn->interface~ixdrint proc~io_dump_pl io_dump_pl proc~io_dump_pl->interface~ixdrint proc~io_init_pl io_init_pl proc~io_init_pl->interface~ixdrint proc~io_read_line io_read_line proc~io_read_line->interface~ixdrint proc~io_init_tp io_init_tp proc~io_init_tp->interface~ixdrint proc~io_write_line io_write_line proc~io_write_line->interface~ixdrint proc~io_dump_tp io_dump_tp proc~io_dump_tp->interface~ixdrint Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function ixdrint(ixdrs, ival) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ixdrs integer, intent(in) :: ival Return Value integer","tags":"","loc":"interface/ixdrint.html"},{"title":"ixdrreal – swiftest","text":"interface Called by interface~~ixdrreal~~CalledByGraph interface~ixdrreal ixdrreal proc~io_write_line io_write_line proc~io_write_line->interface~ixdrreal proc~io_read_line io_read_line proc~io_read_line->interface~ixdrreal proc~io_write_hdr io_write_hdr proc~io_write_hdr->interface~ixdrreal proc~io_read_hdr io_read_hdr proc~io_read_hdr->interface~ixdrreal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function ixdrreal(ixdrs, rval) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ixdrs real, intent(in) :: rval Return Value integer","tags":"","loc":"interface/ixdrreal.html"},{"title":"ixdrrmat – swiftest","text":"interface Called by interface~~ixdrrmat~~CalledByGraph interface~ixdrrmat ixdrrmat proc~io_write_line io_write_line proc~io_write_line->interface~ixdrrmat proc~io_read_line io_read_line proc~io_read_line->interface~ixdrrmat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function ixdrrmat(ixdrs, nels, rval) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ixdrs integer, intent(in) :: nels real, intent(in), DIMENSION(nels) :: rval Return Value integer","tags":"","loc":"interface/ixdrrmat.html"},{"title":"arth_d – swiftest","text":"public function arth_d(first, increment, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: first real(kind=DP), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  DIMENSION(n) Called by proc~~arth_d~~CalledByGraph proc~arth_d arth_d interface~arth arth interface~arth->proc~arth_d proc~util_index util_index proc~util_index->interface~arth Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/arth_d.html"},{"title":"arth_i – swiftest","text":"public function arth_i(first, increment, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: first integer(kind=I4B), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(n) Called by proc~~arth_i~~CalledByGraph proc~arth_i arth_i proc~upper_triangle upper_triangle proc~upper_triangle->proc~arth_i interface~arth arth interface~arth->proc~arth_i proc~util_index util_index proc~util_index->interface~arth Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/arth_i.html"},{"title":"cumsum_i – swiftest","text":"public recursive function cumsum_i(arr, seed) result(ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: arr integer(kind=I4B), intent(in), optional :: seed Return Value integer(kind=I4B),\n  DIMENSION(SIZE(arr)) Called by proc~~cumsum_i~~CalledByGraph proc~cumsum_i cumsum_i proc~cumsum_i->proc~cumsum_i interface~cumsum cumsum interface~cumsum->proc~cumsum_i Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cumsum_i.html"},{"title":"iminloc – swiftest","text":"public function iminloc(arr) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: arr Return Value integer(kind=I4B) Contents None","tags":"","loc":"proc/iminloc.html"},{"title":"outerdiff_d – swiftest","text":"public function outerdiff_d(a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: a real(kind=DP), intent(in), DIMENSION(:) :: b Return Value real(kind=DP),\n  DIMENSION(SIZE(a), SIZE(b)) Called by proc~~outerdiff_d~~CalledByGraph proc~outerdiff_d outerdiff_d interface~outerdiff outerdiff interface~outerdiff->proc~outerdiff_d proc~upper_triangle upper_triangle proc~upper_triangle->interface~outerdiff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/outerdiff_d.html"},{"title":"outerdiff_i – swiftest","text":"public function outerdiff_i(a, b) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: a integer(kind=I4B), intent(in), DIMENSION(:) :: b Return Value integer(kind=I4B),\n  DIMENSION(SIZE(a), SIZE(b)) Called by proc~~outerdiff_i~~CalledByGraph proc~outerdiff_i outerdiff_i interface~outerdiff outerdiff interface~outerdiff->proc~outerdiff_i proc~upper_triangle upper_triangle proc~upper_triangle->interface~outerdiff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/outerdiff_i.html"},{"title":"outerprod_d – swiftest","text":"public function outerprod_d(a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: a real(kind=DP), intent(in), DIMENSION(:) :: b Return Value real(kind=DP),\n  DIMENSION(SIZE(a), SIZE(b)) Called by proc~~outerprod_d~~CalledByGraph proc~outerprod_d outerprod_d interface~outerprod outerprod interface~outerprod->proc~outerprod_d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/outerprod_d.html"},{"title":"upper_triangle – swiftest","text":"public function upper_triangle(j, k, extra) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: j integer(kind=I4B), intent(in) :: k integer(kind=I4B), intent(in), optional :: extra Return Value logical(kind=LGT),\n  DIMENSION(j, k) Calls proc~~upper_triangle~~CallsGraph proc~upper_triangle upper_triangle proc~arth_i arth_i proc~upper_triangle->proc~arth_i interface~outerdiff outerdiff proc~upper_triangle->interface~outerdiff proc~outerdiff_d outerdiff_d interface~outerdiff->proc~outerdiff_d proc~outerdiff_i outerdiff_i interface~outerdiff->proc~outerdiff_i Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/upper_triangle.html"},{"title":"arth – swiftest","text":"public interface arth Calls interface~~arth~~CallsGraph interface~arth arth proc~arth_d arth_d interface~arth->proc~arth_d proc~arth_i arth_i interface~arth->proc~arth_i Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~arth~~CalledByGraph interface~arth arth proc~util_index util_index proc~util_index->interface~arth Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures arth_d arth_i Module Procedures public function arth_d (first, increment, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: first real(kind=DP), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  DIMENSION(n) public function arth_i (first, increment, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: first integer(kind=I4B), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(n)","tags":"","loc":"interface/arth.html"},{"title":"cumsum – swiftest","text":"public interface cumsum Calls interface~~cumsum~~CallsGraph interface~cumsum cumsum proc~cumsum_i cumsum_i interface~cumsum->proc~cumsum_i proc~cumsum_i->proc~cumsum_i Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures cumsum_i Module Procedures public recursive function cumsum_i (arr, seed) result(ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: arr integer(kind=I4B), intent(in), optional :: seed Return Value integer(kind=I4B),\n  DIMENSION(SIZE(arr))","tags":"","loc":"interface/cumsum.html"},{"title":"outerdiff – swiftest","text":"public interface outerdiff Calls interface~~outerdiff~~CallsGraph interface~outerdiff outerdiff proc~outerdiff_d outerdiff_d interface~outerdiff->proc~outerdiff_d proc~outerdiff_i outerdiff_i interface~outerdiff->proc~outerdiff_i Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~outerdiff~~CalledByGraph interface~outerdiff outerdiff proc~upper_triangle upper_triangle proc~upper_triangle->interface~outerdiff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures outerdiff_d outerdiff_i Module Procedures public function outerdiff_d (a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: a real(kind=DP), intent(in), DIMENSION(:) :: b Return Value real(kind=DP),\n  DIMENSION(SIZE(a), SIZE(b)) public function outerdiff_i (a, b) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: a integer(kind=I4B), intent(in), DIMENSION(:) :: b Return Value integer(kind=I4B),\n  DIMENSION(SIZE(a), SIZE(b))","tags":"","loc":"interface/outerdiff.html"},{"title":"outerprod – swiftest","text":"public interface outerprod Calls interface~~outerprod~~CallsGraph interface~outerprod outerprod proc~outerprod_d outerprod_d interface~outerprod->proc~outerprod_d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures outerprod_d Module Procedures public function outerprod_d (a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: a real(kind=DP), intent(in), DIMENSION(:) :: b Return Value real(kind=DP),\n  DIMENSION(SIZE(a), SIZE(b))","tags":"","loc":"interface/outerprod.html"},{"title":"io_get_token – swiftest","text":"interface Calls interface~~io_get_token~~CallsGraph interface~io_get_token io_get_token proc~io_get_token io_get_token interface~io_get_token->proc~io_get_token Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~io_get_token~~CalledByGraph interface~io_get_token io_get_token proc~io_read_param_in io_read_param_in proc~io_read_param_in->interface~io_get_token interface~io_read_param_in io_read_param_in interface~io_read_param_in->proc~io_read_param_in program~swiftest_symba swiftest_symba program~swiftest_symba->interface~io_read_param_in program~tool_encounter_read tool_encounter_read program~tool_encounter_read->interface~io_read_param_in Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function io_get_token(buffer, ilength, ifirst, ilast, ierr) result(token) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: buffer Input string buffer integer(kind=I4B), intent(in) :: ilength Length of input buffer string integer(kind=I4B), intent(inout) :: ifirst Index of the buffer at which to start the search for a token integer(kind=I4B), intent(out) :: ilast Index of the buffer at the end of the returned token integer(kind=I4B), intent(out) :: ierr Error code Return Value character(len=len(buffer)) Returned token string","tags":"","loc":"interface/io_get_token.html"},{"title":"io_read_param_in – swiftest","text":"interface Calls interface~~io_read_param_in~~CallsGraph interface~io_read_param_in io_read_param_in proc~io_read_param_in io_read_param_in interface~io_read_param_in->proc~io_read_param_in interface~io_get_token io_get_token proc~io_read_param_in->interface~io_get_token interface~util_toupper util_toupper proc~io_read_param_in->interface~util_toupper interface~util_exit util_exit proc~io_read_param_in->interface~util_exit proc~io_get_token io_get_token interface~io_get_token->proc~io_get_token Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~io_read_param_in~~CalledByGraph interface~io_read_param_in io_read_param_in program~swiftest_symba swiftest_symba program~swiftest_symba->interface~io_read_param_in program~tool_encounter_read tool_encounter_read program~tool_encounter_read->interface~io_read_param_in Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function io_read_param_in(inparfile) result(param) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: inparfile Parameter input file name (typically param.in) Return Value type( input_parameters ) Output collection of user-defined parameters","tags":"","loc":"interface/io_read_param_in.html"},{"title":"io_read_pl_in – swiftest","text":"interface Calls interface~~io_read_pl_in~~CallsGraph interface~io_read_pl_in io_read_pl_in proc~io_read_pl_in io_read_pl_in interface~io_read_pl_in->proc~io_read_pl_in Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~io_read_pl_in~~CalledByGraph interface~io_read_pl_in io_read_pl_in program~swiftest_symba swiftest_symba program~swiftest_symba->interface~io_read_pl_in Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function io_read_pl_in(param, npl, swiftest_plA) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name type( input_parameters ), intent(in) :: param Output collection of user-defined parameters integer(kind=I4B), intent(in) :: npl Number of massive bodies type(swiftest_pl), intent(inout) :: swiftest_plA Swiftest data structure to store massive body initial conditions Return Value integer(kind=I4B) Error code","tags":"","loc":"interface/io_read_pl_in.html"},{"title":"io_read_param_in – swiftest","text":"module procedure io_read_param_in module function io_read_param_in(inparfile) result(param) Interface → Read in parameters for the integration Adapted from David E. Kaufmann's Swifter routine io_init_param.f90\n Adapted from Martin Duncan's Swift routine io_init_param.f Define the maximum number of threads Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: inparfile Parameter input file name (typically param.in) Return Value type( input_parameters ) Output collection of user-defined parameters Calls proc~~io_read_param_in~~CallsGraph proc~io_read_param_in io_read_param_in interface~io_get_token io_get_token proc~io_read_param_in->interface~io_get_token interface~util_toupper util_toupper proc~io_read_param_in->interface~util_toupper interface~util_exit util_exit proc~io_read_param_in->interface~util_exit proc~io_get_token io_get_token interface~io_get_token->proc~io_get_token Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_read_param_in~~CalledByGraph proc~io_read_param_in io_read_param_in interface~io_read_param_in io_read_param_in interface~io_read_param_in->proc~io_read_param_in program~swiftest_symba swiftest_symba program~swiftest_symba->interface~io_read_param_in program~tool_encounter_read tool_encounter_read program~tool_encounter_read->interface~io_read_param_in Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_param_in.html"},{"title":"io_get_token – swiftest","text":"module procedure io_get_token module function io_get_token(buffer, ilength, ifirst, ilast, ierr) result(token) Interface → Retrieves a character token from an input string. Here a token is defined as any set of contiguous non-blank characters not \n beginning with or containing \"!\". If \"!\" is present, any remaining part of the buffer including the \"!\" is ignored Adapted from Swifter\n Original author David E. Kaufmann Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: buffer Input string buffer integer(kind=I4B), intent(in) :: ilength Length of input buffer string integer(kind=I4B), intent(inout) :: ifirst Index of the buffer at which to start the search for a token integer(kind=I4B), intent(out) :: ilast Index of the buffer at the end of the returned token integer(kind=I4B), intent(out) :: ierr Error code Return Value character(len=len(buffer)) Returned token string Called by proc~~io_get_token~~CalledByGraph proc~io_get_token io_get_token interface~io_get_token io_get_token interface~io_get_token->proc~io_get_token proc~io_read_param_in io_read_param_in proc~io_read_param_in->interface~io_get_token interface~io_read_param_in io_read_param_in interface~io_read_param_in->proc~io_read_param_in program~swiftest_symba swiftest_symba program~swiftest_symba->interface~io_read_param_in program~tool_encounter_read tool_encounter_read program~tool_encounter_read->interface~io_read_param_in Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_get_token.html"},{"title":"io_read_pl_in – swiftest","text":"module procedure io_read_pl_in module function io_read_pl_in(param, npl, swiftest_plA) result(ierr) Interface → Uses swiftest module_symba proc~~io_read_pl_in~~UsesGraph proc~io_read_pl_in io_read_pl_in module~module_symba module_symba proc~io_read_pl_in->module~module_symba module~swiftest swiftest proc~io_read_pl_in->module~swiftest module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Read in massive body data Adapted from David E. Kaufmann's Swifter routine io_init_pl.f90\n Adapted from Martin Duncan's Swift routine io_init_pl.f Arguments Type Intent Optional Attributes Name type( input_parameters ), intent(in) :: param Output collection of user-defined parameters integer(kind=I4B), intent(in) :: npl Number of massive bodies type(swiftest_pl), intent(inout) :: swiftest_plA Swiftest data structure to store massive body initial conditions Return Value integer(kind=I4B) Error code Called by proc~~io_read_pl_in~~CalledByGraph proc~io_read_pl_in io_read_pl_in interface~io_read_pl_in io_read_pl_in interface~io_read_pl_in->proc~io_read_pl_in program~swiftest_symba swiftest_symba program~swiftest_symba->interface~io_read_pl_in Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_pl_in.html"},{"title":"module_interfaces – swiftest","text":"Used by module~~module_interfaces~~UsedByGraph module~module_interfaces module_interfaces proc~symba_casehitandrun symba_casehitandrun proc~symba_casehitandrun->module~module_interfaces proc~util_exit util_exit proc~util_exit->module~module_interfaces proc~symba_getacch_tp symba_getacch_tp proc~symba_getacch_tp->module~module_interfaces proc~symba_energy symba_energy proc~symba_energy->module~module_interfaces proc~rmvs_chk_ind rmvs_chk_ind proc~rmvs_chk_ind->module~module_interfaces proc~symba_rearray symba_rearray proc~symba_rearray->module~module_interfaces proc~obl_acc obl_acc proc~obl_acc->module~module_interfaces proc~helio_step_pl helio_step_pl proc~helio_step_pl->module~module_interfaces proc~symba_merge_tp symba_merge_tp proc~symba_merge_tp->module~module_interfaces proc~util_hills util_hills proc~util_hills->module~module_interfaces proc~util_sort_dp util_sort_dp proc~util_sort_dp->module~module_interfaces proc~io_getn io_getn proc~io_getn->module~module_interfaces proc~coord_h2b_tp coord_h2b_tp proc~coord_h2b_tp->module~module_interfaces proc~coord_vb2vh_tp coord_vb2vh_tp proc~coord_vb2vh_tp->module~module_interfaces proc~helio_getacch helio_getacch proc~helio_getacch->module~module_interfaces proc~drift_kepu_guess drift_kepu_guess proc~drift_kepu_guess->module~module_interfaces proc~symba_helio_drift_tp symba_helio_drift_tp proc~symba_helio_drift_tp->module~module_interfaces proc~coord_h2b coord_h2b proc~coord_h2b->module~module_interfaces proc~util_resize_pl util_resize_pl proc~util_resize_pl->module~module_interfaces proc~symba_helio_getacch_int symba_helio_getacch_int proc~symba_helio_getacch_int->module~module_interfaces proc~helio_drift helio_drift proc~helio_drift->module~module_interfaces proc~python_io_write_frame_tp python_io_write_frame_tp proc~python_io_write_frame_tp->module~module_interfaces proc~drift_kepu_fchk drift_kepu_fchk proc~drift_kepu_fchk->module~module_interfaces proc~io_write_encounter io_write_encounter proc~io_write_encounter->module~module_interfaces proc~helio_user_getacch helio_user_getacch proc~helio_user_getacch->module~module_interfaces proc~util_kahan_sum util_kahan_sum proc~util_kahan_sum->module~module_interfaces proc~util_peri util_peri proc~util_peri->module~module_interfaces proc~io_open io_open proc~io_open->module~module_interfaces proc~drift_kepu_lag drift_kepu_lag proc~drift_kepu_lag->module~module_interfaces proc~symba_discard_sun_pl symba_discard_sun_pl proc~symba_discard_sun_pl->module~module_interfaces proc~symba_step_interp symba_step_interp proc~symba_step_interp->module~module_interfaces proc~helio_getacch_int helio_getacch_int proc~helio_getacch_int->module~module_interfaces proc~symba_step symba_step proc~symba_step->module~module_interfaces proc~orbel_xv2el orbel_xv2el proc~orbel_xv2el->module~module_interfaces proc~symba_step_helio symba_step_helio proc~symba_step_helio->module~module_interfaces proc~orbel_xv2aeq orbel_xv2aeq proc~orbel_xv2aeq->module~module_interfaces proc~discard discard proc~discard->module~module_interfaces proc~util_valid util_valid proc~util_valid->module~module_interfaces proc~symba_casedisruption symba_casedisruption proc~symba_casedisruption->module~module_interfaces proc~symba_discard_peri_pl symba_discard_peri_pl proc~symba_discard_peri_pl->module~module_interfaces proc~symba_user_getacch symba_user_getacch proc~symba_user_getacch->module~module_interfaces proc~symba_discard_merge_pl symba_discard_merge_pl proc~symba_discard_merge_pl->module~module_interfaces proc~symba_casesupercatastrophic symba_casesupercatastrophic proc~symba_casesupercatastrophic->module~module_interfaces proc~drift_kepu drift_kepu proc~drift_kepu->module~module_interfaces proc~io_write_line io_write_line proc~io_write_line->module~module_interfaces proc~util_index util_index proc~util_index->module~module_interfaces proc~helio_getacch_tp helio_getacch_tp proc~helio_getacch_tp->module~module_interfaces proc~coord_vb2vh coord_vb2vh proc~coord_vb2vh->module~module_interfaces proc~discard_pl_close discard_pl_close proc~discard_pl_close->module~module_interfaces proc~io_read_hdr io_read_hdr proc~io_read_hdr->module~module_interfaces proc~drift_one drift_one proc~drift_one->module~module_interfaces proc~obl_pot obl_pot proc~obl_pot->module~module_interfaces proc~symba_merge_pl symba_merge_pl proc~symba_merge_pl->module~module_interfaces proc~symba_kick symba_kick proc~symba_kick->module~module_interfaces proc~helio_kickvb_tp helio_kickvb_tp proc~helio_kickvb_tp->module~module_interfaces proc~drift_kepu_p3solve drift_kepu_p3solve proc~drift_kepu_p3solve->module~module_interfaces proc~discard_peri discard_peri proc~discard_peri->module~module_interfaces proc~helio_kickvb helio_kickvb proc~helio_kickvb->module~module_interfaces proc~helio_drift_tp helio_drift_tp proc~helio_drift_tp->module~module_interfaces proc~symba_caseresolve symba_caseresolve proc~symba_caseresolve->module~module_interfaces proc~orbel_scget orbel_scget proc~orbel_scget->module~module_interfaces proc~symba_getacch symba_getacch proc~symba_getacch->module~module_interfaces module~io io module~io->module~module_interfaces proc~symba_discard_tp symba_discard_tp proc~symba_discard_tp->module~module_interfaces proc~coord_vh2vb coord_vh2vb proc~coord_vh2vb->module~module_interfaces proc~orbel_xv2aqt orbel_xv2aqt proc~orbel_xv2aqt->module~module_interfaces program~tool_encounter_read tool_encounter_read program~tool_encounter_read->module~module_interfaces program~tool_encounter_read->module~io proc~drift_kepmd drift_kepmd proc~drift_kepmd->module~module_interfaces proc~symba_discard_pl symba_discard_pl proc~symba_discard_pl->module~module_interfaces proc~io_dump_param io_dump_param proc~io_dump_param->module~module_interfaces proc~drift_dan drift_dan proc~drift_dan->module~module_interfaces proc~io_read_line io_read_line proc~io_read_line->module~module_interfaces proc~io_open_fxdr io_open_fxdr proc~io_open_fxdr->module~module_interfaces proc~symba_helio_getacch symba_helio_getacch proc~symba_helio_getacch->module~module_interfaces proc~symba_step_recur symba_step_recur proc~symba_step_recur->module~module_interfaces proc~coord_vh2vb_tp coord_vh2vb_tp proc~coord_vh2vb_tp->module~module_interfaces proc~helio_lindrift_tp helio_lindrift_tp proc~helio_lindrift_tp->module~module_interfaces proc~drift_kepu_stumpff drift_kepu_stumpff proc~drift_kepu_stumpff->module~module_interfaces proc~io_write_hdr io_write_hdr proc~io_write_hdr->module~module_interfaces proc~helio_lindrift helio_lindrift proc~helio_lindrift->module~module_interfaces proc~symba_casemerge symba_casemerge proc~symba_casemerge->module~module_interfaces proc~discard_sun discard_sun proc~discard_sun->module~module_interfaces proc~drift_kepu_new drift_kepu_new proc~drift_kepu_new->module~module_interfaces proc~util_sort_sp util_sort_sp proc~util_sort_sp->module~module_interfaces proc~io_discard_write_symba io_discard_write_symba proc~io_discard_write_symba->module~module_interfaces proc~io_dump_tp io_dump_tp proc~io_dump_tp->module~module_interfaces proc~symba_reorder_pl symba_reorder_pl proc~symba_reorder_pl->module~module_interfaces proc~io_write_frame io_write_frame proc~io_write_frame->module~module_interfaces proc~util_sort_i4b util_sort_i4b proc~util_sort_i4b->module~module_interfaces proc~io_read_encounter io_read_encounter proc~io_read_encounter->module~module_interfaces proc~symba_user_getacch_tp symba_user_getacch_tp proc~symba_user_getacch_tp->module~module_interfaces proc~symba_step_helio_pl symba_step_helio_pl proc~symba_step_helio_pl->module~module_interfaces proc~util_version util_version proc~util_version->module~module_interfaces proc~python_io_write_frame_pl python_io_write_frame_pl proc~python_io_write_frame_pl->module~module_interfaces proc~helio_step_tp helio_step_tp proc~helio_step_tp->module~module_interfaces proc~io_init_pl io_init_pl proc~io_init_pl->module~module_interfaces proc~helio_getacch_int_tp helio_getacch_int_tp proc~helio_getacch_int_tp->module~module_interfaces proc~obl_acc_tp obl_acc_tp proc~obl_acc_tp->module~module_interfaces proc~io_init_tp io_init_tp proc~io_init_tp->module~module_interfaces proc~symba_helio_drift symba_helio_drift proc~symba_helio_drift->module~module_interfaces program~swiftest_symba swiftest_symba program~swiftest_symba->module~module_interfaces program~swiftest_symba->module~io proc~symba_chk symba_chk proc~symba_chk->module~module_interfaces proc~io_dump_pl io_dump_pl proc~io_dump_pl->module~module_interfaces proc~discard_pl discard_pl proc~discard_pl->module~module_interfaces proc~helio_user_getacch_tp helio_user_getacch_tp proc~helio_user_getacch_tp->module~module_interfaces proc~symba_fragmentation symba_fragmentation proc~symba_fragmentation->module~module_interfaces proc~util_toupper util_toupper proc~util_toupper->module~module_interfaces proc~symba_peri symba_peri proc~symba_peri->module~module_interfaces module~s_io_read_pl_in s_io_read_pl_in module~s_io_read_pl_in->module~io module~s_io_get_token s_io_get_token module~s_io_get_token->module~io module~s_io_read_param_in s_io_read_param_in module~s_io_read_param_in->module~io Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces coord_h2b coord_h2b_tp coord_vb2vh coord_vb2vh_tp coord_vh2vb coord_vh2vb_tp discard discard_peri discard_pl_close discard_pl discard_sun drift_dan drift_kepmd drift_kepu drift_kepu_fchk drift_kepu_guess drift_kepu_lag drift_kepu_new drift_kepu_p3solve drift_kepu_stumpff drift_one helio_drift helio_drift_tp helio_getacch helio_getacch_int helio_getacch_int_tp helio_getacch_tp helio_kickvb helio_kickvb_tp helio_lindrift helio_lindrift_tp helio_step helio_step_pl helio_step_tp helio_user_getacch helio_user_getacch_tp io_discard_write_symba io_dump_param io_dump_pl io_dump_tp io_getn io_init_pl io_init_tp io_open io_open_fxdr io_read_encounter io_read_hdr io_read_line io_write_encounter io_write_frame io_write_hdr io_write_line obl_acc obl_acc_tp obl_pot orbel_scget orbel_xv2aeq orbel_xv2aqt orbel_xv2el python_io_write_frame_pl python_io_write_frame_tp rmvs_chk_ind symba_casedisruption symba_casehitandrun symba_casemerge symba_caseresolve symba_casesupercatastrophic symba_chk symba_discard_merge_pl symba_discard_peri_pl symba_discard_pl symba_discard_sun_pl symba_discard_tp symba_energy symba_fragmentation symba_getacch symba_getacch_tp symba_helio_drift symba_helio_drift_tp symba_helio_getacch symba_helio_getacch_int symba_kick symba_merge_pl symba_merge_tp symba_peri symba_rearray symba_reorder_pl symba_setup symba_step symba_step_helio symba_step_helio_pl symba_step_interp symba_step_recur symba_user_getacch symba_user_getacch_tp util_exit util_hills util_index util_peri util_resize_pl util_sort util_toupper util_valid util_version util_kahan_sum collresolve_resolve util_regime Interfaces interface public subroutine coord_h2b(npl, swiftest_plA, msys) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(swiftest_pl), intent(inout) :: swiftest_plA real(kind=DP), intent(out) :: msys interface public subroutine coord_h2b_tp(ntp, swiftest_tpA, swiftest_plA) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp type(swiftest_tp), intent(inout) :: swiftest_tpA type(swiftest_pl), intent(inout) :: swiftest_plA interface public subroutine coord_vb2vh(npl, swiftest_plA) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(swiftest_pl), intent(inout) :: swiftest_plA interface public subroutine coord_vb2vh_tp(ntp, swiftest_tpA, vs) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp type(swiftest_tp), intent(inout) :: swiftest_tpA real(kind=DP), intent(in), DIMENSION(NDIM) :: vs interface public subroutine coord_vh2vb(npl, swiftest_plA, msys) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(swiftest_pl), intent(inout) :: swiftest_plA real(kind=DP), intent(out) :: msys interface public subroutine coord_vh2vb_tp(ntp, swiftest_tpA, vs) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp type(swiftest_tp), intent(inout) :: swiftest_tpA real(kind=DP), intent(in), DIMENSION(NDIM) :: vs interface public subroutine discard(t, dt, npl, ntp, swiftest_plA, swiftest_tpA, rmin, rmax, rmaxu, qmin, qmin_alo, qmin_ahi, qmin_coord, lclose, lrhill_present) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp type(swiftest_pl), intent(inout) :: swiftest_plA type(swiftest_tp), intent(inout) :: swiftest_tpA real(kind=DP), intent(in) :: rmin real(kind=DP), intent(in) :: rmax real(kind=DP), intent(in) :: rmaxu real(kind=DP), intent(in) :: qmin real(kind=DP), intent(in) :: qmin_alo real(kind=DP), intent(in) :: qmin_ahi character(len=*), intent(in) :: qmin_coord logical(kind=LGT), intent(in) :: lclose logical(kind=LGT), intent(in) :: lrhill_present interface public subroutine discard_peri(t, npl, ntp, swiftest_plA, swiftest_tpA, msys, qmin, qmin_alo, qmin_ahi, qmin_coord, lrhill_present) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp type(swiftest_pl), intent(inout) :: swiftest_plA type(swiftest_tp), intent(inout) :: swiftest_tpA real(kind=DP), intent(in) :: msys real(kind=DP), intent(in) :: qmin real(kind=DP), intent(in) :: qmin_alo real(kind=DP), intent(in) :: qmin_ahi character(len=*), intent(in) :: qmin_coord logical(kind=LGT), intent(in) :: lrhill_present interface public subroutine discard_pl_close(dx, dv, dt, r2crit, iflag, r2min) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(NDIM) :: dx real(kind=DP), intent(in), DIMENSION(NDIM) :: dv real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r2crit integer(kind=I4B), intent(out) :: iflag real(kind=DP), intent(out) :: r2min interface public subroutine discard_pl(t, dt, npl, ntp, swiftest_plA, swiftest_tpA) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp type(swiftest_pl), intent(inout) :: swiftest_plA type(swiftest_tp), intent(inout) :: swiftest_tpA interface public subroutine discard_sun(t, ntp, msys, swifter_tpA, rmin, rmax, rmaxu) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: ntp real(kind=DP), intent(in) :: msys type(swiftest_tp), intent(inout) :: swifter_tpA real(kind=DP), intent(in) :: rmin real(kind=DP), intent(in) :: rmax real(kind=DP), intent(in) :: rmaxu interface public subroutine drift_dan(mu, x0, v0, dt0, iflag) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu real(kind=DP), intent(inout), DIMENSION(NDIM) :: x0 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v0 real(kind=DP), intent(in) :: dt0 integer(kind=I4B), intent(out) :: iflag interface public subroutine drift_kepmd(dm, es, ec, x, s, c) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dm real(kind=DP), intent(in) :: es real(kind=DP), intent(in) :: ec real(kind=DP), intent(out) :: x real(kind=DP), intent(out) :: s real(kind=DP), intent(out) :: c interface public subroutine drift_kepu(dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: fp real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 integer(kind=I4B), intent(out) :: iflag interface public subroutine drift_kepu_fchk(dt, r0, mu, alpha, u, s, f) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(in) :: s real(kind=DP), intent(out) :: f interface public subroutine drift_kepu_guess(dt, r0, mu, alpha, u, s) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: s interface public subroutine drift_kepu_lag(s, dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout) :: s real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: fp real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 integer(kind=I4B), intent(out) :: iflag interface public subroutine drift_kepu_new(s, dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout) :: s real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: fp real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 integer(kind=I4B), intent(out) :: iflag interface public subroutine drift_kepu_p3solve(dt, r0, mu, alpha, u, s, iflag) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: s integer(kind=I4B), intent(out) :: iflag interface public subroutine drift_kepu_stumpff(x, c0, c1, c2, c3) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout) :: x real(kind=DP), intent(out) :: c0 real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 interface public subroutine drift_one(mu, x, v, dt, iflag) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu real(kind=DP), intent(inout), DIMENSION(NDIM) :: x real(kind=DP), intent(inout), DIMENSION(NDIM) :: v real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(out) :: iflag interface public subroutine helio_drift(npl, swiftest_plA, dt) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(swiftest_pl), intent(inout) :: swiftest_plA real(kind=DP), intent(in) :: dt interface public subroutine helio_drift_tp(ntp, swiftest_tpA, mu, dt) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp type(swiftest_tp), intent(inout) :: swiftest_tpA real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: dt interface public subroutine helio_getacch(lflag, lextra_force, t, npl, nplmax, helio_plA, j2rp2, j4rp4) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lflag logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplmax type(helio_pl), intent(inout) :: helio_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 interface public subroutine helio_getacch_int(npl, helio_plA) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(helio_pl), intent(inout) :: helio_plA interface public subroutine helio_getacch_int_tp(npl, ntp, swiftest_plA, helio_tpA) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp type(swiftest_pl), intent(inout) :: swiftest_plA type(helio_tp), intent(inout) :: helio_tpA interface public subroutine helio_getacch_tp(lflag, lextra_force, t, npl, nplmax, ntp, ntpmax, helio_plA, helio_tpA, xh, j2rp2, j4rp4) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lflag logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: ntpmax type(helio_pl), intent(inout) :: helio_plA type(helio_tp), intent(inout) :: helio_tpA real(kind=DP), intent(in), DIMENSION(NDIM, npl) :: xh real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 interface public subroutine helio_kickvb(npl, helio_plA, dt) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(helio_pl), intent(inout) :: helio_plA real(kind=DP), intent(in) :: dt interface public subroutine helio_kickvb_tp(ntp, helio_tpA, dt) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp type(helio_tp), intent(inout) :: helio_tpA real(kind=DP), intent(in) :: dt interface public subroutine helio_lindrift(npl, swiftest_plA, dt, pt) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(swiftest_pl), intent(inout) :: swiftest_plA real(kind=DP), intent(in) :: dt real(kind=DP), intent(out), DIMENSION(NDIM) :: pt interface public subroutine helio_lindrift_tp(ntp, swiftest_tpA, dt, pt) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp type(swiftest_tp), intent(inout) :: swiftest_tpA real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), DIMENSION(NDIM) :: pt interface public subroutine helio_step(lfirst, lextra_force, t, npl, nplmax, ntp, ntpmax, helio_plA, helio_tpA, j2rp2, j4rp4, dt) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(inout) :: lfirst logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: ntpmax type(helio_pl), intent(inout) :: helio_plA type(helio_tp), intent(inout) :: helio_tpA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: dt interface public subroutine helio_step_pl(lfirst, lextra_force, t, npl, nplmax, helio_plA, j2rp2, j4rp4, dt, xbeg, xend, ptb, pte) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(inout) :: lfirst logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplmax type(helio_pl), intent(inout) :: helio_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: dt real(kind=DP), intent(out), DIMENSION(NDIM, npl) :: xbeg real(kind=DP), intent(out), DIMENSION(NDIM, npl) :: xend real(kind=DP), intent(out), DIMENSION(NDIM) :: ptb real(kind=DP), intent(out), DIMENSION(NDIM) :: pte interface public subroutine helio_step_tp(lfirsttp, lextra_force, t, npl, nplmax, ntp, ntpmax, helio_plA, helio_tpA, j2rp2, j4rp4, dt, xbeg, xend, ptb, pte) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(inout) :: lfirsttp logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: ntpmax type(helio_pl), intent(inout) :: helio_plA type(helio_tp), intent(inout) :: helio_tpA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), DIMENSION(NDIM, npl) :: xbeg real(kind=DP), intent(in), DIMENSION(NDIM, npl) :: xend real(kind=DP), intent(in), DIMENSION(NDIM) :: ptb real(kind=DP), intent(in), DIMENSION(NDIM) :: pte interface public subroutine helio_user_getacch(t, npl, helio_plA) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl type(helio_pl), intent(inout) :: helio_plA interface public subroutine helio_user_getacch_tp(t, ntp, helio_tpA) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: ntp type(helio_tp), intent(inout) :: helio_tpA interface public subroutine io_discard_write_symba(t, mtiny, npl, ntp, nsppl, nsptp, nmergeadd, symba_plA, discard_plA, discard_tpA, mergeadd_list, mergesub_list, fname, lbig_discard) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: mtiny integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: nsppl integer(kind=I4B), intent(in) :: nsptp integer(kind=I4B), intent(in) :: nmergeadd type(symba_pl), intent(inout) :: symba_plA type(swiftest_pl), intent(inout) :: discard_plA type(swiftest_tp), intent(inout) :: discard_tpA type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list character(len=*), intent(in) :: fname logical(kind=LGT), intent(in) :: lbig_discard interface public subroutine io_dump_param(nplmax, ntpmax, ntp, t, tstop, dt, in_type, istep_out, outfile, out_type, out_form, istep_dump, j2rp2, j4rp4, rmin, rmax, rmaxu, qmin, qmin_coord, qmin_alo, qmin_ahi, encounter_file, mtiny, feature, ring_outfile) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntpmax integer(kind=I4B), intent(in) :: ntp real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: tstop real(kind=DP), intent(in) :: dt character(len=*), intent(in) :: in_type integer(kind=I4B), intent(in) :: istep_out character(len=*), intent(in) :: outfile character(len=*), intent(in) :: out_type character(len=*), intent(in) :: out_form integer(kind=I4B), intent(in) :: istep_dump real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: rmin real(kind=DP), intent(in) :: rmax real(kind=DP), intent(in) :: rmaxu real(kind=DP), intent(in) :: qmin character(len=*), intent(in) :: qmin_coord real(kind=DP), intent(in) :: qmin_alo real(kind=DP), intent(in) :: qmin_ahi character(len=*), intent(in) :: encounter_file real(kind=DP), intent(in), optional :: mtiny type(feature_list), intent(in) :: feature character(len=*), intent(in), optional :: ring_outfile interface public subroutine io_dump_pl(npl, swiftest_plA, lclose, lrhill_present) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(swiftest_pl), intent(inout) :: swiftest_plA logical(kind=LGT), intent(in) :: lclose logical(kind=LGT), intent(in) :: lrhill_present interface public subroutine io_dump_tp(ntp, swiftest_tpA) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp type(swiftest_tp), intent(inout) :: swiftest_tpA interface public subroutine io_getn(inplfile, intpfile, in_type, npl, nplmax, ntp, ntpmax) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: inplfile character(len=*), intent(in) :: intpfile character(len=*), intent(in) :: in_type integer(kind=I4B), intent(out) :: npl integer(kind=I4B), intent(inout) :: nplmax integer(kind=I4B), intent(out) :: ntp integer(kind=I4B), intent(inout) :: ntpmax interface public subroutine io_init_pl(inplfile, in_type, lclose, lrhill_present, npl, symba_plA) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: inplfile character(len=*), intent(in) :: in_type logical(kind=LGT), intent(in) :: lclose logical(kind=LGT), intent(in) :: lrhill_present integer(kind=I4B), intent(in) :: npl type(symba_pl), intent(inout) :: symba_plA interface public subroutine io_init_tp(intpfile, in_type, ntp, symba_tpA) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: intpfile character(len=*), intent(in) :: in_type integer(kind=I4B), intent(in) :: ntp type(symba_tp), intent(inout) :: symba_tpA interface public subroutine io_open(iu, fname, fopenstat, fmt, ierr) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu character(len=*), intent(in) :: fname character(len=*), intent(in) :: fopenstat character(len=*), intent(in) :: fmt integer(kind=I4B), intent(out) :: ierr interface public subroutine io_open_fxdr(fname, fopenstat, lflag, iu, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname character(len=1), intent(in) :: fopenstat logical(kind=LGT), intent(in) :: lflag integer(kind=I4B), intent(out) :: iu integer(kind=I4B), intent(out) :: ierr interface public function io_read_encounter(t, name1, name2, mass1, mass2, xh1, xh2, vh1, vh2, encounter_file, out_type) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(out) :: t integer(kind=I4B), intent(out) :: name1 integer(kind=I4B), intent(out) :: name2 real(kind=DP), intent(out) :: mass1 real(kind=DP), intent(out) :: mass2 real(kind=DP), intent(out), DIMENSION(NDIM) :: xh1 real(kind=DP), intent(out), DIMENSION(NDIM) :: xh2 real(kind=DP), intent(out), DIMENSION(NDIM) :: vh1 real(kind=DP), intent(out), DIMENSION(NDIM) :: vh2 character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type Return Value integer(kind=I4B) interface public function io_read_hdr(iu, t, npl, ntp, iout_form, out_type) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu real(kind=DP), intent(out) :: t integer(kind=I4B), intent(out) :: npl integer(kind=I4B), intent(out) :: ntp integer(kind=I4B), intent(out) :: iout_form character(len=*), intent(in) :: out_type Return Value integer(kind=I4B) interface public function io_read_line(iu, name, d1, d2, d3, d4, d5, d6, out_type, MASS, RADIUS) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu integer(kind=I4B), intent(out) :: name real(kind=DP), intent(out) :: d1 real(kind=DP), intent(out) :: d2 real(kind=DP), intent(out) :: d3 real(kind=DP), intent(out) :: d4 real(kind=DP), intent(out) :: d5 real(kind=DP), intent(out) :: d6 character(len=*), intent(in) :: out_type real(kind=DP), intent(out), optional :: MASS real(kind=DP), intent(out), optional :: RADIUS Return Value integer(kind=I4B) interface public subroutine io_write_encounter(t, name1, name2, mass1, mass2, radius1, radius2, xh1, xh2, vh1, vh2, encounter_file, out_type) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: name1 integer(kind=I4B), intent(in) :: name2 real(kind=DP), intent(in) :: mass1 real(kind=DP), intent(in) :: mass2 real(kind=DP), intent(in) :: radius1 real(kind=DP), intent(in) :: radius2 real(kind=DP), intent(in), DIMENSION(NDIM) :: xh1 real(kind=DP), intent(in), DIMENSION(NDIM) :: xh2 real(kind=DP), intent(in), DIMENSION(NDIM) :: vh1 real(kind=DP), intent(in), DIMENSION(NDIM) :: vh2 character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type interface public subroutine io_write_frame(t, npl, ntp, swiftest_plA, swiftest_tpA, outfile, out_type, out_form, out_stat) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp type(swiftest_pl), intent(inout) :: swiftest_plA type(swiftest_tp), intent(inout) :: swiftest_tpA character(len=*), intent(in) :: outfile character(len=*), intent(in) :: out_type character(len=*), intent(in) :: out_form character(len=*), intent(in) :: out_stat interface public subroutine io_write_hdr(iu, t, npl, ntp, iout_form, out_type) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: iout_form character(len=*), intent(in) :: out_type interface public subroutine io_write_line(iu, name, d1, d2, d3, d4, d5, d6, out_type, MASS, RADIUS) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu integer(kind=I4B), intent(in) :: name real(kind=DP), intent(in) :: d1 real(kind=DP), intent(in) :: d2 real(kind=DP), intent(in) :: d3 real(kind=DP), intent(in) :: d4 real(kind=DP), intent(in) :: d5 real(kind=DP), intent(in) :: d6 character(len=*), intent(in) :: out_type real(kind=DP), intent(in), optional :: MASS real(kind=DP), intent(in), optional :: RADIUS interface public subroutine obl_acc(npl, swiftest_plA, j2rp2, j4rp4, xh, irh, aobl) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(swiftest_pl), intent(inout) :: swiftest_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in), DIMENSION(NDIM, npl) :: xh real(kind=DP), intent(in), DIMENSION(npl) :: irh real(kind=DP), intent(out), DIMENSION(NDIM, npl) :: aobl interface public subroutine obl_acc_tp(ntp, xht, j2rp2, j4rp4, irht, aoblt, msun) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp real(kind=DP), intent(in), DIMENSION(NDIM, ntp) :: xht real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in), DIMENSION(ntp) :: irht real(kind=DP), intent(out), DIMENSION(NDIM, ntp) :: aoblt real(kind=DP), intent(in) :: msun interface public subroutine obl_pot(npl, swiftest_plA, j2rp2, j4rp4, xh, irh, oblpot) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(swiftest_pl), intent(inout) :: swiftest_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in), DIMENSION(NDIM, npl) :: xh real(kind=DP), intent(in), DIMENSION(npl) :: irh real(kind=DP), intent(out) :: oblpot interface public subroutine orbel_scget(angle, sx, cx) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: angle real(kind=DP), intent(out) :: sx real(kind=DP), intent(out) :: cx interface public subroutine orbel_xv2aeq(x, v, mu, a, e, q) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(NDIM) :: x real(kind=DP), intent(in), DIMENSION(NDIM) :: v real(kind=DP), intent(in) :: mu real(kind=DP), intent(out) :: a real(kind=DP), intent(out) :: e real(kind=DP), intent(out) :: q interface public subroutine orbel_xv2aqt(x, v, mu, a, q, capm, tperi) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(NDIM) :: x real(kind=DP), intent(in), DIMENSION(NDIM) :: v real(kind=DP), intent(in) :: mu real(kind=DP), intent(out) :: a real(kind=DP), intent(out) :: q real(kind=DP), intent(out) :: capm real(kind=DP), intent(out) :: tperi interface public subroutine orbel_xv2el(x, v, mu, a, e, inc, capom, omega, capm) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(NDIM) :: x real(kind=DP), intent(in), DIMENSION(NDIM) :: v real(kind=DP), intent(in) :: mu real(kind=DP), intent(out) :: a real(kind=DP), intent(out) :: e real(kind=DP), intent(out) :: inc real(kind=DP), intent(out) :: capom real(kind=DP), intent(out) :: omega real(kind=DP), intent(out) :: capm interface public subroutine python_io_write_frame_pl(t, symba_plA, npl, out_stat) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t type(symba_pl), intent(in) :: symba_plA integer, intent(in) :: npl character(len=*), intent(in) :: out_stat interface public subroutine python_io_write_frame_tp(t, symba_tpA, ntp, out_stat) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t type(symba_tp), intent(in) :: symba_tpA integer, intent(in) :: ntp character(len=*), intent(in) :: out_stat interface public subroutine rmvs_chk_ind(xr, vr, dt, r2crit, iflag) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(NDIM) :: xr real(kind=DP), intent(in), DIMENSION(NDIM) :: vr real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r2crit integer(kind=I4B), intent(out) :: iflag interface public subroutine symba_casedisruption(t, dt, index_enc, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, vbs, symba_plA, nplplenc, plplenc_list, nplmax, ntpmax, fragmax, mres, rres, m1, m2, rad1, rad2, x1, x2, v1, v2) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs type(symba_pl), intent(inout) :: symba_plA integer(kind=I4B), intent(inout) :: nplplenc type(symba_plplenc), intent(inout) :: plplenc_list integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntpmax integer(kind=I4B), intent(inout) :: fragmax real(kind=DP), intent(inout), DIMENSION(3) :: mres real(kind=DP), intent(inout), DIMENSION(3) :: rres real(kind=DP), intent(inout) :: m1 real(kind=DP), intent(inout) :: m2 real(kind=DP), intent(inout) :: rad1 real(kind=DP), intent(inout) :: rad2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v2 interface public subroutine symba_casehitandrun(t, index_enc, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, vbs, symba_plA, nplplenc, plplenc_list, nplmax, ntpmax, fragmax, mres, rres, m1, m2, rad1, rad2, x1, x2, v1, v2) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs type(symba_pl), intent(inout) :: symba_plA integer(kind=I4B), intent(inout) :: nplplenc type(symba_plplenc), intent(inout) :: plplenc_list integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntpmax integer(kind=I4B), intent(inout) :: fragmax real(kind=DP), intent(inout), DIMENSION(3) :: mres real(kind=DP), intent(inout), DIMENSION(3) :: rres real(kind=DP), intent(inout) :: m1 real(kind=DP), intent(inout) :: m2 real(kind=DP), intent(inout) :: rad1 real(kind=DP), intent(inout) :: rad2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v2 interface public subroutine symba_casemerge(t, dt, index_enc, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, vbs, encounter_file, out_type, npl, ntp, symba_plA, symba_tpA, nplplenc, npltpenc, pltpenc_list, plplenc_list, array_index1_child, array_index2_child, m1, m2, rad1, rad2, x1, x2, v1, v2) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type integer(kind=I4B), intent(inout) :: npl integer(kind=I4B), intent(inout) :: ntp type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA integer(kind=I4B), intent(inout) :: nplplenc integer(kind=I4B), intent(inout) :: npltpenc type(symba_pltpenc), intent(inout) :: pltpenc_list type(symba_plplenc), intent(inout) :: plplenc_list integer(kind=I4B), intent(inout), DIMENSION(npl) :: array_index1_child integer(kind=I4B), intent(inout), DIMENSION(npl) :: array_index2_child real(kind=DP), intent(inout) :: m1 real(kind=DP), intent(inout) :: m2 real(kind=DP), intent(inout) :: rad1 real(kind=DP), intent(inout) :: rad2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v2 interface public subroutine symba_caseresolve(t, dt, index_enc, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, vbs, encounter_file, out_type, npl, ntp, symba_plA, symba_tpA, nplplenc, npltpenc, pltpenc_list, plplenc_list, regime, nplmax, ntpmax, fragmax, mres, rres, array_index1_child, array_index2_child, m1, m2, rad1, rad2, x1, x2, v1, v2) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type integer(kind=I4B), intent(inout) :: npl integer(kind=I4B), intent(inout) :: ntp type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA integer(kind=I4B), intent(inout) :: nplplenc integer(kind=I4B), intent(inout) :: npltpenc type(symba_pltpenc), intent(inout) :: pltpenc_list type(symba_plplenc), intent(inout) :: plplenc_list integer(kind=I4B), intent(in) :: regime integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntpmax integer(kind=I4B), intent(inout) :: fragmax real(kind=DP), intent(inout), DIMENSION(3) :: mres real(kind=DP), intent(inout), DIMENSION(3) :: rres integer(kind=I4B), intent(inout), DIMENSION(npl) :: array_index1_child integer(kind=I4B), intent(inout), DIMENSION(npl) :: array_index2_child real(kind=DP), intent(inout) :: m1 real(kind=DP), intent(inout) :: m2 real(kind=DP), intent(inout) :: rad1 real(kind=DP), intent(inout) :: rad2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v2 interface public subroutine symba_casesupercatastrophic(t, dt, index_enc, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, vbs, symba_plA, nplplenc, plplenc_list, nplmax, ntpmax, fragmax, mres, rres, m1, m2, rad1, rad2, x1, x2, v1, v2) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs type(symba_pl), intent(inout) :: symba_plA integer(kind=I4B), intent(inout) :: nplplenc type(symba_plplenc), intent(inout) :: plplenc_list integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntpmax integer(kind=I4B), intent(inout) :: fragmax real(kind=DP), intent(inout), DIMENSION(3) :: mres real(kind=DP), intent(inout), DIMENSION(3) :: rres real(kind=DP), intent(inout) :: m1 real(kind=DP), intent(inout) :: m2 real(kind=DP), intent(inout) :: rad1 real(kind=DP), intent(inout) :: rad2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: x2 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v1 real(kind=DP), intent(inout), DIMENSION(NDIM) :: v2 interface public subroutine symba_chk(xr, vr, rhill1, rhill2, dt, irec, lencounter, lvdotr) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: xr real(kind=DP), intent(in), DIMENSION(:) :: vr real(kind=DP), intent(in) :: rhill1 real(kind=DP), intent(in) :: rhill2 real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: irec logical(kind=LGT), intent(out) :: lencounter logical(kind=LGT), intent(out) :: lvdotr interface public subroutine symba_discard_merge_pl(t, npl, symba_plA, nplplenc, plplenc_list) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(inout) :: npl type(symba_pl) :: symba_plA integer(kind=I4B), intent(in) :: nplplenc type(symba_plplenc), intent(in) :: plplenc_list interface public subroutine symba_discard_peri_pl(t, npl, symba_plA, msys, qmin, qmin_alo, qmin_ahi, qmin_coord, ldiscards) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl type(symba_pl), intent(inout) :: symba_plA real(kind=DP), intent(in) :: msys real(kind=DP), intent(in) :: qmin real(kind=DP), intent(in) :: qmin_alo real(kind=DP), intent(in) :: qmin_ahi character(len=*), intent(in) :: qmin_coord logical(kind=LGT), intent(inout) :: ldiscards interface public subroutine symba_discard_pl(t, npl, nplmax, nsp, symba_plA, rmin, rmax, rmaxu, qmin, qmin_coord, qmin_alo, qmin_ahi, j2rp2, j4rp4, eoffset) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(inout) :: npl integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(inout) :: nsp type(symba_pl), intent(inout) :: symba_plA real(kind=DP), intent(in) :: rmin real(kind=DP), intent(in) :: rmax real(kind=DP), intent(in) :: rmaxu real(kind=DP), intent(in) :: qmin character(len=*), intent(in) :: qmin_coord real(kind=DP), intent(in) :: qmin_alo real(kind=DP), intent(in) :: qmin_ahi real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(inout) :: eoffset interface public subroutine symba_discard_sun_pl(t, npl, msys, swiftest_plA, rmin, rmax, rmaxu, ldiscards) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl real(kind=DP), intent(in) :: msys type(swiftest_pl), intent(inout) :: swiftest_plA real(kind=DP), intent(in) :: rmin real(kind=DP), intent(in) :: rmax real(kind=DP), intent(in) :: rmaxu logical(kind=LGT), intent(inout) :: ldiscards interface public subroutine symba_discard_tp(t, npl, ntp, nsp, symba_plA, symba_tpA, dt, rmin, rmax, rmaxu, qmin, qmin_coord, qmin_alo, qmin_ahi, lclose, lrhill_present) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(inout) :: ntp integer(kind=I4B), intent(inout) :: nsp type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: rmin real(kind=DP), intent(in) :: rmax real(kind=DP), intent(in) :: rmaxu real(kind=DP), intent(in) :: qmin character(len=*), intent(in) :: qmin_coord real(kind=DP), intent(in) :: qmin_alo real(kind=DP), intent(in) :: qmin_ahi logical(kind=LGT), intent(in) :: lclose logical(kind=LGT), intent(in) :: lrhill_present interface public subroutine symba_energy(npl, swiftest_plA, j2rp2, j4rp4, ke, pe, te, htot) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(swiftest_pl), intent(inout) :: swiftest_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(out) :: ke real(kind=DP), intent(out) :: pe real(kind=DP), intent(out) :: te real(kind=DP), intent(out), DIMENSION(NDIM) :: htot interface public subroutine symba_fragmentation(t, dt, index_enc, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, vbs, encounter_file, out_type, npl, ntp, symba_plA, symba_tpA, nplplenc, npltpenc, pltpenc_list, plplenc_list, nplmax, ntpmax, fragmax) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type integer(kind=I4B), intent(inout) :: npl integer(kind=I4B), intent(inout) :: ntp type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA integer(kind=I4B), intent(inout) :: nplplenc integer(kind=I4B), intent(inout) :: npltpenc type(symba_pltpenc), intent(inout) :: pltpenc_list type(symba_plplenc), intent(inout) :: plplenc_list integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntpmax integer(kind=I4B), intent(inout) :: fragmax interface public subroutine symba_getacch(lextra_force, t, npl, nplm, symba_plA, j2rp2, j4rp4, nplplenc, plplenc_list) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm type(symba_pl), intent(inout) :: symba_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 integer(kind=I4B), intent(in) :: nplplenc type(symba_plplenc), intent(in) :: plplenc_list interface public subroutine symba_getacch_tp(lextra_force, t, npl, nplm, nplmax, ntp, ntpmax, symba_plA, symba_tpA, xh, j2rp2, j4rp4, npltpenc, pltpenc_list) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: ntpmax type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA real(kind=DP), intent(in), DIMENSION(NDIM, npl) :: xh real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 integer(kind=I4B), intent(in) :: npltpenc type(symba_pltpenc), intent(in) :: pltpenc_list interface public subroutine symba_helio_drift(irec, npl, symba_plA, dt) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: irec integer(kind=I4B), intent(in) :: npl type(symba_pl), intent(inout) :: symba_plA real(kind=DP), intent(in) :: dt interface public subroutine symba_helio_drift_tp(irec, ntp, symba_tpA, mu, dt) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: irec integer(kind=I4B), intent(in) :: ntp type(symba_tp), intent(inout) :: symba_tpA real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: dt interface public subroutine symba_helio_getacch(lflag, lextra_force, t, npl, nplm, nplmax, helio_plA, j2rp2, j4rp4) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lflag logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm integer(kind=I4B), intent(in) :: nplmax type(helio_pl), intent(inout) :: helio_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 interface public subroutine symba_helio_getacch_int(npl, nplm, helio_plA) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm type(helio_pl), intent(inout) :: helio_plA interface public subroutine symba_kick(irec, nplplenc, npltpenc, plplenc_list, pltpenc_list, dt, sgn, symba_plA, symba_tpA) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: irec integer(kind=I4B), intent(in) :: nplplenc integer(kind=I4B), intent(in) :: npltpenc type(symba_plplenc), intent(in) :: plplenc_list type(symba_pltpenc), intent(in) :: pltpenc_list real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: sgn type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA interface public subroutine symba_merge_pl(t, dt, index_enc, nplplenc, plplenc_list, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, vbs, encounter_file, out_type, npl, symba_plA, symba_tpA) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(in) :: nplplenc type(symba_plplenc), intent(inout) :: plplenc_list integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type integer(kind=I4B), intent(inout) :: npl type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA interface public subroutine symba_merge_tp(t, dt, index_enc, npltpenc, pltpenc_list, vbs, encounter_file, out_type, symba_plA, symba_tpA) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: index_enc integer(kind=I4B), intent(in) :: npltpenc type(symba_pltpenc), intent(inout) :: pltpenc_list real(kind=DP), intent(in), DIMENSION(NDIM) :: vbs character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA interface public subroutine symba_peri(lfirst, npl, symba_plA, msys, qmin_coord) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lfirst integer(kind=I4B), intent(in) :: npl type(symba_pl), intent(inout) :: symba_plA real(kind=DP), intent(in) :: msys character(len=*), intent(in) :: qmin_coord interface public subroutine symba_rearray(npl, ntp, nsppl, nsptp, symba_plA, symba_tpA, nmergeadd, mergeadd_list, discard_plA, discard_tpA, feature) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: npl integer(kind=I4B), intent(inout) :: ntp integer(kind=I4B), intent(inout) :: nsppl integer(kind=I4B), intent(inout) :: nsptp type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA integer(kind=I4B), intent(inout) :: nmergeadd type(symba_merger), intent(inout) :: mergeadd_list type(swiftest_pl), intent(inout) :: discard_plA type(swiftest_tp), intent(inout) :: discard_tpA type(feature_list), intent(in) :: feature interface public subroutine symba_reorder_pl(npl, symba_plA) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(symba_pl), intent(inout) :: symba_plA interface public subroutine symba_setup(npl, ntp, symba_plA, symba_tpA, symba_pl1P, symba_tp1P, swiftest_pl1P, swiftest_tp1P) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA type(symba_pl), POINTER :: symba_pl1P type(symba_tp), POINTER :: symba_tp1P type(swiftest_pl), POINTER :: swiftest_pl1P type(swiftest_tp), POINTER :: swiftest_tp1P interface public subroutine symba_step(lfirst, lextra_force, lclose, t, npl, nplmax, ntp, ntpmax, symba_plA, symba_tpA, j2rp2, j4rp4, dt, nplplenc, npltpenc, plplenc_list, pltpenc_list, nmergeadd, nmergesub, mergeadd_list, mergesub_list, eoffset, mtiny, encounter_file, out_type, fragmax, feature) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(inout) :: lfirst logical(kind=LGT), intent(in) :: lextra_force logical(kind=LGT), intent(in) :: lclose real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: ntpmax type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(inout) :: nplplenc integer(kind=I4B), intent(inout) :: npltpenc type(symba_plplenc), intent(inout) :: plplenc_list type(symba_pltpenc), intent(inout) :: pltpenc_list integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list real(kind=DP), intent(inout) :: eoffset real(kind=DP), intent(in) :: mtiny character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type integer(kind=I4B), intent(inout) :: fragmax type(feature_list) :: feature interface public subroutine symba_step_helio(lfirst, lextra_force, t, npl, nplm, nplmax, ntp, ntpmax, helio_plA, helio_tpA, j2rp2, j4rp4, dt) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(inout) :: lfirst logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: ntpmax type(helio_pl), intent(inout) :: helio_plA type(helio_tp), intent(inout) :: helio_tpA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: dt interface public subroutine symba_step_helio_pl(lfirst, lextra_force, t, npl, nplm, nplmax, helio_plA, j2rp2, j4rp4, dt, xbeg, xend, ptb, pte) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(inout) :: lfirst logical(kind=LGT), intent(in) :: lextra_force real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm integer(kind=I4B), intent(in) :: nplmax type(helio_pl), intent(inout) :: helio_plA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: dt real(kind=DP), intent(out), DIMENSION(NDIM, nplm) :: xbeg real(kind=DP), intent(out), DIMENSION(NDIM, nplm) :: xend real(kind=DP), intent(out), DIMENSION(NDIM) :: ptb real(kind=DP), intent(out), DIMENSION(NDIM) :: pte interface public subroutine symba_step_interp(lextra_force, lclose, t, npl, nplm, nplmax, ntp, ntpmax, symba_plA, symba_tpA, j2rp2, j4rp4, dt, eoffset, nplplenc, npltpenc, plplenc_list, pltpenc_list, nmergeadd, nmergesub, mergeadd_list, mergesub_list, encounter_file, out_type, fragmax, feature) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lextra_force logical(kind=LGT), intent(in) :: lclose real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntp integer(kind=I4B), intent(in) :: ntpmax type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA real(kind=DP), intent(in) :: j2rp2 real(kind=DP), intent(in) :: j4rp4 real(kind=DP), intent(in) :: dt real(kind=DP), intent(inout) :: eoffset integer(kind=I4B), intent(in) :: nplplenc integer(kind=I4B), intent(in) :: npltpenc type(symba_plplenc), intent(inout) :: plplenc_list type(symba_pltpenc), intent(inout) :: pltpenc_list integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type integer(kind=I4B), intent(inout) :: fragmax type(feature_list), intent(in) :: feature interface public subroutine symba_step_recur(lclose, t, ireci, npl, nplm, ntp, symba_plA, symba_tpA, dt0, eoffset, nplplenc, npltpenc, plplenc_list, pltpenc_list, nmergeadd, nmergesub, mergeadd_list, mergesub_list, encounter_file, out_type, nplmax, ntpmax, fragmax, feature) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lclose real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: ireci integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: nplm integer(kind=I4B), intent(in) :: ntp type(symba_pl), intent(inout) :: symba_plA type(symba_tp), intent(inout) :: symba_tpA real(kind=DP), intent(in) :: dt0 real(kind=DP), intent(inout) :: eoffset integer(kind=I4B), intent(in) :: nplplenc integer(kind=I4B), intent(in) :: npltpenc type(symba_plplenc), intent(inout) :: plplenc_list type(symba_pltpenc), intent(inout) :: pltpenc_list integer(kind=I4B), intent(inout) :: nmergeadd integer(kind=I4B), intent(inout) :: nmergesub type(symba_merger), intent(inout) :: mergeadd_list type(symba_merger), intent(inout) :: mergesub_list character(len=*), intent(in) :: encounter_file character(len=*), intent(in) :: out_type integer(kind=I4B), intent(in) :: nplmax integer(kind=I4B), intent(in) :: ntpmax integer(kind=I4B), intent(in) :: fragmax type(feature_list), intent(in) :: feature interface public subroutine symba_user_getacch(t, npl, symba_plA) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: npl type(symba_pl), intent(inout) :: symba_plA interface public subroutine symba_user_getacch_tp(t, ntp, symba_tpA) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: ntp type(symba_tp), intent(inout) :: symba_tpA interface public subroutine util_exit(code) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: code interface public subroutine util_hills(npl, swiftest_plA) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl type(swiftest_pl), intent(inout) :: swiftest_plA interface public subroutine util_index(arr, index) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: arr integer(kind=I4B), intent(out), DIMENSION(:) :: index interface public subroutine util_peri(lfirst, ntp, swiftest_tpA, mu, msys, qmin_coord) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: lfirst integer(kind=I4B), intent(in) :: ntp type(swiftest_tp), intent(inout) :: swiftest_tpA real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: msys character(len=*), intent(in) :: qmin_coord interface public subroutine util_resize_pl(symba_plA, npl_new, npl_old) Arguments Type Intent Optional Attributes Name type(symba_pl), intent(inout) :: symba_plA integer(kind=I4B), intent(in) :: npl_new integer(kind=I4B), intent(in) :: npl_old public interface util_sort public subroutine util_sort_i4b(arr) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), DIMENSION(:) :: arr public subroutine util_sort_sp(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: arr public subroutine util_sort_dp(arr) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), DIMENSION(:) :: arr interface public subroutine util_toupper(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string interface public subroutine util_valid(npl, ntp, swiftest_plA, swiftest_tpA) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl integer(kind=I4B), intent(in) :: ntp type(swiftest_pl), intent(inout) :: swiftest_plA type(swiftest_tp), intent(inout) :: swiftest_tpA interface public subroutine util_version() Arguments None interface public function util_kahan_sum(xsum_current, xi, xerror) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: xsum_current real(kind=DP), intent(in) :: xi real(kind=DP), intent(inout) :: xerror Return Value real(kind=DP) interface public function collresolve_resolve(model, m1, m2, r1, r2, p1, p2, v1, v2, n, mres, rres, pres, vres) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: model real(kind=DP), intent(in) :: m1 real(kind=DP), intent(in) :: m2 real(kind=DP), intent(in) :: r1 real(kind=DP), intent(in) :: r2 real(kind=DP), intent(in), DIMENSION(3) :: p1 real(kind=DP), intent(in), DIMENSION(3) :: p2 real(kind=DP), intent(in), DIMENSION(3) :: v1 real(kind=DP), intent(in), DIMENSION(3) :: v2 integer, intent(in) :: n real(kind=DP), intent(out), DIMENSION(n+1) :: mres real(kind=DP), intent(out), DIMENSION(n+1) :: rres real(kind=DP), intent(out), DIMENSION(3,n+1) :: pres real(kind=DP), intent(out), DIMENSION(3,n+1) :: vres Return Value integer(kind=I4B) interface public subroutine util_regime(symba_plA, index1, index2, regime, Mlr, Mslr) Arguments Type Intent Optional Attributes Name type(symba_pl), intent(inout) :: symba_plA integer(kind=I4B), intent(in) :: index1 integer(kind=I4B), intent(in) :: index2 integer(kind=I4B), intent(out) :: regime real(kind=DP), intent(out) :: Mlr real(kind=DP), intent(out) :: Mslr","tags":"","loc":"module/module_interfaces.html"},{"title":"module_swiftest – swiftest","text":"Uses swiftest module~~module_swiftest~~UsesGraph module~module_swiftest module_swiftest module~swiftest swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~module_swiftest~~UsedByGraph module~module_swiftest module_swiftest proc~util_peri util_peri proc~util_peri->module~module_swiftest proc~symba_casehitandrun symba_casehitandrun proc~symba_casehitandrun->module~module_swiftest module~module_helio module_helio proc~symba_casehitandrun->module~module_helio module~module_symba module_symba proc~symba_casehitandrun->module~module_symba proc~helio_kickvb_tp helio_kickvb_tp proc~helio_kickvb_tp->module~module_swiftest proc~helio_kickvb_tp->module~module_helio proc~helio_lindrift helio_lindrift proc~helio_lindrift->module~module_swiftest proc~helio_lindrift->module~module_symba proc~symba_getacch_tp symba_getacch_tp proc~symba_getacch_tp->module~module_swiftest proc~symba_getacch_tp->module~module_helio proc~symba_getacch_tp->module~module_symba proc~symba_discard_sun_pl symba_discard_sun_pl proc~symba_discard_sun_pl->module~module_swiftest proc~symba_step_interp symba_step_interp proc~symba_step_interp->module~module_swiftest proc~symba_step_interp->module~module_helio proc~symba_step_interp->module~module_symba proc~symba_casemerge symba_casemerge proc~symba_casemerge->module~module_swiftest proc~symba_casemerge->module~module_helio proc~symba_casemerge->module~module_symba proc~swiftest_pl_allocate swiftest_pl_allocate proc~swiftest_pl_allocate->module~module_swiftest proc~symba_energy symba_energy proc~symba_energy->module~module_swiftest proc~discard_sun discard_sun proc~discard_sun->module~module_swiftest proc~discard_peri discard_peri proc~discard_peri->module~module_swiftest proc~helio_kickvb helio_kickvb proc~helio_kickvb->module~module_swiftest proc~helio_kickvb->module~module_helio proc~helio_drift_tp helio_drift_tp proc~helio_drift_tp->module~module_swiftest proc~helio_drift helio_drift proc~helio_drift->module~module_swiftest proc~symba_rearray symba_rearray proc~symba_rearray->module~module_swiftest proc~symba_rearray->module~module_helio proc~symba_rearray->module~module_symba proc~io_discard_write_symba io_discard_write_symba proc~io_discard_write_symba->module~module_swiftest proc~io_discard_write_symba->module~module_symba proc~obl_acc obl_acc proc~obl_acc->module~module_swiftest proc~symba_caseresolve symba_caseresolve proc~symba_caseresolve->module~module_swiftest proc~symba_caseresolve->module~module_helio proc~symba_caseresolve->module~module_symba proc~symba_getacch symba_getacch proc~symba_getacch->module~module_swiftest proc~symba_getacch->module~module_helio proc~symba_getacch->module~module_symba proc~helio_step_pl helio_step_pl proc~helio_step_pl->module~module_swiftest proc~helio_step_pl->module~module_helio proc~io_dump_tp io_dump_tp proc~io_dump_tp->module~module_swiftest proc~symba_reorder_pl symba_reorder_pl proc~symba_reorder_pl->module~module_swiftest proc~symba_reorder_pl->module~module_helio proc~symba_reorder_pl->module~module_symba proc~io_write_frame io_write_frame proc~io_write_frame->module~module_swiftest proc~symba_step symba_step proc~symba_step->module~module_swiftest proc~symba_step->module~module_helio proc~symba_step->module~module_symba proc~symba_step_helio symba_step_helio proc~symba_step_helio->module~module_swiftest proc~symba_step_helio->module~module_helio proc~symba_step_helio->module~module_symba proc~discard discard proc~discard->module~module_swiftest proc~util_valid util_valid proc~util_valid->module~module_swiftest proc~symba_discard_tp symba_discard_tp proc~symba_discard_tp->module~module_swiftest proc~symba_discard_tp->module~module_helio proc~symba_discard_tp->module~module_symba proc~symba_fragmentation symba_fragmentation proc~symba_fragmentation->module~module_swiftest proc~symba_fragmentation->module~module_helio proc~symba_fragmentation->module~module_symba proc~coord_vh2vb coord_vh2vb proc~coord_vh2vb->module~module_swiftest proc~coord_vh2vb->module~module_symba proc~util_hills util_hills proc~util_hills->module~module_swiftest proc~symba_step_helio_pl symba_step_helio_pl proc~symba_step_helio_pl->module~module_swiftest proc~symba_step_helio_pl->module~module_helio proc~symba_step_helio_pl->module~module_symba proc~symba_casedisruption symba_casedisruption proc~symba_casedisruption->module~module_swiftest proc~symba_casedisruption->module~module_helio proc~symba_casedisruption->module~module_symba proc~symba_discard_peri_pl symba_discard_peri_pl proc~symba_discard_peri_pl->module~module_swiftest proc~symba_discard_peri_pl->module~module_helio proc~symba_discard_peri_pl->module~module_symba proc~swiftest_pl_deallocate swiftest_pl_deallocate proc~swiftest_pl_deallocate->module~module_swiftest proc~python_io_write_frame_pl python_io_write_frame_pl proc~python_io_write_frame_pl->module~module_swiftest proc~python_io_write_frame_pl->module~module_helio proc~python_io_write_frame_pl->module~module_symba proc~symba_discard_pl symba_discard_pl proc~symba_discard_pl->module~module_swiftest proc~symba_discard_pl->module~module_helio proc~symba_discard_pl->module~module_symba proc~coord_h2b_tp coord_h2b_tp proc~coord_h2b_tp->module~module_swiftest proc~helio_step_tp helio_step_tp proc~helio_step_tp->module~module_swiftest proc~helio_step_tp->module~module_helio proc~io_init_pl io_init_pl proc~io_init_pl->module~module_swiftest proc~io_init_pl->module~module_helio proc~io_init_pl->module~module_symba proc~helio_getacch_int_tp helio_getacch_int_tp proc~helio_getacch_int_tp->module~module_swiftest proc~helio_getacch_int_tp->module~module_helio proc~coord_vb2vh_tp coord_vb2vh_tp proc~coord_vb2vh_tp->module~module_swiftest proc~coord_vb2vh_tp->module~module_symba proc~swiftest_tp_deallocate swiftest_tp_deallocate proc~swiftest_tp_deallocate->module~module_swiftest proc~io_init_tp io_init_tp proc~io_init_tp->module~module_swiftest proc~io_init_tp->module~module_helio proc~io_init_tp->module~module_symba proc~symba_casesupercatastrophic symba_casesupercatastrophic proc~symba_casesupercatastrophic->module~module_swiftest proc~symba_casesupercatastrophic->module~module_helio proc~symba_casesupercatastrophic->module~module_symba proc~symba_helio_drift symba_helio_drift proc~symba_helio_drift->module~module_swiftest proc~symba_helio_drift->module~module_helio proc~symba_helio_drift->module~module_symba program~swiftest_symba swiftest_symba program~swiftest_symba->module~module_swiftest program~swiftest_symba->module~module_symba module~io io program~swiftest_symba->module~io proc~symba_helio_getacch symba_helio_getacch proc~symba_helio_getacch->module~module_swiftest proc~symba_helio_getacch->module~module_helio proc~symba_helio_getacch->module~module_symba proc~symba_chk symba_chk proc~symba_chk->module~module_swiftest proc~symba_chk->module~module_helio proc~symba_chk->module~module_symba module~module_helio->module~module_swiftest proc~helio_getacch_tp helio_getacch_tp proc~helio_getacch_tp->module~module_swiftest proc~helio_getacch_tp->module~module_helio proc~helio_getacch helio_getacch proc~helio_getacch->module~module_swiftest proc~helio_getacch->module~module_helio proc~io_dump_pl io_dump_pl proc~io_dump_pl->module~module_swiftest proc~coord_vh2vb_tp coord_vh2vb_tp proc~coord_vh2vb_tp->module~module_swiftest proc~coord_vb2vh coord_vb2vh proc~coord_vb2vh->module~module_swiftest proc~symba_step_recur symba_step_recur proc~symba_step_recur->module~module_swiftest proc~symba_step_recur->module~module_helio proc~symba_step_recur->module~module_symba proc~discard_pl discard_pl proc~discard_pl->module~module_swiftest proc~swiftest_tp_allocate swiftest_tp_allocate proc~swiftest_tp_allocate->module~module_swiftest proc~coord_h2b coord_h2b proc~coord_h2b->module~module_swiftest proc~symba_helio_drift_tp symba_helio_drift_tp proc~symba_helio_drift_tp->module~module_swiftest proc~symba_helio_drift_tp->module~module_helio proc~symba_helio_drift_tp->module~module_symba proc~util_resize_pl util_resize_pl proc~util_resize_pl->module~module_swiftest proc~util_resize_pl->module~module_helio proc~util_resize_pl->module~module_symba proc~helio_lindrift_tp helio_lindrift_tp proc~helio_lindrift_tp->module~module_swiftest proc~helio_lindrift_tp->module~module_symba proc~obl_pot obl_pot proc~obl_pot->module~module_swiftest proc~symba_merge_pl symba_merge_pl proc~symba_merge_pl->module~module_swiftest proc~symba_merge_pl->module~module_helio proc~symba_merge_pl->module~module_symba proc~python_io_write_frame_tp python_io_write_frame_tp proc~python_io_write_frame_tp->module~module_swiftest proc~python_io_write_frame_tp->module~module_helio proc~python_io_write_frame_tp->module~module_symba proc~symba_kick symba_kick proc~symba_kick->module~module_swiftest proc~symba_kick->module~module_helio proc~symba_kick->module~module_symba proc~symba_peri symba_peri proc~symba_peri->module~module_swiftest proc~symba_peri->module~module_helio proc~symba_peri->module~module_symba proc~helio_user_getacch helio_user_getacch proc~helio_user_getacch->module~module_helio proc~helio_pl_allocate helio_pl_allocate proc~helio_pl_allocate->module~module_helio proc~helio_tp_allocate helio_tp_allocate proc~helio_tp_allocate->module~module_helio proc~helio_pl_deallocate helio_pl_deallocate proc~helio_pl_deallocate->module~module_helio module~module_symba->module~module_helio proc~symba_merge_tp symba_merge_tp proc~symba_merge_tp->module~module_helio proc~symba_merge_tp->module~module_symba proc~helio_user_getacch_tp helio_user_getacch_tp proc~helio_user_getacch_tp->module~module_helio proc~symba_discard_merge_pl symba_discard_merge_pl proc~symba_discard_merge_pl->module~module_helio proc~symba_discard_merge_pl->module~module_symba proc~symba_helio_getacch_int symba_helio_getacch_int proc~symba_helio_getacch_int->module~module_helio proc~symba_helio_getacch_int->module~module_symba proc~helio_tp_deallocate helio_tp_deallocate proc~helio_tp_deallocate->module~module_helio proc~helio_getacch_int helio_getacch_int proc~helio_getacch_int->module~module_helio proc~symba_tp_deallocate symba_tp_deallocate proc~symba_tp_deallocate->module~module_symba proc~symba_merger_deallocate symba_merger_deallocate proc~symba_merger_deallocate->module~module_symba proc~symba_pl_allocate symba_pl_allocate proc~symba_pl_allocate->module~module_symba proc~symba_pltpenc_allocate symba_pltpenc_allocate proc~symba_pltpenc_allocate->module~module_symba module~io->module~module_symba proc~symba_pl_deallocate symba_pl_deallocate proc~symba_pl_deallocate->module~module_symba proc~symba_user_getacch_tp symba_user_getacch_tp proc~symba_user_getacch_tp->module~module_symba proc~symba_tp_allocate symba_tp_allocate proc~symba_tp_allocate->module~module_symba proc~symba_merger_allocate symba_merger_allocate proc~symba_merger_allocate->module~module_symba proc~symba_plplenc_allocate symba_plplenc_allocate proc~symba_plplenc_allocate->module~module_symba proc~symba_plplenc_deallocate symba_plplenc_deallocate proc~symba_plplenc_deallocate->module~module_symba proc~symba_pltpenc_deallocate symba_pltpenc_deallocate proc~symba_pltpenc_deallocate->module~module_symba proc~io_read_pl_in io_read_pl_in proc~io_read_pl_in->module~module_symba proc~symba_user_getacch symba_user_getacch proc~symba_user_getacch->module~module_symba module~s_io_read_pl_in s_io_read_pl_in module~s_io_read_pl_in->module~io module~s_io_get_token s_io_get_token module~s_io_get_token->module~io program~tool_encounter_read tool_encounter_read program~tool_encounter_read->module~io module~s_io_read_param_in s_io_read_param_in module~s_io_read_param_in->module~io Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types swiftest_pl swiftest_tp Derived Types type, public :: swiftest_pl Components Type Visibility Attributes Name Initial integer(kind=I4B), public, dimension(:), allocatable :: name integer(kind=I4B), public, dimension(:), allocatable :: status real(kind=DP), public, dimension(:), allocatable :: mass real(kind=DP), public, dimension(:), allocatable :: radius real(kind=DP), public, dimension(:), allocatable :: rhill real(kind=DP), public, dimension(:,:), allocatable :: xh real(kind=DP), public, dimension(:,:), allocatable :: vh real(kind=DP), public, dimension(:,:), allocatable :: xb real(kind=DP), public, dimension(:,:), allocatable :: vb type, public :: swiftest_tp Components Type Visibility Attributes Name Initial integer(kind=I4B), public, dimension(:), allocatable :: name integer(kind=I4B), public, dimension(:), allocatable :: status integer(kind=I4B), public, dimension(:), allocatable :: isperi real(kind=DP), public, dimension(:), allocatable :: peri real(kind=DP), public, dimension(:), allocatable :: atp real(kind=DP), public, dimension(:,:), allocatable :: xh real(kind=DP), public, dimension(:,:), allocatable :: vh real(kind=DP), public, dimension(:,:), allocatable :: xb real(kind=DP), public, dimension(:,:), allocatable :: vb","tags":"","loc":"module/module_swiftest.html"},{"title":"module_swiftestalloc – swiftest","text":"Uses swiftest module~~module_swiftestalloc~~UsesGraph module~module_swiftestalloc module_swiftestalloc module~swiftest swiftest module~module_swiftestalloc->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~module_swiftestalloc~~UsedByGraph module~module_swiftestalloc module_swiftestalloc proc~util_resize_pl util_resize_pl proc~util_resize_pl->module~module_swiftestalloc program~swiftest_symba swiftest_symba program~swiftest_symba->module~module_swiftestalloc proc~symba_rearray symba_rearray proc~symba_rearray->module~module_swiftestalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines swiftest_pl_allocate helio_pl_allocate symba_pl_allocate symba_plplenc_allocate symba_merger_allocate swiftest_tp_allocate helio_tp_allocate symba_tp_allocate symba_pltpenc_allocate swiftest_pl_deallocate helio_pl_deallocate symba_pl_deallocate symba_plplenc_deallocate symba_merger_deallocate swiftest_tp_deallocate helio_tp_deallocate symba_tp_deallocate symba_pltpenc_deallocate Subroutines public subroutine swiftest_pl_allocate (swiftest_plA, npl) Arguments Type Intent Optional Attributes Name type( swiftest_pl ), intent(inout) :: swiftest_plA integer(kind=I4B), intent(in) :: npl public subroutine helio_pl_allocate (helio_plA, npl) Arguments Type Intent Optional Attributes Name type( helio_pl ), intent(inout) :: helio_plA integer(kind=I4B), intent(in) :: npl public subroutine symba_pl_allocate (symba_plA, npl) Arguments Type Intent Optional Attributes Name type( symba_pl ), intent(inout) :: symba_plA integer(kind=I4B), intent(in) :: npl public subroutine symba_plplenc_allocate (plplenc_list, nplplenc) Arguments Type Intent Optional Attributes Name type( symba_plplenc ), intent(inout) :: plplenc_list integer(kind=I4B), intent(in) :: nplplenc public subroutine symba_merger_allocate (mergeadd_list, nmergeadd) Arguments Type Intent Optional Attributes Name type( symba_merger ), intent(inout) :: mergeadd_list integer(kind=I4B), intent(in) :: nmergeadd public subroutine swiftest_tp_allocate (swiftest_tpA, ntp) Arguments Type Intent Optional Attributes Name type( swiftest_tp ), intent(inout) :: swiftest_tpA integer(kind=I4B), intent(in) :: ntp public subroutine helio_tp_allocate (helio_tpA, ntp) Arguments Type Intent Optional Attributes Name type( helio_tp ), intent(inout) :: helio_tpA integer(kind=I4B), intent(in) :: ntp public subroutine symba_tp_allocate (symba_tpA, ntp) Arguments Type Intent Optional Attributes Name type( symba_tp ), intent(inout) :: symba_tpA integer(kind=I4B), intent(in) :: ntp public subroutine symba_pltpenc_allocate (pltpenc_list, npltpenc) Arguments Type Intent Optional Attributes Name type( symba_pltpenc ), intent(inout) :: pltpenc_list integer(kind=I4B), intent(in) :: npltpenc public subroutine swiftest_pl_deallocate (swiftest_plA) Arguments Type Intent Optional Attributes Name type( swiftest_pl ), intent(inout) :: swiftest_plA public subroutine helio_pl_deallocate (helio_plA) Arguments Type Intent Optional Attributes Name type( helio_pl ), intent(inout) :: helio_plA public subroutine symba_pl_deallocate (symba_plA) Arguments Type Intent Optional Attributes Name type( symba_pl ), intent(inout) :: symba_plA public subroutine symba_plplenc_deallocate (plplenc_list) Arguments Type Intent Optional Attributes Name type( symba_plplenc ), intent(inout) :: plplenc_list public subroutine symba_merger_deallocate (mergeadd_list) Arguments Type Intent Optional Attributes Name type( symba_merger ), intent(inout) :: mergeadd_list public subroutine swiftest_tp_deallocate (swiftest_tpA) Arguments Type Intent Optional Attributes Name type( swiftest_tp ), intent(inout) :: swiftest_tpA public subroutine helio_tp_deallocate (helio_tpA) Arguments Type Intent Optional Attributes Name type( helio_tp ), intent(inout) :: helio_tpA public subroutine symba_tp_deallocate (symba_tpA) Arguments Type Intent Optional Attributes Name type( symba_tp ), intent(inout) :: symba_tpA public subroutine symba_pltpenc_deallocate (pltpenc_list) Arguments Type Intent Optional Attributes Name type( symba_pltpenc ), intent(inout) :: pltpenc_list","tags":"","loc":"module/module_swiftestalloc.html"},{"title":"swiftest – swiftest","text":"Basic parameters, definitions, and global type definitions used throughout the Swiftest project\n Adapted from Swifter module_parameters and module_swifter\n Original author David E. Kaufmann\nList of parameters that are input by the user in the param.in file Contents Variables I4B I2B I1B SP DP LGT PIBY2 PI PI3BY2 TWOPI DEGRAD LOWERCASE_BEGIN LOWERCASE_END UPPERCASE_OFFSET VERSION_NUMBER STRMAX REAL4_TYPE REAL8_TYPE XDR4_TYPE XDR8_TYPE EL XV FILT nthreads NTHERSHOLD SUCCESS FAILURE ELLIPSE PARABOLA HYPERBOLA ACTIVE INACTIVE DISCARDED_RMAX DISCARDED_RMIN DISCARDED_RMAXU DISCARDED_PERI DISCARDED_PLR DISCARDED_PLQ DISCARDED_DRIFTERR MERGED DISRUPTION SUPERCATASTROPHIC GRAZE_AND_MERGE HIT_AND_RUN COLLRESOLVE_REGIME_MERGE COLLRESOLVE_REGIME_DISRUPTION COLLRESOLVE_REGIME_SUPERCATASTROPHIC COLLRESOLVE_REGIME_GRAZE_AND_MERGE COLLRESOLVE_REGIME_HIT_AND_RUN ADD SUB DISCARD_FILE DUMP_PARAM_FILE DUMP_PL_FILE DUMP_TP_FILE ENERGY_FILE pl_outfile tp_outfile E2MAX DM2MAX E2DM2MAX DANBYB NLAG1 NLAG2 NDIM NDIM2 LOOPMAX TINY MU2GM TU2S DU2CM GC ldiscard ldiscard_tp Derived Types feature_list input_parameters Variables Type Visibility Attributes Name Initial integer, public, parameter :: I4B = SELECTED_INT_KIND(9) Symbolic name for kind types of 4-byte integers integer, public, parameter :: I2B = SELECTED_INT_KIND(4) Symbolic name for kind types of 2-byte integers integer, public, parameter :: I1B = SELECTED_INT_KIND(2) Symbolic name for kind types of 1-byte integers integer, public, parameter :: SP = KIND(1.0) Symbolic name for kind types of single-precision reals integer, public, parameter :: DP = KIND(1.0D0) Symbolic name for kind types of double-precision reals integer, public, parameter :: LGT = KIND(.TRUE.) Symbolic name for kind type of default logical real(kind=DP), public, parameter :: PIBY2 = 1.570796326794896619231321691639751442099_DP Definition of /(\\pi / 2) real(kind=DP), public, parameter :: PI = 3.141592653589793238462643383279502884197_DP Definition of /(\\pi) real(kind=DP), public, parameter :: PI3BY2 = 4.712388980384689857693965074919254326296_DP Definition of /(3 \\pi / 2) real(kind=DP), public, parameter :: TWOPI = 6.283185307179586476925286766559005768394_DP Definition of /(2\\pi) real(kind=DP), public, parameter :: DEGRAD = 180.0_DP/PI Definition of conversion factor from degrees to radians integer(kind=I4B), public, parameter :: LOWERCASE_BEGIN = IACHAR('a') ASCII character set parameter for lower to upper conversion - start of lowercase integer(kind=I4B), public, parameter :: LOWERCASE_END = IACHAR('z') ASCII character set parameter for lower to upper conversion - end of lowercase integer(kind=I4B), public, parameter :: UPPERCASE_OFFSET = IACHAR('A')-IACHAR('a') ASCII character set parameter for lower to upper conversion - offset between upper and lower real(kind=SP), public, parameter :: VERSION_NUMBER = 1.0_SP swiftest version integer(kind=I4B), public, parameter :: STRMAX = 128 Symbolic name for swiftest types\n Maximum size of character strings character(len=*), public, parameter :: REAL4_TYPE = \"REAL4\" Symbolic name for binary output file type real4 character(len=*), public, parameter :: REAL8_TYPE = \"REAL8\" Symbolic name for binary output file type real8 character(len=*), public, parameter :: XDR4_TYPE = \"XDR4\" Symbolic name for binary output file type XDR4 character(len=*), public, parameter :: XDR8_TYPE = \"XDR8\" Symbolic name for binary output file type XDR8 integer(kind=I4B), public, parameter :: EL = 1 Symbolic name for binary output file contents for orbital element type integer(kind=I4B), public, parameter :: XV = 2 Symbolic name for binary output file contents for cartesian position and velocity type integer(kind=I4B), public, parameter :: FILT = 3 Symbolic name for binary output file contents for filtered type integer(kind=I4B), public, save :: nthreads = 1 Number of OpenMP threads integer(kind=I4B), public, parameter :: NTHERSHOLD = 1000 Threshold value for OpenMP loop parallelization integer(kind=I4B), public, parameter :: SUCCESS = 0 Symbolic name for function return/flag code for success integer(kind=I4B), public, parameter :: FAILURE = -1 Symbolic name for function return/flag code for failure integer(kind=I4B), public, parameter :: ELLIPSE = -1 Symbolic names for orbit types - ellipse integer(kind=I4B), public, parameter :: PARABOLA = 0 Symbolic names for orbit types - parabola integer(kind=I4B), public, parameter :: HYPERBOLA = 1 Symbolic names for orbit types - hyperbola integer(kind=I4B), public, parameter :: ACTIVE = 0 Symbolic names for body/particle status codes: integer(kind=I4B), public, parameter :: INACTIVE = 1 integer(kind=I4B), public, parameter :: DISCARDED_RMAX = -1 integer(kind=I4B), public, parameter :: DISCARDED_RMIN = -2 integer(kind=I4B), public, parameter :: DISCARDED_RMAXU = -3 integer(kind=I4B), public, parameter :: DISCARDED_PERI = -4 integer(kind=I4B), public, parameter :: DISCARDED_PLR = -5 integer(kind=I4B), public, parameter :: DISCARDED_PLQ = -6 integer(kind=I4B), public, parameter :: DISCARDED_DRIFTERR = -7 integer(kind=I4B), public, parameter :: MERGED = -8 integer(kind=I4B), public, parameter :: DISRUPTION = -9 integer(kind=I4B), public, parameter :: SUPERCATASTROPHIC = -10 integer(kind=I4B), public, parameter :: GRAZE_AND_MERGE = -11 integer(kind=I4B), public, parameter :: HIT_AND_RUN = -12 integer(kind=I4B), public, parameter :: COLLRESOLVE_REGIME_MERGE = 1 Symbolic names for collisional outcomes from collresolve_resolve: integer(kind=I4B), public, parameter :: COLLRESOLVE_REGIME_DISRUPTION = 2 integer(kind=I4B), public, parameter :: COLLRESOLVE_REGIME_SUPERCATASTROPHIC = 3 integer(kind=I4B), public, parameter :: COLLRESOLVE_REGIME_GRAZE_AND_MERGE = 4 integer(kind=I4B), public, parameter :: COLLRESOLVE_REGIME_HIT_AND_RUN = 5 character(len=*), public, parameter :: ADD = \"+1\" String labels for body/particle addition/subtraction in discard file character(len=*), public, parameter :: SUB = \"-1\" character(len=*), public, parameter :: DISCARD_FILE = \"discard.out\" Standard file names character(len=*), public, parameter, dimension(2) :: DUMP_PARAM_FILE = (/\"dump_param1.dat\", \"dump_param2.dat\"/) character(len=*), public, parameter, dimension(2) :: DUMP_PL_FILE = (/\"dump_pl1.bin\", \"dump_pl2.bin\"/) character(len=*), public, parameter, dimension(2) :: DUMP_TP_FILE = (/\"dump_tp1.bin\", \"dump_tp2.bin\"/) character(len=*), public, parameter :: ENERGY_FILE = \"energy.out\" character(len=*), public, parameter :: pl_outfile = \"pl_out.dat\" character(len=*), public, parameter :: tp_outfile = \"tp_out.dat\" real(kind=DP), public, parameter :: E2MAX = 0.36_DP Integration control parameters: real(kind=DP), public, parameter :: DM2MAX = 0.16_DP real(kind=DP), public, parameter :: E2DM2MAX = 0.0016_DP real(kind=DP), public, parameter :: DANBYB = 1.0E-13_DP integer(kind=I2B), public, parameter :: NLAG1 = 50 integer(kind=I2B), public, parameter :: NLAG2 = 400 integer(kind=I4B), public, parameter :: NDIM = 3 Miscellaneous constants:\n Number of dimensions in our reality integer(kind=I4B), public, parameter :: NDIM2 = 2*NDIM 2x the number of dimensions integer(kind=I4B), public, parameter :: LOOPMAX = 2147483647 Maximum loop limit /(2&#94;{31} - 1) real(kind=DP), public, parameter :: TINY = 4.0E-15_DP real(kind=DP), public :: MU2GM = -1.0_DP Converts mass units to grams real(kind=DP), public :: TU2S = -1.0_DP Converts time units to seconds real(kind=DP), public :: DU2CM = -1.0_DP Converts distance unit to centimeters real(kind=DP), public, parameter :: GC = 6.6743E-8_DP Universal gravitational constant in cgs units (from NIST in 2019) logical, public, save :: ldiscard = .false. Added by Carlisle Wishard and Jennifer Pouplin \n If true, then proceed to discard spilled pl and complete discard.out file. logical, public, save :: ldiscard_tp = .false. If true, then proceed to discard spilled tp Derived Types type, public :: feature_list Logical flags to turn on or off various features of the code Components Type Visibility Attributes Name Initial logical, public :: lextra_force = .false. User defined force function turned on logical, public :: lbig_discard = .false. Save big bodies on every discard logical, public :: lrhill_present = .false. Hill's radius is in input file logical, public :: lclose = .false. Turn on close encounters logical, public :: lfragmentation = .false. Do fragmentation modeling instead of simple merger. logical, public :: lpython = .false. Output binary data in Python-friendly format logical, public :: lenergy = .false. Track the total energy of the system logical, public :: lrotation = .false. Include rotation states of big bodies logical, public :: ltides = .false. Include tidal dissipation logical, public :: lringmoons = .false. Turn on the ringmoons code logical, public :: lpredprey = .false. Turn on the predator/prey model for seed growth in ringmoons (experimental) logical, public :: lgr = .false. Turn on GR logical, public :: lyarkosvsky = .false. Turn on Yarkovsky effect logical, public :: lyorp = .false. Turn on YORP effect type, public :: input_parameters User defined input parameters that are read in from param.in Components Type Visibility Attributes Name Initial type( feature_list ), public :: feature collection of logical flags for various features integer(kind=I4B), public :: nplmax = -1 maximum allowed number of planets integer(kind=I4B), public :: ntpmax = -1 maximum allowed number of test particles real(kind=DP), public :: t0 = 0.0_DP integration start time real(kind=DP), public :: tstop = 0.0_DP integration stop time real(kind=DP), public :: dt = 0.0_DP time step character(len=STRMAX), public :: inplfile = '' name of input file for planets character(len=STRMAX), public :: intpfile = '' name of input file for test particles character(len=STRMAX), public :: in_type = 'ASCII' format of input data files integer(kind=I4B), public :: istep_out = -1 number of time steps between binary outputs character(len=STRMAX), public :: outfile = '' name of output binary file character(len=STRMAX), public :: out_type = XDR4_TYPE binary format of output file character(len=STRMAX), public :: out_form = 'XV' data to write to output file character(len=STRMAX), public :: out_stat = 'NEW' open status for output binary file integer(kind=I4B), public :: istep_dump = -1 number of time steps between dumps real(kind=DP), public :: j2rp2 = 0.0_DP J2 * R**2 for the Sun real(kind=DP), public :: j4rp4 = 0.0_DP J4 * R**4 for the Sun real(kind=DP), public :: rmin = -1.0_DP minimum heliocentric radius for test particle real(kind=DP), public :: rmax = -1.0_DP maximum heliocentric radius for test particle real(kind=DP), public :: rmaxu = -1.0_DP maximum unbound heliocentric radius for test particle real(kind=DP), public :: qmin = -1.0_DP minimum pericenter distance for test particle character(len=STRMAX), public :: qmin_coord = 'HELIO' coordinate frame to use for qmin real(kind=DP), public :: qmin_alo = -1.0_DP minimum semimajor axis for qmin real(kind=DP), public :: qmin_ahi = -1.0_DP maximum semimajor axis for qmin character(len=STRMAX), public :: encounter_file = '' name of output file for encounters real(kind=DP), public :: mtiny = 0.0_DP smallest mass that is fully gravitating character(len=STRMAX), public :: ring_outfile = '' name of output file in ring moons real(kind=DP), public :: MU2GM = -1.0_DP Converts mass units to grams real(kind=DP), public :: TU2S = -1.0_DP Converts time units to seconds real(kind=DP), public :: DU2CM = -1.0_DP Converts distance unit to centimeters","tags":"","loc":"module/swiftest.html"},{"title":"module_fxdr – swiftest","text":"Used by module~~module_fxdr~~UsedByGraph module~module_fxdr module_fxdr proc~io_getn io_getn proc~io_getn->module~module_fxdr proc~io_dump_pl io_dump_pl proc~io_dump_pl->module~module_fxdr proc~io_write_frame io_write_frame proc~io_write_frame->module~module_fxdr proc~io_read_encounter io_read_encounter proc~io_read_encounter->module~module_fxdr proc~io_init_pl io_init_pl proc~io_init_pl->module~module_fxdr proc~io_read_hdr io_read_hdr proc~io_read_hdr->module~module_fxdr proc~io_read_line io_read_line proc~io_read_line->module~module_fxdr proc~io_init_tp io_init_tp proc~io_init_tp->module~module_fxdr proc~io_open_fxdr io_open_fxdr proc~io_open_fxdr->module~module_fxdr proc~io_write_line io_write_line proc~io_write_line->module~module_fxdr proc~io_write_hdr io_write_hdr proc~io_write_hdr->module~module_fxdr proc~io_write_encounter io_write_encounter proc~io_write_encounter->module~module_fxdr proc~io_dump_tp io_dump_tp proc~io_dump_tp->module~module_fxdr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces initxdr ixdrclose ixdrdmat ixdrdouble ixdrimat ixdrint ixdrreal ixdrrmat Interfaces interface public function initxdr(filename, mode, returnonerror) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=1), intent(in) :: mode logical, intent(in) :: returnonerror Return Value integer interface public function ixdrclose(ixdr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ixdr Return Value integer interface public function ixdrdmat(ixdrs, nels, dval) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ixdrs integer, intent(in) :: nels double precision, intent(in), DIMENSION(nels) :: dval Return Value integer interface public function ixdrdouble(ixdrs, dval) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ixdrs double precision, intent(in) :: dval Return Value integer interface public function ixdrimat(ixdrs, nels, ival) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ixdrs integer, intent(in) :: nels integer, intent(in), DIMENSION(nels) :: ival Return Value integer interface public function ixdrint(ixdrs, ival) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ixdrs integer, intent(in) :: ival Return Value integer interface public function ixdrreal(ixdrs, rval) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ixdrs real, intent(in) :: rval Return Value integer interface public function ixdrrmat(ixdrs, nels, rval) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ixdrs integer, intent(in) :: nels real, intent(in), DIMENSION(nels) :: rval Return Value integer","tags":"","loc":"module/module_fxdr.html"},{"title":"module_nrutil – swiftest","text":"Uses swiftest module~~module_nrutil~~UsesGraph module~module_nrutil module_nrutil module~swiftest swiftest module~module_nrutil->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~module_nrutil~~UsedByGraph module~module_nrutil module_nrutil proc~util_resize_pl util_resize_pl proc~util_resize_pl->module~module_nrutil proc~util_index util_index proc~util_index->module~module_nrutil Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables NPAR_ARTH NPAR2_ARTH NPAR_CUMSUM Interfaces arth cumsum outerdiff outerprod Functions arth_d arth_i cumsum_i iminloc outerdiff_d outerdiff_i outerprod_d upper_triangle Variables Type Visibility Attributes Name Initial integer(kind=I4B), public, parameter :: NPAR_ARTH = 16 integer(kind=I4B), public, parameter :: NPAR2_ARTH = 8 integer(kind=I4B), public, parameter :: NPAR_CUMSUM = 16 Interfaces public interface arth public function arth_d (first, increment, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: first real(kind=DP), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  DIMENSION(n) public function arth_i (first, increment, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: first integer(kind=I4B), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(n) public interface cumsum public recursive function cumsum_i (arr, seed) result(ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: arr integer(kind=I4B), intent(in), optional :: seed Return Value integer(kind=I4B),\n  DIMENSION(SIZE(arr)) public interface outerdiff public function outerdiff_d (a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: a real(kind=DP), intent(in), DIMENSION(:) :: b Return Value real(kind=DP),\n  DIMENSION(SIZE(a), SIZE(b)) public function outerdiff_i (a, b) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: a integer(kind=I4B), intent(in), DIMENSION(:) :: b Return Value integer(kind=I4B),\n  DIMENSION(SIZE(a), SIZE(b)) public interface outerprod public function outerprod_d (a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: a real(kind=DP), intent(in), DIMENSION(:) :: b Return Value real(kind=DP),\n  DIMENSION(SIZE(a), SIZE(b)) Functions public function arth_d (first, increment, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: first real(kind=DP), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  DIMENSION(n) public function arth_i (first, increment, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: first integer(kind=I4B), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(n) public recursive function cumsum_i (arr, seed) result(ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: arr integer(kind=I4B), intent(in), optional :: seed Return Value integer(kind=I4B),\n  DIMENSION(SIZE(arr)) public function iminloc (arr) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: arr Return Value integer(kind=I4B) public function outerdiff_d (a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: a real(kind=DP), intent(in), DIMENSION(:) :: b Return Value real(kind=DP),\n  DIMENSION(SIZE(a), SIZE(b)) public function outerdiff_i (a, b) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: a integer(kind=I4B), intent(in), DIMENSION(:) :: b Return Value integer(kind=I4B),\n  DIMENSION(SIZE(a), SIZE(b)) public function outerprod_d (a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: a real(kind=DP), intent(in), DIMENSION(:) :: b Return Value real(kind=DP),\n  DIMENSION(SIZE(a), SIZE(b)) public function upper_triangle (j, k, extra) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: j integer(kind=I4B), intent(in) :: k integer(kind=I4B), intent(in), optional :: extra Return Value logical(kind=LGT),\n  DIMENSION(j, k)","tags":"","loc":"module/module_nrutil.html"},{"title":"module_swifter – swiftest","text":"Uses swiftest module~~module_swifter~~UsesGraph module~module_swifter module_swifter module~swiftest swiftest module~module_swifter->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~module_swifter~~UsedByGraph module~module_swifter module_swifter proc~symba_merge_tp symba_merge_tp proc~symba_merge_tp->module~module_swifter proc~symba_discard_merge_pl symba_discard_merge_pl proc~symba_discard_merge_pl->module~module_swifter Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types swifter_ptr_arr swifter_ptr_arr_tp swifter_pl swifter_tp Derived Types type, public :: swifter_ptr_arr Components Type Visibility Attributes Name Initial type( swifter_pl ), public, POINTER :: thisP type, public :: swifter_ptr_arr_tp Components Type Visibility Attributes Name Initial type( swifter_tp ), public, POINTER :: thisP type, public :: swifter_pl Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: id integer(kind=I4B), public :: status real(kind=DP), public :: mass real(kind=DP), public :: radius real(kind=DP), public :: rhill real(kind=DP), public, DIMENSION(NDIM) :: xh real(kind=DP), public, DIMENSION(NDIM) :: vh real(kind=DP), public, DIMENSION(NDIM) :: xb real(kind=DP), public, DIMENSION(NDIM) :: vb type( swifter_pl ), public, POINTER :: prevP type( swifter_pl ), public, POINTER :: nextP type( swifter_ptr_arr ), public, DIMENSION(:), ALLOCATABLE :: swifter_plPA type, public :: swifter_tp Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: id integer(kind=I4B), public :: status integer(kind=I4B), public :: isperi real(kind=DP), public :: peri real(kind=DP), public :: atp real(kind=DP), public, DIMENSION(NDIM) :: xh real(kind=DP), public, DIMENSION(NDIM) :: vh real(kind=DP), public, DIMENSION(NDIM) :: xb real(kind=DP), public, DIMENSION(NDIM) :: vb type( swifter_tp ), public, POINTER :: prevP type( swifter_tp ), public, POINTER :: nextP type( swifter_ptr_arr_tp ), public, DIMENSION(:), ALLOCATABLE :: swifter_tpPA","tags":"","loc":"module/module_swifter.html"},{"title":"module_symba – swiftest","text":"Uses swiftest module_helio module~~module_symba~~UsesGraph module~module_symba module_symba module~module_helio module_helio module~module_symba->module~module_helio module~swiftest swiftest module~module_symba->module~swiftest module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~module_symba~~UsedByGraph module~module_symba module_symba proc~symba_tp_deallocate symba_tp_deallocate proc~symba_tp_deallocate->module~module_symba proc~symba_casehitandrun symba_casehitandrun proc~symba_casehitandrun->module~module_symba proc~symba_merger_deallocate symba_merger_deallocate proc~symba_merger_deallocate->module~module_symba proc~helio_lindrift helio_lindrift proc~helio_lindrift->module~module_symba proc~symba_pl_allocate symba_pl_allocate proc~symba_pl_allocate->module~module_symba proc~symba_getacch_tp symba_getacch_tp proc~symba_getacch_tp->module~module_symba proc~symba_step_interp symba_step_interp proc~symba_step_interp->module~module_symba proc~symba_casemerge symba_casemerge proc~symba_casemerge->module~module_symba proc~symba_rearray symba_rearray proc~symba_rearray->module~module_symba proc~io_discard_write_symba io_discard_write_symba proc~io_discard_write_symba->module~module_symba proc~symba_plplenc_allocate symba_plplenc_allocate proc~symba_plplenc_allocate->module~module_symba proc~symba_caseresolve symba_caseresolve proc~symba_caseresolve->module~module_symba proc~symba_getacch symba_getacch proc~symba_getacch->module~module_symba proc~symba_reorder_pl symba_reorder_pl proc~symba_reorder_pl->module~module_symba proc~symba_step symba_step proc~symba_step->module~module_symba proc~symba_step_helio symba_step_helio proc~symba_step_helio->module~module_symba proc~symba_merge_tp symba_merge_tp proc~symba_merge_tp->module~module_symba proc~symba_pl_deallocate symba_pl_deallocate proc~symba_pl_deallocate->module~module_symba proc~symba_user_getacch_tp symba_user_getacch_tp proc~symba_user_getacch_tp->module~module_symba proc~symba_tp_allocate symba_tp_allocate proc~symba_tp_allocate->module~module_symba proc~symba_discard_tp symba_discard_tp proc~symba_discard_tp->module~module_symba proc~symba_pltpenc_allocate symba_pltpenc_allocate proc~symba_pltpenc_allocate->module~module_symba module~io io module~io->module~module_symba proc~symba_fragmentation symba_fragmentation proc~symba_fragmentation->module~module_symba proc~coord_vh2vb coord_vh2vb proc~coord_vh2vb->module~module_symba proc~symba_step_helio_pl symba_step_helio_pl proc~symba_step_helio_pl->module~module_symba proc~symba_casedisruption symba_casedisruption proc~symba_casedisruption->module~module_symba proc~symba_discard_peri_pl symba_discard_peri_pl proc~symba_discard_peri_pl->module~module_symba proc~python_io_write_frame_pl python_io_write_frame_pl proc~python_io_write_frame_pl->module~module_symba proc~io_read_pl_in io_read_pl_in proc~io_read_pl_in->module~module_symba proc~symba_user_getacch symba_user_getacch proc~symba_user_getacch->module~module_symba proc~symba_discard_pl symba_discard_pl proc~symba_discard_pl->module~module_symba proc~io_init_pl io_init_pl proc~io_init_pl->module~module_symba proc~coord_vb2vh_tp coord_vb2vh_tp proc~coord_vb2vh_tp->module~module_symba proc~symba_discard_merge_pl symba_discard_merge_pl proc~symba_discard_merge_pl->module~module_symba proc~symba_merger_allocate symba_merger_allocate proc~symba_merger_allocate->module~module_symba proc~io_init_tp io_init_tp proc~io_init_tp->module~module_symba proc~symba_casesupercatastrophic symba_casesupercatastrophic proc~symba_casesupercatastrophic->module~module_symba proc~symba_helio_drift symba_helio_drift proc~symba_helio_drift->module~module_symba program~swiftest_symba swiftest_symba program~swiftest_symba->module~module_symba program~swiftest_symba->module~io proc~symba_helio_getacch symba_helio_getacch proc~symba_helio_getacch->module~module_symba proc~symba_chk symba_chk proc~symba_chk->module~module_symba proc~symba_step_recur symba_step_recur proc~symba_step_recur->module~module_symba proc~symba_helio_drift_tp symba_helio_drift_tp proc~symba_helio_drift_tp->module~module_symba proc~util_resize_pl util_resize_pl proc~util_resize_pl->module~module_symba proc~symba_helio_getacch_int symba_helio_getacch_int proc~symba_helio_getacch_int->module~module_symba proc~helio_lindrift_tp helio_lindrift_tp proc~helio_lindrift_tp->module~module_symba proc~symba_merge_pl symba_merge_pl proc~symba_merge_pl->module~module_symba proc~python_io_write_frame_tp python_io_write_frame_tp proc~python_io_write_frame_tp->module~module_symba proc~symba_kick symba_kick proc~symba_kick->module~module_symba proc~symba_plplenc_deallocate symba_plplenc_deallocate proc~symba_plplenc_deallocate->module~module_symba proc~symba_pltpenc_deallocate symba_pltpenc_deallocate proc~symba_pltpenc_deallocate->module~module_symba proc~symba_peri symba_peri proc~symba_peri->module~module_symba module~s_io_read_pl_in s_io_read_pl_in module~s_io_read_pl_in->module~io module~s_io_get_token s_io_get_token module~s_io_get_token->module~io program~tool_encounter_read tool_encounter_read program~tool_encounter_read->module~io module~s_io_read_param_in s_io_read_param_in module~s_io_read_param_in->module~io Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables NENMAX NTENC RHSCALE RSHELL Derived Types symba_pl symba_tp symba_plplenc symba_pltpenc symba_merger Variables Type Visibility Attributes Name Initial integer(kind=I4B), public, parameter :: NENMAX = 32767 integer(kind=I4B), public, parameter :: NTENC = 3 real(kind=DP), public, parameter :: RHSCALE = 6.5_DP real(kind=DP), public, parameter :: RSHELL = 0.48075_DP Derived Types type, public :: symba_pl Components Type Visibility Attributes Name Initial logical(kind=LGT), public, dimension(:), allocatable :: lmerged integer(kind=I4B), public, dimension(:), allocatable :: nplenc integer(kind=I4B), public, dimension(:), allocatable :: ntpenc integer(kind=I4B), public, dimension(:), allocatable :: levelg integer(kind=I4B), public, dimension(:), allocatable :: levelm integer(kind=I4B), public, dimension(:), allocatable :: nchild integer(kind=I4B), public, dimension(:), allocatable :: isperi real(kind=DP), public, dimension(:), allocatable :: peri real(kind=DP), public, dimension(:), allocatable :: atp type( helio_pl ), public :: helio integer(kind=I4B), public, dimension(:), allocatable :: index_parent integer(kind=I4B), public, dimension(:,:), allocatable :: index_child type, public :: symba_tp Components Type Visibility Attributes Name Initial integer(kind=I4B), public, dimension(:), allocatable :: nplenc integer(kind=I4B), public, dimension(:), allocatable :: levelg integer(kind=I4B), public, dimension(:), allocatable :: levelm type( helio_tp ), public :: helio type, public :: symba_plplenc Components Type Visibility Attributes Name Initial logical(kind=LGT), public, dimension(:), allocatable :: lvdotr integer(kind=I4B), public, dimension(:), allocatable :: status integer(kind=I4B), public, dimension(:), allocatable :: level integer(kind=I4B), public, dimension(:), allocatable :: index1 integer(kind=I4B), public, dimension(:), allocatable :: index2 integer(kind=I4B), public, dimension(:), allocatable :: enc_child integer(kind=I4B), public, dimension(:), allocatable :: enc_parent type, public :: symba_pltpenc Components Type Visibility Attributes Name Initial logical(kind=LGT), public, dimension(:), allocatable :: lvdotr integer(kind=I4B), public, dimension(:), allocatable :: status integer(kind=I4B), public, dimension(:), allocatable :: level integer(kind=I4B), public, dimension(:), allocatable :: indexpl integer(kind=I4B), public, dimension(:), allocatable :: indextp type, public :: symba_merger Components Type Visibility Attributes Name Initial integer(kind=I4B), public, dimension(:), allocatable :: name integer(kind=I4B), public, dimension(:), allocatable :: index_ps integer(kind=I4B), public, dimension(:), allocatable :: status integer(kind=I4B), public, dimension(:), allocatable :: ncomp real(kind=DP), public, dimension(:,:), allocatable :: xh real(kind=DP), public, dimension(:,:), allocatable :: vh real(kind=DP), public, dimension(:), allocatable :: mass real(kind=DP), public, dimension(:), allocatable :: radius","tags":"","loc":"module/module_symba.html"},{"title":"module_helio – swiftest","text":"Uses swiftest module_swiftest module~~module_helio~~UsesGraph module~module_helio module_helio module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~swiftest swiftest module~module_helio->module~swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~module_helio~~UsedByGraph module~module_helio module_helio proc~helio_user_getacch helio_user_getacch proc~helio_user_getacch->module~module_helio proc~helio_kickvb_tp helio_kickvb_tp proc~helio_kickvb_tp->module~module_helio proc~symba_casehitandrun symba_casehitandrun proc~symba_casehitandrun->module~module_helio module~module_symba module_symba proc~symba_casehitandrun->module~module_symba proc~symba_getacch_tp symba_getacch_tp proc~symba_getacch_tp->module~module_helio proc~symba_getacch_tp->module~module_symba proc~symba_step_interp symba_step_interp proc~symba_step_interp->module~module_helio proc~symba_step_interp->module~module_symba proc~symba_casemerge symba_casemerge proc~symba_casemerge->module~module_helio proc~symba_casemerge->module~module_symba proc~helio_kickvb helio_kickvb proc~helio_kickvb->module~module_helio proc~symba_rearray symba_rearray proc~symba_rearray->module~module_helio proc~symba_rearray->module~module_symba proc~symba_caseresolve symba_caseresolve proc~symba_caseresolve->module~module_helio proc~symba_caseresolve->module~module_symba proc~helio_getacch_int helio_getacch_int proc~helio_getacch_int->module~module_helio proc~symba_getacch symba_getacch proc~symba_getacch->module~module_helio proc~symba_getacch->module~module_symba proc~helio_step_pl helio_step_pl proc~helio_step_pl->module~module_helio proc~symba_reorder_pl symba_reorder_pl proc~symba_reorder_pl->module~module_helio proc~symba_reorder_pl->module~module_symba proc~helio_pl_deallocate helio_pl_deallocate proc~helio_pl_deallocate->module~module_helio proc~symba_step symba_step proc~symba_step->module~module_helio proc~symba_step->module~module_symba proc~symba_step_helio symba_step_helio proc~symba_step_helio->module~module_helio proc~symba_step_helio->module~module_symba proc~symba_merge_tp symba_merge_tp proc~symba_merge_tp->module~module_helio proc~symba_merge_tp->module~module_symba proc~symba_discard_tp symba_discard_tp proc~symba_discard_tp->module~module_helio proc~symba_discard_tp->module~module_symba proc~symba_fragmentation symba_fragmentation proc~symba_fragmentation->module~module_helio proc~symba_fragmentation->module~module_symba proc~symba_step_helio_pl symba_step_helio_pl proc~symba_step_helio_pl->module~module_helio proc~symba_step_helio_pl->module~module_symba proc~symba_casedisruption symba_casedisruption proc~symba_casedisruption->module~module_helio proc~symba_casedisruption->module~module_symba proc~symba_discard_peri_pl symba_discard_peri_pl proc~symba_discard_peri_pl->module~module_helio proc~symba_discard_peri_pl->module~module_symba proc~python_io_write_frame_pl python_io_write_frame_pl proc~python_io_write_frame_pl->module~module_helio proc~python_io_write_frame_pl->module~module_symba proc~symba_discard_pl symba_discard_pl proc~symba_discard_pl->module~module_helio proc~symba_discard_pl->module~module_symba proc~helio_step_tp helio_step_tp proc~helio_step_tp->module~module_helio module~module_symba->module~module_helio proc~io_init_pl io_init_pl proc~io_init_pl->module~module_helio proc~io_init_pl->module~module_symba proc~helio_getacch_int_tp helio_getacch_int_tp proc~helio_getacch_int_tp->module~module_helio proc~symba_discard_merge_pl symba_discard_merge_pl proc~symba_discard_merge_pl->module~module_helio proc~symba_discard_merge_pl->module~module_symba proc~io_init_tp io_init_tp proc~io_init_tp->module~module_helio proc~io_init_tp->module~module_symba proc~symba_casesupercatastrophic symba_casesupercatastrophic proc~symba_casesupercatastrophic->module~module_helio proc~symba_casesupercatastrophic->module~module_symba proc~symba_helio_drift symba_helio_drift proc~symba_helio_drift->module~module_helio proc~symba_helio_drift->module~module_symba proc~symba_helio_getacch symba_helio_getacch proc~symba_helio_getacch->module~module_helio proc~symba_helio_getacch->module~module_symba proc~symba_chk symba_chk proc~symba_chk->module~module_helio proc~symba_chk->module~module_symba proc~helio_getacch_tp helio_getacch_tp proc~helio_getacch_tp->module~module_helio proc~helio_pl_allocate helio_pl_allocate proc~helio_pl_allocate->module~module_helio proc~helio_getacch helio_getacch proc~helio_getacch->module~module_helio proc~helio_tp_allocate helio_tp_allocate proc~helio_tp_allocate->module~module_helio proc~symba_step_recur symba_step_recur proc~symba_step_recur->module~module_helio proc~symba_step_recur->module~module_symba proc~symba_helio_drift_tp symba_helio_drift_tp proc~symba_helio_drift_tp->module~module_helio proc~symba_helio_drift_tp->module~module_symba proc~helio_user_getacch_tp helio_user_getacch_tp proc~helio_user_getacch_tp->module~module_helio proc~util_resize_pl util_resize_pl proc~util_resize_pl->module~module_helio proc~util_resize_pl->module~module_symba proc~symba_helio_getacch_int symba_helio_getacch_int proc~symba_helio_getacch_int->module~module_helio proc~symba_helio_getacch_int->module~module_symba proc~helio_tp_deallocate helio_tp_deallocate proc~helio_tp_deallocate->module~module_helio proc~symba_merge_pl symba_merge_pl proc~symba_merge_pl->module~module_helio proc~symba_merge_pl->module~module_symba proc~python_io_write_frame_tp python_io_write_frame_tp proc~python_io_write_frame_tp->module~module_helio proc~python_io_write_frame_tp->module~module_symba proc~symba_kick symba_kick proc~symba_kick->module~module_helio proc~symba_kick->module~module_symba proc~symba_peri symba_peri proc~symba_peri->module~module_helio proc~symba_peri->module~module_symba proc~symba_tp_deallocate symba_tp_deallocate proc~symba_tp_deallocate->module~module_symba proc~symba_merger_deallocate symba_merger_deallocate proc~symba_merger_deallocate->module~module_symba proc~helio_lindrift helio_lindrift proc~helio_lindrift->module~module_symba proc~symba_pl_allocate symba_pl_allocate proc~symba_pl_allocate->module~module_symba proc~io_discard_write_symba io_discard_write_symba proc~io_discard_write_symba->module~module_symba proc~symba_plplenc_allocate symba_plplenc_allocate proc~symba_plplenc_allocate->module~module_symba proc~symba_pltpenc_allocate symba_pltpenc_allocate proc~symba_pltpenc_allocate->module~module_symba module~io io module~io->module~module_symba proc~symba_pl_deallocate symba_pl_deallocate proc~symba_pl_deallocate->module~module_symba proc~symba_user_getacch_tp symba_user_getacch_tp proc~symba_user_getacch_tp->module~module_symba proc~symba_tp_allocate symba_tp_allocate proc~symba_tp_allocate->module~module_symba proc~coord_vh2vb coord_vh2vb proc~coord_vh2vb->module~module_symba proc~io_read_pl_in io_read_pl_in proc~io_read_pl_in->module~module_symba proc~symba_user_getacch symba_user_getacch proc~symba_user_getacch->module~module_symba proc~coord_vb2vh_tp coord_vb2vh_tp proc~coord_vb2vh_tp->module~module_symba proc~symba_merger_allocate symba_merger_allocate proc~symba_merger_allocate->module~module_symba program~swiftest_symba swiftest_symba program~swiftest_symba->module~module_symba program~swiftest_symba->module~io proc~helio_lindrift_tp helio_lindrift_tp proc~helio_lindrift_tp->module~module_symba proc~symba_plplenc_deallocate symba_plplenc_deallocate proc~symba_plplenc_deallocate->module~module_symba proc~symba_pltpenc_deallocate symba_pltpenc_deallocate proc~symba_pltpenc_deallocate->module~module_symba module~s_io_read_pl_in s_io_read_pl_in module~s_io_read_pl_in->module~io module~s_io_get_token s_io_get_token module~s_io_get_token->module~io program~tool_encounter_read tool_encounter_read program~tool_encounter_read->module~io module~s_io_read_param_in s_io_read_param_in module~s_io_read_param_in->module~io Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types helio_pl helio_tp Derived Types type, public :: helio_pl Components Type Visibility Attributes Name Initial real(kind=DP), public, dimension(:,:), allocatable :: ah real(kind=DP), public, dimension(:,:), allocatable :: ahi type( swiftest_pl ), public :: swiftest type, public :: helio_tp Components Type Visibility Attributes Name Initial real(kind=DP), public, dimension(:,:), allocatable :: ah real(kind=DP), public, dimension(:,:), allocatable :: ahi type( swiftest_tp ), public :: swiftest","tags":"","loc":"module/module_helio.html"},{"title":"io – swiftest","text":"Module containing all input/output subroutine interface blocks \n The following use statements are temporary until Swiftest module structure conversion is complete Uses swiftest module_interfaces module_symba module~~io~~UsesGraph module~io io module~module_symba module_symba module~io->module~module_symba module~swiftest swiftest module~io->module~swiftest module~module_interfaces module_interfaces module~io->module~module_interfaces module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: s_io_get_token s_io_read_param_in s_io_read_pl_in module~~io~~UsedByGraph module~io io module~s_io_get_token s_io_get_token module~s_io_get_token->module~io program~swiftest_symba swiftest_symba program~swiftest_symba->module~io module~s_io_read_pl_in s_io_read_pl_in module~s_io_read_pl_in->module~io program~tool_encounter_read tool_encounter_read program~tool_encounter_read->module~io module~s_io_read_param_in s_io_read_param_in module~s_io_read_param_in->module~io Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces io_get_token io_read_param_in io_read_pl_in Interfaces interface public module function io_get_token(buffer, ilength, ifirst, ilast, ierr) result(token) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: buffer Input string buffer integer(kind=I4B), intent(in) :: ilength Length of input buffer string integer(kind=I4B), intent(inout) :: ifirst Index of the buffer at which to start the search for a token integer(kind=I4B), intent(out) :: ilast Index of the buffer at the end of the returned token integer(kind=I4B), intent(out) :: ierr Error code Return Value character(len=len(buffer)) Returned token string interface public module function io_read_param_in(inparfile) result(param) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: inparfile Parameter input file name (typically param.in) Return Value type( input_parameters ) Output collection of user-defined parameters interface public module function io_read_pl_in(param, npl, swiftest_plA) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name type( input_parameters ), intent(in) :: param Output collection of user-defined parameters integer(kind=I4B), intent(in) :: npl Number of massive bodies type(swiftest_pl), intent(inout) :: swiftest_plA Swiftest data structure to store massive body initial conditions Return Value integer(kind=I4B) Error code","tags":"","loc":"module/io.html"},{"title":"s_io_read_param_in – swiftest","text":"Uses Ancestors: io module~~s_io_read_param_in~~UsesGraph module~s_io_read_param_in s_io_read_param_in module~io io module~s_io_read_param_in->module~io module~module_symba module_symba module~io->module~module_symba module~swiftest swiftest module~io->module~swiftest module~module_interfaces module_interfaces module~io->module~module_interfaces module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures io_read_param_in Module Procedures module procedure io_read_param_in module function io_read_param_in(inparfile) result(param) Interface → Author The Purdue Swiftest Team -  David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott Read in parameters for the integration Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: inparfile Parameter input file name (typically param.in) Return Value type( input_parameters ) Output collection of user-defined parameters","tags":"","loc":"module/s_io_read_param_in.html"},{"title":"s_io_get_token – swiftest","text":"Uses Ancestors: io module~~s_io_get_token~~UsesGraph module~s_io_get_token s_io_get_token module~io io module~s_io_get_token->module~io module~module_symba module_symba module~io->module~module_symba module~swiftest swiftest module~io->module~swiftest module~module_interfaces module_interfaces module~io->module~module_interfaces module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures io_get_token Module Procedures module procedure io_get_token module function io_get_token(buffer, ilength, ifirst, ilast, ierr) result(token) Interface → Author David A. Minton Retrieves a character token from an input string. Here a token is defined as any set of contiguous non-blank characters not \n beginning with or containing \"!\". If \"!\" is present, any remaining part of the buffer including the \"!\" is ignored Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: buffer Input string buffer integer(kind=I4B), intent(in) :: ilength Length of input buffer string integer(kind=I4B), intent(inout) :: ifirst Index of the buffer at which to start the search for a token integer(kind=I4B), intent(out) :: ilast Index of the buffer at the end of the returned token integer(kind=I4B), intent(out) :: ierr Error code Return Value character(len=len(buffer)) Returned token string","tags":"","loc":"module/s_io_get_token.html"},{"title":"s_io_read_pl_in – swiftest","text":"Uses Ancestors: io module~~s_io_read_pl_in~~UsesGraph module~s_io_read_pl_in s_io_read_pl_in module~io io module~s_io_read_pl_in->module~io module~module_symba module_symba module~io->module~module_symba module~swiftest swiftest module~io->module~swiftest module~module_interfaces module_interfaces module~io->module~module_interfaces module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures io_read_pl_in Module Procedures module procedure io_read_pl_in module function io_read_pl_in(param, npl, swiftest_plA) result(ierr) Interface → Author The Purdue Swiftest Team -  David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott Read in massive body data Read more… Arguments Type Intent Optional Attributes Name type( input_parameters ), intent(in) :: param Output collection of user-defined parameters integer(kind=I4B), intent(in) :: npl Number of massive bodies type(swiftest_pl), intent(inout) :: swiftest_plA Swiftest data structure to store massive body initial conditions Return Value integer(kind=I4B) Error code","tags":"","loc":"module/s_io_read_pl_in.html"},{"title":"swiftest_symba – swiftest","text":"Uses io swiftest module_swiftest module_symba module_interfaces module_swiftestalloc program~~swiftest_symba~~UsesGraph program~swiftest_symba swiftest_symba module~module_symba module_symba program~swiftest_symba->module~module_symba module~io io program~swiftest_symba->module~io module~module_interfaces module_interfaces program~swiftest_symba->module~module_interfaces module~swiftest swiftest program~swiftest_symba->module~swiftest module~module_swiftest module_swiftest program~swiftest_symba->module~module_swiftest module~module_swiftestalloc module_swiftestalloc program~swiftest_symba->module~module_swiftestalloc module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~io->module~module_symba module~io->module~module_interfaces module~io->module~swiftest module~module_swiftest->module~swiftest module~module_swiftestalloc->module~swiftest module~module_helio->module~swiftest module~module_helio->module~module_swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Driver program for the Symplectic Massive Body Algorithm Adapted from Swifter by David E. Kaufmanna swiftert_symba.f90\n Adapted from Hal Levison and Martin Duncan's Swift program swift_symba5.f\n Reference: Duncan, M. J., Levison, H. F. & Lee, M. H. 1998. Astron. J., 116, 2067.\n The following are temporary until the conversion to the new module structure is complete Calls program~~swiftest_symba~~CallsGraph program~swiftest_symba swiftest_symba proc~symba_tp_deallocate symba_tp_deallocate program~swiftest_symba->proc~symba_tp_deallocate interface~io_discard_write_symba io_discard_write_symba program~swiftest_symba->interface~io_discard_write_symba proc~symba_merger_deallocate symba_merger_deallocate program~swiftest_symba->proc~symba_merger_deallocate proc~symba_pl_allocate symba_pl_allocate program~swiftest_symba->proc~symba_pl_allocate interface~symba_energy symba_energy program~swiftest_symba->interface~symba_energy interface~util_exit util_exit program~swiftest_symba->interface~util_exit interface~io_getn io_getn program~swiftest_symba->interface~io_getn interface~symba_discard_pl symba_discard_pl program~swiftest_symba->interface~symba_discard_pl proc~symba_plplenc_allocate symba_plplenc_allocate program~swiftest_symba->proc~symba_plplenc_allocate interface~io_write_frame io_write_frame program~swiftest_symba->interface~io_write_frame proc~symba_pltpenc_allocate symba_pltpenc_allocate program~swiftest_symba->proc~symba_pltpenc_allocate interface~symba_step symba_step program~swiftest_symba->interface~symba_step proc~symba_tp_allocate symba_tp_allocate program~swiftest_symba->proc~symba_tp_allocate proc~symba_pl_deallocate symba_pl_deallocate program~swiftest_symba->proc~symba_pl_deallocate interface~symba_discard_tp symba_discard_tp program~swiftest_symba->interface~symba_discard_tp 7 7 program~swiftest_symba->7 interface~symba_rearray symba_rearray program~swiftest_symba->interface~symba_rearray interface~util_valid util_valid program~swiftest_symba->interface~util_valid proc~symba_merger_allocate symba_merger_allocate program~swiftest_symba->proc~symba_merger_allocate interface~util_version util_version program~swiftest_symba->interface~util_version interface~symba_reorder_pl symba_reorder_pl program~swiftest_symba->interface~symba_reorder_pl interface~python_io_write_frame_pl python_io_write_frame_pl program~swiftest_symba->interface~python_io_write_frame_pl interface~io_dump_param io_dump_param program~swiftest_symba->interface~io_dump_param interface~io_read_param_in io_read_param_in program~swiftest_symba->interface~io_read_param_in interface~io_read_pl_in io_read_pl_in program~swiftest_symba->interface~io_read_pl_in interface~symba_discard_merge_pl symba_discard_merge_pl program~swiftest_symba->interface~symba_discard_merge_pl interface~io_init_tp io_init_tp program~swiftest_symba->interface~io_init_tp interface~io_dump_pl io_dump_pl program~swiftest_symba->interface~io_dump_pl proc~symba_plplenc_deallocate symba_plplenc_deallocate program~swiftest_symba->proc~symba_plplenc_deallocate proc~symba_pltpenc_deallocate symba_pltpenc_deallocate program~swiftest_symba->proc~symba_pltpenc_deallocate proc~helio_pl_allocate helio_pl_allocate proc~symba_pl_allocate->proc~helio_pl_allocate proc~helio_tp_allocate helio_tp_allocate proc~symba_tp_allocate->proc~helio_tp_allocate proc~helio_pl_deallocate helio_pl_deallocate proc~symba_pl_deallocate->proc~helio_pl_deallocate proc~io_read_param_in io_read_param_in interface~io_read_param_in->proc~io_read_param_in proc~io_read_pl_in io_read_pl_in interface~io_read_pl_in->proc~io_read_pl_in proc~swiftest_pl_allocate swiftest_pl_allocate proc~helio_pl_allocate->proc~swiftest_pl_allocate proc~swiftest_tp_allocate swiftest_tp_allocate proc~helio_tp_allocate->proc~swiftest_tp_allocate proc~swiftest_pl_deallocate swiftest_pl_deallocate proc~helio_pl_deallocate->proc~swiftest_pl_deallocate proc~io_read_param_in->interface~util_exit interface~io_get_token io_get_token proc~io_read_param_in->interface~io_get_token interface~util_toupper util_toupper proc~io_read_param_in->interface~util_toupper proc~io_get_token io_get_token interface~io_get_token->proc~io_get_token Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables param feature nplmax ntpmax istep_out istep_dump t0 tstop dt j2rp2 j4rp4 rmin rmax rmaxu qmin qmin_alo qmin_ahi qmin_coord encounter_file inplfile intpfile in_type outfile out_type out_form out_stat ierr lfirst lfrag_add npl ntp ntp0 nsppl nsptp iout idump iloop nplplenc npltpenc nmergeadd nmergesub fragmax t tfrac tbase mtiny ke pe te eoffset htot inparfile symba_plA symba_tpA discard_tpA discard_plA plplenc_list pltpenc_list mergeadd_list mergesub_list egyiu start finish Variables Type Attributes Name Initial type( input_parameters ) :: param type( feature_list ) :: feature integer(kind=I4B) :: nplmax integer(kind=I4B) :: ntpmax integer(kind=I4B) :: istep_out integer(kind=I4B) :: istep_dump real(kind=DP) :: t0 real(kind=DP) :: tstop real(kind=DP) :: dt real(kind=DP) :: j2rp2 real(kind=DP) :: j4rp4 real(kind=DP) :: rmin real(kind=DP) :: rmax real(kind=DP) :: rmaxu real(kind=DP) :: qmin real(kind=DP) :: qmin_alo real(kind=DP) :: qmin_ahi character(len=strmax) :: qmin_coord character(len=strmax) :: encounter_file character(len=strmax) :: inplfile character(len=strmax) :: intpfile character(len=strmax) :: in_type character(len=strmax) :: outfile character(len=strmax) :: out_type character(len=strmax) :: out_form character(len=strmax) :: out_stat integer(kind=I4B) :: ierr Error code logical :: lfirst logical :: lfrag_add integer(kind=I4B) :: npl integer(kind=I4B) :: ntp integer(kind=I4B) :: ntp0 integer(kind=I4B) :: nsppl integer(kind=I4B) :: nsptp integer(kind=I4B) :: iout integer(kind=I4B) :: idump integer(kind=I4B) :: iloop integer(kind=I4B) :: nplplenc integer(kind=I4B) :: npltpenc integer(kind=I4B) :: nmergeadd integer(kind=I4B) :: nmergesub integer(kind=I4B) :: fragmax real(kind=DP) :: t real(kind=DP) :: tfrac real(kind=DP) :: tbase real(kind=DP) :: mtiny real(kind=DP) :: ke real(kind=DP) :: pe real(kind=DP) :: te real(kind=DP) :: eoffset real(kind=DP), dimension(ndim) :: htot character(len=strmax) :: inparfile type( symba_pl ) :: symba_plA type( symba_tp ) :: symba_tpA type( swiftest_tp ) :: discard_tpA type( swiftest_pl ) :: discard_plA type( symba_plplenc ) :: plplenc_list type( symba_pltpenc ) :: pltpenc_list type( symba_merger ) :: mergeadd_list type( symba_merger ) :: mergesub_list integer(kind=I4B), parameter :: egyiu = 72 real(kind=DP) :: start real(kind=DP) :: finish","tags":"","loc":"program/swiftest_symba.html"},{"title":"tool_encounter_read – swiftest","text":"Uses swiftest module_interfaces io program~~tool_encounter_read~~UsesGraph program~tool_encounter_read tool_encounter_read module~io io program~tool_encounter_read->module~io module~swiftest swiftest program~tool_encounter_read->module~swiftest module~module_interfaces module_interfaces program~tool_encounter_read->module~module_interfaces module~io->module~swiftest module~io->module~module_interfaces module~module_symba module_symba module~io->module~module_symba module~module_symba->module~swiftest module~module_helio module_helio module~module_symba->module~module_helio module~module_helio->module~swiftest module~module_swiftest module_swiftest module~module_helio->module~module_swiftest module~module_swiftest->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~tool_encounter_read~~CallsGraph program~tool_encounter_read tool_encounter_read interface~io_read_param_in io_read_param_in program~tool_encounter_read->interface~io_read_param_in interface~io_read_encounter io_read_encounter program~tool_encounter_read->interface~io_read_encounter interface~util_exit util_exit program~tool_encounter_read->interface~util_exit proc~io_read_param_in io_read_param_in interface~io_read_param_in->proc~io_read_param_in proc~io_read_param_in->interface~util_exit interface~io_get_token io_get_token proc~io_read_param_in->interface~io_get_token interface~util_toupper util_toupper proc~io_read_param_in->interface~util_toupper proc~io_get_token io_get_token interface~io_get_token->proc~io_get_token Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables param feature nplmax ntpmax istep_out istep_dump t0 tstop dt j2rp2 j4rp4 rmin rmax rmaxu qmin qmin_alo qmin_ahi mtiny qmin_coord encounter_file inplfile intpfile in_type outfile out_type out_form out_stat i ierr id1 id2 t mass1 mass2 xh1 xh2 vh1 vh2 inparfile Variables Type Attributes Name Initial type( input_parameters ) :: param type( feature_list ) :: feature integer(kind=I4B) :: nplmax integer(kind=I4B) :: ntpmax integer(kind=I4B) :: istep_out integer(kind=I4B) :: istep_dump real(kind=DP) :: t0 real(kind=DP) :: tstop real(kind=DP) :: dt real(kind=DP) :: j2rp2 real(kind=DP) :: j4rp4 real(kind=DP) :: rmin real(kind=DP) :: rmax real(kind=DP) :: rmaxu real(kind=DP) :: qmin real(kind=DP) :: qmin_alo real(kind=DP) :: qmin_ahi real(kind=DP) :: mtiny character(len=STRMAX) :: qmin_coord character(len=STRMAX) :: encounter_file character(len=STRMAX) :: inplfile character(len=STRMAX) :: intpfile character(len=STRMAX) :: in_type character(len=STRMAX) :: outfile character(len=STRMAX) :: out_type character(len=STRMAX) :: out_form character(len=STRMAX) :: out_stat integer(kind=I4B) :: i integer(kind=I4B) :: ierr integer(kind=I4B) :: id1 integer(kind=I4B) :: id2 real(kind=DP) :: t real(kind=DP) :: mass1 real(kind=DP) :: mass2 real(kind=DP), DIMENSION(NDIM) :: xh1 real(kind=DP), DIMENSION(NDIM) :: xh2 real(kind=DP), DIMENSION(NDIM) :: vh1 real(kind=DP), DIMENSION(NDIM) :: vh2 character(len=STRMAX) :: inparfile","tags":"","loc":"program/tool_encounter_read.html"}]}