var tipuesearch = {"pages":[{"title":" swiftest ","text":"swiftest Developer Info David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott The Purdue University Minton Research Group","tags":"home","loc":"index.html"},{"title":"kick.f90 – swiftest","text":"This file depends on sourcefile~~kick.f90~~EfferentGraph sourcefile~kick.f90 kick.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~kick.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_kick Source Code kick.f90 Source Code submodule ( swiftest_classes ) s_kick use swiftest contains module subroutine kick_getacch_int_pl ( self ) !! author: David A. Minton !! !! Compute direct cross (third) term heliocentric accelerations of massive bodies !! !! Adapted from Hal Levison's Swift routine getacch_ah3.f !! Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah3.f90 and helio_kick_getacch_int.f90 implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object call kick_getacch_int_all_pl ( self % nbody , self % nplpl , self % k_plpl , self % xh , self % Gmass , self % radius , self % ah ) return end subroutine kick_getacch_int_pl module subroutine kick_getacch_int_tp ( self , GMpl , xhp , npl ) !! author: David A. Minton !! !! Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies !! !! Adapted from Hal Levison's Swift routine getacch_ah3_tp.f !! Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah3.f90 and helio_kick_getacch_int_tp.f90 implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object real ( DP ), dimension (:), intent ( in ) :: GMpl !! Massive body masses real ( DP ), dimension (:,:), intent ( in ) :: xhp !! Massive body position vectors integer ( I4B ), intent ( in ) :: npl !! Number of active massive bodies if (( self % nbody == 0 ) . or . ( npl == 0 )) return call kick_getacch_int_all_tp ( self % nbody , npl , self % xh , xhp , GMpl , self % lmask , self % ah ) return end subroutine kick_getacch_int_tp module subroutine kick_getacch_int_all_pl ( npl , nplpl , k_plpl , x , Gmass , radius , acc ) !! author: David A. Minton !! !! Compute direct cross (third) term heliocentric accelerations for massive bodies, with parallelization !! !! Adapted from Hal Levison's Swift routine getacch_ah3.f !! Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah3.f90 and helio_kick_getacch_int.f9 implicit none integer ( I4B ), intent ( in ) :: npl !! Number of massive bodies integer ( I8B ), intent ( in ) :: nplpl !! Number of massive body interactions to compute integer ( I4B ), dimension (:,:), intent ( in ) :: k_plpl !! Array of interaction pair indices (flattened upper triangular matrix) real ( DP ), dimension (:,:), intent ( in ) :: x !! Position vector array real ( DP ), dimension (:), intent ( in ) :: Gmass !! Array of massive body G*mass real ( DP ), dimension (:), intent ( in ) :: radius !! Array of massive body radii real ( DP ), dimension (:,:), intent ( inout ) :: acc !! Acceleration vector array ! Internals integer ( I8B ) :: k real ( DP ), dimension ( NDIM , npl ) :: ahi , ahj integer ( I4B ) :: i , j real ( DP ) :: rji2 , rlim2 real ( DP ) :: xr , yr , zr ahi (:,:) = 0.0_DP ahj (:,:) = 0.0_DP !$omp parallel do default(private) schedule(static)& !$omp shared(nplpl, k_plpl, x, Gmass, radius) & !$omp lastprivate(rji2, rlim2, xr, yr, zr) & !$omp reduction(+:ahi) & !$omp reduction(-:ahj) do k = 1_I8B , nplpl i = k_plpl ( 1 , k ) j = k_plpl ( 2 , k ) xr = x ( 1 , j ) - x ( 1 , i ) yr = x ( 2 , j ) - x ( 2 , i ) zr = x ( 3 , j ) - x ( 3 , i ) rji2 = xr ** 2 + yr ** 2 + zr ** 2 rlim2 = ( radius ( i ) + radius ( j )) ** 2 if ( rji2 > rlim2 ) call kick_getacch_int_one_pl ( rji2 , xr , yr , zr , Gmass ( i ), Gmass ( j ), ahi ( 1 , i ), ahi ( 2 , i ), ahi ( 3 , i ), ahj ( 1 , j ), ahj ( 2 , j ), ahj ( 3 , j )) end do !$omp end parallel do do concurrent ( i = 1 : npl ) acc (:, i ) = acc (:, i ) + ahi (:, i ) + ahj (:, i ) end do return end subroutine kick_getacch_int_all_pl module subroutine kick_getacch_int_all_tp ( ntp , npl , xtp , xpl , GMpl , lmask , acc ) !! author: David A. Minton !! !! Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies with parallelisim !! !! Adapted from Hal Levison's Swift routine getacch_ah3_tp.f !! Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah3.f90 and helio_kick_getacch_int_tp.f99 implicit none integer ( I4B ), intent ( in ) :: ntp !! Number of test particles integer ( I4B ), intent ( in ) :: npl !! Number of massive bodies real ( DP ), dimension (:,:), intent ( in ) :: xtp !! Test particle position vector array real ( DP ), dimension (:,:), intent ( in ) :: xpl !! Massive body particle position vector array real ( DP ), dimension (:), intent ( in ) :: GMpl !! Array of massive body G*mass logical , dimension (:), intent ( in ) :: lmask !! Logical mask indicating which test particles should be computed real ( DP ), dimension (:,:), intent ( inout ) :: acc !! Acceleration vector array ! Internals real ( DP ) :: rji2 real ( DP ) :: xr , yr , zr integer ( I4B ) :: i , j !$omp parallel do default(private) schedule(static)& !$omp shared(npl, ntp, lmask, xtp, xpl) & !$omp reduction(-:acc) do i = 1 , ntp if ( lmask ( i )) then do j = 1 , npl xr = xtp ( 1 , i ) - xpl ( 1 , j ) yr = xtp ( 2 , i ) - xpl ( 2 , j ) zr = xtp ( 3 , i ) - xpl ( 3 , j ) rji2 = xr ** 2 + yr ** 2 + zr ** 2 call kick_getacch_int_one_tp ( rji2 , xr , yr , zr , GMpl ( j ), acc ( 1 , i ), acc ( 2 , i ), acc ( 3 , i )) end do end if end do !$omp end parallel do return end subroutine kick_getacch_int_all_tp module pure subroutine kick_getacch_int_one_pl ( rji2 , xr , yr , zr , Gmi , Gmj , axi , ayi , azi , axj , ayj , azj ) !$omp declare simd(kick_getacch_int_one_pl) !! author: David A. Minton !! !! Compute direct cross (third) term heliocentric accelerations for a single pair of massive bodies !! !! Adapted from Hal Levison's Swift routine getacch_ah3.f !! Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah3.f90 and helio_kick_getacch_int.f9 implicit none real ( DP ), intent ( in ) :: rji2 !! Square of distance between the two bodies real ( DP ), intent ( in ) :: xr , yr , zr !! Distances between the two bodies in x, y, and z directions real ( DP ), intent ( in ) :: Gmi !! G*mass of body i real ( DP ), intent ( in ) :: Gmj !! G*mass of body j real ( DP ), intent ( inout ) :: axi , ayi , azi !! Acceleration vector components of body i real ( DP ), intent ( inout ) :: axj , ayj , azj !! Acceleration vector components of body j ! Internals real ( DP ) :: faci , facj , irij3 irij3 = 1.0_DP / ( rji2 * sqrt ( rji2 )) faci = Gmi * irij3 facj = Gmj * irij3 axi = axi + facj * xr ayi = ayi + facj * yr azi = azi + facj * zr axj = axj - faci * xr ayj = ayj - faci * yr azj = azj - faci * zr return end subroutine kick_getacch_int_one_pl module pure subroutine kick_getacch_int_one_tp ( rji2 , xr , yr , zr , GMpl , ax , ay , az ) !$omp declare simd(kick_getacch_int_one_tp) !! author: David A. Minton !! !! Compute direct cross (third) term heliocentric accelerations of a single test particle massive body pair. !! !! Adapted from Hal Levison's Swift routine getacch_ah3_tp.f !! Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah3.f90 and helio_kick_getacch_int_tp.f90 implicit none real ( DP ), intent ( in ) :: rji2 !! Square of distance between the test particle and massive body real ( DP ), intent ( in ) :: xr , yr , zr !! Distances between the two bodies in x, y, and z directions real ( DP ), intent ( in ) :: Gmpl !! G*mass of massive body real ( DP ), intent ( inout ) :: ax , ay , az !! Acceleration vector components of test particle ! Internals real ( DP ) :: fac fac = GMpl * sqrt ( rji2 ** ( - 3 )) ax = ax - fac * xr ay = ay - fac * yr az = az - fac * zr return end subroutine kick_getacch_int_one_tp end submodule s_kick","tags":"","loc":"sourcefile/kick.f90.html"},{"title":"tides_getacch_pl.f90 – swiftest","text":"This file depends on sourcefile~~tides_getacch_pl.f90~~EfferentGraph sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_tides_kick_getacch Source Code tides_getacch_pl.f90 Source Code submodule ( swiftest_classes ) s_tides_kick_getacch use swiftest contains module subroutine tides_kick_getacch_pl ( self , system ) !! author: Jennifer L.L. Pouplin, Carlisle A. wishard, and David A. Minton !! !! Calculated tidal torques from central body to any planet and from any planet to central body !! planet - planet interactions are considered negligable. !! This is a constant time lag model. !! !! Adapted from Mercury-T code from Bolmont et al. (2015) !! !! Reference: !!    Bolmont, E., Raymond, S.N., Leconte, J., Hersant, F., Correia, A.C.M., 2015. !!       Mercury-T : A new code to study tidally evolving multi-planet systems. !!       Applications to Kepler-62. A&A 583, A116. https://doi.org/10.1051/0004-6361/201525909 implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object ! Internals integer ( I4B ) :: i real ( DP ) :: rmag , vmag real ( DP ), dimension ( NDIM ) :: r_unit , v_unit , h_unit , theta_unit , theta_dot , F_T real ( DP ) :: Ftr , Ptopl , Ptocb , r5cbterm , r5plterm associate ( pl => self , npl => self % nbody , cb => system % cb ) pl % atide (:,:) = 0.0_DP cb % atide (:) = 0.0_DP do i = 1 , npl rmag = norm2 ( pl % xh (:, i )) vmag = norm2 ( pl % vh (:, i )) r_unit (:) = pl % xh (:, i ) / rmag v_unit (:) = pl % vh (:, i ) / vmag h_unit (:) = r_unit (:) . cross . v_unit (:) theta_unit (:) = h_unit (:) . cross . r_unit (:) theta_dot = dot_product ( pl % vh (:, i ), theta_unit (:)) ! First calculate the tangential component of the force vector (eq. 5 & 6 of Bolmont et al. 2015) ! The radial component is already computed in the obl_acc methods r5cbterm = pl % Gmass ( i ) ** 2 * cb % k2 * cb % radius ** 5 r5plterm = cb % Gmass ** 2 * pl % k2 ( i ) * pl % radius ( i ) ** 5 Ptopl = 3 * r5plterm * pl % tlag ( i ) / rmag ** 7 Ptocb = 3 * r5cbterm * cb % tlag / rmag ** 7 Ftr = - 3 / rmag ** 7 * ( r5cbterm + r5plterm ) - 3 * vmag / rmag * ( Ptocb + Ptopl ) F_T (:) = ( Ftr + ( Ptocb + Ptopl ) * dot_product ( v_unit , r_unit ) / rmag ) * r_unit (:) & + Ptopl * (( pl % rot (:, i ) - theta_dot (:)) . cross . r_unit (:)) & + Ptocb * (( cb % rot (:) - theta_dot (:)) . cross . r_unit (:)) cb % atide (:) = cb % atide (:) + F_T (:) / cb % Gmass pl % atide (:, i ) = F_T (:) / pl % Gmass ( i ) end do do i = 1 , npl pl % ah (:, i ) = pl % ah (:, i ) + pl % atide (:, i ) + cb % atide (:) end do end associate return end subroutine tides_kick_getacch_pl end submodule s_tides_kick_getacch","tags":"","loc":"sourcefile/tides_getacch_pl.f90.html"},{"title":"tides_spin_step.f90 – swiftest","text":"This file depends on sourcefile~~tides_spin_step.f90~~EfferentGraph sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_tides_step_spin Source Code tides_spin_step.f90 Source Code submodule ( swiftest_classes ) s_tides_step_spin use swiftest type , extends ( lambda_obj_tvar ) :: tides_derivs_func !! Base class for an lambda function object. This object takes no additional arguments other than the dependent variable x, an array of real numbers procedure ( tidederiv ), pointer , nopass :: lambdaptr_tides_deriv real ( DP ), dimension (:,:), allocatable :: xbeg real ( DP ), dimension (:,:), allocatable :: xend real ( DP ) :: dt contains generic :: init => tides_derivs_init procedure :: evalt => tides_derivs_eval procedure , nopass :: tides_derivs_init end type interface lambda_obj module procedure tides_derivs_init end interface abstract interface function tidederiv ( x , t , dt , xbeg , xend ) result ( y ) ! Template for a 0 argument function import DP , swiftest_nbody_system real ( DP ), dimension (:), intent ( in ) :: x real ( DP ), intent ( in ) :: t real ( DP ), intent ( in ) :: dt real ( DP ), dimension (:,:), intent ( in ) :: xbeg real ( DP ), dimension (:,:), intent ( in ) :: xend real ( DP ), dimension (:), allocatable :: y end function end interface contains module subroutine tides_step_spin_system ( self , param , t , dt ) !! author: Jennifer L.L. Pouplin and David A. Minton !! !! Integrates the spin equations for central and massive bodies of the system subjected to tides. implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize ! Internals real ( DP ), dimension (:), allocatable :: rot0 , rot1 real ( DP ) :: subt real ( DP ), parameter :: tol = 1e-6_DP !! Just a guess at the moment real ( DP ) :: subdt associate ( pl => self % pl , npl => self % pl % nbody , cb => self % cb ) allocate ( rot0 ( NDIM * ( npl + 1 ))) rot0 = [ pack ( pl % rot (:, 1 : npl ),. true .), pack ( cb % rot (:),. true .)] ! Use this space call the ode_solver, passing tides_spin_derivs as the function: subdt = dt / 2 0._DP !rot1(:) = util_solve_rkf45(lambda_obj(tides_spin_derivs, subdt, pl%xbeg, pl%xend), rot0, dt, subdt tol) ! Recover with unpack !pl%rot(:,1:npl) = unpack(rot1... !cb%rot(:) = unpack(rot1... end associate return end subroutine tides_step_spin_system function tides_spin_derivs ( rot_pl_cb , t , dt , xbeg , xend ) result ( drot ) !! Need to add more arguments so we can pull in mass, radius, Ip, J2, etc... !! author: Jennifer L.L. Pouplin and David A. Minton !! !! function used to calculate the derivatives that are fed to the ODE solver implicit none ! Arguments real ( DP ), dimension (:,:), intent ( in ) :: rot_pl_cb !! Array of rotations. The last element is the central body, and all others are massive bodies real ( DP ), intent ( in ) :: t !! Current time, which is used to interpolate the massive body positions real ( DP ), intent ( in ) :: dt !! Total step size real ( DP ), dimension (:,:), intent ( in ) :: xbeg real ( DP ), dimension (:,:), intent ( in ) :: xend ! Internals real ( DP ), dimension (:,:), allocatable :: drot real ( DP ), dimension (:), allocatable :: flatrot real ( DP ), dimension ( NDIM ) :: N_Tcb , N_Rcb , N_Tpl , N_Rpl , xinterp real ( DP ) :: C_cb , C_pl , r_dot_rot_cb , r_dot_rot_pl , rmag integer ( I4B ) :: i , n n = size ( rot_pl_cb , 2 ) if ( allocated ( drot )) deallocate ( drot ) allocate ( drot , mold = rot_pl_cb ) drot (:,:) = 0.0_DP do i = 1 , n - 1 xinterp (:) = xbeg (:, i ) + t / dt * ( xend (:, i ) - xbeg (:, i )) ! Calculate Ncb and Npl as a function of xinterp !drot(:,i) = -Mcb / (Mcb + Mpl(i)) * (N_Tpl + N_Rpl) !drot(:,n) = drot(:,n) - Mcb / (Mcb + Mpl(i) * (N_Tcb + N_Rcb) ! end do return end function tides_spin_derivs function tides_derivs_eval ( self , x , t ) result ( y ) implicit none ! Arguments class ( tides_derivs_func ), intent ( inout ) :: self real ( DP ), dimension (:), intent ( in ) :: x real ( DP ), intent ( in ) :: t ! Result real ( DP ), dimension (:), allocatable :: y if ( associated ( self % lambdaptr_tides_deriv )) then y = self % lambdaptr_tides_deriv ( x , t , self % dt , self % xbeg , self % xend ) else error stop \"Lambda function was not initialized\" end if return end function tides_derivs_eval function tides_derivs_init ( lambda , dt , xbeg , xend ) result ( f ) implicit none ! Arguments procedure ( tidederiv ) :: lambda real ( DP ), intent ( in ) :: dt real ( DP ), dimension (:,:), intent ( in ) :: xbeg real ( DP ), dimension (:,:), intent ( in ) :: xend ! Result type ( tides_derivs_func ) :: f f % lambdaptr_tides_deriv => lambda f % dt = dt allocate ( f % xbeg , source = xbeg ) allocate ( f % xend , source = xend ) return end function tides_derivs_init end submodule s_tides_step_spin","tags":"","loc":"sourcefile/tides_spin_step.f90.html"},{"title":"obl.f90 – swiftest","text":"This file depends on sourcefile~~obl.f90~~EfferentGraph sourcefile~obl.f90 obl.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~obl.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_obl Source Code obl.f90 Source Code submodule ( swiftest_classes ) s_obl use swiftest contains module subroutine obl_acc_body ( self , system ) !! author: David A. Minton !! !! Compute the barycentric accelerations of bodies due to the oblateness of the central body !!      Returned values do not include monopole term or terms higher than J4 !! !! Adapted from David E. Kaufmann's Swifter routine: obl_acc.f90 and obl_acc_tp.f90 !! Adapted from Hal Levison's Swift routine obl_acc.f and obl_acc_tp.f implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object ! Internals integer ( I4B ) :: i real ( DP ) :: r2 , irh , rinv2 , t0 , t1 , t2 , t3 , fac1 , fac2 if ( self % nbody == 0 ) return associate ( n => self % nbody , cb => system % cb ) self % aobl (:,:) = 0.0_DP do concurrent ( i = 1 : n , self % lmask ( i )) r2 = dot_product ( self % xh (:, i ), self % xh (:, i )) irh = 1.0_DP / sqrt ( r2 ) rinv2 = irh ** 2 t0 = - cb % Gmass * rinv2 * rinv2 * irh t1 = 1.5_DP * cb % j2rp2 t2 = self % xh ( 3 , i ) * self % xh ( 3 , i ) * rinv2 t3 = 1.875_DP * cb % j4rp4 * rinv2 fac1 = t0 * ( t1 - t3 - ( 5 * t1 - ( 1 4.0_DP - 2 1.0_DP * t2 ) * t3 ) * t2 ) fac2 = 2 * t0 * ( t1 - ( 2.0_DP - ( 1 4.0_DP * t2 / 3.0_DP )) * t3 ) self % aobl (:, i ) = fac1 * self % xh (:, i ) self % aobl ( 3 , i ) = fac2 * self % xh ( 3 , i ) + self % aobl ( 3 , i ) end do end associate return end subroutine obl_acc_body module subroutine obl_acc_pl ( self , system ) !! author: David A. Minton !! !! Compute the barycentric accelerations of massive bodies due to the oblateness of the central body !! !! Adapted from David E. Kaufmann's Swifter routine: obl_acc.f90 and obl_acc_tp.f90 !! Adapted from Hal Levison's Swift routine obl_acc.f and obl_acc_tp.f implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody , cb => system % cb ) call obl_acc_body ( pl , system ) do i = 1 , NDIM cb % aobl ( i ) = - sum ( pl % Gmass ( 1 : npl ) * pl % aobl ( i , 1 : npl ), pl % lmask ( 1 : npl )) / cb % Gmass end do do concurrent ( i = 1 : npl , pl % lmask ( i )) pl % ah (:, i ) = pl % ah (:, i ) + pl % aobl (:, i ) - cb % aobl (:) end do end associate return end subroutine obl_acc_pl module subroutine obl_acc_tp ( self , system ) !! author: David A. Minton !! !! Compute the barycentric accelerations of massive bodies due to the oblateness of the central body !! !! Adapted from David E. Kaufmann's Swifter routine: obl_acc.f90 and obl_acc_tp.f90 !! Adapted from Hal Levison's Swift routine obl_acc.f and obl_acc_tp.f implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object ! Internals real ( DP ), dimension ( NDIM ) :: aoblcb integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody , cb => system % cb ) call obl_acc_body ( tp , system ) if ( system % lbeg ) then aoblcb = cb % aoblbeg else aoblcb = cb % aoblend end if do concurrent ( i = 1 : ntp , tp % lmask ( i )) tp % ah (:, i ) = tp % ah (:, i ) + tp % aobl (:, i ) - aoblcb (:) end do end associate return end subroutine obl_acc_tp module subroutine obl_pot_system ( self ) !! author: David A. Minton !! !! Compute the contribution to the total gravitational potential due solely to the oblateness of the central body !!    Returned value does not include monopole term or terms higher than J4 !! !!    Reference: MacMillan, W. D. 1958. The Theory of the Potential, (Dover Publications), 363. !! !! Adapted from David E. Kaufmann's Swifter routine: obl_pot.f90 !! Adapted from Hal Levison's Swift routine obl_pot.f implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object ! Internals integer ( I4B ) :: i real ( DP ), dimension ( self % pl % nbody ) :: oblpot_arr associate ( system => self , pl => self % pl , npl => self % pl % nbody , cb => self % cb ) if (. not . any ( pl % lmask ( 1 : npl ))) return do concurrent ( i = 1 : npl , pl % lmask ( i )) oblpot_arr ( i ) = obl_pot_one ( npl , cb % Gmass , pl % Gmass ( i ), cb % j2rp2 , cb % j4rp4 , pl % xh ( 3 , i ), 1.0_DP / norm2 ( pl % xh (:, i ))) end do system % oblpot = sum ( oblpot_arr , pl % lmask ( 1 : npl )) end associate return end subroutine obl_pot_system elemental function obl_pot_one ( npl , GMcb , GMpl , j2rp2 , j4rp4 , zh , irh ) result ( oblpot ) !! author: David A. Minton !! !! Compute the contribution to the total gravitational potential due solely to the oblateness of the central body from a single massive body !!    Returned value does not include monopole term or terms higher than J4 !! !!    Reference: MacMillan, W. D. 1958. The Theory of the Potential, (Dover Publications), 363. !! !! Adapted from David E. Kaufmann's Swifter routine: obl_pot.f90 !! Adapted from Hal Levison's Swift routine obl_pot.f implicit none ! Arguments integer ( I4B ), intent ( in ) :: npl !! Number of massive bodies real ( DP ), intent ( in ) :: GMcb !! G*mass of the central body real ( DP ), intent ( in ) :: GMpl !! G*mass of the massive body real ( DP ), intent ( in ) :: j2rp2 !! J_2 / R**2 of the central body real ( DP ), intent ( in ) :: j4rp4 !! J_2 / R**4 of the central body real ( DP ), intent ( in ) :: zh !! z-component of the heliocentric distance vector of the massive body real ( DP ), intent ( in ) :: irh !! Inverse of the heliocentric distance magnitude of the massive body ! Result real ( DP ) :: oblpot !! Gravitational potential ! Internals integer ( I4B ) :: i real ( DP ) :: rinv2 , t0 , t1 , t2 , t3 , p2 , p4 , mu rinv2 = irh ** 2 t0 = GMcb * GMpl * rinv2 * irh t1 = j2rp2 t2 = zh ** 2 * rinv2 t3 = j4rp4 * rinv2 p2 = 0.5_DP * ( 3 * t2 - 1.0_DP ) p4 = 0.125_DP * (( 35 * t2 - 3 0.0_DP ) * t2 + 3.0_DP ) oblpot = t0 * ( t1 * p2 + t3 * p4 ) return end function obl_pot_one end submodule s_obl","tags":"","loc":"sourcefile/obl.f90.html"},{"title":"orbel.f90 – swiftest","text":"This file depends on sourcefile~~orbel.f90~~EfferentGraph sourcefile~orbel.f90 orbel.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~orbel.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_orbel Source Code orbel.f90 Source Code submodule ( swiftest_classes ) s_orbel use swiftest contains module subroutine orbel_el2xv_vec ( self , cb ) !! author: David A. Minton !! !! A wrapper method that converts all of the orbital element vectors into cartesian position and velocity vectors for a Swiftest body object. !! This method deallocates all of the orbital elements after it is finished. implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body objec ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return call self % set_mu ( cb ) do concurrent ( i = 1 : self % nbody ) call orbel_el2xv ( self % mu ( i ), self % a ( i ), self % e ( i ), self % inc ( i ), self % capom ( i ), & self % omega ( i ), self % capm ( i ), self % xh (:, i ), self % vh (:, i )) end do deallocate ( self % a , self % e , self % inc , self % capom , self % omega , self % capm ) return end subroutine orbel_el2xv_vec pure subroutine orbel_el2xv ( mu , a , ie , inc , capom , omega , capm , x , v ) !! author: David A. Minton !! !! Compute osculating orbital elements from relative C)rtesian position and velocity !!  All angular measures are returned in radians !!      If inclination < TINY, longitude of the ascending node is arbitrarily set to 0 !! !!      If eccentricity < sqrt(TINY), argument of pericenter is arbitrarily set to 0 !! !!      ALGORITHM:  See Fitzpatrick \"Principles of Cel. Mech.\" !! !! Adapted from Martin Duncan's el2xv.f !! DATE WRITTEN:  May 11, 1992. !! REVISIONS: May 26 - now use better Kepler solver for ellipses !!  and hyperbolae called EHYBRID.F and FHYBRID.F implicit none real ( DP ), intent ( in ) :: mu real ( DP ), intent ( in ) :: a , ie , inc , capom , omega , capm real ( DP ), dimension (:), intent ( out ) :: x , v integer ( I4B ) :: iorbit_type real ( DP ) :: e , cape , capf , zpara , em1 real ( DP ) :: sip , cip , so , co , si , ci real ( DP ) :: d11 , d12 , d13 , d21 , d22 , d23 real ( DP ) :: scap , ccap , shcap , chcap real ( DP ) :: sqe , sqgma , xfac1 , xfac2 , ri , vfac1 , vfac2 if ( ie < 0.0_DP ) then !write(*,*) ' ERROR in orbel_el2xv: e<0, setting e=0!!1' e = 0.0_DP iorbit_type = ELLIPSE else e = ie em1 = e - 1._DP if ( abs ( em1 ) < VSMALL ) then iorbit_type = PARABOLA else if ( e > 1.0_DP ) then iorbit_type = HYPERBOLA else iorbit_type = ELLIPSE end if endif call orbel_scget ( omega , sip , cip ) call orbel_scget ( capom , so , co ) call orbel_scget ( inc , si , ci ) d11 = cip * co - sip * so * ci d12 = cip * so + sip * co * ci d13 = sip * si d21 = - sip * co - cip * so * ci d22 = - sip * so + cip * co * ci d23 = cip * si !-- ! Get the other quantities depending on orbit type ! if ( iorbit_type == ELLIPSE ) then cape = orbel_ehybrid ( e , capm ) call orbel_scget ( cape , scap , ccap ) sqe = sqrt ( 1._DP - e ** 2 ) sqgma = sqrt ( mu * a ) xfac1 = a * ( ccap - e ) xfac2 = a * sqe * scap ri = 1._DP / ( a * ( 1._DP - e * ccap )) vfac1 = - ri * sqgma * scap vfac2 = ri * sqgma * sqe * ccap endif !-- if ( iorbit_type == HYPERBOLA ) then capf = orbel_fhybrid ( e , capm ) call orbel_schget ( capf , shcap , chcap ) sqe = sqrt ( e ** 2 - 1._DP ) sqgma = sqrt ( mu * a ) xfac1 = a * ( e - chcap ) xfac2 = a * sqe * shcap ri = 1._DP / ( a * ( e * chcap - 1._DP )) vfac1 = - ri * sqgma * shcap vfac2 = ri * sqgma * sqe * chcap endif !-- if ( iorbit_type == PARABOLA ) then zpara = orbel_zget ( capm ) sqgma = sqrt ( 2 * mu * a ) xfac1 = a * ( 1._DP - zpara * zpara ) xfac2 = 2 * a * zpara ri = 1._DP / ( a * ( 1._DP + zpara * zpara )) vfac1 = - ri * sqgma * zpara vfac2 = ri * sqgma endif !-- x ( 1 ) = d11 * xfac1 + d21 * xfac2 x ( 2 ) = d12 * xfac1 + d22 * xfac2 x ( 3 ) = d13 * xfac1 + d23 * xfac2 v ( 1 ) = d11 * vfac1 + d21 * vfac2 v ( 2 ) = d12 * vfac1 + d22 * vfac2 v ( 3 ) = d13 * vfac1 + d23 * vfac2 return end subroutine orbel_el2xv module pure subroutine orbel_scget ( angle , sx , cx ) !! author: David A. Minton !! !! Efficiently compute the sine and cosine of an input angle !!      Input angle must be in radians !! !! Adapted from David E. Kaufmann's Swifter routine: orbel_scget.f90 !! Adapted from Hal Levison's Swift routine orbel_scget.f implicit none ! Arguments real ( DP ), intent ( in ) :: angle real ( DP ), intent ( out ) :: sx , cx ! Internals integer ( I4B ) :: nper real ( DP ) :: x nper = angle / TWOPI x = angle - nper * TWOPI if ( x < 0.0_DP ) x = x + TWOPI sx = sin ( x ) cx = sqrt ( 1.0_DP - sx ** 2 ) if (( x > PIBY2 ) . and . ( x < PI3BY2 )) cx = - cx return end subroutine orbel_scget !********************************************************************** ! Code converted to Modern Fortran by David A. Minton ! Date: 2020-06-29 !********************************************************************** !                   ORBEL_SCHGET.F !********************************************************************** !     PURPOSE:  Given an angle, efficiently compute sinh and cosh. ! !        Input: !             angle ==> angle in radians (real scalar) ! !        Output: !             shx    ==>  sinh(angle)  (real scalar) !             chx    ==>  cosh(angle)  (real scalar) ! !     ALGORITHM: Obvious from the code !     REMARKS: Based on the routine SCGET for sine's and cosine's. !       We use the sqrt rather than cosh (it's faster) !       BE SURE THE ANGLE IS IN RADIANS AND IT CAN'T BE LARGER THAN 300 !       OR OVERFLOWS WILL OCCUR! !     AUTHOR:  M. Duncan. !     DATE WRITTEN:  May 6, 1992. !     REVISIONS: !********************************************************************** pure subroutine orbel_schget ( angle , shx , chx ) real ( DP ), intent ( in ) :: angle real ( DP ), intent ( out ) :: shx , chx shx = sinh ( angle ) chx = sqrt ( 1._DP + shx * shx ) return end subroutine orbel_schget !********************************************************************** ! Code converted to Modern Fortran by David A. Minton ! Date: 2020-06-29 !        !                    ORBEL_FLON.F !********************************************************************** !     PURPOSE:  Solves Kepler's eqn. for hyperbola using hybrid approach. ! !             Input: !                           e ==> eccentricity anomaly. (real scalar) !                        capn ==> hyperbola mean anomaly. (real scalar) !             Returns: !                  orbel_flon ==>  eccentric anomaly. (real scalar) ! !     ALGORITHM: Uses power series for N in terms of F and Newton,s method !     REMARKS: ONLY GOOD FOR LOW VALUES OF N (N < 0.636*e -0.6) !     AUTHOR: M. Duncan !     DATE WRITTEN: May 26, 1992. !     REVISIONS: !********************************************************************** real ( DP ) pure function orbel_flon ( e , icapn ) implicit none real ( DP ), intent ( in ) :: e , icapn integer ( I4B ) :: iflag , i real ( DP ) :: a , b , sq , biga , bigb , capn real ( DP ) :: x , x2 real ( DP ) :: f , fp , dx real ( DP ) :: diff real ( DP ) :: a0 , a1 real ( DP ) :: b1 integer ( I4B ), parameter :: IMAX = 10 real ( DP ), parameter :: a11 = 15 6._DP , a9 = 1716 0._DP , a7 = 123552 0._DP real ( DP ), parameter :: a5 = 5189184 0._DP , a3 = 103783680 0._DP real ( DP ), parameter :: b11 = 11 * a11 , b9 = 9 * a9 , b7 = 7 * a7 real ( DP ), parameter :: b5 = 5 * a5 , b3 = 3 * a3 real ( DP ), parameter :: THIRD = 1._DP / 3._DP ! Function to solve \"Kepler's eqn\" for F (here called ! x) for given e and CAPN. Only good for smallish CAPN iflag = 0 if ( icapn < 0._DP ) then iflag = 1 capn = - icapn else capn = icapn end if a1 = 622702080 0._DP * ( 1._DP - 1._DP / e ) a0 = - 622702080 0._DP * capn / e b1 = a1 !  set iflag nonzero if capn < 0., in which case solve for -capn !  and change the sign of the final answer for f. !  Begin with a reasonable guess based on solving the cubic for small F a = 6 * ( e - 1.d0 ) / e b = - 6 * capn / e sq = SQRT ( 0.25_DP * b ** 2 + a ** 3 / 2 7._DP ) biga = ( - 0.5_DP * b + sq ) ** ( 1.0_DP / 3.0_DP ) bigb = - ( + 0.5_DP * b + sq ) ** ( 1.0_DP / 3.0_DP ) x = biga + bigb ! write(6,*) 'cubic = ',x**3 +a*x +b orbel_flon = x ! If capn is VSMALL (or zero) no need to go further than cubic even for ! e =1. if ( capn < VSMALL ) go to 100 do i = 1 , IMAX x2 = x * x f = a0 + x * ( a1 + x2 * ( a3 + x2 * ( a5 + x2 * ( a7 + x2 * ( a9 + x2 * ( a11 + x2 )))))) fp = b1 + x2 * ( b3 + x2 * ( b5 + x2 * ( b7 + x2 * ( b9 + x2 * ( b11 + 13 * x2 ))))) dx = - f / fp !   write(6,*) 'i,dx,x,f : ' !   write(6,432) i,dx,x,f 432 format ( 1 x , i3 , 3 ( 2 x , 1 p1e22 . 15 )) orbel_flon = x + dx !   if we have converged here there's no point in going on if ( abs ( dx ) <= VSMALL ) go to 100 x = orbel_flon end do ! abnormal return here - we've gone thru the loop ! imax times without convergence if ( iflag == 1 ) then orbel_flon = - orbel_flon capn = - capn end if !write(*,*) 'flon : returning without complete convergence' diff = e * sinh ( orbel_flon ) - orbel_flon - capn !write(*,*) 'n, f, ecc*sinh(f) - f - n : ' !write(*,*) capn,orbel_flon,diff return !  normal return here, but check if capn was originally negative 100 if ( iflag == 1 ) then orbel_flon = - orbel_flon capn = - capn end if return end function orbel_flon !********************************************************************** ! Code converted to Modern Fortran by David A. Minton ! Date: 2020-06-29 !                    ORBEL_FGET.F !********************************************************************** !     PURPOSE:  Solves Kepler's eqn. for hyperbola using hybrid approach. ! !             Input: !                           e ==> eccentricity anomaly. (real scalar) !                        capn ==> hyperbola mean anomaly. (real scalar) !             Returns: !                  orbel_fget ==>  eccentric anomaly. (real scalar) ! !     ALGORITHM: Based on pp. 70-72 of Fitzpatrick's book \"Principles of !           Cel. Mech. \".  Quartic convergence from Danby's book. !     REMARKS: !     AUTHOR: M. Duncan !     DATE WRITTEN: May 11, 1992. !     REVISIONS: 2/26/93 hfl !********************************************************************** real ( DP ) pure function orbel_fget ( e , capn ) implicit none real ( DP ), intent ( in ) :: e , capn integer :: i real ( DP ) :: tmp , x , shx , chx real ( DP ) :: esh , ech , f , fp , fpp , fppp , dx integer ( I4B ), parameter :: IMAX = 10 !---- !...  executable code ! function to solve \"kepler's eqn\" for f (here called ! x) for given e and capn. !  begin with a guess proposed by danby if ( capn < 0.d0 ) then tmp = - 2 * capn / e + 1.8_DP x = - log ( tmp ) else tmp = + 2 * capn / e + 1.8_DP x = log ( tmp ) end if orbel_fget = x do i = 1 , IMAX call orbel_schget ( x , shx , chx ) esh = e * shx ech = e * chx f = esh - x - capn !   write(6,*) 'i,x,f : ',i,x,f fp = ech - 1.d0 fpp = esh fppp = ech dx = - f / fp dx = - f / ( fp + dx * fpp / 2._DP ) dx = - f / ( fp + dx * fpp / 2._DP + dx ** 2 * fppp / 6._DP ) orbel_fget = x + dx !   if we have converged here there's no point in going on if ( abs ( dx ) <= VSMALL ) return x = orbel_fget end do !write(*,*) 'fget : returning without complete convergence' return end function orbel_fget !********************************************************************** ! Code converted to Modern Fortran by David A. Minton ! Date: 2020-06-29 !                    ORBEL_ZGET.F !********************************************************************** !     PURPOSE:  Solves the equivalent of Kepler's eqn. for a parabola !          given Q (Fitz. notation.) ! !             Input: !                           q ==>  parabola mean anomaly. (real scalar) !             Returns: !                  orbel_zget ==>  eccentric anomaly. (real scalar) ! !     ALGORITHM: p. 70-72 of Fitzpatrick's book \"Princ. of Cel. Mech.\" !     REMARKS: For a parabola we can solve analytically. !     AUTHOR: M. Duncan !     DATE WRITTEN: May 11, 1992. !     REVISIONS: May 27 - corrected it for negative Q and use power !       series for small Q. !********************************************************************** real ( DP ) pure function orbel_zget ( iq ) implicit none real ( DP ), intent ( in ) :: iq integer ( I4B ) :: iflag real ( DP ) :: x , tmp , q iflag = 0 if ( iq < 0.0_DP ) then iflag = 1 q = - iq else q = iq end if if ( q < 1.e-3_DP ) then orbel_zget = q * ( 1._DP - ( q ** 2 / 3._DP ) * ( 1._DP - q ** 2 )) else x = 0.5_DP * ( 3 * q + sqrt ( 9 * q ** 2 + 4._DP )) tmp = x ** ( 1._DP / 3._DP ) orbel_zget = tmp - 1._DP / tmp end if if ( iflag == 1 ) then orbel_zget = - orbel_zget q = - q end if return end function orbel_zget !********************************************************************** ! Code converted to Modern Fortran by David A. Minton ! Date: 2020-06-29 !                    ORBEL_ESOLMD.F !********************************************************************** !     PURPOSE:  Solves Kepler's eqn.   e is ecc.   m is mean anomaly. ! !             Input: !                           e ==> eccentricity anomaly. (real scalar) !                           m ==> mean anomaly. (real scalar) !             Returns: !                orbel_esolmd ==>  eccentric anomaly. (real scalar) ! !     ALGORITHM: Some sort of quartic convergence from Wisdom. !     REMARKS: ONLY GOOD FOR SMALL ECCENTRICITY SINCE IT ONLY !         ITERATES ONCE. (GOOD FOR PLANET CALCS.) !         ALSO DOES NOT PUT M OR E BETWEEN 0. AND 2*PI !     INCLUDES: needs SCGET.F !     AUTHOR: M. Duncan !     DATE WRITTEN: May 7, 1992. !     REVISIONS: 2/26/93 hfl !********************************************************************** real ( DP ) pure function orbel_esolmd ( e , m ) implicit none real ( DP ), intent ( in ) :: e real ( DP ), intent ( in ) :: m real ( DP ) :: x , sm , cm , sx , cx real ( DP ) :: es , ec , f , fp , fpp , fppp , dx !...    function to solve kepler's eqn for e (here called !...    x) for given e and m. returns value of x. call orbel_scget ( m , sm , cm ) x = m + e * sm * ( 1._DP + e * ( cm + e * ( 1._DP - 1.5_DP * sm ** 2 ))) call orbel_scget ( x , sx , cx ) es = e * sx ec = e * cx f = x - es - m fp = 1._DP - ec fpp = es fppp = ec dx = - f / fp dx = - f / ( fp + dx * fpp / 2._DP ) dx = - f / ( fp + dx * fpp / 2._DP + dx ** 2 * fppp / 6._DP ) orbel_esolmd = x + dx return end function orbel_esolmd !********************************************************************** ! Code converted to Modern Fortran by David A. Minton ! Date: 2020-06-29 !                    ORBEL_EHIE.F !********************************************************************** !     PURPOSE:  Solves Kepler's eqn.   e is ecc.   m is mean anomaly. ! !             Input: !                           e ==> eccentricity anomaly. (real scalar) !                           m ==> mean anomaly. (real scalar) !             Returns: !              orbel_ehybrid ==>  eccentric anomaly. (real scalar) ! !     ALGORITHM: Use Danby's quartic for 3 iterations. !                Eqn. is f(x) = x - e*sin(x+M). Note  that !          E = x + M. First guess is very good for e near 1. !          Need to first get M between 0. and PI and use !   symmetry to return right answer if M between PI and 2PI !     REMARKS: Modifies M so that both E and M are in range (0,TWOPI) !     AUTHOR: M. Duncan !     DATE WRITTEN: May 25,1992. !     REVISIONS: !********************************************************************** real ( DP ) pure function orbel_ehie ( e , im ) implicit none real ( DP ), intent ( in ) :: e , im integer ( I4B ) :: iflag , nper , niter real ( DP ) :: dx , x , sa , ca , esa , eca , f , fp , m integer ( I4B ), parameter :: NMAX = 3 ! in this section, bring m into the range (0,TWOPI) and if ! the result is greater than pi, solve for (TWOPI - m). iflag = 0 nper = im / TWOPI m = im - nper * TWOPI if ( m < 0._DP ) m = m + TWOPI if ( m > PI ) then m = TWOPI - m iflag = 1 end if ! make a first guess that works well for e near 1. x = ( 6 * m ) ** ( 1._DP / 3._DP ) - m niter = 0 ! iteration loop do niter = 1 , NMAX call orbel_scget ( x + m , sa , ca ) esa = e * sa eca = e * ca f = x - esa fp = 1._DP - eca dx = - f / fp dx = - f / ( fp + 0.5_DP * dx * esa ) dx = - f / ( fp + 0.5_DP * dx * ( esa + eca * dx / 3.0_DP )) x = x + dx end do orbel_ehie = m + x if ( iflag == 1 ) then orbel_ehie = TWOPI - orbel_ehie m = TWOPI - m end if return end function orbel_ehie !********************************************************************** ! Code converted to Modern Fortran by David A. Minton ! Date: 2020-06-29 !                             ORBEL_EGET.F !********************************************************************** !     PURPOSE:  Solves Kepler's eqn.   e is ecc.   m is mean anomaly. ! !             Input: !                           e ==> eccentricity anomaly. (real scalar) !                           m ==> mean anomaly. (real scalar) !             Returns: !                  orbel_eget ==>  eccentric anomaly. (real scalar) ! !     ALGORITHM: Quartic convergence from Danby !     REMARKS: For results very near roundoff, give it M between !           0 and 2*pi. One can condition M before calling EGET !           by calling my double precision function MOD2PI(M). !           This is not done within the routine to speed it up !           and because it works fine even for large M. !     AUTHOR: M. Duncan !     DATE WRITTEN: May 7, 1992. !     REVISIONS: May 21, 1992.  Now have it go through EXACTLY two iterations !                with the premise that it will only be called if !          we have an ellipse with e between 0.15 and 0.8 !********************************************************************** real ( DP ) pure function orbel_eget ( e , m ) implicit none real ( DP ), intent ( in ) :: e , m real ( DP ) :: x , sm , cm , sx , cx real ( DP ) :: es , ec , f , fp , fpp , fppp , dx ! function to solve kepler's eqn for e (here called ! x) for given e and m. returns value of x. ! may 21 : for e < 0.18 use esolmd for speed and sufficient accuracy ! may 21 : for e > 0.8 use ehie - this one may not converge fast enough. call orbel_scget ( m , sm , cm ) !  begin with a guess accurate to order ecc**3 x = m + e * sm * ( 1._DP + e * ( cm + e * ( 1._DP - 1.5_DP * sm * sm ))) !  go through one iteration for improved estimate call orbel_scget ( x , sx , cx ) es = e * sx ec = e * cx f = x - es - m fp = 1._DP - ec fpp = es fppp = ec dx = - f / fp dx = - f / ( fp + dx * fpp / 2._DP ) dx = - f / ( fp + dx * fpp / 2._DP + dx * 2 * fppp / 6._DP ) orbel_eget = x + dx ! do another iteration. ! for m between 0 and 2*pi this seems to be enough to ! get near roundoff error for eccentricities between 0 and 0.8 x = orbel_eget call orbel_scget ( x , sx , cx ) es = e * sx ec = e * cx f = x - es - m fp = 1._DP - ec fpp = es fppp = ec dx = - f / fp dx = - f / ( fp + dx * fpp / 2._DP ) dx = - f / ( fp + dx * fpp / 2._DP + dx ** 2 * fppp / 6._DP ) orbel_eget = x + dx return end function orbel_eget !********************************************************************** ! Code converted to Modern Fortran by David A. Minton ! Date: 2020-06-29 !                    ORBEL_EHYBRID.F !********************************************************************** !     PURPOSE:  Solves Kepler's eqn.   e is ecc.   m is mean anomaly. ! !             Input: !                           e ==> eccentricity anomaly. (real scalar) !                           m ==> mean anomaly. (real scalar) !             Returns: !              orbel_ehybrid ==>  eccentric anomaly. (real scalar) ! !     ALGORITHM: For e < 0.18 uses fast routine ESOLMD !          For larger e but less than 0.8, uses EGET !          For e > 0.8 uses EHIE !     REMARKS: Only EHIE brings M and E into range (0,TWOPI) !     AUTHOR: M. Duncan !     DATE WRITTEN: May 25,1992. !     REVISIONS: 2/26/93 hfl !********************************************************************** real ( DP ) pure function orbel_ehybrid ( e , m ) implicit none real ( DP ), intent ( in ) :: e , m !real(DP) :: orbel_esolmd,orbel_eget,orbel_ehie if ( e < 0.18_DP ) then orbel_ehybrid = orbel_esolmd ( e , m ) else if ( e <= 0.8_DP ) then orbel_ehybrid = orbel_eget ( e , m ) else orbel_ehybrid = orbel_ehie ( e , m ) end if end if return end function orbel_ehybrid !********************************************************************** ! Code converted to Modern Fortran by David A. Minton ! Date: 2020-06-29 !                    ORBEL_FHYBRID.F !********************************************************************** !     PURPOSE:  Solves Kepler's eqn. for hyperbola using hybrid approach. ! !             Input: !                           e ==> eccentricity anomaly. (real scalar) !                           n ==> hyperbola mean anomaly. (real scalar) !             Returns: !               orbel_fhybrid ==>  eccentric anomaly. (real scalar) ! !     ALGORITHM: For abs(N) < 0.636*ecc -0.6 , use FLON !          For larger N, uses FGET !     REMARKS: !     AUTHOR: M. Duncan !     DATE WRITTEN: May 26,1992. !     REVISIONS:: !     REVISIONS: 2/26/93 hfl !********************************************************************** real ( DP ) pure function orbel_fhybrid ( e , n ) implicit none real ( DP ), intent ( in ) :: e , n real ( DP ) :: abn abn = n if ( n < 0._DP ) abn = - abn if ( abn < 0.636_DP * e - 0.6_DP ) then orbel_fhybrid = orbel_flon ( e , n ) else orbel_fhybrid = orbel_fget ( e , n ) end if return end function orbel_fhybrid module pure subroutine orbel_xv2aeq ( mu , x , v , a , e , q ) !! author: David A. Minton !! !! Compute semimajor axis, eccentricity, and pericentric distance from relative Cartesian position and velocity !! !! Adapted from David E. Kaufmann's Swifter routine: orbel_xv2aeq.f90 !! Adapted from Luke Dones' Swift routine orbel_xv2aeq.f implicit none !! Arguments real ( DP ), intent ( in ) :: mu real ( DP ), dimension (:), intent ( in ) :: x , v real ( DP ), intent ( out ) :: a , e , q integer ( I4B ) :: iorbit_type real ( DP ) :: r , v2 , h2 , energy , fac real ( DP ), dimension ( NDIM ) :: hvec a = 0.0_DP e = 0.0_DP q = 0.0_DP r = sqrt ( dot_product ( x (:), x (:))) v2 = dot_product ( v (:), v (:)) hvec (:) = x (:) . cross . v (:) h2 = dot_product ( hvec (:), hvec (:)) if ( h2 == 0.0_DP ) return energy = 0.5_DP * v2 - mu / r if ( abs ( energy * r / mu ) < sqrt ( VSMALL )) then iorbit_type = PARABOLA else a = - 0.5_DP * mu / energy if ( a < 0.0_DP ) then fac = - h2 / ( mu * a ) if ( fac > VSMALL ) then iorbit_type = HYPERBOLA else iorbit_type = PARABOLA end if else iorbit_type = ELLIPSE end if end if select case ( iorbit_type ) case ( ELLIPSE ) fac = 1.0_DP - h2 / ( mu * a ) if ( fac > VSMALL ) e = sqrt ( fac ) q = a * ( 1.0_DP - e ) case ( PARABOLA ) a = 0.5_DP * h2 / mu e = 1.0_DP q = a case ( HYPERBOLA ) e = sqrt ( 1.0_DP + fac ) q = a * ( 1.0_DP - e ) end select return end subroutine orbel_xv2aeq module pure subroutine orbel_xv2aqt ( mu , x , v , a , q , capm , tperi ) !! author: David A. Minton !! !! Compute semimajor axis, pericentric distance, mean anomaly, and time to nearest pericenter passage from !! relative Cartesian position and velocity !!      tperi > 0 means nearest pericenter passage is in the future !!      tperi < 0 means nearest pericenter passage is in the past !! !! Adapted from David E. Kaufmann's Swifter routine: orbel_xv2aqt.f90 implicit none ! Arguments real ( DP ), intent ( in ) :: mu !! Gravitational constant real ( DP ), dimension (:), intent ( in ) :: x !! Position vector real ( DP ), dimension (:), intent ( in ) :: v !! Velocity vector real ( DP ), intent ( out ) :: a !! semimajor axis real ( DP ), intent ( out ) :: q !! periapsis real ( DP ), intent ( out ) :: capm !! mean anomaly real ( DP ), intent ( out ) :: tperi !! time of pericenter passage ! Internals integer ( I4B ) :: iorbit_type real ( DP ) :: r , v2 , h2 , rdotv , energy , fac , w , face , cape , e , tmpf , capf , mm real ( DP ), dimension ( NDIM ) :: hvec a = 0.0_DP q = 0.0_DP capm = 0.0_DP tperi = 0.0_DP r = sqrt ( dot_product ( x (:), x (:))) v2 = dot_product ( v (:), v (:)) hvec (:) = x (:) . cross . v (:) h2 = dot_product ( hvec (:), hvec (:)) if ( h2 == 0.0_DP ) return rdotv = dot_product ( x (:), v (:)) energy = 0.5_DP * v2 - mu / r if ( abs ( energy * r / mu ) < sqrt ( VSMALL )) then iorbit_type = PARABOLA else a = - 0.5_DP * mu / energy if ( a < 0.0_DP ) then fac = - h2 / ( mu * a ) if ( fac > VSMALL ) then iorbit_type = HYPERBOLA else iorbit_type = PARABOLA end if else iorbit_type = ELLIPSE end if end if select case ( iorbit_type ) case ( ELLIPSE ) fac = 1.0_DP - h2 / ( mu * a ) if ( fac > VSMALL ) then e = sqrt ( fac ) cape = 0.0_DP face = ( a - r ) / ( a * e ) if ( face < - 1.0_DP ) then cape = PI else if ( face < 1.0_DP ) then cape = acos ( face ) end if if ( rdotv < 0.0_DP ) cape = TWOPI - cape else e = 0.0_DP cape = 0.0_DP end if capm = cape - e * sin ( cape ) q = a * ( 1.0_DP - e ) mm = sqrt ( mu / a ** 3 ) if ( capm < PI ) then tperi = - 1.0_DP * capm / mm else tperi = - 1.0_DP * ( capm - TWOPI ) / mm end if case ( PARABOLA ) a = 0.5_DP * h2 / mu e = 1.0_DP w = 0.0_DP fac = 2 * a / r - 1.0_DP if ( fac < - 1.0_DP ) then w = PI else if ( fac < 1.0_DP ) then w = acos ( fac ) end if if ( rdotv < 0.0_DP ) w = TWOPI - w tmpf = tan ( 0.5_DP * w ) capm = tmpf * ( 1.0_DP + tmpf * tmpf / 3.0_DP ) q = a mm = sqrt ( 0.5_DP * mu / q ** 3 ) tperi = - 1.0_DP * capm / mm case ( HYPERBOLA ) e = sqrt ( 1.0_DP + fac ) tmpf = ( a - r ) / ( a * e ) if ( tmpf < 1.0_DP ) tmpf = 1.0_DP capf = log ( tmpf + sqrt ( tmpf * tmpf - 1.0_DP )) if ( rdotv < 0.0_DP ) capf = - capf capm = e * sinh ( capf ) - capf q = a * ( 1.0_DP - e ) mm = sqrt ( - mu / a ** 3 ) tperi = - 1.0_DP * capm / mm end select return end subroutine orbel_xv2aqt module subroutine orbel_xv2el_vec ( self , cb ) !! author: David A. Minton !! !! A wrapper method that converts all of the cartesian position and velocity vectors of a Swiftest body object to orbital elements. implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object ! internals integer ( I4B ) :: i if ( self % nbody == 0 ) return call self % set_mu ( cb ) if ( allocated ( self % a )) deallocate ( self % a ); allocate ( self % a ( self % nbody )) if ( allocated ( self % e )) deallocate ( self % e ); allocate ( self % e ( self % nbody )) if ( allocated ( self % inc )) deallocate ( self % inc ); allocate ( self % inc ( self % nbody )) if ( allocated ( self % capom )) deallocate ( self % capom ); allocate ( self % capom ( self % nbody )) if ( allocated ( self % omega )) deallocate ( self % omega ); allocate ( self % omega ( self % nbody )) if ( allocated ( self % capm )) deallocate ( self % capm ); allocate ( self % capm ( self % nbody )) do concurrent ( i = 1 : self % nbody ) call orbel_xv2el ( self % mu ( i ), self % xh (:, i ), self % vh (:, i ), self % a ( i ), self % e ( i ), self % inc ( i ), & self % capom ( i ), self % omega ( i ), self % capm ( i )) end do end subroutine orbel_xv2el_vec module pure subroutine orbel_xv2el ( mu , x , v , a , e , inc , capom , omega , capm ) !! author: David A. Minton !! !! Compute osculating orbital elements from relative Cartesian position and velocity !!  All angular measures are returned in radians !!      If inclination < TINY, longitude of the ascending node is arbitrarily set to 0 !! !!      If eccentricity < sqrt(TINY), argument of pericenter is arbitrarily set to 0 !! !!      References: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 201 - 206. !!              Fitzpatrick, P. M. 1970. Principles of Celestial Mechanics, (Academic Press), 69 - 73. !!              Roy, A. E. 1982. Orbital Motion, (Adam Hilger, Ltd.), 75 - 95 !! !! Adapted from David E. Kaufmann's Swifter routine: orbel_xv2el.f90 !! Adapted from Martin Duncan's Swift routine orbel_xv2el.f implicit none ! Arguments real ( DP ), intent ( in ) :: mu !! Gravitational constant real ( DP ), dimension (:), intent ( in ) :: x !! Position vector real ( DP ), dimension (:), intent ( in ) :: v !! Velocity vector real ( DP ), intent ( out ) :: a !! semimajor axis real ( DP ), intent ( out ) :: e !! eccentricity real ( DP ), intent ( out ) :: inc !! inclination real ( DP ), intent ( out ) :: capom !! longitude of ascending node real ( DP ), intent ( out ) :: omega !! argument of periapsis real ( DP ), intent ( out ) :: capm !! mean anomaly ! Internals integer ( I4B ) :: iorbit_type real ( DP ) :: r , v2 , h2 , h , rdotv , energy , fac , u , w , cw , sw , face , cape , tmpf , capf real ( DP ), dimension ( NDIM ) :: hvec a = 0.0_DP e = 0.0_DP inc = 0.0_DP capom = 0.0_DP omega = 0.0_DP capm = 0.0_DP r = . mag . x (:) v2 = dot_product ( v (:), v (:)) hvec = x (:) . cross . v (:) h2 = dot_product ( hvec (:), hvec (:)) h = . mag . hvec (:) if ( h2 <= 10 * tiny ( 0.0_DP )) return rdotv = dot_product ( x (:), v (:)) energy = 0.5_DP * v2 - mu / r fac = hvec ( 3 ) / h if ( fac < - 1.0_DP ) then inc = PI else if ( fac < 1.0_DP ) then inc = acos ( fac ) end if fac = sqrt ( hvec ( 1 ) ** 2 + hvec ( 2 ) ** 2 ) / h if ( fac ** 2 < VSMALL ) then u = atan2 ( x ( 2 ), x ( 1 )) if ( hvec ( 3 ) < 0.0_DP ) u = - u else capom = atan2 ( hvec ( 1 ), - hvec ( 2 )) u = atan2 ( x ( 3 ) / sin ( inc ), x ( 1 ) * cos ( capom ) + x ( 2 ) * sin ( capom )) end if if ( capom < 0.0_DP ) capom = capom + TWOPI if ( u < 0.0_DP ) u = u + TWOPI if ( abs ( energy * r / mu ) < sqrt ( VSMALL )) then iorbit_type = parabola else a = - 0.5_DP * mu / energy if ( a < 0.0_DP ) then fac = - h2 / ( mu * a ) if ( fac > VSMALL ) then iorbit_type = HYPERBOLA else iorbit_type = PARABOLA end if else iorbit_type = ELLIPSE end if end if select case ( iorbit_type ) case ( ELLIPSE ) fac = 1.0_DP - h2 / ( mu * a ) if ( fac > VSMALL ) then e = sqrt ( fac ) cape = 0.0_DP face = ( a - r ) / ( a * e ) if ( face < - 1.0_DP ) then cape = PI else if ( face < 1.0_DP ) then cape = acos ( face ) end if if ( rdotv < 0.0_DP ) cape = TWOPI - cape fac = 1.0_DP - e * cos ( cape ) cw = ( cos ( cape ) - e ) / fac sw = sqrt ( 1.0_DP - e ** 2 ) * sin ( cape ) / fac w = atan2 ( sw , cw ) if ( w < 0.0_DP ) w = w + TWOPI else cape = u w = u end if capm = cape - e * sin ( cape ) case ( PARABOLA ) a = 0.5_DP * h2 / mu e = 1.0_DP w = 0.0_DP fac = 2 * a / r - 1.0_DP if ( fac < - 1.0_DP ) then w = PI else if ( fac < 1.0_DP ) then w = acos ( fac ) end if if ( rdotv < 0.0_DP ) w = TWOPI - w tmpf = tan ( 0.5_DP * w ) capm = tmpf * ( 1.0_DP + tmpf * tmpf / 3.0_DP ) case ( HYPERBOLA ) e = sqrt ( 1.0_DP + fac ) tmpf = max (( a - r ) / ( a * e ), 1.0_DP ) capf = log ( tmpf + sqrt ( tmpf ** 2 - 1.0_DP )) if ( rdotv < 0.0_DP ) capf = - capf fac = e * cosh ( capf ) - 1.0_DP cw = ( e - cosh ( capf )) / fac sw = sqrt ( e * e - 1.0_DP ) * sinh ( capf ) / fac w = atan2 ( sw , cw ) if ( w < 0.0_DP ) w = w + TWOPI capm = e * sinh ( capf ) - capf end select omega = u - w if ( omega < 0.0_DP ) omega = omega + TWOPI return end subroutine orbel_xv2el end submodule s_orbel","tags":"","loc":"sourcefile/orbel.f90.html"},{"title":"whm_coord.f90 – swiftest","text":"This file depends on sourcefile~~whm_coord.f90~~EfferentGraph sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~whm_coord.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_whm_coord Source Code whm_coord.f90 Source Code submodule ( whm_classes ) s_whm_coord use swiftest contains module subroutine whm_coord_h2j_pl ( self , cb ) !! author: David A. Minton !! !! Convert from heliocentric to Jacobi coordinates, massive bodies only !! !! Uses pre-computed eta rather than computing it each time !! !! Adapted from David E. Kaufmann's Swifter routine coord_h2j.f90 !! !! Adapted from Hal Levison's Swift routine coord_h2j.f implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body particle data structuree ! Internals integer ( I4B ) :: i real ( DP ), dimension ( NDIM ) :: sumx , sumv , cap , capv if ( self % nbody == 0 ) return associate ( npl => self % nbody , GMpl => self % Gmass , eta => self % eta , xh => self % xh , vh => self % vh , & xj => self % xj , vj => self % vj ) xj (:, 1 ) = xh (:, 1 ) vj (:, 1 ) = vh (:, 1 ) sumx (:) = 0.0_DP sumv (:) = 0.0_DP do i = 2 , npl sumx (:) = sumx (:) + GMpl ( i - 1 ) * xh (:, i - 1 ) sumv (:) = sumv (:) + GMpl ( i - 1 ) * vh (:, i - 1 ) cap (:) = sumx (:) / eta ( i - 1 ) capv (:) = sumv (:) / eta ( i - 1 ) xj (:, i ) = xh (:, i ) - cap (:) vj (:, i ) = vh (:, i ) - capv (:) end do end associate return end subroutine whm_coord_h2j_pl module subroutine whm_coord_j2h_pl ( self , cb ) !! author: David A. Minton !! !! Convert from Jacobi to heliocentric coordinates, massive bodies only. !! !! Uses pre-computed eta rather than computing it each time !! !! !! Adapted from David E. Kaufmann's Swifter routine coord_j2h.f90 !! !! Adapted from Hal Levison's Swift routine coord_j2h.f implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body particle data structuree ! Internals integer ( I4B ) :: i real ( DP ), dimension ( NDIM ) :: sumx , sumv if ( self % nbody == 0 ) return associate ( npl => self % nbody , GMpl => self % Gmass , eta => self % eta , xh => self % xh , vh => self % vh , & xj => self % xj , vj => self % vj ) xh (:, 1 ) = xj (:, 1 ) vh (:, 1 ) = vj (:, 1 ) sumx (:) = 0.0_DP sumv (:) = 0.0_DP do i = 2 , npl sumx (:) = sumx (:) + GMpl ( i - 1 ) * xj (:, i - 1 ) / eta ( i - 1 ) sumv (:) = sumv (:) + GMpl ( i - 1 ) * vj (:, i - 1 ) / eta ( i - 1 ) xh (:, i ) = xj (:, i ) + sumx (:) vh (:, i ) = vj (:, i ) + sumv (:) end do end associate return end subroutine whm_coord_j2h_pl module subroutine whm_coord_vh2vj_pl ( self , cb ) !! author: David A. Minton !! !! Convert from heliocentric to Jadcobi coordinates, massive body velocities only !! !! Uses pre-computed eta rather than computing it each time !! !! Adapted from David E. Kaufmann's Swifter routine coord_vh2vj.f90 !! !! Adapted from Hal Levison's Swift routine coord_vh2vj.f implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body particle data structuree ! Internals integer ( I4B ) :: i real ( DP ), dimension ( NDIM ) :: sumv , capv if ( self % nbody == 0 ) return associate ( npl => self % nbody , GMpl => self % Gmass , vh => self % vh , vj => self % vj , eta => self % eta ) vj (:, 1 ) = vh (:, 1 ) sumv (:) = 0.0_DP do i = 2 , npl sumv (:) = sumv (:) + GMpl ( i - 1 ) * vh (:, i - 1 ) capv (:) = sumv (:) / eta ( i - 1 ) vj (:, i ) = vh (:, i ) - capv (:) end do end associate return end subroutine whm_coord_vh2vj_pl end submodule s_whm_coord","tags":"","loc":"sourcefile/whm_coord.f90.html"},{"title":"whm_gr.f90 – swiftest","text":"This file depends on sourcefile~~whm_gr.f90~~EfferentGraph sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~whm_gr.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_whm_gr Source Code whm_gr.f90 Source Code submodule ( whm_classes ) s_whm_gr use swiftest contains module pure subroutine whm_gr_kick_getacch_pl ( self , param ) !! author: David A. Minton !! !! Compute relativisitic accelerations of massive bodies !!    Based on Saha & Tremaine (1994) Eq. 28 !! !! Adapted from David A. Minton's Swifter routine routine gr_whm_kick_getacch.f90 implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i real ( DP ), dimension ( NDIM ) :: suma real ( DP ), dimension (:, :), allocatable :: aj real ( DP ) :: beta , rjmag4 if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody , inv_c2 => param % inv_c2 ) call gr_kick_getacch ( pl % muj , pl % xj , pl % lmask , npl , param % inv_c2 , pl % agr ) suma (:) = 0.0_DP pl % ah (:, 1 ) = pl % ah (:, 1 ) + pl % agr (:, 1 ) do i = 2 , npl suma (:) = suma (:) + pl % Gmass ( i ) * pl % agr (:, i ) / pl % eta ( i ) pl % ah (:, i ) = pl % ah (:, i ) + pl % agr (:, i ) + suma (:) end do end associate return end subroutine whm_gr_kick_getacch_pl module pure subroutine whm_gr_kick_getacch_tp ( self , param ) !! author: David A. Minton !! !! Compute relativisitic accelerations of test particles !!    Based on Saha & Tremaine (1994) Eq. 28 !! !! Adapted from David A. Minton's Swifter routine routine gr_whm_kick_getacch.f90 implicit none ! Arguments class ( whm_tp ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i real ( DP ) :: rjmag4 , beta if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody , inv_c2 => param % inv_c2 ) call gr_kick_getacch ( tp % mu , tp % xh , tp % lmask , ntp , param % inv_c2 , tp % agr ) tp % ah (:, 1 : ntp ) = tp % ah (:, 1 : ntp ) + tp % agr (:, 1 : ntp ) end associate return end subroutine whm_gr_kick_getacch_tp module pure subroutine whm_gr_p4_pl ( self , param , dt ) !! author: David A. Minton !! !! Position kick to massive bodies due to p**4 term in the post-Newtonian correction !!    Based on Saha & Tremaine (1994) Eq. 28 !! !! Adapted from David A. Minton's Swifter routine routine gr_whm_p4.f90 implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Step size ! Internals integer ( I4B ) :: i associate ( pl => self , npl => self % nbody ) if ( npl == 0 ) return do concurrent ( i = 1 : npl , pl % lmask ( i )) call gr_p4_pos_kick ( param , pl % xj (:, i ), pl % vj (:, i ), dt ) end do end associate return end subroutine whm_gr_p4_pl module pure subroutine whm_gr_p4_tp ( self , param , dt ) !! author: David A. Minton !! !! Position kick to test particles due to p**4 term in the post-Newtonian correction !!    Based on Saha & Tremaine (1994) Eq. 28 !! !! Adapted from David A. Minton's Swifter routine routine gr_whm_p4.f90 implicit none ! Arguments class ( whm_tp ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Step size ! Internals integer ( I4B ) :: i associate ( tp => self , ntp => self % nbody ) if ( ntp == 0 ) return do concurrent ( i = 1 : ntp , tp % lmask ( i )) call gr_p4_pos_kick ( param , tp % xh (:, i ), tp % vh (:, i ), dt ) end do end associate return end subroutine whm_gr_p4_tp end submodule s_whm_gr","tags":"","loc":"sourcefile/whm_gr.f90.html"},{"title":"whm_step.f90 – swiftest","text":"This file depends on sourcefile~~whm_step.f90~~EfferentGraph sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~whm_step.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_whm_step Source Code whm_step.f90 Source Code submodule ( whm_classes ) s_whm_step use swiftest contains module subroutine whm_step_system ( self , param , t , dt ) !! author: David A. Minton !! !! Step massive bodies and and active test particles ahead in heliocentric coordinates !! !! Adapted from Hal Levison's Swift routine step_kdk.f !! Adapted from David E. Kaufmann's Swifter routine whm_step.f90 implicit none ! Arguments class ( whm_nbody_system ), intent ( inout ) :: self !! WHM nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize associate ( system => self , cb => self % cb , pl => self % pl , tp => self % tp ) tp % lfirst = pl % lfirst call pl % step ( system , param , t , dt ) call tp % step ( system , param , t , dt ) if ( param % ltides ) call system % step_spin ( param , t , dt ) end associate return end subroutine whm_step_system module subroutine whm_step_pl ( self , system , param , t , dt ) !! author: David A. Minton !! !! Step planets ahead using kick-drift-kick algorithm !! !! Adapted from Hal Levison's Swift routine step_kdk_pl.f !! Adapted from David E. Kaufmann's Swifter routine whm_step_pl.f90 !logical, save :: lfirst = .true. implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize ! Internals real ( DP ) :: dth if ( self % nbody == 0 ) return associate ( pl => self , cb => system % cb ) dth = 0.5_DP * dt call pl % kick ( system , param , t , dth , lbeg = . true .) call pl % vh2vj ( cb ) if ( param % lgr ) call pl % gr_pos_kick ( param , dth ) call pl % drift ( system , param , dt ) if ( param % lgr ) call pl % gr_pos_kick ( param , dth ) call pl % j2h ( cb ) call pl % kick ( system , param , t + dt , dth , lbeg = . false .) end associate return end subroutine whm_step_pl module subroutine whm_step_tp ( self , system , param , t , dt ) !! author: David A. Minton !! !! Step active test particles ahead using kick-drift-kick algorithm !! !! Adapted from Hal Levison's Swift routine step_kdk_tp.f !! Adapted from David E. Kaufmann's Swifter routine whm_step_tp.f90 implicit none ! Arguments class ( whm_tp ), intent ( inout ) :: self !! WHM test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize ! Internals real ( DP ) :: dth if ( self % nbody == 0 ) return select type ( system ) class is ( whm_nbody_system ) associate ( tp => self , cb => system % cb , pl => system % pl ) dth = 0.5_DP * dt call tp % kick ( system , param , t , dth , lbeg = . true .) if ( param % lgr ) call tp % gr_pos_kick ( param , dth ) call tp % drift ( system , param , dt ) if ( param % lgr ) call tp % gr_pos_kick ( param , dth ) call tp % kick ( system , param , t + dt , dth , lbeg = . false .) end associate end select return end subroutine whm_step_tp end submodule s_whm_step","tags":"","loc":"sourcefile/whm_step.f90.html"},{"title":"whm_drift.f90 – swiftest","text":"This file depends on sourcefile~~whm_drift.f90~~EfferentGraph sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~whm_drift.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules whm_drift Source Code whm_drift.f90 Source Code submodule ( whm_classes ) whm_drift use swiftest contains module subroutine whm_drift_pl ( self , system , param , dt ) !! author: David A. Minton !! !! Loop through planets and call Danby drift routine !! !! Adapted from Hal Levison's Swift routine drift.f !! Adapted from David E. Kaufmann's Swifter routine whm_drift.f90 implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! WHM nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize ! Internals integer ( I4B ) :: i integer ( I4B ), dimension (:), allocatable :: iflag if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) allocate ( iflag ( npl )) iflag (:) = 0 call drift_all ( pl % muj , pl % xj , pl % vj , npl , param , dt , pl % lmask , iflag ) if ( any ( iflag ( 1 : npl ) /= 0 )) then where ( iflag ( 1 : npl ) /= 0 ) pl % status ( 1 : npl ) = DISCARDED_DRIFTERR pl % lmask ( 1 : npl ) = . false . end where do i = 1 , npl if ( iflag ( i ) /= 0 ) then write ( * , * ) \" Planet \" , pl % id ( i ), \" is lost!!!!!!!!!!!!\" WRITE ( * , * ) pl % muj ( i ), dt WRITE ( * , * ) pl % xj (:, i ) WRITE ( * , * ) pl % vj (:, i ) WRITE ( * , * ) \" STOPPING \" end if end do call util_exit ( FAILURE ) end if end associate return end subroutine whm_drift_pl end submodule whm_drift","tags":"","loc":"sourcefile/whm_drift.f90.html"},{"title":"whm_kick.f90 – swiftest","text":"This file depends on sourcefile~~whm_kick.f90~~EfferentGraph sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~whm_kick.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_whm_kick Source Code whm_kick.f90 Source Code submodule ( whm_classes ) s_whm_kick use swiftest contains module subroutine whm_kick_getacch_pl ( self , system , param , t , lbeg ) !! author: David A. Minton !! !! Compute heliocentric accelerations of planets !! !! Adapted from Hal Levison's Swift routine getacch.f !! Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch.f90 implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest central body particle data structure class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step ! Internals integer ( I4B ) :: i real ( DP ), dimension ( NDIM ) :: ah0 if ( self % nbody == 0 ) return associate ( cb => system % cb , pl => self , npl => self % nbody ) call pl % set_ir3 () ah0 (:) = whm_kick_getacch_ah0 ( pl % Gmass ( 2 : npl ), pl % xh (:, 2 : npl ), npl - 1 ) do i = 1 , npl pl % ah (:, i ) = pl % ah (:, i ) + ah0 (:) end do call whm_kick_getacch_ah1 ( cb , pl ) call whm_kick_getacch_ah2 ( cb , pl ) call pl % accel_int () if ( param % loblatecb ) then call pl % accel_obl ( system ) if ( lbeg ) then cb % aoblbeg = cb % aobl else cb % aoblend = cb % aobl end if if ( param % ltides ) then cb % atidebeg = cb % aobl call pl % accel_tides ( system ) cb % atideend = cb % atide end if end if if ( param % lgr ) call pl % accel_gr ( param ) if ( param % lextra_force ) call pl % accel_user ( system , param , t , lbeg ) end associate return end subroutine whm_kick_getacch_pl module subroutine whm_kick_getacch_tp ( self , system , param , t , lbeg ) !! author: David A. Minton !! !! Compute heliocentric accelerations of test particles !! !! Adapted from Hal Levison's Swift routine getacch_tp.f !! Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_tp.f90 implicit none ! Arguments class ( whm_tp ), intent ( inout ) :: self !! WHM test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest central body particle data structure class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step ! Internals integer ( I4B ) :: i real ( DP ), dimension ( NDIM ) :: ah0 associate ( tp => self , ntp => self % nbody , pl => system % pl , cb => system % cb , npl => system % pl % nbody ) if ( ntp == 0 . or . npl == 0 ) return system % lbeg = lbeg if ( lbeg ) then ah0 (:) = whm_kick_getacch_ah0 ( pl % Gmass ( 1 : npl ), pl % xbeg (:, 1 : npl ), npl ) do concurrent ( i = 1 : ntp , tp % lmask ( i )) tp % ah (:, i ) = tp % ah (:, i ) + ah0 (:) end do call tp % accel_int ( pl % Gmass ( 1 : npl ), pl % xbeg (:, 1 : npl ), npl ) else ah0 (:) = whm_kick_getacch_ah0 ( pl % Gmass ( 1 : npl ), pl % xend (:, 1 : npl ), npl ) do concurrent ( i = 1 : ntp , tp % lmask ( i )) tp % ah (:, i ) = tp % ah (:, i ) + ah0 (:) end do call tp % accel_int ( pl % Gmass ( 1 : npl ), pl % xend (:, 1 : npl ), npl ) end if if ( param % loblatecb ) call tp % accel_obl ( system ) if ( param % lextra_force ) call tp % accel_user ( system , param , t , lbeg ) if ( param % lgr ) call tp % accel_gr ( param ) end associate return end subroutine whm_kick_getacch_tp function whm_kick_getacch_ah0 ( mu , xhp , n ) result ( ah0 ) !! author: David A. Minton !! !! Compute zeroth term heliocentric accelerations of planets implicit none ! Arguments real ( DP ), dimension (:), intent ( in ) :: mu real ( DP ), dimension (:,:), intent ( in ) :: xhp integer ( I4B ), intent ( in ) :: n ! Result real ( DP ), dimension ( NDIM ) :: ah0 ! Internals real ( DP ) :: fac , r2 , ir3h , irh integer ( I4B ) :: i ah0 (:) = 0.0_DP do i = 1 , n r2 = dot_product ( xhp (:, i ), xhp (:, i )) irh = 1.0_DP / sqrt ( r2 ) ir3h = irh / r2 fac = mu ( i ) * ir3h ah0 (:) = ah0 (:) - fac * xhp (:, i ) end do return end function whm_kick_getacch_ah0 pure subroutine whm_kick_getacch_ah1 ( cb , pl ) !! author: David A. Minton !! !! Compute first term heliocentric accelerations of planets !! !! Adapted from Hal Levison's Swift routine getacch_ah1.f !! Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah1.f90 implicit none ! Arguments class ( swiftest_cb ), intent ( in ) :: cb !! WHM central body object class ( whm_pl ), intent ( inout ) :: pl !! WHM massive body object ! Internals integer ( I4B ) :: i real ( DP ), dimension ( NDIM ) :: ah1h , ah1j associate ( npl => pl % nbody ) do concurrent ( i = 2 : npl , pl % lmask ( i )) ah1j (:) = pl % xj (:, i ) * pl % ir3j ( i ) ah1h (:) = pl % xh (:, i ) * pl % ir3h ( i ) pl % ah (:, i ) = pl % ah (:, i ) + cb % Gmass * ( ah1j (:) - ah1h (:)) end do end associate return end subroutine whm_kick_getacch_ah1 pure subroutine whm_kick_getacch_ah2 ( cb , pl ) !! author: David A. Minton !! !! Compute second term heliocentric accelerations of planets !! !! Adapted from Hal Levison's Swift routine getacch_ah2.f !! Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah2.f90 implicit none ! Arguments class ( swiftest_cb ), intent ( in ) :: cb !! Swiftest central body object class ( whm_pl ), intent ( inout ) :: pl !! WHM massive body object ! Internals integer ( I4B ) :: i real ( DP ) :: etaj , fac real ( DP ), dimension ( NDIM ) :: ah2 , ah2o associate ( npl => pl % nbody ) ah2 (:) = 0.0_DP ah2o (:) = 0.0_DP etaj = cb % Gmass do concurrent ( i = 2 : npl , pl % lmask ( i )) etaj = etaj + pl % Gmass ( i - 1 ) fac = pl % Gmass ( i ) * cb % Gmass * pl % ir3j ( i ) / etaj ah2 (:) = ah2o + fac * pl % xj (:, i ) pl % ah (:, i ) = pl % ah (:, i ) + ah2 (:) ah2o (:) = ah2 (:) end do end associate return end subroutine whm_kick_getacch_ah2 module subroutine whm_kick_vh_pl ( self , system , param , t , dt , lbeg ) !! author: David A. Minton !! !! Kick heliocentric velocities of massive bodies !! !! Adapted from Martin Duncan and Hal Levison's Swift routine kickvh.f !! Adapted from David E. Kaufmann's Swifter routine whm_kickvh.f90 implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Logical flag indicating whether this is the beginning of the half step or not. ! Internals integer ( I4B ) :: i associate ( pl => self , npl => self % nbody , cb => system % cb ) if ( npl == 0 ) return if ( lbeg ) then if ( pl % lfirst ) then call pl % h2j ( cb ) pl % ah (:, 1 : npl ) = 0.0_DP call pl % accel ( system , param , t , lbeg ) pl % lfirst = . false . end if call pl % set_beg_end ( xbeg = pl % xh ) else pl % ah (:, 1 : npl ) = 0.0_DP call pl % accel ( system , param , t , lbeg ) call pl % set_beg_end ( xend = pl % xh ) end if do concurrent ( i = 1 : npl , pl % lmask ( i )) pl % vh (:, i ) = pl % vh (:, i ) + pl % ah (:, i ) * dt end do end associate return end subroutine whm_kick_vh_pl module subroutine whm_kick_vh_tp ( self , system , param , t , dt , lbeg ) !! author: David A. Minton !! !! Kick heliocentric velocities of test particles !! !! Adapted from Martin Duncan and Hal Levison's Swift routine kickvh_tp.f !! Adapted from David E. Kaufmann's Swifter routine whm_kickvh_tp.f90 implicit none ! Arguments class ( whm_tp ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Logical flag indicating whether this is the beginning of the half step or not. ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) if ( tp % lfirst ) then do concurrent ( i = 1 : ntp , tp % lmask ( i )) tp % ah (:, i ) = 0.0_DP end do call tp % accel ( system , param , t , lbeg = . true .) tp % lfirst = . false . end if if (. not . lbeg ) then do concurrent ( i = 1 : ntp , tp % lmask ( i )) tp % ah (:, i ) = 0.0_DP end do call tp % accel ( system , param , t , lbeg ) end if do concurrent ( i = 1 : ntp , tp % lmask ( i )) tp % vh (:, i ) = tp % vh (:, i ) + tp % ah (:, i ) * dt end do end associate return end subroutine whm_kick_vh_tp end submodule s_whm_kick","tags":"","loc":"sourcefile/whm_kick.f90.html"},{"title":"whm_setup.f90 – swiftest","text":"This file depends on sourcefile~~whm_setup.f90~~EfferentGraph sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~whm_setup.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_whm_setup Source Code whm_setup.f90 Source Code submodule ( whm_classes ) s_whm_setup use swiftest contains module subroutine whm_setup_pl ( self , n , param ) !! author: David A. Minton !! !! Allocate WHM planet structure !! !! Equivalent in functionality to David E. Kaufmann's Swifter routine whm_setup.f90 implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! Swiftest test particle object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameter !> Call allocation method for parent class call setup_pl ( self , n , param ) if ( n < 0 ) return if ( allocated ( self % eta )) deallocate ( self % eta ) if ( allocated ( self % muj )) deallocate ( self % muj ) if ( allocated ( self % xj )) deallocate ( self % xj ) if ( allocated ( self % vj )) deallocate ( self % vj ) if ( allocated ( self % ir3j )) deallocate ( self % ir3j ) if ( n == 0 ) return allocate ( self % eta ( n )) allocate ( self % muj ( n )) allocate ( self % xj ( NDIM , n )) allocate ( self % vj ( NDIM , n )) allocate ( self % ir3j ( n )) self % eta (:) = 0.0_DP self % muj (:) = 0.0_DP self % xj (:,:) = 0.0_DP self % vj (:,:) = 0.0_DP self % ir3j (:) = 0.0_DP return end subroutine whm_setup_pl module subroutine whm_util_set_mu_eta_pl ( self , cb ) !! author: David A. Minton !! !! Sets the Jacobi mass value eta for all massive bodies implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM system object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object ! Internals integer ( I4B ) :: i associate ( pl => self , npl => self % nbody ) if ( npl == 0 ) return call util_set_mu_pl ( pl , cb ) pl % eta ( 1 ) = cb % Gmass + pl % Gmass ( 1 ) pl % muj ( 1 ) = pl % eta ( 1 ) do i = 2 , npl pl % eta ( i ) = pl % eta ( i - 1 ) + pl % Gmass ( i ) pl % muj ( i ) = cb % Gmass * pl % eta ( i ) / pl % eta ( i - 1 ) end do end associate return end subroutine whm_util_set_mu_eta_pl module subroutine whm_setup_initialize_system ( self , param ) !! author: David A. Minton !! !! Initialize a WHM nbody system from files !! implicit none ! Arguments class ( whm_nbody_system ), intent ( inout ) :: self !! WHM nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters call setup_initialize_system ( self , param ) ! First we need to make sure that the massive bodies are sorted by heliocentric distance before computing jacobies call util_set_ir3h ( self % pl ) call self % pl % sort ( \"ir3h\" , ascending = . false .) call self % pl % index ( param ) ! Make sure that the discard list gets allocated initially call self % tp_discards % setup ( 0 , param ) call self % pl % set_mu ( self % cb ) call self % tp % set_mu ( self % cb ) if ( param % lgr ) then call self % pl % v2pv ( param ) call self % tp % v2pv ( param ) end if return end subroutine whm_setup_initialize_system end submodule s_whm_setup","tags":"","loc":"sourcefile/whm_setup.f90.html"},{"title":"whm_util.f90 – swiftest","text":"This file depends on sourcefile~~whm_util.f90~~EfferentGraph sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~whm_util.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_whm_util Source Code whm_util.f90 Source Code submodule ( whm_classes ) s_whm_util use swiftest contains module subroutine whm_util_append_pl ( self , source , lsource_mask ) !! author: David A. Minton !! !! Append components from one massive body object to another. !! This method will automatically resize the destination body if it is too small implicit none !! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to select type ( source ) class is ( whm_pl ) associate ( nold => self % nbody , nsrc => source % nbody ) call util_append ( self % eta , source % eta , nold , nsrc , lsource_mask ) call util_append ( self % muj , source % muj , nold , nsrc , lsource_mask ) call util_append ( self % ir3j , source % ir3j , nold , nsrc , lsource_mask ) call util_append ( self % xj , source % xj , nold , nsrc , lsource_mask ) call util_append ( self % vj , source % vj , nold , nsrc , lsource_mask ) call util_append_pl ( self , source , lsource_mask ) end associate class default write ( * , * ) \"Invalid object passed to the append method. Source must be of class whm_pl or its descendents\" call util_exit ( FAILURE ) end select return end subroutine whm_util_append_pl module subroutine whm_util_fill_pl ( self , inserts , lfill_list ) !! author: David A. Minton !! !! Insert new WHM test particle structure into an old one. !! This is the inverse of a fill operation. !! !! Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_body ), intent ( in ) :: inserts !! inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps ! Internals integer ( I4B ) :: i associate ( keeps => self ) select type ( inserts ) class is ( whm_pl ) call util_fill ( keeps % eta , inserts % eta , lfill_list ) call util_fill ( keeps % muj , inserts % muj , lfill_list ) call util_fill ( keeps % ir3j , inserts % ir3j , lfill_list ) call util_fill ( keeps % xj , inserts % xj , lfill_list ) call util_fill ( keeps % vj , inserts % vj , lfill_list ) call util_fill_pl ( keeps , inserts , lfill_list ) class default write ( * , * ) \"Invalid object passed to the fill method. Inserts must be of class whm_pl or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine whm_util_fill_pl module subroutine whm_util_resize_pl ( self , nnew ) !! author: David A. Minton !! !! Checks the current size of a massive body against the requested size and resizes it if it is too small. implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object integer ( I4B ), intent ( in ) :: nnew !! New size neded call util_resize ( self % eta , nnew ) call util_resize ( self % xj , nnew ) call util_resize ( self % vj , nnew ) call util_resize ( self % muj , nnew ) call util_resize ( self % ir3j , nnew ) call util_resize_pl ( self , nnew ) return end subroutine whm_util_resize_pl module subroutine whm_util_set_ir3j ( self ) !! author: David A. Minton !! !! Sets the inverse Jacobi and heliocentric radii cubed (1/rj**3 and 1/rh**3) implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object ! Internals integer ( I4B ) :: i real ( DP ) :: r2 , ir if ( self % nbody > 0 ) then do i = 1 , self % nbody r2 = dot_product ( self % xh (:, i ), self % xh (:, i )) ir = 1.0_DP / sqrt ( r2 ) self % ir3h ( i ) = ir / r2 r2 = dot_product ( self % xj (:, i ), self % xj (:, i )) ir = 1.0_DP / sqrt ( r2 ) self % ir3j ( i ) = ir / r2 end do end if return end subroutine whm_util_set_ir3j module subroutine whm_util_sort_pl ( self , sortby , ascending ) !! author: David A. Minton !! !! Sort a WHM massive body object in-place. !! sortby is a string indicating which array component to sort. implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order ! Internals integer ( I4B ), dimension (:), allocatable :: ind integer ( I4B ) :: direction if ( self % nbody == 0 ) return if ( ascending ) then direction = 1 else direction = - 1 end if associate ( pl => self , npl => self % nbody ) allocate ( ind ( npl )) select case ( sortby ) case ( \"eta\" ) call util_sort ( direction * pl % eta ( 1 : npl ), ind ( 1 : npl )) case ( \"muj\" ) call util_sort ( direction * pl % muj ( 1 : npl ), ind ( 1 : npl )) case ( \"ir3j\" ) call util_sort ( direction * pl % ir3j ( 1 : npl ), ind ( 1 : npl )) case ( \"xj\" , \"vj\" ) write ( * , * ) 'Cannot sort by ' // trim ( adjustl ( sortby )) // '. Component not sortable!' case default call util_sort_pl ( pl , sortby , ascending ) return end select call pl % rearrange ( ind ) end associate return end subroutine whm_util_sort_pl module subroutine whm_util_sort_rearrange_pl ( self , ind ) !! author: David A. Minton !! !! Rearrange WHM massive body structure in-place from an index list. !! This is a helper utility used to make polymorphic sorting work on Swiftest structures. implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) call util_sort_rearrange ( pl % eta , ind , npl ) call util_sort_rearrange ( pl % xj , ind , npl ) call util_sort_rearrange ( pl % vj , ind , npl ) call util_sort_rearrange ( pl % muj , ind , npl ) call util_sort_rearrange ( pl % ir3j , ind , npl ) call util_sort_rearrange_pl ( pl , ind ) end associate return end subroutine whm_util_sort_rearrange_pl module subroutine whm_util_spill_pl ( self , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Move spilled (discarded) WHM test particle structure from active list to discard list !! !! Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 implicit none ! Arguments class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not ! Internals integer ( I4B ) :: i associate ( keeps => self ) select type ( discards ) class is ( whm_pl ) call util_spill ( keeps % eta , discards % eta , lspill_list , ldestructive ) call util_spill ( keeps % muj , discards % muj , lspill_list , ldestructive ) call util_spill ( keeps % ir3j , discards % ir3j , lspill_list , ldestructive ) call util_spill ( keeps % xj , discards % xj , lspill_list , ldestructive ) call util_spill ( keeps % vj , discards % vj , lspill_list , ldestructive ) call util_spill_pl ( keeps , discards , lspill_list , ldestructive ) class default write ( * , * ) \"Invalid object passed to the spill method. Source must be of class whm_pl or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine whm_util_spill_pl end submodule s_whm_util","tags":"","loc":"sourcefile/whm_util.f90.html"},{"title":"operator_cross.f90 – swiftest","text":"This file depends on sourcefile~~operator_cross.f90~~EfferentGraph sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~operator_cross.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_operator_cross Source Code operator_cross.f90 Source Code submodule ( swiftest_operators ) s_operator_cross use swiftest !! author: David A. Minton !! !! Contains implementations for the .cross. operator for all defined integer and real types !! Single vector implementations: C(1:3)   = A(1:3)   .cross. B(1:3) !! Vector list implementations:   C(1:3, :) = A(1:3, :) .cross. B(1:3, :) contains module pure function operator_cross_sp ( A , B ) result ( C ) implicit none real ( SP ), dimension (:), intent ( in ) :: A , B real ( SP ), dimension ( 3 ) :: C C ( 1 ) = A ( 2 ) * B ( 3 ) - A ( 3 ) * B ( 2 ) C ( 2 ) = A ( 3 ) * B ( 1 ) - A ( 1 ) * B ( 3 ) C ( 3 ) = A ( 1 ) * B ( 2 ) - A ( 2 ) * B ( 1 ) return end function operator_cross_sp module pure function operator_cross_dp ( A , B ) result ( C ) implicit none real ( DP ), dimension (:), intent ( in ) :: A , B real ( DP ), dimension ( 3 ) :: C C ( 1 ) = A ( 2 ) * B ( 3 ) - A ( 3 ) * B ( 2 ) C ( 2 ) = A ( 3 ) * B ( 1 ) - A ( 1 ) * B ( 3 ) C ( 3 ) = A ( 1 ) * B ( 2 ) - A ( 2 ) * B ( 1 ) return end function operator_cross_dp module pure function operator_cross_qp ( A , B ) result ( C ) implicit none real ( QP ), dimension (:), intent ( in ) :: A , B real ( QP ), dimension ( 3 ) :: C C ( 1 ) = A ( 2 ) * B ( 3 ) - A ( 3 ) * B ( 2 ) C ( 2 ) = A ( 3 ) * B ( 1 ) - A ( 1 ) * B ( 3 ) C ( 3 ) = A ( 1 ) * B ( 2 ) - A ( 2 ) * B ( 1 ) return end function operator_cross_qp module pure function operator_cross_i1b ( A , B ) result ( C ) implicit none integer ( I1B ), dimension (:), intent ( in ) :: A , B integer ( I1B ), dimension ( 3 ) :: C C ( 1 ) = A ( 2 ) * B ( 3 ) - A ( 3 ) * B ( 2 ) C ( 2 ) = A ( 3 ) * B ( 1 ) - A ( 1 ) * B ( 3 ) C ( 3 ) = A ( 1 ) * B ( 2 ) - A ( 2 ) * B ( 1 ) return end function operator_cross_i1b module pure function operator_cross_i2b ( A , B ) result ( C ) implicit none integer ( I2B ), dimension (:), intent ( in ) :: A , B integer ( I2B ), dimension ( 3 ) :: C C ( 1 ) = A ( 2 ) * B ( 3 ) - A ( 3 ) * B ( 2 ) C ( 2 ) = A ( 3 ) * B ( 1 ) - A ( 1 ) * B ( 3 ) C ( 3 ) = A ( 1 ) * B ( 2 ) - A ( 2 ) * B ( 1 ) return end function operator_cross_i2b module pure function operator_cross_i4b ( A , B ) result ( C ) implicit none integer ( I4B ), dimension (:), intent ( in ) :: A , B integer ( I4B ), dimension ( 3 ) :: C C ( 1 ) = A ( 2 ) * B ( 3 ) - A ( 3 ) * B ( 2 ) C ( 2 ) = A ( 3 ) * B ( 1 ) - A ( 1 ) * B ( 3 ) C ( 3 ) = A ( 1 ) * B ( 2 ) - A ( 2 ) * B ( 1 ) return end function operator_cross_i4b module pure function operator_cross_i8b ( A , B ) result ( C ) implicit none integer ( I8B ), dimension (:), intent ( in ) :: A , B integer ( I8B ), dimension ( 3 ) :: C C ( 1 ) = A ( 2 ) * B ( 3 ) - A ( 3 ) * B ( 2 ) C ( 2 ) = A ( 3 ) * B ( 1 ) - A ( 1 ) * B ( 3 ) C ( 3 ) = A ( 1 ) * B ( 2 ) - A ( 2 ) * B ( 1 ) return end function operator_cross_i8b module pure function operator_cross_el_sp ( A , B ) result ( C ) implicit none real ( SP ), dimension (:,:), intent ( in ) :: A , B real ( SP ), dimension (:,:), allocatable :: C integer ( I4B ) :: i , n n = size ( A , 2 ) if ( allocated ( C )) deallocate ( C ) allocate ( C , mold = A ) do concurrent ( i = 1 : n ) C ( 1 , i ) = A ( 2 , i ) * B ( 3 , i ) - A ( 3 , i ) * B ( 2 , i ) C ( 2 , i ) = A ( 3 , i ) * B ( 1 , i ) - A ( 1 , i ) * B ( 3 , i ) C ( 3 , i ) = A ( 1 , i ) * B ( 2 , i ) - A ( 2 , i ) * B ( 1 , i ) end do return end function operator_cross_el_sp module pure function operator_cross_el_dp ( A , B ) result ( C ) implicit none real ( DP ), dimension (:,:), intent ( in ) :: A , B real ( DP ), dimension (:,:), allocatable :: C integer ( I4B ) :: i , n n = size ( A , 2 ) if ( allocated ( C )) deallocate ( C ) allocate ( C , mold = A ) do concurrent ( i = 1 : n ) C ( 1 , i ) = A ( 2 , i ) * B ( 3 , i ) - A ( 3 , i ) * B ( 2 , i ) C ( 2 , i ) = A ( 3 , i ) * B ( 1 , i ) - A ( 1 , i ) * B ( 3 , i ) C ( 3 , i ) = A ( 1 , i ) * B ( 2 , i ) - A ( 2 , i ) * B ( 1 , i ) end do return end function operator_cross_el_dp module pure function operator_cross_el_qp ( A , B ) result ( C ) implicit none real ( QP ), dimension (:,:), intent ( in ) :: A , B real ( QP ), dimension (:,:), allocatable :: C integer ( I4B ) :: i , n n = size ( A , 2 ) if ( allocated ( C )) deallocate ( C ) allocate ( C , mold = A ) do concurrent ( i = 1 : n ) C ( 1 , i ) = A ( 2 , i ) * B ( 3 , i ) - A ( 3 , i ) * B ( 2 , i ) C ( 2 , i ) = A ( 3 , i ) * B ( 1 , i ) - A ( 1 , i ) * B ( 3 , i ) C ( 3 , i ) = A ( 1 , i ) * B ( 2 , i ) - A ( 2 , i ) * B ( 1 , i ) end do return end function operator_cross_el_qp module pure function operator_cross_el_i1b ( A , B ) result ( C ) implicit none integer ( I1B ), dimension (:,:), intent ( in ) :: A , B integer ( I1B ), dimension (:,:), allocatable :: C integer ( I4B ) :: i , n n = size ( A , 2 ) if ( allocated ( C )) deallocate ( C ) allocate ( C , mold = A ) do concurrent ( i = 1 : n ) C ( 1 , i ) = A ( 2 , i ) * B ( 3 , i ) - A ( 3 , i ) * B ( 2 , i ) C ( 2 , i ) = A ( 3 , i ) * B ( 1 , i ) - A ( 1 , i ) * B ( 3 , i ) C ( 3 , i ) = A ( 1 , i ) * B ( 2 , i ) - A ( 2 , i ) * B ( 1 , i ) end do return end function operator_cross_el_i1b module pure function operator_cross_el_i2b ( A , B ) result ( C ) implicit none integer ( I2B ), dimension (:,:), intent ( in ) :: A , B integer ( I2B ), dimension (:,:), allocatable :: C integer ( I4B ) :: i , n n = size ( A , 2 ) if ( allocated ( C )) deallocate ( C ) allocate ( C , mold = A ) do concurrent ( i = 1 : n ) C ( 1 , i ) = A ( 2 , i ) * B ( 3 , i ) - A ( 3 , i ) * B ( 2 , i ) C ( 2 , i ) = A ( 3 , i ) * B ( 1 , i ) - A ( 1 , i ) * B ( 3 , i ) C ( 3 , i ) = A ( 1 , i ) * B ( 2 , i ) - A ( 2 , i ) * B ( 1 , i ) end do return end function operator_cross_el_i2b module pure function operator_cross_el_i4b ( A , B ) result ( C ) implicit none integer ( I4B ), dimension (:,:), intent ( in ) :: A , B integer ( I4B ), dimension (:,:), allocatable :: C integer ( I4B ) :: i , n n = size ( A , 2 ) if ( allocated ( C )) deallocate ( C ) allocate ( C , mold = A ) do concurrent ( i = 1 : n ) C ( 1 , i ) = A ( 2 , i ) * B ( 3 , i ) - A ( 3 , i ) * B ( 2 , i ) C ( 2 , i ) = A ( 3 , i ) * B ( 1 , i ) - A ( 1 , i ) * B ( 3 , i ) C ( 3 , i ) = A ( 1 , i ) * B ( 2 , i ) - A ( 2 , i ) * B ( 1 , i ) end do return end function operator_cross_el_i4b module pure function operator_cross_el_i8b ( A , B ) result ( C ) implicit none integer ( I8B ), dimension (:,:), intent ( in ) :: A , B integer ( I8B ), dimension (:,:), allocatable :: C integer ( I4B ) :: i , n n = size ( A , 2 ) if ( allocated ( C )) deallocate ( C ) allocate ( C , mold = A ) do concurrent ( i = 1 : n ) C ( 1 , i ) = A ( 2 , i ) * B ( 3 , i ) - A ( 3 , i ) * B ( 2 , i ) C ( 2 , i ) = A ( 3 , i ) * B ( 1 , i ) - A ( 1 , i ) * B ( 3 , i ) C ( 3 , i ) = A ( 1 , i ) * B ( 2 , i ) - A ( 2 , i ) * B ( 1 , i ) end do return end function operator_cross_el_i8b end submodule s_operator_cross","tags":"","loc":"sourcefile/operator_cross.f90.html"},{"title":"operator_mag.f90 – swiftest","text":"This file depends on sourcefile~~operator_mag.f90~~EfferentGraph sourcefile~operator_mag.f90 operator_mag.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~operator_mag.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_operator_mag Source Code operator_mag.f90 Source Code submodule ( swiftest_operators ) s_operator_mag !! author: David A. Minton !! !! Contains implementations for the .mag. operator for all defined real types !! Single vector implementations:  B   = .mag. A(1:3) !! Vector list implementations:   B(:) = .mag. A(1:3, :) contains module pure function operator_mag_sp ( A ) result ( B ) implicit none real ( SP ), dimension (:), intent ( in ) :: A real ( SP ) :: B B = norm2 ( A (:)) return end function operator_mag_sp module pure function operator_mag_dp ( A ) result ( B ) implicit none real ( DP ), dimension (:), intent ( in ) :: A real ( DP ) :: B B = norm2 ( A (:)) return end function operator_mag_dp module pure function operator_mag_el_sp ( A ) result ( B ) implicit none real ( SP ), dimension (:,:), intent ( in ) :: A real ( SP ), dimension (:), allocatable :: B integer ( I4B ) :: i , n n = size ( A , 2 ) if ( allocated ( B )) deallocate ( B ) allocate ( B ( n )) do concurrent ( i = 1 : n ) B ( i ) = norm2 ( A (:, i )) end do return end function operator_mag_el_sp module pure function operator_mag_el_dp ( A ) result ( B ) implicit none real ( DP ), dimension (:,:), intent ( in ) :: A real ( DP ), dimension (:), allocatable :: B integer ( I4B ) :: i , n n = size ( A , 2 ) if ( allocated ( B )) deallocate ( B ) allocate ( B ( n )) do concurrent ( i = 1 : n ) B ( i ) = norm2 ( A (:, i )) end do return end function operator_mag_el_dp module pure function operator_mag_el_qp ( A ) result ( B ) implicit none real ( QP ), dimension (:,:), intent ( in ) :: A real ( QP ), dimension (:), allocatable :: B integer ( I4B ) :: i , n n = size ( A , 2 ) if ( allocated ( B )) deallocate ( B ) allocate ( B ( n )) do concurrent ( i = 1 : n ) B ( i ) = norm2 ( A (:, i )) end do return end function operator_mag_el_qp end submodule s_operator_mag","tags":"","loc":"sourcefile/operator_mag.f90.html"},{"title":"util_solve.f90 – swiftest","text":"This file depends on sourcefile~~util_solve.f90~~EfferentGraph sourcefile~util_solve.f90 util_solve.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_solve.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_solve Source Code util_solve.f90 Source Code submodule ( swiftest_classes ) s_util_solve use swiftest contains module function util_solve_linear_system_d ( A , b , n , lerr ) result ( x ) !! Author: David A. Minton !! !! Solves the linear equation of the form A*x = b for x. !!   A is an (n,n) arrays !!   x and b are (n) arrays !! Uses Gaussian elimination, so will have issues if system is ill-conditioned. !! Uses quad precision intermidiate values, so works best on small arrays. use , intrinsic :: ieee_exceptions implicit none ! Arguments integer ( I4B ), intent ( in ) :: n real ( DP ), dimension (:,:), intent ( in ) :: A real ( DP ), dimension (:), intent ( in ) :: b logical , intent ( out ) :: lerr ! Result real ( DP ), dimension ( n ) :: x ! Internals real ( QP ), dimension (:), allocatable :: qx type ( ieee_status_type ) :: original_fpe_status logical , dimension (:), allocatable :: fpe_flag call ieee_get_status ( original_fpe_status ) ! Save the original floating point exception status call ieee_set_flag ( ieee_all , . false .) ! Set all flags to quiet allocate ( fpe_flag ( size ( ieee_usual ))) qx = solve_wbs ( ge_wpp ( real ( A , kind = QP ), real ( b , kind = QP ))) call ieee_get_flag ( ieee_usual , fpe_flag ) lerr = any ( fpe_flag ) if ( lerr . or . ( any ( abs ( qx ) > huge ( x ))) . or . ( any ( abs ( qx ) < tiny ( x )))) then x = 0.0_DP else x = real ( qx , kind = DP ) end if call ieee_set_status ( original_fpe_status ) return end function util_solve_linear_system_d module function util_solve_linear_system_q ( A , b , n , lerr ) result ( x ) !! Author: David A. Minton !! !! Solves the linear equation of the form A*x = b for x. !!   A is an (n,n) arrays !!   x and b are (n) arrays !! Uses Gaussian elimination, so will have issues if system is ill-conditioned. !! Uses quad precision intermidiate values, so works best on small arrays. use , intrinsic :: ieee_exceptions implicit none ! Arguments integer ( I4B ), intent ( in ) :: n real ( QP ), dimension (:,:), intent ( in ) :: A real ( QP ), dimension (:), intent ( in ) :: b logical , intent ( out ) :: lerr ! Result real ( QP ), dimension ( n ) :: x ! Internals type ( ieee_status_type ) :: original_fpe_status logical , dimension (:), allocatable :: fpe_flag call ieee_get_status ( original_fpe_status ) ! Save the original floating point exception status call ieee_set_flag ( ieee_all , . false .) ! Set all flags to quiet allocate ( fpe_flag ( size ( ieee_usual ))) x = solve_wbs ( ge_wpp ( A , b )) call ieee_get_flag ( ieee_usual , fpe_flag ) lerr = any ( fpe_flag ) if ( lerr ) x = 0.0_DP call ieee_set_status ( original_fpe_status ) return end function util_solve_linear_system_q function solve_wbs ( u ) result ( x ) ! solve with backward substitution !! Based on code available on Rosetta Code: https://rosettacode.org/wiki/Gaussian_elimination#Fortran use , intrinsic :: ieee_exceptions use swiftest implicit none ! Arguments real ( QP ), intent ( in ), dimension (:,:), allocatable :: u ! Result real ( QP ), dimension (:), allocatable :: x ! Internals integer ( I4B ) :: i , n n = size ( u , 1 ) if ( allocated ( x )) deallocate ( x ) if (. not . allocated ( x )) allocate ( x ( n )) if ( any ( abs ( u ) < tiny ( 1._DP )) . or . any ( abs ( u ) > huge ( 1._DP ))) then x (:) = 0._DP return end if call ieee_set_halting_mode ( ieee_divide_by_zero , . false .) do i = n , 1 , - 1 x ( i ) = ( u ( i , n + 1 ) - sum ( u ( i , i + 1 : n ) * x ( i + 1 : n ))) / u ( i , i ) end do return end function solve_wbs function ge_wpp ( A , b ) result ( u ) ! gaussian eliminate with partial pivoting !! Solve  Ax=b  using Gaussian elimination then backwards substitution. !!   A being an n by n matrix. !!   x and b are n by 1 vectors. !! Based on code available on Rosetta Code: https://rosettacode.org/wiki/Gaussian_elimination#Fortran use , intrinsic :: ieee_exceptions use swiftest implicit none ! Arguments real ( QP ), dimension (:,:), intent ( in ) :: A real ( QP ), dimension (:), intent ( in ) :: b ! Result real ( QP ), dimension (:,:), allocatable :: u ! Internals integer ( I4B ) :: i , j , n , p real ( QP ) :: upi n = size ( a , 1 ) allocate ( u ( n , ( n + 1 ))) u = reshape ([ A , b ], [ n , n + 1 ]) call ieee_set_halting_mode ( ieee_divide_by_zero , . false .) do j = 1 , n p = maxloc ( abs ( u ( j : n , j )), 1 ) + j - 1 ! maxloc returns indices between (1, n - j + 1) if ( p /= j ) u ([ p , j ], j ) = u ([ j , p ], j ) u ( j + 1 :, j ) = u ( j + 1 :, j ) / u ( j , j ) do i = j + 1 , n + 1 upi = u ( p , i ) if ( p /= j ) u ([ p , j ], i ) = u ([ j , p ], i ) u ( j + 1 : n , i ) = u ( j + 1 : n , i ) - upi * u ( j + 1 : n , j ) end do end do return end function ge_wpp module function util_solve_rkf45 ( f , y0in , t1 , dt0 , tol ) result ( y1 ) !! author: David A. Minton !! !! Implements the 4th order Runge-Kutta-Fehlberg ODE solver for initial value problems of the form f=dy/dt, y0 = y(t=0), solving for y1 = y(t=t1). Uses a 5th order adaptive step size control. !! Uses a lambda function object as defined in the lambda_function module implicit none ! Arguments class ( lambda_obj ), intent ( inout ) :: f !! lambda function object that has been initialized to be a function of derivatives. The object will return with components lastarg and lasteval set real ( DP ), dimension (:), intent ( in ) :: y0in !! Initial value at t=0 real ( DP ), intent ( in ) :: t1 !! Final time real ( DP ), intent ( in ) :: dt0 !! Initial step size guess real ( DP ), intent ( in ) :: tol !! Tolerance on solution ! Result real ( DP ), dimension (:), allocatable :: y1 !! Final result ! Internals integer ( I4B ), parameter :: MAXREDUX = 1000 !! Maximum number of times step size can be reduced real ( DP ), parameter :: DTFAC = 0.95_DP !! Step size reduction safety factor (Value just under 1.0 to prevent adaptive step size control from discarding steps too aggressively) integer ( I4B ), parameter :: RKS = 6 !! Number of RK stages real ( DP ), dimension ( RKS , RKS - 1 ), parameter :: rkf45_btab = reshape ( & !! Butcher tableau for Runge-Kutta-Fehlberg method ( / 1. / 4. , 1. / 4. , 0. , 0. , 0. , 0. ,& 3. / 8. , 3. / 3 2. , 9. / 3 2. , 0. , 0. , 0. ,& 1 2. / 1 3. , 193 2. / 219 7. , - 720 0. / 219 7. , 729 6. / 219 7. , 0. , 0. ,& 1. , 43 9. / 21 6. , - 8. , 368 0. / 51 3. , - 84 5. / 410 4. , 0. ,& 1. / 2. , - 8. / 2 7. , 2. , - 354 4. / 256 5. , 185 9. / 410 4. , - 1 1. / 4 0. / ), shape ( rkf45_btab )) real ( DP ), dimension ( RKS ), parameter :: rkf4_coeff = ( / 2 5. / 21 6. , 0. , 140 8. / 256 5. , 219 7. / 410 4. , - 1. / 5. , 0. / ) real ( DP ), dimension ( RKS ), parameter :: rkf5_coeff = ( / 1 6. / 13 5. , 0. , 665 6. / 1282 5. , 2856 1. / 5643 0. , - 9. / 5 0. , 2. / 5 5. / ) real ( DP ), dimension (:, :), allocatable :: k !! Runge-Kutta coefficient vector real ( DP ), dimension (:), allocatable :: ynorm !! Normalized y value used for adaptive step size control real ( DP ), dimension (:), allocatable :: y0 !! Value of y at the beginning of each substep integer ( I4B ) :: Nvar !! Number of variables in problem integer ( I4B ) :: rkn !! Runge-Kutta loop index real ( DP ) :: t , x1 , dt , trem !! Current time, step size and total time remaining real ( DP ) :: s , yerr , yscale !!  Step size reduction factor, error in dependent variable, and error scale factor integer ( I4B ) :: i , n allocate ( y0 , source = y0in ) allocate ( y1 , mold = y0 ) allocate ( ynorm , mold = y0 ) Nvar = size ( y0 ) allocate ( k ( Nvar , RKS )) dt = dt0 trem = t1 t = 0._DP do yscale = norm2 ( y0 (:)) do i = 1 , MAXREDUX select type ( f ) class is ( lambda_obj_tvar ) do rkn = 1 , RKS y1 (:) = y0 (:) + matmul ( k (:, 1 : rkn - 1 ), rkf45_btab ( 2 : rkn , rkn - 1 )) if ( rkn == 1 ) then x1 = t else x1 = t + rkf45_btab ( 1 , rkn - 1 ) end if k (:, rkn ) = dt * f % evalt ( y1 (:), t ) end do class is ( lambda_obj ) do rkn = 1 , RKS y1 (:) = y0 (:) + matmul ( k (:, 1 : rkn - 1 ), rkf45_btab ( 2 : rkn , rkn - 1 )) k (:, rkn ) = dt * f % eval ( y1 (:)) end do end select ! Now determine if the step size needs adjusting ynorm (:) = matmul ( k (:,:), ( rkf5_coeff (:) - rkf4_coeff (:))) / yscale yerr = norm2 ( ynorm (:)) s = ( tol / ( 2 * yerr )) ** ( 0.25_DP ) dt = min ( s * DTFAC * dt , trem ) ! Alter step size either up or down, but never bigger than the remaining time if ( s >= 1.0_DP ) exit ! Good step! if ( i == MAXREDUX ) then write ( * , * ) \"Something has gone wrong in util_solve_rkf45!! Step size reduction has gone too far this time!\" call util_exit ( FAILURE ) end if end do ! Compute new value then step ahead in time y1 (:) = y0 (:) + matmul ( k (:, :), rkf4_coeff (:)) trem = trem - dt t = t + dt if ( trem <= 0._DP ) exit y0 (:) = y1 (:) end do return end function util_solve_rkf45 end submodule s_util_solve","tags":"","loc":"sourcefile/util_solve.f90.html"},{"title":"util_set.f90 – swiftest","text":"This file depends on sourcefile~~util_set.f90~~EfferentGraph sourcefile~util_set.f90 util_set.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_set.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_set Source Code util_set.f90 Source Code submodule ( swiftest_classes ) s_util_set !! author: David A. Minton !! This submodule contains a collection of setter method implementations use swiftest contains module subroutine util_set_beg_end_pl ( self , xbeg , xend , vbeg ) !! author: David A. Minton !! !! Sets one or more of the values of xbeg, xend, and vbeg implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object real ( DP ), dimension (:,:), intent ( in ), optional :: xbeg , xend , vbeg if ( present ( xbeg )) then if ( allocated ( self % xbeg )) deallocate ( self % xbeg ) allocate ( self % xbeg , source = xbeg ) end if if ( present ( xend )) then if ( allocated ( self % xend )) deallocate ( self % xend ) allocate ( self % xend , source = xend ) end if if ( present ( vbeg )) then if ( allocated ( self % vbeg )) deallocate ( self % vbeg ) allocate ( self % vbeg , source = vbeg ) end if return end subroutine util_set_beg_end_pl module subroutine util_set_ir3h ( self ) !! author: David A. Minton !! !! Sets the inverse heliocentric radius term (1/rh**3) for all bodies in a structure implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest generic body object ! Internals integer ( I4B ) :: i real ( DP ) :: r2 , irh if ( self % nbody > 0 ) then do i = 1 , self % nbody r2 = dot_product ( self % xh (:, i ), self % xh (:, i )) irh = 1.0_DP / sqrt ( r2 ) self % ir3h ( i ) = irh / r2 end do end if return end subroutine util_set_ir3h module subroutine util_set_msys ( self ) !! author: David A. Minton !! !! Sets the value of msys and the vector mass quantities based on the total mass of the system implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nobdy system object self % Gmtot = self % cb % Gmass + sum ( self % pl % Gmass ( 1 : self % pl % nbody ), self % pl % status ( 1 : self % pl % nbody ) /= INACTIVE ) return end subroutine util_set_msys module subroutine util_set_mu_pl ( self , cb ) !! author: David A. Minton !! !! Computes G * (M + m) for each massive body implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object if ( self % nbody > 0 ) self % mu ( 1 : self % nbody ) = cb % Gmass + self % Gmass ( 1 : self % nbody ) return end subroutine util_set_mu_pl module subroutine util_set_mu_tp ( self , cb ) !! author: David A. Minton !! !! Converts certain scalar values to arrays so that they can be used in elemental functions implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object if ( self % nbody == 0 ) return self % mu ( 1 : self % nbody ) = cb % Gmass return end subroutine util_set_mu_tp module subroutine util_set_particle_info ( self , name , particle_type , status , origin_type , origin_time , origin_xh , origin_vh , discard_time , discard_xh , discard_vh , discard_body_id ) !! author: David A. Minton !! !! Sets one or more values of the particle information metadata object implicit none ! Arguments class ( swiftest_particle_info ), intent ( inout ) :: self character ( len =* ), intent ( in ), optional :: name !! Non-unique name character ( len =* ), intent ( in ), optional :: particle_type !! String containing a description of the particle type (e.g. Central Body, Massive Body, Test Particle) character ( len =* ), intent ( in ), optional :: status !! Particle status description: ACTIVE, MERGED, FRAGMENTED, etc. character ( len =* ), intent ( in ), optional :: origin_type !! String containing a description of the origin of the particle (e.g. Initial Conditions, Supercatastrophic, Disruption, etc.) real ( DP ), intent ( in ), optional :: origin_time !! The time of the particle's formation real ( DP ), dimension (:), intent ( in ), optional :: origin_xh !! The heliocentric distance vector at the time of the particle's formation real ( DP ), dimension (:), intent ( in ), optional :: origin_vh !! The heliocentric velocity vector at the time of the particle's formation real ( DP ), intent ( in ), optional :: discard_time !! The time of the particle's discard real ( DP ), dimension (:), intent ( in ), optional :: discard_xh !! The heliocentric distance vector at the time of the particle's discard real ( DP ), dimension (:), intent ( in ), optional :: discard_vh !! The heliocentric velocity vector at the time of the particle's discard integer ( I4B ), intent ( in ), optional :: discard_body_id !! The id of the other body involved in the discard (0 if no other body involved) ! Internals character ( len = NAMELEN ) :: lenstr character ( len = :), allocatable :: fmtlabel write ( lenstr , * ) NAMELEN fmtlabel = \"(A\" // trim ( adjustl ( lenstr )) // \")\" if ( present ( name )) then write ( self % name , fmtlabel ) trim ( adjustl ( name )) end if if ( present ( particle_type )) then write ( self % particle_type , fmtlabel ) trim ( adjustl ( particle_type )) end if if ( present ( status )) then write ( self % status , fmtlabel ) trim ( adjustl ( status )) end if if ( present ( origin_type )) then write ( self % origin_type , fmtlabel ) trim ( adjustl ( origin_type )) end if if ( present ( origin_time )) then self % origin_time = origin_time end if if ( present ( origin_xh )) then self % origin_xh (:) = origin_xh (:) end if if ( present ( origin_vh )) then self % origin_vh (:) = origin_vh (:) end if if ( present ( discard_time )) then self % discard_time = discard_time end if if ( present ( discard_xh )) then self % discard_xh (:) = discard_xh (:) end if if ( present ( discard_vh )) then self % discard_vh (:) = discard_vh (:) end if if ( present ( discard_body_id )) then self % discard_body_id = discard_body_id end if return end subroutine util_set_particle_info module subroutine util_set_rhill ( self , cb ) !! author: David A. Minton !! !! Sets the value of the Hill's radius implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object if ( self % nbody == 0 ) return call self % xv2el ( cb ) self % rhill ( 1 : self % nbody ) = self % a ( 1 : self % nbody ) * ( self % Gmass ( 1 : self % nbody ) / cb % Gmass / 3 ) ** THIRD return end subroutine util_set_rhill module subroutine util_set_rhill_approximate ( self , cb ) !! author: David A. Minton !! !! Sets the approximate value of the Hill's radius using the heliocentric radius instead of computing the semimajor axis implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object ! Internals real ( DP ), dimension (:), allocatable :: rh if ( self % nbody == 0 ) return rh ( 1 : self % nbody ) = . mag . self % xh (:, 1 : self % nbody ) self % rhill ( 1 : self % nbody ) = rh ( 1 : self % nbody ) * ( self % Gmass ( 1 : self % nbody ) / cb % Gmass / 3 ) ** THIRD return end subroutine util_set_rhill_approximate end submodule s_util_set","tags":"","loc":"sourcefile/util_set.f90.html"},{"title":"util_peri.f90 – swiftest","text":"This file depends on sourcefile~~util_peri.f90~~EfferentGraph sourcefile~util_peri.f90 util_peri.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_peri.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_peri Source Code util_peri.f90 Source Code submodule ( swiftest_classes ) s_util_peri use swiftest contains module subroutine util_peri_tp ( self , system , param ) !! author: David A. Minton !! !! Determine system pericenter passages for test particles !! Note:  If the coordinate system used is barycentric, then this routine assumes that the barycentric coordinates in the !!        test particle structures are up-to-date and are not recomputed !! !! Adapted from David E. Kaufmann's Swifter routine: util_peri.f90 !! Adapted from Hal Levison's Swift routine util_peri.f implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i real ( DP ) :: e real ( DP ), dimension (:), allocatable :: vdotr associate ( tp => self , ntp => self % nbody ) allocate ( vdotr ( ntp )) if ( param % qmin_coord == \"HELIO\" ) then do i = 1 , ntp vdotr ( i ) = dot_product ( tp % xh (:, i ), tp % vh (:, i )) if ( tp % isperi ( i ) == - 1 ) then if ( vdotr ( i ) >= 0.0_DP ) then tp % isperi ( i ) = 0 call orbel_xv2aeq ( tp % mu ( i ), tp % xh (:, i ), tp % vh (:, i ), tp % atp ( i ), e , tp % peri ( i )) end if else if ( vdotr ( i ) > 0.0_DP ) then tp % isperi ( i ) = 1 else tp % isperi ( i ) = - 1 end if end if end do else do i = 1 , ntp vdotr ( i ) = dot_product ( tp % xb (:, i ), tp % vb (:, i )) if ( tp % isperi ( i ) == - 1 ) then if ( vdotr ( i ) >= 0.0_DP ) then tp % isperi ( i ) = 0 call orbel_xv2aeq ( system % Gmtot , tp % xb (:, i ), tp % vb (:, i ), tp % atp ( i ), e , tp % peri ( i )) end if else if ( vdotr ( i ) > 0.0_DP ) then tp % isperi ( i ) = 1 else tp % isperi ( i ) = - 1 end if end if end do end if end associate return end subroutine util_peri_tp end submodule s_util_peri","tags":"","loc":"sourcefile/util_peri.f90.html"},{"title":"util_coord.f90 – swiftest","text":"This file depends on sourcefile~~util_coord.f90~~EfferentGraph sourcefile~util_coord.f90 util_coord.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_coord.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_coord Source Code util_coord.f90 Source Code submodule ( swiftest_classes ) s_util_coord use swiftest contains module subroutine util_coord_h2b_pl ( self , cb ) !! author: David A. Minton !! !! Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) !! !! Adapted from David E. Kaufmann's Swifter routine coord_h2b.f90 !! Adapted from Hal Levison's Swift routine coord_h2b.f implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object ! Internals integer ( I4B ) :: i real ( DP ) :: Gmtot real ( DP ), dimension ( NDIM ) :: xtmp , vtmp if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) Gmtot = cb % Gmass xtmp (:) = 0.0_DP vtmp (:) = 0.0_DP do i = 1 , npl if ( pl % status ( i ) == INACTIVE ) cycle Gmtot = Gmtot + pl % Gmass ( i ) xtmp (:) = xtmp (:) + pl % Gmass ( i ) * pl % xh (:, i ) vtmp (:) = vtmp (:) + pl % Gmass ( i ) * pl % vh (:, i ) end do cb % xb (:) = - xtmp (:) / Gmtot cb % vb (:) = - vtmp (:) / Gmtot do i = 1 , npl if ( pl % status ( i ) == INACTIVE ) cycle pl % xb (:, i ) = pl % xh (:, i ) + cb % xb (:) pl % vb (:, i ) = pl % vh (:, i ) + cb % vb (:) end do end associate return end subroutine util_coord_h2b_pl module subroutine util_coord_h2b_tp ( self , cb ) !! author: David A. Minton !! !! Convert test particles from heliocentric to barycentric coordinates (position and velocity) !! !! Adapted from David E. Kaufmann's Swifter routine coord_h2b_tp.f90 !! Adapted from Hal Levison's Swift routine coord_h2b_tp.f implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_cb ), intent ( in ) :: cb !! Swiftest central body object ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) do concurrent ( i = 1 : ntp , tp % status ( i ) /= INACTIVE ) tp % xb (:, i ) = tp % xh (:, i ) + cb % xb (:) tp % vb (:, i ) = tp % vh (:, i ) + cb % vb (:) end do end associate return end subroutine util_coord_h2b_tp module subroutine util_coord_b2h_pl ( self , cb ) !! author: David A. Minton !! !! Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) !! !! Adapted from David E. Kaufmann's Swifter routine coord_b2h.f90 !! Adapted from Hal Levison's Swift routine coord_b2h.f implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) do concurrent ( i = 1 : npl , pl % status ( i ) /= INACTIVE ) pl % xh (:, i ) = pl % xb (:, i ) - cb % xb (:) pl % vh (:, i ) = pl % vb (:, i ) - cb % vb (:) end do end associate return end subroutine util_coord_b2h_pl module subroutine util_coord_b2h_tp ( self , cb ) !! author: David A. Minton !! !! Convert test particles from barycentric to heliocentric coordinates (position and velocity) !! !! Adapted from David E. Kaufmann's Swifter routine coord_b2h_tp.f90 !! Adapted from Hal Levison's Swift routine coord_b2h_tp.f implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( in ) :: cb !! Swiftest central body object ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) do concurrent ( i = 1 : ntp , tp % status ( i ) /= INACTIVE ) tp % xh (:, i ) = tp % xb (:, i ) - cb % xb (:) tp % vh (:, i ) = tp % vb (:, i ) - cb % vb (:) end do end associate return end subroutine util_coord_b2h_tp module subroutine util_coord_vb2vh_pl ( self , cb ) !! author: David A. Minton !! !! Convert massive bodies from barycentric to heliocentric coordinates (velocity only) !! !! Adapted from David E. Kaufmann's Swifter routine coord_vb2vh.f90 !! Adapted from Hal Levison's Swift routine coord_vb2vh.f implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) do i = 1 , NDIM cb % vb ( i ) = - sum ( pl % Gmass ( 1 : npl ) * pl % vb ( i , 1 : npl )) / cb % Gmass pl % vh ( i , 1 : npl ) = pl % vb ( i , 1 : npl ) - cb % vb ( i ) end do end associate return end subroutine util_coord_vb2vh_pl module subroutine util_coord_vb2vh_tp ( self , vbcb ) !! author: David A. Minton !! !! Convert test particles from barycentric to heliocentric coordinates (velocity only) !! !! Adapted from David E. Kaufmann's Swifter routine coord_vb2vh_tp.f90 !! Adapted from Hal Levison's Swift routine coord_vb2h_tp.f implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object real ( DP ), dimension (:), intent ( in ) :: vbcb !! Barycentric velocity of the central body if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) where ( tp % lmask ( 1 : ntp )) tp % vh ( 1 , 1 : ntp ) = tp % vb ( 1 , 1 : ntp ) - vbcb ( 1 ) tp % vh ( 2 , 1 : ntp ) = tp % vb ( 2 , 1 : ntp ) - vbcb ( 2 ) tp % vh ( 3 , 1 : ntp ) = tp % vb ( 3 , 1 : ntp ) - vbcb ( 3 ) end where end associate return end subroutine util_coord_vb2vh_tp module subroutine util_coord_vh2vb_pl ( self , cb ) !! author: David A. Minton !! !! Convert massive bodies from heliocentric to barycentric coordinates (velocity only) !! !! Adapted from David E. Kaufmann's Swifter routine coord_vh2vb.f90 !! Adapted from Hal Levison's Swift routine coord_vh2b.f implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object ! Internals integer ( I4B ) :: i real ( DP ) :: Gmtot if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) Gmtot = cb % Gmass + sum ( pl % Gmass ( 1 : npl )) do i = 1 , NDIM cb % vb ( i ) = - sum ( pl % Gmass ( 1 : npl ) * pl % vh ( i , 1 : npl )) / Gmtot pl % vb ( i , 1 : npl ) = pl % vh ( i , 1 : npl ) + cb % vb ( i ) end do end associate return end subroutine util_coord_vh2vb_pl module subroutine util_coord_vh2vb_tp ( self , vbcb ) !! author: David A. Minton !! !! Convert test particles from heliocentric to barycentric coordinates (velocity only) !! !! Adapted from David E. Kaufmann's Swifter routine coord_vh2vb_tp.f90 !! Adapted from Hal Levison's Swift routine coord_vh2b_tp.f implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object real ( DP ), dimension (:), intent ( in ) :: vbcb !! Barycentric velocity of the central body if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) where ( tp % lmask ( 1 : ntp )) tp % vb ( 1 , 1 : ntp ) = tp % vh ( 1 , 1 : ntp ) + vbcb ( 1 ) tp % vb ( 2 , 1 : ntp ) = tp % vh ( 2 , 1 : ntp ) + vbcb ( 2 ) tp % vb ( 3 , 1 : ntp ) = tp % vh ( 3 , 1 : ntp ) + vbcb ( 3 ) end where end associate return end subroutine util_coord_vh2vb_tp module subroutine util_coord_xh2xb_pl ( self , cb ) !! author: David A. Minton !! !! Convert position vectors of massive bodies from heliocentric to barycentric coordinates (position only) !! !! Adapted from David E. Kaufmann's Swifter routine coord_h2b.f90 !! Adapted from Hal Levison's Swift routine coord_h2b.f implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object ! Internals integer ( I4B ) :: i real ( DP ) :: Gmtot real ( DP ), dimension ( NDIM ) :: xtmp if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) Gmtot = cb % Gmass xtmp (:) = 0.0_DP do i = 1 , npl if ( pl % status ( i ) == INACTIVE ) cycle Gmtot = Gmtot + pl % Gmass ( i ) xtmp (:) = xtmp (:) + pl % Gmass ( i ) * pl % xh (:, i ) end do cb % xb (:) = - xtmp (:) / Gmtot do i = 1 , npl if ( pl % status ( i ) == INACTIVE ) cycle pl % xb (:, i ) = pl % xh (:, i ) + cb % xb (:) end do end associate return end subroutine util_coord_xh2xb_pl module subroutine util_coord_xh2xb_tp ( self , cb ) !! author: David A. Minton !! !! Convert test particles from heliocentric to barycentric coordinates (position only) !! !! Adapted from David E. Kaufmann's Swifter routine coord_h2b_tp.f90 !! Adapted from Hal Levison's Swift routine coord_h2b_tp.f implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_cb ), intent ( in ) :: cb !! Swiftest central body object ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) do concurrent ( i = 1 : ntp , tp % status ( i ) /= INACTIVE ) tp % xb (:, i ) = tp % xh (:, i ) + cb % xb (:) end do end associate return end subroutine util_coord_xh2xb_tp end submodule s_util_coord","tags":"","loc":"sourcefile/util_coord.f90.html"},{"title":"util_index.f90 – swiftest","text":"This file depends on sourcefile~~util_index.f90~~EfferentGraph sourcefile~util_index.f90 util_index.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_index.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_index.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_index Source Code util_index.f90 Source Code submodule ( swiftest_classes ) s_util_index use swiftest contains module pure subroutine util_index_eucl_ij_to_k ( n , i , j , k ) !$omp declare simd(util_index_eucl_ij_to_k) !! author: Jacob R. Elliott and David A. Minton !! !! Turns i,j indices into k index for use in the Euclidean distance matrix for pl-pl interactions. !! !! Reference: !! !!    Mélodie Angeletti, Jean-Marie Bonny, Jonas Koko. Parallel Euclidean distance matrix computation on big datasets *. !!       2019. hal-0204751 implicit none ! Arguments integer ( I4B ), intent ( in ) :: n !! Number of bodies integer ( I4B ), intent ( in ) :: i !! Index of the ith body integer ( I4B ), intent ( in ) :: j !! Index of the jth body integer ( I8B ), intent ( out ) :: k !! Index of the flattened matrix ! Internals integer ( I8B ) :: i8 , j8 , n8 i8 = int ( i , kind = I8B ) j8 = int ( j , kind = I8B ) n8 = int ( n , kind = I8B ) k = ( i8 - 1_I8B ) * n8 - i8 * ( i8 - 1_I8B ) / 2_I8B + ( j8 - i8 ) return end subroutine util_index_eucl_ij_to_k module pure subroutine util_index_eucl_k_to_ij ( n , k , i , j ) !! author: Jacob R. Elliott and David A. Minton !! !! Turns k index into i,j indices for use in the Euclidean distance matrix for pl-pl interactions. !! !! Reference: !! !!    Mélodie Angeletti, Jean-Marie Bonny, Jonas Koko. Parallel Euclidean distance matrix computation on big datasets *. !!       2019. hal-0204751 implicit none ! Arguments integer ( I4B ), intent ( in ) :: n !! Number of bodies integer ( I8B ), intent ( in ) :: k !! Index of the flattened matrix integer ( I4B ), intent ( out ) :: i !! Index of the ith body integer ( I4B ), intent ( out ) :: j !! Index of the jth body ! Internals integer ( I8B ) :: kp , p , i8 , j8 , n8 n8 = int ( n , kind = I8B ) kp = n8 * ( n8 - 1_I8B ) / 2_I8B - k p = floor (( sqrt ( 1._DP + 8_I8B * kp ) - 1_I8B ) / 2_I8B ) i8 = n8 - 1_I8B - p j8 = k - ( n8 - 1_I8B ) * ( n8 - 2_I8B ) / 2_I8B + p * ( p + 1_I8B ) / 2_I8B + 1_I8B i = int ( i8 , kind = I4B ) j = int ( j8 , kind = I4B ) return end subroutine util_index_eucl_k_to_ij module subroutine util_index_eucl_plpl ( self , param ) !! author: Jacob R. Elliott and David A. Minton !! !! Turns i,j indices into k index for use in the Euclidean distance matrix for pl-pl interactions for a Swiftest massive body object !! !! Reference: !! !!    Mélodie Angeletti, Jean-Marie Bonny, Jonas Koko. Parallel Euclidean distance matrix computation on big datasets *. !!       2019. hal-0204751 implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i , j , npl integer ( I8B ) :: k npl = int ( self % nbody , kind = I8B ) associate ( nplpl => self % nplpl ) nplpl = ( npl * ( npl - 1 ) / 2 ) ! number of entries in a strict lower triangle, npl x npl if ( allocated ( self % k_plpl )) deallocate ( self % k_plpl ) ! Reset the index array if it's been set previously allocate ( self % k_plpl ( 2 , nplpl )) do concurrent ( i = 1 : npl , j = 1 : npl , j > i ) call util_index_eucl_ij_to_k ( npl , i , j , k ) self % k_plpl ( 1 , k ) = i self % k_plpl ( 2 , k ) = j end do end associate return end subroutine util_index_eucl_plpl module subroutine util_index_eucl_pltp ( self , pl , param ) !! author: Jacob R. Elliott and David A. Minton !! !! Turns i,j indices into k index for use in the Euclidean distance matrix for pl-tp interactions !! !! Reference: !! !!    Mélodie Angeletti, Jean-Marie Bonny, Jonas Koko. Parallel Euclidean distance matrix computation on big datasets *. !!       2019. hal-0204751 implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_pl ), intent ( in ) :: pl !! Swiftest massive body object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I8B ) :: i , j , counter , npl , ntp ntp = int ( self % nbody , kind = I8B ) npl = int ( pl % nbody , kind = I8B ) associate ( npltp => self % npltp ) npltp = npl * ntp if ( allocated ( self % k_pltp )) deallocate ( self % k_pltp ) ! Reset the index array if it's been set previously allocate ( self % k_pltp ( 2 , npltp )) do i = 1_I8B , npl counter = ( i - 1_I8B ) * npl + 1_I8B do j = 1_I8B , ntp self % k_pltp ( 1 , counter ) = i self % k_pltp ( 2 , counter ) = j counter = counter + 1_I8B end do end do end associate return end subroutine util_index_eucl_pltp end submodule s_util_index","tags":"","loc":"sourcefile/util_index.f90.html"},{"title":"util_rescale.f90 – swiftest","text":"This file depends on sourcefile~~util_rescale.f90~~EfferentGraph sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_rescale.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_rescale Source Code util_rescale.f90 Source Code submodule ( swiftest_classes ) s_util_rescale use swiftest contains module subroutine util_rescale_system ( self , param , mscale , dscale , tscale ) !! author: David A. Minton !! !! Rescales an nbody system to a new set of units. Inputs are the multipliers on the mass (mscale), distance (dscale), and time units (tscale). !! Rescales all united quantities in the system, as well as the mass conversion factors, gravitational constant, and Einstein's constant in the parameter object. implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters. Returns with new values of the scale vactors and GU real ( DP ), intent ( in ) :: mscale , dscale , tscale !! Scale factors for mass, distance, and time units, respectively. ! Internals real ( DP ) :: vscale param % MU2KG = param % MU2KG * mscale param % DU2M = param % DU2M * dscale param % TU2S = param % TU2S * tscale ! Calculate the G for the system units param % GU = GC / ( param % DU2M ** 3 / ( param % MU2KG * param % TU2S ** 2 )) if ( param % lgr ) then ! Calculate the inverse speed of light in the system units param % inv_c2 = einsteinC * param % TU2S / param % DU2M param % inv_c2 = ( param % inv_c2 ) ** ( - 2 ) end if vscale = dscale / tscale associate ( cb => self % cb , pl => self % pl , npl => self % pl % nbody , tp => self % tp , ntp => self % tp % nbody ) cb % mass = cb % mass / mscale cb % Gmass = param % GU * cb % mass cb % radius = cb % radius / dscale cb % xb (:) = cb % xb (:) / dscale cb % vb (:) = cb % vb (:) / vscale cb % rot (:) = cb % rot (:) * tscale pl % mass ( 1 : npl ) = pl % mass ( 1 : npl ) / mscale pl % Gmass ( 1 : npl ) = param % GU * pl % mass ( 1 : npl ) pl % radius ( 1 : npl ) = pl % radius ( 1 : npl ) / dscale pl % xh (:, 1 : npl ) = pl % xh (:, 1 : npl ) / dscale pl % vh (:, 1 : npl ) = pl % vh (:, 1 : npl ) / vscale pl % xb (:, 1 : npl ) = pl % xb (:, 1 : npl ) / dscale pl % vb (:, 1 : npl ) = pl % vb (:, 1 : npl ) / vscale pl % rot (:, 1 : npl ) = pl % rot (:, 1 : npl ) * tscale end associate return end subroutine util_rescale_system end submodule s_util_rescale","tags":"","loc":"sourcefile/util_rescale.f90.html"},{"title":"util_version.f90 – swiftest","text":"This file depends on sourcefile~~util_version.f90~~EfferentGraph sourcefile~util_version.f90 util_version.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_version.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_version Source Code util_version.f90 Source Code submodule ( swiftest_classes ) s_util_version use swiftest contains module subroutine util_version () !! author: David A. Minton !! !! Print program version information to terminale !! !! Adapted from David E. Kaufmann's Swifter routine: util_version.f90 implicit none write ( * , 200 ) VERSION_NUMBER 200 format ( / , \"************* Swiftest: Version \" , f3 . 1 , \" *************\" , // , & \"Based off of Swifter:\" , // , & \"Authors:\" , // , & \"    The Purdue University Swiftest Development team \" , / , & \"    Lead by David A. Minton \" , / , & \"    Single loop blocking by Jacob R. Elliott\" , / , & \"    Fragmentation by Carlisle A. Wishard and\" , // , & \"    Jennifer L. L. Poutplin                 \" , // , & \"Please address comments and questions to:\" , // , & \"    David A. Minton\" , / , & \"    Department Earth, Atmospheric, & Planetary Sciences \" , / , & \"    Purdue University\" , / , & \"    550 Stadium Mall Drive\" , / , & \"    West Lafayette, Indiana 47907\" , / , & \"    765-250-8034 \" , / , & \"    daminton@purdue.edu\" , / , & \"Special thanks to Hal Levison and Martin Duncan for the original\" , / ,& \"SWIFTER and SWIFT codes that made this possible.\" , // , & \"************************************************\" , / ) 100 FORMAT ( / , \"************* SWIFTER: Version \" , F3 . 1 , \" *************\" , // , & \"Authors:\" , // , & \"    Martin Duncan: Queen's University\" , / , & \"    Hal Levison  : Southwest Research Institute\" , // , & \"Please address comments and questions to:\" , // , & \"    Hal Levison or David Kaufmann\" , / , & \"    Department of Space Studies\" , / , & \"    Southwest Research Institute\" , / , & \"    1050 Walnut Street, Suite 400\" , / , & \"    Boulder, Colorado  80302\" , / , & \"    303-546-0290 (HFL), 720-240-0119 (DEK)\" , / , & \"    303-546-9687 (fax)\" , / , & \"    hal@gort.boulder.swri.edu (HFL)\" , / , & \"    kaufmann@boulder.swri.edu (DEK)\" , // , & \"************************************************\" , / ) return end subroutine util_version end submodule s_util_version","tags":"","loc":"sourcefile/util_version.f90.html"},{"title":"util_sort.f90 – swiftest","text":"This file depends on sourcefile~~util_sort.f90~~EfferentGraph sourcefile~util_sort.f90 util_sort.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_sort.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_sort Source Code util_sort.f90 Source Code submodule ( swiftest_classes ) s_util_sort use swiftest contains module subroutine util_sort_body ( self , sortby , ascending ) !! author: David A. Minton !! !! Sort a Swiftest body structure in-place. !! sortby is a string indicating which array component to sort. implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order ! Internals integer ( I4B ), dimension (:), allocatable :: ind integer ( I4B ) :: direction if ( self % nbody == 0 ) return if ( ascending ) then direction = 1 else direction = - 1 end if associate ( body => self , n => self % nbody ) allocate ( ind ( n )) select case ( sortby ) case ( \"id\" ) call util_sort ( direction * body % id ( 1 : n ), ind ( 1 : n )) case ( \"status\" ) call util_sort ( direction * body % status ( 1 : n ), ind ( 1 : n )) case ( \"ir3h\" ) call util_sort ( direction * body % ir3h ( 1 : n ), ind ( 1 : n )) case ( \"a\" ) call util_sort ( direction * body % a ( 1 : n ), ind ( 1 : n )) case ( \"e\" ) call util_sort ( direction * body % e ( 1 : n ), ind ( 1 : n )) case ( \"inc\" ) call util_sort ( direction * body % inc ( 1 : n ), ind ( 1 : n )) case ( \"capom\" ) call util_sort ( direction * body % capom ( 1 : n ), ind ( 1 : n )) case ( \"mu\" ) call util_sort ( direction * body % mu ( 1 : n ), ind ( 1 : n )) case ( \"lfirst\" , \"nbody\" , \"ldiscard\" , \"xh\" , \"vh\" , \"xb\" , \"vb\" , \"ah\" , \"aobl\" , \"atide\" , \"agr\" ) write ( * , * ) 'Cannot sort by ' // trim ( adjustl ( sortby )) // '. Component not sortable!' case default write ( * , * ) 'Cannot sort by ' // trim ( adjustl ( sortby )) // '. Component not found!' return end select call body % rearrange ( ind ) end associate return end subroutine util_sort_body module subroutine util_sort_dp ( arr ) !! author: David A. Minton !! !! Sort input double precision array in place into ascending numerical order using insertion sort. !! This algorithm works well for partially sorted arrays (which is usually the case here) !! implicit none ! Arguments real ( DP ), dimension (:), intent ( inout ) :: arr ! Internals real ( DP ) :: tmp integer ( I4B ) :: n , i , j n = size ( arr ) do i = 2 , n tmp = arr ( i ) do j = i - 1 , 1 , - 1 if ( arr ( j ) <= tmp ) exit arr ( j + 1 ) = arr ( j ) end do arr ( j + 1 ) = tmp end do return end subroutine util_sort_dp module subroutine util_sort_index_dp ( arr , ind ) !! author: David A. Minton !! !! Sort input double precision array by index in ascending numerical order using insertion sort. !! This algorithm works well for partially sorted arrays (which is usually the case here) !! implicit none ! Arguments real ( DP ), dimension (:), intent ( in ) :: arr integer ( I4B ), dimension (:), intent ( out ) :: ind ! Internals real ( DP ) :: tmp integer ( I4B ) :: n , i , j n = size ( arr ) ind = [( i , i = 1 , n )] do i = 2 , n tmp = arr ( ind ( i )) do j = i - 1 , 1 , - 1 if ( arr ( ind ( j )) <= tmp ) exit ind ( j + 1 ) = ind ( j ) end do ind ( j + 1 ) = i end do return end subroutine util_sort_index_dp module subroutine util_sort_i4b ( arr ) !! author: David A. Minton !! !! Sort input integer array in place into ascending numerical order using insertion sort. !! This algorithm works well for partially sorted arrays (which is usually the case here) !! implicit none ! Arguments integer ( I4B ), dimension (:), intent ( inout ) :: arr ! Internals integer ( I4B ) :: tmp integer ( I4B ) :: n , i , j n = size ( arr ) do i = 2 , n tmp = arr ( i ) do j = i - 1 , 1 , - 1 if ( arr ( j ) <= tmp ) exit arr ( j + 1 ) = arr ( j ) end do arr ( j + 1 ) = tmp end do return end subroutine util_sort_i4b module subroutine util_sort_index_i4b ( arr , ind ) !! author: David A. Minton !! !! Sort input integer array by index in ascending numerical order using insertion sort. !! This algorithm works well for partially sorted arrays (which is usually the case here) !! implicit none ! Arguments integer ( I4B ), dimension (:), intent ( in ) :: arr integer ( I4B ), dimension (:), intent ( out ) :: ind ! Internals integer ( I4B ) :: tmp integer ( I4B ) :: n , i , j n = size ( arr ) ind = [( i , i = 1 , n )] do i = 2 , n tmp = arr ( ind ( i )) do j = i - 1 , 1 , - 1 if ( arr ( ind ( j )) <= tmp ) exit ind ( j + 1 ) = ind ( j ) end do ind ( j + 1 ) = i end do return end subroutine util_sort_index_i4b module subroutine util_sort_sp ( arr ) !! author: David A. Minton !! !! Sort input single precision array in place into ascending numerical order using insertion sort. !! This algorithm works well for partially sorted arrays (which is usually the case here) ! implicit none ! Arguments real ( SP ), dimension (:), intent ( inout ) :: arr ! Internals real ( SP ) :: tmp integer ( I4B ) :: n , i , j n = size ( arr ) do i = 2 , n tmp = arr ( i ) do j = i - 1 , 1 , - 1 if ( arr ( j ) <= tmp ) exit arr ( j + 1 ) = arr ( j ) end do arr ( j + 1 ) = tmp end do return end subroutine util_sort_sp module subroutine util_sort_index_sp ( arr , ind ) !! author: David A. Minton !! !! Sort input single precision array by index in ascending numerical order using insertion sort. !! This algorithm works well for partially sorted arrays (which is usually the case here) !! implicit none ! Arguments real ( SP ), dimension (:), intent ( in ) :: arr integer ( I4B ), dimension (:), intent ( out ) :: ind ! Internals real ( SP ) :: tmp integer ( I4B ) :: n , i , j n = size ( arr ) ind = [( i , i = 1 , n )] do i = 2 , n tmp = arr ( ind ( i )) do j = i - 1 , 1 , - 1 if ( arr ( ind ( j )) <= tmp ) exit ind ( j + 1 ) = ind ( j ) end do ind ( j + 1 ) = i end do return end subroutine util_sort_index_sp module subroutine util_sort_pl ( self , sortby , ascending ) !! author: David A. Minton !! !! Sort a Swiftest massive body object in-place. !! sortby is a string indicating which array component to sort. implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order ! Internals integer ( I4B ), dimension (:), allocatable :: ind integer ( I4B ) :: direction if ( self % nbody == 0 ) return if ( ascending ) then direction = 1 else direction = - 1 end if associate ( pl => self , npl => self % nbody ) allocate ( ind ( npl )) select case ( sortby ) case ( \"Gmass\" , \"mass\" ) call util_sort ( direction * pl % Gmass ( 1 : npl ), ind ( 1 : npl )) case ( \"rhill\" ) call util_sort ( direction * pl % rhill ( 1 : npl ), ind ( 1 : npl )) case ( \"radius\" ) call util_sort ( direction * pl % radius ( 1 : npl ), ind ( 1 : npl )) case ( \"density\" ) call util_sort ( direction * pl % density ( 1 : npl ), ind ( 1 : npl )) case ( \"k2\" ) call util_sort ( direction * pl % k2 ( 1 : npl ), ind ( 1 : npl )) case ( \"Q\" ) call util_sort ( direction * pl % Q ( 1 : npl ), ind ( 1 : npl )) case ( \"tlag\" ) call util_sort ( direction * pl % tlag ( 1 : npl ), ind ( 1 : npl )) case ( \"xbeg\" , \"xend\" , \"vbeg\" , \"Ip\" , \"rot\" , \"k_plpl\" , \"nplpl\" ) write ( * , * ) 'Cannot sort by ' // trim ( adjustl ( sortby )) // '. Component not sortable!' case default ! Look for components in the parent class call util_sort_body ( pl , sortby , ascending ) return end select call pl % rearrange ( ind ) end associate return end subroutine util_sort_pl module subroutine util_sort_tp ( self , sortby , ascending ) !! author: David A. Minton !! !! Sort a Swiftest test particle object  in-place. !! sortby is a string indicating which array component to sort. implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order ! Internals integer ( I4B ), dimension (:), allocatable :: ind integer ( I4B ) :: direction if ( self % nbody == 0 ) return if ( ascending ) then direction = 1 else direction = - 1 end if associate ( tp => self , ntp => self % nbody ) allocate ( ind ( ntp )) select case ( sortby ) case ( \"peri\" ) call util_sort ( direction * tp % peri ( 1 : ntp ), ind ( 1 : ntp )) case ( \"atp\" ) call util_sort ( direction * tp % atp ( 1 : ntp ), ind ( 1 : ntp )) case ( \"isperi\" ) write ( * , * ) 'Cannot sort by ' // trim ( adjustl ( sortby )) // '. Component not sortable!' case default ! Look for components in the parent class call util_sort_body ( tp , sortby , ascending ) return end select call tp % rearrange ( ind ) end associate return end subroutine util_sort_tp module subroutine util_sort_rearrange_body ( self , ind ) !! author: David A. Minton !! !! Rearrange Swiftest body structure in-place from an index list. !! This is a helper utility used to make polymorphic sorting work on Swiftest structures. implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) associate ( n => self % nbody ) call util_sort_rearrange ( self % id , ind , n ) call util_sort_rearrange ( self % info , ind , n ) call util_sort_rearrange ( self % status , ind , n ) call util_sort_rearrange ( self % ldiscard , ind , n ) call util_sort_rearrange ( self % xh , ind , n ) call util_sort_rearrange ( self % vh , ind , n ) call util_sort_rearrange ( self % xb , ind , n ) call util_sort_rearrange ( self % vb , ind , n ) call util_sort_rearrange ( self % ah , ind , n ) call util_sort_rearrange ( self % ir3h , ind , n ) call util_sort_rearrange ( self % mu , ind , n ) call util_sort_rearrange ( self % lmask , ind , n ) call util_sort_rearrange ( self % a , ind , n ) call util_sort_rearrange ( self % e , ind , n ) call util_sort_rearrange ( self % inc , ind , n ) call util_sort_rearrange ( self % capom , ind , n ) call util_sort_rearrange ( self % omega , ind , n ) call util_sort_rearrange ( self % capm , ind , n ) call util_sort_rearrange ( self % aobl , ind , n ) call util_sort_rearrange ( self % atide , ind , n ) call util_sort_rearrange ( self % agr , ind , n ) end associate return end subroutine util_sort_rearrange_body module subroutine util_sort_rearrange_arr_char_string ( arr , ind , n ) !! author: David A. Minton !! !! Rearrange a single array of character string in-place from an index list. implicit none ! Arguments character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index to rearrange against integer ( I4B ), intent ( in ) :: n !! Number of elements in arr and ind to rearrange ! Internals character ( len = STRMAX ), dimension (:), allocatable :: tmp !! Temporary copy of arry used during rearrange operation if (. not . allocated ( arr ) . or . n <= 0 ) return allocate ( tmp , mold = arr ) tmp ( 1 : n ) = arr ( ind ( 1 : n )) call move_alloc ( tmp , arr ) return end subroutine util_sort_rearrange_arr_char_string module subroutine util_sort_rearrange_arr_DP ( arr , ind , n ) !! author: David A. Minton !! !! Rearrange a single array of DP type in-place from an index list. implicit none ! Arguments real ( DP ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index to rearrange against integer ( I4B ), intent ( in ) :: n !! Number of elements in arr and ind to rearrange ! Internals real ( DP ), dimension (:), allocatable :: tmp !! Temporary copy of array used during rearrange operation if (. not . allocated ( arr ) . or . n <= 0 ) return allocate ( tmp , mold = arr ) tmp ( 1 : n ) = arr ( ind ( 1 : n )) call move_alloc ( tmp , arr ) return end subroutine util_sort_rearrange_arr_DP module subroutine util_sort_rearrange_arr_DPvec ( arr , ind , n ) !! author: David A. Minton !! !! Rearrange a single array of (NDIM,n) DP-type vectors in-place from an index list. implicit none ! Arguments real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: arr !! Destination array integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index to rearrange against integer ( I4B ), intent ( in ) :: n !! Number of elements in arr and ind to rearrange ! Internals real ( DP ), dimension (:,:), allocatable :: tmp !! Temporary copy of array used during rearrange operation if (. not . allocated ( arr ) . or . n <= 0 ) return allocate ( tmp , mold = arr ) tmp (:, 1 : n ) = arr (:, ind ( 1 : n )) call move_alloc ( tmp , arr ) return end subroutine util_sort_rearrange_arr_DPvec module subroutine util_sort_rearrange_arr_I4B ( arr , ind , n ) !! author: David A. Minton !! !! Rearrange a single array of integers in-place from an index list. implicit none ! Arguments integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index to rearrange against integer ( I4B ), intent ( in ) :: n !! Number of elements in arr and ind to rearrange ! Internals integer ( I4B ), dimension (:), allocatable :: tmp !! Temporary copy of array used during rearrange operation if (. not . allocated ( arr ) . or . n <= 0 ) return allocate ( tmp , mold = arr ) tmp ( 1 : n ) = arr ( ind ( 1 : n )) call move_alloc ( tmp , arr ) return end subroutine util_sort_rearrange_arr_I4B module subroutine util_sort_rearrange_arr_logical ( arr , ind , n ) !! author: David A. Minton !! !! Rearrange a single array of logicals in-place from an index list. implicit none ! Arguments logical , dimension (:), allocatable , intent ( inout ) :: arr !! Destination array integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index to rearrange against integer ( I4B ), intent ( in ) :: n !! Number of elements in arr and ind to rearrange ! Internals logical , dimension (:), allocatable :: tmp !! Temporary copy of array used during rearrange operation if (. not . allocated ( arr ) . or . n <= 0 ) return allocate ( tmp , mold = arr ) tmp ( 1 : n ) = arr ( ind ( 1 : n )) call move_alloc ( tmp , arr ) return end subroutine util_sort_rearrange_arr_logical module subroutine util_sort_rearrange_arr_info ( arr , ind , n ) !! author: David A. Minton !! !! Rearrange a single array of particle information type in-place from an index list. implicit none ! Arguments type ( swiftest_particle_info ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index to rearrange against integer ( I4B ), intent ( in ) :: n !! Number of elements in arr and ind to rearrange ! Internals type ( swiftest_particle_info ), dimension (:), allocatable :: tmp !! Temporary copy of array used during rearrange operation integer ( I4B ) :: i if (. not . allocated ( arr ) . or . n <= 0 ) return allocate ( tmp , mold = arr ) call util_copy_particle_info_arr ( arr , tmp , ind ) call move_alloc ( tmp , arr ) return end subroutine util_sort_rearrange_arr_info module subroutine util_sort_rearrange_pl ( self , ind ) !! author: David A. Minton !! !! Rearrange Swiftest massive body structure in-place from an index list. !! This is a helper utility used to make polymorphic sorting work on Swiftest structures. implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) associate ( pl => self , npl => self % nbody ) call util_sort_rearrange ( pl % mass , ind , npl ) call util_sort_rearrange ( pl % Gmass , ind , npl ) call util_sort_rearrange ( pl % rhill , ind , npl ) call util_sort_rearrange ( pl % xbeg , ind , npl ) call util_sort_rearrange ( pl % vbeg , ind , npl ) call util_sort_rearrange ( pl % radius , ind , npl ) call util_sort_rearrange ( pl % density , ind , npl ) call util_sort_rearrange ( pl % Ip , ind , npl ) call util_sort_rearrange ( pl % rot , ind , npl ) call util_sort_rearrange ( pl % k2 , ind , npl ) call util_sort_rearrange ( pl % Q , ind , npl ) call util_sort_rearrange ( pl % tlag , ind , npl ) if ( allocated ( pl % k_plpl )) deallocate ( pl % k_plpl ) call util_sort_rearrange_body ( pl , ind ) end associate return end subroutine util_sort_rearrange_pl module subroutine util_sort_rearrange_tp ( self , ind ) !! author: David A. Minton !! !! Rearrange Swiftest massive body structure in-place from an index list. !! This is a helper utility used to make polymorphic sorting work on Swiftest structures. implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) associate ( tp => self , ntp => self % nbody ) call util_sort_rearrange ( tp % isperi , ind , ntp ) call util_sort_rearrange ( tp % peri , ind , ntp ) call util_sort_rearrange ( tp % atp , ind , ntp ) call util_sort_rearrange_body ( tp , ind ) end associate return end subroutine util_sort_rearrange_tp end submodule s_util_sort","tags":"","loc":"sourcefile/util_sort.f90.html"},{"title":"util_spill.f90 – swiftest","text":"This file depends on sourcefile~~util_spill.f90~~EfferentGraph sourcefile~util_spill.f90 util_spill.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_spill.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_spill Source Code util_spill.f90 Source Code submodule ( swiftest_classes ) s_util_spill use swiftest contains module subroutine util_spill_arr_char_string ( keeps , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Performs a spill operation on a single array of type character strings !! This is the inverse of a spill operation implicit none ! Arguments character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not ! Internals integer ( I4B ) :: nspill , nkeep , nlist character ( len = STRMAX ), dimension (:), allocatable :: tmp !! Array of values to keep nkeep = count (. not . lspill_list (:)) nspill = count ( lspill_list (:)) nlist = size ( lspill_list (:)) if (. not . allocated ( keeps ) . or . nspill == 0 ) return if (. not . allocated ( discards )) then allocate ( discards ( nspill )) else if ( size ( discards ) /= nspill ) then deallocate ( discards ) allocate ( discards ( nspill )) end if discards (:) = pack ( keeps ( 1 : nlist ), lspill_list ( 1 : nlist )) if ( ldestructive ) then if ( nkeep > 0 ) then allocate ( tmp ( nkeep )) tmp (:) = pack ( keeps ( 1 : nlist ), . not . lspill_list ( 1 : nlist )) call move_alloc ( tmp , keeps ) else deallocate ( keeps ) end if end if return end subroutine util_spill_arr_char_string module subroutine util_spill_arr_DP ( keeps , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Performs a spill operation on a single array of type DP !! This is the inverse of a spill operation implicit none ! Arguments real ( DP ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep real ( DP ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discardss logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not ! Internals integer ( I4B ) :: nspill , nkeep , nlist real ( DP ), dimension (:), allocatable :: tmp !! Array of values to keep nkeep = count (. not . lspill_list (:)) nspill = count ( lspill_list (:)) nlist = size ( lspill_list (:)) if (. not . allocated ( keeps ) . or . nspill == 0 ) return if (. not . allocated ( discards )) then allocate ( discards ( nspill )) else if ( size ( discards ) /= nspill ) then deallocate ( discards ) allocate ( discards ( nspill )) end if discards (:) = pack ( keeps ( 1 : nlist ), lspill_list ( 1 : nlist )) if ( ldestructive ) then if ( nkeep > 0 ) then allocate ( tmp ( nkeep )) tmp (:) = pack ( keeps ( 1 : nlist ), . not . lspill_list ( 1 : nlist )) call move_alloc ( tmp , keeps ) else deallocate ( keeps ) end if end if return end subroutine util_spill_arr_DP module subroutine util_spill_arr_DPvec ( keeps , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Performs a spill operation on a single array of DP vectors with shape (NDIM, n) !! This is the inverse of a spill operation implicit none ! Arguments real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: keeps !! Array of values to keep real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: discards !! Array discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not ! Internals integer ( I4B ) :: i , nspill , nkeep , nlist real ( DP ), dimension (:,:), allocatable :: tmp !! Array of values to keep nkeep = count (. not . lspill_list (:)) nspill = count ( lspill_list (:)) nlist = size ( lspill_list (:)) if (. not . allocated ( keeps ) . or . nspill == 0 ) return if (. not . allocated ( discards )) then allocate ( discards ( NDIM , nspill )) else if ( size ( discards , dim = 2 ) /= nspill ) then deallocate ( discards ) allocate ( discards ( NDIM , nspill )) end if do i = 1 , NDIM discards ( i ,:) = pack ( keeps ( i , 1 : nlist ), lspill_list ( 1 : nlist )) end do if ( ldestructive ) then if ( nkeep > 0 ) then allocate ( tmp ( NDIM , nkeep )) do i = 1 , NDIM tmp ( i , :) = pack ( keeps ( i , 1 : nlist ), . not . lspill_list ( 1 : nlist )) end do call move_alloc ( tmp , keeps ) else deallocate ( keeps ) end if end if return end subroutine util_spill_arr_DPvec module subroutine util_spill_arr_I4B ( keeps , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Performs a spill operation on a single array of type I4B !! This is the inverse of a spill operation implicit none ! Arguments integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not ! Internals integer ( I4B ) :: nspill , nkeep , nlist integer ( I4B ), dimension (:), allocatable :: tmp !! Array of values to keep nkeep = count (. not . lspill_list (:)) nspill = count ( lspill_list (:)) nlist = size ( lspill_list (:)) if (. not . allocated ( keeps ) . or . nspill == 0 ) return if (. not . allocated ( discards )) then allocate ( discards ( nspill )) else if ( size ( discards ) /= nspill ) then deallocate ( discards ) allocate ( discards ( nspill )) end if discards (:) = pack ( keeps ( 1 : nlist ), lspill_list ( 1 : nlist )) if ( ldestructive ) then if ( nkeep > 0 ) then allocate ( tmp ( nkeep )) tmp (:) = pack ( keeps ( 1 : nlist ), . not . lspill_list ( 1 : nlist )) call move_alloc ( tmp , keeps ) else deallocate ( keeps ) end if end if return end subroutine util_spill_arr_I4B module subroutine util_spill_arr_I8B ( keeps , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Performs a spill operation on a single array of type I4B !! This is the inverse of a spill operation implicit none ! Arguments integer ( I8B ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep integer ( I8B ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not ! Internals integer ( I4B ) :: nspill , nkeep , nlist integer ( I8B ), dimension (:), allocatable :: tmp !! Array of values to keep nkeep = count (. not . lspill_list (:)) nspill = count ( lspill_list (:)) nlist = size ( lspill_list (:)) if (. not . allocated ( keeps ) . or . nspill == 0 ) return if (. not . allocated ( discards )) then allocate ( discards ( nspill )) else if ( size ( discards ) /= nspill ) then deallocate ( discards ) allocate ( discards ( nspill )) end if discards (:) = pack ( keeps ( 1 : nlist ), lspill_list ( 1 : nlist )) if ( ldestructive ) then if ( nkeep > 0 ) then allocate ( tmp ( nkeep )) tmp (:) = pack ( keeps ( 1 : nlist ), . not . lspill_list ( 1 : nlist )) call move_alloc ( tmp , keeps ) else deallocate ( keeps ) end if end if return end subroutine util_spill_arr_I8B module subroutine util_spill_arr_info ( keeps , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Performs a spill operation on a single array of particle origin information types !! This is the inverse of a spill operation implicit none ! Arguments type ( swiftest_particle_info ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep type ( swiftest_particle_info ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discardss logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not ! Internals integer ( I4B ) :: i , nspill , nkeep , nlist integer ( I4B ), dimension (:), allocatable :: idx type ( swiftest_particle_info ), dimension (:), allocatable :: tmp nkeep = count (. not . lspill_list (:)) nspill = count ( lspill_list (:)) nlist = size ( lspill_list (:)) if (. not . allocated ( keeps ) . or . nspill == 0 ) return if (. not . allocated ( discards )) then allocate ( discards ( nspill )) else if ( size ( discards ) /= nspill ) then deallocate ( discards ) allocate ( discards ( nspill )) end if allocate ( idx ( nspill )) idx (:) = pack ([( i , i = 1 , nlist )], lspill_list ) call util_copy_particle_info_arr ( keeps , discards , idx ) if ( ldestructive ) then if ( nkeep > 0 ) then deallocate ( idx ) allocate ( idx ( nkeep )) allocate ( tmp ( nkeep )) idx (:) = pack ([( i , i = 1 , nlist )], . not . lspill_list ) call util_copy_particle_info_arr ( keeps , tmp , idx ) call move_alloc ( tmp , keeps ) else deallocate ( keeps ) end if end if return end subroutine util_spill_arr_info module subroutine util_spill_arr_logical ( keeps , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Performs a spill operation on a single array of logicals !! This is the inverse of a spill operation implicit none ! Arguments logical , dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep logical , dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or no ! Internals integer ( I4B ) :: nspill , nkeep , nlist logical , dimension (:), allocatable :: tmp !! Array of values to keep nkeep = count (. not . lspill_list (:)) nspill = count ( lspill_list (:)) nlist = size ( lspill_list (:)) if (. not . allocated ( keeps ) . or . nspill == 0 ) return if (. not . allocated ( discards )) then allocate ( discards ( nspill )) else if ( size ( discards ) /= nspill ) then deallocate ( discards ) allocate ( discards ( nspill )) end if discards (:) = pack ( keeps ( 1 : nlist ), lspill_list ( 1 : nlist )) if ( ldestructive ) then if ( nkeep > 0 ) then allocate ( tmp ( nkeep )) tmp (:) = pack ( keeps ( 1 : nlist ), . not . lspill_list ( 1 : nlist )) call move_alloc ( tmp , keeps ) else deallocate ( keeps ) end if end if return end subroutine util_spill_arr_logical module subroutine util_spill_body ( self , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Move spilled (discarded) Swiftest generic particle structure from active list to discard list !! Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest generic body object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter body by removing the discard list ! Internals integer ( I4B ) :: nbody_old ! For each component, pack the discarded bodies into the discard object and do the inverse with the keeps !> Spill all the common components associate ( keeps => self ) call util_spill ( keeps % id , discards % id , lspill_list , ldestructive ) call util_spill ( keeps % info , discards % info , lspill_list , ldestructive ) call util_spill ( keeps % status , discards % status , lspill_list , ldestructive ) call util_spill ( keeps % lmask , discards % lmask , lspill_list , ldestructive ) call util_spill ( keeps % ldiscard , discards % ldiscard , lspill_list , ldestructive ) call util_spill ( keeps % mu , discards % mu , lspill_list , ldestructive ) call util_spill ( keeps % xh , discards % xh , lspill_list , ldestructive ) call util_spill ( keeps % vh , discards % vh , lspill_list , ldestructive ) call util_spill ( keeps % xb , discards % xb , lspill_list , ldestructive ) call util_spill ( keeps % vb , discards % vb , lspill_list , ldestructive ) call util_spill ( keeps % ah , discards % ah , lspill_list , ldestructive ) call util_spill ( keeps % aobl , discards % aobl , lspill_list , ldestructive ) call util_spill ( keeps % agr , discards % agr , lspill_list , ldestructive ) call util_spill ( keeps % atide , discards % atide , lspill_list , ldestructive ) call util_spill ( keeps % a , discards % a , lspill_list , ldestructive ) call util_spill ( keeps % e , discards % e , lspill_list , ldestructive ) call util_spill ( keeps % inc , discards % inc , lspill_list , ldestructive ) call util_spill ( keeps % capom , discards % capom , lspill_list , ldestructive ) call util_spill ( keeps % omega , discards % omega , lspill_list , ldestructive ) call util_spill ( keeps % capm , discards % capm , lspill_list , ldestructive ) nbody_old = keeps % nbody ! This is the base class, so will be the last to be called in the cascade. ! Therefore we need to set the nbody values for both the keeps and discareds discards % nbody = count ( lspill_list ( 1 : nbody_old )) if ( ldestructive ) keeps % nbody = nbody_old - discards % nbody end associate return end subroutine util_spill_body module subroutine util_spill_encounter ( self , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Move spilled (discarded) Swiftest encounter structure from active list to discard list implicit none ! Arguments class ( swiftest_encounter ), intent ( inout ) :: self !! Swiftest encounter list class ( swiftest_encounter ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter body by removing the discard list ! Internals integer ( I4B ) :: nenc_old associate ( keeps => self ) call util_spill ( keeps % lvdotr , discards % lvdotr , lspill_list , ldestructive ) call util_spill ( keeps % status , discards % status , lspill_list , ldestructive ) call util_spill ( keeps % kidx , discards % kidx , lspill_list , ldestructive ) call util_spill ( keeps % index1 , discards % index1 , lspill_list , ldestructive ) call util_spill ( keeps % index2 , discards % index2 , lspill_list , ldestructive ) call util_spill ( keeps % id1 , discards % id1 , lspill_list , ldestructive ) call util_spill ( keeps % id2 , discards % id2 , lspill_list , ldestructive ) call util_spill ( keeps % x1 , discards % x1 , lspill_list , ldestructive ) call util_spill ( keeps % x2 , discards % x2 , lspill_list , ldestructive ) call util_spill ( keeps % v1 , discards % v1 , lspill_list , ldestructive ) call util_spill ( keeps % v2 , discards % v2 , lspill_list , ldestructive ) call util_spill ( keeps % t , discards % t , lspill_list , ldestructive ) nenc_old = keeps % nenc ! This is the base class, so will be the last to be called in the cascade. ! Therefore we need to set the nenc values for both the keeps and discareds discards % nenc = count ( lspill_list ( 1 : nenc_old )) if ( ldestructive ) keeps % nenc = nenc_old - discards % nenc end associate return end subroutine util_spill_encounter module subroutine util_spill_pl ( self , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Move spilled (discarded) Swiftest massive body structure from active list to discard list !! Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter body by removing the discard list associate ( keeps => self ) select type ( discards ) ! The standard requires us to select the type of both arguments in order to access all the components class is ( swiftest_pl ) !> Spill components specific to the massive body class call util_spill ( keeps % mass , discards % mass , lspill_list , ldestructive ) call util_spill ( keeps % Gmass , discards % Gmass , lspill_list , ldestructive ) call util_spill ( keeps % rhill , discards % rhill , lspill_list , ldestructive ) call util_spill ( keeps % radius , discards % radius , lspill_list , ldestructive ) call util_spill ( keeps % density , discards % density , lspill_list , ldestructive ) call util_spill ( keeps % k2 , discards % k2 , lspill_list , ldestructive ) call util_spill ( keeps % Q , discards % Q , lspill_list , ldestructive ) call util_spill ( keeps % tlag , discards % tlag , lspill_list , ldestructive ) call util_spill ( keeps % xbeg , discards % xbeg , lspill_list , ldestructive ) call util_spill ( keeps % vbeg , discards % vbeg , lspill_list , ldestructive ) call util_spill ( keeps % Ip , discards % Ip , lspill_list , ldestructive ) call util_spill ( keeps % rot , discards % rot , lspill_list , ldestructive ) if ( ldestructive . and . allocated ( keeps % k_plpl )) deallocate ( keeps % k_plpl ) call util_spill_body ( keeps , discards , lspill_list , ldestructive ) class default write ( * , * ) 'Error! spill method called for incompatible return type on swiftest_pl' end select end associate return end subroutine util_spill_pl module subroutine util_spill_tp ( self , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Move spilled (discarded) Swiftest test particle structure from active list to discard list !! Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discardse logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter body by removing the discard list associate ( keeps => self , ntp => self % nbody ) select type ( discards ) class is ( swiftest_tp ) !> Spill components specific to the test particle class call util_spill ( keeps % isperi , discards % isperi , lspill_list , ldestructive ) call util_spill ( keeps % peri , discards % peri , lspill_list , ldestructive ) call util_spill ( keeps % atp , discards % atp , lspill_list , ldestructive ) call util_spill_body ( keeps , discards , lspill_list , ldestructive ) class default write ( * , * ) 'Error! spill method called for incompatible return type on swiftest_tp' end select end associate return end subroutine util_spill_tp end submodule s_util_spill","tags":"","loc":"sourcefile/util_spill.f90.html"},{"title":"util_valid.f90 – swiftest","text":"This file depends on sourcefile~~util_valid.f90~~EfferentGraph sourcefile~util_valid.f90 util_valid.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_valid.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_valid Source Code util_valid.f90 Source Code submodule ( swiftest_classes ) s_util_valid use swiftest contains module subroutine util_valid_id_system ( self , param ) !! author: David A. Minton !! !! Validate massive body and test particle ids !! Subroutine causes program to exit with error if any ids are not unique !! !! Adapted from David E. Kaufmann's Swifter routine: util_valid.f90 implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i integer ( I4B ), dimension (:), allocatable :: idarr associate ( cb => self % cb , pl => self % pl , npl => self % pl % nbody , tp => self % tp , ntp => self % tp % nbody ) allocate ( idarr ( 1 + npl + ntp )) idarr ( 1 ) = cb % id do i = 1 , npl idarr ( 1 + i ) = pl % id ( i ) end do do i = 1 , ntp idarr ( 1 + npl + i ) = tp % id ( i ) end do call util_sort ( idarr ) do i = 1 , npl + ntp if ( idarr ( i ) == idarr ( i + 1 )) then write ( * , * ) \"Swiftest error:\" write ( * , * ) \"   more than one body/particle has id = \" , idarr ( i ) call util_exit ( FAILURE ) end if end do param % maxid = max ( param % maxid , maxval ( idarr )) end associate return end subroutine util_valid_id_system end submodule s_util_valid","tags":"","loc":"sourcefile/util_valid.f90.html"},{"title":"util_exit.f90 – swiftest","text":"This file depends on sourcefile~~util_exit.f90~~EfferentGraph sourcefile~util_exit.f90 util_exit.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_exit.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_exit Source Code util_exit.f90 Source Code submodule ( swiftest_classes ) s_util_exit use swiftest contains module subroutine util_exit ( code ) !! author: David A. Minton !! !! Print termination message and exit program !! !! Adapted from David E. Kaufmann's Swifter routine: util_exit.f90 !! Adapted from Hal Levison's Swift routine util_exit.f implicit none ! Arguments integer ( I4B ), intent ( in ) :: code ! Internals character ( * ), parameter :: BAR = '(\"------------------------------------------------\")' select case ( code ) case ( SUCCESS ) write ( * , SUCCESS_MSG ) VERSION_NUMBER write ( * , BAR ) case ( USAGE ) write ( * , USAGE_MSG ) case ( HELP ) write ( * , HELP_MSG ) case default write ( * , FAIL_MSG ) VERSION_NUMBER write ( * , BAR ) error stop end select stop end subroutine util_exit end submodule s_util_exit","tags":"","loc":"sourcefile/util_exit.f90.html"},{"title":"util_fill.f90 – swiftest","text":"This file depends on sourcefile~~util_fill.f90~~EfferentGraph sourcefile~util_fill.f90 util_fill.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_fill.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_fill Source Code util_fill.f90 Source Code submodule ( swiftest_classes ) s_util_fill use swiftest contains module subroutine util_fill_arr_char_string ( keeps , inserts , lfill_list ) !! author: David A. Minton !! !! Performs a fill operation on a single array of type character strings !! This is the inverse of a spill operation implicit none ! Arguments character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep character ( len = STRMAX ), dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps if (. not . allocated ( keeps ) . or . . not . allocated ( inserts )) return keeps (:) = unpack ( keeps (:), . not . lfill_list (:), keeps (:)) keeps (:) = unpack ( inserts (:), lfill_list (:), keeps (:)) return end subroutine util_fill_arr_char_string module subroutine util_fill_arr_DP ( keeps , inserts , lfill_list ) !! author: David A. Minton !! !! Performs a fill operation on a single array of type DP !! This is the inverse of a spill operation implicit none ! Arguments real ( DP ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep real ( DP ), dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps if (. not . allocated ( keeps ) . or . . not . allocated ( inserts )) return keeps (:) = unpack ( keeps (:), . not . lfill_list (:), keeps (:)) keeps (:) = unpack ( inserts (:), lfill_list (:), keeps (:)) return end subroutine util_fill_arr_DP module subroutine util_fill_arr_DPvec ( keeps , inserts , lfill_list ) !! author: David A. Minton !! !! Performs a fill operation on a single array of DP vectors with shape (NDIM, n) !! This is the inverse of a spill operation implicit none ! Arguments real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: keeps !! Array of values to keep real ( DP ), dimension (:,:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps ! Internals integer ( I4B ) :: i if (. not . allocated ( keeps ) . or . . not . allocated ( inserts )) return do i = 1 , NDIM keeps ( i ,:) = unpack ( keeps ( i ,:), . not . lfill_list (:), keeps ( i ,:)) keeps ( i ,:) = unpack ( inserts ( i ,:), lfill_list (:), keeps ( i ,:)) end do return end subroutine util_fill_arr_DPvec module subroutine util_fill_arr_I4B ( keeps , inserts , lfill_list ) !! author: David A. Minton !! !! Performs a fill operation on a single array of type I4B !! This is the inverse of a spill operation implicit none ! Arguments integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep integer ( I4B ), dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps if (. not . allocated ( keeps ) . or . . not . allocated ( inserts )) return keeps (:) = unpack ( keeps (:), . not . lfill_list (:), keeps (:)) keeps (:) = unpack ( inserts (:), lfill_list (:), keeps (:)) return end subroutine util_fill_arr_I4B module subroutine util_fill_arr_info ( keeps , inserts , lfill_list ) !! author: David A. Minton !! !! Performs a fill operation on a single array of particle origin information types !! This is the inverse of a spill operation implicit none ! Arguments type ( swiftest_particle_info ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep type ( swiftest_particle_info ), dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps ! Internals integer ( I4B ), dimension (:), allocatable :: insert_idx integer ( I4B ) :: i , nkeep , ninsert if (. not . allocated ( keeps ) . or . . not . allocated ( inserts )) return nkeep = size ( keeps ) ninsert = count ( lfill_list ) allocate ( insert_idx ( ninsert )) insert_idx (:) = pack ([( i , i = 1 , nkeep )], lfill_list ) call util_copy_particle_info_arr ( inserts , keeps , insert_idx ) return end subroutine util_fill_arr_info module subroutine util_fill_arr_logical ( keeps , inserts , lfill_list ) !! author: David A. Minton !! !! Performs a fill operation on a single array of logicals !! This is the inverse of a spill operation implicit none ! Arguments logical , dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep logical , dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps if (. not . allocated ( keeps ) . or . . not . allocated ( inserts )) return keeps (:) = unpack ( keeps (:), . not . lfill_list (:), keeps (:)) keeps (:) = unpack ( inserts (:), lfill_list (:), keeps (:)) return end subroutine util_fill_arr_logical module subroutine util_fill_body ( self , inserts , lfill_list ) !! author: David A. Minton !! !! Insert new Swiftest generic particle structure into an old one. !! This is the inverse of a spill operation. implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest generic body object class ( swiftest_body ), intent ( in ) :: inserts !! Inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps ! internals integer ( I4B ) :: i ! For each component, pack the discarded bodies into the discard object and do the inverse with the keeps !> Fill all the common components associate ( keeps => self ) call util_fill ( keeps % id , inserts % id , lfill_list ) call util_fill ( keeps % info , inserts % info , lfill_list ) call util_fill ( keeps % status , inserts % status , lfill_list ) call util_fill ( keeps % ldiscard , inserts % ldiscard , lfill_list ) call util_fill ( keeps % lmask , inserts % lmask , lfill_list ) call util_fill ( keeps % mu , inserts % mu , lfill_list ) call util_fill ( keeps % xh , inserts % xh , lfill_list ) call util_fill ( keeps % vh , inserts % vh , lfill_list ) call util_fill ( keeps % xb , inserts % xb , lfill_list ) call util_fill ( keeps % vb , inserts % vb , lfill_list ) call util_fill ( keeps % ah , inserts % ah , lfill_list ) call util_fill ( keeps % aobl , inserts % aobl , lfill_list ) call util_fill ( keeps % agr , inserts % agr , lfill_list ) call util_fill ( keeps % atide , inserts % atide , lfill_list ) call util_fill ( keeps % a , inserts % a , lfill_list ) call util_fill ( keeps % e , inserts % e , lfill_list ) call util_fill ( keeps % inc , inserts % inc , lfill_list ) call util_fill ( keeps % capom , inserts % capom , lfill_list ) call util_fill ( keeps % omega , inserts % omega , lfill_list ) call util_fill ( keeps % capm , inserts % capm , lfill_list ) ! This is the base class, so will be the last to be called in the cascade. keeps % nbody = size ( keeps % id (:)) end associate return end subroutine util_fill_body module subroutine util_fill_pl ( self , inserts , lfill_list ) !! author: David A. Minton !! !! Insert new Swiftest massive body structure into an old one. !! This is the inverse of a spill operation. implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_body ), intent ( in ) :: inserts !! Swiftest body object to be inserted logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps ! Internals integer ( I4B ) :: i associate ( keeps => self ) select type ( inserts ) ! The standard requires us to select the type of both arguments in order to access all the components class is ( swiftest_pl ) !> Fill components specific to the massive body class call util_fill ( keeps % mass , inserts % mass , lfill_list ) call util_fill ( keeps % Gmass , inserts % Gmass , lfill_list ) call util_fill ( keeps % rhill , inserts % rhill , lfill_list ) call util_fill ( keeps % radius , inserts % radius , lfill_list ) call util_fill ( keeps % density , inserts % density , lfill_list ) call util_fill ( keeps % k2 , inserts % k2 , lfill_list ) call util_fill ( keeps % Q , inserts % Q , lfill_list ) call util_fill ( keeps % tlag , inserts % tlag , lfill_list ) call util_fill ( keeps % xbeg , inserts % xbeg , lfill_list ) call util_fill ( keeps % vbeg , inserts % vbeg , lfill_list ) call util_fill ( keeps % Ip , inserts % Ip , lfill_list ) call util_fill ( keeps % rot , inserts % rot , lfill_list ) if ( allocated ( keeps % k_plpl )) deallocate ( keeps % k_plpl ) call util_fill_body ( keeps , inserts , lfill_list ) class default write ( * , * ) 'Error! fill method called for incompatible return type on swiftest_pl' end select end associate return end subroutine util_fill_pl module subroutine util_fill_tp ( self , inserts , lfill_list ) !! author: David A. Minton !! !! Insert new Swiftest test particle structure into an old one. !! This is the inverse of a fill operation. implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_body ), intent ( in ) :: inserts !! Swiftest body object to be inserted logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps associate ( keeps => self ) select type ( inserts ) class is ( swiftest_tp ) !> Spill components specific to the test particle class call util_fill ( keeps % isperi , inserts % isperi , lfill_list ) call util_fill ( keeps % peri , inserts % peri , lfill_list ) call util_fill ( keeps % atp , inserts % atp , lfill_list ) call util_fill_body ( keeps , inserts , lfill_list ) class default write ( * , * ) 'Error! fill method called for incompatible return type on swiftest_tp' end select end associate return end subroutine util_fill_tp end submodule s_util_fill","tags":"","loc":"sourcefile/util_fill.f90.html"},{"title":"util_resize.f90 – swiftest","text":"This file depends on sourcefile~~util_resize.f90~~EfferentGraph sourcefile~util_resize.f90 util_resize.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_resize.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_resize Source Code util_resize.f90 Source Code submodule ( swiftest_classes ) s_util_resize use swiftest contains module subroutine util_resize_arr_char_string ( arr , nnew ) !! author: David A. Minton !! !! Resizes an array component of type character string. nnew = 0 will deallocate. implicit none ! Arguments character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size ! Internals character ( len = STRMAX ), dimension (:), allocatable :: tmp !! Temporary storage array in case the input array is already allocated integer ( I4B ) :: nold !! Old size if ( nnew < 0 ) return if ( nnew == 0 ) then if ( allocated ( arr )) deallocate ( arr ) return end if if ( allocated ( arr )) then nold = size ( arr ) else nold = 0 end if if ( nnew == nold ) return allocate ( tmp ( nnew )) if ( nold > 0 ) then if ( nnew > nold ) then tmp ( 1 : nold ) = arr ( 1 : nold ) tmp ( nold + 1 : nnew ) = \"\" else tmp ( 1 : nnew ) = arr ( 1 : nnew ) end if else tmp ( 1 : nnew ) = \"\" end if call move_alloc ( tmp , arr ) return end subroutine util_resize_arr_char_string module subroutine util_resize_arr_DP ( arr , nnew ) !! author: David A. Minton !! !! Resizes an array component of double precision type. Passing nnew = 0 will deallocate. implicit none ! Arguments real ( DP ), dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size ! Internals real ( DP ), dimension (:), allocatable :: tmp !! Temporary storage array in case the input array is already allocated integer ( I4B ) :: nold !! Old size real ( DP ), parameter :: init_val = 0.0_DP if ( nnew < 0 ) return if ( nnew == 0 ) then if ( allocated ( arr )) deallocate ( arr ) return end if if ( allocated ( arr )) then nold = size ( arr ) else nold = 0 end if if ( nnew == nold ) return allocate ( tmp ( nnew )) if ( nold > 0 ) then if ( nnew > nold ) then tmp ( 1 : nold ) = arr ( 1 : nold ) tmp ( nold + 1 : nnew ) = init_val else tmp ( 1 : nnew ) = arr ( 1 : nnew ) end if else tmp ( 1 : nnew ) = init_val end if call move_alloc ( tmp , arr ) return end subroutine util_resize_arr_DP module subroutine util_resize_arr_DPvec ( arr , nnew ) !! author: David A. Minton !! !! Resizes an array component of double precision vectors of size (NDIM, n). Passing nnew = 0 will deallocate. implicit none ! Arguments real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size ! Internals real ( DP ), dimension (:,:), allocatable :: tmp !! Temporary storage array in case the input array is already allocated integer ( I4B ) :: nold !! Old size real ( DP ), dimension ( NDIM ), parameter :: init_val = 0.0_DP integer ( I4B ) :: i if ( nnew < 0 ) return if ( nnew == 0 ) then if ( allocated ( arr )) deallocate ( arr ) return end if if ( allocated ( arr )) then nold = size ( arr , dim = 2 ) else nold = 0 end if if ( nnew == nold ) return allocate ( tmp ( NDIM , nnew )) if ( nold > 0 ) then if ( nnew > nold ) then tmp (:, 1 : nold ) = arr (:, 1 : nold ) do i = nold + 1 , nnew tmp (:, i ) = init_val (:) end do else tmp (:, 1 : nnew ) = arr (:, 1 : nnew ) end if else do i = 1 , nnew tmp (:, i ) = init_val (:) end do end if call move_alloc ( tmp , arr ) return return end subroutine util_resize_arr_DPvec module subroutine util_resize_arr_I4B ( arr , nnew ) !! author: David A. Minton !! !! Resizes an array component of integer type. Passing nnew = 0 will deallocate. implicit none ! Arguments integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size ! Internals integer ( I4B ), dimension (:), allocatable :: tmp !! Temporary storage array in case the input array is already allocated integer ( I4B ) :: nold !! Old size integer ( I4B ), parameter :: init_val = - 1 if ( nnew < 0 ) return if ( nnew == 0 ) then if ( allocated ( arr )) deallocate ( arr ) return end if if ( allocated ( arr )) then nold = size ( arr ) else nold = 0 end if if ( nnew == nold ) return allocate ( tmp ( nnew )) if ( nold > 0 ) then if ( nnew > nold ) then tmp ( 1 : nold ) = arr ( 1 : nold ) tmp ( nold + 1 : nnew ) = init_val else tmp ( 1 : nnew ) = arr ( 1 : nnew ) end if else tmp ( 1 : nnew ) = init_val end if call move_alloc ( tmp , arr ) return end subroutine util_resize_arr_I4B module subroutine util_resize_arr_info ( arr , nnew ) !! author: David A. Minton !! !! Resizes an array component of type character string. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. implicit none ! Arguments type ( swiftest_particle_info ), dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size ! Internals type ( swiftest_particle_info ), dimension (:), allocatable :: tmp !! Temporary storage array in case the input array is already allocated integer ( I4B ) :: nold !! Old size if ( nnew < 0 ) return if ( nnew == 0 ) then if ( allocated ( arr )) deallocate ( arr ) return end if if ( allocated ( arr )) then nold = size ( arr ) else nold = 0 end if if ( nnew == nold ) return allocate ( tmp ( nnew )) if ( nnew > nold ) then call util_copy_particle_info_arr ( arr ( 1 : nold ), tmp ( 1 : nold )) else call util_copy_particle_info_arr ( arr ( 1 : nnew ), tmp ( 1 : nnew )) end if call move_alloc ( tmp , arr ) return end subroutine util_resize_arr_info module subroutine util_resize_arr_logical ( arr , nnew ) !! author: David A. Minton !! !! Resizes an array component of logical type. Passing nnew = 0 will deallocate. implicit none ! Arguments logical , dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size ! Internals logical , dimension (:), allocatable :: tmp !! Temporary storage array in case the input array is already allocated integer ( I4B ) :: nold !! Old size logical , parameter :: init_val = . false . if ( nnew < 0 ) return if ( nnew == 0 ) then if ( allocated ( arr )) deallocate ( arr ) return end if if ( allocated ( arr )) then nold = size ( arr ) else nold = 0 end if if ( nnew == nold ) return allocate ( tmp ( nnew )) if ( nold > 0 ) then if ( nnew > nold ) then tmp ( 1 : nold ) = arr ( 1 : nold ) tmp ( nold + 1 : nnew ) = init_val else tmp ( 1 : nnew ) = arr ( 1 : nnew ) end if else tmp ( 1 : nnew ) = init_val end if call move_alloc ( tmp , arr ) return end subroutine util_resize_arr_logical module subroutine util_resize_body ( self , nnew ) !! author: David A. Minton !! !! Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object integer ( I4B ), intent ( in ) :: nnew !! New size neded call util_resize ( self % info , nnew ) call util_resize ( self % id , nnew ) call util_resize ( self % status , nnew ) call util_resize ( self % ldiscard , nnew ) call util_resize ( self % lmask , nnew ) call util_resize ( self % mu , nnew ) call util_resize ( self % xh , nnew ) call util_resize ( self % vh , nnew ) call util_resize ( self % xb , nnew ) call util_resize ( self % vb , nnew ) call util_resize ( self % ah , nnew ) call util_resize ( self % aobl , nnew ) call util_resize ( self % atide , nnew ) call util_resize ( self % agr , nnew ) call util_resize ( self % ir3h , nnew ) call util_resize ( self % a , nnew ) call util_resize ( self % e , nnew ) call util_resize ( self % inc , nnew ) call util_resize ( self % capom , nnew ) call util_resize ( self % omega , nnew ) call util_resize ( self % capm , nnew ) self % nbody = count ( self % status ( 1 : nnew ) /= INACTIVE ) return end subroutine util_resize_body module subroutine util_resize_encounter ( self , nnew ) !! author: David A. Minton !! !! Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small. !! Note: The reason to extend it by a factor of 2 is for performance. When there are many enounters per step, resizing every time you want to add an !! encounter takes significant computational effort. Resizing by a factor of 2 is a tradeoff between performance (fewer resize calls) and memory managment !! Memory usage grows by a factor of 2 each time it fills up, but no more. implicit none ! Arguments class ( swiftest_encounter ), intent ( inout ) :: self !! Swiftest encounter list integer ( I4B ), intent ( in ) :: nnew !! New size of list needed ! Internals class ( swiftest_encounter ), allocatable :: enc_temp integer ( I4B ) :: nold logical :: lmalloc lmalloc = allocated ( self % status ) if ( lmalloc ) then nold = size ( self % status ) else nold = 0 end if if ( nnew > nold ) then if ( lmalloc ) allocate ( enc_temp , source = self ) call self % setup ( 2 * nnew ) if ( lmalloc ) then call self % copy ( enc_temp ) deallocate ( enc_temp ) end if else self % status ( nnew + 1 : nold ) = INACTIVE end if self % nenc = nnew return end subroutine util_resize_encounter module subroutine util_resize_pl ( self , nnew ) !! author: David A. Minton !! !! Checks the current size of a Swiftest massive body against the requested size and resizes it if it is too small. implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object integer ( I4B ), intent ( in ) :: nnew !! New size neded call util_resize_body ( self , nnew ) call util_resize ( self % mass , nnew ) call util_resize ( self % Gmass , nnew ) call util_resize ( self % rhill , nnew ) call util_resize ( self % radius , nnew ) call util_resize ( self % xbeg , nnew ) call util_resize ( self % xend , nnew ) call util_resize ( self % vbeg , nnew ) call util_resize ( self % density , nnew ) call util_resize ( self % Ip , nnew ) call util_resize ( self % rot , nnew ) call util_resize ( self % k2 , nnew ) call util_resize ( self % Q , nnew ) call util_resize ( self % tlag , nnew ) if ( allocated ( self % k_plpl )) deallocate ( self % k_plpl ) return end subroutine util_resize_pl module subroutine util_resize_tp ( self , nnew ) !! author: David A. Minton !! !! Checks the current size of a Swiftest test particle against the requested size and resizes it if it is too small. implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object integer ( I4B ), intent ( in ) :: nnew !! New size neded call util_resize_body ( self , nnew ) call util_resize ( self % isperi , nnew ) call util_resize ( self % peri , nnew ) call util_resize ( self % atp , nnew ) return end subroutine util_resize_tp end submodule s_util_resize","tags":"","loc":"sourcefile/util_resize.f90.html"},{"title":"util_copy.f90 – swiftest","text":"This file depends on sourcefile~~util_copy.f90~~EfferentGraph sourcefile~util_copy.f90 util_copy.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_copy.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_copy Source Code util_copy.f90 Source Code submodule ( swiftest_classes ) s_util_copy use swiftest contains module subroutine util_copy_encounter ( self , source ) !! author: David A. Minton !! !! Copies elements from the source encounter list into self. implicit none ! Arguments class ( swiftest_encounter ), intent ( inout ) :: self !! Encounter list class ( swiftest_encounter ), intent ( in ) :: source !! Source object to copy into associate ( n => source % nenc ) self % nenc = n self % lvdotr ( 1 : n ) = source % lvdotr ( 1 : n ) self % status ( 1 : n ) = source % status ( 1 : n ) self % kidx ( 1 : n ) = source % kidx ( 1 : n ) self % index1 ( 1 : n ) = source % index1 ( 1 : n ) self % index2 ( 1 : n ) = source % index2 ( 1 : n ) self % id1 ( 1 : n ) = source % id1 ( 1 : n ) self % id2 ( 1 : n ) = source % id2 ( 1 : n ) self % x1 (:, 1 : n ) = source % x1 (:, 1 : n ) self % x2 (:, 1 : n ) = source % x2 (:, 1 : n ) self % v1 (:, 1 : n ) = source % v1 (:, 1 : n ) self % v2 (:, 1 : n ) = source % v2 (:, 1 : n ) self % t ( 1 : n ) = source % t ( 1 : n ) end associate return end subroutine util_copy_encounter module subroutine util_copy_particle_info ( self , source ) !! author: David A. Minton !! !! Copies one set of information object components into another, component-by-component implicit none class ( swiftest_particle_info ), intent ( inout ) :: self class ( swiftest_particle_info ), intent ( in ) :: source call self % set_value (& name = source % name , & particle_type = source % particle_type , & status = source % status , & origin_type = source % origin_type , & origin_time = source % origin_time , & origin_xh = source % origin_xh (:), & origin_vh = source % origin_vh (:), & discard_time = source % discard_time , & discard_xh = source % discard_xh (:), & discard_vh = source % discard_vh (:), & discard_body_id = source % discard_body_id & ) return end subroutine util_copy_particle_info module subroutine util_copy_particle_info_arr ( source , dest , idx ) !! author: David A. Minton !! !! Copies contents from an array of one particle information objects to another. implicit none class ( swiftest_particle_info ), dimension (:), intent ( in ) :: source !! Source object to copy into class ( swiftest_particle_info ), dimension (:), intent ( inout ) :: dest !! Swiftest body object with particle metadata information object integer ( I4B ), dimension (:), intent ( in ), optional :: idx !! Optional array of indices to draw the source object ! Internals integer ( I4B ) :: i , j , n , nsource , ndest if ( size ( source ) == 0 ) return if ( present ( idx )) then n = size ( idx ) else n = size ( source ) end if nsource = size ( source ) ndest = size ( dest ) if (( n == 0 ) . or . ( n > ndest ) . or . ( n > nsource )) then write ( * , * ) 'Particle info copy operation failed. n, nsource, ndest: ' , n , nsource , ndest return end if do i = 1 , n if ( present ( idx )) then j = idx ( i ) else j = i end if call dest ( i )% copy ( source ( j )) end do return end subroutine util_copy_particle_info_arr end submodule s_util_copy","tags":"","loc":"sourcefile/util_copy.f90.html"},{"title":"util_minimize_bfgs.f90 – swiftest","text":"This file depends on sourcefile~~util_minimize_bfgs.f90~~EfferentGraph sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_minimize_bfgs Source Code util_minimize_bfgs.f90 Source Code submodule ( swiftest_classes ) s_util_minimize_bfgs use swiftest contains module function util_minimize_bfgs ( f , N , x0 , eps , maxloop , lerr ) result ( x1 ) !! author: David A. Minton !! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - !! This function implements the Broyden-Fletcher-Goldfarb-Shanno method to determine the minimum of a function of N variables. !! It recieves as input: !!   f%eval(x) : lambda function object containing the objective function as the eval metho !!   N       : Number of variables of function f !!   x0      : Initial starting value of x !!   eps     : Accuracy of 1 - dimensional minimization at each step !!   maxloop : Maximum number of loops to attempt to find a solution !! The outputs include !!   lerr :  Returns .true. if it could not find the minimum !! Returns !!   x1   :  Final minimum (all 0 if none found) !!   0 = No miniumum found !! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - use , intrinsic :: ieee_exceptions implicit none ! Arguments integer ( I4B ), intent ( in ) :: N class ( lambda_obj ), intent ( inout ) :: f real ( DP ), dimension (:), intent ( in ) :: x0 real ( DP ), intent ( in ) :: eps integer ( I4B ), intent ( in ) :: maxloop logical , intent ( out ) :: lerr ! Result real ( DP ), dimension (:), allocatable :: x1 ! Internals integer ( I4B ) :: i , j , k , l , conv , num real ( DP ), parameter :: graddelta = 1e-4_DP !! Delta x for gradient calculations real ( DP ), dimension ( N ) :: S !! Direction vectors real ( DP ), dimension ( N , N ) :: H !! Approximated inverse Hessian matrix real ( DP ), dimension ( N ) :: grad1 !! gradient of f real ( DP ), dimension ( N ) :: grad0 !! old value of gradient real ( DP ) :: astar !! 1D minimized value real ( DP ), dimension ( N ) :: y , P real ( DP ), dimension ( N , N ) :: PP , PyH , HyP real ( DP ) :: yHy , Py type ( ieee_status_type ) :: original_fpe_status logical , dimension (:), allocatable :: fpe_flag call ieee_get_status ( original_fpe_status ) ! Save the original floating point exception status call ieee_set_flag ( ieee_all , . false .) ! Set all flags to quiet allocate ( fpe_flag ( size ( ieee_usual ))) lerr = . false . allocate ( x1 , source = x0 ) ! Initialize approximate Hessian with the identity matrix (i.e. begin with method of steepest descent) ! Get initial gradient and initialize arrays for updated values of gradient and x H (:,:) = reshape ([(( 0._DP , i = 1 , j - 1 ), 1._DP , ( 0._DP , i = j + 1 , N ), j = 1 , N )], [ N , N ]) grad0 = gradf ( f , N , x0 (:), graddelta , lerr ) if ( lerr ) then call ieee_set_status ( original_fpe_status ) return end if grad1 (:) = grad0 (:) do i = 1 , maxloop !check for convergence conv = count ( abs ( grad1 (:)) > eps ) if ( conv == 0 ) exit S (:) = - matmul ( H (:,:), grad1 (:)) astar = minimize1D ( f , x1 , S , N , graddelta , lerr ) if ( lerr ) exit ! Get new x values P (:) = astar * S (:) x1 (:) = x1 (:) + P (:) ! Calculate new gradient grad0 (:) = grad1 (:) grad1 = gradf ( f , N , x1 , graddelta , lerr ) y (:) = grad1 (:) - grad0 (:) Py = sum ( P (:) * y (:)) ! set up factors for H matrix update yHy = 0._DP !$omp do simd schedule(static)& !$omp firstprivate(N, y, H) & !$omp reduction(+:yHy) do k = 1 , N do j = 1 , N yHy = yHy + y ( j ) * H ( j , k ) * y ( k ) end do end do !$omp end do simd ! prevent divide by zero (convergence) if ( abs ( Py ) < tiny ( Py )) exit ! set up update PyH (:,:) = 0._DP HyP (:,:) = 0._DP !$omp parallel do default(private) schedule(static)& !$omp shared(N, PP, P, y, H) & !$omp reduction(+:PyH, HyP) do k = 1 , N do j = 1 , N PP ( j , k ) = P ( j ) * P ( k ) do l = 1 , N PyH ( j , k ) = PyH ( j , k ) + P ( j ) * y ( l ) * H ( l , k ) HyP ( j , k ) = HyP ( j , k ) + P ( k ) * y ( l ) * H ( j , l ) end do end do end do !$omp end parallel do ! update H matrix H (:,:) = H (:,:) + (( 1._DP - yHy / Py ) * PP (:,:) - PyH (:,:) - HyP (:,:)) / Py ! Normalize to prevent it from blowing up if it takes many iterations to find a solution H (:,:) = H (:,:) / norm2 ( H (:,:)) ! Stop everything if there are any exceptions to allow the routine to fail gracefully call ieee_get_flag ( ieee_usual , fpe_flag ) if ( any ( fpe_flag )) exit if ( i == maxloop ) then lerr = . true . end if end do call ieee_get_flag ( ieee_usual , fpe_flag ) lerr = lerr . or . any ( fpe_flag ) call ieee_set_status ( original_fpe_status ) return contains function gradf ( f , N , x1 , dx , lerr ) result ( grad ) !! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - !! Purpose:  Estimates the gradient of a function using a central difference !! approximation !! Inputs: !!   f%eval(x) : lambda function object containing the objective function as the eval metho !!   N    :  number of variables N !!   x1   :  x value array !!   dx   :  step size to use when calculating derivatives !! Outputs: !!   lerr : .true. if an error occurred. Otherwise returns .false. !! Returns !!   grad :  N sized array containing estimated gradient of f at x1 !! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - implicit none ! Arguments integer ( I4B ), intent ( in ) :: N class ( lambda_obj ), intent ( inout ) :: f real ( DP ), dimension (:), intent ( in ) :: x1 real ( DP ), intent ( in ) :: dx logical , intent ( out ) :: lerr ! Result real ( DP ), dimension ( N ) :: grad ! Internals integer ( I4B ) :: i , j real ( DP ), dimension ( N ) :: xp , xm real ( DP ) :: fp , fm logical :: lerrp , lerrm do i = 1 , N do j = 1 , N if ( j == i ) then xp ( j ) = x1 ( j ) + dx xm ( j ) = x1 ( j ) - dx else xp ( j ) = x1 ( j ) xm ( j ) = x1 ( j ) end if end do select type ( f ) class is ( lambda_obj_err ) fp = f % eval ( xp ) lerrp = f % lerr fm = f % eval ( xm ) lerrm = f % lerr lerr = lerrp . or . lerrm class is ( lambda_obj ) fp = f % eval ( xp ) fm = f % eval ( xm ) lerr = . false . end select grad ( i ) = ( fp - fm ) / ( 2 * dx ) if ( lerr ) return end do return end function gradf function minimize1D ( f , x0 , S , N , eps , lerr ) result ( astar ) !! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - !! This program find the minimum of a function of N variables in a single direction !! S using in sequence: !!    1.  A Bracketing method !!    2.  The golden section method !!    3.  A quadratic polynomial fit !! Inputs !!   f%eval(x) : lambda function object containing the objective function as the eval metho !!   x0   :  Array of size N of initial x values !!   S    :  Array of size N that determines the direction of minimization !!   N    :  Number of variables of function f !!   eps  :  Accuracy of 1 - dimensional minimization at each step !! Output !!   lerr : .true. if an error occurred. Otherwise returns .false. !! Returns !!   astar      :  Final minimum along direction S !! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - implicit none ! Arguments integer ( I4B ), intent ( in ) :: N class ( lambda_obj ), intent ( inout ) :: f real ( DP ), dimension (:), intent ( in ) :: x0 , S real ( DP ), intent ( in ) :: eps logical , intent ( out ) :: lerr ! Result real ( DP ) :: astar ! Internals integer ( I4B ) :: num = 0 real ( DP ), parameter :: step = 0.7_DP !! Bracketing method step size real ( DP ), parameter :: gam = 1.2_DP !! Bracketing method expansion parameter real ( DP ), parameter :: greduce = 0.2_DP !! Golden section method reduction factor real ( DP ), parameter :: greduce2 = 0.1_DP ! Secondary golden section method reduction factor real ( DP ) :: alo , ahi !! High and low values for 1 - D minimization routines real ( DP ), parameter :: a0 = epsilon ( 1.0_DP ) !! Initial guess of alpha alo = a0 call bracket ( f , x0 , S , N , gam , step , alo , ahi , lerr ) if ( lerr ) then !write(*,*) \"BFGS bracketing step failed!\" return end if if ( abs ( alo - ahi ) < eps ) then astar = alo lerr = . false . return end if call golden ( f , x0 , S , N , greduce , alo , ahi , lerr ) if ( lerr ) then !write(*,*) \"BFGS golden section step failed!\" return end if if ( abs ( alo - ahi ) < eps ) then astar = alo lerr = . false . return end if call quadfit ( f , x0 , S , N , eps , alo , ahi , lerr ) if ( lerr ) then !write(*,*) \"BFGS quadfit failed!\" return end if if ( abs ( alo - ahi ) < eps ) then astar = alo lerr = . false . return end if ! Quadratic fit method won't converge, so finish off with another golden section call golden ( f , x0 , S , N , greduce2 , alo , ahi , lerr ) if (. not . lerr ) astar = ( alo + ahi ) / 2.0_DP return end function minimize1D function n2one ( f , x0 , S , N , a , lerr ) result ( fnew ) implicit none ! Arguments integer ( I4B ), intent ( in ) :: N class ( lambda_obj ), intent ( inout ) :: f real ( DP ), dimension (:), intent ( in ) :: x0 , S real ( DP ), intent ( in ) :: a logical , intent ( out ) :: lerr ! Return real ( DP ) :: fnew ! Internals real ( DP ), dimension ( N ) :: xnew integer ( I4B ) :: i xnew (:) = x0 (:) + a * S (:) fnew = f % eval ( xnew (:)) select type ( f ) class is ( lambda_obj_err ) lerr = f % lerr class is ( lambda_obj ) lerr = . false . end select return end function n2one ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - subroutine bracket ( f , x0 , S , N , gam , step , lo , hi , lerr ) ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - !! This subroutine brackets the minimum.  It recieves as input: !!   f%eval(x) : lambda function object containing the objective function as the eval metho !!   x0   :  Array of size N of initial x values !!   S    :  Array of size N that determines the direction of minimization !!   gam  :  expansion parameter !!   step :  step size !!   lo   :  initial guess of lo bracket value !! The outputs include !!   lo   :  lo bracket !!   hi   :  hi bracket !!   lerr : .true. if an error occurred. Otherwise returns .false. !! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - implicit none ! Arguments integer ( I4B ), intent ( in ) :: N class ( lambda_obj ), intent ( inout ) :: f real ( DP ), dimension (:), intent ( in ) :: x0 , S real ( DP ), intent ( in ) :: gam , step real ( DP ), intent ( inout ) :: lo real ( DP ), intent ( out ) :: hi logical , intent ( out ) :: lerr ! Internals real ( DP ) :: a0 , a1 , a2 , atmp , da real ( DP ) :: f0 , f1 , f2 integer ( I4B ) :: i , j integer ( I4B ), parameter :: MAXLOOP = 100 ! maximum number of loops before method is determined to have failed real ( DP ), parameter :: eps = epsilon ( lo ) ! small number precision to test floating point equality ! set up initial bracket points a0 = lo da = step a1 = a0 + da a2 = a0 + 2 * da f0 = n2one ( f , x0 , S , N , a0 , lerr ) if ( lerr ) return f1 = n2one ( f , x0 , S , N , a1 , lerr ) if ( lerr ) return f2 = n2one ( f , x0 , S , N , a2 , lerr ) if ( lerr ) return ! loop over bracket method until either min is bracketed method fails do i = 1 , MAXLOOP if (( f0 > f1 ) . and . ( f1 < f2 )) then ! Minimum was found lo = a0 hi = a2 return else if (( f0 >= f1 ) . and . ( f1 > f2 )) then ! Function appears to decrease da = da * gam atmp = a2 + da a0 = a1 a1 = a2 a2 = atmp f0 = f1 f1 = f2 f2 = n2one ( f , x0 , S , N , a2 , lerr ) else if (( f0 < f1 ) . and . ( f1 <= f2 )) then ! Function appears to increase da = da * gam atmp = a0 - da a2 = a1 a1 = a0 a0 = atmp f2 = f1 f0 = n2one ( f , x0 , S , N , a0 , lerr ) else if (( f0 < f1 ) . and . ( f1 > f2 )) then ! We are at a peak. Pick the direction that descends the fastest da = da * gam if ( f2 > f0 ) then ! LHS is lower than RHS atmp = a2 + da a0 = a1 a1 = a2 a2 = atmp f0 = f1 f1 = f2 f2 = n2one ( f , x0 , S , N , a2 , lerr ) else ! RHS is lower than LHS atmp = a0 - da a2 = a1 a1 = a0 a0 = atmp f2 = f1 f1 = f2 f0 = n2one ( f , x0 , S , N , a0 , lerr ) end if else if (( f0 > f1 ) . and . ( abs ( f2 - f1 ) <= eps )) then ! Decrasging but RHS equal da = da * gam atmp = a2 + da a2 = atmp f2 = n2one ( f , x0 , S , N , a2 , lerr ) else if (( abs ( f0 - f1 ) < eps ) . and . ( f1 < f2 )) then ! Increasing but LHS equal da = da * gam atmp = a0 - da a0 = atmp f0 = n2one ( f , x0 , S , N , a0 , lerr ) else ! all values equal. Expand in either direction and try again a0 = a0 - da a2 = a2 + da f0 = n2one ( f , x0 , S , N , a0 , lerr ) if ( lerr ) exit ! An error occurred while evaluating the function f2 = n2one ( f , x0 , S , N , a2 , lerr ) end if if ( lerr ) exit ! An error occurred while evaluating the function end do lerr = . true . return ! no minimum found end subroutine bracket ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - subroutine golden ( f , x0 , S , N , eps , lo , hi , lerr ) ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - !! This function uses the golden section method to reduce the starting interval lo, hi by some amount sigma. !! It recieves as input: !!   f%eval(x) : lambda function object containing the objective function as the eval metho !!   x0   :  Array of size N of initial x values !!   S    :  Array of size N that determines the direction of minimization !!   gam  :  expansion parameter !!   eps  :  reduction interval in range (0 < sigma < 1) such that: !!             hi(new) - lo(new) = eps * (hi(old) - lo(old)) !!   lo   :  initial guess of lo bracket value !! The outputs include !!   lo   :  lo bracket !!   hi   :  hi bracket !!   lerr : .true. if an error occurred. Otherwise returns .false. !! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - implicit none ! Arguments integer ( I4B ), intent ( in ) :: N class ( lambda_obj ), intent ( inout ) :: f real ( DP ), dimension (:), intent ( in ) :: x0 , S real ( DP ), intent ( in ) :: eps real ( DP ), intent ( inout ) :: lo real ( DP ), intent ( out ) :: hi logical , intent ( out ) :: lerr ! Internals real ( DP ), parameter :: tau = 0.5_DP * ( sqrt ( 5.0_DP ) - 1.0_DP ) ! Golden section constant integer ( I4B ), parameter :: MAXLOOP = 40 ! maximum number of loops before method is determined to have failed (unlikely, but could occur if no minimum exists between lo and hi) real ( DP ) :: i0 ! Initial interval value real ( DP ) :: a1 , a2 real ( DP ) :: f1 , f2 integer ( I4B ) :: i , j i0 = hi - lo a1 = hi - tau * i0 a2 = lo + tau * i0 f1 = n2one ( f , x0 , S , N , a1 , lerr ) if ( lerr ) return f2 = n2one ( f , x0 , S , N , a2 , lerr ) if ( lerr ) return do i = 1 , MAXLOOP if ( abs (( hi - lo ) / i0 ) <= eps ) return ! interval reduced to input amount if ( f2 > f1 ) then hi = a2 a2 = a1 f2 = f1 a1 = hi - tau * ( hi - lo ) f1 = n2one ( f , x0 , S , N , a1 , lerr ) else lo = a1 a1 = a2 f2 = f1 a2 = hi - ( 1.0_DP - tau ) * ( hi - lo ) f2 = n2one ( f , x0 , S , N , a2 , lerr ) end if if ( lerr ) exit end do lerr = . true . return ! search took too many iterations - no minimum found end subroutine golden ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - subroutine quadfit ( f , x0 , S , N , eps , lo , hi , lerr ) ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - !! This function uses a quadratic polynomial fit to locate the minimum of a function !! to some accuracy eps.  It recieves as input: !!   f%eval(x) : lambda function object containing the objective function as the eval metho !!   lo    :  low bracket value !!   hi    :  high bracket value !!   eps   :  desired accuracy of final minimum location !! The outputs include !!   lo   :  final minimum location !!   hi   :  final minimum location !! Notes: Uses the ieee_exceptions intrinsic module to allow for graceful failure due to floating point exceptions, which won't terminate the run. !! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - implicit none ! Arguments integer ( I4B ), intent ( in ) :: N class ( lambda_obj ), intent ( inout ) :: f real ( DP ), dimension (:), intent ( in ) :: x0 , S real ( DP ), intent ( in ) :: eps real ( DP ), intent ( inout ) :: lo real ( DP ), intent ( out ) :: hi logical , intent ( out ) :: lerr ! Internals integer ( I4B ), parameter :: MAXLOOP = 20 ! maximum number of loops before method is determined to have failed. real ( DP ) :: a1 , a2 , a3 , astar ! three points for the polynomial fit and polynomial minimum real ( DP ) :: f1 , f2 , f3 , fstar ! three function values for the polynomial and polynomial minimum real ( DP ), dimension ( 3 ) :: row_1 , row_2 , row_3 , rhs , soln ! matrix for 3 equation solver (gaussian elimination) real ( DP ), dimension ( 3 , 3 ) :: lhs real ( DP ) :: d1 , d2 , d3 , aold , denom , errval integer ( I4B ) :: i lerr = . false . ! Get initial a1, a2, a3 values a1 = lo a2 = lo + 0.5_DP * ( hi - lo ) a3 = hi aold = a1 astar = a2 f1 = n2one ( f , x0 , S , N , a1 , lerr ) if ( lerr ) return f2 = n2one ( f , x0 , S , N , a2 , lerr ) if ( lerr ) return f3 = n2one ( f , x0 , S , N , a3 , lerr ) if ( lerr ) return do i = 1 , MAXLOOP ! check to see if convergence is reached and exit errval = abs (( astar - aold ) / astar ) call ieee_get_flag ( ieee_usual , fpe_flag ) if ( any ( fpe_flag )) then !write(*,*) 'quadfit fpe' !write(*,*) 'aold : ',aold !write(*,*) 'astar: ',astar lerr = . true . exit end if if ( errval < eps ) then lo = astar hi = astar exit end if ! Set up system for gaussian elimination equation solver row_1 = [ 1.0_DP , a1 , a1 ** 2 ] row_2 = [ 1.0_DP , a2 , a2 ** 2 ] row_3 = [ 1.0_DP , a3 , a3 ** 2 ] rhs = [ f1 , f2 , f3 ] lhs ( 1 , :) = row_1 lhs ( 2 , :) = row_2 lhs ( 3 , :) = row_3 ! Solve system of equations soln (:) = util_solve_linear_system ( lhs , rhs , 3 , lerr ) call ieee_set_flag ( ieee_all , . false .) ! Set all flags back to quiet call ieee_set_halting_mode ( ieee_divide_by_zero , . false .) if ( lerr ) then !write(*,*) 'quadfit fpe:' !write(*,*) 'util_solve_linear_system failed' exit end if aold = astar if ( soln ( 2 ) == soln ( 3 )) then ! Handles the case where they are both 0. 0/0 is an unhandled exception astar = - 0.5_DP else astar = - soln ( 2 ) / ( 2 * soln ( 3 )) end if call ieee_get_flag ( ieee_usual , fpe_flag ) if ( any ( fpe_flag )) then !write(*,*) 'quadfit fpe' !write(*,*) 'soln(2:3): ',soln(2:3) !write(*,*) 'a1, a2, a3' !write(*,*) a1, a2, a3 !write(*,*) 'f1, f2, f3' !write(*,*) f1, f2, f3 lerr = . true . exit end if fstar = n2one ( f , x0 , S , N , astar , lerr ) if ( lerr ) exit ! keep the three closest a values to astar and discard the fourth d1 = abs ( a1 - astar ) d2 = abs ( a2 - astar ) d3 = abs ( a3 - astar ) if ( d1 > d2 ) then if ( d1 > d3 ) then f1 = fstar a1 = astar else if ( d3 > d2 ) then f3 = fstar a3 = astar end if else if ( d2 > d3 ) then f2 = fstar a2 = astar else if ( d3 > d1 ) then f3 = fstar a3 = astar end if end if end do if ( lerr ) return lo = a1 hi = a3 return end subroutine quadfit end function util_minimize_bfgs end submodule s_util_minimize_bfgs","tags":"","loc":"sourcefile/util_minimize_bfgs.f90.html"},{"title":"util_append.f90 – swiftest","text":"This file depends on sourcefile~~util_append.f90~~EfferentGraph sourcefile~util_append.f90 util_append.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_append.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_append Source Code util_append.f90 Source Code submodule ( swiftest_classes ) s_util_append use swiftest contains module subroutine util_append_arr_char_string ( arr , source , nold , nsrc , lsource_mask ) !! author: David A. Minton !! !! Append a single array of character string type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. implicit none ! Arguments character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array character ( len = STRMAX ), dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to ! Internals integer ( I4B ) :: nnew if (. not . allocated ( source )) return nnew = count ( lsource_mask ( 1 : nsrc )) if (. not . allocated ( arr )) then allocate ( arr ( nold + nnew )) else call util_resize ( arr , nold + nnew ) end if arr ( nold + 1 : nold + nnew ) = pack ( source ( 1 : nsrc ), lsource_mask ( 1 : nsrc )) return end subroutine util_append_arr_char_string module subroutine util_append_arr_DP ( arr , source , nold , nsrc , lsource_mask ) !! author: David A. Minton !! !! Append a single array of double precision type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. implicit none ! Arguments real ( DP ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array real ( DP ), dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to ! Internals integer ( I4B ) :: nnew if (. not . allocated ( source )) return nnew = count ( lsource_mask ( 1 : nsrc )) if (. not . allocated ( arr )) then allocate ( arr ( nold + nnew )) else call util_resize ( arr , nold + nnew ) end if arr ( nold + 1 : nold + nnew ) = pack ( source ( 1 : nsrc ), lsource_mask ( 1 : nsrc )) return end subroutine util_append_arr_DP module subroutine util_append_arr_DPvec ( arr , source , nold , nsrc , lsource_mask ) !! author: David A. Minton !! !! Append a single array of double precision vector type of size (NDIM, n) onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. implicit none ! Arguments real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: arr !! Destination array real ( DP ), dimension (:,:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to ! Internals integer ( I4B ) :: nnew if (. not . allocated ( source )) return nnew = count ( lsource_mask ( 1 : nsrc )) if (. not . allocated ( arr )) then allocate ( arr ( NDIM , nold + nnew )) else call util_resize ( arr , nold + nnew ) end if arr ( 1 , nold + 1 : nold + nnew ) = pack ( source ( 1 , 1 : nsrc ), lsource_mask ( 1 : nsrc )) arr ( 2 , nold + 1 : nold + nnew ) = pack ( source ( 2 , 1 : nsrc ), lsource_mask ( 1 : nsrc )) arr ( 3 , nold + 1 : nold + nnew ) = pack ( source ( 3 , 1 : nsrc ), lsource_mask ( 1 : nsrc )) return end subroutine util_append_arr_DPvec module subroutine util_append_arr_I4B ( arr , source , nold , nsrc , lsource_mask ) !! author: David A. Minton !! !! Append a single array of integer(I4B) onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. implicit none ! Arguments integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array integer ( I4B ), dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to ! Internals integer ( I4B ) :: nnew if (. not . allocated ( source )) return nnew = count ( lsource_mask ( 1 : nsrc )) if (. not . allocated ( arr )) then allocate ( arr ( nold + nnew )) else call util_resize ( arr , nold + nnew ) end if arr ( nold + 1 : nold + nnew ) = pack ( source ( 1 : nsrc ), lsource_mask ( 1 : nsrc )) return end subroutine util_append_arr_I4B module subroutine util_append_arr_info ( arr , source , nold , nsrc , lsource_mask ) !! author: David A. Minton !! !! Append a single array of particle information type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. implicit none ! Arguments type ( swiftest_particle_info ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array type ( swiftest_particle_info ), dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to ! Internals integer ( I4B ) :: nnew , i integer ( I4B ), dimension (:), allocatable :: idx if (. not . allocated ( source )) return nnew = count ( lsource_mask ( 1 : nsrc )) if (. not . allocated ( arr )) then allocate ( arr ( nold + nnew )) else call util_resize ( arr , nold + nnew ) end if allocate ( idx ( nnew )) idx = pack ([( i , i = 1 , nsrc )], lsource_mask ( 1 : nsrc )) call util_copy_particle_info_arr ( source ( 1 : nsrc ), arr ( nold + 1 : nold + nnew ), idx ) return end subroutine util_append_arr_info module subroutine util_append_arr_logical ( arr , source , nold , nsrc , lsource_mask ) !! author: David A. Minton !! !! Append a single array of logical type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. implicit none ! Arguments logical , dimension (:), allocatable , intent ( inout ) :: arr !! Destination array logical , dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to ! Internals integer ( I4B ) :: nnew if (. not . allocated ( source )) return nnew = count ( lsource_mask ( 1 : nsrc )) if (. not . allocated ( arr )) then allocate ( arr ( nold + nnew )) else call util_resize ( arr , nold + nnew ) end if arr ( nold + 1 : nold + nnew ) = pack ( source ( 1 : nsrc ), lsource_mask ( 1 : nsrc )) return end subroutine util_append_arr_logical module subroutine util_append_body ( self , source , lsource_mask ) !! author: David A. Minton !! !! Append components from one Swiftest body object to another. !! This method will automatically resize the destination body if it is too small implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to ! Internals integer ( I4B ) :: nold , nsrc , nnew nold = self % nbody nsrc = source % nbody nnew = count ( lsource_mask ( 1 : nsrc )) call util_append ( self % info , source % info , nold , nsrc , lsource_mask ) call util_append ( self % id , source % id , nold , nsrc , lsource_mask ) call util_append ( self % status , source % status , nold , nsrc , lsource_mask ) call util_append ( self % ldiscard , source % ldiscard , nold , nsrc , lsource_mask ) call util_append ( self % lmask , source % lmask , nold , nsrc , lsource_mask ) call util_append ( self % mu , source % mu , nold , nsrc , lsource_mask ) call util_append ( self % xh , source % xh , nold , nsrc , lsource_mask ) call util_append ( self % vh , source % vh , nold , nsrc , lsource_mask ) call util_append ( self % xb , source % xb , nold , nsrc , lsource_mask ) call util_append ( self % vb , source % vb , nold , nsrc , lsource_mask ) call util_append ( self % ah , source % ah , nold , nsrc , lsource_mask ) call util_append ( self % aobl , source % aobl , nold , nsrc , lsource_mask ) call util_append ( self % atide , source % atide , nold , nsrc , lsource_mask ) call util_append ( self % agr , source % agr , nold , nsrc , lsource_mask ) call util_append ( self % ir3h , source % ir3h , nold , nsrc , lsource_mask ) call util_append ( self % a , source % a , nold , nsrc , lsource_mask ) call util_append ( self % e , source % e , nold , nsrc , lsource_mask ) call util_append ( self % inc , source % inc , nold , nsrc , lsource_mask ) call util_append ( self % capom , source % capom , nold , nsrc , lsource_mask ) call util_append ( self % omega , source % omega , nold , nsrc , lsource_mask ) call util_append ( self % capm , source % capm , nold , nsrc , lsource_mask ) self % nbody = nold + nnew return end subroutine util_append_body module subroutine util_append_encounter ( self , source , lsource_mask ) !! author: David A. Minton !! !! Append components from one Swiftest body object to another. !! This method will automatically resize the destination body if it is too small implicit none ! Arguments class ( swiftest_encounter ), intent ( inout ) :: self !! Swiftest encounter list object class ( swiftest_encounter ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to ! Internals integer ( I4B ) :: nold , nsrc nold = self % nenc nsrc = source % nenc call util_append ( self % lvdotr , source % lvdotr , nold , nsrc , lsource_mask ) call util_append ( self % status , source % status , nold , nsrc , lsource_mask ) call util_append ( self % index1 , source % index1 , nold , nsrc , lsource_mask ) call util_append ( self % index2 , source % index2 , nold , nsrc , lsource_mask ) call util_append ( self % id1 , source % id1 , nold , nsrc , lsource_mask ) call util_append ( self % id2 , source % id2 , nold , nsrc , lsource_mask ) call util_append ( self % x1 , source % x1 , nold , nsrc , lsource_mask ) call util_append ( self % x2 , source % x2 , nold , nsrc , lsource_mask ) call util_append ( self % v1 , source % v1 , nold , nsrc , lsource_mask ) call util_append ( self % v2 , source % v2 , nold , nsrc , lsource_mask ) call util_append ( self % t , source % t , nold , nsrc , lsource_mask ) self % nenc = nold + count ( lsource_mask ( 1 : nsrc )) return end subroutine util_append_encounter module subroutine util_append_pl ( self , source , lsource_mask ) !! author: David A. Minton !! !! Append components from one Swiftest body object to another. !! This method will automatically resize the destination body if it is too small implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to select type ( source ) class is ( swiftest_pl ) associate ( nold => self % nbody , nsrc => source % nbody ) call util_append ( self % mass , source % mass , nold , nsrc , lsource_mask ) call util_append ( self % Gmass , source % Gmass , nold , nsrc , lsource_mask ) call util_append ( self % rhill , source % rhill , nold , nsrc , lsource_mask ) call util_append ( self % radius , source % radius , nold , nsrc , lsource_mask ) call util_append ( self % xbeg , source % xbeg , nold , nsrc , lsource_mask ) call util_append ( self % xend , source % xend , nold , nsrc , lsource_mask ) call util_append ( self % vbeg , source % vbeg , nold , nsrc , lsource_mask ) call util_append ( self % density , source % density , nold , nsrc , lsource_mask ) call util_append ( self % Ip , source % Ip , nold , nsrc , lsource_mask ) call util_append ( self % rot , source % rot , nold , nsrc , lsource_mask ) call util_append ( self % k2 , source % k2 , nold , nsrc , lsource_mask ) call util_append ( self % Q , source % Q , nold , nsrc , lsource_mask ) call util_append ( self % tlag , source % tlag , nold , nsrc , lsource_mask ) if ( allocated ( self % k_plpl )) deallocate ( self % k_plpl ) call util_append_body ( self , source , lsource_mask ) end associate class default write ( * , * ) \"Invalid object passed to the append method. Source must be of class swiftest_pl or its descendents\" call util_exit ( FAILURE ) end select return end subroutine util_append_pl module subroutine util_append_tp ( self , source , lsource_mask ) !! author: David A. Minton !! !! Append components from one Swiftest body object to another. !! This method will automatically resize the destination body if it is too small implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to select type ( source ) class is ( swiftest_tp ) associate ( nold => self % nbody , nsrc => source % nbody ) call util_append ( self % isperi , source % isperi , nold , nsrc , lsource_mask ) call util_append ( self % peri , source % peri , nold , nsrc , lsource_mask ) call util_append ( self % atp , source % atp , nold , nsrc , lsource_mask ) call util_append_body ( self , source , lsource_mask ) end associate class default write ( * , * ) \"Invalid object passed to the append method. Source must be of class swiftest_tp or its descendents\" call util_exit ( FAILURE ) end select return end subroutine util_append_tp end submodule s_util_append","tags":"","loc":"sourcefile/util_append.f90.html"},{"title":"util_get_energy_momentum.f90 – swiftest","text":"This file depends on sourcefile~~util_get_energy_momentum.f90~~EfferentGraph sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_util_get_energy_momentum Source Code util_get_energy_momentum.f90 Source Code submodule ( swiftest_classes ) s_util_get_energy_momentum use swiftest contains module subroutine util_get_energy_momentum_system ( self , param ) !! author: David A. Minton !! !! Compute total system angular momentum vector and kinetic, potential and total system energy !! !! Adapted from David E. Kaufmann Swifter routine symba_energy_eucl.f90 !! !! Adapted from Martin Duncan's Swift routine anal_energy.f implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i , j integer ( I8B ) :: k , nplpl real ( DP ) :: oblpot , kecb , kespincb real ( DP ), dimension ( self % pl % nbody ) :: irh , kepl , kespinpl real ( DP ), dimension ( self % pl % nbody ) :: Lplorbitx , Lplorbity , Lplorbitz real ( DP ), dimension ( self % pl % nbody ) :: Lplspinx , Lplspiny , Lplspinz real ( DP ), dimension ( NDIM ) :: Lcborbit , Lcbspin real ( DP ) :: hx , hy , hz associate ( system => self , pl => self % pl , npl => self % pl % nbody , cb => self % cb ) nplpl = pl % nplpl system % Lorbit (:) = 0.0_DP system % Lspin (:) = 0.0_DP system % Ltot (:) = 0.0_DP system % ke_orbit = 0.0_DP system % ke_spin = 0.0_DP kepl (:) = 0.0_DP Lplorbitx (:) = 0.0_DP Lplorbity (:) = 0.0_DP Lplorbitz (:) = 0.0_DP Lplspinx (:) = 0.0_DP Lplspiny (:) = 0.0_DP Lplspinz (:) = 0.0_DP pl % lmask ( 1 : npl ) = pl % status ( 1 : npl ) /= INACTIVE system % GMtot = cb % Gmass + sum ( pl % Gmass ( 1 : npl ), pl % lmask ( 1 : npl )) kecb = cb % mass * dot_product ( cb % vb (:), cb % vb (:)) Lcborbit (:) = cb % mass * ( cb % xb (:) . cross . cb % vb (:)) do concurrent ( i = 1 : npl , pl % lmask ( i )) hx = pl % xb ( 2 , i ) * pl % vb ( 3 , i ) - pl % xb ( 3 , i ) * pl % vb ( 2 , i ) hy = pl % xb ( 3 , i ) * pl % vb ( 1 , i ) - pl % xb ( 1 , i ) * pl % vb ( 3 , i ) hz = pl % xb ( 1 , i ) * pl % vb ( 2 , i ) - pl % xb ( 2 , i ) * pl % vb ( 1 , i ) ! Angular momentum from orbit Lplorbitx ( i ) = pl % mass ( i ) * hx Lplorbity ( i ) = pl % mass ( i ) * hy Lplorbitz ( i ) = pl % mass ( i ) * hz ! Kinetic energy from orbit kepl ( i ) = pl % mass ( i ) * dot_product ( pl % vb (:, i ), pl % vb (:, i )) end do if ( param % lrotation ) then kespincb = cb % mass * cb % Ip ( 3 ) * cb % radius ** 2 * dot_product ( cb % rot (:), cb % rot (:)) ! For simplicity, we always assume that the rotation pole is the 3rd principal axis Lcbspin (:) = cb % Ip ( 3 ) * cb % mass * cb % radius ** 2 * cb % rot (:) do concurrent ( i = 1 : npl , pl % lmask ( i )) ! Currently we assume that the rotation pole is the 3rd principal axis ! Angular momentum from spin Lplspinx ( i ) = pl % mass ( i ) * pl % Ip ( 3 , i ) * pl % radius ( i ) ** 2 * pl % rot ( 1 , i ) Lplspiny ( i ) = pl % mass ( i ) * pl % Ip ( 3 , i ) * pl % radius ( i ) ** 2 * pl % rot ( 2 , i ) Lplspinz ( i ) = pl % mass ( i ) * pl % Ip ( 3 , i ) * pl % radius ( i ) ** 2 * pl % rot ( 3 , i ) ! Kinetic energy from spin kespinpl ( i ) = pl % mass ( i ) * pl % Ip ( 3 , i ) * pl % radius ( i ) ** 2 * dot_product ( pl % rot (:, i ), pl % rot (:, i )) end do else kespincb = 0.0_DP kespinpl (:) = 0.0_DP end if call util_get_energy_potential ( npl , nplpl , pl % k_plpl , pl % lmask , cb % Gmass , pl % Gmass , pl % mass , pl % xb , system % pe ) ! Potential energy from the oblateness term if ( param % loblatecb ) then call system % obl_pot () system % pe = system % pe + system % oblpot end if system % ke_orbit = 0.5_DP * ( kecb + sum ( kepl ( 1 : npl ), pl % lmask ( 1 : npl ))) if ( param % lrotation ) system % ke_spin = 0.5_DP * ( kespincb + sum ( kespinpl ( 1 : npl ), pl % lmask ( 1 : npl ))) system % Lorbit ( 1 ) = Lcborbit ( 1 ) + sum ( Lplorbitx ( 1 : npl ), pl % lmask ( 1 : npl )) system % Lorbit ( 2 ) = Lcborbit ( 2 ) + sum ( Lplorbity ( 1 : npl ), pl % lmask ( 1 : npl )) system % Lorbit ( 3 ) = Lcborbit ( 3 ) + sum ( Lplorbitz ( 1 : npl ), pl % lmask ( 1 : npl )) if ( param % lrotation ) then system % Lspin ( 1 ) = Lcbspin ( 1 ) + sum ( Lplspinx ( 1 : npl ), pl % lmask ( 1 : npl )) system % Lspin ( 2 ) = Lcbspin ( 2 ) + sum ( Lplspiny ( 1 : npl ), pl % lmask ( 1 : npl )) system % Lspin ( 3 ) = Lcbspin ( 3 ) + sum ( Lplspinz ( 1 : npl ), pl % lmask ( 1 : npl )) end if system % te = system % ke_orbit + system % ke_spin + system % pe system % Ltot (:) = system % Lorbit (:) + system % Lspin (:) end associate return end subroutine util_get_energy_momentum_system subroutine util_get_energy_potential ( npl , nplpl , k_plpl , lmask , GMcb , Gmass , mass , xb , pe ) !! author: David A. Minton !! !! Compute total system potential energy implicit none ! Arguments integer ( I4B ), intent ( in ) :: npl integer ( I8B ), intent ( in ) :: nplpl integer ( I4B ), dimension (:,:), intent ( in ) :: k_plpl logical , dimension (:), intent ( in ) :: lmask real ( DP ), intent ( in ) :: GMcb real ( DP ), dimension (:), intent ( in ) :: Gmass real ( DP ), dimension (:), intent ( in ) :: mass real ( DP ), dimension (:,:), intent ( in ) :: xb real ( DP ), intent ( out ) :: pe ! Internals integer ( I4B ) :: i , j integer ( I8B ) :: k real ( DP ), dimension ( npl ) :: pecb real ( DP ), dimension ( nplpl ) :: pepl logical , dimension ( nplpl ) :: lstatpl ! Do the central body potential energy component first where (. not . lmask ( 1 : npl )) pecb ( 1 : npl ) = 0.0_DP end where do concurrent ( i = 1 : npl , lmask ( i )) pecb ( i ) = - GMcb * mass ( i ) / norm2 ( xb (:, i )) end do !$omp parallel do default(private) schedule(static)& !$omp shared(nplpl, k_plpl, xb, mass, Gmass, pepl, lstatpl, lmask) do k = 1 , nplpl i = k_plpl ( 1 , k ) j = k_plpl ( 2 , k ) lstatpl ( k ) = ( lmask ( i ) . and . lmask ( j )) if ( lstatpl ( k )) then pepl ( k ) = - ( Gmass ( i ) * mass ( j )) / norm2 ( xb (:, i ) - xb (:, j )) else pepl ( k ) = 0.0_DP end if end do !$omp end parallel do pe = sum ( pepl (:), lstatpl (:)) + sum ( pecb ( 1 : npl ), lmask ( 1 : npl )) return end subroutine util_get_energy_potential end submodule s_util_get_energy_momentum","tags":"","loc":"sourcefile/util_get_energy_momentum.f90.html"},{"title":"gr.f90 – swiftest","text":"This file depends on sourcefile~~gr.f90~~EfferentGraph sourcefile~gr.f90 gr.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~gr.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_gr Source Code gr.f90 Source Code submodule ( swiftest_classes ) s_gr use swiftest contains module pure subroutine gr_kick_getaccb_ns_body ( self , system , param ) !! author: David A. Minton !! !! Add relativistic correction acceleration for non-symplectic integrators. !! Based on Quinn et al. (1991) eq. 5 !! !! Reference: !!    Quinn, T.R., Tremaine, S., Duncan, M., 1991. A three million year integration of the earth’s orbit. !!       AJ 101, 2287–2305. https://doi.org/10.1086/115850 !! !! Adapted from David A. Minton's Swifter routine routine gr_kick_getaccb_ns.f90 implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest generic body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals real ( DP ) :: rmag , rdotv , vmag2 integer ( I4B ) :: i associate ( n => self % nbody , cb => system % cb , inv_c2 => param % inv_c2 ) if ( n == 0 ) return do i = 1 , n rmag = norm2 ( self % xh (:, i )) vmag2 = dot_product ( self % vh (:, i ), self % vh (:, i )) rdotv = dot_product ( self % xh (:, i ), self % vh (:, i )) self % agr (:, i ) = self % mu * inv_c2 / rmag ** 3 * (( 4 * self % mu ( i ) / rmag - vmag2 ) * self % xh (:, i ) + 4 * rdotv * self % vh (:, i )) end do select type ( self ) class is ( swiftest_pl ) do i = 1 , NDIM cb % agr ( i ) = - sum ( self % Gmass ( 1 : n ) * self % agr ( 1 : n , i ) / cb % Gmass ) end do end select end associate return end subroutine gr_kick_getaccb_ns_body module pure subroutine gr_kick_getacch ( mu , x , lmask , n , inv_c2 , agr ) !! author: David A. Minton !! !! Compute relativisitic accelerations of massive bodies !!    Based on Saha & Tremaine (1994) Eq. 28 !! !! Adapted from David A. Minton's Swifter routine routine gr_whm_kick_getacch.f90 implicit none ! Arguments real ( DP ), dimension (:), intent ( in ) :: mu !! Gravitational constant real ( DP ), dimension (:,:), intent ( in ) :: x !! Position vectors logical , dimension (:), intent ( in ) :: lmask !! Logical mask indicating which bodies to compute integer ( I4B ), intent ( in ) :: n !! Total number of bodies real ( DP ), intent ( in ) :: inv_c2 !! Inverse speed of light squared: 1 / c**2 real ( DP ), dimension (:,:), intent ( out ) :: agr !! Accelerations ! Internals integer ( I4B ) :: i real ( DP ) :: beta , rjmag4 agr (:,:) = 0.0_DP do concurrent ( i = 1 : n , lmask ( i )) rjmag4 = ( dot_product ( x (:, i ), x (:, i ))) ** 2 beta = - mu ( i ) ** 2 * inv_c2 agr (:, i ) = 2 * beta * x (:, i ) / rjmag4 end do return end subroutine gr_kick_getacch module pure subroutine gr_p4_pos_kick ( param , x , v , dt ) !! author: David A. Minton !! !! Position kick due to p**4 term in the post-Newtonian correction !!    Based on Saha & Tremaine (1994) Eq. 28 !! !! Reference: !!    Saha, P., Tremaine, S., 1994. Long-term planetary integration with individual time steps. !!       AJ 108, 1962–1969. https://doi.org/10.1086/117210 !! !! Adapted from David A. Minton's Swifter routine gr_whm_p4.f90 implicit none ! Arguments class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), dimension (:), intent ( inout ) :: x !! Position vector real ( DP ), dimension (:), intent ( in ) :: v !! Velocity vector real ( DP ), intent ( in ) :: dt !! Step size ! Internals real ( DP ), dimension ( NDIM ) :: dr real ( DP ) :: vmag2 vmag2 = dot_product ( v (:), v (:)) dr (:) = - 2 * param % inv_c2 * vmag2 * v (:) x (:) = x (:) + dr (:) * dt return end subroutine gr_p4_pos_kick module pure subroutine gr_pseudovel2vel ( param , mu , xh , pv , vh ) !! author: David A. Minton !! !! Converts the relativistic pseudovelocity back into a veliocentric velocity !!    Based on Saha & Tremaine (1994) Eq. 32 !! !! Reference: !!    Saha, P., Tremaine, S., 1994. Long-term planetary integration with individual time steps. !!       AJ 108, 1962–1969. https://doi.org/10.1086/117210 !! !! Adapted from David A. Minton's Swifter routine gr_pseudovel2vel.f90 implicit none ! Arguments class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: mu !! G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real ( DP ), dimension (:), intent ( in ) :: xh !! Heliocentric position vector real ( DP ), dimension (:), intent ( in ) :: pv !! Pseudovelocity velocity vector - see Saha & Tremain (1994), eq. (32) real ( DP ), dimension (:), intent ( out ) :: vh !! Heliocentric velocity vector ! Internals real ( DP ) :: vmag2 , rmag , grterm associate ( inv_c2 => param % inv_c2 ) vmag2 = dot_product ( pv (:), pv (:)) rmag = norm2 ( xh (:)) grterm = 1.0_DP - inv_c2 * ( 0.5_DP * vmag2 + 3 * mu / rmag ) vh (:) = pv (:) * grterm end associate return end subroutine gr_pseudovel2vel module pure subroutine gr_pv2vh_body ( self , param ) !! author: David A. Minton !! !! Wrapper function that converts from pseudovelocity to heliocentric velocity for swiftest bodies implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i real ( DP ), dimension (:,:), allocatable :: vh !! Temporary holder of pseudovelocity for in-place conversion associate ( n => self % nbody ) if ( n == 0 ) return allocate ( vh , mold = self % vh ) do i = 1 , n call gr_pseudovel2vel ( param , self % mu ( i ), self % xh (:, i ), self % vh (:, i ), vh (:, i )) end do call move_alloc ( vh , self % vh ) end associate return end subroutine gr_pv2vh_body module pure subroutine gr_vel2pseudovel ( param , mu , xh , vh , pv ) !! author: David A. Minton !! !! Converts the heliocentric velocity into a pseudovelocity with relativistic corrections. !! Uses Newton-Raphson method with direct inversion of the Jacobian (yeah, it's slow, but !! this is only done once per run). !! !! Reference: !!    Saha, P., Tremaine, S., 1994. Long-term planetary integration with individual time steps. !!       AJ 108, 1962–1969. https://doi.org/10.1086/117210 !! !! Adapted from David A. Minton's Swifter routine gr_vel2pseudovel.f90 implicit none ! Arguments class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: mu !! G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real ( DP ), dimension (:), intent ( in ) :: xh !! Heliocentric position vector real ( DP ), dimension (:), intent ( in ) :: vh !! Heliocentric velocity vector real ( DP ), dimension (:), intent ( out ) :: pv !! Pseudovelocity vector - see Saha & Tremain (1994), eq. (32) ! Internals real ( DP ) :: v2 , G , pv2 , rterm , det real ( DP ), dimension ( NDIM , NDIM ) :: J , Jinv real ( DP ), dimension ( NDIM ) :: F integer ( I4B ) :: n , i , k integer ( I4B ), parameter :: MAXITER = 50 real ( DP ), parameter :: TOL = 1.0e-12_DP associate ( inv_c2 => param % inv_c2 ) pv ( 1 : NDIM ) = vh ( 1 : NDIM ) ! Initial guess rterm = 3 * mu / norm2 ( xh (:)) v2 = dot_product ( vh (:), vh (:)) do n = 1 , MAXITER pv2 = dot_product ( pv (:), pv (:)) G = 1.0_DP - inv_c2 * ( 0.5_DP * pv2 + rterm ) F (:) = pv (:) * G - vh (:) if ( abs ( sum ( F ) / v2 ) < TOL ) exit ! Root found ! Calculate the Jacobian do k = 1 , NDIM do i = 1 , NDIM if ( i == k ) then J ( i , k ) = G - inv_c2 * pv ( k ) else J ( i , k ) = - inv_c2 * pv ( k ) end if end do end do ! Inverse of the Jacobian det = J ( 1 , 1 ) * ( J ( 3 , 3 ) * J ( 2 , 2 ) - J ( 3 , 2 ) * J ( 2 , 3 )) det = det - J ( 2 , 1 ) * ( J ( 3 , 3 ) * J ( 1 , 2 ) - J ( 3 , 2 ) * J ( 1 , 3 )) det = det + J ( 3 , 1 ) * ( J ( 2 , 3 ) * J ( 1 , 2 ) - J ( 2 , 2 ) * J ( 1 , 3 )) Jinv ( 1 , 1 ) = J ( 3 , 3 ) * J ( 2 , 2 ) - J ( 3 , 2 ) * J ( 2 , 3 ) Jinv ( 1 , 2 ) = - ( J ( 3 , 3 ) * J ( 1 , 2 ) - J ( 3 , 2 ) * J ( 1 , 3 )) Jinv ( 1 , 3 ) = J ( 2 , 3 ) * J ( 1 , 2 ) - J ( 2 , 2 ) * J ( 1 , 3 ) Jinv ( 2 , 1 ) = - ( J ( 3 , 3 ) * J ( 2 , 1 ) - J ( 3 , 1 ) * J ( 2 , 3 )) Jinv ( 2 , 2 ) = J ( 3 , 3 ) * J ( 1 , 1 ) - J ( 3 , 1 ) * J ( 1 , 3 ) Jinv ( 2 , 3 ) = - ( J ( 2 , 3 ) * J ( 1 , 1 ) - J ( 2 , 1 ) * J ( 1 , 3 )) Jinv ( 3 , 1 ) = J ( 3 , 2 ) * J ( 2 , 1 ) - J ( 3 , 1 ) * J ( 2 , 2 ) Jinv ( 3 , 2 ) = - ( J ( 3 , 2 ) * J ( 1 , 1 ) - J ( 3 , 1 ) * J ( 1 , 2 )) Jinv ( 3 , 3 ) = J ( 2 , 2 ) * J ( 1 , 1 ) - J ( 2 , 1 ) * J ( 1 , 2 ) Jinv = Jinv * det do i = 1 , NDIM pv ( i ) = pv ( i ) - dot_product ( Jinv ( i ,:), F (:)) end do end do end associate return end subroutine gr_vel2pseudovel module pure subroutine gr_vh2pv_body ( self , param ) !! author: David A. Minton !! !! Wrapper function that converts from heliocentric velocity to pseudovelocity for Swiftest bodies implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i real ( DP ), dimension (:,:), allocatable :: pv !! Temporary holder of pseudovelocity for in-place conversion associate ( n => self % nbody ) if ( n == 0 ) return allocate ( pv , mold = self % vh ) do i = 1 , n call gr_vel2pseudovel ( param , self % mu ( i ), self % xh (:, i ), self % vh (:, i ), pv (:, i )) end do call move_alloc ( pv , self % vh ) end associate return end subroutine gr_vh2pv_body end submodule s_gr","tags":"","loc":"sourcefile/gr.f90.html"},{"title":"discard.f90 – swiftest","text":"This file depends on sourcefile~~discard.f90~~EfferentGraph sourcefile~discard.f90 discard.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~discard.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_discard Source Code discard.f90 Source Code submodule ( swiftest_classes ) s_discard use swiftest contains module subroutine discard_system ( self , param ) !! author: David A. Minton !! !! Calls the discard methods for each body class and then the write method if any discards were detected !! implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals logical :: lany_discards , lpl_discards , ltp_discards , lpl_check , ltp_check lpl_check = allocated ( self % pl_discards ) ltp_check = allocated ( self % tp_discards ) associate ( system => self , tp => self % tp , pl => self % pl , tp_discards => self % tp_discards , pl_discards => self % pl_discards ) lpl_discards = . false . ltp_discards = . false . if ( lpl_check ) then call pl % discard ( system , param ) lpl_discards = ( pl_discards % nbody > 0 ) end if if ( ltp_check ) then call tp % discard ( system , param ) ltp_discards = ( tp_discards % nbody > 0 ) end if if ( lpl_discards . or . ltp_discards ) call system % write_discard ( param ) if ( lpl_discards . and . param % lenergy ) call self % conservation_report ( param , lterminal = . false .) if ( lpl_check ) call pl_discards % setup ( 0 , param ) if ( ltp_check ) call tp_discards % setup ( 0 , param ) end associate return end subroutine discard_system module subroutine discard_pl ( self , system , param ) !! author: David A. Minton !! !!  Placeholder method for discarding massive bodies. This method does nothing except to ensure that the discard flag is set to false. !!  This method is intended to be overridden by more advanced integrators. implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameter if ( self % nbody == 0 ) return self % ldiscard ( 1 : self % nbody ) = . false . return end subroutine discard_pl module subroutine discard_tp ( self , system , param ) !! author: David A. Minton !! !! Check to see if particles should be discarded based on their positions relative to the massive bodies !! !! Adapted from David E. Kaufmann's Swifter routine: discard.f90 !! Adapted from Hal Levison's Swift routine discard. implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameter ! Internals logical , dimension (:), allocatable :: ldiscard integer ( I4B ) :: npl , ntp associate ( tp => self , cb => system % cb , pl => system % pl ) if (( ntp == 0 ) . or . ( npl == 0 )) return ntp = tp % nbody npl = pl % nbody if (( param % rmin >= 0.0_DP ) . or . ( param % rmax >= 0.0_DP ) . or . & ( param % rmaxu >= 0.0_DP ) . or . (( param % qmin >= 0.0_DP ) . and . ( param % qmin_coord == \"BARY\" ))) then call pl % h2b ( cb ) call tp % h2b ( cb ) end if if (( param % rmin >= 0.0_DP ) . or . ( param % rmax >= 0.0_DP ) . or . ( param % rmaxu >= 0.0_DP )) call discard_cb_tp ( tp , system , param ) if ( param % qmin >= 0.0_DP ) call discard_peri_tp ( tp , system , param ) if ( param % lclose ) call discard_pl_tp ( tp , system , param ) if ( any ( tp % ldiscard ( 1 : ntp ))) then allocate ( ldiscard , source = tp % ldiscard ) call tp % spill ( system % tp_discards , ldiscard ( 1 : ntp ), ldestructive = . true .) end if end associate return end subroutine discard_tp subroutine discard_cb_tp ( tp , system , param ) !! author: David A. Minton !! !!  Check to see if test particles should be discarded based on their positions relative to the Sun !!        or because they are unbound from the system !! !! Adapted from David E. Kaufmann's Swifter routine: discard_sun.f90 !! Adapted from Hal Levison's Swift routine discard_sun.f implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: tp !! Swiftest test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i real ( DP ) :: energy , vb2 , rb2 , rh2 , rmin2 , rmax2 , rmaxu2 character ( len = STRMAX ) :: idstr , timestr associate ( ntp => tp % nbody , cb => system % cb , Gmtot => system % Gmtot ) rmin2 = max ( param % rmin * param % rmin , cb % radius * cb % radius ) rmax2 = param % rmax ** 2 rmaxu2 = param % rmaxu ** 2 do i = 1 , ntp if ( tp % status ( i ) == ACTIVE ) then rh2 = dot_product ( tp % xh (:, i ), tp % xh (:, i )) if (( param % rmax >= 0.0_DP ) . and . ( rh2 > rmax2 )) then tp % status ( i ) = DISCARDED_RMAX write ( idstr , * ) tp % id ( i ) write ( timestr , * ) param % t write ( * , * ) \"Particle \" // trim ( adjustl ( tp % info ( i )% name )) // \" (\" // trim ( adjustl ( idstr )) // \")\" // \" too far from the central body at t = \" // trim ( adjustl ( timestr )) tp % ldiscard ( i ) = . true . tp % lmask ( i ) = . false . call tp % info ( i )% set_value ( status = \"DISCARDED_RMAX\" , discard_time = param % t , discard_xh = tp % xh (:, i ), discard_vh = tp % vh (:, i )) else if (( param % rmin >= 0.0_DP ) . and . ( rh2 < rmin2 )) then tp % status ( i ) = DISCARDED_RMIN write ( idstr , * ) tp % id ( i ) write ( timestr , * ) param % t write ( * , * ) \"Particle \" // trim ( adjustl ( tp % info ( i )% name )) // \" (\" // trim ( adjustl ( idstr )) // \")\" // \" too close to the central body at t = \" // trim ( adjustl ( timestr )) tp % ldiscard ( i ) = . true . tp % lmask ( i ) = . false . call tp % info ( i )% set_value ( status = \"DISCARDED_RMIN\" , discard_time = param % t , discard_xh = tp % xh (:, i ), discard_vh = tp % vh (:, i ), discard_body_id = cb % id ) else if ( param % rmaxu >= 0.0_DP ) then rb2 = dot_product ( tp % xb (:, i ), tp % xb (:, i )) vb2 = dot_product ( tp % vb (:, i ), tp % vb (:, i )) energy = 0.5_DP * vb2 - Gmtot / sqrt ( rb2 ) if (( energy > 0.0_DP ) . and . ( rb2 > rmaxu2 )) then tp % status ( i ) = DISCARDED_RMAXU write ( idstr , * ) tp % id ( i ) write ( timestr , * ) param % t write ( * , * ) \"Particle \" // trim ( adjustl ( tp % info ( i )% name )) // \" (\" // trim ( adjustl ( idstr )) // \")\" // \" is unbound and too far from barycenter at t = \" // trim ( adjustl ( timestr )) tp % ldiscard ( i ) = . true . tp % lmask ( i ) = . false . call tp % info ( i )% set_value ( status = \"DISCARDED_RMAXU\" , discard_time = param % t , discard_xh = tp % xh (:, i ), discard_vh = tp % vh (:, i )) end if end if end if end do end associate return end subroutine discard_cb_tp subroutine discard_peri_tp ( tp , system , param ) !! author: David A. Minton !! !! Check to see if a test particle should be discarded because its perihelion distance becomes too small !! !! Adapted from David E. Kaufmann's Swifter routine: discard_peri.f90 !! Adapted from Hal Levison's Swift routine discard_peri.f implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: tp !! Swiftest test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameterss ! Internals logical , save :: lfirst = . true . integer ( I4B ) :: i , j , ih real ( DP ) :: r2 real ( DP ), dimension ( NDIM ) :: dx character ( len = STRMAX ) :: idstr , timestr associate ( cb => system % cb , ntp => tp % nbody , pl => system % pl , npl => system % pl % nbody , t => param % t ) call tp % get_peri ( system , param ) do i = 1 , ntp if ( tp % status ( i ) == ACTIVE ) then if ( tp % isperi ( i ) == 0 ) then ih = 1 do j = 1 , npl dx (:) = tp % xh (:, i ) - pl % xh (:, j ) r2 = dot_product ( dx (:), dx (:)) if ( r2 <= ( pl % rhill ( j )) ** 2 ) ih = 0 end do if ( ih == 1 ) then if (( tp % atp ( i ) >= param % qmin_alo ) . and . & ( tp % atp ( i ) <= param % qmin_ahi ) . and . & ( tp % peri ( i ) <= param % qmin )) then tp % status ( i ) = DISCARDED_PERI write ( idstr , * ) tp % id ( i ) write ( timestr , * ) param % t write ( * , * ) \"Particle \" // trim ( adjustl ( tp % info ( i )% name )) // \" (\" // trim ( adjustl ( idstr )) // \")\" // \" perihelion distance too small at t = \" // trim ( adjustl ( timestr )) tp % ldiscard ( i ) = . true . call tp % info ( i )% set_value ( status = \"DISCARDED_PERI\" , discard_time = param % t , discard_xh = tp % xh (:, i ), discard_vh = tp % vh (:, i ), discard_body_id = pl % id ( j )) end if end if end if end if end do end associate return end subroutine discard_peri_tp subroutine discard_pl_tp ( tp , system , param ) !! author: David A. Minton !! !! Check to see if test particles should be discarded based on their positions relative to the massive bodies !! !! Adapted from David E. Kaufmann's Swifter routine: discard_pl.f90 !! Adapted from Hal Levison's Swift routine discard_pl.f implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: tp !! Swiftest test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i , j , isp real ( DP ) :: r2min , radius real ( DP ), dimension ( NDIM ) :: dx , dv character ( len = STRMAX ) :: idstri , idstrj , timestr associate ( ntp => tp % nbody , pl => system % pl , npl => system % pl % nbody , t => param % t , dt => param % dt ) do i = 1 , ntp if ( tp % status ( i ) == ACTIVE ) then do j = 1 , npl dx (:) = tp % xh (:, i ) - pl % xh (:, j ) dv (:) = tp % vh (:, i ) - pl % vh (:, j ) radius = pl % radius ( j ) call discard_pl_close ( dx (:), dv (:), dt , radius ** 2 , isp , r2min ) if ( isp /= 0 ) then tp % status ( i ) = DISCARDED_PLR tp % lmask ( i ) = . false . pl % ldiscard ( j ) = . true . write ( idstri , * ) tp % id ( i ) write ( idstrj , * ) pl % id ( j ) write ( timestr , * ) param % t write ( * , * ) \"Test particle \" // trim ( adjustl ( tp % info ( i )% name )) // \" (\" // trim ( adjustl ( idstri )) // \")\" & // \"  too close to massive body \" // trim ( adjustl ( pl % info ( i )% name )) // \" (\" // trim ( adjustl ( idstrj )) & // \" at t = \" // trim ( adjustl ( timestr )) tp % ldiscard ( i ) = . true . call tp % info ( i )% set_value ( status = \"DISCARDED_PLR\" , discard_time = param % t , discard_xh = tp % xh (:, i ), discard_vh = tp % vh (:, i ), discard_body_id = pl % id ( j )) exit end if end do end if end do end associate return end subroutine discard_pl_tp subroutine discard_pl_close ( dx , dv , dt , r2crit , iflag , r2min ) !! author: David A. Minton !! !!  Check to see if a test particle and massive body are having, or will have within the next time step, an encounter such !!          that the separation distance r is less than some critical radius rcrit (or r**2 < rcrit**2 = r2crit) !! !! Adapted from David E. Kaufmann's Swifter routine: discard_pl_close.f90 !! Adapted from Hal Levison's Swift routine discard_pl_close.f implicit none ! Arguments real ( DP ), dimension (:), intent ( in ) :: dx , dv real ( DP ), intent ( in ) :: dt , r2crit integer ( I4B ), intent ( out ) :: iflag real ( DP ), intent ( out ) :: r2min ! Internals real ( DP ) :: r2 , v2 , vdotr , tmin r2 = dot_product ( dx (:), dx (:)) if ( r2 <= r2crit ) then iflag = 1 else vdotr = dot_product ( dx (:), dv (:)) if ( vdotr > 0.0_DP ) then iflag = 0 else v2 = dot_product ( dv (:), dv (:)) tmin = - vdotr / v2 if ( tmin < dt ) then r2min = r2 - vdotr * vdotr / v2 else r2min = r2 + 2 * vdotr * dt + v2 * dt ** 2 end if r2min = min ( r2min , r2 ) if ( r2min <= r2crit ) then iflag = 1 else iflag = 0 end if end if end if return end subroutine discard_pl_close end submodule s_discard","tags":"","loc":"sourcefile/discard.f90.html"},{"title":"helio_step.f90 – swiftest","text":"This file depends on sourcefile~~helio_step.f90~~EfferentGraph sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~helio_step.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_helio_step Source Code helio_step.f90 Source Code submodule ( helio_classes ) s_helio_step use swiftest contains module subroutine helio_step_system ( self , param , t , dt ) !! author: David A. Minton !! !! Step massive bodies and and active test particles ahead in heliocentric coordinates. !! !! Currently there's no difference between this and the WHM system stepper, so this is just !! a wrapper function to keep the method calls consistent for inherited types. !! !! Adapted from Hal Levison's Swift routine step_kdk.f !! Adapted from David E. Kaufmann's Swifter routine helio_step.f90 implicit none ! Arguments class ( helio_nbody_system ), intent ( inout ) :: self !! Helio nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize call whm_step_system ( self , param , t , dt ) return end subroutine helio_step_system module subroutine helio_step_pl ( self , system , param , t , dt ) !! author: David A. Minton !! !! Step massive bodies ahead Democratic Heliocentric method !! !! Adapted from David E. Kaufmann's Swifter helio_step_pl.f90 !! Adapted from Hal Levison's Swift routine helio_step_pl.f implicit none ! Arguments class ( helio_pl ), intent ( inout ) :: self !! Helio massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nboody system class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Stepsize ! Internals real ( DP ) :: dth !! Half step size if ( self % nbody == 0 ) return associate ( pl => self ) select type ( cb => system % cb ) class is ( helio_cb ) dth = 0.5_DP * dt if ( pl % lfirst ) then call pl % vh2vb ( cb ) pl % lfirst = . false . end if call pl % lindrift ( cb , dth , lbeg = . true .) call pl % kick ( system , param , t , dth , lbeg = . true .) if ( param % lgr ) call pl % gr_pos_kick ( param , dth ) call pl % drift ( system , param , dt ) call pl % kick ( system , param , t + dt , dth , lbeg = . false .) if ( param % lgr ) call pl % gr_pos_kick ( param , dth ) call pl % lindrift ( cb , dth , lbeg = . false .) call pl % vb2vh ( cb ) end select end associate return end subroutine helio_step_pl module subroutine helio_step_tp ( self , system , param , t , dt ) !! author: David A. Minton !! !! Step active test particles ahead using Democratic Heliocentric method !! !! Adapted from David E. Kaufmann's Swifter routine helio_step_tp.f90 !! Adapted from Hal Levison's Swift routine helio_step_tp.f implicit none ! Arguments class ( helio_tp ), intent ( inout ) :: self !! Helio test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nboody system class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Stepsize ! Internals real ( DP ) :: dth !! Half step size if ( self % nbody == 0 ) return associate ( tp => self ) select type ( cb => system % cb ) class is ( helio_cb ) dth = 0.5_DP * dt if ( tp % lfirst ) then call tp % vh2vb ( vbcb = - cb % ptbeg ) tp % lfirst = . false . end if call tp % lindrift ( cb , dth , lbeg = . true .) call tp % kick ( system , param , t , dth , lbeg = . true .) if ( param % lgr ) call tp % gr_pos_kick ( param , dth ) call tp % drift ( system , param , dt ) call tp % kick ( system , param , t + dt , dth , lbeg = . false .) if ( param % lgr ) call tp % gr_pos_kick ( param , dth ) call tp % lindrift ( cb , dth , lbeg = . false .) call tp % vb2vh ( vbcb = - cb % ptend ) end select end associate return end subroutine helio_step_tp end submodule s_helio_step","tags":"","loc":"sourcefile/helio_step.f90.html"},{"title":"helio_setup.f90 – swiftest","text":"This file depends on sourcefile~~helio_setup.f90~~EfferentGraph sourcefile~helio_setup.f90 helio_setup.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~helio_setup.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_setup.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_helio_setup Source Code helio_setup.f90 Source Code submodule ( helio_classes ) s_helio_setup use swiftest contains module subroutine helio_setup_initialize_system ( self , param ) !! author: David A. Minton !! !! Initialize a Helio nbody system from files, converting all heliocentric quantities to barycentric. !! implicit none ! Arguments class ( helio_nbody_system ), intent ( inout ) :: self !! Helio nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters call whm_setup_initialize_system ( self , param ) call self % pl % h2b ( self % cb ) call self % tp % h2b ( self % cb ) call self % pl % sort ( \"mass\" , ascending = . false .) call self % pl % index ( param ) return end subroutine helio_setup_initialize_system end submodule s_helio_setup","tags":"","loc":"sourcefile/helio_setup.f90.html"},{"title":"helio_gr.f90 – swiftest","text":"This file depends on sourcefile~~helio_gr.f90~~EfferentGraph sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~helio_gr.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_helio_gr Source Code helio_gr.f90 Source Code submodule ( helio_classes ) s_helio_gr use swiftest contains module pure subroutine helio_gr_kick_getacch_pl ( self , param ) !! author: David A. Minton !! !! Compute relativisitic accelerations of massive bodies !!    Based on Saha & Tremaine (1994) Eq. 28 !! !! Adapted from David A. Minton's Swifter routine routine gr_whm_kick_getacch.f90 implicit none ! Arguments class ( helio_pl ), intent ( inout ) :: self !! Helio massive body particle data structure class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i real ( DP ), dimension ( NDIM ) :: suma real ( DP ), dimension (:, :), allocatable :: aj real ( DP ) :: beta , rjmag4 if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) call gr_kick_getacch ( pl % mu , pl % xh , pl % lmask , npl , param % inv_c2 , pl % agr ) pl % ah (:, 1 : npl ) = pl % ah (:, 1 : npl ) + pl % agr (:, 1 : npl ) end associate return end subroutine helio_gr_kick_getacch_pl module pure subroutine helio_gr_kick_getacch_tp ( self , param ) !! author: David A. Minton !! !! Compute relativisitic accelerations of test particles !!    Based on Saha & Tremaine (1994) Eq. 28 !! !! Adapted from David A. Minton's Swifter routine routine gr_helio_kick_getacch.f90 implicit none ! Arguments class ( helio_tp ), intent ( inout ) :: self !! Helio massive body particle data structure class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i real ( DP ) :: rjmag4 , beta if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) call gr_kick_getacch ( tp % mu , tp % xh , tp % lmask , ntp , param % inv_c2 , tp % agr ) tp % ah (:, 1 : ntp ) = tp % ah (:, 1 : ntp ) + tp % agr (:, 1 : ntp ) end associate return end subroutine helio_gr_kick_getacch_tp module pure subroutine helio_gr_p4_pl ( self , param , dt ) !! author: David A. Minton !! !! Position kick to massive bodies due to p**4 term in the post-Newtonian correction !!    Based on Saha & Tremaine (1994) Eq. 28 !! !! Adapted from David A. Minton's Swifter routine routine gr_helio_p4.f90 implicit none ! Arguments class ( helio_pl ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Step size ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) do concurrent ( i = 1 : npl , pl % lmask ( i )) call gr_p4_pos_kick ( param , pl % xh (:, i ), pl % vb (:, i ), dt ) end do end associate return end subroutine helio_gr_p4_pl module pure subroutine helio_gr_p4_tp ( self , param , dt ) !! author: David A. Minton !! !! Position kick to test particles due to p**4 term in the post-Newtonian correction !!    Based on Saha & Tremaine (1994) Eq. 28 !! !! Adapted from David A. Minton's Swifter routine routine gr_helio_p4.f90 implicit none ! Arguments class ( helio_tp ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Step size ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) do concurrent ( i = 1 : ntp , tp % lmask ( i )) call gr_p4_pos_kick ( param , tp % xh (:, i ), tp % vb (:, i ), dt ) end do end associate return end subroutine helio_gr_p4_tp end submodule s_helio_gr","tags":"","loc":"sourcefile/helio_gr.f90.html"},{"title":"helio_kick.f90 – swiftest","text":"This file depends on sourcefile~~helio_kick.f90~~EfferentGraph sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~helio_kick.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_helio_kick Source Code helio_kick.f90 Source Code submodule ( helio_classes ) s_helio_kick use swiftest contains module subroutine helio_kick_getacch_pl ( self , system , param , t , lbeg ) !! author: David A. Minton !! !! Compute heliocentric accelerations of massive bodies !! !! Adapted from David E. Kaufmann's Swifter routine helio_kick_getacch.f90 !! Adapted from Hal Levison's Swift routine helio_kick_getacch.f implicit none ! Arguments class ( helio_pl ), intent ( inout ) :: self !! Helio massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step if ( self % nbody == 0 ) return associate ( cb => system % cb , pl => self , npl => self % nbody ) call pl % accel_int () if ( param % loblatecb ) then call pl % accel_obl ( system ) if ( lbeg ) then cb % aoblbeg = cb % aobl else cb % aoblend = cb % aobl end if if ( param % ltides ) then call pl % accel_tides ( system ) if ( lbeg ) then cb % atidebeg = cb % atide else cb % atideend = cb % atide end if end if end if if ( param % lextra_force ) call pl % accel_user ( system , param , t , lbeg ) if ( param % lgr ) call pl % accel_gr ( param ) end associate return end subroutine helio_kick_getacch_pl module subroutine helio_kick_getacch_tp ( self , system , param , t , lbeg ) !! author: David A. Minton !! !! Compute heliocentric accelerations of test particles !! !! Adapted from David E. Kaufmann's Swifter routine helio_kick_getacch_tp.f90 !! Adapted from Hal Levison's Swift routine helio_kick_getacch_tp.f implicit none ! Arguments class ( helio_tp ), intent ( inout ) :: self !! Helio test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step if ( self % nbody == 0 ) return associate ( tp => self , cb => system % cb , pl => system % pl , npl => system % pl % nbody ) system % lbeg = lbeg if ( system % lbeg ) then call tp % accel_int ( pl % Gmass ( 1 : npl ), pl % xbeg (:, 1 : npl ), npl ) else call tp % accel_int ( pl % Gmass ( 1 : npl ), pl % xend (:, 1 : npl ), npl ) end if if ( param % loblatecb ) call tp % accel_obl ( system ) if ( param % lextra_force ) call tp % accel_user ( system , param , t , lbeg ) if ( param % lgr ) call tp % accel_gr ( param ) end associate return end subroutine helio_kick_getacch_tp module subroutine helio_kick_vb_pl ( self , system , param , t , dt , lbeg ) !! author: David A. Minton !! !! Kick barycentric velocities of bodies !! !! Adapted from Martin Duncan and Hal Levison's Swift routine kickvh.f !! Adapted from David E. Kaufmann's Swifter routine helio_kick_vb.f90 implicit none ! Arguments class ( helio_pl ), intent ( inout ) :: self !! Swiftest generic body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Logical flag indicating whether this is the beginning of the half step or not. ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) pl % ah (:, 1 : npl ) = 0.0_DP call pl % accel ( system , param , t , lbeg ) if ( lbeg ) then call pl % set_beg_end ( xbeg = pl % xh ) else call pl % set_beg_end ( xend = pl % xh ) end if do concurrent ( i = 1 : npl , pl % lmask ( i )) pl % vb ( 1 , i ) = pl % vb ( 1 , i ) + pl % ah ( 1 , i ) * dt pl % vb ( 2 , i ) = pl % vb ( 2 , i ) + pl % ah ( 2 , i ) * dt pl % vb ( 3 , i ) = pl % vb ( 3 , i ) + pl % ah ( 3 , i ) * dt end do end associate return end subroutine helio_kick_vb_pl module subroutine helio_kick_vb_tp ( self , system , param , t , dt , lbeg ) !! author: David A. Minton !! !! Kick barycentric velocities of bodies !! !! Adapted from Martin Duncan and Hal Levison's Swift routine kickvh_tp.f !! Adapted from David E. Kaufmann's Swifter routine helio_kick_vb_tp.f90 implicit none ! Arguments class ( helio_tp ), intent ( inout ) :: self !! Swiftest generic body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Logical flag indicating whether this is the beginning of the half step or not. ! Internals integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) tp % ah (:, 1 : ntp ) = 0.0_DP call tp % accel ( system , param , t , lbeg ) do concurrent ( i = 1 : ntp , tp % lmask ( i )) tp % vb (:, i ) = tp % vb (:, i ) + tp % ah (:, i ) * dt end do end associate return end subroutine helio_kick_vb_tp end submodule s_helio_kick","tags":"","loc":"sourcefile/helio_kick.f90.html"},{"title":"helio_drift.f90 – swiftest","text":"This file depends on sourcefile~~helio_drift.f90~~EfferentGraph sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~helio_drift.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_helio_drift Source Code helio_drift.f90 Source Code submodule ( helio_classes ) s_helio_drift use swiftest contains module subroutine helio_drift_body ( self , system , param , dt ) !! author: David A. Minton !! !! Loop through bodies and call Danby drift routine on democratic heliocentric coordinates !! !! Adapted from David E. Kaufmann's Swifter routine helio_drift.f90 !! Adapted from Hal Levison's Swift routine drift.f implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize ! Internals integer ( I4B ) :: i !! Loop counter real ( DP ) :: rmag , vmag2 , energy integer ( I4B ), dimension (:), allocatable :: iflag !! Vectorized error code flag real ( DP ), dimension (:), allocatable :: dtp , mu if ( self % nbody == 0 ) return associate ( n => self % nbody ) allocate ( iflag ( n )) iflag (:) = 0 allocate ( mu ( n )) mu (:) = system % cb % Gmass call drift_all ( mu , self % xh , self % vb , self % nbody , param , dt , self % lmask , iflag ) if ( any ( iflag ( 1 : n ) /= 0 )) then where ( iflag ( 1 : n ) /= 0 ) self % status ( 1 : n ) = DISCARDED_DRIFTERR do i = 1 , n if ( iflag ( i ) /= 0 ) write ( * , * ) \" Body \" , self % id ( i ), \" lost due to error in Danby drift\" end do end if end associate return end subroutine helio_drift_body module subroutine helio_drift_pl ( self , system , param , dt ) !! author: David A. Minton !! !! Wrapper function used to call the body drift routine from a helio_pl structure implicit none ! Arguments class ( helio_pl ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize call helio_drift_body ( self , system , param , dt ) return end subroutine helio_drift_pl module subroutine helio_drift_tp ( self , system , param , dt ) !! author: David A. Minton !! !! Wrapper function used to call the body drift routine from a helio_pl structure implicit none ! Arguments class ( helio_tp ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize call helio_drift_body ( self , system , param , dt ) return end subroutine helio_drift_tp module subroutine helio_drift_linear_pl ( self , cb , dt , lbeg ) !! author: David A. Minton !! !! Perform linear drift of massive bodies due to barycentric momentum of Sun !! !! Adapted from David E. Kaufmann's Swifter routine helio_lindrift.f90 !! Adapted from Hal Levison's Swift routine helio_lindrift.f implicit none ! Arguments class ( helio_pl ), intent ( inout ) :: self !! Helio massive body object class ( helio_cb ), intent ( inout ) :: cb !! Helio central body real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Argument that determines whether or not this is the beginning or end of the step ! Internals real ( DP ), dimension ( NDIM ) :: pt !! negative barycentric velocity of the central body integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) if ( npl == 0 ) return pt ( 1 ) = sum ( pl % Gmass ( 1 : npl ) * pl % vb ( 1 , 1 : npl ), self % lmask ( 1 : npl )) pt ( 2 ) = sum ( pl % Gmass ( 1 : npl ) * pl % vb ( 2 , 1 : npl ), self % lmask ( 1 : npl )) pt ( 3 ) = sum ( pl % Gmass ( 1 : npl ) * pl % vb ( 3 , 1 : npl ), self % lmask ( 1 : npl )) pt (:) = pt (:) / cb % Gmass do concurrent ( i = 1 : npl , self % lmask ( i )) pl % xh (:, i ) = pl % xh (:, i ) + pt (:) * dt end do if ( lbeg ) then cb % ptbeg = pt (:) else cb % ptend = pt (:) end if end associate return end subroutine helio_drift_linear_pl module subroutine helio_drift_linear_tp ( self , cb , dt , lbeg ) !! author: David A. Minton !! !! Perform linear drift of test particles due to barycentric momentum of Sun !! New vectorized version included !! !! Adapted from David E. Kaufmann's Swifter routine helio_lindrift_tp.f90 !! Adapted from Hal Levison's Swift routine helio_lindrift_tp.f implicit none ! Arguments class ( helio_tp ), intent ( inout ) :: self !! Helio test particleb object class ( helio_cb ), intent ( in ) :: cb !! Helio central body real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Argument that determines whether or not this is the beginning or end of the step ! Internals real ( DP ), dimension ( NDIM ) :: pt !! negative barycentric velocity of the central body if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) if ( ntp == 0 ) return if ( lbeg ) then pt (:) = cb % ptbeg else pt (:) = cb % ptend end if where ( self % lmask ( 1 : ntp )) tp % xh ( 1 , 1 : ntp ) = tp % xh ( 1 , 1 : ntp ) + pt ( 1 ) * dt tp % xh ( 2 , 1 : ntp ) = tp % xh ( 2 , 1 : ntp ) + pt ( 2 ) * dt tp % xh ( 3 , 1 : ntp ) = tp % xh ( 3 , 1 : ntp ) + pt ( 3 ) * dt end where end associate return end subroutine helio_drift_linear_tp end submodule s_helio_drift","tags":"","loc":"sourcefile/helio_drift.f90.html"},{"title":"io.f90 – swiftest","text":"This file depends on sourcefile~~io.f90~~EfferentGraph sourcefile~io.f90 io.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~io.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_io Source Code io.f90 Source Code submodule ( swiftest_classes ) s_io use swiftest contains module subroutine io_conservation_report ( self , param , lterminal ) !! author: The Purdue Swiftest Team -  David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Reports the current state of energy, mass, and angular momentum conservation in a run implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Input colleciton of user-defined parameters logical , intent ( in ) :: lterminal !! Indicates whether to output information to the terminal screen ! Internals real ( DP ), dimension ( NDIM ) :: Ltot_now , Lorbit_now , Lspin_now real ( DP ) :: ke_orbit_now , ke_spin_now , pe_now , Eorbit_now real ( DP ) :: Eorbit_error , Etotal_error , Ecoll_error real ( DP ) :: GMtot_now real ( DP ) :: Lerror , Merror character ( len = STRMAX ) :: errmsg character ( len =* ), parameter :: EGYFMT = '(ES23.16,10(\",\",ES23.16,:))' ! Format code for all simulation output character ( len =* ), parameter :: EGYHEADER = '(\"t,Eorbit,Ecollisions,Lx,Ly,Lz,Mtot\")' integer ( I4B ), parameter :: EGYIU = 72 character ( len =* ), parameter :: EGYTERMFMT = '(\"  DL/L0 = \", ES12.5 & \"; DEcollisions/|E0| = \", ES12.5, & \"; D(Eorbit+Ecollisions)/|E0| = \", ES12.5, & \"; DM/M0 = \", ES12.5)' associate ( system => self , pl => self % pl , cb => self % cb , npl => self % pl % nbody ) if (( param % out_type == REAL4_TYPE ) . or . ( param % out_type == REAL8_TYPE ) . and . ( param % energy_out /= \"\" )) then if ( param % lfirstenergy . and . ( param % out_stat /= \"OLD\" )) then open ( unit = EGYIU , file = param % energy_out , form = \"formatted\" , status = \"replace\" , action = \"write\" , err = 667 , iomsg = errmsg ) write ( EGYIU , EGYHEADER , err = 667 , iomsg = errmsg ) else open ( unit = EGYIU , file = param % energy_out , form = \"formatted\" , status = \"old\" , action = \"write\" , position = \"append\" , err = 667 , iomsg = errmsg ) end if end if call pl % vb2vh ( cb ) call pl % xh2xb ( cb ) call system % get_energy_and_momentum ( param ) ke_orbit_now = system % ke_orbit ke_spin_now = system % ke_spin pe_now = system % pe Lorbit_now (:) = system % Lorbit (:) Lspin_now (:) = system % Lspin (:) Eorbit_now = ke_orbit_now + ke_spin_now + pe_now Ltot_now (:) = system % Ltot (:) + param % Lescape (:) GMtot_now = system % GMtot + param % GMescape if ( param % lfirstenergy ) then param % Eorbit_orig = Eorbit_now param % GMtot_orig = GMtot_now param % Lorbit_orig (:) = Lorbit_now (:) param % Lspin_orig (:) = Lspin_now (:) param % Ltot_orig (:) = Ltot_now (:) param % lfirstenergy = . false . end if if (( param % out_type == REAL4_TYPE ) . or . ( param % out_type == REAL8_TYPE ) . and . ( param % energy_out /= \"\" )) then write ( EGYIU , EGYFMT , err = 667 , iomsg = errmsg ) param % t , Eorbit_now , param % Ecollisions , Ltot_now , GMtot_now close ( EGYIU , err = 667 , iomsg = errmsg ) end if if (. not . param % lfirstenergy ) then Lerror = norm2 ( Ltot_now (:) - param % Ltot_orig (:)) / norm2 ( param % Ltot_orig (:)) Eorbit_error = ( Eorbit_now - param % Eorbit_orig ) / abs ( param % Eorbit_orig ) Ecoll_error = param % Ecollisions / abs ( param % Eorbit_orig ) Etotal_error = ( Eorbit_now - param % Ecollisions - param % Eorbit_orig - param % Euntracked ) / abs ( param % Eorbit_orig ) Merror = ( GMtot_now - param % GMtot_orig ) / param % GMtot_orig if ( lterminal ) write ( * , EGYTERMFMT ) Lerror , Ecoll_error , Etotal_error , Merror if ( abs ( Merror ) > 100 * epsilon ( Merror )) then write ( * , * ) \"Severe error! Mass not conserved! Halting!\" call pl % xv2el ( cb ) call param % nciu % open ( param ) call self % write_hdr ( param % nciu , param ) call cb % write_frame ( param % nciu , param ) call pl % write_frame ( param % nciu , param ) call param % nciu % close ( param ) call util_exit ( FAILURE ) end if end if end associate return 667 continue write ( * , * ) \"Error writing energy and momentum tracking file: \" // trim ( adjustl ( errmsg )) call util_exit ( FAILURE ) end subroutine io_conservation_report module subroutine io_dump_param ( self , param_file_name ) !! author: David A. Minton !! !! Dump integration parameters to file !! !! Adapted from David E. Kaufmann's Swifter routine io_dump_param.f90 !! Adapted from Martin Duncan's Swift routine io_dump_param.f implicit none ! Arguments class ( swiftest_parameters ), intent ( in ) :: self !! Output collection of parameters character ( len =* ), intent ( in ) :: param_file_name !! Parameter input file name (i.e. param.in) ! Internals integer ( I4B ), parameter :: LUN = 7 !! Unit number of output file character ( STRMAX ) :: errmsg !! Error message in UDIO procedure integer ( I4B ) :: ierr open ( unit = LUN , file = param_file_name , status = 'replace' , form = 'FORMATTED' , err = 667 , iomsg = errmsg ) !! todo: Currently this procedure does not work in user-defined derived-type input mode !!    due to compiler incompatabilities !write(LUN,'(DT)') param call self % writer ( LUN , iotype = \"none\" , v_list = [ 0 ], iostat = ierr , iomsg = errmsg ) if ( ierr == 0 ) then close ( LUN , err = 667 , iomsg = errmsg ) return end if 667 continue write ( * , * ) \"Error opening parameter dump file \" // trim ( adjustl ( errmsg )) call util_exit ( FAILURE ) end subroutine io_dump_param module subroutine io_dump_particle_info ( self , iu ) !! author: David A. Minton !! !! Reads in particle information object information from an open file unformatted file implicit none ! Arguments class ( swiftest_particle_info ), intent ( in ) :: self !! Particle metadata information object integer ( I4B ), intent ( in ) :: iu !! Open file unit number ! Internals character ( STRMAX ) :: errmsg write ( iu , err = 667 , iomsg = errmsg ) self % name write ( iu , err = 667 , iomsg = errmsg ) self % particle_type write ( iu , err = 667 , iomsg = errmsg ) self % origin_type write ( iu , err = 667 , iomsg = errmsg ) self % origin_time write ( iu , err = 667 , iomsg = errmsg ) self % origin_xh (:) write ( iu , err = 667 , iomsg = errmsg ) self % origin_vh (:) return 667 continue write ( * , * ) \"Error writing particle metadata information from file: \" // trim ( adjustl ( errmsg )) call util_exit ( FAILURE ) end subroutine io_dump_particle_info module subroutine io_dump_particle_info_base ( self , param , idx ) !! author: David A. Minton !! !! Dumps the particle information data to a file. !! Pass a list of array indices for test particles (tpidx) and/or massive bodies (plidx) to append implicit none ! Arguments class ( swiftest_base ), intent ( inout ) :: self !! Swiftest base object (can be cb, pl, or tp) class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters integer ( I4B ), dimension (:), optional , intent ( in ) :: idx !! Array of test particle indices to append to the particle file ! Internals logical , save :: lfirst = . true . integer ( I4B ), parameter :: LUN = 22 integer ( I4B ) :: i character ( STRMAX ) :: errmsg !if ((param%out_type == REAL4_TYPE) .or. (param%out_type == REAL8_TYPE)) then if ( lfirst ) then select case ( param % out_stat ) case ( 'APPEND' ) open ( unit = LUN , file = param % particle_out , status = 'OLD' , position = 'APPEND' , form = 'UNFORMATTED' , err = 667 , iomsg = errmsg ) case ( 'NEW' , 'UNKNOWN' , 'REPLACE' ) open ( unit = LUN , file = param % particle_out , status = param % out_stat , form = 'UNFORMATTED' , err = 667 , iomsg = errmsg ) case default write ( * , * ) 'Invalid status code' , trim ( adjustl ( param % out_stat )) call util_exit ( FAILURE ) end select lfirst = . false . else open ( unit = LUN , file = param % particle_out , status = 'OLD' , position = 'APPEND' , form = 'UNFORMATTED' , err = 667 , iomsg = errmsg ) end if select type ( self ) class is ( swiftest_cb ) write ( LUN , err = 667 , iomsg = errmsg ) self % id call self % info % dump ( LUN ) class is ( swiftest_body ) if ( present ( idx )) then do i = 1 , size ( idx ) write ( LUN , err = 667 , iomsg = errmsg ) self % id ( idx ( i )) call self % info ( idx ( i ))% dump ( LUN ) end do else do i = 1 , self % nbody write ( LUN , err = 667 , iomsg = errmsg ) self % id ( i ) call self % info ( i )% dump ( LUN ) end do end if end select close ( unit = LUN , err = 667 , iomsg = errmsg ) !else if ((param%out_type == NETCDF_FLOAT_TYPE) .or. (param%out_type == NETCDF_DOUBLE_TYPE)) then if (( param % out_type == NETCDF_FLOAT_TYPE ) . or . ( param % out_type == NETCDF_DOUBLE_TYPE )) then call param % nciu % open ( param ) call self % write_particle_info ( param % nciu ) call param % nciu % close ( param ) end if return 667 continue write ( * , * ) \"Error reading central body file: \" // trim ( adjustl ( errmsg )) call util_exit ( FAILURE ) end subroutine io_dump_particle_info_base module subroutine io_dump_base ( self , param ) !! author: David A. Minton !! !! Dump massive body data to files !! !! Adapted from David E. Kaufmann's Swifter routine: io_dump_pl.f90 and io_dump_tp.f90 !! Adapted from Hal Levison's Swift routine io_dump_pl.f and io_dump_tp.f implicit none ! Arguments class ( swiftest_base ), intent ( inout ) :: self !! Swiftest base object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: ierr !! Error code integer ( I4B ), parameter :: LUN = 7 !! Unit number for dump file integer ( I4B ) :: iu = LUN character ( len = :), allocatable :: dump_file_name character ( STRMAX ) :: errmsg select type ( self ) class is ( swiftest_cb ) dump_file_name = trim ( adjustl ( param % incbfile )) class is ( swiftest_pl ) dump_file_name = trim ( adjustl ( param % inplfile )) class is ( swiftest_tp ) dump_file_name = trim ( adjustl ( param % intpfile )) end select open ( unit = iu , file = dump_file_name , form = \"UNFORMATTED\" , status = 'replace' , err = 667 , iomsg = errmsg ) select type ( self ) class is ( swiftest_body ) write ( iu , err = 667 , iomsg = errmsg ) self % nbody call io_write_frame_body ( self , iu , param ) class is ( swiftest_cb ) call io_write_frame_cb ( self , iu , param ) end select close ( iu , err = 667 , iomsg = errmsg ) return 667 continue write ( * , * ) \"Error dumping body data to file \" // trim ( adjustl ( errmsg )) call util_exit ( FAILURE ) end subroutine io_dump_base module subroutine io_dump_system ( self , param ) !! author: David A. Minton !! !! Dumps the state of the system to files in case the simulation is interrupted. !! As a safety mechanism, there are two dump files that are written in alternating order !! so that if a dump file gets corrupted during writing, the user can restart from the older one. implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals class ( swiftest_parameters ), allocatable :: dump_param !! Local parameters variable used to parameters change input file names !! to dump file-specific values without changing the user-defined values integer ( I4B ), save :: idx = 1 !! Index of current dump file. Output flips between 2 files for extra security !! in case the program halts during writing character ( len = :), allocatable :: param_file_name real ( DP ) :: tfrac character ( * ), parameter :: statusfmt = '(\"Time = \", ES12.5, \"; fraction done = \", F6.3, \"; Number of active pl, tp = \", I5, \", \", I5)' character ( * ), parameter :: symbastatfmt = '(\"Time = \", ES12.5, \"; fraction done = \", F6.3, \"; Number of active plm, pl, tp = \", I5, \", \", I5, \", \", I5)' logical , save :: lfirst = . true . if ( lfirst ) then lfirst = . false . if ( param % lenergy ) call self % conservation_report ( param , lterminal = . false .) else allocate ( dump_param , source = param ) param_file_name = trim ( adjustl ( DUMP_PARAM_FILE ( idx ))) dump_param % incbfile = trim ( adjustl ( DUMP_CB_FILE ( idx ))) dump_param % inplfile = trim ( adjustl ( DUMP_PL_FILE ( idx ))) dump_param % intpfile = trim ( adjustl ( DUMP_TP_FILE ( idx ))) dump_param % in_form = XV dump_param % out_stat = 'APPEND' dump_param % in_type = REAL8_TYPE dump_param % T0 = param % t call dump_param % dump ( param_file_name ) dump_param % out_form = XV call self % cb % dump ( dump_param ) call self % pl % dump ( dump_param ) call self % tp % dump ( dump_param ) idx = idx + 1 if ( idx > NDUMPFILES ) idx = 1 tfrac = ( param % t - param % t0 ) / ( param % tstop - param % t0 ) select type ( pl => self % pl ) class is ( symba_pl ) write ( * , symbastatfmt ) param % t , tfrac , pl % nplm , pl % nbody , self % tp % nbody class default write ( * , statusfmt ) param % t , tfrac , pl % nbody , self % tp % nbody end select end if return end subroutine io_dump_system module function io_get_args ( integrator , param_file_name ) result ( ierr ) !! author: David A. Minton !! !! Reads in the name of the parameter file from command line arguments. implicit none ! Arguments integer ( I4B ) :: integrator !! Symbolic code of the requested integrator character ( len = :), allocatable :: param_file_name !! Name of the input parameters file ! Result integer ( I4B ) :: ierr !! I/O error code ! Internals character ( len = STRMAX ) :: arg1 , arg2 integer :: narg , ierr_arg1 , ierr_arg2 character ( len =* ), parameter :: linefmt = '(A)' ierr = - 1 ! Default is to fail narg = command_argument_count () ! if ( narg == 2 ) then call get_command_argument ( 1 , arg1 , status = ierr_arg1 ) call get_command_argument ( 2 , arg2 , status = ierr_arg2 ) if (( ierr_arg1 == 0 ) . and . ( ierr_arg2 == 0 )) then ierr = 0 call io_toupper ( arg1 ) select case ( arg1 ) case ( 'BS' ) integrator = BS case ( 'HELIO' ) integrator = HELIO case ( 'RA15' ) integrator = RA15 case ( 'TU4' ) integrator = TU4 case ( 'WHM' ) integrator = WHM case ( 'RMVS' ) integrator = RMVS case ( 'SYMBA' ) integrator = SYMBA case ( 'RINGMOONS' ) integrator = RINGMOONS case default integrator = UNKNOWN_INTEGRATOR write ( * , * ) trim ( adjustl ( arg1 )) // ' is not a valid integrator.' ierr = - 1 end select param_file_name = trim ( adjustl ( arg2 )) end if else call get_command_argument ( 1 , arg1 , status = ierr_arg1 ) if ( ierr_arg1 == 0 ) then if ( arg1 == '-v' . or . arg1 == '--version' ) then call util_version () else if ( arg1 == '-h' . or . arg1 == '--help' ) then call util_exit ( HELP ) end if end if end if if ( ierr /= 0 ) call util_exit ( USAGE ) return end function io_get_args module function io_get_old_t_final_system ( self , param ) result ( old_t_final ) !! author: David A. Minton !! !! Validates the dump file to check whether the dump file initial conditions duplicate the last frame of the binary output. !! implicit none ! Arguments class ( swiftest_nbody_system ), intent ( in ) :: self class ( swiftest_parameters ), intent ( in ) :: param ! Result real ( DP ) :: old_t_final ! Internals class ( swiftest_nbody_system ), allocatable :: tmpsys class ( swiftest_parameters ), allocatable :: tmpparam integer ( I4B ), parameter :: LUN = 76 integer ( I4B ) :: ierr , iu = LUN character ( len = STRMAX ) :: errmsg old_t_final = 0.0_DP allocate ( tmpsys , source = self ) allocate ( tmpparam , source = param ) ierr = 0 open ( unit = iu , file = param % outfile , status = 'OLD' , form = 'UNFORMATTED' , err = 667 , iomsg = errmsg ) do ierr = tmpsys % read_frame ( iu , tmpparam ) if ( ierr /= 0 ) exit end do if ( is_iostat_end ( ierr )) then old_t_final = tmpparam % t return end if 667 continue write ( * , * ) \"Error reading binary output file. \" // trim ( adjustl ( errmsg )) call util_exit ( FAILURE ) end function io_get_old_t_final_system module function io_get_token ( buffer , ifirst , ilast , ierr ) result ( token ) !! author: David A. Minton !! !! Retrieves a character token from an input string. Here a token is defined as any set of contiguous non-blank characters not !! beginning with or containing \"!\". If \"!\" is present, any remaining part of the buffer including the \"!\" is ignored !! !! Adapted from David E. Kaufmann's Swifter routine io_get_token.f90 implicit none ! Arguments character ( len =* ), intent ( in ) :: buffer !! Input string buffer integer ( I4B ), intent ( inout ) :: ifirst !! Index of the buffer at which to start the search for a token integer ( I4B ), intent ( out ) :: ilast !! Index of the buffer at the end of the returned token integer ( I4B ), intent ( out ) :: ierr !! Error code ! Result character ( len = :), allocatable :: token !! Returned token string ! Internals integer ( I4B ) :: i , ilength ilength = len ( buffer ) if ( ifirst > ilength ) then ilast = ifirst ierr = - 1 !! Bad input token = '' return end if do i = ifirst , ilength if ( buffer ( i : i ) /= ' ' ) exit end do if (( i > ilength ) . or . ( buffer ( i : i ) == '!' )) then ifirst = i ilast = i ierr = - 2 !! No valid token token = '' return end if ifirst = i do i = ifirst , ilength if (( buffer ( i : i ) == ' ' ) . or . ( buffer ( i : i ) == '!' )) exit end do ilast = i - 1 ierr = 0 token = buffer ( ifirst : ilast ) return end function io_get_token module subroutine io_param_reader ( self , unit , iotype , v_list , iostat , iomsg ) !! author: The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Read in parameters for the integration !! Currently this procedure does not work in user-defined derived-type input mode !!    e.g. read(unit,'(DT)') param !! as the newline characters are ignored in the input file when compiled in ifort. !! !! Adapted from David E. Kaufmann's Swifter routine io_init_param.f90 !! Adapted from Martin Duncan's Swift routine io_init_param.f implicit none ! Arguments class ( swiftest_parameters ), intent ( inout ) :: self !! Collection of parameters integer , intent ( in ) :: unit !! File unit number character ( len =* ), intent ( in ) :: iotype !! Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. !!    If you do not include a char-literal-constant, the iotype argument contains only DT. integer , intent ( in ) :: v_list (:) !! The first element passes the integrator code to the reader integer , intent ( out ) :: iostat !! IO status code character ( len =* ), intent ( inout ) :: iomsg !! Message to pass if iostat /= 0 ! Internals logical :: t0_set = . false . !! Is the initial time set in the input file? logical :: tstop_set = . false . !! Is the final time set in the input file? logical :: dt_set = . false . !! Is the step size set in the input file? integer ( I4B ) :: ilength , ifirst , ilast , i !! Variables used to parse input file character ( STRMAX ) :: line !! Line of the input file character ( len = :), allocatable :: line_trim , param_name , param_value !! Strings used to parse the param file character ( * ), parameter :: linefmt = '(A)' !! Format code for simple text string ! Parse the file line by line, extracting tokens then matching them up with known parameters if possible associate ( param => self ) do read ( unit = unit , fmt = linefmt , end = 1 , err = 667 , iomsg = iomsg ) line line_trim = trim ( adjustl ( line )) ilength = len ( line_trim ) if (( ilength /= 0 )) then ifirst = 1 ! Read the pair of tokens. The first one is the parameter name, the second is the value. param_name = io_get_token ( line_trim , ifirst , ilast , iostat ) if ( param_name == '' ) cycle ! No parameter name (usually because this line is commented out) call io_toupper ( param_name ) ifirst = ilast + 1 param_value = io_get_token ( line_trim , ifirst , ilast , iostat ) select case ( param_name ) case ( \"T0\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % t0 t0_set = . true . case ( \"TSTOP\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % tstop tstop_set = . true . case ( \"DT\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % dt dt_set = . true . case ( \"CB_IN\" ) param % incbfile = param_value case ( \"PL_IN\" ) param % inplfile = param_value case ( \"TP_IN\" ) param % intpfile = param_value case ( \"IN_TYPE\" ) call io_toupper ( param_value ) param % in_type = param_value case ( \"IN_FORM\" ) call io_toupper ( param_value ) param % in_form = param_value case ( \"ISTEP_OUT\" ) read ( param_value , * ) param % istep_out case ( \"BIN_OUT\" ) param % outfile = param_value case ( \"OUT_TYPE\" ) call io_toupper ( param_value ) param % out_type = param_value case ( \"OUT_FORM\" ) call io_toupper ( param_value ) param % out_form = param_value case ( \"OUT_STAT\" ) call io_toupper ( param_value ) param % out_stat = param_value case ( \"ISTEP_DUMP\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % istep_dump case ( \"CHK_CLOSE\" ) call io_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % lclose = . true . case ( \"CHK_RMIN\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % rmin case ( \"CHK_RMAX\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % rmax case ( \"CHK_EJECT\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % rmaxu case ( \"CHK_QMIN\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % qmin case ( \"CHK_QMIN_COORD\" ) call io_toupper ( param_value ) param % qmin_coord = param_value case ( \"CHK_QMIN_RANGE\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % qmin_alo ifirst = ilast + 1 param_value = io_get_token ( line , ifirst , ilast , iostat ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % qmin_ahi case ( \"ENC_OUT\" ) param % enc_out = param_value case ( \"DISCARD_OUT\" ) param % discard_out = param_value case ( \"ENERGY_OUT\" ) param % energy_out = param_value case ( \"EXTRA_FORCE\" ) call io_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % lextra_force = . true . case ( \"BIG_DISCARD\" ) call io_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % lbig_discard = . true . case ( \"RHILL_PRESENT\" ) call io_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % lrhill_present = . true . case ( \"MU2KG\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % MU2KG case ( \"TU2S\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % TU2S case ( \"DU2M\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % DU2M case ( \"ENERGY\" ) call io_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % lenergy = . true . case ( \"GR\" ) call io_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % lgr = . true . case ( \"ROTATION\" ) call io_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % lrotation = . true . case ( \"TIDES\" ) call io_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == 'T' ) param % ltides = . true . case ( \"FIRSTKICK\" ) call io_toupper ( param_value ) if ( param_value == \"NO\" . or . param_value == 'F' ) param % lfirstkick = . false . case ( \"FIRSTENERGY\" ) call io_toupper ( param_value ) if ( param_value == \"NO\" . or . param_value == 'F' ) param % lfirstenergy = . false . case ( \"EORBIT_ORIG\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % Eorbit_orig case ( \"GMTOT_ORIG\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % GMtot_orig case ( \"LTOT_ORIG\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % Ltot_orig ( 1 ) do i = 2 , NDIM ifirst = ilast + 2 param_value = io_get_token ( line , ifirst , ilast , iostat ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % Ltot_orig ( i ) end do case ( \"LORBIT_ORIG\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % Lorbit_orig ( 1 ) do i = 2 , NDIM ifirst = ilast + 2 param_value = io_get_token ( line , ifirst , ilast , iostat ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % Lorbit_orig ( i ) end do case ( \"LSPIN_ORIG\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % Lspin_orig ( 1 ) do i = 2 , NDIM ifirst = ilast + 2 param_value = io_get_token ( line , ifirst , ilast , iostat ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % Lspin_orig ( i ) end do case ( \"LESCAPE\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % Lescape ( 1 ) do i = 2 , NDIM ifirst = ilast + 2 param_value = io_get_token ( line , ifirst , ilast , iostat ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % Lescape ( i ) end do case ( \"GMESCAPE\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % GMescape case ( \"ECOLLISIONS\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % Ecollisions case ( \"EUNTRACKED\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % Euntracked case ( \"MAXID\" ) read ( param_value , * , err = 667 , iomsg = iomsg ) param % maxid case ( \"PARTICLE_OUT\" ) param % particle_out = param_value case ( \"NPLMAX\" , \"NTPMAX\" , \"GMTINY\" , \"MIN_GMFRAG\" , \"FRAGMENTATION\" , \"SEED\" , \"YARKOVSKY\" , \"YORP\" ) ! Ignore SyMBA-specific, not-yet-implemented, or obsolete input parameters case default write ( * , * ) \"Unknown parameter -> \" , param_name iostat = - 1 return end select end if end do 1 continue iostat = 0 !! Do basic sanity checks on the input values if ((. not . t0_set ) . or . (. not . tstop_set ) . or . (. not . dt_set )) then write ( iomsg , * ) 'Valid simulation time not set' iostat = - 1 return end if if ( param % dt <= 0.0_DP ) then write ( iomsg , * ) 'Invalid timestep: ' iostat = - 1 return end if if ( param % inplfile == \"\" ) then write ( iomsg , * ) 'No valid massive body file in input file' iostat = - 1 return end if if (( param % in_type /= REAL8_TYPE ) . and . ( param % in_type /= \"ASCII\" )) then write ( iomsg , * ) 'Invalid input file type:' , trim ( adjustl ( param % in_type )) iostat = - 1 return end if if (( param % istep_out <= 0 ) . and . ( param % istep_dump <= 0 )) then write ( iomsg , * ) 'Invalid istep' iostat = - 1 return end if if (( param % istep_out > 0 ) . and . ( param % outfile == \"\" )) then write ( iomsg , * ) 'Invalid outfile' iostat = - 1 return end if param % lrestart = ( param % out_stat == \"APPEND\" ) if ( param % outfile /= \"\" ) then if (( param % out_type /= REAL4_TYPE ) . and . ( param % out_type /= REAL8_TYPE ) . and . & ( param % out_type /= NETCDF_FLOAT_TYPE ) . and . ( param % out_type /= NETCDF_DOUBLE_TYPE )) then write ( iomsg , * ) 'Invalid out_type: ' , trim ( adjustl ( param % out_type )) iostat = - 1 return end if if (( param % out_form /= \"EL\" ) . and . ( param % out_form /= \"XV\" ) . and . ( param % out_form /= \"XVEL\" )) then write ( iomsg , * ) 'Invalid out_form: ' , trim ( adjustl ( param % out_form )) iostat = - 1 return end if if (( param % out_stat /= \"NEW\" ) . and . ( param % out_stat /= \"REPLACE\" ) . and . ( param % out_stat /= \"APPEND\" ) . and . ( param % out_stat /= \"UNKNOWN\" )) then write ( iomsg , * ) 'Invalid out_stat: ' , trim ( adjustl ( param % out_stat )) iostat = - 1 return end if end if if ( param % qmin > 0.0_DP ) then if (( param % qmin_coord /= \"HELIO\" ) . and . ( param % qmin_coord /= \"BARY\" )) then write ( iomsg , * ) 'Invalid qmin_coord: ' , trim ( adjustl ( param % qmin_coord )) iostat = - 1 return end if if (( param % qmin_alo <= 0.0_DP ) . or . ( param % qmin_ahi <= 0.0_DP )) then write ( iomsg , * ) 'Invalid qmin vals' iostat = - 1 return end if end if if ( param % ltides . and . . not . param % lrotation ) then write ( iomsg , * ) 'Tides require rotation to be turned on' iostat = - 1 return end if write ( * , * ) \"T0             = \" , param % t0 write ( * , * ) \"TSTOP          = \" , param % tstop write ( * , * ) \"DT             = \" , param % dt write ( * , * ) \"CB_IN          = \" , trim ( adjustl ( param % incbfile )) write ( * , * ) \"PL_IN          = \" , trim ( adjustl ( param % inplfile )) write ( * , * ) \"TP_IN          = \" , trim ( adjustl ( param % intpfile )) write ( * , * ) \"IN_TYPE        = \" , trim ( adjustl ( param % in_type )) write ( * , * ) \"ISTEP_OUT      = \" , param % istep_out write ( * , * ) \"BIN_OUT        = \" , trim ( adjustl ( param % outfile )) write ( * , * ) \"OUT_TYPE       = \" , trim ( adjustl ( param % out_type )) write ( * , * ) \"OUT_FORM       = \" , trim ( adjustl ( param % out_form )) write ( * , * ) \"IN_FORM        = \" , trim ( adjustl ( param % in_form )) write ( * , * ) \"OUT_STAT       = \" , trim ( adjustl ( param % out_stat )) write ( * , * ) \"ISTEP_DUMP     = \" , param % istep_dump write ( * , * ) \"CHK_CLOSE      = \" , param % lclose if ( param % rmin > 0.0 ) then write ( * , * ) \"CHK_RMIN       = \" , param % rmin else write ( * , * ) \"! CHK_RMIN value will be the central body radius\" end if if ( param % rmax > 0.0_DP ) write ( * , * ) \"CHK_RMAX       = \" , param % rmax if ( param % rmaxu > 0.0_DP ) write ( * , * ) \"CHK_EJECT      = \" , param % rmaxu if (( param % qmin > 0.0_DP ) . or . ( param % qmin_alo > 0.0_DP ) . or . ( param % qmin_ahi > 0.0_DP )) write ( * , * ) \"CHK_QMIN_COORD = \" , trim ( adjustl ( param % qmin_coord )) if ( param % qmin > 0.0_DP ) write ( * , * ) \"CHK_QMIN       = \" , param % qmin if (( param % qmin_alo > 0.0_DP ) . or . ( param % qmin_ahi > 0.0_DP )) write ( * , * ) \"CHK_QMIN_RANGE = \" , param % qmin_alo , param % qmin_ahi write ( * , * ) \"EXTRA_FORCE    = \" , param % lextra_force write ( * , * ) \"RHILL_PRESENT  = \" , param % lrhill_present write ( * , * ) \"ROTATION      = \" , param % lrotation write ( * , * ) \"TIDES         = \" , param % ltides write ( * , * ) \"ENERGY         = \" , param % lenergy if ( param % lenergy ) write ( * , * ) \"ENERGY_OUT     = \" , trim ( adjustl ( param % energy_out )) write ( * , * ) \"MU2KG          = \" , param % MU2KG write ( * , * ) \"TU2S           = \" , param % TU2S write ( * , * ) \"DU2M           = \" , param % DU2M if ( trim ( adjustl ( param % outfile )) == \"\" ) then param % outfile = BIN_OUTFILE end if if ( trim ( adjustl ( param % enc_out )) /= \"\" ) then write ( * , * ) \"ENC_OUT        = \" , trim ( adjustl ( param % enc_out )) else write ( * , * ) \"! ENC_OUT not set: Encounters will not be recorded to file\" end if if ( trim ( adjustl ( param % discard_out )) /= \"\" ) then write ( * , * ) \"DISCARD_OUT    = \" , trim ( adjustl ( param % discard_out )) write ( * , * ) \"BIG_DISCARD    = \" , param % lbig_discard else write ( * , * ) \"! DISCARD_OUT not set: Discards will not be recorded to file\" param % lbig_discard = . false . write ( * , * ) \"! BIG_DISCARD    = \" , param % lbig_discard end if if (( param % MU2KG < 0.0_DP ) . or . ( param % TU2S < 0.0_DP ) . or . ( param % DU2M < 0.0_DP )) then write ( iomsg , * ) 'Invalid unit conversion factor' iostat = - 1 return end if ! Calculate the G for the system units param % GU = GC / ( param % DU2M ** 3 / ( param % MU2KG * param % TU2S ** 2 )) if ( param % lgr ) then ! Calculate the inverse speed of light in the system units param % inv_c2 = einsteinC * param % TU2S / param % DU2M param % inv_c2 = ( param % inv_c2 ) ** ( - 2 ) end if associate ( integrator => v_list ( 1 )) if (( integrator == RMVS ) . or . ( integrator == SYMBA )) then if (. not . param % lclose ) then write ( iomsg , * ) 'This integrator requires CHK_CLOSE to be enabled.' iostat = - 1 return end if end if ! Determine if the GR flag is set correctly for this integrator select case ( integrator ) case ( WHM , RMVS , HELIO , SYMBA ) write ( * , * ) \"GR             = \" , param % lgr case default if ( param % lgr ) write ( iomsg , * ) 'GR is not yet implemented for this integrator. This parameter will be ignored.' param % lgr = . false . end select end associate iostat = 0 end associate 667 continue return end subroutine io_param_reader module subroutine io_param_writer ( self , unit , iotype , v_list , iostat , iomsg ) !! author: David A. Minton !! !! Dump integration parameters to file !! !! Adapted from David E. Kaufmann's Swifter routine io_dump_param.f90 !! Adapted from Martin Duncan's Swift routine io_dump_param.f implicit none ! Arguments class ( swiftest_parameters ), intent ( in ) :: self !! Collection of parameters integer , intent ( in ) :: unit !! File unit number character ( len =* ), intent ( in ) :: iotype !! Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. !!    If you do not include a char-literal-constant, the iotype argument contains only DT. integer , intent ( in ) :: v_list (:) !! Not used in this procedure integer , intent ( out ) :: iostat !! IO status code character ( len =* ), intent ( inout ) :: iomsg !! Message to pass if iostat /= 0 ! Internals character ( * ), parameter :: Ifmt = '(I0)' !! Format label for integer values character ( * ), parameter :: Rfmt = '(ES25.17)' !! Format label for real values character ( * ), parameter :: Lfmt = '(L1)' !! Format label for logical values character ( len = NAMELEN ) :: param_name character ( LEN = STRMAX ) :: param_value , v1 , v2 , v3 type character_array character ( 25 ) :: value end type character_array type ( character_array ), dimension (:), allocatable :: param_array integer ( I4B ) :: i associate ( param => self ) write ( param_name , * ) \"T0\" ; write ( param_value , Rfmt ) param % t0 ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"TSTOP\" ; write ( param_value , Rfmt ) param % tstop ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"DT\" ; write ( param_value , Rfmt ) param % dt ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"CB_IN\" ; write ( param_value , * ) trim ( adjustl ( param % incbfile )); write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"PL_IN\" ; write ( param_value , * ) trim ( adjustl ( param % inplfile )); write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"TP_IN\" ; write ( param_value , * ) trim ( adjustl ( param % intpfile )); write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"IN_TYPE\" ; write ( param_value , * ) trim ( adjustl ( param % in_type )); write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"IN_FORM\" ; write ( param_value , * ) trim ( adjustl ( param % in_form )); write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) if ( param % istep_dump > 0 ) write ( param_name , * ) \"ISTEP_DUMP\" ; write ( param_value , Ifmt ) param % istep_dump ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) if ( param % istep_out > 0 ) then write ( param_name , * ) \"ISTEP_OUT\" ; write ( param_value , Ifmt ) param % istep_out ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"BIN_OUT\" ; write ( param_value , * ) trim ( adjustl ( param % outfile )); write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"OUT_TYPE\" ; write ( param_value , * ) trim ( adjustl ( param % out_type )); write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"OUT_FORM\" ; write ( param_value , * ) trim ( adjustl ( param % out_form )); write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"OUT_STAT\" ; write ( param_value , * ) \"APPEND\" ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) end if write ( param_name , * ) \"PARTICLE_OUT\" ; write ( param_value , * ) trim ( adjustl ( param % particle_out )); write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) if ( param % enc_out /= \"\" ) then write ( param_name , * ) \"ENC_OUT\" ; write ( param_value , * ) trim ( adjustl ( param % enc_out )); write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) end if write ( param_name , * ) \"CHK_RMIN\" ; write ( param_value , Rfmt ) param % rmin ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"CHK_RMAX\" ; write ( param_value , Rfmt ) param % rmax ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"CHK_EJECT\" ; write ( param_value , Rfmt ) param % rmaxu ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"CHK_QMIN\" ; write ( param_value , Rfmt ) param % qmin ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) if ( param % qmin >= 0.0_DP ) then write ( param_name , * ) \"CHK_QMIN_COORD\" ; write ( param_value , * ) trim ( adjustl ( param % qmin_coord )); write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) allocate ( param_array ( 2 )) write ( param_array ( 1 )% value , Rfmt ) param % qmin_alo write ( param_array ( 2 )% value , Rfmt ) param % qmin_ahi write ( param_name , * ) \"CHK_QMIN_RANGE\" ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ), adjustl ( param_array ( 1 )% value ), adjustl ( param_array ( 2 )% value ) end if write ( param_name , * ) \"MU2KG\" ; write ( param_value , Rfmt ) param % MU2KG ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"TU2S\" ; write ( param_value , Rfmt ) param % TU2S ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"DU2M\" ; write ( param_value , Rfmt ) param % DU2M ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"RHILL_PRESENT\" ; write ( param_value , Lfmt ) param % lrhill_present ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"EXTRA_FORCE\" ; write ( param_value , Lfmt ) param % lextra_force ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) if ( param % discard_out /= \"\" ) then write ( param_name , * ) \"DISCARD_OUT\" ; write ( param_value , * ) trim ( adjustl ( param % discard_out )); write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) end if if ( param % discard_out /= \"\" ) then write ( param_name , * ) \"BIG_DISCARD\" ; write ( param_value , Lfmt ) param % lbig_discard ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) end if write ( param_name , * ) \"CHK_CLOSE\" ; write ( param_value , Lfmt ) param % lclose ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"ENERGY\" ; write ( param_value , Lfmt ) param % lenergy ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) if ( param % lenergy . and . ( param % energy_out /= \"\" )) then write ( param_name , * ) \"ENERGY_OUT\" ; write ( param_value , * ) trim ( adjustl ( param % energy_out )); write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) end if write ( param_name , * ) \"GR\" ; write ( param_value , Lfmt ) param % lgr ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"ROTATION\" ; write ( param_value , Lfmt ) param % lrotation ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"TIDES\" ; write ( param_value , Lfmt ) param % ltides ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) if ( param % lenergy ) then write ( param_name , * ) \"FIRSTENERGY\" ; write ( param_value , Lfmt ) param % lfirstenergy ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"EORBIT_ORIG\" ; write ( param_value , Rfmt ) param % Eorbit_orig ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"GMTOT_ORIG\" ; write ( param_value , Rfmt ) param % GMtot_orig ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"LTOT_ORIG\" ; write ( v1 , Rfmt ) param % Ltot_orig ( 1 ); write ( v2 , Rfmt ) param % Ltot_orig ( 2 ); write ( v3 , Rfmt ) param % Ltot_orig ( 3 ) write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( v1 )) // \" \" // trim ( adjustl ( v2 )) // \" \" // trim ( adjustl ( v3 )) write ( param_name , * ) \"LORBIT_ORIG\" ; write ( v1 , Rfmt ) param % Lorbit_orig ( 1 ); write ( v2 , Rfmt ) param % Lorbit_orig ( 2 ); write ( v3 , Rfmt ) param % Lorbit_orig ( 3 ) write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( v1 )) // \" \" // trim ( adjustl ( v2 )) // \" \" // trim ( adjustl ( v3 )) write ( param_name , * ) \"LSPIN_ORIG\" ; write ( v1 , Rfmt ) param % Lspin_orig ( 1 ); write ( v2 , Rfmt ) param % Lspin_orig ( 2 ); write ( v3 , Rfmt ) param % Lspin_orig ( 3 ) write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( v1 )) // \" \" // trim ( adjustl ( v2 )) // \" \" // trim ( adjustl ( v3 )) write ( param_name , * ) \"LESCAPE\" ; write ( v1 , Rfmt ) param % Lescape ( 1 ); write ( v2 , Rfmt ) param % Lescape ( 2 ); write ( v3 , Rfmt ) param % Lescape ( 3 ) write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( v1 )) // \" \" // trim ( adjustl ( v2 )) // \" \" // trim ( adjustl ( v3 )) write ( param_name , * ) \"GMESCAPE\" ; write ( param_value , Rfmt ) param % GMescape ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"ECOLLISIONS\" ; write ( param_value , Rfmt ) param % Ecollisions ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"EUNTRACKED\" ; write ( param_value , Rfmt ) param % Euntracked ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) end if write ( param_name , * ) \"FIRSTKICK\" ; write ( param_value , Lfmt ) param % lfirstkick ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"MAXID\" ; write ( param_value , Ifmt ) param % maxid ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) iostat = 0 iomsg = \"UDIO not implemented\" end associate 667 continue return end subroutine io_param_writer module subroutine io_read_in_body ( self , param ) !! author: The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Read in either test particle or massive body data !! !! Adapted from David E. Kaufmann's Swifter routine swiftest_init_pl.f90 and swiftest_init_tp.f90 !! Adapted from Martin Duncan's Swift routine swiftest_init_pl.f and swiftest_init_tp.f implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals integer ( I4B ), parameter :: LUN = 7 !! Unit number of input file integer ( I4B ) :: iu = LUN integer ( I4B ) :: i , nbody logical :: is_ascii , is_pl character ( len = :), allocatable :: infile real ( DP ) :: t character ( STRMAX ) :: errmsg integer ( I4B ) :: ierr ! Select the appropriate polymorphic class (test particle or massive body) select type ( self ) class is ( swiftest_pl ) infile = param % inplfile is_pl = . true . class is ( swiftest_tp ) infile = param % intpfile is_pl = . false . end select is_ascii = ( param % in_type == 'ASCII' ) select case ( param % in_type ) case ( ASCII_TYPE ) open ( unit = iu , file = infile , status = 'old' , form = 'FORMATTED' , err = 667 , iomsg = errmsg ) read ( iu , * , err = 667 , iomsg = errmsg ) nbody case ( REAL4_TYPE , REAL8_TYPE ) open ( unit = iu , file = infile , status = 'old' , form = 'UNFORMATTED' , err = 667 , iomsg = errmsg ) read ( iu , err = 667 , iomsg = errmsg ) nbody case default write ( errmsg , * ) trim ( adjustl ( param % in_type )) // ' is an unrecognized file type' goto 667 end select call self % setup ( nbody , param ) ierr = 0 if ( nbody > 0 ) then ierr = self % read_frame ( iu , param ) self % status (:) = ACTIVE self % lmask (:) = . true . do i = 1 , nbody call self % info ( i )% set_value ( status = \"ACTIVE\" ) end do end if close ( iu , err = 667 , iomsg = errmsg ) if ( ierr == 0 ) return 667 continue write ( * , * ) 'Error reading in initial conditions file: ' , trim ( adjustl ( errmsg )) return end subroutine io_read_in_body module subroutine io_read_in_cb ( self , param ) !! author: David A. Minton !! !! Reads in central body data !! !! Adapted from David E. Kaufmann's Swifter routine swiftest_init_pl.f90 !! Adapted from Martin Duncan's Swift routine swiftest_init_pl.f implicit none ! Arguments class ( swiftest_cb ), intent ( inout ) :: self class ( swiftest_parameters ), intent ( inout ) :: param ! Internals integer ( I4B ), parameter :: LUN = 7 !! Unit number of input file integer ( I4B ) :: iu = LUN character ( len = STRMAX ) :: errmsg integer ( I4B ) :: ierr , idold character ( len = NAMELEN ) :: name if ( param % in_type == 'ASCII' ) then self % id = 0 param % maxid = 0 open ( unit = iu , file = param % incbfile , status = 'old' , form = 'FORMATTED' , err = 667 , iomsg = errmsg ) read ( iu , * , err = 667 , iomsg = errmsg ) name call self % info % set_value ( name = name ) read ( iu , * , err = 667 , iomsg = errmsg ) self % Gmass self % mass = real ( self % Gmass / param % GU , kind = DP ) read ( iu , * , err = 667 , iomsg = errmsg ) self % radius read ( iu , * , err = 667 , iomsg = errmsg ) self % j2rp2 read ( iu , * , err = 667 , iomsg = errmsg ) self % j4rp4 if ( param % lrotation ) then read ( iu , * , err = 667 , iomsg = errmsg ) self % Ip ( 1 ), self % Ip ( 2 ), self % Ip ( 3 ) read ( iu , * , err = 667 , iomsg = errmsg ) self % rot ( 1 ), self % rot ( 2 ), self % rot ( 3 ) end if ierr = 0 else open ( unit = iu , file = param % incbfile , status = 'old' , form = 'UNFORMATTED' , err = 667 , iomsg = errmsg ) ierr = self % read_frame ( iu , param ) end if close ( iu , err = 667 , iomsg = errmsg ) if ( ierr == 0 ) then if ( self % j2rp2 /= 0.0_DP ) param % loblatecb = . true . if ( param % rmin < 0.0 ) param % rmin = self % radius select type ( cb => self ) class is ( symba_cb ) cb % GM0 = cb % Gmass cb % dGM = 0.0_DP cb % R0 = cb % radius cb % L0 (:) = cb % Ip ( 3 ) * cb % mass * cb % radius ** 2 * cb % rot (:) end select end if return 667 continue write ( * , * ) \"Error reading central body file: \" // trim ( adjustl ( errmsg )) call util_exit ( FAILURE ) end subroutine io_read_in_cb function io_read_encounter ( t , id1 , id2 , Gmass1 , Gmass2 , radius1 , radius2 , & xh1 , xh2 , vh1 , vh2 , enc_out , out_type ) result ( ierr ) !! author: David A. Minton !! !! Read close encounter data from input binary files !!     Other than time t, there is no direct file input from this function !!     Function returns read error status (0 = OK, nonzero = ERROR) !! Adapted from David E. Kaufmann's Swifter routine: io_read_encounter.f90 implicit none ! Arguments integer ( I4B ), intent ( out ) :: id1 , id2 real ( DP ), intent ( out ) :: t , Gmass1 , Gmass2 , radius1 , radius2 real ( DP ), dimension (:), intent ( out ) :: xh1 , xh2 , vh1 , vh2 character ( * ), intent ( in ) :: enc_out , out_type ! Result integer ( I4B ) :: ierr ! Internals logical , save :: lfirst = . true . integer ( I4B ), parameter :: lun = 30 integer ( I4B ), save :: iu = lun if ( lfirst ) then open ( unit = iu , file = enc_out , status = 'OLD' , form = 'UNFORMATTED' , iostat = ierr ) if ( ierr /= 0 ) then write ( * , * ) \"Swiftest Error:\" write ( * , * ) \"   unable to open binary encounter file\" call util_exit ( FAILURE ) end if lfirst = . false . end if read ( iu , iostat = ierr ) t if ( ierr /= 0 ) then close ( unit = iu , iostat = ierr ) return end if read ( iu , iostat = ierr ) id1 , xh1 ( 1 ), xh1 ( 2 ), xh1 ( 3 ), vh1 ( 1 ), vh1 ( 2 ), vh1 ( 3 ), Gmass1 , radius1 if ( ierr /= 0 ) then close ( unit = iu , iostat = ierr ) return end if read ( iu , iostat = ierr ) id2 , xh2 ( 2 ), xh2 ( 2 ), xh2 ( 3 ), vh2 ( 2 ), vh2 ( 2 ), vh2 ( 3 ), Gmass2 , radius2 if ( ierr /= 0 ) then close ( unit = iu , iostat = ierr ) return end if return end function io_read_encounter module function io_read_frame_body ( self , iu , param ) result ( ierr ) !! author: David A. Minton !! !! Reads a frame of output of either test particle or massive body data from a binary output file !! !! Adapted from David E. Kaufmann's Swifter routine  io_read_frame.f90 !! Adapted from Hal Levison's Swift routine io_read_frame.F implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest particle object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Result integer ( I4B ) :: ierr !! Error code: returns 0 if the read is successful ! Internals character ( len = STRMAX ) :: errmsg character ( len = NAMELEN ), dimension ( self % nbody ) :: name integer ( I4B ) :: i real ( QP ) :: val if ( self % nbody == 0 ) return if (( param % in_form /= EL ) . and . ( param % in_form /= XV )) then write ( errmsg , * ) trim ( adjustl ( param % in_form )) // \" is not a recognized format code for input files.\" goto 667 end if associate ( n => self % nbody ) if ( param % in_form == EL ) then if (. not . allocated ( self % a )) allocate ( self % a ( n )) if (. not . allocated ( self % e )) allocate ( self % e ( n )) if (. not . allocated ( self % inc )) allocate ( self % inc ( n )) if (. not . allocated ( self % capom )) allocate ( self % capom ( n )) if (. not . allocated ( self % omega )) allocate ( self % omega ( n )) if (. not . allocated ( self % capm )) allocate ( self % capm ( n )) end if select case ( param % in_type ) case ( REAL4_TYPE , REAL8_TYPE ) read ( iu , err = 667 , iomsg = errmsg ) self % id (:) read ( iu , err = 667 , iomsg = errmsg ) name (:) do i = 1 , n call self % info ( i )% set_value ( name = name ( i )) end do select case ( param % in_form ) case ( XV ) read ( iu , err = 667 , iomsg = errmsg ) self % xh ( 1 , :) read ( iu , err = 667 , iomsg = errmsg ) self % xh ( 2 , :) read ( iu , err = 667 , iomsg = errmsg ) self % xh ( 3 , :) read ( iu , err = 667 , iomsg = errmsg ) self % vh ( 1 , :) read ( iu , err = 667 , iomsg = errmsg ) self % vh ( 2 , :) read ( iu , err = 667 , iomsg = errmsg ) self % vh ( 3 , :) case ( EL ) read ( iu , err = 667 , iomsg = errmsg ) self % a (:) read ( iu , err = 667 , iomsg = errmsg ) self % e (:) read ( iu , err = 667 , iomsg = errmsg ) self % inc (:) read ( iu , err = 667 , iomsg = errmsg ) self % capom (:) read ( iu , err = 667 , iomsg = errmsg ) self % omega (:) read ( iu , err = 667 , iomsg = errmsg ) self % capm (:) end select select type ( pl => self ) class is ( swiftest_pl ) ! Additional output if the passed polymorphic object is a massive body read ( iu , err = 667 , iomsg = errmsg ) pl % Gmass (:) pl % mass (:) = pl % Gmass (:) / param % GU if ( param % lrhill_present ) read ( iu , err = 667 , iomsg = errmsg ) pl % rhill (:) read ( iu , err = 667 , iomsg = errmsg ) pl % radius (:) if ( param % lrotation ) then read ( iu , err = 667 , iomsg = errmsg ) pl % Ip ( 1 , :) read ( iu , err = 667 , iomsg = errmsg ) pl % Ip ( 2 , :) read ( iu , err = 667 , iomsg = errmsg ) pl % Ip ( 3 , :) read ( iu , err = 667 , iomsg = errmsg ) pl % rot ( 1 , :) read ( iu , err = 667 , iomsg = errmsg ) pl % rot ( 2 , :) read ( iu , err = 667 , iomsg = errmsg ) pl % rot ( 3 , :) end if if ( param % ltides ) then read ( iu , err = 667 , iomsg = errmsg ) pl % k2 (:) read ( iu , err = 667 , iomsg = errmsg ) pl % Q (:) end if end select param % maxid = max ( param % maxid , maxval ( self % id ( 1 : n ))) case ( ASCII_TYPE ) do i = 1 , n select type ( self ) class is ( swiftest_pl ) if ( param % lrhill_present ) then read ( iu , * , err = 667 , iomsg = errmsg ) name ( i ), val , self % rhill ( i ) else read ( iu , * , err = 667 , iomsg = errmsg ) name ( i ), val end if self % Gmass ( i ) = real ( val , kind = DP ) self % mass ( i ) = real ( val / param % GU , kind = DP ) read ( iu , * , err = 667 , iomsg = errmsg ) self % radius ( i ) class is ( swiftest_tp ) read ( iu , * , err = 667 , iomsg = errmsg ) name ( i ) end select call self % info ( i )% set_value ( name = name ( i )) select case ( param % in_form ) case ( XV ) read ( iu , * , err = 667 , iomsg = errmsg ) self % xh ( 1 , i ), self % xh ( 2 , i ), self % xh ( 3 , i ) read ( iu , * , err = 667 , iomsg = errmsg ) self % vh ( 1 , i ), self % vh ( 2 , i ), self % vh ( 3 , i ) case ( EL ) read ( iu , * , err = 667 , iomsg = errmsg ) self % a ( i ), self % e ( i ), self % inc ( i ) read ( iu , * , err = 667 , iomsg = errmsg ) self % capom ( i ), self % omega ( i ), self % capm ( i ) end select select type ( self ) class is ( swiftest_pl ) if ( param % lrotation ) then read ( iu , * , err = 667 , iomsg = errmsg ) self % Ip ( 1 , i ), self % Ip ( 2 , i ), self % Ip ( 3 , i ) read ( iu , * , err = 667 , iomsg = errmsg ) self % rot ( 1 , i ), self % rot ( 2 , i ), self % rot ( 3 , i ) end if if ( param % ltides ) then read ( iu , * , err = 667 , iomsg = errmsg ) self % k2 ( i ) read ( iu , * , err = 667 , iomsg = errmsg ) self % Q ( i ) end if end select param % maxid = param % maxid + 1 self % id ( i ) = param % maxid end do end select if ( param % in_form == EL ) then self % inc ( 1 : n ) = self % inc ( 1 : n ) * DEG2RAD self % capom ( 1 : n ) = self % capom ( 1 : n ) * DEG2RAD self % omega ( 1 : n ) = self % omega ( 1 : n ) * DEG2RAD self % capm ( 1 : n ) = self % capm ( 1 : n ) * DEG2RAD end if end associate ierr = 0 return 667 continue select type ( self ) class is ( swiftest_pl ) write ( * , * ) \"Error reading massive body file: \" // trim ( adjustl ( errmsg )) class is ( swiftest_tp ) write ( * , * ) \"Error reading test particle file: \" // trim ( adjustl ( errmsg )) class default write ( * , * ) \"Error reading body file: \" // trim ( adjustl ( errmsg )) end select call util_exit ( FAILURE ) end function io_read_frame_body module function io_read_frame_cb ( self , iu , param ) result ( ierr ) !! author: David A. Minton !! !! Reads a frame of output of central body data to the binary output file !! !! Adapted from David E. Kaufmann's Swifter routine  io_read_frame.f90 !! Adapted from Hal Levison's Swift routine io_read_frame.F implicit none ! Arguments class ( swiftest_cb ), intent ( inout ) :: self !! Swiftest central body object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Result integer ( I4B ) :: ierr !! Error code: returns 0 if the read is successful ! Internals character ( len = STRMAX ) :: errmsg character ( len = NAMELEN ) :: name read ( iu , err = 667 , iomsg = errmsg ) self % id read ( iu , err = 667 , iomsg = errmsg ) name call self % info % set_value ( name = name ) read ( iu , err = 667 , iomsg = errmsg ) self % Gmass self % mass = self % Gmass / param % GU read ( iu , err = 667 , iomsg = errmsg ) self % radius read ( iu , err = 667 , iomsg = errmsg ) self % j2rp2 read ( iu , err = 667 , iomsg = errmsg ) self % j4rp4 if ( param % lrotation ) then read ( iu , err = 667 , iomsg = errmsg ) self % Ip ( 1 ) read ( iu , err = 667 , iomsg = errmsg ) self % Ip ( 2 ) read ( iu , err = 667 , iomsg = errmsg ) self % Ip ( 3 ) read ( iu , err = 667 , iomsg = errmsg ) self % rot ( 1 ) read ( iu , err = 667 , iomsg = errmsg ) self % rot ( 2 ) read ( iu , err = 667 , iomsg = errmsg ) self % rot ( 3 ) end if if ( param % ltides ) then read ( iu , err = 667 , iomsg = errmsg ) self % k2 read ( iu , err = 667 , iomsg = errmsg ) self % Q end if ierr = 0 return 667 continue write ( * , * ) \"Error reading central body file: \" // trim ( adjustl ( errmsg )) call util_exit ( FAILURE ) end function io_read_frame_cb module function io_read_frame_system ( self , iu , param ) result ( ierr ) !! author: The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Read a frame (header plus records for each massive body and active test particle) from a output binary file implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Result integer ( I4B ) :: ierr !! Error code: returns 0 if the read is successful ! Internals character ( len = STRMAX ) :: errmsg integer ( I4B ) :: npl , ntp ierr = io_read_hdr ( iu , param % t , npl , ntp , param % out_form , param % out_type ) if ( is_iostat_end ( ierr )) return ! Reached the end of the frames call self % pl % setup ( npl , param ) call self % tp % setup ( ntp , param ) if ( ierr /= 0 ) then write ( errmsg , * ) \"Cannot read frame header.\" goto 667 end if ierr = self % cb % read_frame ( iu , param ) if ( ierr /= 0 ) then write ( errmsg , * ) \"Cannot read central body frame.\" goto 667 end if ierr = self % pl % read_frame ( iu , param ) if ( ierr /= 0 ) then write ( errmsg , * ) \"Cannot read massive body frame.\" goto 667 end if ierr = self % tp % read_frame ( iu , param ) if ( ierr /= 0 ) then write ( errmsg , * ) \"Cannot read test particle frame.\" goto 667 end if return 667 continue write ( * , * ) \"Error reading system frame: \" // trim ( adjustl ( errmsg )) end function io_read_frame_system function io_read_hdr ( iu , t , npl , ntp , out_form , out_type ) result ( ierr ) !! author: David A. Minton !! !! Read frame header from input binary files !!     Function returns read error status (0 = OK, nonzero = ERROR) !! Adapted from David E. Kaufmann's Swifter routine: io_read_hdr.f90 !! Adapted from Hal Levison's Swift routine io_read_hdr.f implicit none ! Arguments integer ( I4B ), intent ( in ) :: iu integer ( I4B ), intent ( out ) :: npl , ntp character ( * ), intent ( out ) :: out_form real ( DP ), intent ( out ) :: t character ( * ), intent ( in ) :: out_type ! Result integer ( I4B ) :: ierr ! Internals real ( SP ) :: ttmp character ( len = STRMAX ) :: errmsg select case ( out_type ) case ( REAL4_TYPE ) read ( iu , iostat = ierr , err = 667 , iomsg = errmsg , end = 333 ) ttmp t = ttmp case ( REAL8_TYPE ) read ( iu , iostat = ierr , err = 667 , iomsg = errmsg , end = 333 ) t case default write ( errmsg , * ) trim ( adjustl ( out_type )) // ' is an unrecognized file type' ierr = - 1 end select read ( iu , iostat = ierr , err = 667 , iomsg = errmsg ) npl read ( iu , iostat = ierr , err = 667 , iomsg = errmsg ) ntp read ( iu , iostat = ierr , err = 667 , iomsg = errmsg ) out_form return 667 continue write ( * , * ) \"Error reading header: \" // trim ( adjustl ( errmsg )) 333 continue return return end function io_read_hdr module subroutine io_read_in_param ( self , param_file_name ) !! author: David A. Minton !! !! Read in parameters for the integration !! !! Adapted from David E. Kaufmann's Swifter routine io_init_param.f90 !! Adapted from Martin Duncan's Swift routine io_init_param.f implicit none ! Arguments class ( swiftest_parameters ), intent ( inout ) :: self !! Current run configuration parameters character ( len =* ), intent ( in ) :: param_file_name !! Parameter input file name (i.e. param.in) ! Internals integer ( I4B ), parameter :: LUN = 7 !! Unit number of input file integer ( I4B ) :: ierr = 0 !! Input error code character ( STRMAX ) :: errmsg !! Error message in UDIO procedure ! Read in name of parameter file write ( * , * ) 'Parameter input file is ' , trim ( adjustl ( param_file_name )) write ( * , * ) ' ' 100 format ( A ) open ( unit = LUN , file = param_file_name , status = 'old' , iostat = ierr , err = 667 , iomsg = errmsg ) !! todo: Currently this procedure does not work in user-defined derived-type input mode !!    as the newline characters are ignored in the input file when compiled in ifort. !read(LUN,'(DT)', iostat= ierr, iomsg = errmsg) param call self % reader ( LUN , iotype = \"none\" , v_list = [ self % integrator ], iostat = ierr , iomsg = errmsg ) if ( ierr == 0 ) return 667 continue write ( * , * ) \"Error reading parameter file: \" // trim ( adjustl ( errmsg )) call util_exit ( FAILURE ) end subroutine io_read_in_param module subroutine io_read_in_particle_info ( self , iu ) !! author: David A. Minton !! !! Reads in particle information object information from an open file unformatted file implicit none ! Arguments class ( swiftest_particle_info ), intent ( inout ) :: self !! Particle metadata information object integer ( I4B ), intent ( in ) :: iu !! Open file unit number ! Internals character ( STRMAX ) :: errmsg read ( iu , err = 667 , iomsg = errmsg ) self % name read ( iu , err = 667 , iomsg = errmsg ) self % particle_type read ( iu , err = 667 , iomsg = errmsg ) self % origin_type read ( iu , err = 667 , iomsg = errmsg ) self % origin_time read ( iu , err = 667 , iomsg = errmsg ) self % origin_xh (:) read ( iu , err = 667 , iomsg = errmsg ) self % origin_vh (:) return 667 continue write ( * , * ) \"Error reading particle metadata information from file: \" // trim ( adjustl ( errmsg )) call util_exit ( FAILURE ) end subroutine io_read_in_particle_info module subroutine io_read_particle_info_system ( self , param ) !! author: David A. Minton !! !! Reads an old particle information file for a restartd run implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals integer ( I4B ), parameter :: LUN = 22 integer ( I4B ) :: i , id , idx logical :: lmatch character ( STRMAX ) :: errmsg type ( swiftest_particle_info ), allocatable :: tmpinfo open ( unit = LUN , file = param % particle_out , status = 'OLD' , form = 'UNFORMATTED' , err = 667 , iomsg = errmsg ) allocate ( tmpinfo , mold = self % cb % info ) select type ( cb => self % cb ) class is ( swiftest_cb ) select type ( pl => self % pl ) class is ( swiftest_pl ) select type ( tp => self % tp ) class is ( swiftest_tp ) associate ( npl => pl % nbody , ntp => tp % nbody ) do lmatch = . false . read ( LUN , err = 667 , iomsg = errmsg , end = 333 ) id if ( id == cb % id ) then call cb % info % read_in ( LUN ) lmatch = . true . else if ( npl > 0 ) then idx = findloc ( pl % id ( 1 : npl ), id , dim = 1 ) if ( idx /= 0 ) then call pl % info ( idx )% read_in ( LUN ) lmatch = . true . end if end if if (. not . lmatch . and . ntp > 0 ) then idx = findloc ( tp % id ( 1 : ntp ), id , dim = 1 ) if ( idx /= 0 ) then call tp % info ( idx )% read_in ( LUN ) lmatch = . true . end if end if end if if (. not . lmatch ) then call tmpinfo % read_in ( LUN ) end if end do end associate close ( unit = LUN , err = 667 , iomsg = errmsg ) end select end select end select 333 continue return 667 continue write ( * , * ) \"Error reading particle information file: \" // trim ( adjustl ( errmsg )) call util_exit ( FAILURE ) end subroutine io_read_particle_info_system module subroutine io_toupper ( string ) !! author: David A. Minton !! !! Convert string to uppercase !! !! Adapted from David E. Kaufmann's Swifter routine: util_toupper.f90 implicit none ! Arguments character ( * ), intent ( inout ) :: string !! String to make upper case ! Internals integer ( I4B ) :: i , length , idx length = len ( string ) do i = 1 , length idx = iachar ( string ( i : i )) if (( idx >= lowercase_begin ) . and . ( idx <= lowercase_end )) then idx = idx + uppercase_offset string ( i : i ) = achar ( idx ) end if end do return end subroutine io_toupper module subroutine io_write_discard ( self , param ) !! author: David A. Minton !! !! Write out information about discarded test particle !! !! Adapted from David E. Kaufmann's Swifter routine  io_discard_write.f90 !! Adapted from Hal Levison's Swift routine io_discard_write.f implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals integer ( I4B ), parameter :: LUN = 40 integer ( I4B ) :: i logical , save :: lfirst = . true . real ( DP ), dimension (:,:), allocatable :: vh character ( * ), parameter :: HDRFMT = '(E23.16, 1X, I8, 1X, L1)' character ( * ), parameter :: NAMEFMT = '(A, 2(1X, I8))' character ( * ), parameter :: VECFMT = '(3(E23.16, 1X))' character ( * ), parameter :: NPLFMT = '(I8)' character ( * ), parameter :: PLNAMEFMT = '(I8, 2(1X, E23.16))' class ( swiftest_body ), allocatable :: pltemp character ( len = STRMAX ) :: errmsg , out_stat associate ( tp_discards => self % tp_discards , nsp => self % tp_discards % nbody , pl => self % pl , npl => self % pl % nbody ) ! Record the discarded body metadata information to file if (( param % out_type == NETCDF_FLOAT_TYPE ) . or . ( param % out_type == NETCDF_DOUBLE_TYPE )) then call param % nciu % open ( param ) call tp_discards % write_particle_info ( param % nciu ) call param % nciu % close ( param ) end if if ( param % discard_out == \"\" ) return if ( nsp == 0 ) return if ( lfirst ) then out_stat = param % out_stat else out_stat = 'APPEND' end if select case ( out_stat ) case ( 'APPEND' ) open ( unit = LUN , file = param % discard_out , status = 'OLD' , position = 'APPEND' , form = 'FORMATTED' , err = 667 , iomsg = errmsg ) case ( 'NEW' , 'REPLACE' , 'UNKNOWN' ) open ( unit = LUN , file = param % discard_out , status = param % out_stat , form = 'FORMATTED' , err = 667 , iomsg = errmsg ) case default write ( * , * ) 'Invalid status code for OUT_STAT: ' , trim ( adjustl ( param % out_stat )) call util_exit ( FAILURE ) end select lfirst = . false . if ( param % lgr ) call tp_discards % pv2v ( param ) write ( LUN , HDRFMT ) param % t , nsp , param % lbig_discard do i = 1 , nsp write ( LUN , NAMEFMT , err = 667 , iomsg = errmsg ) SUB , tp_discards % id ( i ), tp_discards % status ( i ) write ( LUN , VECFMT , err = 667 , iomsg = errmsg ) tp_discards % xh ( 1 , i ), tp_discards % xh ( 2 , i ), tp_discards % xh ( 3 , i ) write ( LUN , VECFMT , err = 667 , iomsg = errmsg ) tp_discards % vh ( 1 , i ), tp_discards % vh ( 2 , i ), tp_discards % vh ( 3 , i ) end do if ( param % lbig_discard ) then if ( param % lgr ) then allocate ( pltemp , source = pl ) call pltemp % pv2v ( param ) allocate ( vh , source = pltemp % vh ) deallocate ( pltemp ) else allocate ( vh , source = pl % vh ) end if write ( LUN , NPLFMT ) npl do i = 1 , npl write ( LUN , PLNAMEFMT , err = 667 , iomsg = errmsg ) pl % id ( i ), pl % Gmass ( i ), pl % radius ( i ) write ( LUN , VECFMT , err = 667 , iomsg = errmsg ) pl % xh ( 1 , i ), pl % xh ( 2 , i ), pl % xh ( 3 , i ) write ( LUN , VECFMT , err = 667 , iomsg = errmsg ) vh ( 1 , i ), vh ( 2 , i ), vh ( 3 , i ) end do deallocate ( vh ) end if close ( LUN ) end associate return 667 continue write ( * , * ) \"Error writing discard file: \" // trim ( adjustl ( errmsg )) call util_exit ( FAILURE ) end subroutine io_write_discard module subroutine io_write_encounter ( self , pl , encbody , param ) implicit none ! Arguments class ( swiftest_encounter ), intent ( in ) :: self !! Swiftest encounter list object class ( swiftest_pl ), intent ( in ) :: pl !! Swiftest massive body object class ( swiftest_body ), intent ( in ) :: encbody !! Encountering body - Swiftest generic body object (pl or tp) class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals logical , save :: lfirst = . true . integer ( I4B ), parameter :: LUN = 30 integer ( I4B ) :: k , ierr character ( len = STRMAX ) :: errmsg if ( param % enc_out == \"\" . or . self % nenc == 0 ) return open ( unit = LUN , file = param % enc_out , status = 'OLD' , position = 'APPEND' , form = 'UNFORMATTED' , iostat = ierr , iomsg = errmsg ) if ( ierr /= 0 ) then if ( lfirst ) then open ( unit = LUN , file = param % enc_out , status = 'NEW' , form = 'UNFORMATTED' , err = 667 , iomsg = errmsg ) else goto 667 end if end if lfirst = . false . associate ( ind1 => self % index1 , ind2 => self % index2 ) select type ( encbody ) class is ( swiftest_pl ) do k = 1 , self % nenc call io_write_frame_encounter ( LUN , self % t ( k ), & pl % id ( ind1 ( k )), encbody % id ( ind2 ( k )), & pl % Gmass ( ind1 ( k )), encbody % Gmass ( ind2 ( k )), & pl % radius ( ind1 ( k )), encbody % radius ( ind2 ( k )), & self % x1 (:, k ), self % x2 (:, k ), & self % v1 (:, k ), self % v2 (:, k )) end do class is ( swiftest_tp ) do k = 1 , self % nenc call io_write_frame_encounter ( LUN , self % t ( k ), & pl % id ( ind1 ( k )), encbody % id ( ind2 ( k )), & pl % Gmass ( ind1 ( k )), 0.0_DP , & pl % radius ( ind1 ( k )), 0.0_DP , & self % x1 (:, k ), self % x2 (:, k ), & self % v1 (:, k ), self % v2 (:, k )) end do end select end associate close ( unit = LUN , err = 667 , iomsg = errmsg ) return 667 continue write ( * , * ) \"Error writing encounter file: \" // trim ( adjustl ( errmsg )) call util_exit ( FAILURE ) end subroutine io_write_encounter module subroutine io_write_frame_body ( self , iu , param ) !! author: David A. Minton !! !! Write a frame of output of either test particle or massive body data to the binary output file !!    Note: If outputting to orbital elements, but sure that the conversion is done prior to calling this method !! !! Adapted from David E. Kaufmann's Swifter routine  io_write_frame.f90 !! Adapted from Hal Levison's Swift routine io_write_frame.F implicit none ! Arguments class ( swiftest_body ), intent ( in ) :: self !! Swiftest particle object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals character ( len = STRMAX ) :: errmsg associate ( n => self % nbody ) if ( n == 0 ) return write ( iu , err = 667 , iomsg = errmsg ) self % id ( 1 : n ) write ( iu , err = 667 , iomsg = errmsg ) self % info ( 1 : n )% name if (( param % out_form == XV ) . or . ( param % out_form == XVEL )) then write ( iu , err = 667 , iomsg = errmsg ) self % xh ( 1 , 1 : n ) write ( iu , err = 667 , iomsg = errmsg ) self % xh ( 2 , 1 : n ) write ( iu , err = 667 , iomsg = errmsg ) self % xh ( 3 , 1 : n ) write ( iu , err = 667 , iomsg = errmsg ) self % vh ( 1 , 1 : n ) write ( iu , err = 667 , iomsg = errmsg ) self % vh ( 2 , 1 : n ) write ( iu , err = 667 , iomsg = errmsg ) self % vh ( 3 , 1 : n ) end if if (( param % out_form == EL ) . or . ( param % out_form == XVEL )) then write ( iu , err = 667 , iomsg = errmsg ) self % a ( 1 : n ) write ( iu , err = 667 , iomsg = errmsg ) self % e ( 1 : n ) write ( iu , err = 667 , iomsg = errmsg ) self % inc ( 1 : n ) * RAD2DEG write ( iu , err = 667 , iomsg = errmsg ) self % capom ( 1 : n ) * RAD2DEG write ( iu , err = 667 , iomsg = errmsg ) self % omega ( 1 : n ) * RAD2DEG write ( iu , err = 667 , iomsg = errmsg ) self % capm ( 1 : n ) * RAD2DEG end if select type ( pl => self ) class is ( swiftest_pl ) ! Additional output if the passed polymorphic object is a massive body write ( iu , err = 667 , iomsg = errmsg ) pl % Gmass ( 1 : n ) if ( param % lrhill_present ) write ( iu , err = 667 , iomsg = errmsg ) pl % rhill ( 1 : n ) write ( iu , err = 667 , iomsg = errmsg ) pl % radius ( 1 : n ) if ( param % lrotation ) then write ( iu , err = 667 , iomsg = errmsg ) pl % Ip ( 1 , 1 : n ) write ( iu , err = 667 , iomsg = errmsg ) pl % Ip ( 2 , 1 : n ) write ( iu , err = 667 , iomsg = errmsg ) pl % Ip ( 3 , 1 : n ) write ( iu , err = 667 , iomsg = errmsg ) pl % rot ( 1 , 1 : n ) write ( iu , err = 667 , iomsg = errmsg ) pl % rot ( 2 , 1 : n ) write ( iu , err = 667 , iomsg = errmsg ) pl % rot ( 3 , 1 : n ) end if if ( param % ltides ) then write ( iu , err = 667 , iomsg = errmsg ) pl % k2 ( 1 : n ) write ( iu , err = 667 , iomsg = errmsg ) pl % Q ( 1 : n ) end if end select end associate return 667 continue write ( * , * ) \"Error writing body frame: \" // trim ( adjustl ( errmsg )) call util_exit ( FAILURE ) end subroutine io_write_frame_body module subroutine io_write_frame_cb ( self , iu , param ) !! author: David A. Minton !! !! Write a frame of output of central body data to the binary output file !! !! Adapted from David E. Kaufmann's Swifter routine  io_write_frame.f90 !! Adapted from Hal Levison's Swift routine io_write_frame.F implicit none ! Arguments class ( swiftest_cb ), intent ( in ) :: self !! Swiftest central body object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals character ( len = STRMAX ) :: errmsg associate ( cb => self ) write ( iu , err = 667 , iomsg = errmsg ) cb % id write ( iu , err = 667 , iomsg = errmsg ) cb % info % name write ( iu , err = 667 , iomsg = errmsg ) cb % Gmass write ( iu , err = 667 , iomsg = errmsg ) cb % radius write ( iu , err = 667 , iomsg = errmsg ) cb % j2rp2 write ( iu , err = 667 , iomsg = errmsg ) cb % j4rp4 if ( param % lrotation ) then write ( iu , err = 667 , iomsg = errmsg ) cb % Ip ( 1 ) write ( iu , err = 667 , iomsg = errmsg ) cb % Ip ( 2 ) write ( iu , err = 667 , iomsg = errmsg ) cb % Ip ( 3 ) write ( iu , err = 667 , iomsg = errmsg ) cb % rot ( 1 ) write ( iu , err = 667 , iomsg = errmsg ) cb % rot ( 2 ) write ( iu , err = 667 , iomsg = errmsg ) cb % rot ( 3 ) end if if ( param % ltides ) then write ( iu , err = 667 , iomsg = errmsg ) cb % k2 write ( iu , err = 667 , iomsg = errmsg ) cb % Q end if end associate return 667 continue write ( * , * ) \"Error writing central body frame: \" // trim ( adjustl ( errmsg )) call util_exit ( FAILURE ) end subroutine io_write_frame_cb module subroutine io_write_frame_encounter ( iu , t , id1 , id2 , Gmass1 , Gmass2 , radius1 , radius2 , xh1 , xh2 , vh1 , vh2 ) !! author: David A. Minton !! !! Write a single frame of close encounter data to output binary files !! !! Adapted from David E. Kaufmann's Swifter routine: io_write_encounter.f90 !! Adapted from Hal Levison's Swift routine io_write_encounter.f implicit none ! Arguments integer ( I4B ), intent ( in ) :: iu !! Open file unit number real ( DP ), intent ( in ) :: t !! Time of encounter integer ( I4B ), intent ( in ) :: id1 , id2 !! ids of the two encountering bodies real ( DP ), intent ( in ) :: Gmass1 , Gmass2 !! G*mass of the two encountering bodies real ( DP ), intent ( in ) :: radius1 , radius2 !! Radii of the two encountering bodies real ( DP ), dimension (:), intent ( in ) :: xh1 , xh2 !! Heliocentric position vectors of the two encountering bodies real ( DP ), dimension (:), intent ( in ) :: vh1 , vh2 !! Heliocentric velocity vectors of the two encountering bodies ! Internals character ( len = STRMAX ) :: errmsg write ( iu , err = 667 , iomsg = errmsg ) t write ( iu , err = 667 , iomsg = errmsg ) id1 , xh1 ( 1 ), xh1 ( 2 ), xh1 ( 3 ), vh1 ( 1 ), vh1 ( 2 ), Gmass1 , radius1 write ( iu , err = 667 , iomsg = errmsg ) id2 , xh2 ( 1 ), xh2 ( 2 ), xh2 ( 3 ), vh2 ( 1 ), vh2 ( 2 ), Gmass2 , radius2 return 667 continue write ( * , * ) \"Error writing encounter file: \" // trim ( adjustl ( errmsg )) call util_exit ( FAILURE ) end subroutine module subroutine io_write_frame_system ( self , param ) !! author: The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Write a frame (header plus records for each massive body and active test particle) to output binary file !! There is no direct file output from this subroutine !! !! Adapted from David E. Kaufmann's Swifter routine  io_write_frame.f90 !! Adapted from Hal Levison's Swift routine io_write_frame.F implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals logical , save :: lfirst = . true . !! Flag to determine if this is the first call of this method class ( swiftest_cb ), allocatable :: cb !! Temporary local version of pl structure used for non-destructive conversions class ( swiftest_pl ), allocatable :: pl !! Temporary local version of pl structure used for non-destructive conversions class ( swiftest_tp ), allocatable :: tp !! Temporary local version of pl structure used for non-destructive conversions character ( len = STRMAX ) :: errmsg integer ( I4B ) :: iu = BINUNIT !! Unit number for the output file to write frame to logical :: fileExists if (. not . lfirst . and . param % lenergy ) call self % conservation_report ( param , lterminal = . true .) allocate ( cb , source = self % cb ) allocate ( pl , source = self % pl ) allocate ( tp , source = self % tp ) iu = BINUNIT if (( param % out_type == REAL4_TYPE ) . or . ( param % out_type == REAL8_TYPE )) then if ( lfirst ) then select case ( param % out_stat ) case ( 'APPEND' ) open ( unit = iu , file = param % outfile , status = 'OLD' , position = 'APPEND' , form = 'UNFORMATTED' , err = 667 , iomsg = errmsg ) case ( 'NEW' , 'REPLACE' , 'UNKNOWN' ) open ( unit = iu , file = param % outfile , status = param % out_stat , form = 'UNFORMATTED' , err = 667 , iomsg = errmsg ) case default write ( * , * ) 'Invalid status code for OUT_STAT: ' , trim ( adjustl ( param % out_stat )) call util_exit ( FAILURE ) end select lfirst = . false . else open ( unit = iu , file = param % outfile , status = 'OLD' , position = 'APPEND' , form = 'UNFORMATTED' , err = 667 , iomsg = errmsg ) end if else if (( param % out_type == NETCDF_FLOAT_TYPE ) . or . ( param % out_type == NETCDF_DOUBLE_TYPE )) then if ( lfirst ) then inquire ( file = param % outfile , exist = fileExists ) select case ( param % out_stat ) case ( 'APPEND' ) if (. not . fileExists ) then errmsg = param % outfile // \" not found! You must specify OUT_STAT = NEW, REPLACE, or UNKNOWN\" goto 667 end if case ( 'NEW' ) if ( fileExists ) then errmsg = param % outfile // \" Alread Exists! You must specify OUT_STAT = OLD, REPLACE, or UNKNOWN\" goto 667 end if case ( 'REPLACE' , 'UNKNOWN' ) if ( fileExists ) then open ( file = param % outfile , unit = iu , status = 'OLD' ) close ( unit = BINUNIT , status = \"delete\" ) end if end select select case ( param % out_stat ) case ( 'APPEND' ) call param % nciu % open ( param ) case ( 'NEW' , 'REPLACE' , 'UNKNOWN' ) call param % nciu % initialize ( param ) call param % nciu % close ( param ) call param % nciu % open ( param ) end select lfirst = . false . else call param % nciu % open ( param ) end if end if if ( param % lgr ) then call pl % pv2v ( param ) call tp % pv2v ( param ) end if if (( param % out_form == EL ) . or . ( param % out_form == XVEL )) then ! Do an orbital element conversion prior to writing out the frame, as we have access to the central body here call pl % xv2el ( cb ) call tp % xv2el ( cb ) end if ! Write out each data type frame if (( param % out_type == REAL4_TYPE ) . or . ( param % out_type == REAL8_TYPE )) then call self % write_hdr ( iu , param ) call cb % write_frame ( iu , param ) call pl % write_frame ( iu , param ) call tp % write_frame ( iu , param ) close ( iu , err = 667 , iomsg = errmsg ) else if (( param % out_type == NETCDF_FLOAT_TYPE ) . or . ( param % out_type == NETCDF_DOUBLE_TYPE )) then call self % write_hdr ( param % nciu , param ) call cb % write_frame ( param % nciu , param ) call pl % write_frame ( param % nciu , param ) call tp % write_frame ( param % nciu , param ) call param % nciu % close ( param ) end if return 667 continue write ( * , * ) \"Error writing system frame: \" // trim ( adjustl ( errmsg )) call util_exit ( FAILURE ) end subroutine io_write_frame_system module subroutine io_write_hdr_system ( self , iu , param ) ! t, npl, ntp, out_form, out_type) !! author: The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Write frame header to output binary file !! !! Adapted from David Adapted from David E. Kaufmann's Swifter routine io_write_hdr.f90 !! Adapted from Hal Levison's Swift routine io_write_hdr.F implicit none ! Arguments class ( swiftest_nbody_system ), intent ( in ) :: self !! Swiftest nbody system object integer ( I4B ), intent ( inout ) :: iu !! Output file unit number class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals character ( len = STRMAX ) :: errmsg select case ( param % out_type ) case ( REAL4_TYPE ) write ( iu , err = 667 , iomsg = errmsg ) real ( param % t , kind = SP ) case ( REAL8_TYPE ) write ( iu , err = 667 , iomsg = errmsg ) param % t end select write ( iu , err = 667 , iomsg = errmsg ) self % pl % nbody write ( iu , err = 667 , iomsg = errmsg ) self % tp % nbody write ( iu , err = 667 , iomsg = errmsg ) param % out_form return 667 continue write ( * , * ) \"Error writing header: \" // trim ( adjustl ( errmsg )) call util_exit ( FAILURE ) end subroutine io_write_hdr_system end submodule s_io","tags":"","loc":"sourcefile/io.f90.html"},{"title":"setup.f90 – swiftest","text":"This file depends on sourcefile~~setup.f90~~EfferentGraph sourcefile~setup.f90 setup.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~setup.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_setup Source Code setup.f90 Source Code submodule ( swiftest_classes ) s_setup use swiftest contains module subroutine setup_construct_system ( system , param ) !! author: David A. Minton !! !! Constructor for a Swiftest nbody system. Creates the nbody system object based on the user-input integrator !! implicit none ! Arguments class ( swiftest_nbody_system ), allocatable , intent ( inout ) :: system !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Swiftest parameters select case ( param % integrator ) case ( BS ) write ( * , * ) 'Bulirsch-Stoer integrator not yet enabled' case ( HELIO ) allocate ( helio_nbody_system :: system ) select type ( system ) class is ( helio_nbody_system ) allocate ( helio_cb :: system % cb ) allocate ( helio_pl :: system % pl ) allocate ( helio_tp :: system % tp ) allocate ( helio_tp :: system % tp_discards ) end select case ( RA15 ) write ( * , * ) 'Radau integrator not yet enabled' case ( TU4 ) write ( * , * ) 'TU4 integrator not yet enabled' case ( WHM ) allocate ( whm_nbody_system :: system ) select type ( system ) class is ( whm_nbody_system ) allocate ( whm_cb :: system % cb ) allocate ( whm_pl :: system % pl ) allocate ( whm_tp :: system % tp ) allocate ( whm_tp :: system % tp_discards ) end select case ( RMVS ) allocate ( rmvs_nbody_system :: system ) select type ( system ) class is ( rmvs_nbody_system ) allocate ( rmvs_cb :: system % cb ) allocate ( rmvs_pl :: system % pl ) allocate ( rmvs_tp :: system % tp ) allocate ( rmvs_tp :: system % tp_discards ) end select case ( SYMBA ) allocate ( symba_nbody_system :: system ) select type ( system ) class is ( symba_nbody_system ) allocate ( symba_cb :: system % cb ) allocate ( symba_pl :: system % pl ) allocate ( symba_tp :: system % tp ) allocate ( symba_tp :: system % tp_discards ) allocate ( symba_merger :: system % pl_adds ) allocate ( symba_merger :: system % pl_discards ) allocate ( symba_pltpenc :: system % pltpenc_list ) allocate ( symba_plplenc :: system % plplenc_list ) allocate ( symba_plplenc :: system % plplcollision_list ) end select case ( RINGMOONS ) write ( * , * ) 'RINGMOONS-SyMBA integrator not yet enabled' case default write ( * , * ) 'Unkown integrator' , param % integrator call util_exit ( FAILURE ) end select return end subroutine setup_construct_system module subroutine setup_encounter ( self , n ) !! author: David A. Minton !! !! A constructor that sets the number of encounters and allocates and initializes all arrays !! implicit none ! Arguments class ( swiftest_encounter ), intent ( inout ) :: self !! Swiftest encounter structure integer ( I4B ), intent ( in ) :: n !! Number of encounters to allocate space for if ( n < 0 ) return if ( allocated ( self % lvdotr )) deallocate ( self % lvdotr ) if ( allocated ( self % status )) deallocate ( self % status ) if ( allocated ( self % kidx )) deallocate ( self % kidx ) if ( allocated ( self % index1 )) deallocate ( self % index1 ) if ( allocated ( self % index2 )) deallocate ( self % index2 ) if ( allocated ( self % id1 )) deallocate ( self % id1 ) if ( allocated ( self % id2 )) deallocate ( self % id2 ) if ( allocated ( self % x1 )) deallocate ( self % x1 ) if ( allocated ( self % x2 )) deallocate ( self % x2 ) if ( allocated ( self % v1 )) deallocate ( self % v1 ) if ( allocated ( self % v2 )) deallocate ( self % v2 ) if ( allocated ( self % t )) deallocate ( self % t ) self % nenc = n if ( n == 0 ) return allocate ( self % lvdotr ( n )) allocate ( self % status ( n )) allocate ( self % kidx ( n )) allocate ( self % index1 ( n )) allocate ( self % index2 ( n )) allocate ( self % id1 ( n )) allocate ( self % id2 ( n )) allocate ( self % x1 ( NDIM , n )) allocate ( self % x2 ( NDIM , n )) allocate ( self % v1 ( NDIM , n )) allocate ( self % v2 ( NDIM , n )) allocate ( self % t ( n )) self % lvdotr (:) = . false . self % status (:) = INACTIVE self % kidx (:) = 0_I8B self % index1 (:) = 0 self % index2 (:) = 0 self % id1 (:) = 0 self % id2 (:) = 0 self % x1 (:,:) = 0.0_DP self % x2 (:,:) = 0.0_DP self % v1 (:,:) = 0.0_DP self % v2 (:,:) = 0.0_DP self % t (:) = 0.0_DP return end subroutine setup_encounter module subroutine setup_initialize_particle_info_system ( self , param ) !! author: David A. Minton !! !! Setup up particle information metadata from initial conditions ! implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i associate ( cb => self % cb , pl => self % pl , npl => self % pl % nbody , tp => self % tp , ntp => self % tp % nbody ) call cb % info % set_value ( particle_type = CB_TYPE_NAME , status = \"ACTIVE\" , origin_type = \"Initial conditions\" , origin_time = param % t0 , origin_xh = [ 0.0_DP , 0.0_DP , 0.0_DP ], origin_vh = [ 0.0_DP , 0.0_DP , 0.0_DP ]) do i = 1 , self % pl % nbody call pl % info ( i )% set_value ( particle_type = PL_TYPE_NAME , status = \"ACTIVE\" , origin_type = \"Initial conditions\" , origin_time = param % t0 , origin_xh = self % pl % xh (:, i ), origin_vh = self % pl % vh (:, i )) end do do i = 1 , self % tp % nbody call tp % info ( i )% set_value ( particle_type = TP_TYPE_NAME , status = \"ACTIVE\" , origin_type = \"Initial conditions\" , origin_time = param % t0 , origin_xh = self % tp % xh (:, i ), origin_vh = self % tp % vh (:, i )) end do end associate return end subroutine setup_initialize_particle_info_system module subroutine setup_initialize_system ( self , param ) !! author: David A. Minton !! !! Wrapper method to initialize a basic Swiftest nbody system from files !! implicit none ! Arguments class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters call self % cb % read_in ( param ) call self % pl % read_in ( param ) call self % tp % read_in ( param ) call self % validate_ids ( param ) call self % set_msys () call self % pl % set_mu ( self % cb ) call self % tp % set_mu ( self % cb ) if ( param % in_form == EL ) then call self % pl % el2xv ( self % cb ) call self % tp % el2xv ( self % cb ) end if call self % pl % index ( param ) if (. not . param % lrhill_present ) call self % pl % set_rhill ( self % cb ) self % pl % lfirst = param % lfirstkick self % tp % lfirst = param % lfirstkick if ( param % lrestart ) then call self % read_particle_info ( param ) else call self % init_particle_info ( param ) end if return end subroutine setup_initialize_system module subroutine setup_body ( self , n , param ) !! author: David A. Minton !! !! Constructor for base Swiftest particle class. Allocates space for all particles and !! initializes all components with a value. !! Note: Timing tests indicate that (NDIM, n) is more efficient than (NDIM, n) implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest generic body object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameter ! Internals integer ( I4B ) :: i if ( n < 0 ) return self % lfirst = . true . if ( allocated ( self % info )) deallocate ( self % info ) if ( allocated ( self % id )) deallocate ( self % id ) if ( allocated ( self % status )) deallocate ( self % status ) if ( allocated ( self % ldiscard )) deallocate ( self % ldiscard ) if ( allocated ( self % lmask )) deallocate ( self % lmask ) if ( allocated ( self % mu )) deallocate ( self % mu ) if ( allocated ( self % xh )) deallocate ( self % xh ) if ( allocated ( self % vh )) deallocate ( self % vh ) if ( allocated ( self % xb )) deallocate ( self % xb ) if ( allocated ( self % vb )) deallocate ( self % vb ) if ( allocated ( self % ah )) deallocate ( self % ah ) if ( allocated ( self % aobl )) deallocate ( self % aobl ) if ( allocated ( self % agr )) deallocate ( self % lmask ) if ( allocated ( self % atide )) deallocate ( self % lmask ) if ( allocated ( self % ir3h )) deallocate ( self % ir3h ) if ( allocated ( self % a )) deallocate ( self % a ) if ( allocated ( self % e )) deallocate ( self % e ) if ( allocated ( self % e )) deallocate ( self % e ) if ( allocated ( self % inc )) deallocate ( self % inc ) if ( allocated ( self % capom )) deallocate ( self % capom ) if ( allocated ( self % omega )) deallocate ( self % omega ) if ( allocated ( self % capm )) deallocate ( self % capm ) self % nbody = n if ( n == 0 ) return allocate ( self % info ( n )) allocate ( self % id ( n )) allocate ( self % status ( n )) allocate ( self % ldiscard ( n )) allocate ( self % lmask ( n )) allocate ( self % mu ( n )) allocate ( self % xh ( NDIM , n )) allocate ( self % vh ( NDIM , n )) allocate ( self % xb ( NDIM , n )) allocate ( self % vb ( NDIM , n )) allocate ( self % ah ( NDIM , n )) allocate ( self % ir3h ( n )) self % id (:) = 0 do i = 1 , n call self % info ( i )% set_value (& name = \"UNNAMED\" , & particle_type = \"UNKNOWN\" , & status = \"INACTIVE\" , & origin_type = \"UNKNOWN\" , & origin_time = - huge ( 1.0_DP ), & origin_xh = [ 0.0_DP , 0.0_DP , 0.0_DP ], & origin_vh = [ 0.0_DP , 0.0_DP , 0.0_DP ], & discard_time = - huge ( 1.0_DP ), & discard_xh = [ 0.0_DP , 0.0_DP , 0.0_DP ], & discard_vh = [ 0.0_DP , 0.0_DP , 0.0_DP ], & discard_body_id = - 1 & ) end do self % status (:) = INACTIVE self % lmask (:) = . false . self % ldiscard (:) = . false . self % xh (:,:) = 0.0_DP self % vh (:,:) = 0.0_DP self % xb (:,:) = 0.0_DP self % vb (:,:) = 0.0_DP self % ah (:,:) = 0.0_DP self % ir3h (:) = 0.0_DP self % mu (:) = 0.0_DP if ( param % loblatecb ) then allocate ( self % aobl ( NDIM , n )) self % aobl (:,:) = 0.0_DP end if if ( param % ltides ) then allocate ( self % atide ( NDIM , n )) self % atide (:,:) = 0.0_DP end if if ( param % lgr ) then allocate ( self % agr ( NDIM , n )) self % agr (:,:) = 0.0_DP end if return end subroutine setup_body module subroutine setup_pl ( self , n , param ) !! author: David A. Minton !! !! Constructor for base Swiftest massive body class. Allocates space for all particles and !! initializes all components with a value. implicit none ! Arguments class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameter !> Call allocation method for parent class !> The parent class here is the abstract swiftest_body class, so we can't use the type-bound procedure call setup_body ( self , n , param ) if ( n < 0 ) return if ( allocated ( self % mass )) deallocate ( self % mass ) if ( allocated ( self % Gmass )) deallocate ( self % Gmass ) if ( allocated ( self % rhill )) deallocate ( self % rhill ) if ( allocated ( self % radius )) deallocate ( self % radius ) if ( allocated ( self % density )) deallocate ( self % density ) if ( allocated ( self % rot )) deallocate ( self % rot ) if ( allocated ( self % Ip )) deallocate ( self % Ip ) if ( allocated ( self % k2 )) deallocate ( self % k2 ) if ( allocated ( self % Q )) deallocate ( self % Q ) if ( allocated ( self % tlag )) deallocate ( self % tlag ) if ( n == 0 ) return allocate ( self % mass ( n )) allocate ( self % Gmass ( n )) allocate ( self % rhill ( n )) self % mass (:) = 0.0_DP self % Gmass (:) = 0.0_DP self % rhill (:) = 0.0_DP self % nplpl = 0 if ( param % lclose ) then allocate ( self % radius ( n )) allocate ( self % density ( n )) self % radius (:) = 0.0_DP self % density (:) = 1.0_DP end if if ( param % lrotation ) then allocate ( self % rot ( NDIM , n )) allocate ( self % Ip ( NDIM , n )) self % rot (:,:) = 0.0_DP self % Ip (:,:) = 0.0_DP end if if ( param % ltides ) then allocate ( self % k2 ( n )) allocate ( self % Q ( n )) allocate ( self % tlag ( n )) self % k2 (:) = 0.0_DP self % Q (:) = 0.0_DP self % tlag (:) = 0.0_DP end if return end subroutine setup_pl module subroutine setup_tp ( self , n , param ) !! author: David A. Minton !! !! Constructor for base Swiftest test particle particle class. Allocates space for !! all particles and initializes all components with a value. implicit none ! Arguments class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameter !> Call allocation method for parent class !> The parent class here is the abstract swiftest_body class, so we can't use the type-bound procedure call setup_body ( self , n , param ) if ( n < 0 ) return if ( allocated ( self % isperi )) deallocate ( self % isperi ) if ( allocated ( self % peri )) deallocate ( self % peri ) if ( allocated ( self % atp )) deallocate ( self % atp ) if ( n == 0 ) return allocate ( self % isperi ( n )) allocate ( self % peri ( n )) allocate ( self % atp ( n )) self % isperi (:) = 0 self % peri (:) = 0.0_DP self % atp (:) = 0.0_DP return end subroutine setup_tp end submodule s_setup","tags":"","loc":"sourcefile/setup.f90.html"},{"title":"user_getacch.f90 – swiftest","text":"This file depends on sourcefile~~user_getacch.f90~~EfferentGraph sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~user_getacch.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_user_kick_getacch Source Code user_getacch.f90 Source Code submodule ( swiftest_classes ) s_user_kick_getacch use swiftest contains module subroutine user_kick_getacch_body ( self , system , param , t , lbeg ) !! author: David A. Minton !! !! Add user-supplied heliocentric accelerations to planets. !! !! Adapted from David E. Kaufmann's Swifter routine whm_user_kick_getacch.f90 implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody_system_object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters user parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the ste return end subroutine user_kick_getacch_body end submodule s_user_kick_getacch","tags":"","loc":"sourcefile/user_getacch.f90.html"},{"title":"drift.f90 – swiftest","text":"This file depends on sourcefile~~drift.f90~~EfferentGraph sourcefile~drift.f90 drift.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~drift.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules drift_implementation Source Code drift.f90 Source Code submodule ( swiftest_classes ) drift_implementation use swiftest !> Integration control parameters: real ( DP ), parameter :: E2MAX = 0.36_DP real ( DP ), parameter :: DM2MAX = 0.16_DP real ( DP ), parameter :: E2DM2MAX = 0.0016_DP real ( DP ), parameter :: DANBYB = 1.0E-13_DP integer ( I2B ), parameter :: NLAG1 = 50 integer ( I2B ), parameter :: NLAG2 = 40 contains module subroutine drift_body ( self , system , param , dt ) !! author: David A. Minton !! !! Loop bodies and call Danby drift routine on the heliocentric position and velocities. !! !! Adapted from Hal Levison's Swift routine drift_tp.f !! Adapted from David E. Kaufmann's Swifter routine whm_drift_tp.f90 implicit none ! Arguments class ( swiftest_body ), intent ( inout ) :: self !! Swiftest test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize ! Internals integer ( I4B ) :: i integer ( I4B ), dimension (:), allocatable :: iflag associate ( n => self % nbody ) allocate ( iflag ( n )) iflag (:) = 0 call drift_all ( self % mu , self % xh , self % vh , self % nbody , param , dt , self % lmask , iflag ) if ( any ( iflag ( 1 : n ) /= 0 )) then where ( iflag ( 1 : n ) /= 0 ) self % status ( 1 : n ) = DISCARDED_DRIFTERR do i = 1 , n if ( iflag ( i ) /= 0 ) write ( * , * ) \" Body \" , self % id ( i ), \" lost due to error in Danby drift\" end do end if end associate return end subroutine drift_body module subroutine drift_all ( mu , x , v , n , param , dt , lmask , iflag ) !! author: David A. Minton !! !! Loop bodies and call Danby drift routine on all bodies for the given position and velocity vector. !! !! Adapted from Hal Levison's Swift routine drift_tp.f !! Adapted from David E. Kaufmann's Swifter routine whm_drift_tp.f9 implicit none ! Arguments real ( DP ), dimension (:), intent ( in ) :: mu !! Vector of gravitational constants real ( DP ), dimension (:,:), intent ( inout ) :: x , v !! Position and velocity vectors integer ( I4B ), intent ( in ) :: n !! number of bodies class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize logical , dimension (:), intent ( in ) :: lmask !! Logical mask of size self%nbody that determines which bodies to drift. integer ( I4B ), dimension (:), intent ( out ) :: iflag !! Vector of error flags. 0 means no problem ! Internals integer ( I4B ) :: i real ( DP ) :: energy , vmag2 , rmag !! Variables used in GR calculation real ( DP ), dimension (:), allocatable :: dtp if ( n == 0 ) return allocate ( dtp ( n )) if ( param % lgr ) then do concurrent ( i = 1 : n , lmask ( i )) rmag = norm2 ( x (:, i )) vmag2 = dot_product ( v (:, i ), v (:, i )) energy = 0.5_DP * vmag2 - mu ( i ) / rmag dtp ( i ) = dt * ( 1.0_DP + 3 * param % inv_c2 * energy ) end do else where ( lmask ( 1 : n )) dtp ( 1 : n ) = dt end if !$omp parallel do default(private) & !$omp shared(n, lmask, mu, x, v, dtp, iflag) do i = 1 , n if ( lmask ( i )) call drift_one ( mu ( i ), x ( 1 , i ), x ( 2 , i ), x ( 3 , i ), v ( 1 , i ), v ( 2 , i ), v ( 3 , i ), dtp ( i ), iflag ( i )) end do !$omp end parallel do return end subroutine drift_all module pure elemental subroutine drift_one ( mu , px , py , pz , vx , vy , vz , dt , iflag ) !! author: The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Perform Danby drift for one body, redoing drift with smaller substeps if original accuracy is insufficient !! !! Adapted from David E. Kaufmann's Swifter routine routine drift_one.f90 !! Adapted from Hal Levison and Martin Duncan's Swift routine drift_one.f implicit none ! Arguments real ( DP ), intent ( in ) :: mu !! G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body to drift real ( DP ), intent ( inout ) :: px , py , pz , vx , vy , vz !! Position and velocity of body to drift real ( DP ), intent ( in ) :: dt !! Step size integer ( I4B ), intent ( out ) :: iflag !! iflag : error status flag for Danby drift (0 = OK, nonzero = ERROR) ! Internals integer ( I4B ) :: i real ( DP ) :: dttmp real ( DP ), dimension ( NDIM ) :: x , v x = [ px , py , pz ] v = [ vx , vy , vz ] call drift_dan ( mu , x (:), v (:), dt , iflag ) if ( iflag /= 0 ) then dttmp = 0.1_DP * dt do i = 1 , 10 call drift_dan ( mu , x (:), v (:), dttmp , iflag ) if ( iflag /= 0 ) exit end do end if px = x ( 1 ); py = x ( 2 ); pz = x ( 3 ) vx = v ( 1 ); vy = v ( 2 ); vz = v ( 3 ) return end subroutine drift_one pure subroutine drift_dan ( mu , x0 , v0 , dt0 , iflag ) !! author: David A. Minton !! !! Perform Kepler drift, solving Kepler's equation in appropriate variables !! !! Adapted from David E. Kaufmann's Swifter routine: drift_dan.f90 !! Adapted from Hal Levison and Martin Duncan's Swift routine drift_dan.f implicit none integer ( I4B ), intent ( out ) :: iflag real ( DP ), intent ( in ) :: mu , dt0 real ( DP ), dimension (:), intent ( inout ) :: x0 , v0 real ( DP ) :: dt , f , g , fdot , gdot , c1 , c2 , c3 , u , alpha , fp , r0 real ( DP ) :: v0s , a , asq , en , dm , ec , es , esq , xkep , fchk , s , c real ( DP ), dimension ( NDIM ) :: x , v ! Executable code iflag = 0 dt = dt0 r0 = sqrt ( dot_product ( x0 (:), x0 (:))) v0s = dot_product ( v0 (:), v0 (:)) u = dot_product ( x0 (:), v0 (:)) alpha = 2 * mu / r0 - v0s if ( alpha > 0.0_DP ) then a = mu / alpha asq = a ** 2 en = sqrt ( mu / ( a * asq )) ec = 1.0_DP - r0 / a es = u / ( en * asq ) esq = ec ** 2 + es ** 2 dm = dt * en - int ( dt * en / TWOPI , kind = I4B ) * TWOPI dt = dm / en if (( esq < E2MAX ) . and . ( dm ** 2 < DM2MAX ) . and . ( esq * dm ** 2 < E2DM2MAX )) then call drift_kepmd ( dm , es , ec , xkep , s , c ) fchk = ( xkep - ec * s + es * ( 1.0_DP - c ) - dm ) ! DEK - original code compared fchk*fchk with DANBYB, but i think it should ! DEK - be compared with DANBYB*DANBYB, and i changed it accordingly - please ! DEK - check with hal and/or martin about this if ( fchk ** 2 > DANBYB ** 2 ) then iflag = 1 return end if fp = 1.0_DP - ec * c + es * s f = a / r0 * ( c - 1.0_DP ) + 1.0_DP g = dt + ( s - xkep ) / en fdot = - ( a / ( r0 * fp )) * en * s gdot = ( c - 1.0_DP ) / fp + 1.0_DP x (:) = x0 (:) * f + v0 (:) * g v (:) = x0 (:) * fdot + v0 (:) * gdot x0 (:) = x (:) v0 (:) = v (:) iflag = 0 return end if end if call drift_kepu ( dt , r0 , mu , alpha , u , fp , c1 , c2 , c3 , iflag ) if ( iflag == 0 ) then f = 1.0_DP - mu / r0 * c2 g = dt - mu * c3 fdot = - mu / ( fp * r0 ) * c1 gdot = 1.0_DP - mu / fp * c2 x (:) = x0 (:) * f + v0 (:) * g v (:) = x0 (:) * fdot + v0 (:) * gdot x0 (:) = x (:) v0 (:) = v (:) end if return end subroutine drift_dan pure subroutine drift_kepmd ( dm , es , ec , x , s , c ) !! author: David A. Minton !! !! Solve Kepler's equation in difference form for an ellipse for small input dm and eccentricity !!    Original disclaimer: built for speed, does not check how well the original equation is solved !!    Can do that in calling routine by checking how close (x - ec*s + es*(1.0 - c) - dm) is to zero !! !! Adapted from David E. Kaufmann's Swifter routine: drift_kepmd.f90 !! Adapted from Martin Duncan's Swift routine drift_kepmd.f implicit none real ( DP ), intent ( in ) :: dm , es , ec real ( DP ), intent ( out ) :: x , s , c real ( DP ), parameter :: a0 = 3991680 0.0_DP , a1 = 665280 0.0_DP , a2 = 33264 0.0_DP , a3 = 792 0.0_DP , a4 = 11 0.0_DP real ( DP ) :: dx , fac1 , fac2 , q , y , f , fp , fpp , fppp ! executable code fac1 = 1.0_DP / ( 1.0_DP - ec ) q = fac1 * dm fac2 = es ** 2 * fac1 - ec / 3.0_DP x = q * ( 1.0_DP - 0.5_DP * fac1 * q * ( es - q * fac2 )) y = x ** 2 s = x * ( a0 - y * ( a1 - y * ( a2 - y * ( a3 - y * ( a4 - y ))))) / a0 c = sqrt ( 1.0_DP - s ** 2 ) f = x - ec * s + es * ( 1.0_DP - c ) - dm fp = 1.0_DP - ec * c + es * s fpp = ec * s + es * c fppp = ec * c - es * s dx = - f / fp dx = - f / ( fp + dx * fpp / 2.0_DP ) dx = - f / ( fp + dx * fpp / 2.0_DP + dx ** 2 * fppp / 6.0_DP ) x = x + dx y = x ** 2 s = x * ( a0 - y * ( a1 - y * ( a2 - y * ( a3 - y * ( a4 - y ))))) / a0 c = sqrt ( 1.0_DP - s ** 2 ) return end subroutine drift_kepmd pure subroutine drift_kepu ( dt , r0 , mu , alpha , u , fp , c1 , c2 , c3 , iflag ) !! author: David A. Minton !! !! Solve Kepler's equation in universal variables !! !! Adapted from David E. Kaufmann's Swifter routine: drift_kepu.f90 !! Adapted from Hal Levison's Swift routine drift_kepu.f implicit none integer ( I4B ), intent ( out ) :: iflag real ( DP ), intent ( in ) :: dt , r0 , mu , alpha , u real ( DP ), intent ( out ) :: fp , c1 , c2 , c3 real ( DP ) :: s , st , fo , fn ! executable code call drift_kepu_guess ( dt , r0 , mu , alpha , u , s ) st = s call drift_kepu_new ( s , dt , r0 , mu , alpha , u , fp , c1 , c2 , c3 , iflag ) if ( iflag /= 0 ) then call drift_kepu_fchk ( dt , r0 , mu , alpha , u , st , fo ) call drift_kepu_fchk ( dt , r0 , mu , alpha , u , s , fn ) if ( abs ( fo ) < abs ( fn )) s = st call drift_kepu_lag ( s , dt , r0 , mu , alpha , u , fp , c1 , c2 , c3 , iflag ) end if return end subroutine drift_kepu pure subroutine drift_kepu_fchk ( dt , r0 , mu , alpha , u , s , f ) !! author: David A. Minton !! !! Computes the value of f, the function whose root we are trying to find in universal variables !! !! Adapted from David E. Kaufmann's Swifter routine: drift_kepu_fchk.f90 !! Adapted from Martin Duncan's Swift routine drift_kepu_fchk.f implicit none real ( DP ), intent ( in ) :: dt , r0 , mu , alpha , u , s real ( DP ), intent ( out ) :: f real ( DP ) :: x , c0 , c1 , c2 , c3 x = s ** 2 * alpha call drift_kepu_stumpff ( x , c0 , c1 , c2 , c3 ) c1 = c1 * s c2 = c2 * s ** 2 c3 = c3 * s ** 3 f = r0 * c1 + u * c2 + mu * c3 - dt return end subroutine drift_kepu_fchk pure subroutine drift_kepu_guess ( dt , r0 , mu , alpha , u , s ) !! author: David A. Minton !! !! Compute initial guess for solving Kepler's equation using universal variables !! !! Adapted from David E. Kaufmann's Swifter routine: drift_kepu_guess.f90 !! Adapted from Hal Levison and Martin Duncan's Swift routine drift_kepu_guess.f implicit none real ( DP ), intent ( in ) :: dt , r0 , mu , alpha , u real ( DP ), intent ( out ) :: s integer ( I4B ) :: iflag real ( DP ), parameter :: thresh = 0.4_DP , danbyk = 0.85_DP real ( DP ) :: y , sy , cy , sigma , es , x , a , en , ec , e if ( alpha > 0.0_DP ) then if ( dt / r0 <= thresh ) then s = dt / r0 - ( dt ** 2 * u ) / ( 2 * r0 ** 3 ) else a = mu / alpha en = sqrt ( mu / a ** 3 ) ec = 1.0_DP - r0 / a es = u / ( en * a ** 2 ) e = sqrt ( ec ** 2 + es ** 2 ) y = en * dt - es call orbel_scget ( y , sy , cy ) sigma = sign ( 1.0_DP , es * cy + ec * sy ) x = y + sigma * danbyk * e s = x / sqrt ( alpha ) end if else call drift_kepu_p3solve ( dt , r0 , mu , alpha , u , s , iflag ) if ( iflag /= 0 ) s = dt / r0 end if return end subroutine drift_kepu_guess pure subroutine drift_kepu_lag ( s , dt , r0 , mu , alpha , u , fp , c1 , c2 , c3 , iflag ) !! author: David A. Minton !! !! Solve Kepler's equation in universal variables using Laguerre's method !!      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 178 - 180. !! !! Adapted from David E. Kaufmann's Swifter routine: drift_kepu_lag.f90 !! Adapted from Hal Levison's Swift routine drift_kepu_lag.f implicit none integer ( I4B ), intent ( out ) :: iflag real ( DP ), intent ( in ) :: dt , r0 , mu , alpha , u real ( DP ), intent ( inout ) :: s real ( DP ), intent ( out ) :: fp , c1 , c2 , c3 integer ( I4B ) :: nc , ncmax real ( DP ) :: ln , x , fpp , ds , c0 , f , fdt if ( alpha < 0.0_DP ) then ncmax = NLAG2 else ncmax = NLAG1 end if ln = 5.0_DP do nc = 0 , ncmax x = s * s * alpha call drift_kepu_stumpff ( x , c0 , c1 , c2 , c3 ) c1 = c1 * s c2 = c2 * s ** 2 c3 = c3 * s ** 3 f = r0 * c1 + u * c2 + mu * c3 - dt fp = r0 * c0 + u * c1 + mu * c2 fpp = ( - r0 * alpha + mu ) * c1 + u * c0 ds = - ln * f / ( fp + sign ( 1.0_DP , fp ) * sqrt ( abs (( ln - 1.0_DP ) ** 2 * fp ** 2 - ( ln - 1.0_DP ) * ln * f * fpp ))) s = s + ds fdt = f / dt if ( fdt ** 2 < DANBYB ** 2 ) then iflag = 0 return end if end do iflag = 2 return end subroutine drift_kepu_lag pure subroutine drift_kepu_new ( s , dt , r0 , mu , alpha , u , fp , c1 , c2 , c3 , iflag ) !! author: David A. Minton !! !! Solve Kepler's equation in universal variables using Newton's method !!      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 174 - 175. !! !! Adapted from David E. Kaufmann's Swifter routine: drift_kepu_new.f90 !! Adapted from Hal Levison's Swift routine drift_kepu_new.f implicit none integer ( I4B ), intent ( out ) :: iflag real ( DP ), intent ( in ) :: dt , r0 , mu , alpha , u real ( DP ), intent ( inout ) :: s real ( DP ), intent ( out ) :: fp , c1 , c2 , c3 integer ( I4B ) :: nc real ( DP ) :: x , c0 , ds , f , fpp , fppp , fdt do nc = 0 , 6 x = s ** 2 * alpha call drift_kepu_stumpff ( x , c0 , c1 , c2 , c3 ) c1 = c1 * s c2 = c2 * s ** 2 c3 = c3 * s ** 3 f = r0 * c1 + u * c2 + mu * c3 - dt fp = r0 * c0 + u * c1 + mu * c2 fpp = ( - r0 * alpha + mu ) * c1 + u * c0 fppp = ( - r0 * alpha + mu ) * c0 - u * alpha * c1 ds = - f / fp ds = - f / ( fp + ds * fpp / 2.0_DP ) ds = - f / ( fp + ds * fpp / 2.0_DP + ds ** 2 * fppp / 6.0_DP ) s = s + ds fdt = f / dt if ( fdt ** 2 < DANBYB ** 2 ) then iflag = 0 return end if end do iflag = 1 return end subroutine drift_kepu_new pure subroutine drift_kepu_p3solve ( dt , r0 , mu , alpha , u , s , iflag ) !! author: David A. Minton !! !! Computes real root of cubic involved in setting initial guess for solving Kepler's equation in universal variables !!      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 177 - 178. !! !! Adapted from David E. Kaufmann's Swifter routine: drift_kepu_p3solve.f90 !! Adapted from Martin Duncan's Swift routine drift_kepu_p3solve.f implicit none integer ( I4B ), intent ( out ) :: iflag real ( DP ), intent ( in ) :: dt , r0 , mu , alpha , u real ( DP ), intent ( out ) :: s real ( DP ) :: denom , a0 , a1 , a2 , q , r , sq2 , sq , p1 , p2 denom = ( mu - alpha * r0 ) / 6.0_DP a2 = 0.5_DP * u / denom a1 = r0 / denom a0 = - dt / denom q = ( a1 - a2 ** 2 / 3.0_DP ) / 3.0_DP r = ( a1 * a2 - 3 * a0 ) / 6.0_DP - a2 ** 3 / 2 7.0_DP sq2 = q ** 3 + r ** 2 if ( sq2 >= 0.0_DP ) then sq = sqrt ( sq2 ) if (( r + sq ) <= 0.0_DP ) then p1 = - ( - ( r + sq )) ** ( 1.0_DP / 3.0_DP ) else p1 = ( r + sq ) ** ( 1.0_DP / 3.0_DP ) end if if (( r - sq ) <= 0.0_DP ) then p2 = - ( - ( r - sq )) ** ( 1.0_DP / 3.0_DP ) else p2 = ( r - sq ) ** ( 1.0_DP / 3.0_DP ) end if iflag = 0 s = p1 + p2 - a2 / 3.0_DP else iflag = 1 s = 0.0_DP end if return end subroutine drift_kepu_p3solve pure subroutine drift_kepu_stumpff ( x , c0 , c1 , c2 , c3 ) !! author: David A. Minton !! !! Compute Stumpff functions needed for Kepler drift in universal variables !!      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 171 - 172. !! !! Adapted from David E. Kaufmann's Swifter routine: drift_kepu_stumpff.f90 !! Adapted from Hal Levison's Swift routine drift_kepu_stumpff.f implicit none real ( DP ), intent ( inout ) :: x real ( DP ), intent ( out ) :: c0 , c1 , c2 , c3 integer ( I4B ) :: i , n real ( DP ) :: xm n = 0 xm = 0.1_DP do while ( abs ( x ) >= xm ) n = n + 1 x = x / 4.0_DP end do c2 = ( 1.0_DP - x * ( 1.0_DP - x * ( 1.0_DP - x * ( 1.0_DP - x * ( 1.0_DP - x * & ( 1.0_DP - x / 18 2.0_DP ) / 13 2.0_DP ) / 9 0.0_DP ) / 5 6.0_DP ) / & 3 0.0_DP ) / 1 2.0_DP ) / 2.0_DP c3 = ( 1.0_DP - x * ( 1.0_DP - x * ( 1.0_DP - x * ( 1.0_DP - x * ( 1.0_DP - x * & ( 1.0_DP - x / 21 0.0_DP ) / 15 6.0_DP ) / 11 0.0_DP ) / 7 2.0_DP ) / & 4 2.0_DP ) / 2 0.0_DP ) / 6.0_DP c1 = 1.0_DP - x * c3 c0 = 1.0_DP - x * c2 if ( n /= 0 ) then do i = n , 1 , - 1 c3 = ( c2 + c0 * c3 ) / 4.0_DP c2 = c1 ** 2 / 2.0_DP c1 = c0 * c1 c0 = 2 * c0 ** 2 - 1.0_DP x = x * 4 end do end if return end subroutine drift_kepu_stumpff end submodule drift_implementation","tags":"","loc":"sourcefile/drift.f90.html"},{"title":"symba_util.f90 – swiftest","text":"This file depends on sourcefile~~symba_util.f90~~EfferentGraph sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_util.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_symba_util Source Code symba_util.f90 Source Code submodule ( symba_classes ) s_symba_util use swiftest contains module subroutine symba_util_append_arr_kin ( arr , source , nold , nsrc , lsource_mask ) !! author: David A. Minton !! !! Append a single array of kinship type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. implicit none ! Arguments type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array type ( symba_kinship ), dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to ! Internals integer ( I4B ) :: nnew if (. not . allocated ( source )) return nnew = count ( lsource_mask ( 1 : nsrc )) if (. not . allocated ( arr )) then allocate ( arr ( nold + nnew )) else call util_resize ( arr , nold + nnew ) end if arr ( nold + 1 : nold + nnew ) = pack ( source ( 1 : nsrc ), lsource_mask ( 1 : nsrc )) return end subroutine symba_util_append_arr_kin module subroutine symba_util_append_encounter ( self , source , lsource_mask ) !! author: David A. Minton !! !! Append components from one encounter list (pl-pl or pl-tp) body object to another. !! This method will automatically resize the destination body if it is too small implicit none ! Arguments class ( symba_encounter ), intent ( inout ) :: self !! SyMBA encounter list object class ( swiftest_encounter ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to associate ( nold => self % nenc , nsrc => source % nenc ) select type ( source ) class is ( symba_encounter ) call util_append ( self % level , source % level , nold , nsrc , lsource_mask ) end select call util_append_encounter ( self , source , lsource_mask ) end associate return end subroutine symba_util_append_encounter module subroutine symba_util_append_pl ( self , source , lsource_mask ) !! author: David A. Minton !! !! Append components from one massive body object to another. !! This method will automatically resize the destination body if it is too small implicit none !! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to select type ( source ) class is ( symba_pl ) associate ( nold => self % nbody , nsrc => source % nbody ) call util_append ( self % lcollision , source % lcollision , nold , nsrc , lsource_mask ) call util_append ( self % lencounter , source % lencounter , nold , nsrc , lsource_mask ) call util_append ( self % lmtiny , source % lmtiny , nold , nsrc , lsource_mask ) call util_append ( self % nplenc , source % nplenc , nold , nsrc , lsource_mask ) call util_append ( self % ntpenc , source % ntpenc , nold , nsrc , lsource_mask ) call util_append ( self % levelg , source % levelg , nold , nsrc , lsource_mask ) call util_append ( self % levelm , source % levelm , nold , nsrc , lsource_mask ) call util_append ( self % isperi , source % isperi , nold , nsrc , lsource_mask ) call util_append ( self % peri , source % peri , nold , nsrc , lsource_mask ) call util_append ( self % atp , source % atp , nold , nsrc , lsource_mask ) call util_append ( self % kin , source % kin , nold , nsrc , lsource_mask ) call util_append_pl ( self , source , lsource_mask ) ! Note: helio_pl does not have its own append method, so we skip back to the base class end associate class default write ( * , * ) \"Invalid object passed to the append method. Source must be of class symba_pl or its descendents!\" call util_exit ( FAILURE ) end select return end subroutine symba_util_append_pl module subroutine symba_util_append_merger ( self , source , lsource_mask ) !! author: David A. Minton !! !! Append components from one massive body object to another. !! This method will automatically resize the destination body if it is too small implicit none ! Arguments class ( symba_merger ), intent ( inout ) :: self !! SyMBA massive body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to ! Internals integer ( I4B ), dimension (:), allocatable :: ncomp_tmp !! Temporary placeholder for ncomp incase we are appending a symba_pl object to a symba_merger integer ( I4B ) :: nold , nsrc , nnew nold = self % nbody nsrc = source % nbody nnew = count ( lsource_mask ) select type ( source ) class is ( symba_merger ) call util_append ( self % ncomp , source % ncomp , nold , nsrc , lsource_mask ) call symba_util_append_pl ( self , source , lsource_mask ) class is ( symba_pl ) allocate ( ncomp_tmp , mold = source % id ) ncomp_tmp (:) = 0 call util_append ( self % ncomp , ncomp_tmp , nold , nsrc , lsource_mask ) call symba_util_append_pl ( self , source , lsource_mask ) class default write ( * , * ) \"Invalid object passed to the append method. Source must be of class symba_pl or its descendents!\" call util_exit ( FAILURE ) end select ! Save the number of appended bodies self % ncomp ( nold + 1 : nold + nnew ) = nnew return end subroutine symba_util_append_merger module subroutine symba_util_append_tp ( self , source , lsource_mask ) !! author: David A. Minton !! !! Append components from test particle object to another. !! This method will automatically resize the destination body if it is too small implicit none !! Arguments class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to select type ( source ) class is ( symba_tp ) associate ( nold => self % nbody , nsrc => source % nbody ) call util_append ( self % nplenc , source % nplenc , nold , nsrc , lsource_mask ) call util_append ( self % levelg , source % levelg , nold , nsrc , lsource_mask ) call util_append ( self % levelm , source % levelm , nold , nsrc , lsource_mask ) call util_append_tp ( self , source , lsource_mask ) ! Note: helio_tp does not have its own append method, so we skip back to the base class end associate class default write ( * , * ) \"Invalid object passed to the append method. Source must be of class symba_tp or its descendents!\" call util_exit ( FAILURE ) end select return end subroutine symba_util_append_tp module subroutine symba_util_copy_encounter ( self , source ) !! author: David A. Minton !! !! Copies elements from the source encounter list into self. implicit none ! Arguments class ( symba_encounter ), intent ( inout ) :: self !! Encounter list class ( swiftest_encounter ), intent ( in ) :: source !! Source object to copy into select type ( source ) class is ( symba_encounter ) associate ( n => source % nenc ) self % level ( 1 : n ) = source % level ( 1 : n ) end associate end select call util_copy_encounter ( self , source ) return end subroutine symba_util_copy_encounter module subroutine symba_util_fill_arr_kin ( keeps , inserts , lfill_list ) !! author: David A. Minton !! !! Performs a fill operation on a single array of particle kinship types !! This is the inverse of a spill operation implicit none ! Arguments type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep type ( symba_kinship ), dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps if (. not . allocated ( keeps ) . or . . not . allocated ( inserts )) return keeps (:) = unpack ( keeps (:), . not . lfill_list (:), keeps (:)) keeps (:) = unpack ( inserts (:), lfill_list (:), keeps (:)) return end subroutine symba_util_fill_arr_kin module subroutine symba_util_fill_pl ( self , inserts , lfill_list ) !! author: David A. Minton !! !! Insert new SyMBA test particle structure into an old one. !! This is the inverse of a fill operation. !! implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA masive body object class ( swiftest_body ), intent ( in ) :: inserts !! Inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps associate ( keeps => self ) select type ( inserts ) class is ( symba_pl ) call util_fill ( keeps % lcollision , inserts % lcollision , lfill_list ) call util_fill ( keeps % lencounter , inserts % lencounter , lfill_list ) call util_fill ( keeps % lmtiny , inserts % lmtiny , lfill_list ) call util_fill ( keeps % nplenc , inserts % nplenc , lfill_list ) call util_fill ( keeps % ntpenc , inserts % ntpenc , lfill_list ) call util_fill ( keeps % levelg , inserts % levelg , lfill_list ) call util_fill ( keeps % levelm , inserts % levelm , lfill_list ) call util_fill ( keeps % isperi , inserts % isperi , lfill_list ) call util_fill ( keeps % peri , inserts % peri , lfill_list ) call util_fill ( keeps % atp , inserts % atp , lfill_list ) call util_fill ( keeps % kin , inserts % kin , lfill_list ) call util_fill_pl ( keeps , inserts , lfill_list ) ! Note: helio_pl does not have its own fill method, so we skip back to the base class class default write ( * , * ) \"Invalid object passed to the fill method. Source must be of class symba_pl or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine symba_util_fill_pl module subroutine symba_util_fill_tp ( self , inserts , lfill_list ) !! author: David A. Minton !! !! Insert new SyMBA test particle structure into an old one. !! This is the inverse of a fill operation. !! implicit none ! Arguments class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object class ( swiftest_body ), intent ( in ) :: inserts !! Inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps associate ( keeps => self ) select type ( inserts ) class is ( symba_tp ) call util_fill ( keeps % nplenc , inserts % nplenc , lfill_list ) call util_fill ( keeps % levelg , inserts % levelg , lfill_list ) call util_fill ( keeps % levelm , inserts % levelm , lfill_list ) call util_fill_tp ( keeps , inserts , lfill_list ) ! Note: helio_tp does not have its own fill method, so we skip back to the base class class default write ( * , * ) \"Invalid object passed to the fill method. Source must be of class symba_tp or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine symba_util_fill_tp module subroutine symba_util_index_eucl_plpl ( self , param ) !! author: Jacob R. Elliott and David A. Minton !! !! Turns i,j indices into k index for use in the Euclidean distance matrix. This also sets the lmtiny flag and computes the !! number of interactions that excludes semi-interacting bodies with each other (Gmass < GMTINY). !! This method will also sort the bodies in descending order by Mass !! !! Reference: !! !!    Mélodie Angeletti, Jean-Marie Bonny, Jonas Koko. Parallel Euclidean distance matrix computation on big datasets *. !!       2019. hal-0204751 implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I8B ) :: k , nplpl , nplplm integer ( I4B ) :: i , j , npl , nplm , ip , jp associate ( pl => self ) npl = int ( self % nbody , kind = I8B ) nplm = count (. not . pl % lmtiny ( 1 : npl )) pl % nplm = int ( nplm , kind = I4B ) pl % nplpl = ( npl * ( npl - 1 ) / 2 ) ! number of entries in a strict lower triangle, npl x npl, minus first column pl % nplplm = nplm * npl - nplm * ( nplm + 1 ) / 2 ! number of entries in a strict lower triangle, npl x npl, minus first column including only mutually interacting bodies if ( allocated ( self % k_plpl )) deallocate ( self % k_plpl ) ! Reset the index array if it's been set previously allocate ( self % k_plpl ( 2 , pl % nplpl )) do concurrent ( i = 1 : npl ) do concurrent ( j = i + 1 : npl ) call util_index_eucl_ij_to_k ( npl , i , j , k ) self % k_plpl ( 1 , k ) = i self % k_plpl ( 2 , k ) = j end do end do end associate return end subroutine symba_util_index_eucl_plpl module subroutine symba_util_peri_pl ( self , system , param ) !! author: David A. Minton !! !! Determine system pericenter passages for planets in SyMBA !! !! Adapted from David E. Kaufmann's Swifter routine: symba_peri.f90 !! Adapted from Hal Levison's Swift routine util_mass_peri.f implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i real ( DP ) :: vdotr , e associate ( pl => self , npl => self % nbody ) if ( pl % lfirst ) then if ( param % qmin_coord == \"HELIO\" ) then do i = 1 , npl if ( pl % status ( i ) == ACTIVE ) then vdotr = dot_product ( pl % xh (:, i ), pl % vh (:, i )) if ( vdotr > 0.0_DP ) then pl % isperi ( i ) = 1 else pl % isperi ( i ) = - 1 end if end if end do else do i = 1 , npl if ( pl % status ( i ) == ACTIVE ) then vdotr = dot_product ( pl % xb (:, i ), pl % vb (:, i )) if ( vdotr > 0.0_DP ) then pl % isperi ( i ) = 1 else pl % isperi ( i ) = - 1 end if end if end do end if else if ( param % qmin_coord == \"HELIO\" ) then do i = 1 , npl if ( pl % status ( i ) == ACTIVE ) then vdotr = dot_product ( pl % xh (:, i ), pl % vh (:, i )) if ( pl % isperi ( i ) == - 1 ) then if ( vdotr >= 0.0_DP ) then pl % isperi ( i ) = 0 CALL orbel_xv2aeq ( pl % mu ( i ), pl % xh (:, i ), pl % vh (:, i ), pl % atp ( i ), e , pl % peri ( i )) end if else if ( vdotr > 0.0_DP ) then pl % isperi ( i ) = 1 else pl % isperi ( i ) = - 1 end if end if end if end do else do i = 1 , npl if ( pl % status ( i ) == ACTIVE ) then vdotr = dot_product ( pl % xb (:, i ), pl % vb (:, i )) if ( pl % isperi ( i ) == - 1 ) then if ( vdotr >= 0.0_DP ) then pl % isperi ( i ) = 0 CALL orbel_xv2aeq ( system % Gmtot , pl % xb (:, i ), pl % vb (:, i ), pl % atp ( i ), e , pl % peri ( i )) end if else if ( vdotr > 0.0_DP ) then pl % isperi ( i ) = 1 else pl % isperi ( i ) = - 1 end if end if end if end do end if end if end associate return end subroutine symba_util_peri_pl module subroutine symba_util_rearray_pl ( self , system , param ) !! Author: the Purdue Swiftest Team -  David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Clean up the massive body structures to remove discarded bodies and add new bodies implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object class ( symba_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( symba_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals class ( symba_pl ), allocatable :: tmp !! The discarded body list. integer ( I4B ) :: i , j , k , npl , nadd , nencmin , nenc_old , idnew1 , idnew2 , idold1 , idold2 logical , dimension (:), allocatable :: lmask , ldump_mask class ( symba_plplenc ), allocatable :: plplenc_old logical :: lencounter integer ( I4B ), dimension (:), allocatable :: levelg_orig_pl , levelm_orig_pl , levelg_orig_tp , levelm_orig_tp , nplenc_orig_pl , nplenc_orig_tp , ntpenc_orig_pl associate ( pl => self , pl_adds => system % pl_adds ) npl = pl % nbody nadd = pl_adds % nbody if ( npl == 0 ) return ! Deallocate any temporary variables if ( allocated ( pl % xbeg )) deallocate ( pl % xbeg ) if ( allocated ( pl % xend )) deallocate ( pl % xend ) ! Remove the discards and destroy the list, as the system already tracks pl_discards elsewhere allocate ( lmask ( npl )) lmask ( 1 : npl ) = pl % ldiscard ( 1 : npl ) allocate ( tmp , mold = self ) call pl % spill ( tmp , lspill_list = lmask , ldestructive = . true .) npl = pl % nbody call tmp % setup ( 0 , param ) deallocate ( tmp ) deallocate ( lmask ) ! Store the original plplenc list so we don't remove any of the original encounters nenc_old = system % plplenc_list % nenc if ( nenc_old > 0 ) then allocate ( plplenc_old , source = system % plplenc_list ) call plplenc_old % copy ( system % plplenc_list ) end if ! Add in any new bodies if ( nadd > 0 ) then ! Append the adds to the main pl object call pl % append ( pl_adds , lsource_mask = [(. true ., i = 1 , nadd )]) allocate ( ldump_mask ( npl + nadd )) ! This mask is used only to append the original Fortran binary particle.dat file with new bodies. This is ignored for NetCDF output ldump_mask ( 1 : npl ) = . false . ldump_mask ( npl + 1 : npl + nadd ) = pl % status ( npl + 1 : npl + nadd ) == NEW_PARTICLE npl = pl % nbody else allocate ( ldump_mask ( npl )) ldump_mask (:) = . false . end if ! Reset all of the status flags for this body pl % status ( 1 : npl ) = ACTIVE do i = 1 , npl call pl % info ( i )% set_value ( status = \"ACTIVE\" ) end do pl % ldiscard ( 1 : npl ) = . false . pl % lcollision ( 1 : npl ) = . false . pl % lmask ( 1 : npl ) = . true . select type ( param ) class is ( symba_parameters ) pl % lmtiny ( 1 : npl ) = pl % Gmass ( 1 : npl ) < param % GMTINY where ( pl % lmtiny ( 1 : npl )) pl % info ( 1 : npl )% particle_type = PL_TINY_TYPE_NAME elsewhere pl % info ( 1 : npl )% particle_type = PL_TYPE_NAME end where end select call pl % dump_particle_info ( param , idx = pack ([( i , i = 1 , npl )], ldump_mask )) deallocate ( ldump_mask ) ! Reindex the new list of bodies call pl % sort ( \"mass\" , ascending = . false .) call pl % index ( param ) ! Reset the kinship trackers call pl % reset_kinship ([( i , i = 1 , npl )]) ! Re-build the zero-level encounter list, being sure to save the original level information for all bodies allocate ( levelg_orig_pl , source = pl % levelg ) allocate ( levelm_orig_pl , source = pl % levelm ) allocate ( nplenc_orig_pl , source = pl % nplenc ) lencounter = pl % encounter_check ( system , param % dt , 0 ) if ( system % tp % nbody > 0 ) then select type ( tp => system % tp ) class is ( symba_tp ) allocate ( ntpenc_orig_pl , source = pl % ntpenc ) allocate ( levelg_orig_tp , source = tp % levelg ) allocate ( levelm_orig_tp , source = tp % levelm ) allocate ( nplenc_orig_tp , source = tp % nplenc ) lencounter = tp % encounter_check ( system , param % dt , 0 ) call move_alloc ( levelg_orig_tp , tp % levelg ) call move_alloc ( levelm_orig_tp , tp % levelm ) call move_alloc ( nplenc_orig_tp , tp % nplenc ) call move_alloc ( ntpenc_orig_pl , pl % ntpenc ) end select end if call move_alloc ( levelg_orig_pl , pl % levelg ) call move_alloc ( levelm_orig_pl , pl % levelm ) call move_alloc ( nplenc_orig_pl , pl % nplenc ) ! Re-index the encounter list as the index values may have changed if ( nenc_old > 0 ) then nencmin = min ( system % plplenc_list % nenc , plplenc_old % nenc ) do k = 1 , nencmin idnew1 = system % plplenc_list % id1 ( k ) idnew2 = system % plplenc_list % id2 ( k ) idold1 = plplenc_old % id1 ( k ) idold2 = plplenc_old % id2 ( k ) if (( idnew1 == idold1 ) . and . ( idnew2 == idold2 )) then ! This is an encounter we already know about, so save the old information system % plplenc_list % lvdotr ( k ) = plplenc_old % lvdotr ( k ) system % plplenc_list % status ( k ) = plplenc_old % status ( k ) system % plplenc_list % x1 (:, k ) = plplenc_old % x1 (:, k ) system % plplenc_list % x2 (:, k ) = plplenc_old % x2 (:, k ) system % plplenc_list % v1 (:, k ) = plplenc_old % v1 (:, k ) system % plplenc_list % v2 (:, k ) = plplenc_old % v2 (:, k ) system % plplenc_list % t ( k ) = plplenc_old % t ( k ) system % plplenc_list % level ( k ) = plplenc_old % level ( k ) else if ((( idnew1 == idold2 ) . and . ( idnew2 == idold1 ))) then ! This is an encounter we already know about, but with the order reversed, so save the old information system % plplenc_list % lvdotr ( k ) = plplenc_old % lvdotr ( k ) system % plplenc_list % status ( k ) = plplenc_old % status ( k ) system % plplenc_list % x1 (:, k ) = plplenc_old % x2 (:, k ) system % plplenc_list % x2 (:, k ) = plplenc_old % x1 (:, k ) system % plplenc_list % v1 (:, k ) = plplenc_old % v2 (:, k ) system % plplenc_list % v2 (:, k ) = plplenc_old % v1 (:, k ) system % plplenc_list % t ( k ) = plplenc_old % t ( k ) system % plplenc_list % level ( k ) = plplenc_old % level ( k ) end if end do end if end associate return end subroutine symba_util_rearray_pl module subroutine symba_util_reset_kinship ( self , idx ) !! author: David A. Minton !! !! Resets the kinship status of bodies. !! implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), dimension (:), intent ( in ) :: idx !! Index array of bodies to reset ! Internals integer ( I4B ) :: i , j self % kin ( idx (:))% parent = idx (:) self % kin ( idx (:))% nchild = 0 do j = 1 , size ( idx (:)) i = idx ( j ) if ( allocated ( self % kin ( i )% child )) deallocate ( self % kin ( i )% child ) end do return end subroutine symba_util_reset_kinship module subroutine symba_util_resize_arr_kin ( arr , nnew ) !! author: David A. Minton !! !! Resizes an array component of type character string. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. implicit none ! Arguments type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size ! Internals type ( symba_kinship ), dimension (:), allocatable :: tmp !! Temporary storage array in case the input array is already allocated integer ( I4B ) :: nold !! Old size if ( nnew < 0 ) return if ( nnew == 0 ) then if ( allocated ( arr )) deallocate ( arr ) return end if if ( allocated ( arr )) then nold = size ( arr ) else nold = 0 end if allocate ( tmp ( nnew )) if ( nnew > nold ) then tmp ( 1 : nold ) = arr ( 1 : nold ) else tmp ( 1 : nnew ) = arr ( 1 : nnew ) end if call move_alloc ( tmp , arr ) return end subroutine symba_util_resize_arr_kin module subroutine symba_util_resize_merger ( self , nnew ) !! author: David A. Minton !! !! Checks the current size of a SyMBA merger list against the requested size and resizes it if it is too small. implicit none ! Arguments class ( symba_merger ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), intent ( in ) :: nnew !! New size neded call util_resize ( self % ncomp , nnew ) call symba_util_resize_pl ( self , nnew ) return end subroutine symba_util_resize_merger module subroutine symba_util_resize_pl ( self , nnew ) !! author: David A. Minton !! !! Checks the current size of a SyMBA massive body object against the requested size and resizes it if it is too small. implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), intent ( in ) :: nnew !! New size neded call util_resize ( self % lcollision , nnew ) call util_resize ( self % lencounter , nnew ) call util_resize ( self % lmtiny , nnew ) call util_resize ( self % nplenc , nnew ) call util_resize ( self % ntpenc , nnew ) call util_resize ( self % levelg , nnew ) call util_resize ( self % levelm , nnew ) call util_resize ( self % isperi , nnew ) call util_resize ( self % peri , nnew ) call util_resize ( self % atp , nnew ) call util_resize ( self % kin , nnew ) call util_resize_pl ( self , nnew ) return end subroutine symba_util_resize_pl module subroutine symba_util_resize_tp ( self , nnew ) !! author: David A. Minton !! !! Checks the current size of a test particle object against the requested size and resizes it if it is too small. implicit none ! Arguments class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object integer ( I4B ), intent ( in ) :: nnew !! New size neded call util_resize ( self % nplenc , nnew ) call util_resize ( self % levelg , nnew ) call util_resize ( self % levelm , nnew ) call util_resize_tp ( self , nnew ) return end subroutine symba_util_resize_tp module subroutine symba_util_sort_pl ( self , sortby , ascending ) !! author: David A. Minton !! !! Sort a SyMBA massive body object in-place. !! sortby is a string indicating which array component to sort. implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order ! Internals integer ( I4B ), dimension (:), allocatable :: ind integer ( I4B ) :: direction if ( self % nbody == 0 ) return if ( ascending ) then direction = 1 else direction = - 1 end if associate ( pl => self , npl => self % nbody ) allocate ( ind ( npl )) select case ( sortby ) case ( \"nplenc\" ) call util_sort ( direction * pl % nplenc ( 1 : npl ), ind ( 1 : npl )) case ( \"ntpenc\" ) call util_sort ( direction * pl % ntpenc ( 1 : npl ), ind ( 1 : npl )) case ( \"levelg\" ) call util_sort ( direction * pl % levelg ( 1 : npl ), ind ( 1 : npl )) case ( \"levelm\" ) call util_sort ( direction * pl % levelm ( 1 : npl ), ind ( 1 : npl )) case ( \"peri\" ) call util_sort ( direction * pl % peri ( 1 : npl ), ind ( 1 : npl )) case ( \"atp\" ) call util_sort ( direction * pl % atp ( 1 : npl ), ind ( 1 : npl )) case ( \"lcollision\" , \"lencounter\" , \"lmtiny\" , \"nplm\" , \"nplplm\" , \"kin\" , \"info\" ) write ( * , * ) 'Cannot sort by ' // trim ( adjustl ( sortby )) // '. Component not sortable!' case default ! Look for components in the parent class call util_sort_pl ( pl , sortby , ascending ) return end select call pl % rearrange ( ind ) end associate return end subroutine symba_util_sort_pl module subroutine symba_util_sort_tp ( self , sortby , ascending ) !! author: David A. Minton !! !! Sort a SyMBA test particle object in-place. !! sortby is a string indicating which array component to sort. implicit none ! Arguments class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order ! Internals integer ( I4B ), dimension (:), allocatable :: ind integer ( I4B ) :: direction if ( self % nbody == 0 ) return if ( ascending ) then direction = 1 else direction = - 1 end if associate ( tp => self , ntp => self % nbody ) allocate ( ind ( ntp )) select case ( sortby ) case ( \"nplenc\" ) call util_sort ( direction * tp % nplenc ( 1 : ntp ), ind ( 1 : ntp )) case ( \"levelg\" ) call util_sort ( direction * tp % levelg ( 1 : ntp ), ind ( 1 : ntp )) case ( \"levelm\" ) call util_sort ( direction * tp % levelm ( 1 : ntp ), ind ( 1 : ntp )) case default ! Look for components in the parent class call util_sort_tp ( tp , sortby , ascending ) return end select call tp % rearrange ( ind ) end associate return end subroutine symba_util_sort_tp module subroutine symba_util_sort_rearrange_arr_kin ( arr , ind , n ) !! author: David A. Minton !! !! Rearrange a single array of particle kinship type in-place from an index list. implicit none ! Arguments type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index to rearrange against integer ( I4B ), intent ( in ) :: n !! Number of elements in arr and ind to rearrange ! Internals type ( symba_kinship ), dimension (:), allocatable :: tmp !! Temporary copy of array used during rearrange operation integer ( I4B ) :: i , j if (. not . allocated ( arr ) . or . n <= 0 ) return allocate ( tmp , source = arr ) tmp ( 1 : n ) = arr ( ind ( 1 : n )) do i = 1 , n do j = 1 , tmp ( i )% nchild tmp ( i )% child ( j ) = ind ( tmp ( i )% child ( j )) end do end do call move_alloc ( tmp , arr ) return end subroutine symba_util_sort_rearrange_arr_kin module subroutine symba_util_sort_rearrange_pl ( self , ind ) !! author: David A. Minton !! !! Rearrange SyMBA massive body structure in-place from an index list. !! This is a helper utility used to make polymorphic sorting work on Swiftest structures. implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) ! Internals integer ( I4B ) :: i , j associate ( pl => self , npl => self % nbody ) call util_sort_rearrange ( pl % lcollision , ind , npl ) call util_sort_rearrange ( pl % lencounter , ind , npl ) call util_sort_rearrange ( pl % lmtiny , ind , npl ) call util_sort_rearrange ( pl % nplenc , ind , npl ) call util_sort_rearrange ( pl % ntpenc , ind , npl ) call util_sort_rearrange ( pl % levelg , ind , npl ) call util_sort_rearrange ( pl % levelm , ind , npl ) call util_sort_rearrange ( pl % isperi , ind , npl ) call util_sort_rearrange ( pl % peri , ind , npl ) call util_sort_rearrange ( pl % atp , ind , npl ) call util_sort_rearrange ( pl % kin , ind , npl ) call util_sort_rearrange_pl ( pl , ind ) end associate return end subroutine symba_util_sort_rearrange_pl module subroutine symba_util_sort_rearrange_tp ( self , ind ) !! author: David A. Minton !! !! Rearrange SyMBA test particle object in-place from an index list. !! This is a helper utility used to make polymorphic sorting work on Swiftest structures. implicit none ! Arguments class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) associate ( tp => self , ntp => self % nbody ) call util_sort_rearrange ( tp % nplenc , ind , ntp ) call util_sort_rearrange ( tp % levelg , ind , ntp ) call util_sort_rearrange ( tp % levelm , ind , ntp ) call util_sort_rearrange_tp ( tp , ind ) end associate return end subroutine symba_util_sort_rearrange_tp module subroutine symba_util_spill_arr_kin ( keeps , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Performs a spill operation on a single array of particle kinships !! This is the inverse of a spill operation implicit none ! Arguments type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discardss logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not ! Internals integer ( I4B ) :: nspill , nkeep , nlist nkeep = count (. not . lspill_list (:)) nspill = count ( lspill_list (:)) nlist = size ( lspill_list (:)) if (. not . allocated ( keeps ) . or . nspill == 0 ) return if (. not . allocated ( discards )) then allocate ( discards ( nspill )) else if ( size ( discards ) /= nspill ) then deallocate ( discards ) allocate ( discards ( nspill )) end if discards (:) = pack ( keeps ( 1 : nlist ), lspill_list ( 1 : nlist )) if ( ldestructive ) then if ( nkeep > 0 ) then keeps (:) = pack ( keeps ( 1 : nlist ), . not . lspill_list ( 1 : nlist )) else deallocate ( keeps ) end if end if return end subroutine symba_util_spill_arr_kin module subroutine symba_util_spill_pl ( self , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Move spilled (discarded) SyMBA massive body particle structure from active list to discard list !! Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter body by removing the discard list ! For each component, pack the discarded bodies into the discard object and do the inverse with the keeps !> Spill all the common components associate ( keeps => self ) select type ( discards ) class is ( symba_pl ) call util_spill ( keeps % lcollision , discards % lcollision , lspill_list , ldestructive ) call util_spill ( keeps % lencounter , discards % lencounter , lspill_list , ldestructive ) call util_spill ( keeps % lmtiny , discards % lmtiny , lspill_list , ldestructive ) call util_spill ( keeps % nplenc , discards % nplenc , lspill_list , ldestructive ) call util_spill ( keeps % ntpenc , discards % ntpenc , lspill_list , ldestructive ) call util_spill ( keeps % levelg , discards % levelg , lspill_list , ldestructive ) call util_spill ( keeps % levelm , discards % levelm , lspill_list , ldestructive ) call util_spill ( keeps % isperi , discards % isperi , lspill_list , ldestructive ) call util_spill ( keeps % peri , discards % peri , lspill_list , ldestructive ) call util_spill ( keeps % atp , discards % atp , lspill_list , ldestructive ) call util_spill ( keeps % kin , discards % kin , lspill_list , ldestructive ) call util_spill_pl ( keeps , discards , lspill_list , ldestructive ) class default write ( * , * ) \"Invalid object passed to the spill method. Source must be of class symba_pl or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine symba_util_spill_pl module subroutine symba_util_spill_encounter ( self , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Move spilled (discarded) SyMBA encounter structure from active list to discard list !! Note: Because the symba_plplenc currently does not contain any additional variable components, this method can recieve it as an input as well. implicit none ! Arguments class ( symba_encounter ), intent ( inout ) :: self !! SyMBA pl-tp encounter list class ( swiftest_encounter ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter body by removing the discard list associate ( keeps => self ) select type ( discards ) class is ( symba_encounter ) call util_spill ( keeps % level , discards % level , lspill_list , ldestructive ) call util_spill_encounter ( keeps , discards , lspill_list , ldestructive ) class default write ( * , * ) \"Invalid object passed to the spill method. Source must be of class symba_encounter or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine symba_util_spill_encounter module subroutine symba_util_spill_tp ( self , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Move spilled (discarded) SyMBA test particle structure from active list to discard list !! Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 implicit none ! Arguments class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter body by removing the discard list ! For each component, pack the discarded bodies into the discard object and do the inverse with the keeps !> Spill all the common components associate ( keeps => self ) select type ( discards ) class is ( symba_tp ) call util_spill ( keeps % nplenc , discards % nplenc , lspill_list , ldestructive ) call util_spill ( keeps % levelg , discards % levelg , lspill_list , ldestructive ) call util_spill ( keeps % levelm , discards % levelm , lspill_list , ldestructive ) call util_spill_tp ( keeps , discards , lspill_list , ldestructive ) class default write ( * , * ) \"Invalid object passed to the spill method. Source must be of class symba_tp or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine symba_util_spill_tp end submodule s_symba_util","tags":"","loc":"sourcefile/symba_util.f90.html"},{"title":"symba_collision.f90 – swiftest","text":"This file depends on sourcefile~~symba_collision.f90~~EfferentGraph sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_collision.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_symba_collision Source Code symba_collision.f90 Source Code submodule ( symba_classes ) s_symba_collision use swiftest contains module function symba_collision_casedisruption ( system , param , colliders , frag ) result ( status ) !! author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Create the fragments resulting from a non-catastrophic disruption collision !! implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( inout ) :: param !! Current run configuration parameters with SyMBA additions class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle colliders object class ( fraggle_fragments ), intent ( inout ) :: frag !! Fraggle fragmentation system object ! Result integer ( I4B ) :: status !! Status flag assigned to this outcome ! Internals integer ( I4B ) :: i , nfrag logical :: lfailure character ( len = STRMAX ) :: message select case ( frag % regime ) case ( COLLRESOLVE_REGIME_DISRUPTION ) message = \"Disruption between\" case ( COLLRESOLVE_REGIME_SUPERCATASTROPHIC ) message = \"Supercatastrophic disruption between\" end select call symba_collision_collider_message ( system % pl , colliders % idx , message ) call fraggle_io_log_one_message ( message ) ! Collisional fragments will be uniformly distributed around the pre-impact barycenter call frag % set_mass_dist ( colliders , param ) ! Generate the position and velocity distributions of the fragments call frag % generate_fragments ( colliders , system , param , lfailure ) if ( lfailure ) then call fraggle_io_log_one_message ( \"No fragment solution found, so treat as a pure hit-and-run\" ) status = ACTIVE nfrag = 0 select type ( pl => system % pl ) class is ( symba_pl ) pl % status ( colliders % idx (:)) = status pl % ldiscard ( colliders % idx (:)) = . false . pl % lcollision ( colliders % idx (:)) = . false . end select else ! Populate the list of new bodies nfrag = frag % nbody write ( message , * ) nfrag call fraggle_io_log_one_message ( \"Generating \" // trim ( adjustl ( message )) // \" fragments\" ) select case ( frag % regime ) case ( COLLRESOLVE_REGIME_DISRUPTION ) status = DISRUPTION case ( COLLRESOLVE_REGIME_SUPERCATASTROPHIC ) status = SUPERCATASTROPHIC end select frag % id ( 1 : nfrag ) = [( i , i = param % maxid + 1 , param % maxid + nfrag )] param % maxid = frag % id ( nfrag ) call symba_collision_mergeaddsub ( system , param , colliders , frag , status ) end if return end function symba_collision_casedisruption module function symba_collision_casehitandrun ( system , param , colliders , frag ) result ( status ) !! author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Create the fragments resulting from a non-catastrophic hit-and-run collision !! implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( inout ) :: param !! Current run configuration parameters with SyMBA additions class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle colliders object class ( fraggle_fragments ), intent ( inout ) :: frag !! Fraggle fragmentation system object ! Result integer ( I4B ) :: status !! Status flag assigned to this outcom ! Internals integer ( I4B ) :: i , ibiggest , nfrag , jtarg , jproj logical :: lpure character ( len = STRMAX ) :: message character ( len = NAMELEN ) :: idstr message = \"Hit and run between\" call symba_collision_collider_message ( system % pl , colliders % idx , message ) call fraggle_io_log_one_message ( trim ( adjustl ( message ))) if ( colliders % mass ( 1 ) > colliders % mass ( 2 )) then jtarg = 1 jproj = 2 else jtarg = 2 jproj = 1 end if if ( frag % mass_dist ( 2 ) > 0.9_DP * colliders % mass ( jproj )) then ! Pure hit and run, so we'll just keep the two bodies untouched call fraggle_io_log_one_message ( \"Pure hit and run. No new fragments generated.\" ) nfrag = 0 lpure = . true . else ! Imperfect hit and run, so we'll keep the largest body and destroy the other lpure = . false . call frag % set_mass_dist ( colliders , param ) ! Generate the position and velocity distributions of the fragments call frag % generate_fragments ( colliders , system , param , lpure ) if ( lpure ) then call fraggle_io_log_one_message ( \"Should have been a pure hit and run instead\" ) nfrag = 0 else nfrag = frag % nbody write ( message , * ) nfrag call fraggle_io_log_one_message ( \"Generating \" // trim ( adjustl ( message )) // \" fragments\" ) end if end if if ( lpure ) then ! Reset these bodies back to being active so that nothing further is done to them status = HIT_AND_RUN_PURE select type ( pl => system % pl ) class is ( symba_pl ) pl % status ( colliders % idx (:)) = ACTIVE pl % ldiscard ( colliders % idx (:)) = . false . pl % lcollision ( colliders % idx (:)) = . false . end select else ibiggest = colliders % idx ( maxloc ( system % pl % Gmass ( colliders % idx (:)), dim = 1 )) frag % id ( 1 ) = system % pl % id ( ibiggest ) frag % id ( 2 : nfrag ) = [( i , i = param % maxid + 1 , param % maxid + nfrag - 1 )] param % maxid = frag % id ( nfrag ) status = HIT_AND_RUN_DISRUPT call symba_collision_mergeaddsub ( system , param , colliders , frag , status ) end if return end function symba_collision_casehitandrun module function symba_collision_casemerge ( system , param , colliders , frag ) result ( status ) !! author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Merge massive bodies. !! !! Adapted from David E. Kaufmann's Swifter routines symba_merge_pl.f90 and symba_discard_merge_pl.f90 !! !! Adapted from Hal Levison's Swift routines symba5_merge.f and discard_mass_merge.f implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( inout ) :: param !! Current run configuration parameters with SyMBA additions class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle colliders object class ( fraggle_fragments ), intent ( inout ) :: frag !! Fraggle fragmentation system object ! Result integer ( I4B ) :: status !! Status flag assigned to this outcome ! Internals integer ( I4B ) :: i , j , k , ibiggest real ( DP ), dimension ( 2 ) :: volume , density real ( DP ) :: pe real ( DP ), dimension ( NDIM ) :: L_spin_new character ( len = NAMELEN ) :: idstr character ( len = STRMAX ) :: message message = \"Merging\" call symba_collision_collider_message ( system % pl , colliders % idx , message ) call fraggle_io_log_one_message ( message ) select type ( pl => system % pl ) class is ( symba_pl ) call frag % set_mass_dist ( colliders , param ) ibiggest = colliders % idx ( maxloc ( pl % Gmass ( colliders % idx (:)), dim = 1 )) frag % id ( 1 ) = pl % id ( ibiggest ) frag % xb (:, 1 ) = frag % xbcom (:) frag % vb (:, 1 ) = frag % vbcom (:) if ( param % lrotation ) then ! Conserve angular momentum by putting pre-impact orbital momentum into spin of the new body L_spin_new (:) = colliders % L_orbit (:, 1 ) + colliders % L_orbit (:, 2 ) + colliders % L_spin (:, 1 ) + colliders % L_spin (:, 2 ) ! Assume prinicpal axis rotation on 3rd Ip axis frag % rot (:, 1 ) = L_spin_new (:) / ( frag % Ip ( 3 , 1 ) * frag % mass ( 1 ) * frag % radius ( 1 ) ** 2 ) else ! If spin is not enabled, we will consider the lost pre-collision angular momentum as \"escaped\" and add it to our bookkeeping variable param % Lescape (:) = param % Lescape (:) + colliders % L_orbit (:, 1 ) + colliders % L_orbit (:, 2 ) end if ! Keep track of the component of potential energy due to the pre-impact colliders%idx for book-keeping pe = 0.0_DP do j = 1 , colliders % ncoll do i = j + 1 , colliders % ncoll pe = pe - pl % Gmass ( i ) * pl % mass ( j ) / norm2 ( pl % xb (:, i ) - pl % xb (:, j )) end do end do param % Ecollisions = param % Ecollisions + pe param % Euntracked = param % Euntracked - pe ! Update any encounter lists that have the removed bodies in them so that they instead point to the new do k = 1 , system % plplenc_list % nenc do j = 1 , colliders % ncoll i = colliders % idx ( j ) if ( i == ibiggest ) cycle if ( system % plplenc_list % id1 ( k ) == pl % id ( i )) then system % plplenc_list % id1 ( k ) = pl % id ( ibiggest ) system % plplenc_list % index1 ( k ) = i end if if ( system % plplenc_list % id2 ( k ) == pl % id ( i )) then system % plplenc_list % id2 ( k ) = pl % id ( ibiggest ) system % plplenc_list % index2 ( k ) = i end if if ( system % plplenc_list % id1 ( k ) == system % plplenc_list % id2 ( k )) system % plplenc_list % status ( k ) = INACTIVE end do end do status = MERGED call symba_collision_mergeaddsub ( system , param , colliders , frag , status ) end select return end function symba_collision_casemerge subroutine symba_collision_collider_message ( pl , collidx , collider_message ) !! author: David A. Minton !! !! Prints a nicely formatted message about which bodies collided, including their names and ids. !! This subroutine appends the body names and ids to an input message. implicit none ! Arguments class ( swiftest_pl ), intent ( in ) :: pl !! Swiftest massive body object integer ( I4B ), dimension (:), intent ( in ) :: collidx !! Index of collisional colliders%idx members character ( * ), intent ( inout ) :: collider_message !! The message to print to the screen. ! Internals integer ( I4B ) :: i , n character ( len = STRMAX ) :: idstr n = size ( collidx ) if ( n == 0 ) return do i = 1 , n if ( i > 1 ) collider_message = trim ( adjustl ( collider_message )) // \" and \" collider_message = \" \" // trim ( adjustl ( collider_message )) // \" \" // trim ( adjustl ( pl % info ( collidx ( i ))% name )) write ( idstr , '(I10)' ) pl % id ( collidx ( i )) collider_message = trim ( adjustl ( collider_message )) // \" (\" // trim ( adjustl ( idstr )) // \") \" end do return end subroutine symba_collision_collider_message module function symba_collision_check_encounter ( self , system , param , t , dt , irec ) result ( lany_collision ) !! author: David A. Minton !! !! Check for merger between massive bodies and test particles in SyMBA !! !! Adapted from David E. Kaufmann's Swifter routine symba_merge.f90 and symba_merge_tp.f90 !! !! Adapted from Hal Levison's Swift routine symba5_merge.f implicit none ! Arguments class ( symba_encounter ), intent ( inout ) :: self !! SyMBA pl-tp encounter list object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! current time real ( DP ), intent ( in ) :: dt !! step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level ! Result logical :: lany_collision !! Returns true if cany pair of encounters resulted in a collision ! Internals logical , dimension (:), allocatable :: lcollision , lmask real ( DP ), dimension ( NDIM ) :: xr , vr integer ( I4B ) :: i , j , k , nenc real ( DP ) :: rlim , Gmtot logical :: isplpl character ( len = STRMAX ) :: timestr , idstri , idstrj , message lany_collision = . false . if ( self % nenc == 0 ) return select type ( self ) class is ( symba_plplenc ) isplpl = . true . class default isplpl = . false . end select select type ( pl => system % pl ) class is ( symba_pl ) select type ( tp => system % tp ) class is ( symba_tp ) nenc = self % nenc nenc = self % nenc allocate ( lmask ( nenc )) lmask (:) = (( self % status ( 1 : nenc ) == ACTIVE ) . and . ( pl % levelg ( self % index1 ( 1 : nenc )) >= irec )) if ( isplpl ) then lmask (:) = lmask (:) . and . ( pl % levelg ( self % index2 ( 1 : nenc )) >= irec ) else lmask (:) = lmask (:) . and . ( tp % levelg ( self % index2 ( 1 : nenc )) >= irec ) end if if (. not . any ( lmask (:))) return allocate ( lcollision ( nenc )) lcollision (:) = . false . if ( isplpl ) then do concurrent ( k = 1 : nenc , lmask ( k )) i = self % index1 ( k ) j = self % index2 ( k ) xr (:) = pl % xh (:, i ) - pl % xh (:, j ) vr (:) = pl % vb (:, i ) - pl % vb (:, j ) rlim = pl % radius ( i ) + pl % radius ( j ) Gmtot = pl % Gmass ( i ) + pl % Gmass ( j ) lcollision ( k ) = symba_collision_check_one ( xr ( 1 ), xr ( 2 ), xr ( 3 ), vr ( 1 ), vr ( 2 ), vr ( 3 ), Gmtot , rlim , dt , self % lvdotr ( k )) end do else do concurrent ( k = 1 : nenc , lmask ( k )) i = self % index1 ( k ) j = self % index2 ( k ) xr (:) = pl % xh (:, i ) - tp % xh (:, j ) vr (:) = pl % vb (:, i ) - tp % vb (:, j ) lcollision ( k ) = symba_collision_check_one ( xr ( 1 ), xr ( 2 ), xr ( 3 ), vr ( 1 ), vr ( 2 ), vr ( 3 ), pl % Gmass ( i ), pl % radius ( i ), dt , self % lvdotr ( k )) end do end if if ( any ( lcollision ( 1 : nenc ))) call pl % xh2xb ( system % cb ) ! Update the central body barycenteric position vector to get us out of DH and into bary do k = 1 , nenc i = self % index1 ( k ) j = self % index2 ( k ) if ( lcollision ( k )) self % status ( k ) = COLLISION self % t ( k ) = t self % x1 (:, k ) = pl % xh (:, i ) + system % cb % xb (:) self % v1 (:, k ) = pl % vb (:, i ) if ( isplpl ) then self % x2 (:, k ) = pl % xh (:, j ) + system % cb % xb (:) self % v2 (:, k ) = pl % vb (:, j ) if ( lcollision ( k )) then ! Check to see if either of these bodies has been involved with a collision before, and if so, make this a collisional colliders%idx if ( pl % lcollision ( i ) . or . pl % lcollision ( j )) call pl % make_colliders ([ i , j ]) ! Set the collision flag for these to bodies to true in case they become involved in another collision later in the step pl % lcollision ([ i , j ]) = . true . pl % status ([ i , j ]) = COLLISION call pl % info ( i )% set_value ( status = \"COLLISION\" , discard_time = t , discard_xh = pl % xh (:, i ), discard_vh = pl % vh (:, i )) call pl % info ( j )% set_value ( status = \"COLLISION\" , discard_time = t , discard_xh = pl % xh (:, j ), discard_vh = pl % vh (:, j )) end if else self % x2 (:, k ) = tp % xh (:, j ) + system % cb % xb (:) self % v2 (:, k ) = tp % vb (:, j ) if ( lcollision ( k )) then tp % status ( j ) = DISCARDED_PLR tp % ldiscard ( j ) = . true . write ( idstri , * ) pl % id ( i ) write ( idstrj , * ) tp % id ( j ) write ( timestr , * ) t call tp % info ( j )% set_value ( status = \"DISCARDED_PLR\" , discard_time = t , discard_xh = tp % xh (:, j ), discard_vh = tp % vh (:, j )) write ( message , * ) \"Particle \" // trim ( adjustl ( tp % info ( j )% name )) // \" (\" // trim ( adjustl ( idstrj )) // \")\" & // \" collided with massive body \" // trim ( adjustl ( pl % info ( i )% name )) // \" (\" // trim ( adjustl ( idstri )) // \")\" & // \" at t = \" // trim ( adjustl ( timestr )) call fraggle_io_log_one_message ( message ) end if end if end do end select end select lany_collision = any ( lcollision (:)) ! Extract the pl-pl encounter list and return the plplcollision_list if ( lany_collision ) then select type ( plplenc_list => self ) class is ( symba_plplenc ) call plplenc_list % extract_collisions ( system , param ) end select end if return end function symba_collision_check_encounter pure elemental function symba_collision_check_one ( xr , yr , zr , vxr , vyr , vzr , Gmtot , rlim , dt , lvdotr ) result ( lcollision ) !! author: David A. Minton !! !! Check for a merger between a single pair of particles !! !! Adapted from David E. Kaufmann's Swifter routines symba_merge_tp.f90 and symba_merge_pl.f90 !! !! Adapted from Hal Levison's Swift routine symba5_merge.f implicit none ! Arguments real ( DP ), intent ( in ) :: xr , yr , zr !! Relative position vector components real ( DP ), intent ( in ) :: vxr , vyr , vzr !! Relative velocity vector components real ( DP ), intent ( in ) :: Gmtot !! Sum of G*mass of colliding bodies real ( DP ), intent ( in ) :: rlim !! Collision limit - Typically the sum of the radii of colliding bodies real ( DP ), intent ( in ) :: dt !! Step size logical , intent ( in ) :: lvdotr !! Logical flag indicating that these two bodies are approaching in the current substep ! Result logical :: lcollision !! Logical flag indicating whether these two bodies will collide or not ! Internals real ( DP ) :: r2 , rlim2 , a , e , q , vdotr , tcr2 , dt2 r2 = xr ** 2 + yr ** 2 + zr ** 2 rlim2 = rlim ** 2 if ( r2 <= rlim2 ) then ! checks if bodies are actively colliding in this time step lcollision = . true . else ! if they are not actively colliding in  this time step, checks if they are going to collide next time step based on velocities and q lcollision = . false . vdotr = xr * vxr + yr * vyr + zr * vzr if ( lvdotr . and . ( vdotr > 0.0_DP )) then tcr2 = r2 / ( vxr ** 2 + vyr ** 2 + vzr ** 2 ) dt2 = dt ** 2 if ( tcr2 <= dt2 ) then call orbel_xv2aeq ( Gmtot , [ xr , yr , zr ], [ vxr , vyr , vzr ], a , e , q ) lcollision = ( q < rlim ) end if end if end if return end function symba_collision_check_one function symba_collision_consolidate_colliders ( pl , cb , param , idx_parent , colliders ) result ( lflag ) !! author: David A. Minton !! !! Loops through the pl-pl collision list and groups families together by index. Outputs the indices of all colliders%idx members, !! and pairs of quantities (x and v vectors, mass, radius, L_spin, and Ip) that can be used to resolve the collisional outcome. implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: pl !! SyMBA massive body object class ( symba_cb ), intent ( inout ) :: cb !! SyMBA central body object class ( symba_parameters ), intent ( in ) :: param !! Current run configuration parameters with SyMBA additions integer ( I4B ), dimension ( 2 ), intent ( inout ) :: idx_parent !! Index of the two bodies considered the \"parents\" of the collision class ( fraggle_colliders ), intent ( out ) :: colliders ! Result logical :: lflag !! Logical flag indicating whether a colliders%idx was successfully created or not ! Internals type collidx_array integer ( I4B ), dimension (:), allocatable :: id integer ( I4B ), dimension (:), allocatable :: idx end type collidx_array type ( collidx_array ), dimension ( 2 ) :: parent_child_index_array integer ( I4B ), dimension ( 2 ) :: nchild integer ( I4B ) :: i , j , ncolliders , idx_child real ( DP ), dimension ( 2 ) :: volume , density real ( DP ) :: mchild , mtot , volchild real ( DP ), dimension ( NDIM ) :: xc , vc , xcom , vcom , xchild , vchild , xcrossv real ( DP ), dimension ( NDIM , 2 ) :: mxc , vcc nchild (:) = pl % kin ( idx_parent (:))% nchild ! If all of these bodies share a parent, but this is still a unique collision, move the last child ! out of the parent's position and make it the secondary body if ( idx_parent ( 1 ) == idx_parent ( 2 )) then if ( nchild ( 1 ) == 0 ) then ! There is only one valid body recorded in this pair (this could happen due to restructuring of the kinship relationships, though it should be rare) lflag = . false . call pl % reset_kinship ([ idx_parent ( 1 )]) return end if idx_parent ( 2 ) = pl % kin ( idx_parent ( 1 ))% child ( nchild ( 1 )) nchild ( 1 ) = nchild ( 1 ) - 1 nchild ( 2 ) = 0 pl % kin ( idx_parent (:))% nchild = nchild (:) pl % kin ( idx_parent ( 2 ))% parent = idx_parent ( 1 ) end if colliders % mass (:) = pl % mass ( idx_parent (:)) ! Note: This is meant to mass, not G*mass, as the collisional regime determination uses mass values that will be converted to Si colliders % radius (:) = pl % radius ( idx_parent (:)) volume (:) = ( 4.0_DP / 3.0_DP ) * PI * colliders % radius (:) ** 3 ! Group together the ids and indexes of each collisional parent and its children do j = 1 , 2 allocate ( parent_child_index_array ( j )% idx ( nchild ( j ) + 1 )) allocate ( parent_child_index_array ( j )% id ( nchild ( j ) + 1 )) associate ( idx_arr => parent_child_index_array ( j )% idx , & id_arr => parent_child_index_array ( j )% id , & ncj => nchild ( j ), & pl => pl , & plkinj => pl % kin ( idx_parent ( j ))) idx_arr ( 1 ) = idx_parent ( j ) if ( ncj > 0 ) idx_arr ( 2 : ncj + 1 ) = plkinj % child ( 1 : ncj ) id_arr (:) = pl % id ( idx_arr (:)) end associate end do ! Consolidate the groups of collsional parents with any children they may have into a single \"colliders%idx\" index array ncolliders = 2 + sum ( nchild (:)) allocate ( colliders % idx ( ncolliders )) colliders % idx = [ parent_child_index_array ( 1 )% idx (:), parent_child_index_array ( 2 )% idx (:)] colliders % ncoll = count ( pl % lcollision ( colliders % idx (:))) colliders % idx = pack ( colliders % idx (:), pl % lcollision ( colliders % idx (:))) colliders % L_spin (:,:) = 0.0_DP colliders % Ip (:,:) = 0.0_DP ! Find the barycenter of each body along with its children, if it has any do j = 1 , 2 colliders % xb (:, j ) = pl % xh (:, idx_parent ( j )) + cb % xb (:) colliders % vb (:, j ) = pl % vb (:, idx_parent ( j )) ! Assume principal axis rotation about axis corresponding to highest moment of inertia (3rd Ip) if ( param % lrotation ) then colliders % Ip (:, j ) = colliders % mass ( j ) * pl % Ip (:, idx_parent ( j )) colliders % L_spin (:, j ) = colliders % Ip ( 3 , j ) * colliders % radius ( j ) ** 2 * pl % rot (:, idx_parent ( j )) end if if ( nchild ( j ) > 0 ) then do i = 1 , nchild ( j ) ! Loop over all children and take the mass weighted mean of the properties idx_child = parent_child_index_array ( j )% idx ( i + 1 ) if (. not . pl % lcollision ( idx_child )) cycle mchild = pl % mass ( idx_child ) xchild (:) = pl % xh (:, idx_child ) + cb % xb (:) vchild (:) = pl % vb (:, idx_child ) volchild = ( 4.0_DP / 3.0_DP ) * PI * pl % radius ( idx_child ) ** 3 volume ( j ) = volume ( j ) + volchild ! Get angular momentum of the child-parent pair and add that to the spin ! Add the child's spin if ( param % lrotation ) then xcom (:) = ( colliders % mass ( j ) * colliders % xb (:, j ) + mchild * xchild (:)) / ( colliders % mass ( j ) + mchild ) vcom (:) = ( colliders % mass ( j ) * colliders % vb (:, j ) + mchild * vchild (:)) / ( colliders % mass ( j ) + mchild ) xc (:) = colliders % xb (:, j ) - xcom (:) vc (:) = colliders % vb (:, j ) - vcom (:) xcrossv (:) = xc (:) . cross . vc (:) colliders % L_spin (:, j ) = colliders % L_spin (:, j ) + colliders % mass ( j ) * xcrossv (:) xc (:) = xchild (:) - xcom (:) vc (:) = vchild (:) - vcom (:) xcrossv (:) = xc (:) . cross . vc (:) colliders % L_spin (:, j ) = colliders % L_spin (:, j ) + mchild * xcrossv (:) colliders % L_spin (:, j ) = colliders % L_spin (:, j ) + mchild * pl % Ip ( 3 , idx_child ) * pl % radius ( idx_child ) ** 2 * pl % rot (:, idx_child ) colliders % Ip (:, j ) = colliders % Ip (:, j ) + mchild * pl % Ip (:, idx_child ) end if ! Merge the child and parent colliders % mass ( j ) = colliders % mass ( j ) + mchild colliders % xb (:, j ) = xcom (:) colliders % vb (:, j ) = vcom (:) end do end if density ( j ) = colliders % mass ( j ) / volume ( j ) colliders % radius ( j ) = ( 3 * volume ( j ) / ( 4 * PI )) ** ( 1.0_DP / 3.0_DP ) if ( param % lrotation ) colliders % Ip (:, j ) = colliders % Ip (:, j ) / colliders % mass ( j ) xcom (:) = ( colliders % mass ( 1 ) * colliders % xb (:, 1 ) + colliders % mass ( 2 ) * colliders % xb (:, 2 )) / sum ( colliders % mass (:)) vcom (:) = ( colliders % mass ( 1 ) * colliders % vb (:, 1 ) + colliders % mass ( 2 ) * colliders % vb (:, 2 )) / sum ( colliders % mass (:)) mxc (:, 1 ) = colliders % mass ( 1 ) * ( colliders % xb (:, 1 ) - xcom (:)) mxc (:, 2 ) = colliders % mass ( 2 ) * ( colliders % xb (:, 2 ) - xcom (:)) vcc (:, 1 ) = colliders % vb (:, 1 ) - vcom (:) vcc (:, 2 ) = colliders % vb (:, 2 ) - vcom (:) colliders % L_orbit (:,:) = mxc (:,:) . cross . vcc (:,:) end do lflag = . true . ! Destroy the kinship relationships for all members of this colliders%idx call pl % reset_kinship ( colliders % idx (:)) return end function symba_collision_consolidate_colliders module subroutine symba_collision_encounter_extract_collisions ( self , system , param ) !! author: David A. Minton !! !! Processes the pl-pl encounter list remove only those encounters that led to a collision !! implicit none ! Arguments class ( symba_plplenc ), intent ( inout ) :: self !! SyMBA pl-pl encounter list class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals logical , dimension (:), allocatable :: lplpl_collision logical , dimension (:), allocatable :: lplpl_unique_parent integer ( I4B ), dimension (:), pointer :: plparent integer ( I4B ), dimension (:), allocatable :: collision_idx , unique_parent_idx integer ( I4B ) :: i , index_coll , ncollisions , nunique_parent , nplplenc select type ( pl => system % pl ) class is ( symba_pl ) associate ( plplenc_list => self , idx1 => self % index1 , idx2 => self % index2 , plparent => pl % kin % parent ) nplplenc = plplenc_list % nenc allocate ( lplpl_collision ( nplplenc )) lplpl_collision (:) = plplenc_list % status ( 1 : nplplenc ) == COLLISION if (. not . any ( lplpl_collision )) return ! Collisions have been detected in this step. So we need to determine which of them are between unique bodies. ! Get the subset of pl-pl encounters that lead to a collision ncollisions = count ( lplpl_collision (:)) allocate ( collision_idx ( ncollisions )) collision_idx = pack ([( i , i = 1 , nplplenc )], lplpl_collision ) ! Get the subset of collisions that involve a unique pair of parents allocate ( lplpl_unique_parent ( ncollisions )) lplpl_unique_parent (:) = plparent ( idx1 ( collision_idx (:))) /= plparent ( idx2 ( collision_idx (:))) nunique_parent = count ( lplpl_unique_parent (:)) allocate ( unique_parent_idx ( nunique_parent )) unique_parent_idx = pack ( collision_idx (:), lplpl_unique_parent (:)) ! Scrub all pl-pl collisions involving unique pairs of parents, which will remove all duplicates and leave behind ! all pairs that have themselves as parents but are not part of the unique parent list. This can hapepn in rare cases ! due to restructuring of parent/child relationships when there are large numbers of multi-body collisions in a single ! step lplpl_unique_parent (:) = . true . do index_coll = 1 , ncollisions associate ( ip1 => plparent ( idx1 ( collision_idx ( index_coll ))), ip2 => plparent ( idx2 ( collision_idx ( index_coll )))) lplpl_unique_parent (:) = . not . ( any ( plparent ( idx1 ( unique_parent_idx (:))) == ip1 ) . or . & any ( plparent ( idx2 ( unique_parent_idx (:))) == ip1 ) . or . & any ( plparent ( idx1 ( unique_parent_idx (:))) == ip2 ) . or . & any ( plparent ( idx2 ( unique_parent_idx (:))) == ip2 ) ) end associate end do ! Reassemble collision index list to include only those containing the unique pairs of parents, plus all the non-unique pairs that don't ! contain a parent body on the unique parent list. ncollisions = nunique_parent + count ( lplpl_unique_parent ) collision_idx = [ unique_parent_idx (:), pack ( collision_idx (:), lplpl_unique_parent (:))] ! Create a mask that contains only the pl-pl encounters that did not result in a collision, and then discard them lplpl_collision (:) = . false . lplpl_collision ( collision_idx (:)) = . true . call plplenc_list % spill ( system % plplcollision_list , lplpl_collision , ldestructive = . true .) ! Extract any encounters that are not collisions from the list. end associate end select return end subroutine symba_collision_encounter_extract_collisions module subroutine symba_collision_make_colliders_pl ( self , idx ) !! author: Jennifer L.L. Pouplin, Carlisle A. wishard, and David A. Minton !! !! When a single body is involved in more than one collision in a single step, it becomes part of a colliders%idx. !! The largest body involved in a multi-body collision is the \"parent\" and all bodies that collide with it are its \"children,\" !! including those that collide with the children. !! !! Adapted from David E. Kaufmann's Swifter routine symba_merge_pl.f90 !! !! Adapted from Hal Levison's Swift routine symba5_merge.f implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), dimension ( 2 ), intent ( in ) :: idx !! Array holding the indices of the two bodies involved in the collision ! Internals integer ( I4B ) :: i , j , index_parent , index_child , p1 , p2 integer ( I4B ) :: nchild_inherit , nchild_orig , nchild_new integer ( I4B ), dimension (:), allocatable :: temp associate ( pl => self ) p1 = pl % kin ( idx ( 1 ))% parent p2 = pl % kin ( idx ( 2 ))% parent if ( p1 == p2 ) return ! This is a collision between to children of a shared parent. We will ignore it. if ( pl % mass ( p1 ) > pl % mass ( p2 )) then index_parent = p1 index_child = p2 else index_parent = p2 index_child = p1 end if ! Expand the child array (or create it if necessary) and copy over the previous lists of children nchild_orig = pl % kin ( index_parent )% nchild nchild_inherit = pl % kin ( index_child )% nchild nchild_new = nchild_orig + nchild_inherit + 1 allocate ( temp ( nchild_new )) if ( nchild_orig > 0 ) temp ( 1 : nchild_orig ) = pl % kin ( index_parent )% child ( 1 : nchild_orig ) ! Find out if the child body has any children of its own. The new parent wil inherit these children if ( nchild_inherit > 0 ) then temp ( nchild_orig + 1 : nchild_orig + nchild_inherit ) = pl % kin ( index_child )% child ( 1 : nchild_inherit ) do i = 1 , nchild_inherit j = pl % kin ( index_child )% child ( i ) ! Set the childrens' parent to the new parent pl % kin ( j )% parent = index_parent end do end if call pl % reset_kinship ([ index_child ]) ! Add the new child to its parent pl % kin ( index_child )% parent = index_parent temp ( nchild_new ) = index_child ! Save the new child array to the parent pl % kin ( index_parent )% nchild = nchild_new call move_alloc ( from = temp , to = pl % kin ( index_parent )% child ) end associate return end subroutine symba_collision_make_colliders_pl subroutine symba_collision_mergeaddsub ( system , param , colliders , frag , status ) !! author:  David A. Minton !! !! Fills the pl_discards and pl_adds with removed and added bodies !! implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( inout ) :: param !! Current run configuration parameters with SyMBA additions class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle colliders object class ( fraggle_fragments ), intent ( inout ) :: frag !! Fraggle fragmentation system object integer ( I4B ), intent ( in ) :: status !! Status flag to assign to adds ! Internals integer ( I4B ) :: i , ibiggest , ismallest , iother , nstart , nend , ncolliders , nfrag logical , dimension ( system % pl % nbody ) :: lmask class ( symba_pl ), allocatable :: plnew , plsub character ( * ), parameter :: FRAGFMT = '(\"Newbody\",I0.7)' character ( len = NAMELEN ) :: newname character ( len = STRMAX ) :: message select type ( pl => system % pl ) class is ( symba_pl ) select type ( pl_discards => system % pl_discards ) class is ( symba_merger ) associate ( info => pl % info , pl_adds => system % pl_adds , cb => system % cb , npl => pl % nbody ) ! Add the colliders%idx bodies to the subtraction list ncolliders = colliders % ncoll nfrag = frag % nbody ! Setup new bodies allocate ( plnew , mold = pl ) call plnew % setup ( nfrag , param ) ibiggest = colliders % idx ( maxloc ( pl % Gmass ( colliders % idx (:)), dim = 1 )) ismallest = colliders % idx ( minloc ( pl % Gmass ( colliders % idx (:)), dim = 1 )) ! Copy over identification, information, and physical properties of the new bodies from the fragment list plnew % id ( 1 : nfrag ) = frag % id ( 1 : nfrag ) plnew % xb (:, 1 : nfrag ) = frag % xb (:, 1 : nfrag ) plnew % vb (:, 1 : nfrag ) = frag % vb (:, 1 : nfrag ) call pl % vb2vh ( cb ) call pl % xh2xb ( cb ) do i = 1 , nfrag plnew % xh (:, i ) = frag % xb (:, i ) - cb % xb (:) plnew % vh (:, i ) = frag % vb (:, i ) - cb % vb (:) end do plnew % mass ( 1 : nfrag ) = frag % mass ( 1 : nfrag ) plnew % Gmass ( 1 : nfrag ) = param % GU * frag % mass ( 1 : nfrag ) plnew % radius ( 1 : nfrag ) = frag % radius ( 1 : nfrag ) plnew % density ( 1 : nfrag ) = frag % mass ( 1 : nfrag ) / frag % radius ( 1 : nfrag ) call plnew % set_rhill ( cb ) select case ( status ) case ( DISRUPTION ) plnew % status ( 1 : nfrag ) = NEW_PARTICLE do i = 1 , nfrag write ( newname , FRAGFMT ) frag % id ( i ) call plnew % info ( i )% set_value ( origin_type = \"Disruption\" , origin_time = param % t , name = newname , origin_xh = plnew % xh (:, i ), origin_vh = plnew % vh (:, i )) end do do i = 1 , ncolliders if ( colliders % idx ( i ) == ibiggest ) then iother = ismallest else iother = ibiggest end if call pl % info ( colliders % idx ( i ))% set_value ( status = \"Disruption\" , discard_time = param % t , discard_xh = pl % xh (:, i ), discard_vh = pl % vh (:, i ), discard_body_id = iother ) end do case ( SUPERCATASTROPHIC ) plnew % status ( 1 : nfrag ) = NEW_PARTICLE do i = 1 , nfrag write ( newname , FRAGFMT ) frag % id ( i ) call plnew % info ( i )% set_value ( origin_type = \"Supercatastrophic\" , origin_time = param % t , name = newname , origin_xh = plnew % xh (:, i ), origin_vh = plnew % vh (:, i )) end do do i = 1 , ncolliders if ( colliders % idx ( i ) == ibiggest ) then iother = ismallest else iother = ibiggest end if call pl % info ( colliders % idx ( i ))% set_value ( status = \"Supercatastrophic\" , discard_time = param % t , discard_xh = pl % xh (:, i ), discard_vh = pl % vh (:, i ), discard_body_id = iother ) end do case ( HIT_AND_RUN_DISRUPT ) call plnew % info ( 1 )% copy ( pl % info ( ibiggest )) plnew % status ( 1 ) = OLD_PARTICLE do i = 2 , nfrag write ( newname , FRAGFMT ) frag % id ( i ) call plnew % info ( i )% set_value ( origin_type = \"Hit and run fragment\" , origin_time = param % t , name = newname , origin_xh = plnew % xh (:, i ), origin_vh = plnew % vh (:, i )) end do do i = 1 , ncolliders if ( colliders % idx ( i ) == ibiggest ) cycle iother = ibiggest call pl % info ( colliders % idx ( i ))% set_value ( status = \"Hit and run fragmention\" , discard_time = param % t , discard_xh = pl % xh (:, i ), discard_vh = pl % vh (:, i ), discard_body_id = iother ) end do case ( MERGED ) call plnew % info ( 1 )% copy ( pl % info ( ibiggest )) plnew % status ( 1 ) = OLD_PARTICLE do i = 1 , ncolliders if ( colliders % idx ( i ) == ibiggest ) cycle iother = ibiggest call pl % info ( colliders % idx ( i ))% set_value ( status = \"MERGED\" , discard_time = param % t , discard_xh = pl % xh (:, i ), discard_vh = pl % vh (:, i ), discard_body_id = iother ) end do end select if ( param % lrotation ) then plnew % Ip (:, 1 : nfrag ) = frag % Ip (:, 1 : nfrag ) plnew % rot (:, 1 : nfrag ) = frag % rot (:, 1 : nfrag ) end if if ( param % ltides ) then plnew % Q = pl % Q ( ibiggest ) plnew % k2 = pl % k2 ( ibiggest ) plnew % tlag = pl % tlag ( ibiggest ) end if !Copy over or set integration parameters for new bodies plnew % lcollision ( 1 : nfrag ) = . false . plnew % ldiscard ( 1 : nfrag ) = . false . plnew % levelg ( 1 : nfrag ) = pl % levelg ( ibiggest ) plnew % levelm ( 1 : nfrag ) = pl % levelm ( ibiggest ) ! Log the properties of the new bodies call fraggle_io_log_pl ( plnew , param ) ! Append the new merged body to the list nstart = pl_adds % nbody + 1 nend = pl_adds % nbody + nfrag call pl_adds % append ( plnew , lsource_mask = [(. true ., i = 1 , nfrag )]) ! Record how many bodies were added in this event pl_adds % ncomp ( nstart : nend ) = plnew % nbody ! Add the discarded bodies to the discard list pl % status ( colliders % idx (:)) = MERGED pl % ldiscard ( colliders % idx (:)) = . true . pl % lcollision ( colliders % idx (:)) = . true . lmask (:) = . false . lmask ( colliders % idx (:)) = . true . call plnew % setup ( 0 , param ) deallocate ( plnew ) allocate ( plsub , mold = pl ) call pl % spill ( plsub , lmask , ldestructive = . false .) nstart = pl_discards % nbody + 1 nend = pl_discards % nbody + ncolliders call pl_discards % append ( plsub , lsource_mask = [(. true ., i = 1 , ncolliders )]) ! Record how many bodies were subtracted in this event pl_discards % ncomp ( nstart : nend ) = ncolliders call plsub % setup ( 0 , param ) deallocate ( plsub ) end associate end select end select return end subroutine symba_collision_mergeaddsub module subroutine symba_collision_resolve_fragmentations ( self , system , param ) !! author: David A. Minton !! !! Process list of collisions, determine the collisional regime, and then create fragments. !! implicit none ! Arguments class ( symba_plplenc ), intent ( inout ) :: self !! SyMBA pl-pl encounter list class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( inout ) :: param !! Current run configuration parameters with SyMBA additions ! Internals ! Internals integer ( I4B ), dimension ( 2 ) :: idx_parent !! Index of the two bodies considered the \"parents\" of the collision real ( DP ), dimension ( NDIM , 2 ) :: x , v , L_spin , Ip !! Output values that represent a 2-body equivalent of a possibly 2+ body collision real ( DP ), dimension ( 2 ) :: mass , radius !! Output values that represent a 2-body equivalent of a possibly 2+ body collision logical :: lgoodcollision integer ( I4B ) :: i type ( fraggle_colliders ) :: colliders !! Fraggle colliders object type ( fraggle_fragments ) :: frag !! Fraggle fragmentation system object associate ( plplcollision_list => self , ncollisions => self % nenc , idx1 => self % index1 , idx2 => self % index2 ) select type ( pl => system % pl ) class is ( symba_pl ) select type ( cb => system % cb ) class is ( symba_cb ) do i = 1 , ncollisions idx_parent ( 1 ) = pl % kin ( idx1 ( i ))% parent idx_parent ( 2 ) = pl % kin ( idx2 ( i ))% parent lgoodcollision = symba_collision_consolidate_colliders ( pl , cb , param , idx_parent , colliders ) if ((. not . lgoodcollision ) . or . any ( pl % status ( idx_parent (:)) /= COLLISION )) cycle call colliders % regime ( frag , system , param ) select case ( frag % regime ) case ( COLLRESOLVE_REGIME_DISRUPTION , COLLRESOLVE_REGIME_SUPERCATASTROPHIC ) plplcollision_list % status ( i ) = symba_collision_casedisruption ( system , param , colliders , frag ) case ( COLLRESOLVE_REGIME_HIT_AND_RUN ) plplcollision_list % status ( i ) = symba_collision_casehitandrun ( system , param , colliders , frag ) case ( COLLRESOLVE_REGIME_MERGE , COLLRESOLVE_REGIME_GRAZE_AND_MERGE ) plplcollision_list % status ( i ) = symba_collision_casemerge ( system , param , colliders , frag ) case default write ( * , * ) \"Error in symba_collision, unrecognized collision regime\" call util_exit ( FAILURE ) end select end do end select end select end associate return end subroutine symba_collision_resolve_fragmentations module subroutine symba_collision_resolve_mergers ( self , system , param ) !! author: David A. Minton !! !! Process list of collisions and merge colliding bodies together. !! implicit none ! Arguments class ( symba_plplenc ), intent ( inout ) :: self !! SyMBA pl-pl encounter list class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( inout ) :: param !! Current run configuration parameters with SyMBA additions ! Internals integer ( I4B ), dimension ( 2 ) :: idx_parent !! Index of the two bodies considered the \"parents\" of the collision real ( DP ), dimension ( NDIM , 2 ) :: x , v , L_spin , Ip !! Output values that represent a 2-body equivalent of a possibly 2+ body collision real ( DP ), dimension ( 2 ) :: mass , radius !! Output values that represent a 2-body equivalent of a possibly 2+ body collision logical :: lgoodcollision integer ( I4B ) :: i type ( fraggle_colliders ) :: colliders !! Fraggle colliders object type ( fraggle_fragments ) :: frag !! Fraggle fragmentation system object associate ( plplcollision_list => self , ncollisions => self % nenc , idx1 => self % index1 , idx2 => self % index2 ) select type ( pl => system % pl ) class is ( symba_pl ) select type ( cb => system % cb ) class is ( symba_cb ) do i = 1 , ncollisions idx_parent ( 1 ) = pl % kin ( idx1 ( i ))% parent idx_parent ( 2 ) = pl % kin ( idx2 ( i ))% parent lgoodcollision = symba_collision_consolidate_colliders ( pl , cb , param , idx_parent , colliders ) if (. not . lgoodcollision ) cycle if ( any ( pl % status ( idx_parent (:)) /= COLLISION )) cycle ! One of these two bodies has already been resolved frag % regime = COLLRESOLVE_REGIME_MERGE frag % mtot = sum ( colliders % mass (:)) frag % xbcom (:) = ( colliders % mass ( 1 ) * colliders % xb (:, 1 ) + colliders % mass ( 2 ) * colliders % xb (:, 2 )) / frag % mtot frag % vbcom (:) = ( colliders % mass ( 1 ) * colliders % vb (:, 1 ) + colliders % mass ( 2 ) * colliders % vb (:, 2 )) / frag % mtot plplcollision_list % status ( i ) = symba_collision_casemerge ( system , param , colliders , frag ) end do end select end select end associate return end subroutine symba_collision_resolve_mergers module subroutine symba_collision_resolve_plplenc ( self , system , param , t , dt , irec ) !! author: David A. Minton !! !! Process the pl-pl collision list, then modifiy the massive bodies based on the outcome of the collision !! implicit none ! Arguments class ( symba_plplenc ), intent ( inout ) :: self !! SyMBA pl-pl encounter list class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters with SyMBA additions real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Current simulation step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level ! Internals real ( DP ) :: Eorbit_before , Eorbit_after logical :: lplpl_collision character ( len = STRMAX ) :: timestr class ( symba_parameters ), allocatable :: tmp_param associate ( plplenc_list => self , plplcollision_list => system % plplcollision_list ) select type ( pl => system % pl ) class is ( symba_pl ) select type ( param ) class is ( symba_parameters ) if ( plplcollision_list % nenc == 0 ) return ! No collisions to resolve ! Make sure that the heliocentric and barycentric coordinates are consistent with each other call pl % vb2vh ( system % cb ) call pl % xh2xb ( system % cb ) ! Get the energy before the collision is resolved if ( param % lenergy ) then call system % get_energy_and_momentum ( param ) Eorbit_before = system % te end if do write ( timestr , * ) t call fraggle_io_log_one_message ( \"\" ) call fraggle_io_log_one_message ( \"***********************************************************************************************************************\" ) call fraggle_io_log_one_message ( \"Collision between massive bodies detected at time t = \" // trim ( adjustl ( timestr ))) call fraggle_io_log_one_message ( \"***********************************************************************************************************************\" ) allocate ( tmp_param , source = param ) tmp_param % t = t if ( param % lfragmentation ) then call plplcollision_list % resolve_fragmentations ( system , param ) else call plplcollision_list % resolve_mergers ( system , param ) end if ! Destroy the collision list now that the collisions are resolved call plplcollision_list % setup ( 0 ) if (( system % pl_adds % nbody == 0 ) . and . ( system % pl_discards % nbody == 0 )) exit ! Save the add/discard information to file call system % write_discard ( tmp_param ) ! Rearrange the arrays: Remove discarded bodies, add any new bodies, resort, and recompute all indices and encounter lists call pl % rearray ( system , tmp_param ) ! Destroy the add/discard list so that we don't append the same body multiple times if another collision is detected call system % pl_discards % setup ( 0 , param ) call system % pl_adds % setup ( 0 , param ) deallocate ( tmp_param ) ! Check whether or not any of the particles that were just added are themselves in a collision state. This will generate a new plplcollision_list lplpl_collision = plplenc_list % collision_check ( system , param , t , dt , irec ) if (. not . lplpl_collision ) exit end do if ( param % lenergy ) then call system % get_energy_and_momentum ( param ) Eorbit_after = system % te param % Ecollisions = param % Ecollisions + ( Eorbit_after - Eorbit_before ) end if end select end select end associate return end subroutine symba_collision_resolve_plplenc module subroutine symba_collision_resolve_pltpenc ( self , system , param , t , dt , irec ) !! author: David A. Minton !! !! Process the pl-tp collision list, then modifiy the massive bodies based on the outcome of the collision !! implicit none ! Arguments class ( symba_pltpenc ), intent ( inout ) :: self !! SyMBA pl-pl encounter list class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters with SyMBA additions real ( DP ), intent ( in ) :: t !! Current simulation tim real ( DP ), intent ( in ) :: dt !! Current simulation step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level call system % tp % xh2xb ( system % cb ) call system % tp % discard ( system , param ) return end subroutine symba_collision_resolve_pltpenc end submodule s_symba_collision","tags":"","loc":"sourcefile/symba_collision.f90.html"},{"title":"symba_setup.f90 – swiftest","text":"This file depends on sourcefile~~symba_setup.f90~~EfferentGraph sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_setup.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_symba_setup Source Code symba_setup.f90 Source Code submodule ( symba_classes ) s_symba_setup use swiftest contains module subroutine symba_setup_initialize_system ( self , param ) !! author: David A. Minton !! !! Initialize an SyMBA nbody system from files and sets up the planetocentric structures. !! This subroutine will also sort the massive bodies in descending order by mass !! implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i , j ! Call parent method associate ( system => self ) call helio_setup_initialize_system ( system , param ) call system % pltpenc_list % setup ( 0 ) call system % plplenc_list % setup ( 0 ) call system % plplcollision_list % setup ( 0 ) end associate return end subroutine symba_setup_initialize_system module subroutine symba_setup_merger ( self , n , param ) !! author: David A. Minton !! !! Allocate SyMBA test particle structure !! !! Equivalent in functionality to David E. Kaufmann's Swifter routine symba_setup.f90 implicit none ! Arguments class ( symba_merger ), intent ( inout ) :: self !! SyMBA merger list object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameter ! Internals integer ( I4B ) :: i !> Call allocation method for parent class. In this case, helio_pl does not have its own setup method so we use the base method for swiftest_pl call symba_setup_pl ( self , n , param ) if ( n < 0 ) return if ( allocated ( self % ncomp )) deallocate ( self % ncomp ) if ( n == 0 ) return allocate ( self % ncomp ( n )) self % ncomp (:) = 0 return end subroutine symba_setup_merger module subroutine symba_setup_pl ( self , n , param ) !! author: David A. Minton !! !! Allocate SyMBA test particle structure !! !! Equivalent in functionality to David E. Kaufmann's Swifter routine symba_setup.f90 implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameter ! Internals integer ( I4B ) :: i !> Call allocation method for parent class. In this case, helio_pl does not have its own setup method so we use the base method for swiftest_pl call setup_pl ( self , n , param ) if ( n < 0 ) return if ( allocated ( self % lcollision )) deallocate ( self % lcollision ) if ( allocated ( self % lencounter )) deallocate ( self % lencounter ) if ( allocated ( self % lmtiny )) deallocate ( self % lmtiny ) if ( allocated ( self % nplenc )) deallocate ( self % nplenc ) if ( allocated ( self % ntpenc )) deallocate ( self % ntpenc ) if ( allocated ( self % levelg )) deallocate ( self % levelg ) if ( allocated ( self % levelm )) deallocate ( self % levelm ) if ( allocated ( self % isperi )) deallocate ( self % isperi ) if ( allocated ( self % peri )) deallocate ( self % peri ) if ( allocated ( self % atp )) deallocate ( self % atp ) if ( allocated ( self % kin )) deallocate ( self % kin ) if ( n == 0 ) return allocate ( self % lcollision ( n )) allocate ( self % lencounter ( n )) allocate ( self % lmtiny ( n )) allocate ( self % nplenc ( n )) allocate ( self % ntpenc ( n )) allocate ( self % levelg ( n )) allocate ( self % levelm ( n )) allocate ( self % isperi ( n )) allocate ( self % peri ( n )) allocate ( self % atp ( n )) allocate ( self % kin ( n )) self % lcollision (:) = . false . self % lencounter (:) = . false . self % lmtiny (:) = . false . self % nplenc (:) = 0 self % ntpenc (:) = 0 self % levelg (:) = - 1 self % levelm (:) = - 1 self % isperi (:) = 0 self % peri (:) = 0.0_DP self % atp (:) = 0.0_DP call self % reset_kinship ([( i , i = 1 , n )]) return end subroutine symba_setup_pl module subroutine symba_setup_encounter ( self , n ) !! author: David A. Minton !! !! A constructor that sets the number of encounters and allocates and initializes all arrays !! implicit none ! Arguments class ( symba_encounter ), intent ( inout ) :: self !! SyMBA pl-tp encounter structure integer ( I4B ), intent ( in ) :: n !! Number of encounters to allocate space for call setup_encounter ( self , n ) if ( n < 0 ) return if ( allocated ( self % level )) deallocate ( self % level ) if ( n == 0 ) return allocate ( self % level ( n )) self % level (:) = - 1 return end subroutine symba_setup_encounter module subroutine symba_setup_tp ( self , n , param ) !! author: David A. Minton !! !! Allocate WHM test particle structure !! !! Equivalent in functionality to David E. Kaufmann's Swifter routine whm_setup.f90 implicit none ! Arguments class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameter !> Call allocation method for parent class. In this case, helio_tp does not have its own setup method so we use the base method for swiftest_tp call setup_tp ( self , n , param ) if ( n < 0 ) return if ( allocated ( self % nplenc )) deallocate ( self % nplenc ) if ( allocated ( self % levelg )) deallocate ( self % levelg ) if ( allocated ( self % levelm )) deallocate ( self % levelm ) if ( allocated ( self % info )) deallocate ( self % info ) if ( n == 0 ) return allocate ( self % nplenc ( n )) allocate ( self % levelg ( n )) allocate ( self % levelm ( n )) allocate ( self % info ( n )) self % nplenc (:) = 0 self % levelg (:) = - 1 self % levelm (:) = - 1 return end subroutine symba_setup_tp end submodule s_symba_setup","tags":"","loc":"sourcefile/symba_setup.f90.html"},{"title":"symba_kick.f90 – swiftest","text":"This file depends on sourcefile~~symba_kick.f90~~EfferentGraph sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_kick.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_symba_kick Source Code symba_kick.f90 Source Code submodule ( symba_classes ) s_symba_kick use swiftest contains module subroutine symba_kick_getacch_int_pl ( self ) !! author: David A. Minton !! !! Compute direct cross (third) term heliocentric accelerations of massive bodies, with no mutual interactions between bodies below GMTINY !! !! Adapted from Hal Levison's Swift routine symba5_helio_getacch.f !! Adapted from David E. Kaufmann's Swifter routine helio_kick_getacch_int.f90 implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self call kick_getacch_int_all_pl ( self % nbody , self % nplplm , self % k_plpl , self % xh , self % Gmass , self % radius , self % ah ) return end subroutine symba_kick_getacch_int_pl module subroutine symba_kick_getacch_pl ( self , system , param , t , lbeg ) !! author: David A. Minton !! !! Compute heliocentric accelerations of massive bodies !! !! Adapted from David E. Kaufmann's Swifter routine symba_kick_getacch.f90 !! Adapted from Hal Levison's Swift routine symba5_kick_getacch.f implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step ! Internals integer ( I4B ) :: i , j integer ( I8B ) :: k , nplplenc real ( DP ) :: rjj , rlim2 , xr , yr , zr real ( DP ), dimension ( NDIM , self % nbody ) :: ah_enc integer ( I4B ), dimension (:,:), allocatable :: k_plpl_enc if ( self % nbody == 0 ) return select type ( system ) class is ( symba_nbody_system ) associate ( pl => self , npl => self % nbody , plplenc_list => system % plplenc_list , radius => self % radius ) ! Apply kicks to all bodies (including those in the encounter list) call helio_kick_getacch_pl ( pl , system , param , t , lbeg ) if ( plplenc_list % nenc > 0 ) then ! Remove kicks from bodies involved currently in the encounter list, as these are dealt with separately. nplplenc = int ( plplenc_list % nenc , kind = I8B ) allocate ( k_plpl_enc ( 2 , nplplenc )) k_plpl_enc (:, 1 : nplplenc ) = pl % k_plpl (:, plplenc_list % kidx ( 1 : nplplenc )) ah_enc (:,:) = 0.0_DP call kick_getacch_int_all_pl ( npl , nplplenc , k_plpl_enc , pl % xh , pl % Gmass , pl % radius , ah_enc ) pl % ah (:, 1 : npl ) = pl % ah (:, 1 : npl ) - ah_enc (:, 1 : npl ) end if end associate end select return end subroutine symba_kick_getacch_pl module subroutine symba_kick_getacch_tp ( self , system , param , t , lbeg ) !! author: David A. Minton !! !! Compute heliocentric accelerations of test particles !! !! Adapted from David E. Kaufmann's Swifter routine symba_kick_getacch_tp.f90 !! Adapted from Hal Levison's Swift routine symba5_kick_getacch.f implicit none ! Arguments class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step ! Internals integer ( I4B ) :: i , j , k real ( DP ) :: rjj , fac , rlim2 real ( DP ), dimension ( NDIM ) :: dx if ( self % nbody == 0 ) return select type ( system ) class is ( symba_nbody_system ) associate ( tp => self , cb => system % cb , pl => system % pl , pltpenc_list => system % pltpenc_list , npltpenc => system % pltpenc_list % nenc ) call helio_kick_getacch_tp ( tp , system , param , t , lbeg ) ! Remove accelerations from encountering pairs do k = 1 , npltpenc i = pltpenc_list % index1 ( k ) j = pltpenc_list % index2 ( k ) if ( tp % lmask ( j )) then if ( lbeg ) then dx (:) = tp % xh (:, j ) - pl % xbeg (:, i ) else dx (:) = tp % xh (:, j ) - pl % xend (:, i ) end if rjj = dot_product ( dx (:), dx (:)) fac = pl % Gmass ( i ) / ( rjj * sqrt ( rjj )) tp % ah (:, j ) = tp % ah (:, j ) + fac * dx (:) end if end do end associate end select return end subroutine symba_kick_getacch_tp module subroutine symba_kick_encounter ( self , system , dt , irec , sgn ) !! author: David A. Minton !! !! Kick barycentric velocities of massive bodies and ACTIVE test particles within SyMBA recursion. !! Note: This method works for the polymorphic symba_pltpenc and symba_plplenc types !! !! Adapted from David E. Kaufmann's Swifter routine: symba_kick.f90 !! Adapted from Hal Levison's Swift routine symba5_kick.f implicit none ! Arguments class ( symba_encounter ), intent ( in ) :: self !! SyMBA pl-tp encounter list object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object real ( DP ), intent ( in ) :: dt !! step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level integer ( I4B ), intent ( in ) :: sgn !! sign to be applied to acceleration ! Internals integer ( I4B ) :: i , j , irm1 , irecl , ngood integer ( I8B ) :: k real ( DP ) :: r , rr , ri , ris , rim1 , r2 , ir3 , fac , faci , facj real ( DP ), dimension ( NDIM ) :: dx logical :: isplpl logical , dimension (:), allocatable :: lgoodlevel integer ( I4B ), dimension (:), allocatable :: good_idx if ( self % nenc == 0 ) return select type ( self ) class is ( symba_plplenc ) isplpl = . true . class is ( symba_pltpenc ) isplpl = . false . end select select type ( pl => system % pl ) class is ( symba_pl ) select type ( tp => system % tp ) class is ( symba_tp ) associate ( npl => pl % nbody , ntp => tp % nbody , nenc => self % nenc ) if ( npl > 0 ) pl % lmask ( 1 : npl ) = pl % status ( 1 : npl ) /= INACTIVE if ( ntp > 0 ) tp % lmask ( 1 : ntp ) = tp % status ( 1 : ntp ) /= INACTIVE allocate ( lgoodlevel ( nenc )) irm1 = irec - 1 if ( sgn < 0 ) then irecl = irec - 1 else irecl = irec end if do k = 1 , nenc i = self % index1 ( k ) j = self % index2 ( k ) if ( isplpl ) then lgoodlevel ( k ) = ( pl % levelg ( i ) >= irm1 ) . and . ( pl % levelg ( j ) >= irm1 ) else lgoodlevel ( k ) = ( pl % levelg ( i ) >= irm1 ) . and . ( tp % levelg ( j ) >= irm1 ) end if lgoodlevel ( k ) = ( self % status ( k ) == ACTIVE ) . and . lgoodlevel ( k ) end do ngood = count ( lgoodlevel (:)) if ( ngood > 0_I8B ) then allocate ( good_idx ( ngood )) good_idx (:) = pack ([( i , i = 1 , nenc )], lgoodlevel (:)) if ( isplpl ) then do concurrent ( k = 1 : ngood ) i = self % index1 ( good_idx ( k )) j = self % index2 ( good_idx ( k )) pl % ah (:, i ) = 0.0_DP pl % ah (:, j ) = 0.0_DP end do else do concurrent ( k = 1_I8B : ngood ) j = self % index2 ( good_idx ( k )) tp % ah (:, j ) = 0.0_DP end do end if do k = 1 , ngood i = self % index1 ( good_idx ( k )) j = self % index2 ( good_idx ( k )) if ( isplpl ) then ri = (( pl % rhill ( i ) + pl % rhill ( j )) ** 2 ) * ( RHSCALE ** 2 ) * ( RSHELL ** ( 2 * irecl )) rim1 = ri * ( RSHELL ** 2 ) dx (:) = pl % xh (:, j ) - pl % xh (:, i ) else ri = (( pl % rhill ( i )) ** 2 ) * ( RHSCALE ** 2 ) * ( RSHELL ** ( 2 * irecl )) rim1 = ri * ( RSHELL ** 2 ) dx (:) = tp % xh (:, j ) - pl % xh (:, i ) end if r2 = dot_product ( dx (:), dx (:)) if ( r2 < rim1 ) then fac = 0.0_DP lgoodlevel ( good_idx ( k )) = . false . cycle end if if ( r2 < ri ) then ris = sqrt ( ri ) r = sqrt ( r2 ) rr = ( ris - r ) / ( ris * ( 1.0_DP - RSHELL )) fac = ( r2 ** ( - 1.5_DP )) * ( 1.0_DP - 3 * ( rr ** 2 ) + 2 * ( rr ** 3 )) else ir3 = 1.0_DP / ( r2 * sqrt ( r2 )) fac = ir3 end if faci = fac * pl % Gmass ( i ) if ( isplpl ) then facj = fac * pl % Gmass ( j ) pl % ah (:, i ) = pl % ah (:, i ) + facj * dx (:) pl % ah (:, j ) = pl % ah (:, j ) - faci * dx (:) else tp % ah (:, j ) = tp % ah (:, j ) - faci * dx (:) end if end do ngood = count ( lgoodlevel (:)) if ( ngood == 0_I8B ) return good_idx ( 1 : ngood ) = pack ([( i , i = 1 , nenc )], lgoodlevel (:)) if ( isplpl ) then do k = 1 , ngood i = self % index1 ( good_idx ( k )) j = self % index2 ( good_idx ( k )) pl % vb (:, i ) = pl % vb (:, i ) + sgn * dt * pl % ah (:, i ) pl % vb (:, j ) = pl % vb (:, j ) + sgn * dt * pl % ah (:, j ) pl % ah (:, i ) = 0.0_DP pl % ah (:, j ) = 0.0_DP end do else do k = 1 , ngood j = self % index2 ( good_idx ( k )) tp % vb (:, j ) = tp % vb (:, j ) + sgn * dt * tp % ah (:, j ) tp % ah (:, j ) = 0.0_DP end do end if end if end associate end select end select return end subroutine symba_kick_encounter end submodule s_symba_kick","tags":"","loc":"sourcefile/symba_kick.f90.html"},{"title":"symba_encounter_check.f90 – swiftest","text":"This file depends on sourcefile~~symba_encounter_check.f90~~EfferentGraph sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_encounter_check.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_symba_encounter_check Source Code symba_encounter_check.f90 Source Code submodule ( symba_classes ) s_symba_encounter_check use swiftest contains subroutine symba_encounter_check_all ( nplplm , k_plpl , x , v , rhill , dt , irec , lencounter , loc_lvdotr ) !! author: David A. Minton !! !! Check for encounters between massive bodies. Split off from the main subroutine for performance implicit none integer ( I8B ), intent ( in ) :: nplplm integer ( I4B ), dimension (:,:), intent ( in ) :: k_plpl real ( DP ), dimension (:,:), intent ( in ) :: x , v real ( DP ), dimension (:), intent ( in ) :: rhill real ( DP ), intent ( in ) :: dt integer ( I4B ), intent ( in ) :: irec logical , dimension (:), intent ( out ) :: lencounter , loc_lvdotr ! Internals integer ( I8B ) :: k integer ( I4B ) :: i , j real ( DP ) :: xr , yr , zr , vxr , vyr , vzr , rhill1 , rhill2 !$omp parallel do simd default(private) schedule(static)& !$omp shared(nplplm, k_plpl, x, v, rhill,  dt, irec, lencounter, loc_lvdotr) & !$omp lastprivate(xr, yr, zr, vxr, vyr, vzr, rhill1, rhill2) do k = 1_I8B , nplplm i = k_plpl ( 1 , k ) j = k_plpl ( 2 , k ) xr = x ( 1 , j ) - x ( 1 , i ) yr = x ( 2 , j ) - x ( 2 , i ) zr = x ( 3 , j ) - x ( 3 , i ) vxr = v ( 1 , j ) - v ( 1 , i ) vyr = v ( 2 , j ) - v ( 2 , i ) vzr = v ( 3 , j ) - v ( 3 , i ) rhill1 = rhill ( i ) rhill2 = rhill ( j ) call symba_encounter_check_one ( xr , yr , zr , vxr , vyr , vzr , rhill1 , rhill2 , dt , irec , lencounter ( k ), loc_lvdotr ( k )) end do !$omp end parallel do simd return end subroutine symba_encounter_check_all module function symba_encounter_check_pl ( self , system , dt , irec ) result ( lany_encounter ) !! author: David A. Minton !! !! Check for an encounter between massive bodies. !! implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA test particle object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object real ( DP ), intent ( in ) :: dt !! step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level ! Result logical :: lany_encounter !! Returns true if there is at least one close encounter ! Internals integer ( I8B ) :: k , nplplm , kenc integer ( I4B ) :: i , j , nenc , npl logical , dimension (:), allocatable :: lencounter , loc_lvdotr , lvdotr integer ( I4B ), dimension (:), allocatable :: index1 , index2 if ( self % nbody == 0 ) return associate ( pl => self ) nplplm = pl % nplplm npl = pl % nbody allocate ( lencounter ( nplplm )) allocate ( loc_lvdotr ( nplplm )) call symba_encounter_check_all ( nplplm , pl % k_plpl , pl % xh , pl % vh , pl % rhill , dt , irec , lencounter , loc_lvdotr ) nenc = count ( lencounter (:)) lany_encounter = nenc > 0 if ( lany_encounter ) then associate ( plplenc_list => system % plplenc_list ) call plplenc_list % resize ( nenc ) allocate ( lvdotr ( nenc )) allocate ( index1 ( nenc )) allocate ( index2 ( nenc )) lvdotr (:) = pack ( loc_lvdotr (:), lencounter (:)) index1 (:) = pack ( pl % k_plpl ( 1 , 1 : nplplm ), lencounter (:)) index2 (:) = pack ( pl % k_plpl ( 2 , 1 : nplplm ), lencounter (:)) deallocate ( lencounter , loc_lvdotr ) call move_alloc ( lvdotr , plplenc_list % lvdotr ) call move_alloc ( index1 , plplenc_list % index1 ) call move_alloc ( index2 , plplenc_list % index2 ) do k = 1 , nenc i = plplenc_list % index1 ( k ) j = plplenc_list % index2 ( k ) call util_index_eucl_ij_to_k ( npl , i , j , kenc ) plplenc_list % kidx ( k ) = kenc plplenc_list % id1 ( k ) = pl % id ( plplenc_list % index1 ( k )) plplenc_list % id2 ( k ) = pl % id ( plplenc_list % index2 ( k )) plplenc_list % status ( k ) = ACTIVE plplenc_list % level ( k ) = irec pl % lencounter ( i ) = . true . pl % lencounter ( j ) = . true . pl % levelg ( i ) = irec pl % levelm ( i ) = irec pl % levelg ( j ) = irec pl % levelm ( j ) = irec pl % nplenc ( i ) = pl % nplenc ( i ) + 1 pl % nplenc ( j ) = pl % nplenc ( j ) + 1 end do end associate end if end associate return end function symba_encounter_check_pl module function symba_encounter_check ( self , system , dt , irec ) result ( lany_encounter ) !! author: David A. Minton !! !! Check for an encounter between test particles and massive bodies in the pltpenc list. !! Note: This method works for the polymorphic symba_pltpenc and symba_plplenc types. !! !! Adapted from portions of David E. Kaufmann's Swifter routine: symba_step_recur.f90 implicit none ! Arguments class ( symba_encounter ), intent ( inout ) :: self !! SyMBA pl-pl encounter list object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object real ( DP ), intent ( in ) :: dt !! step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level logical :: lany_encounter !! Returns true if there is at least one close encounter ! Internals integer ( I4B ) :: i , j , k , lidx , nenc_enc real ( DP ), dimension ( NDIM ) :: xr , vr logical :: lencounter , isplpl real ( DP ) :: rlim2 , rji2 logical , dimension (:), allocatable :: lencmask integer ( I4B ), dimension (:), allocatable :: encidx lany_encounter = . false . if ( self % nenc == 0 ) return select type ( self ) class is ( symba_plplenc ) isplpl = . true . class is ( symba_pltpenc ) isplpl = . false . end select select type ( pl => system % pl ) class is ( symba_pl ) select type ( tp => system % tp ) class is ( symba_tp ) allocate ( lencmask ( self % nenc )) lencmask (:) = ( self % status ( 1 : self % nenc ) == ACTIVE ) . and . ( self % level ( 1 : self % nenc ) == irec - 1 ) nenc_enc = count ( lencmask (:)) if ( nenc_enc == 0 ) return allocate ( encidx ( nenc_enc )) encidx (:) = pack ([( k , k = 1 , self % nenc )], lencmask (:)) do lidx = 1 , nenc_enc k = encidx ( lidx ) i = self % index1 ( k ) j = self % index2 ( k ) if ( isplpl ) then xr (:) = pl % xh (:, j ) - pl % xh (:, i ) vr (:) = pl % vb (:, j ) - pl % vb (:, i ) call symba_encounter_check_one ( xr ( 1 ), xr ( 2 ), xr ( 3 ), vr ( 1 ), vr ( 2 ), vr ( 3 ), pl % rhill ( i ), pl % rhill ( j ), dt , irec , lencounter , self % lvdotr ( k )) else xr (:) = tp % xh (:, j ) - pl % xh (:, i ) vr (:) = tp % vb (:, j ) - pl % vb (:, i ) call symba_encounter_check_one ( xr ( 1 ), xr ( 2 ), xr ( 3 ), vr ( 1 ), vr ( 2 ), vr ( 3 ), pl % rhill ( i ), 0.0_DP , dt , irec , lencounter , self % lvdotr ( k )) end if if ( lencounter ) then if ( isplpl ) then rlim2 = ( pl % radius ( i ) + pl % radius ( j )) ** 2 else rlim2 = ( pl % radius ( i )) ** 2 end if rji2 = dot_product ( xr (:), xr (:)) ! Check to see if these are physically overlapping bodies first, which we should ignore if ( rji2 > rlim2 ) then lany_encounter = . true . pl % levelg ( i ) = irec pl % levelm ( i ) = MAX ( irec , pl % levelm ( i )) if ( isplpl ) then pl % levelg ( j ) = irec pl % levelm ( j ) = MAX ( irec , pl % levelm ( j )) else tp % levelg ( j ) = irec tp % levelm ( j ) = MAX ( irec , tp % levelm ( j )) end if self % level ( k ) = irec end if end if end do end select end select return end function symba_encounter_check module function symba_encounter_check_tp ( self , system , dt , irec ) result ( lany_encounter ) !! author: David A. Minton !! !! Check for an encounter between test particles and massive bodies. !! implicit none ! Arguments class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object real ( DP ), intent ( in ) :: dt !! step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level ! Result logical :: lany_encounter !! Returns true if there is at least one close encounter ! Internals real ( DP ) :: r2crit , vdotr , r2 , v2 , tmin , r2min , term2 integer ( I4B ) :: i , j , k , nenc , plind , tpind real ( DP ), dimension ( NDIM ) :: xr , vr logical , dimension (:,:), allocatable :: lencounter , loc_lvdotr if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody , pl => system % pl , npl => system % pl % nbody ) allocate ( lencounter ( ntp , npl ), loc_lvdotr ( ntp , npl )) lencounter (:,:) = . false . do j = 1 , npl do i = 1 , ntp xr ( 1 ) = tp % xh ( 1 , i ) - pl % xh ( 1 , j ) xr ( 2 ) = tp % xh ( 2 , i ) - pl % xh ( 2 , j ) xr ( 3 ) = tp % xh ( 3 , i ) - pl % xh ( 3 , j ) vr ( 1 ) = tp % vh ( 1 , i ) - pl % vh ( 1 , j ) vr ( 2 ) = tp % vh ( 2 , i ) - pl % vh ( 2 , j ) vr ( 3 ) = tp % vh ( 3 , i ) - pl % vh ( 3 , j ) call symba_encounter_check_one ( xr ( 1 ), xr ( 2 ), xr ( 3 ), vr ( 1 ), vr ( 2 ), vr ( 3 ), pl % rhill ( j ), 0.0_DP , dt , irec , lencounter ( i , j ), loc_lvdotr ( i , j )) end do end do nenc = count ( lencounter (:,:)) lany_encounter = nenc > 0 if ( lany_encounter ) then associate ( pltpenc_list => system % pltpenc_list ) call pltpenc_list % resize ( nenc ) pltpenc_list % status ( 1 : nenc ) = ACTIVE pltpenc_list % level ( 1 : nenc ) = irec pltpenc_list % lvdotr ( 1 : nenc ) = pack ( loc_lvdotr ( 1 : ntp , 1 : npl ), lencounter ( 1 : ntp , 1 : npl )) pltpenc_list % index1 ( 1 : nenc ) = pack ( spread ([( i , i = 1 , npl )], dim = 1 , ncopies = ntp ), lencounter ( 1 : ntp , 1 : npl )) pltpenc_list % index2 ( 1 : nenc ) = pack ( spread ([( i , i = 1 , ntp )], dim = 2 , ncopies = npl ), lencounter ( 1 : ntp , 1 : npl )) pltpenc_list % id1 ( 1 : nenc ) = pl % id ( pltpenc_list % index1 ( 1 : nenc )) pltpenc_list % id2 ( 1 : nenc ) = tp % id ( pltpenc_list % index2 ( 1 : nenc )) select type ( pl ) class is ( symba_pl ) pl % lencounter ( 1 : npl ) = . false . do k = 1 , nenc plind = pltpenc_list % index1 ( k ) tpind = pltpenc_list % index2 ( k ) pl % lencounter ( plind ) = . true . pl % levelg ( plind ) = irec pl % levelm ( plind ) = irec tp % levelg ( tpind ) = irec tp % levelm ( tpind ) = irec pl % ntpenc ( plind ) = pl % ntpenc ( plind ) + 1 tp % nplenc ( tpind ) = tp % nplenc ( tpind ) + 1 end do end select end associate end if end associate return end function symba_encounter_check_tp module pure subroutine symba_encounter_check_one ( xr , yr , zr , vxr , vyr , vzr , rhill1 , rhill2 , dt , irec , lencounter , lvdotr ) !$omp declare simd(symba_encounter_check_one) !! author: David A. Minton !! !! Check for an encounter. !! !! Adapted from David E. Kaufmann's Swifter routine: symba_chk.f90 !! Adapted from Hal Levison's Swift routine symba5_chk.f implicit none ! Arguments real ( DP ), intent ( in ) :: xr , yr , zr , vxr , vyr , vzr real ( DP ), intent ( in ) :: rhill1 , rhill2 , dt integer ( I4B ), intent ( in ) :: irec logical , intent ( out ) :: lencounter , lvdotr ! Internals real ( DP ) :: r2crit , rshell_irec integer ( I4B ) :: i rshell_irec = 1._DP do i = 1 , irec rshell_irec = rshell_irec * RSHELL end do r2crit = ( rhill1 + rhill2 ) * RHSCALE * rshell_irec r2crit = r2crit ** 2 call rmvs_chk_ind ( xr , yr , zr , vxr , vyr , vzr , dt , r2crit , lencounter , lvdotr ) return end subroutine symba_encounter_check_one end submodule s_symba_encounter_check","tags":"","loc":"sourcefile/symba_encounter_check.f90.html"},{"title":"symba_io.f90 – swiftest","text":"This file depends on sourcefile~~symba_io.f90~~EfferentGraph sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_io.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_symba_io Source Code symba_io.f90 Source Code submodule ( symba_classes ) s_symba_io use swiftest contains module subroutine symba_io_param_reader ( self , unit , iotype , v_list , iostat , iomsg ) !! author: The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Read in parameters specific to the SyMBA integrator, then calls the base io_param_reader. !! !! Adapted from David E. Kaufmann's Swifter routine io_init_param.f90 !! Adapted from Martin Duncan's Swift routine io_init_param.f implicit none ! Arguments class ( symba_parameters ), intent ( inout ) :: self !! Collection of parameters integer , intent ( in ) :: unit !! File unit number character ( len =* ), intent ( in ) :: iotype !! Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. !!    If you do not include a char-literal-constant, the iotype argument contains only DT. integer , intent ( in ) :: v_list (:) !! The first element passes the integrator code to the reader integer , intent ( out ) :: iostat !! IO status code character ( len =* ), intent ( inout ) :: iomsg !! Message to pass if iostat /= 0 ! internals integer ( I4B ) :: ilength , ifirst , ilast !! Variables used to parse input file character ( STRMAX ) :: line !! Line of the input file character ( len = :), allocatable :: line_trim , param_name , param_value !! Strings used to parse the param file integer ( I4B ) :: nseeds , nseeds_from_file , i logical :: seed_set = . false . !! Is the random seed set in the input file? character ( len =* ), parameter :: linefmt = '(A)' associate ( param => self ) call io_param_reader ( param , unit , iotype , v_list , iostat , iomsg ) call random_seed ( size = nseeds ) if ( allocated ( param % seed )) deallocate ( param % seed ) allocate ( param % seed ( nseeds )) rewind ( unit ) do read ( unit = unit , fmt = linefmt , iostat = iostat , end = 1 , err = 667 , iomsg = iomsg ) line line_trim = trim ( adjustl ( line )) ilength = len ( line_trim ) if (( ilength /= 0 )) then ifirst = 1 ! Read the pair of tokens. The first one is the parameter name, the second is the value. param_name = io_get_token ( line_trim , ifirst , ilast , iostat ) if ( param_name == '' ) cycle ! No parameter name (usually because this line is commented out) call io_toupper ( param_name ) ifirst = ilast + 1 param_value = io_get_token ( line_trim , ifirst , ilast , iostat ) select case ( param_name ) case ( \"FRAGMENTATION\" ) call io_toupper ( param_value ) if ( param_value == \"YES\" . or . param_value == \"T\" ) self % lfragmentation = . true . case ( \"GMTINY\" ) read ( param_value , * ) param % GMTINY case ( \"MIN_GMFRAG\" ) read ( param_value , * ) param % min_GMfrag case ( \"SEED\" ) read ( param_value , * ) nseeds_from_file ! Because the number of seeds can vary between compilers/systems, we need to make sure we can handle cases in which the input file has a different ! number of seeds than the current system. If the number of seeds in the file is smaller than required, we will use them as a source to fill in the missing elements. ! If the number of seeds in the file is larger than required, we will truncate the seed array. if ( nseeds_from_file > nseeds ) then nseeds = nseeds_from_file deallocate ( param % seed ) allocate ( param % seed ( nseeds )) do i = 1 , nseeds ifirst = ilast + 2 param_value = io_get_token ( line , ifirst , ilast , iostat ) read ( param_value , * ) param % seed ( i ) end do else ! Seed array in file is too small do i = 1 , nseeds_from_file ifirst = ilast + 2 param_value = io_get_token ( line , ifirst , ilast , iostat ) read ( param_value , * ) param % seed ( i ) end do param % seed ( nseeds_from_file + 1 : nseeds ) = [( param % seed ( 1 ) - param % seed ( nseeds_from_file ) + i , i = nseeds_from_file + 1 , nseeds )] end if seed_set = . true . end select end if end do 1 continue if ( self % GMTINY < 0.0_DP ) then write ( iomsg , * ) \"GMTINY invalid or not set: \" , self % GMTINY iostat = - 1 return else write ( * , * ) \"GMTINY          = \" , self % GMTINY end if write ( * , * ) \"FRAGMENTATION = \" , param % lfragmentation if ( param % lfragmentation ) then if ( seed_set ) then call random_seed ( put = param % seed ) else call random_seed ( get = param % seed ) end if write ( * , * ) \"SEED: N,VAL    = \" , size ( param % seed ), param % seed (:) if ( param % min_GMfrag < 0.0_DP ) param % min_GMfrag = param % GMTINY write ( * , * ) \"MIN_GMFRAG      = \" , self % min_GMfrag end if if (. not . self % lclose ) then write ( iomsg , * ) 'This integrator requires CHK_CLOSE to be enabled.' iostat = - 1 return end if ! All reporting of collision information in SyMBA (including mergers) is now recorded in the Fraggle logfile call fraggle_io_log_start ( param ) end associate iostat = 0 667 continue return end subroutine symba_io_param_reader module subroutine symba_io_param_writer ( self , unit , iotype , v_list , iostat , iomsg ) !! author: David A. Minton !! !! Dump integration parameters specific to SyMBA to file and then call the base io_param_writer method. !! !! Adapted from David E. Kaufmann's Swifter routine io_dump_param.f90 !! Adapted from Martin Duncan's Swift routine io_dump_param.f implicit none ! Arguments class ( symba_parameters ), intent ( in ) :: self !! Collection of SyMBA parameters integer , intent ( in ) :: unit !! File unit number character ( len =* ), intent ( in ) :: iotype !! Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. !!    If you do not include a char-literal-constant, the iotype argument contains only DT. integer , intent ( in ) :: v_list (:) !! Not used in this procedure integer , intent ( out ) :: iostat !! IO status code character ( len =* ), intent ( inout ) :: iomsg !! Message to pass if iostat /= 0 ! Internals character ( * ), parameter :: Ifmt = '(I0)' !! Format label for integer values character ( * ), parameter :: Rfmt = '(ES25.17)' !! Format label for real values character ( * ), parameter :: Rarrfmt = '(3(ES25.17,1X))' !! Format label for real values character ( * ), parameter :: Lfmt = '(L1)' !! Format label for logical values character ( len = NAMELEN ) :: param_name character ( len = STRMAX ) :: param_value type character_array character ( 25 ) :: value end type character_array type ( character_array ), dimension (:), allocatable :: param_array integer ( I4B ) :: i , nstr associate ( param => self ) call io_param_writer ( param , unit , iotype , v_list , iostat , iomsg ) ! Special handling is required for writing the random number seed array as its size is not known until runtime ! For the \"SEED\" parameter line, the first value will be the size of the seed array and the rest will be the seed array elements write ( param_name , * ) \"GMTINY\" ; write ( param_value , Rfmt ) param % GMTINY ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"MIN_GMFRAG\" ; write ( param_value , Rfmt ) param % min_GMfrag ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) write ( param_name , * ) \"FRAGMENTATION\" ; write ( param_value , Lfmt ) param % lfragmentation ; write ( unit , * , err = 667 , iomsg = iomsg ) adjustl ( param_name ) // trim ( adjustl ( param_value )) if ( param % lfragmentation ) then write ( param_name , * ) \"SEED\" if ( allocated ( param_array )) deallocate ( param_array ) allocate ( param_array ( 0 : size ( param % seed ))) write ( param_array ( 0 )% value , Ifmt ) size ( param % seed ) do i = 1 , size ( param % seed ) write ( param_array ( i )% value , Ifmt ) param % seed ( i ) end do write ( unit , '(\" \",A32)' , advance = 'no' , err = 667 , iomsg = iomsg ) adjustl ( param_name ) do i = 0 , size ( param % seed ) nstr = len ( trim ( adjustl ( param_array ( i )% value ))) if ( i < size ( param % seed )) then write ( unit , '(A12)' , advance = 'no' , err = 667 , iomsg = iomsg ) trim ( adjustl ( param_array ( i )% value )) // \" \" else write ( unit , '(A12)' , err = 667 , iomsg = iomsg ) trim ( adjustl ( param_array ( i )% value )) end if end do end if iostat = 0 end associate return 667 continue write ( * , * ) \"Error writing parameter file for SyMBA: \" // trim ( adjustl ( iomsg )) end subroutine symba_io_param_writer module subroutine symba_io_write_discard ( self , param ) implicit none class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals integer ( I4B ), parameter :: LUN = 40 integer ( I4B ) :: iadd , isub , j , nsub , nadd logical , save :: lfirst = . true . real ( DP ), dimension (:,:), allocatable :: vh character ( * ), parameter :: HDRFMT = '(E23.16, 1X, I8, 1X, L1)' character ( * ), parameter :: NAMEFMT = '(A, 2(1X, I8))' character ( * ), parameter :: VECFMT = '(3(E23.16, 1X))' character ( * ), parameter :: NPLFMT = '(I8)' character ( * ), parameter :: PLNAMEFMT = '(I8, 2(1X, E23.16))' class ( swiftest_body ), allocatable :: pltemp character ( STRMAX ) :: errmsg , out_stat associate ( pl => self % pl , npl => self % pl % nbody , pl_adds => self % pl_adds ) if ( self % tp_discards % nbody > 0 ) call io_write_discard ( self , param ) select type ( pl_discards => self % pl_discards ) class is ( symba_merger ) if ( pl_discards % nbody == 0 ) return ! Record the discarded body metadata information to file if (( param % out_type == NETCDF_FLOAT_TYPE ) . or . ( param % out_type == NETCDF_DOUBLE_TYPE )) then call param % nciu % open ( param ) call pl_discards % write_particle_info ( param % nciu ) call param % nciu % close ( param ) end if if ( param % discard_out == \"\" ) return if ( lfirst ) then out_stat = param % out_stat else out_stat = 'APPEND' end if select case ( out_stat ) case ( 'APPEND' ) open ( unit = LUN , file = param % discard_out , status = 'OLD' , position = 'APPEND' , form = 'FORMATTED' , err = 667 , iomsg = errmsg ) case ( 'NEW' , 'REPLACE' , 'UNKNOWN' ) open ( unit = LUN , file = param % discard_out , status = param % out_stat , form = 'FORMATTED' , err = 667 , iomsg = errmsg ) case default write ( * , * ) 'Invalid status code for OUT_STAT: ' , trim ( adjustl ( param % out_stat )) call util_exit ( FAILURE ) end select lfirst = . false . if ( param % lgr ) then call pl_discards % pv2v ( param ) call pl_adds % pv2v ( param ) end if write ( LUN , HDRFMT , err = 667 , iomsg = errmsg ) param % t , pl_discards % nbody , param % lbig_discard iadd = 1 isub = 1 do while ( iadd <= pl_adds % nbody ) nadd = pl_adds % ncomp ( iadd ) nsub = pl_discards % ncomp ( isub ) do j = 1 , nadd if ( iadd <= pl_adds % nbody ) then write ( LUN , NAMEFMT , err = 667 , iomsg = errmsg ) ADD , pl_adds % id ( iadd ), pl_adds % status ( iadd ) write ( LUN , VECFMT , err = 667 , iomsg = errmsg ) pl_adds % xh ( 1 , iadd ), pl_adds % xh ( 2 , iadd ), pl_adds % xh ( 3 , iadd ) write ( LUN , VECFMT , err = 667 , iomsg = errmsg ) pl_adds % vh ( 1 , iadd ), pl_adds % vh ( 2 , iadd ), pl_adds % vh ( 3 , iadd ) else exit end if iadd = iadd + 1 end do do j = 1 , nsub if ( isub <= pl_discards % nbody ) then write ( LUN , NAMEFMT , err = 667 , iomsg = errmsg ) SUB , pl_discards % id ( isub ), pl_discards % status ( isub ) write ( LUN , VECFMT , err = 667 , iomsg = errmsg ) pl_discards % xh ( 1 , isub ), pl_discards % xh ( 2 , isub ), pl_discards % xh ( 3 , isub ) write ( LUN , VECFMT , err = 667 , iomsg = errmsg ) pl_discards % vh ( 1 , isub ), pl_discards % vh ( 2 , isub ), pl_discards % vh ( 3 , isub ) else exit end if isub = isub + 1 end do end do close ( LUN ) end select end associate return 667 continue write ( * , * ) \"Error writing discard file: \" // trim ( adjustl ( errmsg )) call util_exit ( FAILURE ) end subroutine symba_io_write_discard end submodule s_symba_io","tags":"","loc":"sourcefile/symba_io.f90.html"},{"title":"symba_discard.f90 – swiftest","text":"This file depends on sourcefile~~symba_discard.f90~~EfferentGraph sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_discard.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_symba_discard Source Code symba_discard.f90 Source Code submodule ( symba_classes ) s_symba_discard use swiftest contains subroutine symba_discard_cb_pl ( pl , system , param ) !! author: David A. Minton !! !! Check to see if planets should be discarded based on their positions relative to the central body. !! If a body gets flagged here when it has also been previously flagged for a collision with another massive body, !! its collisional status will be revoked. Discards due to colliding with or escaping the central body take precedence !! over pl-pl collisions !! !! Adapted from David E. Kaufmann's Swifter routine: symba_discard_sun.f90 !! Adapted from Hal Levison's Swift routine discard_massive5.f implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: pl !! SyMBA massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i , j real ( DP ) :: energy , vb2 , rb2 , rh2 , rmin2 , rmax2 , rmaxu2 character ( len = STRMAX ) :: idstr , timestr , message associate ( npl => pl % nbody , cb => system % cb ) call system % set_msys () rmin2 = param % rmin ** 2 rmax2 = param % rmax ** 2 rmaxu2 = param % rmaxu ** 2 do i = 1 , npl if ( pl % status ( i ) == ACTIVE ) then rh2 = dot_product ( pl % xh (:, i ), pl % xh (:, i )) if (( param % rmax >= 0.0_DP ) . and . ( rh2 > rmax2 )) then pl % ldiscard ( i ) = . true . pl % lcollision ( i ) = . false . pl % status ( i ) = DISCARDED_RMAX write ( idstr , * ) pl % id ( i ) write ( timestr , * ) param % t write ( message , * ) trim ( adjustl ( pl % info ( i )% name )) // \" (\" // trim ( adjustl ( idstr )) // \")\" // \" too far from the central body at t = \" // trim ( adjustl ( timestr )) call fraggle_io_log_one_message ( \"\" ) call fraggle_io_log_one_message ( \"***********************************************************************************************************************\" ) call fraggle_io_log_one_message ( message ) call fraggle_io_log_one_message ( \"***********************************************************************************************************************\" ) call fraggle_io_log_one_message ( \"\" ) call pl % info ( i )% set_value ( status = \"DISCARDED_RMAX\" , discard_time = param % t , discard_xh = pl % xh (:, i ), discard_vh = pl % vh (:, i )) else if (( param % rmin >= 0.0_DP ) . and . ( rh2 < rmin2 )) then pl % ldiscard ( i ) = . true . pl % lcollision ( i ) = . false . pl % status ( i ) = DISCARDED_RMIN write ( idstr , * ) pl % id ( i ) write ( timestr , * ) param % t write ( message , * ) trim ( adjustl ( pl % info ( i )% name )) // \" (\" // trim ( adjustl ( idstr )) // \")\" // \" too close to the central body at t = \" // trim ( adjustl ( timestr )) call fraggle_io_log_one_message ( \"\" ) call fraggle_io_log_one_message ( \"***********************************************************************************************************************\" ) call fraggle_io_log_one_message ( message ) call fraggle_io_log_one_message ( \"***********************************************************************************************************************\" ) call fraggle_io_log_one_message ( \"\" ) call pl % info ( i )% set_value ( status = \"DISCARDED_RMIN\" , discard_time = param % t , discard_xh = pl % xh (:, i ), discard_vh = pl % vh (:, i ), discard_body_id = cb % id ) else if ( param % rmaxu >= 0.0_DP ) then rb2 = dot_product ( pl % xb (:, i ), pl % xb (:, i )) vb2 = dot_product ( pl % vb (:, i ), pl % vb (:, i )) energy = 0.5_DP * vb2 - system % Gmtot / sqrt ( rb2 ) if (( energy > 0.0_DP ) . and . ( rb2 > rmaxu2 )) then pl % ldiscard ( i ) = . true . pl % lcollision ( i ) = . false . pl % status ( i ) = DISCARDED_RMAXU write ( idstr , * ) pl % id ( i ) write ( timestr , * ) param % t write ( message , * ) trim ( adjustl ( pl % info ( i )% name )) // \" (\" // trim ( adjustl ( idstr )) // \")\" // \" is unbound and too far from barycenter at t = \" // trim ( adjustl ( timestr )) call fraggle_io_log_one_message ( \"\" ) call fraggle_io_log_one_message ( \"***********************************************************************************************************************\" ) call fraggle_io_log_one_message ( message ) call fraggle_io_log_one_message ( \"***********************************************************************************************************************\" ) call fraggle_io_log_one_message ( \"\" ) call pl % info ( i )% set_value ( status = \"DISCARDED_RMAXU\" , discard_time = param % t , discard_xh = pl % xh (:, i ), discard_vh = pl % vh (:, i )) end if end if end if end do end associate return end subroutine symba_discard_cb_pl subroutine symba_discard_conserve_mtm ( pl , system , param , ipl , lescape_body ) !! author: David A. Minton !! !! Conserves system momentum when a body is lost from the system or collides with central body implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: pl class ( symba_nbody_system ), intent ( inout ) :: system class ( symba_parameters ), intent ( inout ) :: param integer ( I4B ), intent ( in ) :: ipl logical , intent ( in ) :: lescape_body ! Internals real ( DP ), dimension ( NDIM ) :: Lpl , Ltot , Lcb , xcom , vcom real ( DP ) :: pe , ke_orbit , ke_spin integer ( I4B ) :: i , oldstat select type ( cb => system % cb ) class is ( symba_cb ) ! Add the potential and kinetic energy of the lost body to the records pe = - cb % Gmass * pl % mass ( ipl ) / norm2 ( pl % xb (:, ipl ) - cb % xb (:)) ke_orbit = 0.5_DP * pl % mass ( ipl ) * dot_product ( pl % vb (:, ipl ), pl % vb (:, ipl )) if ( param % lrotation ) then ke_spin = 0.5_DP * pl % mass ( ipl ) * pl % radius ( ipl ) ** 2 * pl % Ip ( 3 , ipl ) * dot_product ( pl % rot (:, ipl ), pl % rot (:, ipl )) else ke_spin = 0.0_DP end if ! Add the pre-collision ke of the central body to the records ! Add planet mass to central body accumulator if ( lescape_body ) then param % GMescape = param % GMescape + pl % Gmass ( ipl ) do i = 1 , pl % nbody if ( i == ipl ) cycle pe = pe - pl % Gmass ( i ) * pl % mass ( ipl ) / norm2 ( pl % xb (:, ipl ) - pl % xb (:, i )) end do Ltot (:) = 0.0_DP do i = 1 , pl % nbody Lpl (:) = pL % mass ( i ) * ( pl % xb (:, i ) . cross . pl % vb (:, i )) Ltot (:) = Ltot (:) + Lpl (:) end do Ltot (:) = Ltot (:) + cb % mass * ( cb % xb (:) . cross . cb % vb (:)) call pl % b2h ( cb ) oldstat = pl % status ( ipl ) pl % status ( ipl ) = INACTIVE call pl % h2b ( cb ) pl % status ( ipl ) = oldstat do i = 1 , pl % nbody if ( i == ipl ) cycle Lpl (:) = pl % mass ( i ) * ( pl % xb (:, i ) . cross . pl % vb (:, i )) Ltot (:) = Ltot (:) - Lpl (:) end do Ltot (:) = Ltot (:) - cb % mass * ( cb % xb (:) . cross . cb % vb (:)) param % Lescape (:) = param % Lescape (:) + Ltot (:) if ( param % lrotation ) param % Lescape (:) = param % Lescape + pl % mass ( ipl ) * pl % radius ( ipl ) ** 2 * pl % Ip ( 3 , ipl ) * pl % rot (:, ipl ) else xcom (:) = ( pl % mass ( ipl ) * pl % xb (:, ipl ) + cb % mass * cb % xb (:)) / ( cb % mass + pl % mass ( ipl )) vcom (:) = ( pl % mass ( ipl ) * pl % vb (:, ipl ) + cb % mass * cb % vb (:)) / ( cb % mass + pl % mass ( ipl )) Lpl (:) = ( pl % xb (:, ipl ) - xcom (:)) . cross . ( pL % vb (:, ipl ) - vcom (:)) if ( param % lrotation ) Lpl (:) = pl % mass ( ipl ) * ( Lpl (:) + pl % radius ( ipl ) ** 2 * pl % Ip ( 3 , ipl ) * pl % rot (:, ipl )) Lcb (:) = cb % mass * (( cb % xb (:) - xcom (:)) . cross . ( cb % vb (:) - vcom (:))) ke_orbit = ke_orbit + 0.5_DP * cb % mass * dot_product ( cb % vb (:), cb % vb (:)) if ( param % lrotation ) ke_spin = ke_spin + 0.5_DP * cb % mass * cb % radius ** 2 * cb % Ip ( 3 ) * dot_product ( cb % rot (:), cb % rot (:)) ! Update mass of central body to be consistent with its total mass cb % dGM = cb % dGM + pl % Gmass ( ipl ) cb % dR = cb % dR + 1.0_DP / 3.0_DP * ( pl % radius ( ipl ) / cb % radius ) ** 3 - 2.0_DP / 9.0_DP * ( pl % radius ( ipl ) / cb % radius ) ** 6 cb % Gmass = cb % GM0 + cb % dGM cb % mass = cb % Gmass / param % GU cb % radius = cb % R0 + cb % dR param % rmin = cb % radius ! Add planet angular momentum to central body accumulator cb % dL (:) = Lpl (:) + Lcb (:) + cb % dL (:) ! Update rotation of central body to by consistent with its angular momentum if ( param % lrotation ) then cb % rot (:) = ( cb % L0 (:) + cb % dL (:)) / ( cb % Ip ( 3 ) * cb % mass * cb % radius ** 2 ) ke_spin = ke_spin - 0.5_DP * cb % mass * cb % radius ** 2 * cb % Ip ( 3 ) * dot_product ( cb % rot (:), cb % rot (:)) end if cb % xb (:) = xcom (:) cb % vb (:) = vcom (:) ke_orbit = ke_orbit - 0.5_DP * cb % mass * dot_product ( cb % vb (:), cb % vb (:)) end if call pl % b2h ( cb ) ! We must do this for proper book-keeping, since we can no longer track this body's contribution to energy directly if ( lescape_body ) then param % Ecollisions = param % Ecollisions + ke_orbit + ke_spin + pe param % Euntracked = param % Euntracked - ( ke_orbit + ke_spin + pe ) else param % Ecollisions = param % Ecollisions + pe param % Euntracked = param % Euntracked - pe end if end select return end subroutine symba_discard_conserve_mtm subroutine symba_discard_nonplpl ( pl , system , param ) !! author: David A. Minton !! !! Check to see if planets should be discarded based on their positions or because they are unbound !s !! !! Adapted from David E. Kaufmann's Swifter routine: symba_discard_pl.f90 !! Adapted from Hal Levison's Swift routine discard_massive5.f implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: pl !! SyMBA test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals logical , dimension ( pl % nbody ) :: ldiscard integer ( I4B ) :: i , nstart , nend , nsub class ( symba_pl ), allocatable :: plsub ! First check for collisions with the central body associate ( npl => pl % nbody , cb => system % cb ) if ( npl == 0 ) return select type ( pl_discards => system % pl_discards ) class is ( symba_merger ) if (( param % rmin >= 0.0_DP ) . or . ( param % rmax >= 0.0_DP ) . or . ( param % rmaxu >= 0.0_DP )) then call symba_discard_cb_pl ( pl , system , param ) end if if ( param % qmin >= 0.0_DP ) call symba_discard_peri_pl ( pl , system , param ) if ( any ( pl % ldiscard ( 1 : npl ))) then ldiscard ( 1 : npl ) = pl % ldiscard ( 1 : npl ) allocate ( plsub , mold = pl ) call pl % spill ( plsub , ldiscard , ldestructive = . false .) nsub = plsub % nbody nstart = pl_discards % nbody + 1 nend = pl_discards % nbody + nsub call pl_discards % append ( plsub , lsource_mask = [(. true ., i = 1 , nsub )]) ! Record how many bodies were subtracted in this event pl_discards % ncomp ( nstart : nend ) = nsub end if end select end associate return end subroutine symba_discard_nonplpl subroutine symba_discard_nonplpl_conservation ( pl , system , param ) !! author: David A. Minton !! !! If there are any bodies that are removed due to either colliding with the central body or escaping the systme, !! we need to track the conserved quantities with the system bookkeeping terms. implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: pl !! SyMBA test particle object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i , ndiscard , dstat logical :: lescape logical , dimension ( pl % nbody ) :: discard_l_pl integer ( I4B ), dimension (:), allocatable :: discard_index_list associate ( npl => pl % nbody ) discard_l_pl ( 1 : npl ) = pl % ldiscard ( 1 : npl ) . and . . not . pl % lcollision ( 1 : npl ) ! These are bodies that are discarded but not flagged as pl-pl collision ndiscard = count ( discard_l_pl (:)) allocate ( discard_index_list ( ndiscard )) discard_index_list (:) = pack ([( i , i = 1 , npl )], discard_l_pl ( 1 : npl )) do i = 1 , ndiscard dstat = pl % status ( discard_index_list ( i )) if (( dstat == DISCARDED_RMIN ) . or . ( dstat == DISCARDED_PERI )) then lescape = . false . else if (( dstat == DISCARDED_RMAX ) . or . ( dstat == DISCARDED_RMAXU )) then lescape = . true . else cycle end if ! Conserve all the quantities call symba_discard_conserve_mtm ( pl , system , param , discard_index_list ( i ), lescape ) end do end associate return end subroutine symba_discard_nonplpl_conservation subroutine symba_discard_peri_pl ( pl , system , param ) !! author: David A. Minton !! !! Check to see if a test particle should be discarded because its perihelion distance becomes too small !! !! Adapted from David E. Kaufmann's Swifter routine: symba_discard_peri_pl.f90 !! Adapted from Hal Levison's Swift routine discard_mass_peri.f implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: pl !! SyMBA massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals logical , save :: lfirst = . true . logical :: lfirst_orig integer ( I4B ) :: i character ( len = STRMAX ) :: timestr , idstr lfirst_orig = pl % lfirst pl % lfirst = lfirst if ( lfirst ) then call pl % get_peri ( system , param ) lfirst = . false . else call pl % get_peri ( system , param ) do i = 1 , pl % nbody if ( pl % status ( i ) == ACTIVE ) then if (( pl % isperi ( i ) == 0 ) . and . ( pl % nplenc ( i ) == 0 )) then if (( pl % atp ( i ) >= param % qmin_alo ) . and . ( pl % atp ( i ) <= param % qmin_ahi ) . and . ( pl % peri ( i ) <= param % qmin )) then pl % ldiscard ( i ) = . true . pl % lcollision ( i ) = . false . pl % status ( i ) = DISCARDED_PERI write ( timestr , * ) param % t write ( idstr , * ) pl % id ( i ) write ( * , * ) trim ( adjustl ( pl % info ( i )% name )) // \" (\" // trim ( adjustl ( idstr )) // \") perihelion distance too small at t = \" // trim ( adjustl ( timestr )) call pl % info ( i )% set_value ( status = \"DISCARDED_PERI\" , discard_time = param % t , discard_xh = pl % xh (:, i ), discard_vh = pl % vh (:, i ), discard_body_id = system % cb % id ) end if end if end if end do end if pl % lfirst = lfirst_orig return end subroutine symba_discard_peri_pl module subroutine symba_discard_pl ( self , system , param ) !! author: David A. Minton !! !! Call the various flavors of discards for massive bodies in SyMBA runs, including discards due to colliding with the central body or escaping the system implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! SyMBA test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals real ( DP ) :: Eorbit_before , Eorbit_after select type ( system ) class is ( symba_nbody_system ) select type ( param ) class is ( symba_parameters ) associate ( pl => self , plplenc_list => system % plplenc_list , plplcollision_list => system % plplcollision_list ) call pl % vb2vh ( system % cb ) call pl % xh2xb ( system % cb ) call plplenc_list % write ( pl , pl , param ) call symba_discard_nonplpl ( self , system , param ) if (. not . any ( pl % ldiscard (:))) return if ( param % lenergy ) then call system % get_energy_and_momentum ( param ) Eorbit_before = system % te end if call symba_discard_nonplpl_conservation ( self , system , param ) ! Save the add/discard information to file call system % write_discard ( param ) call pl % rearray ( system , param ) if ( param % lenergy ) then call system % get_energy_and_momentum ( param ) Eorbit_after = system % te param % Ecollisions = param % Ecollisions + ( Eorbit_after - Eorbit_before ) end if end associate end select end select return end subroutine symba_discard_pl end submodule s_symba_discard","tags":"","loc":"sourcefile/symba_discard.f90.html"},{"title":"symba_step.f90 – swiftest","text":"This file depends on sourcefile~~symba_step.f90~~EfferentGraph sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_step.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_symba_step Source Code symba_step.f90 Source Code submodule ( symba_classes ) s_symba_step use swiftest contains module subroutine symba_step_system ( self , param , t , dt ) !! author: David A. Minton !! !! Step planets and active test particles ahead in democratic heliocentric coordinates, descending the recursive !!   branch if necessary to handle possible close encounters !! !! Adapted from David E. Kaufmann's Swifter routine: symba_step.f90 !! Adapted from Hal Levison's Swift routine symba5_step_pl.f implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize ! Internals logical :: lencounter select type ( pl => self % pl ) class is ( symba_pl ) select type ( tp => self % tp ) class is ( symba_tp ) select type ( param ) class is ( symba_parameters ) call self % reset ( param ) lencounter = pl % encounter_check ( self , dt , 0 ) . or . tp % encounter_check ( self , dt , 0 ) if ( lencounter ) then call self % interp ( param , t , dt ) param % lfirstkick = . true . else self % irec = - 1 call helio_step_system ( self , param , t , dt ) end if end select end select end select return end subroutine symba_step_system module subroutine symba_step_interp_system ( self , param , t , dt ) !! author: David A. Minton !! !! Step planets and active test particles ahead in democratic heliocentric coordinates, calling the recursive !!         subroutine to descend to the appropriate level to handle close encounters !! !! Adapted from David E. Kaufmann's Swifter routine: symba_step_interp.f90 !! Adapted from Hal Levison's Swift routine symba5_step_interp.f implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize ! Internals real ( DP ) :: dth !! Half step size dth = 0.5_DP * dt associate ( system => self ) select type ( pl => system % pl ) class is ( symba_pl ) select type ( tp => system % tp ) class is ( symba_tp ) select type ( cb => system % cb ) class is ( symba_cb ) system % irec = - 1 call pl % vh2vb ( cb ) call pl % lindrift ( cb , dth , lbeg = . true .) call pl % kick ( system , param , t , dth , lbeg = . true .) call pl % drift ( system , param , dt ) call tp % vh2vb ( vbcb = - cb % ptbeg ) call tp % lindrift ( cb , dth , lbeg = . true .) call tp % kick ( system , param , t , dth , lbeg = . true .) call tp % drift ( system , param , dt ) call system % recursive_step ( param , t , 0 ) call pl % kick ( system , param , t , dth , lbeg = . false .) call pl % vb2vh ( cb ) call pl % lindrift ( cb , dth , lbeg = . false .) call tp % kick ( system , param , t , dth , lbeg = . false .) call tp % vb2vh ( vbcb = - cb % ptend ) call tp % lindrift ( cb , dth , lbeg = . false .) end select end select end select end associate return end subroutine symba_step_interp_system module subroutine symba_step_set_recur_levels_system ( self , ireci ) !! author: David A. Minton !! !! Resets pl, tp,and encounter structures at the start of a new step !! !! Adapted from David E. Kaufmann's Swifter routine: symba_step_recur.f90 !! Adapted from Hal Levison's Swift routine symba5_step_recur.f implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object integer ( I4B ), intent ( in ) :: ireci !! Input recursion level ! Internals integer ( I4B ) :: k , irecp associate ( system => self , plplenc_list => self % plplenc_list , pltpenc_list => self % pltpenc_list , npl => self % pl % nbody , ntp => self % tp % nbody ) select type ( pl => self % pl ) class is ( symba_pl ) select type ( tp => self % tp ) class is ( symba_tp ) irecp = ireci + 1 if ( npl > 0 ) where ( pl % levelg ( 1 : npl ) == irecp ) pl % levelg ( 1 : npl ) = ireci if ( ntp > 0 ) where ( tp % levelg ( 1 : ntp ) == irecp ) tp % levelg ( 1 : ntp ) = ireci if ( plplenc_list % nenc > 0 ) where ( plplenc_list % level ( 1 : plplenc_list % nenc ) == irecp ) plplenc_list % level ( 1 : plplenc_list % nenc ) = ireci if ( pltpenc_list % nenc > 0 ) where ( pltpenc_list % level ( 1 : pltpenc_list % nenc ) == irecp ) pltpenc_list % level ( 1 : pltpenc_list % nenc ) = ireci system % irec = ireci end select end select end associate return end subroutine symba_step_set_recur_levels_system module recursive subroutine symba_step_recur_system ( self , param , t , ireci ) !! author: David A. Minton !! !! Step interacting planets and active test particles ahead in democratic heliocentric coordinates at the current !!         recursion level, if applicable, and descend to the next deeper level if necessarys !! !! Adapted from David E. Kaufmann's Swifter routine: symba_step_recur.f90 !! Adapted from Hal Levison's Swift routine symba5_step_recur.f implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t integer ( I4B ), intent ( in ) :: ireci !! input recursion level ! Internals integer ( I4B ) :: i , j , irecp , nloops real ( DP ) :: dtl , dth real ( DP ), dimension ( NDIM ) :: xr , vr logical :: lencounter , lplpl_collision , lpltp_collision associate ( system => self , plplenc_list => self % plplenc_list , pltpenc_list => self % pltpenc_list ) select type ( pl => self % pl ) class is ( symba_pl ) select type ( tp => self % tp ) class is ( symba_tp ) system % irec = ireci dtl = param % dt / ( NTENC ** ireci ) dth = 0.5_DP * dtl IF ( dtl / param % dt < VSMALL ) THEN write ( * , * ) \"SWIFTEST Warning:\" write ( * , * ) \"   In symba_step_recur_system, local time step is too small\" write ( * , * ) \"   Roundoff error will be important!\" call util_exit ( FAILURE ) END IF irecp = ireci + 1 if ( ireci == 0 ) then nloops = 1 else nloops = NTENC end if do j = 1 , nloops lencounter = plplenc_list % encounter_check ( system , dtl , irecp ) . or . pltpenc_list % encounter_check ( system , dtl , irecp ) call plplenc_list % kick ( system , dth , irecp , 1 ) call pltpenc_list % kick ( system , dth , irecp , 1 ) if ( ireci /= 0 ) then call plplenc_list % kick ( system , dth , irecp , - 1 ) call pltpenc_list % kick ( system , dth , irecp , - 1 ) end if call pl % drift ( system , param , dtl ) call tp % drift ( system , param , dtl ) if ( lencounter ) call system % recursive_step ( param , t + dth , irecp ) system % irec = ireci call plplenc_list % kick ( system , dth , irecp , 1 ) call pltpenc_list % kick ( system , dth , irecp , 1 ) if ( ireci /= 0 ) then call plplenc_list % kick ( system , dth , irecp , - 1 ) call pltpenc_list % kick ( system , dth , irecp , - 1 ) end if if ( param % lclose ) then lplpl_collision = plplenc_list % collision_check ( system , param , t + dtl , dtl , ireci ) lpltp_collision = pltpenc_list % collision_check ( system , param , t + dtl , dtl , ireci ) if ( lplpl_collision ) call plplenc_list % resolve_collision ( system , param , t + dtl , dtl , ireci ) if ( lpltp_collision ) call pltpenc_list % resolve_collision ( system , param , t + dtl , dtl , ireci ) end if call self % set_recur_levels ( ireci ) end do end select end select end associate return end subroutine symba_step_recur_system module subroutine symba_step_reset_system ( self , param ) !! author: David A. Minton !! !! Resets pl, tp,and encounter structures at the start of a new step !! !! Adapted from David E. Kaufmann's Swifter routine: symba_step.f90 !! Adapted from Hal Levison's Swift routine symba5_step.f implicit none ! Arguments class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object class ( symba_parameters ), intent ( in ) :: param !! Current run configuration parameters with SyMBA additions ! Internals integer ( I4B ) :: i , nenc_old associate ( system => self ) select type ( pl => system % pl ) class is ( symba_pl ) select type ( tp => system % tp ) class is ( symba_tp ) associate ( npl => pl % nbody , ntp => tp % nbody ) if ( npl > 0 ) then pl % lcollision ( 1 : npl ) = . false . call pl % reset_kinship ([( i , i = 1 , npl )]) pl % nplenc ( 1 : npl ) = 0 pl % ntpenc ( 1 : npl ) = 0 pl % levelg ( 1 : npl ) = - 1 pl % levelm ( 1 : npl ) = - 1 pl % lencounter ( 1 : npl ) = . false . pl % lcollision ( 1 : npl ) = . false . pl % ldiscard ( 1 : npl ) = . false . pl % lmask ( 1 : npl ) = . true . nenc_old = system % plplenc_list % nenc call system % plplenc_list % setup ( 0 ) call system % plplenc_list % setup ( nenc_old ) system % plplenc_list % nenc = 0 call system % plplcollision_list % setup ( 0 ) end if if ( ntp > 0 ) then tp % nplenc ( 1 : ntp ) = 0 tp % levelg ( 1 : ntp ) = - 1 tp % levelm ( 1 : ntp ) = - 1 tp % lmask ( 1 : ntp ) = . true . tp % ldiscard ( 1 : npl ) = . false . nenc_old = system % pltpenc_list % nenc call system % pltpenc_list % setup ( 0 ) call system % pltpenc_list % setup ( nenc_old ) system % pltpenc_list % nenc = 0 end if call system % pl_adds % setup ( 0 , param ) call system % pl_discards % setup ( 0 , param ) tp % lfirst = param % lfirstkick pl % lfirst = param % lfirstkick end associate end select end select end associate return end subroutine symba_step_reset_system end submodule s_symba_step","tags":"","loc":"sourcefile/symba_step.f90.html"},{"title":"symba_drift.f90 – swiftest","text":"This file depends on sourcefile~~symba_drift.f90~~EfferentGraph sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_drift.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_symba_drift Source Code symba_drift.f90 Source Code submodule ( symba_classes ) s_symba_drift use swiftest contains module subroutine symba_drift_pl ( self , system , param , dt ) !! author: David A. Minton !! !! Wrapper function used to call the body drift routine from a symba_pl structure implicit none ! Arguments class ( symba_pl ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) select type ( system ) class is ( symba_nbody_system ) pl % lmask ( 1 : npl ) = pl % status ( 1 : npl ) /= INACTIVE . and . pl % levelg ( 1 : npl ) == system % irec call helio_drift_body ( pl , system , param , dt ) pl % lmask ( 1 : npl ) = pl % status ( 1 : npl ) /= INACTIVE end select end associate return end subroutine symba_drift_pl module subroutine symba_drift_tp ( self , system , param , dt ) !! author: David A. Minton !! !! Wrapper function used to call the body drift routine from a symba_pl structure implicit none ! Arguments class ( symba_tp ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) select type ( system ) class is ( symba_nbody_system ) tp % lmask ( 1 : ntp ) = tp % status ( 1 : ntp ) /= INACTIVE . and . tp % levelg ( 1 : ntp ) == system % irec call helio_drift_body ( tp , system , param , dt ) tp % lmask ( 1 : ntp ) = tp % status ( 1 : ntp ) /= INACTIVE end select end associate return end subroutine symba_drift_tp end submodule s_symba_drift","tags":"","loc":"sourcefile/symba_drift.f90.html"},{"title":"orbel.f90 – swiftest","text":"This file depends on sourcefile~~orbel.f90~2~~EfferentGraph sourcefile~orbel.f90~2 orbel.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~orbel.f90~2->sourcefile~swiftest.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~orbel.f90~2->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules orbel Source Code orbel.f90 Source Code module orbel use swiftest private public :: xv2el contains pure elemental subroutine xv2el ( mu , px , py , pz , vx , vy , vz , a , e , inc , capom , omega , capm ) use swiftest_classes , only : orbel_xv2el implicit none ! Arguments real * 8 , intent ( in ) :: mu , px , py , pz , vx , vy , vz real * 8 , intent ( out ) :: a , e , inc , capom , omega , capm !$f2py intent(in) mu !$f2py intent(in) px !$f2py intent(in) py !$f2py intent(in) pz !$f2py intent(in) vx !$f2py intent(in) vy !$f2py intent(in) vz !$f2py intent(out) a !$f2py intent(out) e !$f2py intent(out) inc !$f2py intent(out) capom !$f2py intent(out) omega !$f2py intent(out) capm ! Internals real * 8 , dimension ( 3 ) :: x , v x = [ px , py , pz ] v = [ vx , vy , vz ] call orbel_xv2el ( mu , x (:), v (:), a , e , inc , capom , omega , capm ) return end subroutine xv2el end module orbel","tags":"","loc":"sourcefile/orbel.f90~2.html"},{"title":"netcdf.f90 – swiftest","text":"This file depends on sourcefile~~netcdf.f90~~EfferentGraph sourcefile~netcdf.f90 netcdf.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~netcdf.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~netcdf.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_netcdf Source Code netcdf.f90 Source Code submodule ( swiftest_classes ) s_netcdf use swiftest use netcdf contains subroutine check ( status ) !! author: Carlisle A. Wishard, Dana Singh, and David A. Minton !! !! Checks the status of all NetCDF operations to catch errors implicit none ! Arguments integer , intent ( in ) :: status if ( status /= nf90_noerr ) then write ( * , * ) trim ( nf90_strerror ( status )) call util_exit ( FAILURE ) end if return end subroutine check module subroutine netcdf_close ( self , param ) !! author: Carlisle A. Wishard, Dana Singh, and David A. Minton !! !! Closes a NetCDF file implicit none ! Arguments class ( netcdf_parameters ), intent ( inout ) :: self !! Parameters used to identify a particular NetCDF dataset class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters call check ( nf90_close ( self % ncid ) ) return end subroutine netcdf_close module subroutine netcdf_initialize_output ( self , param ) !! author: Carlisle A. Wishard, Dana Singh, and David A. Minton !! !! Initialize a NetCDF file system and defines all variables. use , intrinsic :: ieee_arithmetic implicit none ! Arguments class ( netcdf_parameters ), intent ( inout ) :: self !! Parameters used to identify a particular NetCDF dataset class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals logical :: fileExists integer ( I4B ) :: old_mode , nvar , varid , vartype real ( DP ) :: dfill real ( SP ) :: sfill dfill = ieee_value ( dfill , IEEE_QUIET_NAN ) sfill = ieee_value ( sfill , IEEE_QUIET_NAN ) !! Create the new output file, deleting any previously existing output file of the same name call check ( nf90_create ( param % outfile , NF90_NETCDF4 , self % ncid ) ) ! Define the NetCDF dimensions with particle name as the record dimension call check ( nf90_def_dim ( self % ncid , ID_DIMNAME , NF90_UNLIMITED , self % id_dimid ) ) ! 'x' dimension call check ( nf90_def_dim ( self % ncid , TIME_DIMNAME , NF90_UNLIMITED , self % time_dimid ) ) ! 'y' dimension call check ( nf90_def_dim ( self % ncid , STR_DIMNAME , NAMELEN , self % str_dimid ) ) ! Dimension for string variables (aka character arrays) select case ( param % out_type ) case ( NETCDF_FLOAT_TYPE ) self % out_type = NF90_FLOAT case ( NETCDF_DOUBLE_TYPE ) self % out_type = NF90_DOUBLE end select !! Define the variables call check ( nf90_def_var ( self % ncid , TIME_DIMNAME , self % out_type , self % time_dimid , self % time_varid ) ) call check ( nf90_def_var ( self % ncid , ID_DIMNAME , NF90_INT , self % id_dimid , self % id_varid ) ) call check ( nf90_def_var ( self % ncid , NPL_VARNAME , NF90_INT , self % time_dimid , self % npl_varid ) ) call check ( nf90_def_var ( self % ncid , NTP_VARNAME , NF90_INT , self % time_dimid , self % ntp_varid ) ) call check ( nf90_def_var ( self % ncid , NAME_VARNAME , NF90_CHAR , [ self % str_dimid , self % id_dimid ], self % name_varid ) ) call check ( nf90_def_var ( self % ncid , PTYPE_VARNAME , NF90_CHAR , [ self % str_dimid , self % id_dimid ], self % ptype_varid ) ) if (( param % out_form == XV ) . or . ( param % out_form == XVEL )) then call check ( nf90_def_var ( self % ncid , XHX_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % xhx_varid ) ) call check ( nf90_def_var ( self % ncid , XHY_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % xhy_varid ) ) call check ( nf90_def_var ( self % ncid , XHZ_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % xhz_varid ) ) call check ( nf90_def_var ( self % ncid , VHX_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % vhx_varid ) ) call check ( nf90_def_var ( self % ncid , VHY_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % vhy_varid ) ) call check ( nf90_def_var ( self % ncid , VHZ_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % vhz_varid ) ) end if if (( param % out_form == EL ) . or . ( param % out_form == XVEL )) then call check ( nf90_def_var ( self % ncid , A_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % a_varid ) ) call check ( nf90_def_var ( self % ncid , E_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % e_varid ) ) call check ( nf90_def_var ( self % ncid , INC_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % inc_varid ) ) call check ( nf90_def_var ( self % ncid , CAPOM_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % capom_varid ) ) call check ( nf90_def_var ( self % ncid , OMEGA_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % omega_varid ) ) call check ( nf90_def_var ( self % ncid , CAPM_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % capm_varid ) ) end if call check ( nf90_def_var ( self % ncid , GMASS_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % Gmass_varid ) ) if ( param % lrhill_present ) call check ( nf90_def_var ( self % ncid , RHILL_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % rhill_varid ) ) if ( param % lclose ) call check ( nf90_def_var ( self % ncid , RADIUS_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % radius_varid ) ) if ( param % lrotation ) then call check ( nf90_def_var ( self % ncid , IP1_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % Ip1_varid ) ) call check ( nf90_def_var ( self % ncid , IP2_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % Ip2_varid ) ) call check ( nf90_def_var ( self % ncid , IP3_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % Ip3_varid ) ) call check ( nf90_def_var ( self % ncid , ROTX_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % rotx_varid ) ) call check ( nf90_def_var ( self % ncid , ROTY_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % roty_varid ) ) call check ( nf90_def_var ( self % ncid , ROTZ_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % rotz_varid ) ) end if if ( param % ltides ) then call check ( nf90_def_var ( self % ncid , K2_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % k2_varid ) ) call check ( nf90_def_var ( self % ncid , Q_VARNAME , self % out_type , [ self % id_dimid , self % time_dimid ], self % Q_varid ) ) end if if ( param % lenergy ) then call check ( nf90_def_var ( self % ncid , KE_ORB_VARNAME , self % out_type , self % time_dimid , self % KE_orb_varid ) ) call check ( nf90_def_var ( self % ncid , KE_SPIN_VARNAME , self % out_type , self % time_dimid , self % KE_spin_varid ) ) call check ( nf90_def_var ( self % ncid , PE_VARNAME , self % out_type , self % time_dimid , self % PE_varid ) ) call check ( nf90_def_var ( self % ncid , L_ORBX_VARNAME , self % out_type , self % time_dimid , self % L_orbx_varid ) ) call check ( nf90_def_var ( self % ncid , L_ORBY_VARNAME , self % out_type , self % time_dimid , self % L_orby_varid ) ) call check ( nf90_def_var ( self % ncid , L_ORBZ_VARNAME , self % out_type , self % time_dimid , self % L_orbz_varid ) ) call check ( nf90_def_var ( self % ncid , L_SPINX_VARNAME , self % out_type , self % time_dimid , self % L_spinx_varid ) ) call check ( nf90_def_var ( self % ncid , L_SPINY_VARNAME , self % out_type , self % time_dimid , self % L_spiny_varid ) ) call check ( nf90_def_var ( self % ncid , L_SPINZ_VARNAME , self % out_type , self % time_dimid , self % L_spinz_varid ) ) call check ( nf90_def_var ( self % ncid , L_ESCAPEX_VARNAME , self % out_type , self % time_dimid , self % L_escapex_varid ) ) call check ( nf90_def_var ( self % ncid , L_ESCAPEY_VARNAME , self % out_type , self % time_dimid , self % L_escapey_varid ) ) call check ( nf90_def_var ( self % ncid , L_ESCAPEZ_VARNAME , self % out_type , self % time_dimid , self % L_escapez_varid ) ) call check ( nf90_def_var ( self % ncid , ECOLLISIONS_VARNAME , self % out_type , self % time_dimid , self % Ecollisions_varid ) ) call check ( nf90_def_var ( self % ncid , EUNTRACKED_VARNAME , self % out_type , self % time_dimid , self % Euntracked_varid ) ) call check ( nf90_def_var ( self % ncid , GMESCAPE_VARNAME , self % out_type , self % time_dimid , self % GMescape_varid ) ) end if call check ( nf90_def_var ( self % ncid , STATUS_VARNAME , NF90_CHAR , [ self % str_dimid , self % id_dimid ], self % status_varid ) ) call check ( nf90_def_var ( self % ncid , ORIGIN_TYPE_VARNAME , NF90_CHAR , [ self % str_dimid , self % id_dimid ], self % origin_type_varid ) ) call check ( nf90_def_var ( self % ncid , ORIGIN_TIME_VARNAME , self % out_type , self % id_dimid , self % origin_time_varid ) ) call check ( nf90_def_var ( self % ncid , ORIGIN_XHX_VARNAME , self % out_type , self % id_dimid , self % origin_xhx_varid ) ) call check ( nf90_def_var ( self % ncid , ORIGIN_XHY_VARNAME , self % out_type , self % id_dimid , self % origin_xhy_varid ) ) call check ( nf90_def_var ( self % ncid , ORIGIN_XHZ_VARNAME , self % out_type , self % id_dimid , self % origin_xhz_varid ) ) call check ( nf90_def_var ( self % ncid , ORIGIN_VHX_VARNAME , self % out_type , self % id_dimid , self % origin_vhx_varid ) ) call check ( nf90_def_var ( self % ncid , ORIGIN_VHY_VARNAME , self % out_type , self % id_dimid , self % origin_vhy_varid ) ) call check ( nf90_def_var ( self % ncid , ORIGIN_VHZ_VARNAME , self % out_type , self % id_dimid , self % origin_vhz_varid ) ) call check ( nf90_def_var ( self % ncid , DISCARD_TIME_VARNAME , self % out_type , self % id_dimid , self % discard_time_varid ) ) call check ( nf90_def_var ( self % ncid , DISCARD_XHX_VARNAME , self % out_type , self % id_dimid , self % discard_xhx_varid ) ) call check ( nf90_def_var ( self % ncid , DISCARD_XHY_VARNAME , self % out_type , self % id_dimid , self % discard_xhy_varid ) ) call check ( nf90_def_var ( self % ncid , DISCARD_XHZ_VARNAME , self % out_type , self % id_dimid , self % discard_xhz_varid ) ) call check ( nf90_def_var ( self % ncid , DISCARD_VHX_VARNAME , self % out_type , self % id_dimid , self % discard_vhx_varid ) ) call check ( nf90_def_var ( self % ncid , DISCARD_VHY_VARNAME , self % out_type , self % id_dimid , self % discard_vhy_varid ) ) call check ( nf90_def_var ( self % ncid , DISCARD_VHZ_VARNAME , self % out_type , self % id_dimid , self % discard_vhz_varid ) ) call check ( nf90_def_var ( self % ncid , DISCARD_BODY_ID_VARNAME , NF90_INT , self % id_dimid , self % discard_body_id_varid ) ) ! Set fill mode to NaN for all variables call check ( nf90_inquire ( self % ncid , nVariables = nvar ) ) do varid = 1 , nvar call check ( nf90_inquire_variable ( self % ncid , varid , xtype = vartype ) ) select case ( vartype ) case ( NF90_INT ) call check ( nf90_def_var_fill ( self % ncid , varid , 0 , NF90_FILL_INT ) ) case ( NF90_FLOAT ) call check ( nf90_def_var_fill ( self % ncid , varid , 0 , sfill ) ) case ( NF90_DOUBLE ) call check ( nf90_def_var_fill ( self % ncid , varid , 0 , dfill ) ) case ( NF90_CHAR ) call check ( nf90_def_var_fill ( self % ncid , varid , 0 , 0 ) ) end select end do return end subroutine netcdf_initialize_output module subroutine netcdf_open ( self , param ) !! author: Carlisle A. Wishard, Dana Singh, and David A. Minton !! !! Opens a NetCDF file and does the variable inquiries to activate variable ids implicit none ! Arguments class ( netcdf_parameters ), intent ( inout ) :: self !! Parameters used to identify a particular NetCDF dataset class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters call check ( nf90_open ( param % outfile , nf90_write , self % ncid ) ) call check ( nf90_inq_varid ( self % ncid , TIME_DIMNAME , self % time_varid )) call check ( nf90_inq_varid ( self % ncid , ID_DIMNAME , self % id_varid )) call check ( nf90_inq_varid ( self % ncid , NPL_VARNAME , self % npl_varid )) call check ( nf90_inq_varid ( self % ncid , NTP_VARNAME , self % ntp_varid )) call check ( nf90_inq_varid ( self % ncid , NAME_VARNAME , self % name_varid )) call check ( nf90_inq_varid ( self % ncid , PTYPE_VARNAME , self % ptype_varid )) if (( param % out_form == XV ) . or . ( param % out_form == XVEL )) then call check ( nf90_inq_varid ( self % ncid , XHX_VARNAME , self % xhx_varid )) call check ( nf90_inq_varid ( self % ncid , XHY_VARNAME , self % xhy_varid )) call check ( nf90_inq_varid ( self % ncid , XHZ_VARNAME , self % xhz_varid )) call check ( nf90_inq_varid ( self % ncid , VHX_VARNAME , self % vhx_varid )) call check ( nf90_inq_varid ( self % ncid , VHY_VARNAME , self % vhy_varid )) call check ( nf90_inq_varid ( self % ncid , VHZ_VARNAME , self % vhz_varid )) end if if (( param % out_form == EL ) . or . ( param % out_form == XVEL )) then call check ( nf90_inq_varid ( self % ncid , A_VARNAME , self % a_varid )) call check ( nf90_inq_varid ( self % ncid , E_VARNAME , self % e_varid )) call check ( nf90_inq_varid ( self % ncid , INC_VARNAME , self % inc_varid )) call check ( nf90_inq_varid ( self % ncid , CAPOM_VARNAME , self % capom_varid )) call check ( nf90_inq_varid ( self % ncid , OMEGA_VARNAME , self % omega_varid )) call check ( nf90_inq_varid ( self % ncid , CAPM_VARNAME , self % capm_varid )) end if call check ( nf90_inq_varid ( self % ncid , GMASS_VARNAME , self % Gmass_varid )) if ( param % lclose ) call check ( nf90_inq_varid ( self % ncid , RADIUS_VARNAME , self % radius_varid )) if ( param % lrhill_present ) call check ( nf90_inq_varid ( self % ncid , RHILL_VARNAME , self % rhill_varid )) if ( param % lrotation ) then call check ( nf90_inq_varid ( self % ncid , IP1_VARNAME , self % Ip1_varid )) call check ( nf90_inq_varid ( self % ncid , IP2_VARNAME , self % Ip2_varid )) call check ( nf90_inq_varid ( self % ncid , IP3_VARNAME , self % Ip3_varid )) call check ( nf90_inq_varid ( self % ncid , ROTX_VARNAME , self % rotx_varid )) call check ( nf90_inq_varid ( self % ncid , ROTY_VARNAME , self % roty_varid )) call check ( nf90_inq_varid ( self % ncid , ROTZ_VARNAME , self % rotz_varid )) end if if ( param % ltides ) then call check ( nf90_inq_varid ( self % ncid , K2_VARNAME , self % k2_varid )) call check ( nf90_inq_varid ( self % ncid , Q_VARNAME , self % Q_varid )) end if if ( param % lenergy ) then call check ( nf90_inq_varid ( self % ncid , KE_ORB_VARNAME , self % KE_orb_varid ) ) call check ( nf90_inq_varid ( self % ncid , KE_SPIN_VARNAME , self % KE_spin_varid ) ) call check ( nf90_inq_varid ( self % ncid , PE_VARNAME , self % PE_varid ) ) call check ( nf90_inq_varid ( self % ncid , L_ORBX_VARNAME , self % L_orbx_varid ) ) call check ( nf90_inq_varid ( self % ncid , L_ORBY_VARNAME , self % L_orby_varid ) ) call check ( nf90_inq_varid ( self % ncid , L_ORBZ_VARNAME , self % L_orbz_varid ) ) call check ( nf90_inq_varid ( self % ncid , L_SPINX_VARNAME , self % L_spinx_varid ) ) call check ( nf90_inq_varid ( self % ncid , L_SPINY_VARNAME , self % L_spiny_varid ) ) call check ( nf90_inq_varid ( self % ncid , L_SPINZ_VARNAME , self % L_spinz_varid ) ) call check ( nf90_inq_varid ( self % ncid , L_ESCAPEX_VARNAME , self % L_escapex_varid ) ) call check ( nf90_inq_varid ( self % ncid , L_ESCAPEY_VARNAME , self % L_escapey_varid ) ) call check ( nf90_inq_varid ( self % ncid , L_ESCAPEZ_VARNAME , self % L_escapez_varid ) ) call check ( nf90_inq_varid ( self % ncid , ECOLLISIONS_VARNAME , self % Ecollisions_varid ) ) call check ( nf90_inq_varid ( self % ncid , EUNTRACKED_VARNAME , self % Euntracked_varid ) ) call check ( nf90_inq_varid ( self % ncid , GMESCAPE_VARNAME , self % GMescape_varid ) ) end if call check ( nf90_inq_varid ( self % ncid , STATUS_VARNAME , self % status_varid )) call check ( nf90_inq_varid ( self % ncid , ORIGIN_TYPE_VARNAME , self % origin_type_varid )) call check ( nf90_inq_varid ( self % ncid , ORIGIN_TIME_VARNAME , self % origin_time_varid )) call check ( nf90_inq_varid ( self % ncid , ORIGIN_XHX_VARNAME , self % origin_xhx_varid )) call check ( nf90_inq_varid ( self % ncid , ORIGIN_XHY_VARNAME , self % origin_xhy_varid )) call check ( nf90_inq_varid ( self % ncid , ORIGIN_XHZ_VARNAME , self % origin_xhz_varid )) call check ( nf90_inq_varid ( self % ncid , ORIGIN_VHX_VARNAME , self % origin_vhx_varid )) call check ( nf90_inq_varid ( self % ncid , ORIGIN_VHY_VARNAME , self % origin_vhy_varid )) call check ( nf90_inq_varid ( self % ncid , ORIGIN_VHZ_VARNAME , self % origin_vhz_varid )) call check ( nf90_inq_varid ( self % ncid , DISCARD_TIME_VARNAME , self % discard_time_varid )) call check ( nf90_inq_varid ( self % ncid , DISCARD_XHX_VARNAME , self % discard_xhx_varid )) call check ( nf90_inq_varid ( self % ncid , DISCARD_XHY_VARNAME , self % discard_xhy_varid )) call check ( nf90_inq_varid ( self % ncid , DISCARD_XHZ_VARNAME , self % discard_xhz_varid )) call check ( nf90_inq_varid ( self % ncid , DISCARD_VHX_VARNAME , self % discard_vhx_varid )) call check ( nf90_inq_varid ( self % ncid , DISCARD_VHY_VARNAME , self % discard_vhy_varid )) call check ( nf90_inq_varid ( self % ncid , DISCARD_VHZ_VARNAME , self % discard_vhz_varid )) call check ( nf90_inq_varid ( self % ncid , DISCARD_BODY_ID_VARNAME , self % discard_body_id_varid )) return end subroutine netcdf_open module subroutine netcdf_write_frame_base ( self , iu , param ) !! author: Carlisle A. Wishard, Dana Singh, and David A. Minton !! !! Write a frame of output of either test particle or massive body data to the binary output file !!    Note: If outputting to orbital elements, but sure that the conversion is done prior to calling this method implicit none ! Arguments class ( swiftest_base ), intent ( in ) :: self !! Swiftest particle object class ( netcdf_parameters ), intent ( inout ) :: iu !! Parameters used to identify a particular NetCDF dataset class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i , j , tslot , strlen , idslot , old_mode integer ( I4B ), dimension (:), allocatable :: ind character ( len = :), allocatable :: charstring call self % write_particle_info ( iu ) tslot = int ( param % ioutput , kind = I4B ) + 1 call check ( nf90_set_fill ( iu % ncid , nf90_nofill , old_mode ) ) select type ( self ) class is ( swiftest_body ) associate ( n => self % nbody ) if ( n == 0 ) return allocate ( ind ( n )) call util_sort ( self % id ( 1 : n ), ind ) do i = 1 , n j = ind ( i ) idslot = self % id ( j ) + 1 if (( param % out_form == XV ) . or . ( param % out_form == XVEL )) then call check ( nf90_put_var ( iu % ncid , iu % xhx_varid , self % xh ( 1 , j ), start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % xhy_varid , self % xh ( 2 , j ), start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % xhz_varid , self % xh ( 3 , j ), start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % vhx_varid , self % vh ( 1 , j ), start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % vhy_varid , self % vh ( 2 , j ), start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % vhz_varid , self % vh ( 3 , j ), start = [ idslot , tslot ]) ) end if if (( param % out_form == EL ) . or . ( param % out_form == XVEL )) then call check ( nf90_put_var ( iu % ncid , iu % a_varid , self % a ( j ), start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % e_varid , self % e ( j ), start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % inc_varid , self % inc ( j ) * RAD2DEG , start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % capom_varid , self % capom ( j ) * RAD2DEG , start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % omega_varid , self % omega ( j ) * RAD2DEG , start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % capm_varid , self % capm ( j ) * RAD2DEG , start = [ idslot , tslot ]) ) end if select type ( self ) class is ( swiftest_pl ) ! Additional output if the passed polymorphic object is a massive body call check ( nf90_put_var ( iu % ncid , iu % Gmass_varid , self % Gmass ( j ), start = [ idslot , tslot ]) ) if ( param % lrhill_present ) then call check ( nf90_put_var ( iu % ncid , iu % rhill_varid , self % rhill ( j ), start = [ idslot , tslot ]) ) end if if ( param % lclose ) then call check ( nf90_put_var ( iu % ncid , iu % radius_varid , self % radius ( j ), start = [ idslot , tslot ]) ) end if if ( param % lrotation ) then call check ( nf90_put_var ( iu % ncid , iu % Ip1_varid , self % Ip ( 1 , j ), start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % Ip2_varid , self % Ip ( 2 , j ), start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % Ip3_varid , self % Ip ( 3 , j ), start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % rotx_varid , self % rot ( 1 , j ), start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % roty_varid , self % rot ( 2 , j ), start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % rotz_varid , self % rot ( 3 , j ), start = [ idslot , tslot ]) ) end if if ( param % ltides ) then call check ( nf90_put_var ( iu % ncid , iu % k2_varid , self % k2 ( j ), start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % Q_varid , self % Q ( j ), start = [ idslot , tslot ]) ) end if end select end do end associate class is ( swiftest_cb ) idslot = self % id + 1 call check ( nf90_put_var ( iu % ncid , iu % id_varid , self % id , start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % Gmass_varid , self % Gmass , start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % radius_varid , self % radius , start = [ idslot , tslot ]) ) if ( param % lrotation ) then call check ( nf90_put_var ( iu % ncid , iu % Ip1_varid , self % Ip ( 1 ), start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % Ip2_varid , self % Ip ( 2 ), start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % Ip3_varid , self % Ip ( 3 ), start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % rotx_varid , self % rot ( 1 ), start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % roty_varid , self % rot ( 2 ), start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % rotz_varid , self % rot ( 3 ), start = [ idslot , tslot ]) ) end if if ( param % ltides ) then call check ( nf90_put_var ( iu % ncid , iu % k2_varid , self % k2 , start = [ idslot , tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % Q_varid , self % Q , start = [ idslot , tslot ]) ) end if end select call check ( nf90_set_fill ( iu % ncid , old_mode , old_mode ) ) return end subroutine netcdf_write_frame_base module subroutine netcdf_write_particle_info_base ( self , iu ) !! author: Carlisle A. Wishard, Dana Singh, and David A. Minton !! !! Write all current particle to file implicit none ! Arguments class ( swiftest_base ), intent ( in ) :: self !! Swiftest particle object class ( netcdf_parameters ), intent ( inout ) :: iu !! Parameters used to identify a particular NetCDF dataset ! Internals integer ( I4B ) :: i , j , tslot , strlen , idslot , old_mode integer ( I4B ), dimension (:), allocatable :: ind character ( len = :), allocatable :: charstring character ( len = NAMELEN ) :: emptystr , lenstr character ( len = :), allocatable :: fmtlabel ! This string of spaces of length NAMELEN is used to clear out any old data left behind inside the string variables call check ( nf90_set_fill ( iu % ncid , nf90_nofill , old_mode ) ) write ( lenstr , * ) NAMELEN fmtlabel = \"(A\" // trim ( adjustl ( lenstr )) // \")\" write ( emptystr , fmtlabel ) \" \" select type ( self ) class is ( swiftest_body ) associate ( n => self % nbody ) if ( n == 0 ) return allocate ( ind ( n )) call util_sort ( self % id ( 1 : n ), ind ) do i = 1 , n j = ind ( i ) idslot = self % id ( j ) + 1 call check ( nf90_put_var ( iu % ncid , iu % id_varid , self % id ( j ), start = [ idslot ]) ) charstring = trim ( adjustl ( self % info ( j )% name )) strlen = len ( charstring ) call check ( nf90_put_var ( iu % ncid , iu % name_varid , emptystr , start = [ 1 , idslot ], count = [ NAMELEN , 1 ]) ) call check ( nf90_put_var ( iu % ncid , iu % name_varid , charstring , start = [ 1 , idslot ], count = [ strlen , 1 ]) ) charstring = trim ( adjustl ( self % info ( j )% particle_type )) strlen = len ( charstring ) call check ( nf90_put_var ( iu % ncid , iu % ptype_varid , emptystr , start = [ 1 , idslot ], count = [ NAMELEN , 1 ]) ) call check ( nf90_put_var ( iu % ncid , iu % ptype_varid , charstring , start = [ 1 , idslot ], count = [ strlen , 1 ]) ) charstring = trim ( adjustl ( self % info ( j )% status )) strlen = len ( charstring ) call check ( nf90_put_var ( iu % ncid , iu % status_varid , emptystr , start = [ 1 , idslot ], count = [ NAMELEN , 1 ]) ) call check ( nf90_put_var ( iu % ncid , iu % status_varid , charstring , start = [ 1 , idslot ], count = [ strlen , 1 ]) ) charstring = trim ( adjustl ( self % info ( j )% origin_type )) strlen = len ( charstring ) call check ( nf90_put_var ( iu % ncid , iu % origin_type_varid , emptystr , start = [ 1 , idslot ], count = [ NAMELEN , 1 ]) ) call check ( nf90_put_var ( iu % ncid , iu % origin_type_varid , charstring , start = [ 1 , idslot ], count = [ strlen , 1 ]) ) call check ( nf90_put_var ( iu % ncid , iu % origin_time_varid , self % info ( j )% origin_time , start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % origin_xhx_varid , self % info ( j )% origin_xh ( 1 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % origin_xhy_varid , self % info ( j )% origin_xh ( 2 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % origin_xhz_varid , self % info ( j )% origin_xh ( 3 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % origin_vhx_varid , self % info ( j )% origin_vh ( 1 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % origin_vhy_varid , self % info ( j )% origin_vh ( 2 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % origin_vhz_varid , self % info ( j )% origin_vh ( 3 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % discard_time_varid , self % info ( j )% discard_time , start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % discard_xhx_varid , self % info ( j )% discard_xh ( 1 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % discard_xhy_varid , self % info ( j )% discard_xh ( 2 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % discard_xhz_varid , self % info ( j )% discard_xh ( 3 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % discard_vhx_varid , self % info ( j )% discard_vh ( 1 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % discard_vhy_varid , self % info ( j )% discard_vh ( 2 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % discard_vhz_varid , self % info ( j )% discard_vh ( 3 ), start = [ idslot ]) ) end do end associate class is ( swiftest_cb ) idslot = self % id + 1 call check ( nf90_put_var ( iu % ncid , iu % id_varid , self % id , start = [ idslot ]) ) charstring = trim ( adjustl ( self % info % name )) strlen = len ( charstring ) call check ( nf90_put_var ( iu % ncid , iu % name_varid , emptystr , start = [ 1 , idslot ], count = [ NAMELEN , 1 ]) ) call check ( nf90_put_var ( iu % ncid , iu % name_varid , charstring , start = [ 1 , idslot ], count = [ strlen , 1 ]) ) charstring = trim ( adjustl ( self % info % particle_type )) strlen = len ( charstring ) call check ( nf90_put_var ( iu % ncid , iu % ptype_varid , emptystr , start = [ 1 , idslot ], count = [ NAMELEN , 1 ]) ) call check ( nf90_put_var ( iu % ncid , iu % ptype_varid , charstring , start = [ 1 , idslot ], count = [ strlen , 1 ]) ) charstring = trim ( adjustl ( self % info % status )) strlen = len ( charstring ) call check ( nf90_put_var ( iu % ncid , iu % status_varid , emptystr , start = [ 1 , idslot ], count = [ NAMELEN , 1 ]) ) call check ( nf90_put_var ( iu % ncid , iu % status_varid , charstring , start = [ 1 , idslot ], count = [ strlen , 1 ]) ) charstring = trim ( adjustl ( self % info % origin_type )) strlen = len ( charstring ) call check ( nf90_put_var ( iu % ncid , iu % origin_type_varid , emptystr , start = [ 1 , idslot ], count = [ NAMELEN , 1 ]) ) call check ( nf90_put_var ( iu % ncid , iu % origin_type_varid , charstring , start = [ 1 , idslot ], count = [ strlen , 1 ]) ) call check ( nf90_put_var ( iu % ncid , iu % origin_time_varid , self % info % origin_time , start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % origin_xhx_varid , self % info % origin_xh ( 1 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % origin_xhy_varid , self % info % origin_xh ( 2 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % origin_xhz_varid , self % info % origin_xh ( 3 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % origin_vhx_varid , self % info % origin_vh ( 1 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % origin_vhy_varid , self % info % origin_vh ( 2 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % origin_vhz_varid , self % info % origin_vh ( 3 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % discard_time_varid , self % info % discard_time , start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % discard_xhx_varid , self % info % discard_xh ( 1 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % discard_xhy_varid , self % info % discard_xh ( 2 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % discard_xhz_varid , self % info % discard_xh ( 3 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % discard_vhx_varid , self % info % discard_vh ( 1 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % discard_vhy_varid , self % info % discard_vh ( 2 ), start = [ idslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % discard_vhz_varid , self % info % discard_vh ( 3 ), start = [ idslot ]) ) end select call check ( nf90_set_fill ( iu % ncid , old_mode , old_mode ) ) return end subroutine netcdf_write_particle_info_base module subroutine netcdf_write_hdr_system ( self , iu , param ) !! author: David A. Minton !! !! Writes header information (variables that change with time, but not particle id). !! This subroutine significantly improves the output over the original binary file, allowing us to track energy, momentum, and other quantities that !! previously were handled as separate output files. implicit none ! Arguments class ( swiftest_nbody_system ), intent ( in ) :: self !! Swiftest nbody system object class ( netcdf_parameters ), intent ( inout ) :: iu !! Parameters used to for writing a NetCDF dataset to file class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: tslot tslot = int ( param % ioutput , kind = I4B ) + 1 call check ( nf90_open ( param % outfile , nf90_write , iu % ncid ) ) call check ( nf90_put_var ( iu % ncid , iu % time_varid , param % t , start = [ tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % npl_varid , self % pl % nbody , start = [ tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % ntp_varid , self % tp % nbody , start = [ tslot ]) ) if ( param % lenergy ) then call check ( nf90_put_var ( iu % ncid , iu % KE_orb_varid , self % ke_orbit , start = [ tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % KE_spin_varid , self % ke_spin , start = [ tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % PE_varid , self % pe , start = [ tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % L_orbx_varid , self % Lorbit ( 1 ), start = [ tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % L_orby_varid , self % Lorbit ( 2 ), start = [ tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % L_orbz_varid , self % Lorbit ( 3 ), start = [ tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % L_spinx_varid , self % Lspin ( 1 ), start = [ tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % L_spiny_varid , self % Lspin ( 2 ), start = [ tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % L_spinz_varid , self % Lspin ( 3 ), start = [ tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % L_escapex_varid , param % Lescape ( 1 ), start = [ tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % L_escapey_varid , param % Lescape ( 2 ), start = [ tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % L_escapez_varid , param % Lescape ( 3 ), start = [ tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % Ecollisions_varid , param % Ecollisions , start = [ tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % Euntracked_varid , param % Euntracked , start = [ tslot ]) ) call check ( nf90_put_var ( iu % ncid , iu % GMescape_varid , param % GMescape , start = [ tslot ]) ) end if return end subroutine netcdf_write_hdr_system end submodule s_netcdf","tags":"","loc":"sourcefile/netcdf.f90.html"},{"title":"swiftest_driver.f90 – swiftest","text":"This file depends on sourcefile~~swiftest_driver.f90~~EfferentGraph sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs swiftest_driver Source Code swiftest_driver.f90 Source Code program swiftest_driver !! author: David A. Minton !! !! Driver program for the Swiftest integrators. Unlike the earlier Swift and Swifter drivers, in Swiftest all integrators !!    are run from this single program. !! !! Adapted from Swifter by David E. Kaufmann's Swifter driver programs swifter_[bs,helio,ra15,rmvs,symba,tu4,whm].f90 !! Adapted from Hal Levison and Martin Duncan's Swift driver programs use swiftest implicit none class ( swiftest_nbody_system ), allocatable :: nbody_system !! Polymorphic object containing the nbody system to be integrated class ( swiftest_parameters ), allocatable :: param !! Run configuration parameters integer ( I4B ) :: integrator !! Integrator type code (see swiftest_globals for symbolic names) character ( len = :), allocatable :: param_file_name !! Name of the file containing user-defined parameters integer ( I4B ) :: ierr !! I/O error code integer ( I8B ) :: iloop !! Loop counter integer ( I8B ) :: idump !! Dump cadence counter integer ( I8B ) :: iout !! Output cadence counter integer ( I8B ) :: ioutput_t0 !! The output frame counter at time 0 integer ( I8B ) :: nloops !! Number of steps to take in the simulation real ( DP ) :: old_t_final = 0.0_DP !! Output time at which writing should start, in order to prevent duplicate lines being written for restarts type ( walltimer ) :: timer !! Object used for computing elapsed wall time ierr = io_get_args ( integrator , param_file_name ) if ( ierr /= 0 ) then write ( * , * ) 'Error reading in arguments from the command line' call util_exit ( FAILURE ) end if !> Read in the user-defined parameters file and the initial conditions of the system select case ( integrator ) case ( symba ) allocate ( symba_parameters :: param ) case default allocate ( swiftest_parameters :: param ) end select param % integrator = integrator call setup_construct_system ( nbody_system , param ) call param % read_in ( param_file_name ) associate ( t => param % t , & t0 => param % t0 , & dt => param % dt , & tstop => param % tstop , & istep_out => param % istep_out , & istep_dump => param % istep_dump , & ioutput => param % ioutput ) call nbody_system % initialize ( param ) t = t0 iloop = 0 iout = istep_out idump = istep_dump nloops = ceiling (( tstop - t0 ) / dt , kind = I8B ) ioutput_t0 = int ( t0 / dt / istep_out , kind = I8B ) ioutput = ioutput_t0 ! Prevent duplicate frames from being written if this is a restarted run if (( param % lrestart ) . and . (( param % out_type == REAL8_TYPE ) . or . param % out_type == REAL4_TYPE )) then old_t_final = nbody_system % get_old_t_final ( param ) else old_t_final = t0 if ( istep_out > 0 ) call nbody_system % write_frame ( param ) call nbody_system % dump ( param ) end if !> Define the maximum number of threads nthreads = 1 ! In the *serial* case !$ nthreads = omp_get_max_threads() ! In the *parallel* case !$ write(*,'(a)')   ' OpenMP parameters:' !$ write(*,'(a)')   ' ------------------' !$ write(*,'(a,i3,/)') ' Number of threads  = ', nthreads call timer % reset () write ( * , * ) \" *************** Main Loop *************** \" do iloop = 1 , nloops !> Step the system forward in time call nbody_system % step ( param , t , dt ) t = t0 + iloop * dt !> Evaluate any discards or collisional outcomes call nbody_system % discard ( param ) !> If the loop counter is at the output cadence value, append the data file with a single frame if ( istep_out > 0 ) then iout = iout - 1 if ( iout == 0 ) then ioutput = ioutput_t0 + iloop / istep_out call timer % finish ( nsubsteps = istep_out , message = \"Integration steps:\" ) if ( t > old_t_final ) call nbody_system % write_frame ( param ) call timer % finish ( nsubsteps = 1 , message = \"File I/O:         \" ) iout = istep_out end if end if !> If the loop counter is at the dump cadence value, dump the state of the system to a file in case it needs to be restarted if ( istep_dump > 0 ) then idump = idump - 1 if ( idump == 0 ) then call nbody_system % dump ( param ) idump = istep_dump end if end if end do end associate call util_exit ( SUCCESS ) stop end program swiftest_driver","tags":"","loc":"sourcefile/swiftest_driver.f90.html"},{"title":"rmvs_classes.f90 – swiftest","text":"This file depends on sourcefile~~rmvs_classes.f90~~EfferentGraph sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~rmvs_classes.f90~~AfferentGraph sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_setup.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_util.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~rmvs_io.f90 rmvs_io.f90 sourcefile~rmvs_io.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_io.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_discard.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_kick.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_step.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~kick.f90 kick.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~util_index.f90 util_index.f90 sourcefile~util_index.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~util_sort.f90 util_sort.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~util_spill.f90 util_spill.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~fraggle_regime.f90 fraggle_regime.f90 sourcefile~fraggle_regime.f90->sourcefile~swiftest.f90 sourcefile~util_copy.f90 util_copy.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~fraggle_io.f90 fraggle_io.f90 sourcefile~fraggle_io.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90~2 orbel.f90 sourcefile~orbel.f90~2->sourcefile~swiftest.f90 sourcefile~fraggle_generate.f90 fraggle_generate.f90 sourcefile~fraggle_generate.f90->sourcefile~swiftest.f90 sourcefile~netcdf.f90 netcdf.f90 sourcefile~netcdf.f90->sourcefile~swiftest.f90 sourcefile~util_coord.f90 util_coord.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~gr.f90 gr.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~util_set.f90 util_set.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~util_append.f90 util_append.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 sourcefile~util_resize.f90 util_resize.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~drift.f90 drift.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~fraggle_placeholder.f90 fraggle_placeholder.f90 sourcefile~fraggle_placeholder.f90->sourcefile~swiftest.f90 sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90 orbel.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~fraggle_setup.f90 fraggle_setup.f90 sourcefile~fraggle_setup.f90->sourcefile~swiftest.f90 sourcefile~obl.f90 obl.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~setup.f90 setup.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~util_fill.f90 util_fill.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~fraggle_util.f90 fraggle_util.f90 sourcefile~fraggle_util.f90->sourcefile~swiftest.f90 sourcefile~helio_setup.f90 helio_setup.f90 sourcefile~helio_setup.f90->sourcefile~swiftest.f90 sourcefile~util_solve.f90 util_solve.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~fraggle_set.f90 fraggle_set.f90 sourcefile~fraggle_set.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules rmvs_classes Source Code rmvs_classes.f90 Source Code module rmvs_classes !! author: David A. Minton !! !! Definition of classes and methods specific to the Regularized Mixed Variable Symplectic (RMVS) integrator !! Partially adapted from David E. Kaufmann's Swifter module: module_rmvs.f90 use swiftest_globals use whm_classes , only : whm_cb , whm_pl , whm_tp , whm_nbody_system implicit none public integer ( I4B ), private , parameter :: NTENC = 10 integer ( I4B ), private , parameter :: NTPHENC = 3 integer ( I4B ), private , parameter :: NTPENC = NTENC * NTPHENC real ( DP ), private , parameter :: RHSCALE = 3.5_DP real ( DP ), private , parameter :: RHPSCALE = 1.0_DP real ( DP ), private , parameter :: FACQDT = 2.0_DP !******************************************************************************************************************************** !  rmvs_nbody_system class definitions and method interfaces !******************************************************************************************************************************** type , extends ( whm_nbody_system ) :: rmvs_nbody_system !> In the RMVS integrator, only test particles are discarded logical :: lplanetocentric = . false . !! Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations real ( DP ) :: rts !! fraction of Hill's sphere radius to use as radius of encounter region real ( DP ), dimension (:,:), allocatable :: vbeg !! Planet velocities at beginning ot step contains !> Replace the abstract procedures with concrete ones procedure :: initialize => rmvs_setup_initialize_system !! Performs RMVS-specific initilization steps, including generating the close encounter planetocentric structures procedure :: step => rmvs_step_system !! Advance the RMVS nbody system forward in time by one step end type rmvs_nbody_system type , private :: rmvs_interp real ( DP ), dimension (:, :), allocatable :: x !! interpolated heliocentric planet position for outer encounter real ( DP ), dimension (:, :), allocatable :: v !! interpolated heliocentric planet velocity for outer encounter real ( DP ), dimension (:, :), allocatable :: aobl !! Encountering planet's oblateness acceleration value real ( DP ), dimension (:, :), allocatable :: atide !! Encountering planet's tidal acceleration value end type rmvs_interp !******************************************************************************************************************************** ! rmvs_cb class definitions and method interfaces !******************************************************************************************************************************* !> RMVS central body particle class type , extends ( whm_cb ) :: rmvs_cb type ( rmvs_interp ), dimension (:), allocatable :: outer !! interpolated heliocentric central body position for outer encounters type ( rmvs_interp ), dimension (:), allocatable :: inner !! interpolated heliocentric central body position for inner encounters logical :: lplanetocentric = . false . !! Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations end type rmvs_cb !******************************************************************************************************************************** !  rmvs_tp class definitions and method interfaces !******************************************************************************************************************************* !! RMVS test particle class type , extends ( whm_tp ) :: rmvs_tp !! Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the !!    component list, such as rmvs_setup_tp and rmvs_util_spill_tp ! encounter steps) logical , dimension (:), allocatable :: lperi !! planetocentric pericenter passage flag (persistent for a full rmvs time step) over a full RMVS time step) integer ( I4B ), dimension (:), allocatable :: plperP !! index of planet associated with pericenter distance peri (persistent over a full RMVS time step) integer ( I4B ), dimension (:), allocatable :: plencP !! index of planet that test particle is encountering (not persistent for a full RMVS time step) ! The following are used to correctly set the oblateness values of the acceleration during an inner encounter with a planet type ( rmvs_cb ) :: cb_heliocentric !! Copy of original central body object passed to close encounter (used for oblateness acceleration during planetocentric encoountters) real ( DP ), dimension (:,:), allocatable :: xheliocentric !! original heliocentric position (used for oblateness calculation during close encounters) integer ( I4B ) :: index !!  inner substep number within current set integer ( I4B ) :: ipleP !!  index value of encountering planet logical :: lplanetocentric = . false . !! Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations contains procedure :: discard => rmvs_discard_tp !! Check to see if test particles should be discarded based on pericenter passage distances with respect to planets encountered procedure :: encounter_check => rmvs_encounter_check_tp !! Checks if any test particles are undergoing a close encounter with a massive body procedure :: accel => rmvs_kick_getacch_tp !! Calculates either the standard or modified version of the acceleration depending if the !!    if the test particle is undergoing a close encounter or not procedure :: setup => rmvs_setup_tp !! Constructor method - Allocates space for the input number of bodiess procedure :: append => rmvs_util_append_tp !! Appends elements from one structure to another procedure :: fill => rmvs_util_fill_tp !! \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure :: resize => rmvs_util_resize_tp !! Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure :: sort => rmvs_util_sort_tp !! Sorts body arrays by a sortable componen procedure :: rearrange => rmvs_util_sort_rearrange_tp !! Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure :: spill => rmvs_util_spill_tp !! \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) end type rmvs_tp !******************************************************************************************************************************** !                                    rmvs_pl class definitions and method interfaces !******************************************************************************************************************************* !> RMVS massive body particle class type , extends ( whm_pl ) :: rmvs_pl integer ( I4B ), dimension (:), allocatable :: nenc !! number of test particles encountering planet this full rmvs time step integer ( I4B ), dimension (:), allocatable :: tpenc1P !! index of first test particle encountering planet integer ( I4B ), dimension (:), allocatable :: plind !! Connects the planetocentric indices back to the heliocentric planet list type ( rmvs_interp ), dimension (:), allocatable :: outer !! interpolated heliocentric central body position for outer encounters type ( rmvs_interp ), dimension (:), allocatable :: inner !! interpolated heliocentric central body position for inner encounters class ( rmvs_nbody_system ), dimension (:), allocatable :: planetocentric !! Planetocentric version of the massive body objects (one for each massive body) logical :: lplanetocentric = . false . !! Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations contains procedure :: setup => rmvs_setup_pl !! Constructor method - Allocates space for the input number of bodiess procedure :: append => rmvs_util_append_pl !! Appends elements from one structure to another procedure :: fill => rmvs_util_fill_pl !! \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure :: resize => rmvs_util_resize_pl !! Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure :: sort => rmvs_util_sort_pl !! Sorts body arrays by a sortable componen procedure :: rearrange => rmvs_util_sort_rearrange_pl !! Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure :: spill => rmvs_util_spill_pl !! \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) end type rmvs_pl interface module pure subroutine rmvs_chk_ind ( xr , yr , zr , vxr , vyr , vzr , dt , r2crit , lencounter , lvdotr ) !$omp declare simd(rmvs_chk_ind) implicit none real ( DP ), intent ( in ) :: xr , yr , zr !! Relative distance vector components real ( DP ), intent ( in ) :: vxr , vyr , vzr !! Relative velocity vector components real ( DP ), intent ( in ) :: dt !! Step size real ( DP ), intent ( in ) :: r2crit !! Square of the critical encounter distance logical , intent ( out ) :: lencounter !! Flag indicating that an encounter has occurred logical , intent ( out ) :: lvdotr !! Logical flag indicating the direction of the v .dot. r vector end subroutine rmvs_chk_ind module subroutine rmvs_discard_tp ( self , system , param ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine rmvs_discard_tp module function rmvs_encounter_check_tp ( self , system , dt ) result ( lencounter ) implicit none class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object class ( rmvs_nbody_system ), intent ( inout ) :: system !! RMVS nbody system object real ( DP ), intent ( in ) :: dt !! step size logical :: lencounter !! Returns true if there is at least one close encounter end function rmvs_encounter_check_tp module subroutine rmvs_io_write_encounter ( t , id1 , id2 , Gmass1 , Gmass2 , radius1 , radius2 , xh1 , xh2 , vh1 , vh2 , enc_out ) implicit none integer ( I4B ), intent ( in ) :: id1 , id2 real ( DP ), intent ( in ) :: t , Gmass1 , Gmass2 , radius1 , radius2 real ( DP ), dimension (:), intent ( in ) :: xh1 , xh2 , vh1 , vh2 character ( * ), intent ( in ) :: enc_out end subroutine rmvs_io_write_encounter module subroutine rmvs_kick_getacch_tp ( self , system , param , t , lbeg ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest central body particle data structuree class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step end subroutine rmvs_kick_getacch_tp module subroutine rmvs_setup_pl ( self , n , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine rmvs_setup_pl module subroutine rmvs_setup_initialize_system ( self , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( rmvs_nbody_system ), intent ( inout ) :: self !! RMVS system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine rmvs_setup_initialize_system module subroutine rmvs_setup_tp ( self , n , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parametere end subroutine rmvs_setup_tp module subroutine rmvs_util_append_pl ( self , source , lsource_mask ) use swiftest_classes , only : swiftest_body implicit none class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine rmvs_util_append_pl module subroutine rmvs_util_append_tp ( self , source , lsource_mask ) use swiftest_classes , only : swiftest_body implicit none class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine rmvs_util_append_tp module subroutine rmvs_util_fill_pl ( self , inserts , lfill_list ) use swiftest_classes , only : swiftest_body implicit none class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object class ( swiftest_body ), intent ( in ) :: inserts !! Inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine rmvs_util_fill_pl module subroutine rmvs_util_fill_tp ( self , inserts , lfill_list ) use swiftest_classes , only : swiftest_body implicit none class ( rmvs_tp ), intent ( inout ) :: self !! RMVS massive body object class ( swiftest_body ), intent ( in ) :: inserts !!  Inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine rmvs_util_fill_tp module subroutine rmvs_util_resize_pl ( self , nnew ) implicit none class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object integer ( I4B ), intent ( in ) :: nnew !! New size neded end subroutine rmvs_util_resize_pl module subroutine rmvs_util_resize_tp ( self , nnew ) implicit none class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object integer ( I4B ), intent ( in ) :: nnew !! New size neded end subroutine rmvs_util_resize_tp module subroutine rmvs_util_sort_pl ( self , sortby , ascending ) implicit none class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order end subroutine rmvs_util_sort_pl module subroutine rmvs_util_sort_tp ( self , sortby , ascending ) implicit none class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order end subroutine rmvs_util_sort_tp module subroutine rmvs_util_sort_rearrange_pl ( self , ind ) implicit none class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) end subroutine rmvs_util_sort_rearrange_pl module subroutine rmvs_util_sort_rearrange_tp ( self , ind ) implicit none class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) end subroutine rmvs_util_sort_rearrange_tp module subroutine rmvs_util_spill_pl ( self , discards , lspill_list , ldestructive ) use swiftest_classes , only : swiftest_body implicit none class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine rmvs_util_spill_pl module subroutine rmvs_util_spill_tp ( self , discards , lspill_list , ldestructive ) use swiftest_classes , only : swiftest_body implicit none class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine rmvs_util_spill_tp module subroutine rmvs_step_system ( self , param , t , dt ) use swiftest_classes , only : swiftest_parameters implicit none class ( rmvs_nbody_system ), intent ( inout ) :: self !! RMVS nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize end subroutine rmvs_step_system end interface end module rmvs_classes","tags":"","loc":"sourcefile/rmvs_classes.f90.html"},{"title":"swiftest_globals.f90 – swiftest","text":"Files dependent on this one sourcefile~~swiftest_globals.f90~~AfferentGraph sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_collision.f90->sourcefile~symba_classes.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~symba_classes.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~kick.f90 kick.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~kick.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~symba_classes.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~util_exit.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_discard.f90->sourcefile~symba_classes.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~util_index.f90 util_index.f90 sourcefile~util_index.f90->sourcefile~swiftest.f90 sourcefile~util_index.f90->sourcefile~swiftest_classes.f90 sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~whm_drift.f90->sourcefile~whm_classes.f90 sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~util_rescale.f90->sourcefile~swiftest_classes.f90 sourcefile~operator_mag.f90 operator_mag.f90 sourcefile~operator_mag.f90->sourcefile~swiftest_operators.f90 sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~rmvs_classes.f90 sourcefile~util_sort.f90 util_sort.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~util_sort.f90->sourcefile~swiftest_classes.f90 sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest_classes.f90 sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~operator_cross.f90->sourcefile~swiftest_operators.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~util_spill.f90 util_spill.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~util_spill.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_regime.f90 fraggle_regime.f90 sourcefile~fraggle_regime.f90->sourcefile~fraggle_classes.f90 sourcefile~fraggle_regime.f90->sourcefile~swiftest.f90 sourcefile~util_copy.f90 util_copy.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~util_copy.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_io.f90 fraggle_io.f90 sourcefile~fraggle_io.f90->sourcefile~fraggle_classes.f90 sourcefile~fraggle_io.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90~2 orbel.f90 sourcefile~orbel.f90~2->sourcefile~swiftest.f90 sourcefile~orbel.f90~2->sourcefile~swiftest_classes.f90 sourcefile~fraggle_generate.f90 fraggle_generate.f90 sourcefile~fraggle_generate.f90->sourcefile~fraggle_classes.f90 sourcefile~fraggle_generate.f90->sourcefile~swiftest.f90 sourcefile~netcdf.f90 netcdf.f90 sourcefile~netcdf.f90->sourcefile~swiftest.f90 sourcefile~netcdf.f90->sourcefile~swiftest_classes.f90 sourcefile~util_coord.f90 util_coord.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~util_coord.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~whm_gr.f90->sourcefile~whm_classes.f90 sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~helio_classes.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~gr.f90 gr.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~gr.f90->sourcefile~swiftest_classes.f90 sourcefile~util_set.f90 util_set.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~util_set.f90->sourcefile~swiftest_classes.f90 sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_io.f90->sourcefile~symba_classes.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~util_append.f90 util_append.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 sourcefile~util_append.f90->sourcefile~swiftest_classes.f90 sourcefile~util_resize.f90 util_resize.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~util_resize.f90->sourcefile~swiftest_classes.f90 sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90->sourcefile~rmvs_classes.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~io.f90->sourcefile~swiftest_classes.f90 sourcefile~drift.f90 drift.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~drift.f90->sourcefile~swiftest_classes.f90 sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_step.f90->sourcefile~rmvs_classes.f90 sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_gr.f90->sourcefile~helio_classes.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_util.f90->sourcefile~symba_classes.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90->sourcefile~whm_classes.f90 sourcefile~fraggle_placeholder.f90 fraggle_placeholder.f90 sourcefile~fraggle_placeholder.f90->sourcefile~fraggle_classes.f90 sourcefile~fraggle_placeholder.f90->sourcefile~swiftest.f90 sourcefile~rmvs_io.f90 rmvs_io.f90 sourcefile~rmvs_io.f90->sourcefile~swiftest.f90 sourcefile~rmvs_io.f90->sourcefile~rmvs_classes.f90 sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~whm_kick.f90->sourcefile~whm_classes.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~util_peri.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_kick.f90->sourcefile~helio_classes.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90->sourcefile~whm_classes.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~discard.f90->sourcefile~swiftest_classes.f90 sourcefile~orbel.f90 orbel.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~whm_setup.f90->sourcefile~whm_classes.f90 sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~user_getacch.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_setup.f90 fraggle_setup.f90 sourcefile~fraggle_setup.f90->sourcefile~fraggle_classes.f90 sourcefile~fraggle_setup.f90->sourcefile~swiftest.f90 sourcefile~obl.f90 obl.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~obl.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_encounter_check.f90->sourcefile~symba_classes.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_drift.f90->sourcefile~symba_classes.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~whm_util.f90->sourcefile~whm_classes.f90 sourcefile~fraggle_util.f90 fraggle_util.f90 sourcefile~fraggle_util.f90->sourcefile~fraggle_classes.f90 sourcefile~fraggle_util.f90->sourcefile~swiftest.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~util_version.f90->sourcefile~swiftest_classes.f90 sourcefile~setup.f90 setup.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~setup.f90->sourcefile~swiftest_classes.f90 sourcefile~util_fill.f90 util_fill.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~util_fill.f90->sourcefile~swiftest_classes.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_setup.f90 helio_setup.f90 sourcefile~helio_setup.f90->sourcefile~helio_classes.f90 sourcefile~helio_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_setup.f90->sourcefile~rmvs_classes.f90 sourcefile~util_solve.f90 util_solve.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~util_solve.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_step.f90->sourcefile~helio_classes.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_setup.f90->sourcefile~symba_classes.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_set.f90 fraggle_set.f90 sourcefile~fraggle_set.f90->sourcefile~fraggle_classes.f90 sourcefile~fraggle_set.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules swiftest_globals Source Code swiftest_globals.f90 Source Code module swiftest_globals !! author: David A. Minton !! graph: false !! !! Basic parameters, definitions, and global type definitions used throughout the Swiftest project !! Adapted from David E. Kaufmann's Swifter routine: swiftest_globals.f90 and module_swifter.f90 use , intrinsic :: iso_fortran_env ! Use the intrinsic kind definitions implicit none public integer , parameter :: I8B = int64 !! Symbolic name for kind types of 8-byte integers integer , parameter :: I4B = int32 !! Symbolic name for kind types of 4-byte integers integer , parameter :: I2B = int16 !! Symbolic name for kind types of 2-byte integers integer , parameter :: I1B = int8 !! Symbolic name for kind types of 1-byte integers integer , parameter :: SP = real32 !! Symbolic name for kind types of single-precision reals integer , parameter :: DP = real64 !! Symbolic name for kind types of double-precision reals integer , parameter :: QP = real128 !! Symbolic name for kind types of quad-precision reals real ( DP ), parameter :: PIBY2 = 1.570796326794896619231321691639751442099_DP !! Definition of /(\\pi / 2 real ( DP ), parameter :: PI = 3.141592653589793238462643383279502884197_DP !! Definition of /(\\pi real ( DP ), parameter :: PI3BY2 = 4.712388980384689857693965074919254326296_DP !! Definition of /(3 \\pi / 2 real ( DP ), parameter :: TWOPI = 6.283185307179586476925286766559005768394_DP !! Definition of 2 \\pi real ( DP ), parameter :: THIRD = 0.333333333333333333333333333333333333333_DP !! Definition of 1 / 3 real ( DP ), parameter :: DEG2RAD = PI / 18 0.0_DP !! Definition of conversion factor from degrees to radians real ( DP ), parameter :: RAD2DEG = 18 0.0_DP / PI !! Definition of conversion factor from degrees to radians real ( DP ), parameter :: GC = 6.6743E-11_DP !! Universal gravitational constant in SI units real ( DP ), parameter :: einsteinC = 29979245 8.0_DP !! Speed of light in SI units integer ( I4B ), parameter :: LOWERCASE_BEGIN = iachar ( 'a' ) !! ASCII character set parameter for lower to upper conversion - start of lowercase integer ( I4B ), parameter :: LOWERCASE_END = iachar ( 'z' ) !! ASCII character set parameter for lower to upper conversion - end of lowercase integer ( I4B ), parameter :: UPPERCASE_OFFSET = iachar ( 'A' ) - iachar ( 'a' ) !! ASCII character set parameter for lower to upper conversion - offset between upper and lower real ( SP ), parameter :: VERSION_NUMBER = 0.1_SP !! swiftest version !> Symbolic name for integrator types integer ( I4B ), parameter :: UNKNOWN_INTEGRATOR = 1 integer ( I4B ), parameter :: BS = 2 integer ( I4B ), parameter :: HELIO = 3 integer ( I4B ), parameter :: RA15 = 4 integer ( I4B ), parameter :: TU4 = 5 integer ( I4B ), parameter :: WHM = 6 integer ( I4B ), parameter :: RMVS = 7 integer ( I4B ), parameter :: SYMBA = 8 integer ( I4B ), parameter :: RINGMOONS = 9 integer ( I4B ), parameter :: STRMAX = 512 !! Maximum size of character strings integer ( I4B ), parameter :: NAMELEN = 32 !! Maximum size of name strings character ( * ), parameter :: ASCII_TYPE = 'ASCII' !! Symbolic name for ASCII file type character ( * ), parameter :: REAL4_TYPE = 'REAL4' !! Symbolic name for binary file type REAL4 character ( * ), parameter :: REAL8_TYPE = 'REAL8' !! Symbolic name for binary file type REAL8 character ( * ), parameter :: NETCDF_FLOAT_TYPE = 'NETCDF_FLOAT' !! Symbolic name for binary file type REAL8 character ( * ), parameter :: NETCDF_DOUBLE_TYPE = 'NETCDF_DOUBLE' !! Symbolic name for binary file type REAL8 character ( * ), parameter :: EL = 'EL' !! Symbolic name for binary output file contents for orbital elements character ( * ), parameter :: XV = 'XV' !! Symbolic name for binary output file contents for cartesian position and velocity vectors character ( * ), parameter :: XVEL = 'XVEL' !! Symbolic name for binary output file contents for both cartesian position and velocity and orbital elements character ( * ), parameter :: CB_TYPE_NAME = \"Central Body\" character ( * ), parameter :: PL_TYPE_NAME = \"Massive Body\" character ( * ), parameter :: TP_TYPE_NAME = \"Test Particle\" character ( * ), parameter :: PL_TINY_TYPE_NAME = \"Semi-Interacting Massive Body\" ! OpenMP Parameters integer ( I4B ) :: nthreads = 1 !! Number of OpenMP threads integer ( I4B ), parameter :: NTHERSHOLD = 1000 !! Threshold value for OpenMP loop parallelization integer ( I4B ), parameter :: SUCCESS = 0 !! Symbolic name for function return/flag code for success integer ( I4B ), parameter :: FAILURE = - 1 !! Symbolic name for function return/flag code for failure integer ( I4B ), parameter :: USAGE = - 2 !! Symbolic name for function return/flag code for printing the usage message integer ( I4B ), parameter :: HELP = - 3 !! Symbolic name for function return/flag code for printing the usage message character ( * ), parameter :: SUCCESS_MSG = '(/, \"Normal termination of Swiftest (version \", f3.1, \")\")' character ( * ), parameter :: FAIL_MSG = '(/, \"Terminating Swiftest (version \", f3.1, \") due to error!!\")' character ( * ), parameter :: USAGE_MSG = '(\"Usage: swiftest [bs|helio|ra15|rmvs|symba|tu4|whm] <paramfile>\")' character ( * ), parameter :: HELP_MSG = USAGE_MSG integer ( I4B ), parameter :: ELLIPSE = - 1 !! Symbolic names for orbit types - ellipse integer ( I4B ), parameter :: PARABOLA = 0 !! Symbolic names for orbit types - parabola integer ( I4B ), parameter :: HYPERBOLA = 1 !! Symbolic names for orbit types - hyperbola !> Symbolic names for body/particle status codes: integer ( I4B ), parameter :: ACTIVE = 0 integer ( I4B ), parameter :: INACTIVE = 1 integer ( I4B ), parameter :: DISCARDED_RMAX = - 1 integer ( I4B ), parameter :: DISCARDED_RMIN = - 2 integer ( I4B ), parameter :: DISCARDED_RMAXU = - 3 integer ( I4B ), parameter :: DISCARDED_PERI = - 4 integer ( I4B ), parameter :: DISCARDED_PLR = - 5 integer ( I4B ), parameter :: DISCARDED_PLQ = - 6 integer ( I4B ), parameter :: DISCARDED_DRIFTERR = - 7 integer ( I4B ), parameter :: MERGED = - 8 integer ( I4B ), parameter :: DISRUPTION = - 9 integer ( I4B ), parameter :: SUPERCATASTROPHIC = - 10 integer ( I4B ), parameter :: GRAZE_AND_MERGE = - 11 integer ( I4B ), parameter :: HIT_AND_RUN_DISRUPT = - 12 integer ( I4B ), parameter :: HIT_AND_RUN_PURE = - 13 integer ( I4B ), parameter :: COLLISION = - 14 integer ( I4B ), parameter :: NEW_PARTICLE = - 15 integer ( I4B ), parameter :: OLD_PARTICLE = - 16 !>Symbolic names for collisional outcomes from collresolve_resolve: integer ( I4B ), parameter :: COLLRESOLVE_REGIME_MERGE = 1 integer ( I4B ), parameter :: COLLRESOLVE_REGIME_DISRUPTION = 2 integer ( I4B ), parameter :: COLLRESOLVE_REGIME_SUPERCATASTROPHIC = 3 integer ( I4B ), parameter :: COLLRESOLVE_REGIME_GRAZE_AND_MERGE = 4 integer ( I4B ), parameter :: COLLRESOLVE_REGIME_HIT_AND_RUN = 5 !> String labels for body/particle addition/subtraction in discard file character ( * ), parameter :: ADD = '+1' character ( * ), parameter :: SUB = '-1' !> Standard file names integer ( I4B ), parameter :: NDUMPFILES = 2 character ( * ), dimension ( 2 ), parameter :: DUMP_CB_FILE = [ 'dump_cb1.bin' , 'dump_cb2.bin' ] character ( * ), dimension ( 2 ), parameter :: DUMP_PL_FILE = [ 'dump_pl1.bin' , 'dump_pl2.bin' ] character ( * ), dimension ( 2 ), parameter :: DUMP_TP_FILE = [ 'dump_tp1.bin' , 'dump_tp2.bin' ] character ( * ), dimension ( 2 ), parameter :: DUMP_PARAM_FILE = [ 'dump_param1.in' , 'dump_param2.in' ] !> Default file names that can be changed by the user in the parameters file character ( * ), parameter :: CB_INFILE = 'cb.in' character ( * ), parameter :: PL_INFILE = 'pl.in' character ( * ), parameter :: TP_INFILE = 'tp.in' character ( * ), parameter :: BIN_OUTFILE = 'bin.dat' integer ( I4B ), parameter :: BINUNIT = 20 !! File unit number for the binary output file character ( * ), parameter :: PARTICLE_OUTFILE = 'particle.dat' integer ( I4B ), parameter :: PARTICLEUNIT = 44 !! File unit number for the binary particle info output file !> Miscellaneous constants: integer ( I4B ), parameter :: NDIM = 3 !! Number of dimensions in our reality integer ( I4B ), parameter :: NDIM2 = 2 * NDIM !! 2x the number of dimensions real ( DP ), parameter :: VSMALL = 2 * epsilon ( 1._DP ) !! Very small number used to prevent floating underflow !> NetCDF variable names and constants character ( * ), parameter :: NETCDF_OUTFILE = 'bin.nc' !! Default output file name character ( * ), parameter :: TIME_DIMNAME = \"time\" !! NetCDF name of the time dimension character ( * ), parameter :: ID_DIMNAME = \"id\" !! NetCDF name of the particle id dimension character ( * ), parameter :: STR_DIMNAME = \"str\" !! NetCDF name of the particle id dimension character ( * ), parameter :: PTYPE_VARNAME = \"particle_type\" !! NetCDF name of the particle type variable character ( * ), parameter :: NAME_VARNAME = \"name\" !! NetCDF name of the particle name variable character ( * ), parameter :: NPL_VARNAME = \"npl\" !! NetCDF name of the number of active massive bodies variable character ( * ), parameter :: NTP_VARNAME = \"ntp\" !! NetCDF name of the number of active test particles variable character ( * ), parameter :: A_VARNAME = \"a\" !! NetCDF name of the semimajor axis variable character ( * ), parameter :: E_VARNAME = \"e\" !! NetCDF name of the eccentricity variable character ( * ), parameter :: INC_VARNAME = \"inc\" !! NetCDF name of the inclination variable character ( * ), parameter :: CAPOM_VARNAME = \"capom\" !! NetCDF name of the long. asc. node variable character ( * ), parameter :: OMEGA_VARNAME = \"omega\" !! NetCDF name of the arg. periapsis variable character ( * ), parameter :: CAPM_VARNAME = \"capm\" !! NetCDF name of the mean anomaly variable character ( * ), parameter :: XHX_VARNAME = \"xhx\" !! NetCDF name of the heliocentric position x variable character ( * ), parameter :: XHY_VARNAME = \"xhy\" !! NetCDF name of the heliocentric position y variable character ( * ), parameter :: XHZ_VARNAME = \"xhz\" !! NetCDF name of the heliocentric position z variable character ( * ), parameter :: VHX_VARNAME = \"vhx\" !! NetCDF name of the heliocentric velocity x variable character ( * ), parameter :: VHY_VARNAME = \"vhy\" !! NetCDF name of the heliocentric velocity y variable character ( * ), parameter :: VHZ_VARNAME = \"vhz\" !! NetCDF name of the heliocentric velocity z variable character ( * ), parameter :: GMASS_VARNAME = \"Gmass\" !! NetCDF name of the mass variable character ( * ), parameter :: RHILL_VARNAME = \"rhill\" !! NetCDF name of the hill radius variable character ( * ), parameter :: RADIUS_VARNAME = \"radius\" !! NetCDF name of the radius variable character ( * ), parameter :: IP1_VARNAME = \"Ip1\" !! NetCDF name of the axis 1 principal moment of inertial variable character ( * ), parameter :: IP2_VARNAME = \"Ip2\" !! NetCDF name of the axis 2 principal moment of inertial variable character ( * ), parameter :: IP3_VARNAME = \"Ip3\" !! NetCDF name of the axis 3 principal moment of inertial variable character ( * ), parameter :: ROTX_VARNAME = \"rotx\" !! NetCDF name of the rotation x variable character ( * ), parameter :: ROTY_VARNAME = \"roty\" !! NetCDF name of the rotation y variable character ( * ), parameter :: ROTZ_VARNAME = \"rotz\" !! NetCDF name of the rotation z variable character ( * ), parameter :: K2_VARNAME = \"k2\" !! NetCDF name of the Love number variable character ( * ), parameter :: Q_VARNAME = \"Q\" !! NetCDF name of the energy dissipation variable character ( * ), parameter :: KE_ORB_VARNAME = \"KE_orb\" !! NetCDF name of the system orbital kinetic energy variable character ( * ), parameter :: KE_SPIN_VARNAME = \"KE_spin\" !! NetCDF name of the system spin kinetic energy variable character ( * ), parameter :: PE_VARNAME = \"PE\" !! NetCDF name of the system potential energy variable character ( * ), parameter :: L_ORBX_VARNAME = \"L_orbx\" !! NetCDF name of the orbital angular momentum x variable character ( * ), parameter :: L_ORBY_VARNAME = \"L_orby\" !! NetCDF name of the orbital angular momentum y variable character ( * ), parameter :: L_ORBZ_VARNAME = \"L_orbz\" !! NetCDF name of the orbital angular momentum z variable character ( * ), parameter :: L_SPINX_VARNAME = \"L_spinx\" !! NetCDF name of the spin angular momentum x variable character ( * ), parameter :: L_SPINY_VARNAME = \"L_spiny\" !! NetCDF name of the spin angular momentum y variable character ( * ), parameter :: L_SPINZ_VARNAME = \"L_spinz\" !! NetCDF name of the spin angular momentum z variable character ( * ), parameter :: L_ESCAPEX_VARNAME = \"L_escapex\" !! NetCDF name of the escaped angular momentum x variable character ( * ), parameter :: L_ESCAPEY_VARNAME = \"L_escapey\" !! NetCDF name of the escaped angular momentum y variable character ( * ), parameter :: L_ESCAPEZ_VARNAME = \"L_escapez\" !! NetCDF name of the escaped angular momentum z variable character ( * ), parameter :: ECOLLISIONS_VARNAME = \"Ecollisions\" !! NetCDF name of the escaped angular momentum y variable character ( * ), parameter :: EUNTRACKED_VARNAME = \"Euntracked\" !! NetCDF name of the energy that is untracked due to loss (untracked potential energy due to mergers and body energy for escaped bodies) character ( * ), parameter :: GMESCAPE_VARNAME = \"GMescape\" !! NetCDF name of the G*Mass of bodies that escape the system character ( * ), parameter :: STATUS_VARNAME = \"status\" !! NetCDF name of the current status of the body variable (includes discard type) character ( * ), parameter :: ORIGIN_TYPE_VARNAME = \"origin_type\" !! NetCDF name of the origin type variable (Initial Conditions, Disruption, etc.) character ( * ), parameter :: ORIGIN_TIME_VARNAME = \"origin_time\" !! NetCDF name of the time of origin variable character ( * ), parameter :: ORIGIN_XHX_VARNAME = \"origin_xhx\" !! NetCDF name of the heliocentric position of the body at the time of origin x variable character ( * ), parameter :: ORIGIN_XHY_VARNAME = \"origin_xhy\" !! NetCDF name of the heliocentric position of the body at the time of origin y variable character ( * ), parameter :: ORIGIN_XHZ_VARNAME = \"origin_xhz\" !! NetCDF name of the heliocentric position of the body at the time of origin z variable character ( * ), parameter :: ORIGIN_VHX_VARNAME = \"origin_vhx\" !! NetCDF name of the heliocentric velocity of the body at the time of origin x variable character ( * ), parameter :: ORIGIN_VHY_VARNAME = \"origin_vhy\" !! NetCDF name of the heliocentric velocity of the body at the time of origin y variable character ( * ), parameter :: ORIGIN_VHZ_VARNAME = \"origin_vhz\" !! NetCDF name of the heliocentric velocity of the body at the time of origin z variable character ( * ), parameter :: DISCARD_TIME_VARNAME = \"discard_time\" !! NetCDF name of the time of discard variable character ( * ), parameter :: DISCARD_XHX_VARNAME = \"discard_xhx\" !! NetCDF name of the heliocentric position of the body at the time of discard x variable character ( * ), parameter :: DISCARD_XHY_VARNAME = \"discard_xhy\" !! NetCDF name of the heliocentric position of the body at the time of discard y variable character ( * ), parameter :: DISCARD_XHZ_VARNAME = \"discard_xhz\" !! NetCDF name of the heliocentric position of the body at the time of discard z variable character ( * ), parameter :: DISCARD_VHX_VARNAME = \"discard_vhx\" !! NetCDF name of the heliocentric velocity of the body at the time of discard x variable character ( * ), parameter :: DISCARD_VHY_VARNAME = \"discard_vhy\" !! NetCDF name of the heliocentric velocity of the body at the time of discard y variable character ( * ), parameter :: DISCARD_VHZ_VARNAME = \"discard_vhz\" !! NetCDF name of the heliocentric velocity of the body at the time of discard z variable character ( * ), parameter :: DISCARD_BODY_ID_VARNAME = \"discard_body_id\" !! NetCDF name of the id of the other body involved in the discard end module swiftest_globals","tags":"","loc":"sourcefile/swiftest_globals.f90.html"},{"title":"walltime_classes.f90 – swiftest","text":"This file depends on sourcefile~~walltime_classes.f90~~EfferentGraph sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~walltime_classes.f90~~AfferentGraph sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~kick.f90 kick.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~util_index.f90 util_index.f90 sourcefile~util_index.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~util_sort.f90 util_sort.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~util_spill.f90 util_spill.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~fraggle_regime.f90 fraggle_regime.f90 sourcefile~fraggle_regime.f90->sourcefile~swiftest.f90 sourcefile~util_copy.f90 util_copy.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~fraggle_io.f90 fraggle_io.f90 sourcefile~fraggle_io.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90~2 orbel.f90 sourcefile~orbel.f90~2->sourcefile~swiftest.f90 sourcefile~fraggle_generate.f90 fraggle_generate.f90 sourcefile~fraggle_generate.f90->sourcefile~swiftest.f90 sourcefile~netcdf.f90 netcdf.f90 sourcefile~netcdf.f90->sourcefile~swiftest.f90 sourcefile~util_coord.f90 util_coord.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~gr.f90 gr.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~util_set.f90 util_set.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~fraggle_set.f90 fraggle_set.f90 sourcefile~fraggle_set.f90->sourcefile~swiftest.f90 sourcefile~util_append.f90 util_append.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 sourcefile~util_resize.f90 util_resize.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~drift.f90 drift.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~fraggle_placeholder.f90 fraggle_placeholder.f90 sourcefile~fraggle_placeholder.f90->sourcefile~swiftest.f90 sourcefile~rmvs_io.f90 rmvs_io.f90 sourcefile~rmvs_io.f90->sourcefile~swiftest.f90 sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90 orbel.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~fraggle_setup.f90 fraggle_setup.f90 sourcefile~fraggle_setup.f90->sourcefile~swiftest.f90 sourcefile~obl.f90 obl.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~setup.f90 setup.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~util_fill.f90 util_fill.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~fraggle_util.f90 fraggle_util.f90 sourcefile~fraggle_util.f90->sourcefile~swiftest.f90 sourcefile~helio_setup.f90 helio_setup.f90 sourcefile~helio_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~util_solve.f90 util_solve.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules walltime_classes Source Code walltime_classes.f90 Source Code module walltime_classes !! author: David A. Minton !! !! Classes and methods used to compute elasped wall time use swiftest_globals implicit none public type :: walltimer integer ( I8B ) :: count_rate !! Rate at wich the clock ticks integer ( I8B ) :: count_max !! Maximum value of the clock ticker integer ( I8B ) :: count_start_main !! Value of the clock ticker at when the timer is first called integer ( I8B ) :: count_start_step !! Value of the clock ticker at the start of a timed step integer ( I8B ) :: count_finish_step !! Value of the clock ticker at the end of a timed step logical :: lmain_is_started = . false . !! Logical flag indicating whether or not the main timer has been reset or not contains procedure :: reset => walltime_reset !! Resets the clock ticker, settting main_start to the current ticker value procedure :: start => walltime_start !! Starts the timer, setting step_start to the current ticker value procedure :: finish => walltime_finish !! Ends the timer, setting step_finish to the current ticker value and printing the elapsed time information to the terminal end type interface module subroutine walltime_finish ( self , nsubsteps , message ) implicit none class ( walltimer ), intent ( inout ) :: self !! Walltimer object integer ( I4B ), intent ( in ) :: nsubsteps !! Number of substeps used to compute the time per step character ( len =* ), intent ( in ) :: message !! Message to prepend to the wall time terminal output end subroutine walltime_finish module subroutine walltime_reset ( self ) implicit none class ( walltimer ), intent ( inout ) :: self !! Walltimer object end subroutine walltime_reset module subroutine walltime_start ( self ) implicit none class ( walltimer ), intent ( inout ) :: self !! Walltimer object end subroutine walltime_start end interface contains module subroutine walltime_finish ( self , nsubsteps , message ) !! author: David A. Minton !! !! Ends the timer, setting step_finish to the current ticker value and printing the elapsed time information to the terminal use swiftest_globals implicit none ! Arguments class ( walltimer ), intent ( inout ) :: self !! Walltimer object integer ( I4B ), intent ( in ) :: nsubsteps !! Number of substeps used to compute the time per step character ( len =* ), intent ( in ) :: message !! Message to prepend to the wall time terminal output ! Internals character ( len =* ), parameter :: walltimefmt = '\" Wall time (s): \", es12.5, \"; Wall time/step in this interval (s):  \", es12.5' character ( len = STRMAX ) :: fmt integer ( I8B ) :: count_delta_step , count_delta_main real ( DP ) :: wall_main !! Value of total elapsed time at the end of a timed step real ( DP ) :: wall_step !! Value of elapsed time since the start of a timed step real ( DP ) :: wall_per_substep !! Value of time per substep if (. not . self % lmain_is_started ) then write ( * , * ) \"Wall timer error: The step finish time cannot be calculated because the timer is not started!\" return end if call system_clock ( self % count_finish_step ) count_delta_step = self % count_finish_step - self % count_start_step count_delta_main = self % count_finish_step - self % count_start_main wall_step = count_delta_step / ( self % count_rate * 1.0_DP ) wall_main = count_delta_main / ( self % count_rate * 1.0_DP ) wall_per_substep = wall_step / nsubsteps fmt = '(\"' // adjustl ( message ) // '\",' // walltimefmt // ')' write ( * , trim ( adjustl ( fmt ))) wall_main , wall_per_substep call self % start () return end subroutine walltime_finish module subroutine walltime_reset ( self ) !! author: David A. Minton !! !! Resets the clock ticker, settting main_start to the current ticker value use swiftest_globals implicit none ! Arguments class ( walltimer ), intent ( inout ) :: self call system_clock ( self % count_start_main , self % count_rate , self % count_max ) self % lmain_is_started = . true . call self % start () return end subroutine walltime_reset module subroutine walltime_start ( self ) !! author: David A. Minton !! !! Starts the timer, setting step_start to the current ticker value use swiftest_globals implicit none ! Arguments class ( walltimer ), intent ( inout ) :: self if (. not . self % lmain_is_started ) then write ( * , * ) \"Wall timer error: Cannot start the step time until reset is called at least once!\" return end if call system_clock ( self % count_start_step ) return end subroutine walltime_start end module walltime_classes","tags":"","loc":"sourcefile/walltime_classes.f90.html"},{"title":"swiftest_operators.f90 – swiftest","text":"This file depends on sourcefile~~swiftest_operators.f90~~EfferentGraph sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~swiftest_operators.f90~~AfferentGraph sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~operator_cross.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~operator_mag.f90 operator_mag.f90 sourcefile~operator_mag.f90->sourcefile~swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~kick.f90 kick.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~util_index.f90 util_index.f90 sourcefile~util_index.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~util_sort.f90 util_sort.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~util_spill.f90 util_spill.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~fraggle_regime.f90 fraggle_regime.f90 sourcefile~fraggle_regime.f90->sourcefile~swiftest.f90 sourcefile~util_copy.f90 util_copy.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~fraggle_io.f90 fraggle_io.f90 sourcefile~fraggle_io.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90~2 orbel.f90 sourcefile~orbel.f90~2->sourcefile~swiftest.f90 sourcefile~fraggle_generate.f90 fraggle_generate.f90 sourcefile~fraggle_generate.f90->sourcefile~swiftest.f90 sourcefile~netcdf.f90 netcdf.f90 sourcefile~netcdf.f90->sourcefile~swiftest.f90 sourcefile~util_coord.f90 util_coord.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~gr.f90 gr.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~util_set.f90 util_set.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~fraggle_set.f90 fraggle_set.f90 sourcefile~fraggle_set.f90->sourcefile~swiftest.f90 sourcefile~util_append.f90 util_append.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 sourcefile~util_resize.f90 util_resize.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~drift.f90 drift.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~fraggle_placeholder.f90 fraggle_placeholder.f90 sourcefile~fraggle_placeholder.f90->sourcefile~swiftest.f90 sourcefile~rmvs_io.f90 rmvs_io.f90 sourcefile~rmvs_io.f90->sourcefile~swiftest.f90 sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90 orbel.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~fraggle_setup.f90 fraggle_setup.f90 sourcefile~fraggle_setup.f90->sourcefile~swiftest.f90 sourcefile~obl.f90 obl.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~setup.f90 setup.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~util_fill.f90 util_fill.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~fraggle_util.f90 fraggle_util.f90 sourcefile~fraggle_util.f90->sourcefile~swiftest.f90 sourcefile~helio_setup.f90 helio_setup.f90 sourcefile~helio_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~util_solve.f90 util_solve.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules swiftest_operators Source Code swiftest_operators.f90 Source Code module swiftest_operators !! author: David A. Minton !! !! Custom operators, including !!   A .cross. B = Cross product of A(1:3) and B(1:3) !! !! Each operator can also do element-wise computation on arrays of the form .mag. A(1:3, 1:n) use swiftest_globals implicit none public !******************************************************************************************************************************** ! Interfaces for .cross. operator !******************************************************************************************************************************** interface operator (. cross .) module pure function operator_cross_sp ( A , B ) result ( C ) implicit none real ( SP ), dimension (:), intent ( in ) :: A , B real ( SP ), dimension ( 3 ) :: C end function operator_cross_sp module pure function operator_cross_dp ( A , B ) result ( C ) implicit none real ( DP ), dimension (:), intent ( in ) :: A , B real ( DP ), dimension ( 3 ) :: C end function operator_cross_dp module pure function operator_cross_qp ( A , B ) result ( C ) implicit none real ( QP ), dimension (:), intent ( in ) :: A , B real ( QP ), dimension ( 3 ) :: C end function operator_cross_qp module pure function operator_cross_i1b ( A , B ) result ( C ) implicit none integer ( I1B ), dimension (:), intent ( in ) :: A , B integer ( I1B ), dimension ( 3 ) :: C end function operator_cross_i1b module pure function operator_cross_i2b ( A , B ) result ( C ) implicit none integer ( I2B ), dimension (:), intent ( in ) :: A , B integer ( I2B ), dimension ( 3 ) :: C end function operator_cross_i2b module pure function operator_cross_i4b ( A , B ) result ( C ) implicit none integer ( I4B ), dimension (:), intent ( in ) :: A , B integer ( I4B ), dimension ( 3 ) :: C end function operator_cross_i4b module pure function operator_cross_i8b ( A , B ) result ( C ) implicit none integer ( I8B ), dimension (:), intent ( in ) :: A , B integer ( I8B ), dimension ( 3 ) :: C end function operator_cross_i8b module pure function operator_cross_el_sp ( A , B ) result ( C ) implicit none real ( SP ), dimension (:,:), intent ( in ) :: A , B real ( SP ), dimension (:,:), allocatable :: C end function operator_cross_el_sp module pure function operator_cross_el_dp ( A , B ) result ( C ) implicit none real ( DP ), dimension (:,:), intent ( in ) :: A , B real ( DP ), dimension (:,:), allocatable :: C end function operator_cross_el_dp module pure function operator_cross_el_qp ( A , B ) result ( C ) implicit none real ( QP ), dimension (:,:), intent ( in ) :: A , B real ( QP ), dimension (:,:), allocatable :: C end function operator_cross_el_qp module pure function operator_cross_el_i1b ( A , B ) result ( C ) implicit none integer ( I1B ), dimension (:,:), intent ( in ) :: A , B integer ( I1B ), dimension (:,:), allocatable :: C end function operator_cross_el_i1b module pure function operator_cross_el_i2b ( A , B ) result ( C ) implicit none integer ( I2B ), dimension (:,:), intent ( in ) :: A , B integer ( I2B ), dimension (:,:), allocatable :: C end function operator_cross_el_i2b module pure function operator_cross_el_i4b ( A , B ) result ( C ) implicit none integer ( I4B ), dimension (:,:), intent ( in ) :: A , B integer ( I4B ), dimension (:,:), allocatable :: C end function operator_cross_el_i4b module pure function operator_cross_el_i8b ( A , B ) result ( C ) implicit none integer ( I8B ), dimension (:,:), intent ( in ) :: A , B integer ( I8B ), dimension (:,:), allocatable :: C end function operator_cross_el_i8b end interface !******************************************************************************************************************************** ! Interfaces for .mag. operator !******************************************************************************************************************************** interface operator (. mag .) module pure function operator_mag_sp ( A ) result ( B ) implicit none real ( SP ), dimension (:), intent ( in ) :: A real ( SP ) :: B end function operator_mag_sp module pure function operator_mag_dp ( A ) result ( B ) implicit none real ( DP ), dimension (:), intent ( in ) :: A real ( DP ) :: B end function operator_mag_dp module pure function operator_mag_qp ( A ) result ( B ) implicit none real ( QP ), dimension (:), intent ( in ) :: A real ( QP ) :: B end function operator_mag_qp module pure function operator_mag_el_sp ( A ) result ( B ) implicit none real ( SP ), dimension (:,:), intent ( in ) :: A real ( SP ), dimension (:), allocatable :: B end function operator_mag_el_sp module pure function operator_mag_el_dp ( A ) result ( B ) implicit none real ( DP ), dimension (:,:), intent ( in ) :: A real ( DP ), dimension (:), allocatable :: B end function operator_mag_el_dp module pure function operator_mag_el_qp ( A ) result ( B ) implicit none real ( QP ), dimension (:,:), intent ( in ) :: A real ( QP ), dimension (:), allocatable :: B end function operator_mag_el_qp end interface end module swiftest_operators","tags":"","loc":"sourcefile/swiftest_operators.f90.html"},{"title":"helio_classes.f90 – swiftest","text":"This file depends on sourcefile~~helio_classes.f90~~EfferentGraph sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~helio_classes.f90~~AfferentGraph sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_gr.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~helio_classes.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_setup.f90 helio_setup.f90 sourcefile~helio_setup.f90->sourcefile~helio_classes.f90 sourcefile~helio_setup.f90->sourcefile~swiftest.f90 sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_step.f90->sourcefile~helio_classes.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_kick.f90->sourcefile~helio_classes.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_collision.f90->sourcefile~symba_classes.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~symba_classes.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~kick.f90 kick.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~symba_classes.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_discard.f90->sourcefile~symba_classes.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~util_index.f90 util_index.f90 sourcefile~util_index.f90->sourcefile~swiftest.f90 sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~util_sort.f90 util_sort.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~util_spill.f90 util_spill.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~fraggle_regime.f90 fraggle_regime.f90 sourcefile~fraggle_regime.f90->sourcefile~swiftest.f90 sourcefile~util_copy.f90 util_copy.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90~2 orbel.f90 sourcefile~orbel.f90~2->sourcefile~swiftest.f90 sourcefile~fraggle_io.f90 fraggle_io.f90 sourcefile~fraggle_io.f90->sourcefile~swiftest.f90 sourcefile~fraggle_generate.f90 fraggle_generate.f90 sourcefile~fraggle_generate.f90->sourcefile~swiftest.f90 sourcefile~netcdf.f90 netcdf.f90 sourcefile~netcdf.f90->sourcefile~swiftest.f90 sourcefile~util_coord.f90 util_coord.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~gr.f90 gr.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~util_set.f90 util_set.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_io.f90->sourcefile~symba_classes.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~fraggle_set.f90 fraggle_set.f90 sourcefile~fraggle_set.f90->sourcefile~swiftest.f90 sourcefile~util_append.f90 util_append.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 sourcefile~util_resize.f90 util_resize.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~drift.f90 drift.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_util.f90->sourcefile~symba_classes.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~fraggle_placeholder.f90 fraggle_placeholder.f90 sourcefile~fraggle_placeholder.f90->sourcefile~swiftest.f90 sourcefile~rmvs_io.f90 rmvs_io.f90 sourcefile~rmvs_io.f90->sourcefile~swiftest.f90 sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90 orbel.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~fraggle_setup.f90 fraggle_setup.f90 sourcefile~fraggle_setup.f90->sourcefile~swiftest.f90 sourcefile~obl.f90 obl.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_encounter_check.f90->sourcefile~symba_classes.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_drift.f90->sourcefile~symba_classes.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~setup.f90 setup.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~util_fill.f90 util_fill.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~fraggle_util.f90 fraggle_util.f90 sourcefile~fraggle_util.f90->sourcefile~swiftest.f90 sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~util_solve.f90 util_solve.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_setup.f90->sourcefile~symba_classes.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules helio_classes Source Code helio_classes.f90 Source Code module helio_classes !! author: The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Definition of classes and methods specific to the Democratic Heliocentric Method !! Adapted from David E. Kaufmann's Swifter routine: module_helio.f90 use swiftest_globals use swiftest_classes , only : swiftest_cb , swiftest_pl , swiftest_tp , swiftest_nbody_system use whm_classes , only : whm_nbody_system implicit none public !******************************************************************************************************************************** !  helio_nbody_system class definitions and method interfaces !******************************************************************************************************************************** type , extends ( whm_nbody_system ) :: helio_nbody_system contains procedure :: step => helio_step_system !! Advance the Helio nbody system forward in time by one step procedure :: initialize => helio_setup_initialize_system !! Performs Helio-specific initilization steps, including converting to DH coordinates end type helio_nbody_system !******************************************************************************************************************************** ! helio_cb class definitions and method interfaces !******************************************************************************************************************************* !> Helio central body particle class type , extends ( swiftest_cb ) :: helio_cb real ( DP ), dimension ( NDIM ) :: ptbeg !! negative barycentric velocity of the central body at the beginning of time step real ( DP ), dimension ( NDIM ) :: ptend !! negative barycentric velocity of the central body at the end of time step contains end type helio_cb !******************************************************************************************************************************** !                                    helio_pl class definitions and method interfaces !******************************************************************************************************************************* !! Helio massive body particle class type , extends ( swiftest_pl ) :: helio_pl contains procedure :: drift => helio_drift_pl !! Method for Danby drift in Democratic Heliocentric coordinates procedure :: lindrift => helio_drift_linear_pl !! Method for linear drift of massive bodies due to barycentric momentum of Sun procedure :: accel_gr => helio_gr_kick_getacch_pl !! Acceleration term arising from the post-Newtonian correction procedure :: gr_pos_kick => helio_gr_p4_pl !! Position kick due to p**4 term in the post-Newtonian correction procedure :: accel => helio_kick_getacch_pl !! Compute heliocentric accelerations of massive bodies procedure :: kick => helio_kick_vb_pl !! Kicks the barycentric velocities procedure :: step => helio_step_pl !! Steps the body forward one stepsize end type helio_pl !******************************************************************************************************************************** !                                    helio_tp class definitions and method interfaces !******************************************************************************************************************************* !! Helio test particle class type , extends ( swiftest_tp ) :: helio_tp contains procedure :: lindrift => helio_drift_linear_tp !! Method for linear drift of massive bodies due to barycentric momentum of Sun procedure :: drift => helio_drift_tp !! Method for Danby drift in Democratic Heliocentric coordinates procedure :: accel_gr => helio_gr_kick_getacch_tp !! Acceleration term arising from the post-Newtonian correction procedure :: gr_pos_kick => helio_gr_p4_tp !! Position kick due to p**4 term in the post-Newtonian correction procedure :: accel => helio_kick_getacch_tp !! Compute heliocentric accelerations of massive bodies procedure :: kick => helio_kick_vb_tp !! Kicks the barycentric velocities procedure :: step => helio_step_tp !! Steps the body forward one stepsize end type helio_tp interface module subroutine helio_drift_body ( self , system , param , dt ) use swiftest_classes , only : swiftest_body , swiftest_nbody_system , swiftest_parameters implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize end subroutine helio_drift_body module subroutine helio_drift_pl ( self , system , param , dt ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( helio_pl ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize end subroutine helio_drift_pl module subroutine helio_drift_tp ( self , system , param , dt ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( helio_tp ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize end subroutine helio_drift_tp module subroutine helio_drift_linear_pl ( self , cb , dt , lbeg ) implicit none class ( helio_pl ), intent ( inout ) :: self !! Helio massive body object class ( helio_cb ), intent ( inout ) :: cb !! Helio central body real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Argument that determines whether or not this is the beginning or end of the step end subroutine helio_drift_linear_pl module subroutine helio_drift_linear_tp ( self , cb , dt , lbeg ) implicit none class ( helio_tp ), intent ( inout ) :: self !! Helio test particle object class ( helio_cb ), intent ( in ) :: cb !! Helio central body real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Argument that determines whether or not this is the beginning or end of the step end subroutine helio_drift_linear_tp module pure subroutine helio_gr_kick_getacch_pl ( self , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( helio_pl ), intent ( inout ) :: self !! Helio massive body particle data structure class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine helio_gr_kick_getacch_pl module pure subroutine helio_gr_kick_getacch_tp ( self , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( helio_tp ), intent ( inout ) :: self !! Helio massive body particle data structure class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine helio_gr_kick_getacch_tp module pure subroutine helio_gr_p4_pl ( self , param , dt ) use swiftest_classes , only : swiftest_parameters implicit none class ( helio_pl ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Step size end subroutine helio_gr_p4_pl module pure subroutine helio_gr_p4_tp ( self , param , dt ) use swiftest_classes , only : swiftest_parameters implicit none class ( helio_tp ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Step size end subroutine helio_gr_p4_tp module subroutine helio_kick_getacch_pl ( self , system , param , t , lbeg ) use swiftest_classes , only : swiftest_parameters , swiftest_nbody_system implicit none class ( helio_pl ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step end subroutine helio_kick_getacch_pl module subroutine helio_kick_getacch_tp ( self , system , param , t , lbeg ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( helio_tp ), intent ( inout ) :: self !! Helio test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step end subroutine helio_kick_getacch_tp module subroutine helio_kick_vb_pl ( self , system , param , t , dt , lbeg ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( helio_pl ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Logical flag indicating whether this is the beginning of the half step or not. end subroutine helio_kick_vb_pl module subroutine helio_kick_vb_tp ( self , system , param , t , dt , lbeg ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( helio_tp ), intent ( inout ) :: self !! Helio test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Logical flag indicating whether this is the beginning of the half step or not. end subroutine helio_kick_vb_tp module subroutine helio_setup_initialize_system ( self , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( helio_nbody_system ), intent ( inout ) :: self !! Helio nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine helio_setup_initialize_system module subroutine helio_step_pl ( self , system , param , t , dt ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( helio_pl ), intent ( inout ) :: self !! Helio massive body particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nboody system class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Stepsize end subroutine helio_step_pl module subroutine helio_step_system ( self , param , t , dt ) use swiftest_classes , only : swiftest_parameters implicit none class ( helio_nbody_system ), intent ( inout ) :: self !! Helio nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize end subroutine helio_step_system module subroutine helio_step_tp ( self , system , param , t , dt ) use swiftest_classes , only : swiftest_cb , swiftest_parameters , swiftest_nbody_system implicit none class ( helio_tp ), intent ( inout ) :: self !! Helio test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Stepsizee end subroutine helio_step_tp end interface end module helio_classes","tags":"","loc":"sourcefile/helio_classes.f90.html"},{"title":"whm_classes.f90 – swiftest","text":"This file depends on sourcefile~~whm_classes.f90~~EfferentGraph sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~whm_classes.f90~~AfferentGraph sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_setup.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_util.f90->sourcefile~whm_classes.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_gr.f90->sourcefile~whm_classes.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_drift.f90->sourcefile~whm_classes.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_step.f90->sourcefile~whm_classes.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_kick.f90->sourcefile~whm_classes.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_coord.f90->sourcefile~whm_classes.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~symba_collision.f90->sourcefile~symba_classes.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90->sourcefile~symba_classes.f90 sourcefile~kick.f90 kick.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~util_index.f90 util_index.f90 sourcefile~util_index.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90->sourcefile~symba_classes.f90 sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~symba_discard.f90->sourcefile~symba_classes.f90 sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~rmvs_classes.f90 sourcefile~util_sort.f90 util_sort.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~util_spill.f90 util_spill.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~fraggle_regime.f90 fraggle_regime.f90 sourcefile~fraggle_regime.f90->sourcefile~swiftest.f90 sourcefile~util_copy.f90 util_copy.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90~2 orbel.f90 sourcefile~orbel.f90~2->sourcefile~swiftest.f90 sourcefile~fraggle_io.f90 fraggle_io.f90 sourcefile~fraggle_io.f90->sourcefile~swiftest.f90 sourcefile~fraggle_generate.f90 fraggle_generate.f90 sourcefile~fraggle_generate.f90->sourcefile~swiftest.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~netcdf.f90 netcdf.f90 sourcefile~netcdf.f90->sourcefile~swiftest.f90 sourcefile~util_coord.f90 util_coord.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~helio_classes.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~gr.f90 gr.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~util_set.f90 util_set.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~symba_io.f90->sourcefile~symba_classes.f90 sourcefile~fraggle_set.f90 fraggle_set.f90 sourcefile~fraggle_set.f90->sourcefile~swiftest.f90 sourcefile~util_append.f90 util_append.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 sourcefile~util_resize.f90 util_resize.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90->sourcefile~rmvs_classes.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~drift.f90 drift.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_gr.f90->sourcefile~helio_classes.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~symba_util.f90->sourcefile~symba_classes.f90 sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~fraggle_placeholder.f90 fraggle_placeholder.f90 sourcefile~fraggle_placeholder.f90->sourcefile~swiftest.f90 sourcefile~rmvs_io.f90 rmvs_io.f90 sourcefile~rmvs_io.f90->sourcefile~swiftest.f90 sourcefile~rmvs_io.f90->sourcefile~rmvs_classes.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_kick.f90->sourcefile~helio_classes.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90 orbel.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~fraggle_setup.f90 fraggle_setup.f90 sourcefile~fraggle_setup.f90->sourcefile~swiftest.f90 sourcefile~obl.f90 obl.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~setup.f90 setup.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~symba_encounter_check.f90->sourcefile~symba_classes.f90 sourcefile~util_fill.f90 util_fill.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~symba_drift.f90->sourcefile~symba_classes.f90 sourcefile~fraggle_util.f90 fraggle_util.f90 sourcefile~fraggle_util.f90->sourcefile~swiftest.f90 sourcefile~helio_setup.f90 helio_setup.f90 sourcefile~helio_setup.f90->sourcefile~helio_classes.f90 sourcefile~helio_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_setup.f90->sourcefile~rmvs_classes.f90 sourcefile~util_solve.f90 util_solve.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_step.f90->sourcefile~helio_classes.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90->sourcefile~symba_classes.f90 sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_step.f90->sourcefile~rmvs_classes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules whm_classes Source Code whm_classes.f90 Source Code module whm_classes !! author: David A. Minton !! !! Definition of classes and methods specific to the Democratic Heliocentric Method !! Partially adapted from David E. Kaufmann's Swifter module: module_whm.f90 use swiftest_globals use swiftest_classes , only : swiftest_cb , swiftest_pl , swiftest_tp , swiftest_nbody_system implicit none public !******************************************************************************************************************************** ! whm_cb class definitions and method interfaces !******************************************************************************************************************************* !> Swiftest central body particle class type , extends ( swiftest_cb ) :: whm_cb contains end type whm_cb !******************************************************************************************************************************** !                                    whm_pl class definitions and method interfaces !******************************************************************************************************************************* !> WHM massive body particle class type , extends ( swiftest_pl ) :: whm_pl real ( DP ), dimension (:), allocatable :: eta !! Jacobi mass real ( DP ), dimension (:,:), allocatable :: xj !! Jacobi position real ( DP ), dimension (:,:), allocatable :: vj !! Jacobi velocity real ( DP ), dimension (:), allocatable :: muj !! Jacobi mu: GMcb * eta(i) / eta(i - 1) real ( DP ), dimension (:), allocatable :: ir3j !! Third term of heliocentric acceleration !! Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the !!    component list, such as whm_setup_pl and whm_util_spill_pl contains procedure :: h2j => whm_coord_h2j_pl !! Convert position and velcoity vectors from heliocentric to Jacobi coordinates procedure :: j2h => whm_coord_j2h_pl !! Convert position and velcoity vectors from Jacobi to helliocentric coordinates procedure :: vh2vj => whm_coord_vh2vj_pl !! Convert velocity vectors from heliocentric to Jacobi coordinates procedure :: drift => whm_drift_pl !! Loop through massive bodies and call Danby drift routine to jacobi coordinates procedure :: accel_gr => whm_gr_kick_getacch_pl !! Acceleration term arising from the post-Newtonian correction procedure :: gr_pos_kick => whm_gr_p4_pl !! Position kick due to p**4 term in the post-Newtonian correction procedure :: accel => whm_kick_getacch_pl !! Compute heliocentric accelerations of massive bodies procedure :: kick => whm_kick_vh_pl !! Kick heliocentric velocities of massive bodies procedure :: append => whm_util_append_pl !! Appends elements from one structure to another procedure :: fill => whm_util_fill_pl !! \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure :: resize => whm_util_resize_pl !! Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure :: set_ir3 => whm_util_set_ir3j !! Sets both the heliocentric and jacobi inverse radius terms (1/rj**3 and 1/rh**3) procedure :: set_mu => whm_util_set_mu_eta_pl !! Sets the Jacobi mass value for all massive bodies. procedure :: sort => whm_util_sort_pl !! Sort a WHM massive body object in-place. procedure :: rearrange => whm_util_sort_rearrange_pl !! Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure :: spill => whm_util_spill_pl !!\"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure :: setup => whm_setup_pl !! Constructor method - Allocates space for the input number of bodiess procedure :: step => whm_step_pl !! Steps the body forward one stepsize end type whm_pl !******************************************************************************************************************************** !  whm_tp class definitions and method interfaces !******************************************************************************************************************************* !! WHM test particle class type , extends ( swiftest_tp ) :: whm_tp !! Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the !!    component list, such as whm_util_spill_tp contains procedure :: accel_gr => whm_gr_kick_getacch_tp !! Acceleration term arising from the post-Newtonian correction procedure :: gr_pos_kick => whm_gr_p4_tp !! Position kick due to p**4 term in the post-Newtonian correction procedure :: accel => whm_kick_getacch_tp !! Compute heliocentric accelerations of test particles procedure :: kick => whm_kick_vh_tp !! Kick heliocentric velocities of test particles procedure :: step => whm_step_tp !! Steps the particle forward one stepsize end type whm_tp !******************************************************************************************************************************** !  whm_nbody_system class definitions and method interfaces !******************************************************************************************************************************** !> An abstract class for the WHM integrator nbody system type , extends ( swiftest_nbody_system ) :: whm_nbody_system contains !> Replace the abstract procedures with concrete ones procedure :: initialize => whm_setup_initialize_system ! Performs WHM-specific initilization steps, like calculating the Jacobi masses procedure :: step => whm_step_system !! Advance the WHM nbody system forward in time by one step end type whm_nbody_system interface module subroutine whm_coord_h2j_pl ( self , cb ) use swiftest_classes , only : swiftest_cb implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body particle data structuree end subroutine whm_coord_h2j_pl module subroutine whm_coord_j2h_pl ( self , cb ) use swiftest_classes , only : swiftest_cb implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body particle data structuree end subroutine whm_coord_j2h_pl module subroutine whm_coord_vh2vj_pl ( self , cb ) use swiftest_classes , only : swiftest_cb implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body particle data structuree end subroutine whm_coord_vh2vj_pl module subroutine whm_drift_pl ( self , system , param , dt ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! WHM nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize end subroutine whm_drift_pl module subroutine whm_util_index_eucl_plpl ( self , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine whm_util_index_eucl_plpl !> Get heliocentric accelration of massive bodies module subroutine whm_kick_getacch_pl ( self , system , param , t , lbeg ) use swiftest_classes , only : swiftest_cb , swiftest_parameters implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! WHM nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step end subroutine whm_kick_getacch_pl !> Get heliocentric accelration of the test particle module subroutine whm_kick_getacch_tp ( self , system , param , t , lbeg ) use swiftest_classes , only : swiftest_cb , swiftest_parameters implicit none class ( whm_tp ), intent ( inout ) :: self !! WHM test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! WHM nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step end subroutine whm_kick_getacch_tp module subroutine whm_kick_vh_pl ( self , system , param , t , dt , lbeg ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Logical flag indicating whether this is the beginning of the half step or not. end subroutine whm_kick_vh_pl module subroutine whm_kick_vh_tp ( self , system , param , t , dt , lbeg ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( whm_tp ), intent ( inout ) :: self !! WHM test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Logical flag indicating whether this is the beginning of the half step or not. end subroutine whm_kick_vh_tp module pure subroutine whm_gr_kick_getacch_pl ( self , param ) use swiftest_classes , only : swiftest_cb , swiftest_parameters implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body particle data structure class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine whm_gr_kick_getacch_pl module pure subroutine whm_gr_kick_getacch_tp ( self , param ) use swiftest_classes , only : swiftest_cb , swiftest_parameters implicit none class ( whm_tp ), intent ( inout ) :: self !! WHM test particle data structure class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine whm_gr_kick_getacch_tp module pure subroutine whm_gr_p4_pl ( self , param , dt ) use swiftest_classes , only : swiftest_parameters implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Step size end subroutine whm_gr_p4_pl module pure subroutine whm_gr_p4_tp ( self , param , dt ) use swiftest_classes , only : swiftest_parameters implicit none class ( whm_tp ), intent ( inout ) :: self !! WHM test particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Step size end subroutine whm_gr_p4_tp !> Reads WHM massive body object in from file module subroutine whm_setup_pl ( self , n , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body objectobject integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine whm_setup_pl module subroutine whm_setup_initialize_system ( self , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( whm_nbody_system ), intent ( inout ) :: self !! WHM nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine whm_setup_initialize_system module subroutine whm_step_pl ( self , system , param , t , dt ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize end subroutine whm_step_pl module subroutine whm_step_system ( self , param , t , dt ) use swiftest_classes , only : swiftest_parameters implicit none class ( whm_nbody_system ), intent ( inout ) :: self !! WHM system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize end subroutine whm_step_system module subroutine whm_step_tp ( self , system , param , t , dt ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( whm_tp ), intent ( inout ) :: self !! WHM test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Stepsize end subroutine whm_step_tp module subroutine whm_util_append_pl ( self , source , lsource_mask ) use swiftest_classes , only : swiftest_body implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine whm_util_append_pl module subroutine whm_util_spill_pl ( self , discards , lspill_list , ldestructive ) use swiftest_classes , only : swiftest_body implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine whm_util_spill_pl module subroutine whm_util_fill_pl ( self , inserts , lfill_list ) use swiftest_classes , only : swiftest_body implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_body ), intent ( in ) :: inserts !! inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine whm_util_fill_pl module subroutine whm_util_resize_pl ( self , nnew ) implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object integer ( I4B ), intent ( in ) :: nnew !! New size neded end subroutine whm_util_resize_pl module subroutine whm_util_set_ir3j ( self ) implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object end subroutine whm_util_set_ir3j module subroutine whm_util_set_mu_eta_pl ( self , cb ) use swiftest_classes , only : swiftest_cb implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine whm_util_set_mu_eta_pl module subroutine whm_util_sort_pl ( self , sortby , ascending ) implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order end subroutine whm_util_sort_pl module subroutine whm_util_sort_rearrange_pl ( self , ind ) implicit none class ( whm_pl ), intent ( inout ) :: self !! WHM massive body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) end subroutine whm_util_sort_rearrange_pl end interface end module whm_classes","tags":"","loc":"sourcefile/whm_classes.f90.html"},{"title":"fraggle_classes.f90 – swiftest","text":"This file depends on sourcefile~~fraggle_classes.f90~~EfferentGraph sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~fraggle_classes.f90~~AfferentGraph sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~fraggle_generate.f90 fraggle_generate.f90 sourcefile~fraggle_generate.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~fraggle_generate.f90->sourcefile~swiftest.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~fraggle_setup.f90 fraggle_setup.f90 sourcefile~fraggle_setup.f90->sourcefile~fraggle_classes.f90 sourcefile~fraggle_setup.f90->sourcefile~swiftest.f90 sourcefile~fraggle_util.f90 fraggle_util.f90 sourcefile~fraggle_util.f90->sourcefile~fraggle_classes.f90 sourcefile~fraggle_util.f90->sourcefile~swiftest.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~fraggle_placeholder.f90 fraggle_placeholder.f90 sourcefile~fraggle_placeholder.f90->sourcefile~fraggle_classes.f90 sourcefile~fraggle_placeholder.f90->sourcefile~swiftest.f90 sourcefile~fraggle_regime.f90 fraggle_regime.f90 sourcefile~fraggle_regime.f90->sourcefile~fraggle_classes.f90 sourcefile~fraggle_regime.f90->sourcefile~swiftest.f90 sourcefile~fraggle_io.f90 fraggle_io.f90 sourcefile~fraggle_io.f90->sourcefile~fraggle_classes.f90 sourcefile~fraggle_io.f90->sourcefile~swiftest.f90 sourcefile~fraggle_set.f90 fraggle_set.f90 sourcefile~fraggle_set.f90->sourcefile~fraggle_classes.f90 sourcefile~fraggle_set.f90->sourcefile~swiftest.f90 sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_collision.f90->sourcefile~symba_classes.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~symba_classes.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~kick.f90 kick.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~symba_classes.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_discard.f90->sourcefile~symba_classes.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~util_index.f90 util_index.f90 sourcefile~util_index.f90->sourcefile~swiftest.f90 sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~util_sort.f90 util_sort.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~util_spill.f90 util_spill.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~util_copy.f90 util_copy.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90~2 orbel.f90 sourcefile~orbel.f90~2->sourcefile~swiftest.f90 sourcefile~netcdf.f90 netcdf.f90 sourcefile~netcdf.f90->sourcefile~swiftest.f90 sourcefile~util_coord.f90 util_coord.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~gr.f90 gr.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~util_set.f90 util_set.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_io.f90->sourcefile~symba_classes.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~util_append.f90 util_append.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 sourcefile~util_resize.f90 util_resize.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~drift.f90 drift.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_util.f90->sourcefile~symba_classes.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_io.f90 rmvs_io.f90 sourcefile~rmvs_io.f90->sourcefile~swiftest.f90 sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90 orbel.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~obl.f90 obl.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_encounter_check.f90->sourcefile~symba_classes.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_drift.f90->sourcefile~symba_classes.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~setup.f90 setup.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~util_fill.f90 util_fill.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~helio_setup.f90 helio_setup.f90 sourcefile~helio_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~util_solve.f90 util_solve.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_setup.f90->sourcefile~symba_classes.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules fraggle_classes Source Code fraggle_classes.f90 Source Code module fraggle_classes !! author: The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Definition of classes and methods specific to Fraggel: The Fragment Generation Model use swiftest_globals use swiftest_classes , only : swiftest_parameters , swiftest_nbody_system , swiftest_cb , swiftest_pl implicit none public integer ( I4B ), parameter :: FRAGGLE_NMASS_DIST = 3 !! Number of mass bins returned by the regime calculation (largest fragment, second largest, and remainder) character ( len =* ), parameter :: FRAGGLE_LOG_OUT = \"fraggle.log\" !! Name of log file for Fraggle diagnostic information integer ( I4B ), parameter :: FRAGGLE_LOG_UNIT = 76 !! Unit number for Fraggle log file !******************************************************************************************************************************** !                                    fraggle_colliders class definitions and method interfaces !******************************************************************************************************************************* !> Class definition for the variables that describe the bodies involved in the collision type :: fraggle_colliders integer ( I4B ) :: ncoll !! Number of bodies involved in the collision integer ( I4B ), dimension (:), allocatable :: idx !! Index of bodies involved in the collision real ( DP ), dimension ( NDIM , 2 ) :: xb !! Two-body equivalent position vectors of the collider bodies prior to collision real ( DP ), dimension ( NDIM , 2 ) :: vb !! Two-body equivalent velocity vectors of the collider bodies prior to collision real ( DP ), dimension ( NDIM , 2 ) :: rot !! Two-body equivalent principal axes moments of inertia the collider bodies prior to collision real ( DP ), dimension ( NDIM , 2 ) :: L_spin !! Two-body equivalent spin angular momentum vectors of the collider bodies prior to collision real ( DP ), dimension ( NDIM , 2 ) :: L_orbit !! Two-body equivalent orbital angular momentum vectors of the collider bodies prior to collision real ( DP ), dimension ( NDIM , 2 ) :: Ip !! Two-body equivalent principal axes moments of inertia the collider bodies prior to collision real ( DP ), dimension ( 2 ) :: mass !! Two-body equivalent mass of the collider bodies prior to the collision real ( DP ), dimension ( 2 ) :: radius !! Two-body equivalent radii of the collider bodies prior to the collision contains procedure :: regime => fraggle_regime_colliders !! Determine which fragmentation regime the set of colliders will be end type fraggle_colliders !******************************************************************************************************************************** !                                    fraggle_fragments class definitions and method interfaces !******************************************************************************************************************************* !> Class definition for the variables that describe a collection of fragments by Fraggle barycentric coordinates type , extends ( swiftest_pl ) :: fraggle_fragments real ( DP ) :: mtot !! Total mass of fragments real ( DP ) :: Qloss !! Energy lost during the collision real ( DP ), dimension ( FRAGGLE_NMASS_DIST ) :: mass_dist !! Distribution of fragment mass determined by the regime calculation (largest fragment, second largest, and remainder) integer ( I4B ) :: regime !! Collresolve regime code for this collision ! Values in a coordinate frame centered on the collider barycenter and collisional system unit vectors (these are used internally by the fragment generation subroutine) real ( DP ), dimension ( NDIM ) :: xbcom !! Center of mass position vector of the collider system in system barycentric coordinates real ( DP ), dimension ( NDIM ) :: vbcom !! Velocity vector of the center of mass of the collider system in system barycentric coordinates real ( DP ), dimension ( NDIM ) :: x_coll_unit !! x-direction unit vector of collisional system real ( DP ), dimension ( NDIM ) :: y_coll_unit !! y-direction unit vector of collisional system real ( DP ), dimension ( NDIM ) :: z_coll_unit !! z-direction unit vector of collisional system real ( DP ), dimension (:,:), allocatable :: x_coll !! Array of fragment position vectors in the collisional coordinate frame real ( DP ), dimension (:,:), allocatable :: v_coll !! Array of fragment velocity vectors in the collisional coordinate frame real ( DP ), dimension (:,:), allocatable :: v_r_unit !! Array of radial direction unit vectors of individual fragments in the collisional coordinate frame real ( DP ), dimension (:,:), allocatable :: v_t_unit !! Array of tangential direction unit vectors of individual fragments in the collisional coordinate frame real ( DP ), dimension (:,:), allocatable :: v_n_unit !! Array of normal direction unit vectors of individual fragments in the collisional coordinate frame real ( DP ), dimension (:), allocatable :: rmag !! Array of radial distance magnitudes of individual fragments in the collisional coordinate frame real ( DP ), dimension (:), allocatable :: rotmag !! Array of rotation magnitudes of individual fragments real ( DP ), dimension (:), allocatable :: v_r_mag !! Array of radial direction velocity magnitudes of individual fragments real ( DP ), dimension (:), allocatable :: v_t_mag !! Array of tangential direction velocity magnitudes of individual fragments ! Energy and momentum book-keeping variables that characterize the whole system of fragments real ( DP ) :: ke_orbit !! Current orbital kinetic energy of the system of fragments in the collisional frame real ( DP ) :: ke_spin !! Current spin kinetic energy of the system of fragments in the collisional frame real ( DP ), dimension ( NDIM ) :: L_orbit !! Current orbital angular momentum of the system of fragments in the collisional frame real ( DP ), dimension ( NDIM ) :: L_spin !! Current spin angular momentum of the system of fragments in the collisional frame real ( DP ) :: ke_budget !! Total kinetic energy budget for the system of fragmens in the collisional frame real ( DP ), dimension ( NDIM ) :: L_budget !! Total angular momentum budget for the system of fragmens in the collisional frame ! For the following variables, \"before\" refers to the *entire* n-body system in its pre-collisional state and \"after\" refers to the system in its post-collisional state real ( DP ), dimension ( NDIM ) :: Lorbit_before , Lorbit_after !! Before/after orbital angular momentum real ( DP ), dimension ( NDIM ) :: Lspin_before , Lspin_after !! Before/after spin angular momentum real ( DP ), dimension ( NDIM ) :: Ltot_before , Ltot_after !! Before/after total system angular momentum real ( DP ) :: ke_orbit_before , ke_orbit_after !! Before/after orbital kinetic energy real ( DP ) :: ke_spin_before , ke_spin_after !! Before/after spin kinetic energy real ( DP ) :: pe_before , pe_after !! Before/after potential energy real ( DP ) :: Etot_before , Etot_after !! Before/after total system energy ! Scale factors used to scale dimensioned quantities to a more \"natural\" system where important quantities (like kinetic energy, momentum) are of order ~1 real ( DP ) :: dscale !! Distance dimension scale factor real ( DP ) :: mscale !! Mass scale factor real ( DP ) :: tscale !! Time scale factor real ( DP ) :: vscale !! Velocity scale factor (a convenience unit that is derived from dscale and tscale) real ( DP ) :: Escale !! Energy scale factor (a convenience unit that is derived from dscale, tscale, and mscale) real ( DP ) :: Lscale !! Angular momentum scale factor (a convenience unit that is derived from dscale, tscale, and mscale) contains procedure :: generate_fragments => fraggle_generate_fragments !! Generates a system of fragments in barycentric coordinates that conserves energy and momentum. procedure :: accel => fraggle_placeholder_accel !! Placeholder subroutine to fulfill requirement for an accel method procedure :: kick => fraggle_placeholder_kick !! Placeholder subroutine to fulfill requirement for a kick method procedure :: step => fraggle_placeholder_step !! Placeholder subroutine to fulfill requirement for a step method procedure :: set_budgets => fraggle_set_budgets_fragments !! Sets the energy and momentum budgets of the fragments based on the collider value procedure :: set_coordinate_system => fraggle_set_coordinate_system !! Defines the collisional coordinate system, including the unit vectors of both the system and individual fragments. procedure :: set_mass_dist => fraggle_set_mass_dist_fragments !! Sets the distribution of mass among the fragments depending on the regime type procedure :: set_natural_scale => fraggle_set_natural_scale_factors !! Scales dimenional quantities to ~O(1) with respect to the collisional system. procedure :: set_original_scale => fraggle_set_original_scale_factors !! Restores dimenional quantities back to the original system units procedure :: setup => fraggle_setup_fragments !! Allocates arrays for n fragments in a Fraggle system. Passing n = 0 deallocates all arrays. procedure :: reset => fraggle_setup_reset_fragments !! Resets all position and velocity-dependent fragment quantities in order to do a fresh calculation (does not reset mass, radius, or other values that get set prior to the call to fraggle_generate) procedure :: get_ang_mtm => fraggle_util_ang_mtm !! Calcualtes the current angular momentum of the fragments procedure :: get_energy_and_momentum => fraggle_util_get_energy_momentum !! Calculates total system energy in either the pre-collision outcome state (lbefore = .true.) or the post-collision outcome state (lbefore = .false.) procedure :: restructure => fraggle_util_restructure !! Restructure the inputs after a failed attempt failed to find a set of positions and velocities that satisfy the energy and momentum constraints end type fraggle_fragments interface module subroutine fraggle_generate_fragments ( self , colliders , system , param , lfailure ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle colliders object containing the two-body equivalent values of the colliding bodies class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters logical , intent ( out ) :: lfailure !! Answers the question: Should this have been a merger instead? end subroutine fraggle_generate_fragments module subroutine fraggle_io_log_generate ( frag ) implicit none class ( fraggle_fragments ), intent ( in ) :: frag end subroutine fraggle_io_log_generate module subroutine fraggle_io_log_one_message ( message ) implicit none character ( len =* ), intent ( in ) :: message character ( STRMAX ) :: errmsg end subroutine fraggle_io_log_one_message module subroutine fraggle_io_log_pl ( pl , param ) implicit none class ( swiftest_pl ), intent ( in ) :: pl !! Swiftest massive body object (only the new bodies generated in a collision) class ( swiftest_parameters ), intent ( in ) :: param !! Current swiftest run configuration parameters end subroutine fraggle_io_log_pl module subroutine fraggle_io_log_regime ( colliders , frag ) implicit none class ( fraggle_colliders ), intent ( in ) :: colliders class ( fraggle_fragments ), intent ( in ) :: frag end subroutine fraggle_io_log_regime module subroutine fraggle_io_log_start ( param ) implicit none class ( swiftest_parameters ), intent ( in ) :: param end subroutine fraggle_io_log_start !> The following interfaces are placeholders intended to satisfy the required abstract methods given by the parent class module subroutine fraggle_placeholder_accel ( self , system , param , t , lbeg ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time logical , intent ( in ) :: lbeg !! Optional argument that determines whether or not this is the beginning or end of the step end subroutine fraggle_placeholder_accel module subroutine fraggle_placeholder_kick ( self , system , param , t , dt , lbeg ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system objec class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Logical flag indicating whether this is the beginning of the half step or not. end subroutine fraggle_placeholder_kick module subroutine fraggle_placeholder_step ( self , system , param , t , dt ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( fraggle_fragments ), intent ( inout ) :: self !! Helio massive body particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nboody system class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Stepsiz end subroutine fraggle_placeholder_step module subroutine fraggle_regime_colliders ( self , frag , system , param ) implicit none class ( fraggle_colliders ), intent ( inout ) :: self !! Fraggle colliders object class ( fraggle_fragments ), intent ( inout ) :: frag !! Fraggle fragment system object class ( swiftest_nbody_system ), intent ( in ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current Swiftest run configuration parameters end subroutine fraggle_regime_colliders module subroutine fraggle_set_budgets_fragments ( self , colliders ) implicit none class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle collider system object end subroutine fraggle_set_budgets_fragments module subroutine fraggle_set_coordinate_system ( self , colliders ) implicit none class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle collider system object end subroutine fraggle_set_coordinate_system module subroutine fraggle_set_mass_dist_fragments ( self , colliders , param ) implicit none class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle collider system object class ( swiftest_parameters ), intent ( in ) :: param !! Current Swiftest run configuration parameters end subroutine fraggle_set_mass_dist_fragments module subroutine fraggle_set_natural_scale_factors ( self , colliders ) implicit none class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle collider system object end subroutine fraggle_set_natural_scale_factors module subroutine fraggle_set_original_scale_factors ( self , colliders ) implicit none class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle collider system object end subroutine fraggle_set_original_scale_factors module subroutine fraggle_setup_fragments ( self , n , param ) implicit none class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object integer ( I4B ), intent ( in ) :: n !! Number of fragments class ( swiftest_parameters ), intent ( in ) :: param !! Current swiftest run configuration parameters end subroutine fraggle_setup_fragments module subroutine fraggle_setup_reset_fragments ( self ) implicit none class ( fraggle_fragments ), intent ( inout ) :: self end subroutine fraggle_setup_reset_fragments module subroutine fraggle_util_add_fragments_to_system ( frag , colliders , system , param ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( fraggle_fragments ), intent ( in ) :: frag !! Fraggle fragment system object class ( fraggle_colliders ), intent ( in ) :: colliders !! Fraggle collider system object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current swiftest run configuration parameters end subroutine fraggle_util_add_fragments_to_system module subroutine fraggle_util_ang_mtm ( self ) implicit none class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object end subroutine fraggle_util_ang_mtm module subroutine fraggle_util_construct_temporary_system ( frag , system , param , tmpsys , tmpparam ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( fraggle_fragments ), intent ( in ) :: frag !! Fraggle fragment system object class ( swiftest_nbody_system ), intent ( in ) :: system !! Original swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current swiftest run configuration parameters class ( swiftest_nbody_system ), allocatable , intent ( out ) :: tmpsys !! Output temporary swiftest nbody system object class ( swiftest_parameters ), allocatable , intent ( out ) :: tmpparam !! Output temporary configuration run parameters end subroutine fraggle_util_construct_temporary_system module subroutine fraggle_util_get_energy_momentum ( self , colliders , system , param , lbefore ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle collider system object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current swiftest run configuration parameters logical , intent ( in ) :: lbefore !! Flag indicating that this the \"before\" state of the system, with colliders included and fragments excluded or vice versa end subroutine fraggle_util_get_energy_momentum module subroutine fraggle_util_restructure ( self , colliders , try , f_spin , r_max_start ) implicit none class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object class ( fraggle_colliders ), intent ( in ) :: colliders !! Fraggle collider system object integer ( I4B ), intent ( in ) :: try !! The current number of times Fraggle has tried to find a solution real ( DP ), intent ( inout ) :: f_spin !! Fraction of energy/momentum that goes into spin. This decreases ater a failed attempt real ( DP ), intent ( inout ) :: r_max_start !! The maximum radial distance that the position calculation starts with. This increases after a failed attempt end subroutine fraggle_util_restructure module subroutine fraggle_util_shift_vector_to_origin ( m_frag , vec_frag ) implicit none real ( DP ), dimension (:), intent ( in ) :: m_frag !! Fragment masses real ( DP ), dimension (:,:), intent ( inout ) :: vec_frag !! Fragment positions or velocities in the center of mass frame end subroutine module function fraggle_util_vmag_to_vb ( v_r_mag , v_r_unit , v_t_mag , v_t_unit , m_frag , vcom ) result ( vb ) implicit none real ( DP ), dimension (:), intent ( in ) :: v_r_mag !! Unknown radial component of fragment velocity vector real ( DP ), dimension (:), intent ( in ) :: v_t_mag !! Tangential component of velocity vector set previously by angular momentum constraint real ( DP ), dimension (:,:), intent ( in ) :: v_r_unit , v_t_unit !! Radial and tangential unit vectors for each fragment real ( DP ), dimension (:), intent ( in ) :: m_frag !! Fragment masses real ( DP ), dimension (:), intent ( in ) :: vcom !! Barycentric velocity of collisional system center of mass real ( DP ), dimension (:,:), allocatable :: vb end function fraggle_util_vmag_to_vb end interface end module fraggle_classes","tags":"","loc":"sourcefile/fraggle_classes.f90.html"},{"title":"symba_classes.f90 – swiftest","text":"This file depends on sourcefile~~symba_classes.f90~~EfferentGraph sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~symba_classes.f90~~AfferentGraph sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_collision.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~symba_classes.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~symba_classes.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_util.f90->sourcefile~symba_classes.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_encounter_check.f90->sourcefile~symba_classes.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_discard.f90->sourcefile~symba_classes.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_drift.f90->sourcefile~symba_classes.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_io.f90->sourcefile~symba_classes.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_setup.f90->sourcefile~symba_classes.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~kick.f90 kick.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~util_index.f90 util_index.f90 sourcefile~util_index.f90->sourcefile~swiftest.f90 sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~util_spill.f90 util_spill.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~fraggle_regime.f90 fraggle_regime.f90 sourcefile~fraggle_regime.f90->sourcefile~swiftest.f90 sourcefile~util_copy.f90 util_copy.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~fraggle_io.f90 fraggle_io.f90 sourcefile~fraggle_io.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90~2 orbel.f90 sourcefile~orbel.f90~2->sourcefile~swiftest.f90 sourcefile~fraggle_generate.f90 fraggle_generate.f90 sourcefile~fraggle_generate.f90->sourcefile~swiftest.f90 sourcefile~netcdf.f90 netcdf.f90 sourcefile~netcdf.f90->sourcefile~swiftest.f90 sourcefile~util_coord.f90 util_coord.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~gr.f90 gr.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~util_set.f90 util_set.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~fraggle_set.f90 fraggle_set.f90 sourcefile~fraggle_set.f90->sourcefile~swiftest.f90 sourcefile~util_append.f90 util_append.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 sourcefile~util_resize.f90 util_resize.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~drift.f90 drift.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~fraggle_placeholder.f90 fraggle_placeholder.f90 sourcefile~fraggle_placeholder.f90->sourcefile~swiftest.f90 sourcefile~rmvs_io.f90 rmvs_io.f90 sourcefile~rmvs_io.f90->sourcefile~swiftest.f90 sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90 orbel.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~fraggle_setup.f90 fraggle_setup.f90 sourcefile~fraggle_setup.f90->sourcefile~swiftest.f90 sourcefile~obl.f90 obl.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~setup.f90 setup.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~util_fill.f90 util_fill.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~fraggle_util.f90 fraggle_util.f90 sourcefile~fraggle_util.f90->sourcefile~swiftest.f90 sourcefile~helio_setup.f90 helio_setup.f90 sourcefile~helio_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~util_solve.f90 util_solve.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~util_sort.f90 util_sort.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules symba_classes Source Code symba_classes.f90 Source Code module symba_classes !! author: The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Definition of classes and methods specific to the SyMBA integrator !! Adapted from David E. Kaufmann's Swifter routine: module_symba.f90 use swiftest_globals use swiftest_classes , only : swiftest_parameters , swiftest_base , swiftest_encounter , swiftest_particle_info , netcdf_parameters use helio_classes , only : helio_cb , helio_pl , helio_tp , helio_nbody_system use fraggle_classes , only : fraggle_colliders , fraggle_fragments implicit none public integer ( I4B ), private , parameter :: NENMAX = 32767 integer ( I4B ), private , parameter :: NTENC = 3 real ( DP ), private , parameter :: RHSCALE = 6.5_DP real ( DP ), private , parameter :: RSHELL = 0.48075_DP type , extends ( swiftest_parameters ) :: symba_parameters real ( DP ) :: GMTINY = - 1.0_DP !! Smallest G*mass that is fully gravitating real ( DP ) :: min_GMfrag = - 1.0_DP !! Smallest G*mass that can be produced in a fragmentation event integer ( I4B ), dimension (:), allocatable :: seed !! Random seeds logical :: lfragmentation = . false . !! Do fragmentation modeling instead of simple merger. contains procedure :: reader => symba_io_param_reader procedure :: writer => symba_io_param_writer end type symba_parameters !******************************************************************************************************************************** !                                    symba_kinship class definitions and method interfaces !******************************************************************************************************************************* !> Class definition for the kinship relationships used in bookkeeping multiple collisions bodies in a single time step. type symba_kinship integer ( I4B ) :: parent !! Index of parent particle integer ( I4B ) :: nchild !! number of children in merger list integer ( I4B ), dimension (:), allocatable :: child !! Index of children particles end type symba_kinship !******************************************************************************************************************************** ! symba_cb class definitions and method interfaces !******************************************************************************************************************************* !> SyMBA central body particle class type , extends ( helio_cb ) :: symba_cb real ( DP ) :: GM0 = 0.0_DP !! Initial G*mass of the central body real ( DP ) :: dGM = 0.0_DP !! Change in G*mass of the central body real ( DP ) :: R0 = 0.0_DP !! Initial radius of the central body real ( DP ) :: dR = 0.0_DP !! Change in the radius of the central body contains end type symba_cb !******************************************************************************************************************************** !                                    symba_pl class definitions and method interfaces !******************************************************************************************************************************* !> SyMBA massive body class type , extends ( helio_pl ) :: symba_pl logical , dimension (:), allocatable :: lcollision !! flag indicating whether body has merged with another this time step logical , dimension (:), allocatable :: lencounter !! flag indicating whether body is part of an encounter this time step logical , dimension (:), allocatable :: lmtiny !! flag indicating whether this body is below the GMTINY cutoff value integer ( I4B ) :: nplm !! number of bodies above the GMTINY limit integer ( I8B ) :: nplplm !! Number of body (all massive)-body (only those above GMTINY) comparisons in the flattened upper triangular matrix integer ( I4B ), dimension (:), allocatable :: nplenc !! number of encounters with other planets this time step integer ( I4B ), dimension (:), allocatable :: ntpenc !! number of encounters with test particles this time step integer ( I4B ), dimension (:), allocatable :: levelg !! level at which this body should be moved integer ( I4B ), dimension (:), allocatable :: levelm !! deepest encounter level achieved this time step integer ( I4B ), dimension (:), allocatable :: isperi !! perihelion passage flag real ( DP ), dimension (:), allocatable :: peri !! perihelion distance real ( DP ), dimension (:), allocatable :: atp !! semimajor axis following perihelion passage type ( symba_kinship ), dimension (:), allocatable :: kin !! Array of merger relationship structures that can account for multiple pairwise mergers in a single step contains procedure :: make_colliders => symba_collision_make_colliders_pl !! When a single body is involved in more than one collision in a single step, it becomes part of a family procedure :: index => symba_util_index_eucl_plpl !! Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix procedure :: discard => symba_discard_pl !! Process massive body discards procedure :: drift => symba_drift_pl !! Method for Danby drift in Democratic Heliocentric coordinates. Sets the mask to the current recursion level procedure :: encounter_check => symba_encounter_check_pl !! Checks if massive bodies are going through close encounters with each other procedure :: accel_int => symba_kick_getacch_int_pl !! Compute direct cross (third) term heliocentric accelerations of massive bodiess, with no mutual interactions between bodies below GMTINY procedure :: accel => symba_kick_getacch_pl !! Compute heliocentric accelerations of massive bodies procedure :: setup => symba_setup_pl !! Constructor method - Allocates space for the input number of bodies procedure :: append => symba_util_append_pl !! Appends elements from one structure to another procedure :: fill => symba_util_fill_pl !! \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure :: get_peri => symba_util_peri_pl !! Determine system pericenter passages for massive bodies procedure :: rearray => symba_util_rearray_pl !! Clean up the massive body structures to remove discarded bodies and add new bodies procedure :: reset_kinship => symba_util_reset_kinship !! Resets the kinship status of bodies procedure :: resize => symba_util_resize_pl !! Checks the current size of a SyMBA massive body against the requested size and resizes it if it is too small. procedure :: sort => symba_util_sort_pl !! Sorts body arrays by a sortable componen procedure :: rearrange => symba_util_sort_rearrange_pl !! Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure :: spill => symba_util_spill_pl !! \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) end type symba_pl type , extends ( symba_pl ) :: symba_merger integer ( I4B ), dimension (:), allocatable :: ncomp contains procedure :: append => symba_util_append_merger !! Appends elements from one structure to another procedure :: resize => symba_util_resize_merger !! Checks the current size of a SyMBA merger list against the requested size and resizes it if it is too small. procedure :: setup => symba_setup_merger !! Constructor method - Allocates space for the input number of bodies end type symba_merger !******************************************************************************************************************************** !                                    symba_tp class definitions and method interfaces !******************************************************************************************************************************* !> SyMBA test particle class type , extends ( helio_tp ) :: symba_tp integer ( I4B ), dimension (:), allocatable :: nplenc !! number of encounters with planets this time step integer ( I4B ), dimension (:), allocatable :: levelg !! level at which this particle should be moved integer ( I4B ), dimension (:), allocatable :: levelm !! deepest encounter level achieved this time step contains procedure :: drift => symba_drift_tp !! Method for Danby drift in Democratic Heliocentric coordinates. Sets the mask to the current recursion level procedure :: encounter_check => symba_encounter_check_tp !! Checks if any test particles are undergoing a close encounter with a massive body procedure :: accel => symba_kick_getacch_tp !! Compute heliocentric accelerations of test particles procedure :: setup => symba_setup_tp !! Constructor method - Allocates space for the input number of bodies procedure :: append => symba_util_append_tp !! Appends elements from one structure to another procedure :: fill => symba_util_fill_tp !! \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure :: resize => symba_util_resize_tp !! Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure :: sort => symba_util_sort_tp !! Sorts body arrays by a sortable componen procedure :: rearrange => symba_util_sort_rearrange_tp !! Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure :: spill => symba_util_spill_tp !! \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) end type symba_tp !******************************************************************************************************************************** !                                    symba_encounter class definitions and method interfaces !******************************************************************************************************************************* !> SyMBA class for tracking close encounters in a step type , extends ( swiftest_encounter ) :: symba_encounter integer ( I4B ), dimension (:), allocatable :: level !! encounter recursion level contains procedure :: collision_check => symba_collision_check_encounter !! Checks if a test particle is going to collide with a massive body procedure :: encounter_check => symba_encounter_check !! Checks if massive bodies are going through close encounters with each other procedure :: kick => symba_kick_encounter !! Kick barycentric velocities of active test particles within SyMBA recursion procedure :: setup => symba_setup_encounter !! A constructor that sets the number of encounters and allocates and initializes all arrays procedure :: copy => symba_util_copy_encounter !! Copies elements from the source encounter list into self. procedure :: spill => symba_util_spill_encounter !! \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure :: append => symba_util_append_encounter !! Appends elements from one structure to another end type symba_encounter !******************************************************************************************************************************** !                                    symba_pltpenc class definitions and method interfaces !******************************************************************************************************************************* !> SyMBA class for tracking pl-tp close encounters in a step type , extends ( symba_encounter ) :: symba_pltpenc contains procedure :: resolve_collision => symba_collision_resolve_pltpenc !! Process the pl-tp collision list, then modifiy the massive bodies based on the outcome of the c end type symba_pltpenc !******************************************************************************************************************************** !                                    symba_plplenc class definitions and method interfaces !******************************************************************************************************************************* !> SyMBA class for tracking pl-pl close encounters in a step type , extends ( symba_encounter ) :: symba_plplenc contains procedure :: extract_collisions => symba_collision_encounter_extract_collisions !! Processes the pl-pl encounter list remove only those encounters that led to a collision procedure :: resolve_fragmentations => symba_collision_resolve_fragmentations !! Process list of collisions, determine the collisional regime, and then create fragments procedure :: resolve_mergers => symba_collision_resolve_mergers !! Process list of collisions and merge colliding bodies together procedure :: resolve_collision => symba_collision_resolve_plplenc !! Process the pl-pl collision list, then modifiy the massive bodies based on the outcome of the c end type symba_plplenc !******************************************************************************************************************************** !  symba_nbody_system class definitions and method interfaces !******************************************************************************************************************************** type , extends ( helio_nbody_system ) :: symba_nbody_system class ( symba_merger ), allocatable :: pl_adds !! List of added bodies in mergers or collisions class ( symba_pltpenc ), allocatable :: pltpenc_list !! List of massive body-test particle encounters in a single step class ( symba_plplenc ), allocatable :: plplenc_list !! List of massive body-massive body encounters in a single step class ( symba_plplenc ), allocatable :: plplcollision_list !! List of massive body-massive body collisions in a single step integer ( I4B ) :: irec !! System recursion level contains procedure :: write_discard => symba_io_write_discard !! Write out information about discarded and merged planets and test particles in SyMBA procedure :: initialize => symba_setup_initialize_system !! Performs SyMBA-specific initilization steps procedure :: step => symba_step_system !! Advance the SyMBA nbody system forward in time by one step procedure :: interp => symba_step_interp_system !! Perform an interpolation step on the SymBA nbody system procedure :: set_recur_levels => symba_step_set_recur_levels_system !! Sets recursion levels of bodies and encounter lists to the current system level procedure :: recursive_step => symba_step_recur_system !! Step interacting planets and active test particles ahead in democratic heliocentric coordinates at the current recursion level, if applicable, and descend to the next deeper level if necessary procedure :: reset => symba_step_reset_system !! Resets pl, tp,and encounter structures at the start of a new step end type symba_nbody_system interface module function symba_collision_check_encounter ( self , system , param , t , dt , irec ) result ( lany_collision ) use swiftest_classes , only : swiftest_parameters implicit none class ( symba_encounter ), intent ( inout ) :: self !! SyMBA pl-tp encounter list object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! current time real ( DP ), intent ( in ) :: dt !! step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level logical :: lany_collision !! Returns true if cany pair of encounters resulted in a collision n end function symba_collision_check_encounter module subroutine symba_collision_encounter_extract_collisions ( self , system , param ) implicit none class ( symba_plplenc ), intent ( inout ) :: self !! SyMBA pl-pl encounter list class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine module subroutine symba_collision_make_colliders_pl ( self , idx ) implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), dimension ( 2 ), intent ( in ) :: idx !! Array holding the indices of the two bodies involved in the collision end subroutine symba_collision_make_colliders_pl module subroutine symba_collision_resolve_fragmentations ( self , system , param ) implicit none class ( symba_plplenc ), intent ( inout ) :: self !! SyMBA pl-pl encounter list class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( inout ) :: param !! Current run configuration parameters with SyMBA additions end subroutine symba_collision_resolve_fragmentations module subroutine symba_collision_resolve_mergers ( self , system , param ) implicit none class ( symba_plplenc ), intent ( inout ) :: self !! SyMBA pl-pl encounter list class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( inout ) :: param !! Current run configuration parameters with SyMBA additions end subroutine symba_collision_resolve_mergers module subroutine symba_collision_resolve_plplenc ( self , system , param , t , dt , irec ) implicit none class ( symba_plplenc ), intent ( inout ) :: self !! SyMBA pl-pl encounter list class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters with SyMBA additions real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Current simulation step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level end subroutine symba_collision_resolve_plplenc module subroutine symba_collision_resolve_pltpenc ( self , system , param , t , dt , irec ) implicit none class ( symba_pltpenc ), intent ( inout ) :: self !! SyMBA pl-tp encounter list class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters with SyMBA additions real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Current simulation step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level end subroutine symba_collision_resolve_pltpenc module subroutine symba_discard_pl ( self , system , param ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine symba_discard_pl module subroutine symba_drift_pl ( self , system , param , dt ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( symba_pl ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize end subroutine symba_drift_pl module subroutine symba_drift_tp ( self , system , param , dt ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( symba_tp ), intent ( inout ) :: self !! Helio massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize end subroutine symba_drift_tp module pure subroutine symba_encounter_check_one ( xr , yr , zr , vxr , vyr , vzr , rhill1 , rhill2 , dt , irec , lencounter , lvdotr ) !$omp declare simd(symba_encounter_check_one) implicit none real ( DP ), intent ( in ) :: xr , yr , zr , vxr , vyr , vzr real ( DP ), intent ( in ) :: rhill1 , rhill2 , dt integer ( I4B ), intent ( in ) :: irec logical , intent ( out ) :: lencounter , lvdotr end subroutine symba_encounter_check_one module function symba_encounter_check_pl ( self , system , dt , irec ) result ( lany_encounter ) implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA test particle object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object real ( DP ), intent ( in ) :: dt !! step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level logical :: lany_encounter !! Returns true if there is at least one close encounter end function symba_encounter_check_pl module function symba_encounter_check ( self , system , dt , irec ) result ( lany_encounter ) implicit none class ( symba_encounter ), intent ( inout ) :: self !! SyMBA pl-pl encounter list object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object real ( DP ), intent ( in ) :: dt !! step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level logical :: lany_encounter !! Returns true if there is at least one close encounter end function symba_encounter_check module function symba_encounter_check_tp ( self , system , dt , irec ) result ( lany_encounter ) implicit none class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object real ( DP ), intent ( in ) :: dt !! step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level logical :: lany_encounter !! Returns true if there is at least one close encounter end function symba_encounter_check_tp module function symba_collision_casedisruption ( system , param , colliders , frag ) result ( status ) use fraggle_classes , only : fraggle_colliders , fraggle_fragments implicit none class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( inout ) :: param !! Current run configuration parameters with SyMBA additions class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle colliders object class ( fraggle_fragments ), intent ( inout ) :: frag !! Fraggle fragmentation system object integer ( I4B ) :: status !! Status flag assigned to this outcome end function symba_collision_casedisruption module function symba_collision_casehitandrun ( system , param , colliders , frag ) result ( status ) use fraggle_classes , only : fraggle_colliders , fraggle_fragments implicit none class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( inout ) :: param !! Current run configuration parameters with SyMBA additions class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle colliders object class ( fraggle_fragments ), intent ( inout ) :: frag !! Fraggle fragmentation system object integer ( I4B ) :: status !! Status flag assigned to this outcome end function symba_collision_casehitandrun module function symba_collision_casemerge ( system , param , colliders , frag ) result ( status ) use fraggle_classes , only : fraggle_colliders , fraggle_fragments implicit none class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( inout ) :: param !! Current run configuration parameters with SyMBA additions class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle colliders object class ( fraggle_fragments ), intent ( inout ) :: frag !! Fraggle fragmentation system object integer ( I4B ) :: status !! Status flag assigned to this outcome end function symba_collision_casemerge module subroutine symba_util_index_eucl_plpl ( self , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine symba_util_index_eucl_plpl module subroutine symba_io_param_reader ( self , unit , iotype , v_list , iostat , iomsg ) implicit none class ( symba_parameters ), intent ( inout ) :: self !! Current run configuration parameters with SyMBA additionss integer , intent ( in ) :: unit !! File unit number character ( len =* ), intent ( in ) :: iotype !! Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. !!    If you do not include a char-literal-constant, the iotype argument contains only DT. integer , intent ( in ) :: v_list (:) !! The first element passes the integrator code to the reader integer , intent ( out ) :: iostat !! IO status code character ( len =* ), intent ( inout ) :: iomsg !! Message to pass if iostat /= 0 end subroutine symba_io_param_reader module subroutine symba_io_param_writer ( self , unit , iotype , v_list , iostat , iomsg ) implicit none class ( symba_parameters ), intent ( in ) :: self !! Current run configuration parameters with SyMBA additions integer , intent ( in ) :: unit !! File unit number character ( len =* ), intent ( in ) :: iotype !! Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. !!    If you do not include a char-literal-constant, the iotype argument contains only DT. integer , intent ( in ) :: v_list (:) !! Not used in this procedure integer , intent ( out ) :: iostat !! IO status code character ( len =* ), intent ( inout ) :: iomsg !! Message to pass if iostat /= 0 end subroutine symba_io_param_writer module subroutine symba_io_write_discard ( self , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine symba_io_write_discard module subroutine symba_kick_getacch_int_pl ( self ) implicit none class ( symba_pl ), intent ( inout ) :: self end subroutine symba_kick_getacch_int_pl module subroutine symba_kick_getacch_pl ( self , system , param , t , lbeg ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step end subroutine symba_kick_getacch_pl module subroutine symba_kick_getacch_tp ( self , system , param , t , lbeg ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step end subroutine symba_kick_getacch_tp module subroutine symba_kick_encounter ( self , system , dt , irec , sgn ) implicit none class ( symba_encounter ), intent ( in ) :: self !! SyMBA pl-tp encounter list object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object real ( DP ), intent ( in ) :: dt !! step size integer ( I4B ), intent ( in ) :: irec !! Current recursion level integer ( I4B ), intent ( in ) :: sgn !! sign to be applied to acceleration end subroutine symba_kick_encounter module subroutine symba_setup_initialize_system ( self , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine symba_setup_initialize_system module subroutine symba_setup_merger ( self , n , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( symba_merger ), intent ( inout ) :: self !! SyMBA merger list object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine symba_setup_merger module subroutine symba_setup_pl ( self , n , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine symba_setup_pl module subroutine symba_setup_encounter ( self , n ) implicit none class ( symba_encounter ), intent ( inout ) :: self !! SyMBA pl-tp encounter structure integer ( I4B ), intent ( in ) :: n !! Number of encounters to allocate space for end subroutine symba_setup_encounter module subroutine symba_setup_tp ( self , n , param ) use swiftest_classes , only : swiftest_parameters implicit none class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameter end subroutine symba_setup_tp module subroutine symba_step_system ( self , param , t , dt ) use swiftest_classes , only : swiftest_parameters implicit none class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize end subroutine symba_step_system module subroutine symba_step_interp_system ( self , param , t , dt ) use swiftest_classes , only : swiftest_parameters implicit none class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize end subroutine symba_step_interp_system module subroutine symba_step_set_recur_levels_system ( self , ireci ) implicit none class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system objec integer ( I4B ), intent ( in ) :: ireci !! Input recursion level end subroutine symba_step_set_recur_levels_system module recursive subroutine symba_step_recur_system ( self , param , t , ireci ) use swiftest_classes , only : swiftest_parameters implicit none class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t integer ( I4B ), intent ( in ) :: ireci !! input recursion level end subroutine symba_step_recur_system module subroutine symba_step_reset_system ( self , param ) implicit none class ( symba_nbody_system ), intent ( inout ) :: self !! SyMBA nbody system object class ( symba_parameters ), intent ( in ) :: param !! Current run configuration parameters with SyMBA additions end subroutine symba_step_reset_system end interface interface util_append module subroutine symba_util_append_arr_kin ( arr , source , nold , nsrc , lsource_mask ) implicit none type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array type ( symba_kinship ), dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine symba_util_append_arr_kin end interface interface module subroutine symba_util_append_encounter ( self , source , lsource_mask ) implicit none class ( symba_encounter ), intent ( inout ) :: self !! SyMBA encounter list object class ( swiftest_encounter ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine symba_util_append_encounter module subroutine symba_util_append_merger ( self , source , lsource_mask ) use swiftest_classes , only : swiftest_body implicit none class ( symba_merger ), intent ( inout ) :: self !! SyMBA massive body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine symba_util_append_merger module subroutine symba_util_append_pl ( self , source , lsource_mask ) use swiftest_classes , only : swiftest_body implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine symba_util_append_pl module subroutine symba_util_append_tp ( self , source , lsource_mask ) use swiftest_classes , only : swiftest_body implicit none class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine symba_util_append_tp module subroutine symba_util_copy_encounter ( self , source ) use swiftest_classes , only : swiftest_encounter implicit none class ( symba_encounter ), intent ( inout ) :: self !! Encounter list class ( swiftest_encounter ), intent ( in ) :: source !! Source object to copy into end subroutine symba_util_copy_encounter end interface interface util_fill module subroutine symba_util_fill_arr_kin ( keeps , inserts , lfill_list ) implicit none type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep type ( symba_kinship ), dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine symba_util_fill_arr_kin end interface interface module subroutine symba_util_fill_pl ( self , inserts , lfill_list ) use swiftest_classes , only : swiftest_body implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object class ( swiftest_body ), intent ( in ) :: inserts !! Inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine symba_util_fill_pl module subroutine symba_util_fill_tp ( self , inserts , lfill_list ) use swiftest_classes , only : swiftest_body implicit none class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object class ( swiftest_body ), intent ( in ) :: inserts !! Inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine symba_util_fill_tp module subroutine symba_util_peri_pl ( self , system , param ) use swiftest_classes , only : swiftest_nbody_system , swiftest_parameters implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine symba_util_peri_pl module subroutine symba_util_rearray_pl ( self , system , param ) implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object class ( symba_nbody_system ), intent ( inout ) :: system !! SyMBA nbody system object class ( symba_parameters ), intent ( inout ) :: param !! Current run configuration parameters with SyMBA additions end subroutine symba_util_rearray_pl module subroutine symba_util_reset_kinship ( self , idx ) implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), dimension (:), intent ( in ) :: idx !! Index array of bodies to reset integer ( I4B ) :: i , j end subroutine symba_util_reset_kinship end interface interface util_resize module subroutine symba_util_resize_arr_kin ( arr , nnew ) implicit none type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size end subroutine symba_util_resize_arr_kin end interface interface module subroutine symba_util_resize_merger ( self , nnew ) implicit none class ( symba_merger ), intent ( inout ) :: self !! SyMBA merger list object integer ( I4B ), intent ( in ) :: nnew !! New size neded end subroutine symba_util_resize_merger module subroutine symba_util_resize_pl ( self , nnew ) implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), intent ( in ) :: nnew !! New size neded end subroutine symba_util_resize_pl module subroutine symba_util_resize_tp ( self , nnew ) implicit none class ( symba_tp ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), intent ( in ) :: nnew !! New size neded end subroutine symba_util_resize_tp module subroutine symba_util_sort_pl ( self , sortby , ascending ) implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order end subroutine symba_util_sort_pl module subroutine symba_util_sort_tp ( self , sortby , ascending ) implicit none class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order end subroutine symba_util_sort_tp end interface interface util_sort_rearrange module subroutine symba_util_sort_rearrange_arr_kin ( arr , ind , n ) implicit none type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index to rearrange against integer ( I4B ), intent ( in ) :: n !! Number of elements in arr and ind to rearrange end subroutine symba_util_sort_rearrange_arr_kin end interface util_sort_rearrange interface module subroutine symba_util_sort_rearrange_pl ( self , ind ) implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) end subroutine symba_util_sort_rearrange_pl module subroutine symba_util_sort_rearrange_tp ( self , ind ) implicit none class ( symba_tp ), intent ( inout ) :: self !! SyMBA massive body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) end subroutine symba_util_sort_rearrange_tp end interface interface util_spill module subroutine symba_util_spill_arr_kin ( keeps , discards , lspill_list , ldestructive ) implicit none type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep type ( symba_kinship ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discardss logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine symba_util_spill_arr_kin end interface interface module subroutine symba_util_spill_pl ( self , discards , lspill_list , ldestructive ) use swiftest_classes , only : swiftest_body implicit none class ( symba_pl ), intent ( inout ) :: self !! SyMBA massive body object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine symba_util_spill_pl module subroutine symba_util_spill_encounter ( self , discards , lspill_list , ldestructive ) use swiftest_classes , only : swiftest_encounter implicit none class ( symba_encounter ), intent ( inout ) :: self !! SyMBA pl-tp encounter list class ( swiftest_encounter ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter body by removing the discard list end subroutine symba_util_spill_encounter module subroutine symba_util_spill_tp ( self , discards , lspill_list , ldestructive ) use swiftest_classes , only : swiftest_body implicit none class ( symba_tp ), intent ( inout ) :: self !! SyMBA test particle object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine symba_util_spill_tp end interface end module symba_classes","tags":"","loc":"sourcefile/symba_classes.f90.html"},{"title":"swiftest.f90 – swiftest","text":"This file depends on sourcefile~~swiftest.f90~~EfferentGraph sourcefile~swiftest.f90 swiftest.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~swiftest.f90~~AfferentGraph sourcefile~swiftest.f90 swiftest.f90 sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~kick.f90 kick.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~util_index.f90 util_index.f90 sourcefile~util_index.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~util_sort.f90 util_sort.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~util_spill.f90 util_spill.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~fraggle_regime.f90 fraggle_regime.f90 sourcefile~fraggle_regime.f90->sourcefile~swiftest.f90 sourcefile~util_copy.f90 util_copy.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~fraggle_io.f90 fraggle_io.f90 sourcefile~fraggle_io.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90~2 orbel.f90 sourcefile~orbel.f90~2->sourcefile~swiftest.f90 sourcefile~fraggle_generate.f90 fraggle_generate.f90 sourcefile~fraggle_generate.f90->sourcefile~swiftest.f90 sourcefile~netcdf.f90 netcdf.f90 sourcefile~netcdf.f90->sourcefile~swiftest.f90 sourcefile~util_coord.f90 util_coord.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~gr.f90 gr.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~util_set.f90 util_set.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~fraggle_set.f90 fraggle_set.f90 sourcefile~fraggle_set.f90->sourcefile~swiftest.f90 sourcefile~util_append.f90 util_append.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 sourcefile~util_resize.f90 util_resize.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~drift.f90 drift.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~fraggle_placeholder.f90 fraggle_placeholder.f90 sourcefile~fraggle_placeholder.f90->sourcefile~swiftest.f90 sourcefile~rmvs_io.f90 rmvs_io.f90 sourcefile~rmvs_io.f90->sourcefile~swiftest.f90 sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90 orbel.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~fraggle_setup.f90 fraggle_setup.f90 sourcefile~fraggle_setup.f90->sourcefile~swiftest.f90 sourcefile~obl.f90 obl.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~setup.f90 setup.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~util_fill.f90 util_fill.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~fraggle_util.f90 fraggle_util.f90 sourcefile~fraggle_util.f90->sourcefile~swiftest.f90 sourcefile~helio_setup.f90 helio_setup.f90 sourcefile~helio_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~util_solve.f90 util_solve.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules swiftest Source Code swiftest.f90 Source Code module swiftest !! author: David A. Minton !! graph: false !! !! This module serves to combine all of the Swiftest project modules under a single umbrella so that they can be accessed from individual submodule implementations with a simple \"use swiftest\" line. use swiftest_globals use swiftest_operators use swiftest_classes use whm_classes use rmvs_classes use helio_classes use symba_classes use fraggle_classes use lambda_function use walltime_classes !use advisor_annotate !$ use omp_lib implicit none public end module swiftest","tags":"","loc":"sourcefile/swiftest.f90.html"},{"title":"swiftest_classes.f90 – swiftest","text":"This file depends on sourcefile~~swiftest_classes.f90~~EfferentGraph sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~swiftest_classes.f90~~AfferentGraph sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~kick.f90 kick.f90 sourcefile~kick.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~swiftest_classes.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~util_index.f90 util_index.f90 sourcefile~util_index.f90->sourcefile~swiftest_classes.f90 sourcefile~util_index.f90->sourcefile~swiftest.f90 sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest_classes.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~util_rescale.f90->sourcefile~swiftest_classes.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest_classes.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~util_spill.f90 util_spill.f90 sourcefile~util_spill.f90->sourcefile~swiftest_classes.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~util_copy.f90 util_copy.f90 sourcefile~util_copy.f90->sourcefile~swiftest_classes.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90~2 orbel.f90 sourcefile~orbel.f90~2->sourcefile~swiftest_classes.f90 sourcefile~orbel.f90~2->sourcefile~swiftest.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~netcdf.f90 netcdf.f90 sourcefile~netcdf.f90->sourcefile~swiftest_classes.f90 sourcefile~netcdf.f90->sourcefile~swiftest.f90 sourcefile~util_coord.f90 util_coord.f90 sourcefile~util_coord.f90->sourcefile~swiftest_classes.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest_classes.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~gr.f90 gr.f90 sourcefile~gr.f90->sourcefile~swiftest_classes.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~util_set.f90 util_set.f90 sourcefile~util_set.f90->sourcefile~swiftest_classes.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~util_append.f90 util_append.f90 sourcefile~util_append.f90->sourcefile~swiftest_classes.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 sourcefile~util_resize.f90 util_resize.f90 sourcefile~util_resize.f90->sourcefile~swiftest_classes.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~swiftest_classes.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~drift.f90 drift.f90 sourcefile~drift.f90->sourcefile~swiftest_classes.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~swiftest_classes.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~swiftest_classes.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90 orbel.f90 sourcefile~orbel.f90->sourcefile~swiftest_classes.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~user_getacch.f90->sourcefile~swiftest_classes.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~obl.f90 obl.f90 sourcefile~obl.f90->sourcefile~swiftest_classes.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~setup.f90 setup.f90 sourcefile~setup.f90->sourcefile~swiftest_classes.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~swiftest_classes.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~util_fill.f90 util_fill.f90 sourcefile~util_fill.f90->sourcefile~swiftest_classes.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~swiftest_classes.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~util_solve.f90 util_solve.f90 sourcefile~util_solve.f90->sourcefile~swiftest_classes.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest_classes.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~util_sort.f90 util_sort.f90 sourcefile~util_sort.f90->sourcefile~swiftest_classes.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_collision.f90->sourcefile~symba_classes.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~symba_classes.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~symba_classes.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_discard.f90->sourcefile~symba_classes.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~whm_drift.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~rmvs_classes.f90 sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~fraggle_regime.f90 fraggle_regime.f90 sourcefile~fraggle_regime.f90->sourcefile~fraggle_classes.f90 sourcefile~fraggle_regime.f90->sourcefile~swiftest.f90 sourcefile~fraggle_io.f90 fraggle_io.f90 sourcefile~fraggle_io.f90->sourcefile~fraggle_classes.f90 sourcefile~fraggle_io.f90->sourcefile~swiftest.f90 sourcefile~fraggle_generate.f90 fraggle_generate.f90 sourcefile~fraggle_generate.f90->sourcefile~fraggle_classes.f90 sourcefile~fraggle_generate.f90->sourcefile~swiftest.f90 sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~whm_gr.f90->sourcefile~whm_classes.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~helio_classes.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90->sourcefile~rmvs_classes.f90 sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_io.f90->sourcefile~symba_classes.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90->sourcefile~rmvs_classes.f90 sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_step.f90->sourcefile~rmvs_classes.f90 sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_gr.f90->sourcefile~helio_classes.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_util.f90->sourcefile~symba_classes.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90->sourcefile~whm_classes.f90 sourcefile~fraggle_placeholder.f90 fraggle_placeholder.f90 sourcefile~fraggle_placeholder.f90->sourcefile~fraggle_classes.f90 sourcefile~fraggle_placeholder.f90->sourcefile~swiftest.f90 sourcefile~rmvs_io.f90 rmvs_io.f90 sourcefile~rmvs_io.f90->sourcefile~swiftest.f90 sourcefile~rmvs_io.f90->sourcefile~rmvs_classes.f90 sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~whm_kick.f90->sourcefile~whm_classes.f90 sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_kick.f90->sourcefile~helio_classes.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~whm_setup.f90->sourcefile~whm_classes.f90 sourcefile~fraggle_setup.f90 fraggle_setup.f90 sourcefile~fraggle_setup.f90->sourcefile~fraggle_classes.f90 sourcefile~fraggle_setup.f90->sourcefile~swiftest.f90 sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_encounter_check.f90->sourcefile~symba_classes.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_drift.f90->sourcefile~symba_classes.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~whm_util.f90->sourcefile~whm_classes.f90 sourcefile~fraggle_util.f90 fraggle_util.f90 sourcefile~fraggle_util.f90->sourcefile~fraggle_classes.f90 sourcefile~fraggle_util.f90->sourcefile~swiftest.f90 sourcefile~helio_setup.f90 helio_setup.f90 sourcefile~helio_setup.f90->sourcefile~helio_classes.f90 sourcefile~helio_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_setup.f90->sourcefile~rmvs_classes.f90 sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_step.f90->sourcefile~helio_classes.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_setup.f90->sourcefile~symba_classes.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_set.f90 fraggle_set.f90 sourcefile~fraggle_set.f90->sourcefile~fraggle_classes.f90 sourcefile~fraggle_set.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules swiftest_classes Source Code swiftest_classes.f90 Source Code module swiftest_classes !! author: The Purdue Swiftest Team -  David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott !! !! Definition of data and structures generic to all integrators. !! Adapted from David E. Kaufmann's Swifter routine: module_swifter.f90 use swiftest_globals implicit none public type :: netcdf_parameters integer ( I4B ) :: out_type !! NetCDF output type (will be assigned either NF90_DOUBLE or NF90_FLOAT, depending on the user parameter) integer ( I4B ) :: ncid !! NetCDF ID for the output file integer ( I4B ) :: dimids ( 3 ) !! Dimensions of the NetCDF file integer ( I4B ) :: time_dimid !! NetCDF ID for the time dimension integer ( I4B ) :: id_dimid !! NetCDF ID for the particle id dimension integer ( I4B ) :: str_dimid !! NetCDF ID for the character string dimension integer ( I4B ) :: time_varid !! NetCDF ID for the time variable integer ( I4B ) :: id_varid !! NetCDF ID for the particle name variable integer ( I4B ) :: name_varid !! NetCDF ID for the namevariable integer ( I4B ) :: ptype_varid !! NetCDF ID for the particle type variable integer ( I4B ) :: npl_varid !! NetCDF ID for the number of active massive bodies variable integer ( I4B ) :: ntp_varid !! NetCDF ID for the number of active test particles variable integer ( I4B ) :: a_varid !! NetCDF ID for the semimajor axis variable integer ( I4B ) :: e_varid !! NetCDF ID for the eccentricity variable integer ( I4B ) :: inc_varid !! NetCDF ID for the inclination variable integer ( I4B ) :: capom_varid !! NetCDF ID for the long. asc. node variable integer ( I4B ) :: omega_varid !! NetCDF ID for the arg. periapsis variable integer ( I4B ) :: capm_varid !! NetCDF ID for the mean anomaly variable integer ( I4B ) :: xhx_varid !! NetCDF ID for the heliocentric position x variable integer ( I4B ) :: xhy_varid !! NetCDF ID for the heliocentric position y variable integer ( I4B ) :: xhz_varid !! NetCDF ID for the heliocentric position z variable integer ( I4B ) :: vhx_varid !! NetCDF ID for the heliocentric velocity x variable integer ( I4B ) :: vhy_varid !! NetCDF ID for the heliocentric velocity y variable integer ( I4B ) :: vhz_varid !! NetCDF ID for the heliocentric velocity z variable integer ( I4B ) :: Gmass_varid !! NetCDF ID for the mass variable integer ( I4B ) :: rhill_varid !! NetCDF ID for the hill radius variable integer ( I4B ) :: radius_varid !! NetCDF ID for the radius variable integer ( I4B ) :: Ip1_varid !! NetCDF ID for the axis 1 principal moment of inertia variable integer ( I4B ) :: Ip2_varid !! NetCDF ID for the axis 2 principal moment of inertia variable integer ( I4B ) :: Ip3_varid !! NetCDF ID for the axis 3 principal moment of inertia variable integer ( I4B ) :: rotx_varid !! NetCDF ID for the rotation x variable integer ( I4B ) :: roty_varid !! NetCDF ID for the rotation y variable integer ( I4B ) :: rotz_varid !! NetCDF ID for the rotation z variable integer ( I4B ) :: k2_varid !! NetCDF ID for the Love number variable integer ( I4B ) :: Q_varid !! NetCDF ID for the energy dissipation variable integer ( I4B ) :: KE_orb_varid !! NetCDF ID for the system orbital kinetic energy variable integer ( I4B ) :: KE_spin_varid !! NetCDF ID for the system spin kinetic energy variable integer ( I4B ) :: PE_varid !! NetCDF ID for the system potential energy variable integer ( I4B ) :: L_orbx_varid !! NetCDF ID for the system orbital angular momentum x variable integer ( I4B ) :: L_orby_varid !! NetCDF ID for the system orbital angular momentum y variable integer ( I4B ) :: L_orbz_varid !! NetCDF ID for the system orbital angular momentum z variable integer ( I4B ) :: L_spinx_varid !! NetCDF ID for the system spin angular momentum x variable integer ( I4B ) :: L_spiny_varid !! NetCDF ID for the system spin angular momentum y variable integer ( I4B ) :: L_spinz_varid !! NetCDF ID for the system spin angular momentum z variable integer ( I4B ) :: L_escapex_varid !! NetCDF ID for the escaped angular momentum x variable integer ( I4B ) :: L_escapey_varid !! NetCDF ID for the escaped angular momentum x variable integer ( I4B ) :: L_escapez_varid !! NetCDF ID for the escaped angular momentum x variable integer ( I4B ) :: Ecollisions_varid !! NetCDF ID for the energy lost in collisions variable integer ( I4B ) :: Euntracked_varid !! NetCDF ID for the energy that is untracked due to loss (untracked potential energy due to mergers and body energy for escaped bodies) integer ( I4B ) :: GMescape_varid !! NetCDF ID for the G*Mass of bodies that escape the system integer ( I4B ) :: status_varid !! NetCDF ID for the status variable integer ( I4B ) :: origin_type_varid !! NetCDF ID for the origin type integer ( I4B ) :: origin_time_varid !! NetCDF ID for the origin time integer ( I4B ) :: origin_xhx_varid !! NetCDF ID for the origin xh x component integer ( I4B ) :: origin_xhy_varid !! NetCDF ID for the origin xh y component integer ( I4B ) :: origin_xhz_varid !! NetCDF ID for the origin xh z component integer ( I4B ) :: origin_vhx_varid !! NetCDF ID for the origin xh x component integer ( I4B ) :: origin_vhy_varid !! NetCDF ID for the origin xh y component integer ( I4B ) :: origin_vhz_varid !! NetCDF ID for the origin xh z component integer ( I4B ) :: discard_time_varid !! NetCDF ID for the time of discard variable integer ( I4B ) :: discard_xhx_varid !! NetCDF ID for the heliocentric position of the body at the time of discard x variable integer ( I4B ) :: discard_xhy_varid !! NetCDF ID for the heliocentric position of the body at the time of discard y variable integer ( I4B ) :: discard_xhz_varid !! NetCDF ID for the heliocentric position of the body at the time of discard z variable integer ( I4B ) :: discard_vhx_varid !! NetCDF ID for the heliocentric velocity of the body at the time of discard x variable integer ( I4B ) :: discard_vhy_varid !! NetCDF ID for the heliocentric velocity of the body at the time of discard y variable integer ( I4B ) :: discard_vhz_varid !! NetCDF ID for the heliocentric velocity of the body at the time of discard z variable integer ( I4B ) :: discard_body_id_varid !! NetCDF ID for the id of the other body involved in the discard contains procedure :: close => netcdf_close !! Closes an open NetCDF file procedure :: initialize => netcdf_initialize_output !! Initialize a set of parameters used to identify a NetCDF output object procedure :: open => netcdf_open !! Opens a NetCDF file end type netcdf_parameters !******************************************************************************************************************************** ! swiftest_parameters class definitions !******************************************************************************************************************************** !> User defined parameters that are read in from the parameters input file. !>    Each paramter is initialized to a default values. type :: swiftest_parameters integer ( I4B ) :: integrator = UNKNOWN_INTEGRATOR !! Symbolic name of the nbody integrator  used integer ( I4B ) :: maxid = - 1 !! The current maximum particle id number real ( DP ) :: t0 = - 1.0_DP !! Integration start time real ( DP ) :: t = - 1.0_DP !! Integration current time real ( DP ) :: tstop = - 1.0_DP !! Integration stop time real ( DP ) :: dt = - 1.0_DP !! Time step integer ( I8B ) :: ioutput = 0_I8B !! Output counter character ( STRMAX ) :: incbfile = CB_INFILE !! Name of input file for the central body character ( STRMAX ) :: inplfile = PL_INFILE !! Name of input file for massive bodies character ( STRMAX ) :: intpfile = TP_INFILE !! Name of input file for test particles character ( STRMAX ) :: in_type = ASCII_TYPE !! Data representation type of input data files character ( STRMAX ) :: in_form = XV !! Format of input data files (EL or XV) integer ( I4B ) :: istep_out = - 1 !! Number of time steps between binary outputs character ( STRMAX ) :: outfile = NETCDF_OUTFILE !! Name of output binary file character ( STRMAX ) :: out_type = NETCDF_DOUBLE_TYPE !! Binary format of output file character ( STRMAX ) :: out_form = XVEL !! Data to write to output file character ( STRMAX ) :: out_stat = 'NEW' !! Open status for output binary file character ( STRMAX ) :: particle_out = PARTICLE_OUTFILE !! Name of output particle information file integer ( I4B ) :: istep_dump = - 1 !! Number of time steps between dumps real ( DP ) :: rmin = - 1.0_DP !! Minimum heliocentric radius for test particle real ( DP ) :: rmax = - 1.0_DP !! Maximum heliocentric radius for test particle real ( DP ) :: rmaxu = - 1.0_DP !! Maximum unbound heliocentric radius for test particle real ( DP ) :: qmin = - 1.0_DP !! Minimum pericenter distance for test particle character ( STRMAX ) :: qmin_coord = 'HELIO' !! Coordinate frame to use for qmin real ( DP ) :: qmin_alo = - 1.0_DP !! Minimum semimajor axis for qmin real ( DP ) :: qmin_ahi = - 1.0_DP !! Maximum semimajor axis for qmin character ( STRMAX ) :: enc_out = \"\" !! Name of output file for encounters character ( STRMAX ) :: discard_out = \"\" !! Name of output file for discards real ( QP ) :: MU2KG = - 1.0_QP !! Converts mass units to grams real ( QP ) :: TU2S = - 1.0_QP !! Converts time units to seconds real ( QP ) :: DU2M = - 1.0_QP !! Converts distance unit to centimeters real ( DP ) :: GU = - 1.0_DP !! Universal gravitational constant in the system units real ( DP ) :: inv_c2 = - 1.0_DP !! Inverse speed of light squared in the system units character ( STRMAX ) :: energy_out = \"\" !! Name of output energy and momentum report file ! Logical flags to turn on or off various features of the code logical :: lrhill_present = . false . !! Hill radii are given as an input rather than calculated by the code (can be used to inflate close encounter regions manually) logical :: lextra_force = . false . !! User defined force function turned on logical :: lbig_discard = . false . !! Save big bodies on every discard logical :: lclose = . false . !! Turn on close encounters logical :: lenergy = . false . !! Track the total energy of the system logical :: loblatecb = . false . !! Calculate acceleration from oblate central body (automatically turns true if nonzero J2 is input) logical :: lrotation = . false . !! Include rotation states of big bodies logical :: ltides = . false . !! Include tidal dissipation ! Initial values to pass to the energy report subroutine (usually only used in the case of a restart, otherwise these will be updated with initial conditions values) real ( DP ) :: Eorbit_orig = 0.0_DP !! Initial orbital energy real ( DP ) :: GMtot_orig = 0.0_DP !! Initial system mass real ( DP ), dimension ( NDIM ) :: Ltot_orig = 0.0_DP !! Initial total angular momentum vector real ( DP ), dimension ( NDIM ) :: Lorbit_orig = 0.0_DP !! Initial orbital angular momentum real ( DP ), dimension ( NDIM ) :: Lspin_orig = 0.0_DP !! Initial spin angular momentum vector real ( DP ), dimension ( NDIM ) :: Lescape = 0.0_DP !! Angular momentum of bodies that escaped the system (used for bookeeping) real ( DP ) :: GMescape = 0.0_DP !! Mass of bodies that escaped the system (used for bookeeping) real ( DP ) :: Ecollisions = 0.0_DP !! Energy lost from system due to collisions real ( DP ) :: Euntracked = 0.0_DP !! Energy gained from system due to escaped bodies logical :: lfirstenergy = . true . !! This is the first time computing energe logical :: lfirstkick = . true . !! Initiate the first kick in a symplectic step logical :: lrestart = . false . !! Indicates whether or not this is a restarted run ! Future features not implemented or in development logical :: lgr = . false . !! Turn on GR logical :: lyarkovsky = . false . !! Turn on Yarkovsky effect logical :: lyorp = . false . !! Turn on YORP effect type ( netcdf_parameters ) :: nciu !! Object containing NetCDF parameters contains procedure :: reader => io_param_reader procedure :: writer => io_param_writer procedure :: dump => io_dump_param procedure :: read_in => io_read_in_param end type swiftest_parameters !******************************************************************************************************************************** !                                    swiftest_swiftest_particle_info class definitions and method interfaces !******************************************************************************************************************************* !> Class definition for the particle origin information object. This object is used to track time, location, and collisional regime !> of fragments produced in collisional events. type :: swiftest_particle_info character ( len = NAMELEN ) :: name !! Non-unique name character ( len = NAMELEN ) :: particle_type !! String containing a description of the particle type (e.g. Central Body, Massive Body, Test Particle) character ( len = NAMELEN ) :: origin_type !! String containing a description of the origin of the particle (e.g. Initial Conditions, Supercatastrophic, Disruption, etc.) real ( DP ) :: origin_time !! The time of the particle's formation real ( DP ), dimension ( NDIM ) :: origin_xh !! The heliocentric distance vector at the time of the particle's formation real ( DP ), dimension ( NDIM ) :: origin_vh !! The heliocentric velocity vector at the time of the particle's formation real ( DP ) :: discard_time !! The time of the particle's discard character ( len = NAMELEN ) :: status !! Particle status description: Active, Merged, Fragmented, etc. real ( DP ), dimension ( NDIM ) :: discard_xh !! The heliocentric distance vector at the time of the particle's discard real ( DP ), dimension ( NDIM ) :: discard_vh !! The heliocentric velocity vector at the time of the particle's discard integer ( I4B ) :: discard_body_id !! The id of the other body involved in the discard (0 if no other body involved) contains procedure :: dump => io_dump_particle_info !! Dumps contents of particle information to file procedure :: read_in => io_read_in_particle_info !! Read in a particle information object from an open file procedure :: copy => util_copy_particle_info !! Copies one set of information object components into another, component-by-component procedure :: set_value => util_set_particle_info !! Sets one or more values of the particle information metadata object end type swiftest_particle_info !******************************************************************************************************************************** ! swiftest_base class definitions and methods !******************************************************************************************************************************** type , abstract :: swiftest_base !! An abstract superclass for a generic Swiftest object contains !! The minimal methods that all systems must have procedure :: dump => io_dump_base !! Dump contents to file procedure :: dump_particle_info => io_dump_particle_info_base !! Dump contents of particle information metadata to file procedure :: write_frame_netcdf => netcdf_write_frame_base !! I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format procedure :: write_particle_info_netcdf => netcdf_write_particle_info_base !! Writes out the particle information metadata to NetCDF file generic :: write_frame => write_frame_netcdf !! Set up generic procedure that will switch between NetCDF or Fortran binary depending on arguments generic :: write_particle_info => write_particle_info_netcdf end type swiftest_base !******************************************************************************************************************************** ! swiftest_cb class definitions and methods !******************************************************************************************************************************** !> A concrete lass for the central body in a Swiftest simulation type , abstract , extends ( swiftest_base ) :: swiftest_cb type ( swiftest_particle_info ) :: info !! Particle metadata information integer ( I4B ) :: id = 0 !! External identifier (unique) real ( DP ) :: mass = 0.0_DP !! Central body mass (units MU) real ( DP ) :: Gmass = 0.0_DP !! Central mass gravitational term G * mass (units GU * MU) real ( DP ) :: radius = 0.0_DP !! Central body radius (units DU) real ( DP ) :: density = 1.0_DP !! Central body mass density - calculated internally (units MU / DU**3) real ( DP ) :: j2rp2 = 0.0_DP !! J2*R&#94;2 term for central body real ( DP ) :: j4rp4 = 0.0_DP !! J4*R&#94;2 term for central body real ( DP ), dimension ( NDIM ) :: aobl = 0.0_DP !! Barycentric acceleration due to central body oblatenes real ( DP ), dimension ( NDIM ) :: atide = 0.0_DP !! Barycentric acceleration due to central body oblatenes real ( DP ), dimension ( NDIM ) :: aoblbeg = 0.0_DP !! Barycentric acceleration due to central body oblatenes at beginning of step real ( DP ), dimension ( NDIM ) :: aoblend = 0.0_DP !! Barycentric acceleration due to central body oblatenes at end of step real ( DP ), dimension ( NDIM ) :: atidebeg = 0.0_DP !! Barycentric acceleration due to central body oblatenes at beginning of step real ( DP ), dimension ( NDIM ) :: atideend = 0.0_DP !! Barycentric acceleration due to central body oblatenes at end of step real ( DP ), dimension ( NDIM ) :: xb = 0.0_DP !! Barycentric position (units DU) real ( DP ), dimension ( NDIM ) :: vb = 0.0_DP !! Barycentric velocity (units DU / TU) real ( DP ), dimension ( NDIM ) :: agr = 0.0_DP !! Acceleration due to post-Newtonian correction real ( DP ), dimension ( NDIM ) :: Ip = 0.0_DP !! Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real ( DP ), dimension ( NDIM ) :: rot = 0.0_DP !! Body rotation vector in inertial coordinate frame (units rad / TU) real ( DP ) :: k2 = 0.0_DP !! Tidal Love number real ( DP ) :: Q = 0.0_DP !! Tidal quality factor real ( DP ) :: tlag = 0.0_DP !! Tidal phase lag angle real ( DP ), dimension ( NDIM ) :: L0 = 0.0_DP !! Initial angular momentum of the central body real ( DP ), dimension ( NDIM ) :: dL = 0.0_DP !! Change in angular momentum of the central body contains procedure :: read_in => io_read_in_cb !! I/O routine for reading in central body data procedure :: read_frame => io_read_frame_cb !! I/O routine for reading out a single frame of time-series data for the central body procedure :: write_frame_bin => io_write_frame_cb !! I/O routine for writing out a single frame of time-series data for the central body generic :: write_frame => write_frame_bin !! Write a frame (either binary or NetCDF, using generic procedures) end type swiftest_cb !******************************************************************************************************************************** ! swiftest_body definitions and methods !******************************************************************************************************************************** !> An abstract class for a generic collection of Swiftest bodies type , abstract , extends ( swiftest_base ) :: swiftest_body !! Superclass that defines the generic elements of a Swiftest particle logical :: lfirst = . true . !! Run the current step as a first integer ( I4B ) :: nbody = 0 !! Number of bodies type ( swiftest_particle_info ), dimension (:), allocatable :: info !! Particle metadata information integer ( I4B ), dimension (:), allocatable :: id !! External identifier (unique) integer ( I4B ), dimension (:), allocatable :: status !! An integrator-specific status indicator logical , dimension (:), allocatable :: ldiscard !! Body should be discarded logical , dimension (:), allocatable :: lmask !! Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real ( DP ), dimension (:), allocatable :: mu !! G * (Mcb + [m]) real ( DP ), dimension (:,:), allocatable :: xh !! Swiftestcentric position real ( DP ), dimension (:,:), allocatable :: vh !! Swiftestcentric velocity real ( DP ), dimension (:,:), allocatable :: xb !! Barycentric position real ( DP ), dimension (:,:), allocatable :: vb !! Barycentric velocity real ( DP ), dimension (:,:), allocatable :: ah !! Total heliocentric acceleration real ( DP ), dimension (:,:), allocatable :: aobl !! Barycentric accelerations of bodies due to central body oblatenes real ( DP ), dimension (:,:), allocatable :: atide !! Tanngential component of acceleration of bodies due to tides real ( DP ), dimension (:,:), allocatable :: agr !! Acceleration due to post-Newtonian correction real ( DP ), dimension (:), allocatable :: ir3h !! Inverse heliocentric radius term (1/rh**3) real ( DP ), dimension (:), allocatable :: a !! Semimajor axis (pericentric distance for a parabolic orbit) real ( DP ), dimension (:), allocatable :: e !! Eccentricity real ( DP ), dimension (:), allocatable :: inc !! Inclination real ( DP ), dimension (:), allocatable :: capom !! Longitude of ascending node real ( DP ), dimension (:), allocatable :: omega !! Argument of pericenter real ( DP ), dimension (:), allocatable :: capm !! Mean anomaly !! Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the !!    component list, such as setup_body and util_spill contains procedure ( abstract_discard_body ), deferred :: discard procedure ( abstract_kick_body ), deferred :: kick procedure ( abstract_set_mu ), deferred :: set_mu procedure ( abstract_step_body ), deferred :: step procedure ( abstract_accel ), deferred :: accel ! These are concrete because the implementation is the same for all types of particles procedure :: drift => drift_body !! Loop through bodies and call Danby drift routine on heliocentric variables procedure :: v2pv => gr_vh2pv_body !! Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure :: pv2v => gr_pv2vh_body !! Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure :: read_in => io_read_in_body !! Read in body initial conditions from a file procedure :: read_frame => io_read_frame_body !! I/O routine for writing out a single frame of time-series data for the central body procedure :: write_frame_bin => io_write_frame_body !! I/O routine for writing out a single frame of time-series data for the central body procedure :: accel_obl => obl_acc_body !! Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure :: el2xv => orbel_el2xv_vec !! Convert orbital elements to position and velocity vectors procedure :: xv2el => orbel_xv2el_vec !! Convert position and velocity vectors to orbital  elements procedure :: setup => setup_body !! A constructor that sets the number of bodies and allocates all allocatable arrays procedure :: accel_user => user_kick_getacch_body !! Add user-supplied heliocentric accelerations to planets procedure :: append => util_append_body !! Appends elements from one structure to another procedure :: fill => util_fill_body !! \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure :: resize => util_resize_body !! Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure :: set_ir3 => util_set_ir3h !! Sets the inverse heliocentric radius term (1/rh**3) procedure :: sort => util_sort_body !! Sorts body arrays by a sortable componen procedure :: rearrange => util_sort_rearrange_body !! Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure :: spill => util_spill_body !! \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) generic :: write_frame => write_frame_bin !! Add the generic write frame for Fortran binary files end type swiftest_body !******************************************************************************************************************************** ! swiftest_pl definitions and methods !******************************************************************************************************************************** !> An abstract class for a generic collection of Swiftest massive bodies type , abstract , extends ( swiftest_body ) :: swiftest_pl !! Superclass that defines the generic elements of a Swiftest particle real ( DP ), dimension (:), allocatable :: mass !! Body mass (units MU) real ( DP ), dimension (:), allocatable :: Gmass !! Mass gravitational term G * mass (units GU * MU) real ( DP ), dimension (:), allocatable :: rhill !! Body mass (units MU) real ( DP ), dimension (:), allocatable :: radius !! Body radius (units DU) real ( DP ), dimension (:,:), allocatable :: xbeg !! Position at beginning of step real ( DP ), dimension (:,:), allocatable :: xend !! Position at end of step real ( DP ), dimension (:,:), allocatable :: vbeg !! Velocity at beginning of step real ( DP ), dimension (:), allocatable :: density !! Body mass density - calculated internally (units MU / DU**3) real ( DP ), dimension (:,:), allocatable :: Ip !! Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real ( DP ), dimension (:,:), allocatable :: rot !! Body rotation vector in inertial coordinate frame (units rad / TU) real ( DP ), dimension (:), allocatable :: k2 !! Tidal Love number real ( DP ), dimension (:), allocatable :: Q !! Tidal quality factor real ( DP ), dimension (:), allocatable :: tlag !! Tidal phase lag integer ( I4B ), dimension (:,:), allocatable :: k_plpl !! Index array used to convert flattened the body-body comparison upper triangular matrix integer ( I8B ) :: nplpl !! Number of body-body comparisons in the flattened upper triangular matrix !! Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the !!    component list, such as setup_pl and util_spill_pl contains ! Massive body-specific concrete methods ! These are concrete because they are the same implemenation for all integrators procedure :: discard => discard_pl !! Placeholder method for discarding massive bodies procedure :: index => util_index_eucl_plpl !! Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix procedure :: accel_int => kick_getacch_int_pl !! Compute direct cross (third) term heliocentric accelerations of massive bodies procedure :: accel_obl => obl_acc_pl !! Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure :: setup => setup_pl !! A base constructor that sets the number of bodies and allocates and initializes all arrays procedure :: accel_tides => tides_kick_getacch_pl !! Compute the accelerations of bodies due to tidal interactions with the central body procedure :: append => util_append_pl !! Appends elements from one structure to another procedure :: h2b => util_coord_h2b_pl !! Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) procedure :: b2h => util_coord_b2h_pl !! Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) procedure :: vh2vb => util_coord_vh2vb_pl !! Convert massive bodies from heliocentric to barycentric coordinates (velocity only) procedure :: vb2vh => util_coord_vb2vh_pl !! Convert massive bodies from barycentric to heliocentric coordinates (velocity only) procedure :: xh2xb => util_coord_xh2xb_pl !! Convert massive bodies from heliocentric to barycentric coordinates (position only) procedure :: fill => util_fill_pl !! \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure :: resize => util_resize_pl !! Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure :: set_beg_end => util_set_beg_end_pl !! Sets the beginning and ending positions and velocities of planets. procedure :: set_mu => util_set_mu_pl !! Method used to construct the vectorized form of the central body mass procedure :: set_rhill => util_set_rhill !! Calculates the Hill's radii for each body procedure :: sort => util_sort_pl !! Sorts body arrays by a sortable component procedure :: rearrange => util_sort_rearrange_pl !! Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure :: spill => util_spill_pl !! \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) end type swiftest_pl !******************************************************************************************************************************** ! swiftest_tp definitions and methods !******************************************************************************************************************************** !> An abstract class for a generic collection of Swiftest test particles type , abstract , extends ( swiftest_body ) :: swiftest_tp !! Superclass that defines the generic elements of a Swiftest test particle integer ( I4B ), dimension (:), allocatable :: isperi !! Perihelion passage flag real ( DP ), dimension (:), allocatable :: peri !! Perihelion distance real ( DP ), dimension (:), allocatable :: atp !! Semimajor axis following perihelion passage integer ( I4B ), dimension (:,:), allocatable :: k_pltp !! Index array used to convert flattened the body-body comparison upper triangular matrix integer ( I8B ) :: npltp !! Number of pl-tp comparisons in the flattened upper triangular matrix !! Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the !!    component list, such as setup_tp and util_spill_tp contains ! Test particle-specific concrete methods ! These are concrete because they are the same implemenation for all integrators procedure :: discard => discard_tp !! Check to see if test particles should be discarded based on their positions relative to the massive bodies procedure :: accel_int => kick_getacch_int_tp !! Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies procedure :: accel_obl => obl_acc_tp !! Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure :: setup => setup_tp !! A base constructor that sets the number of bodies and procedure :: append => util_append_tp !! Appends elements from one structure to another procedure :: h2b => util_coord_h2b_tp !! Convert test particles from heliocentric to barycentric coordinates (position and velocity) procedure :: b2h => util_coord_b2h_tp !! Convert test particles from barycentric to heliocentric coordinates (position and velocity) procedure :: vb2vh => util_coord_vb2vh_tp !! Convert test particles from barycentric to heliocentric coordinates (velocity only) procedure :: vh2vb => util_coord_vh2vb_tp !! Convert test particles from heliocentric to barycentric coordinates (velocity only) procedure :: xh2xb => util_coord_xh2xb_tp !! Convert test particles from heliocentric to barycentric coordinates (position only) procedure :: fill => util_fill_tp !! \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure :: get_peri => util_peri_tp !! Determine system pericenter passages for test particles procedure :: resize => util_resize_tp !! Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure :: set_mu => util_set_mu_tp !! Method used to construct the vectorized form of the central body mass procedure :: sort => util_sort_tp !! Sorts body arrays by a sortable component procedure :: rearrange => util_sort_rearrange_tp !! Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure :: spill => util_spill_tp !! \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) end type swiftest_tp !******************************************************************************************************************************** ! swiftest_nbody_system class definitions and methods !******************************************************************************************************************************** !> An abstract class for a basic Swiftest nbody system type , abstract :: swiftest_nbody_system !!  This superclass contains a minimial system of a set of test particles (tp), massive bodies (pl), and a central body (cb) class ( swiftest_cb ), allocatable :: cb !! Central body data structure class ( swiftest_pl ), allocatable :: pl !! Massive body data structure class ( swiftest_tp ), allocatable :: tp !! Test particle data structure class ( swiftest_tp ), allocatable :: tp_discards !! Discarded test particle data structure class ( swiftest_pl ), allocatable :: pl_discards !! Discarded massive body particle data structure real ( DP ) :: GMtot = 0.0_DP !! Total system mass - used for barycentric coordinate conversion real ( DP ) :: ke_orbit = 0.0_DP !! System orbital kinetic energy real ( DP ) :: ke_spin = 0.0_DP !! System spin kinetic energy real ( DP ) :: pe = 0.0_DP !! System potential energy real ( DP ) :: te = 0.0_DP !! System total energy real ( DP ) :: oblpot = 0.0_DP !! System potential energy due to oblateness of the central body real ( DP ), dimension ( NDIM ) :: Lorbit = 0.0_DP !! System orbital angular momentum vector real ( DP ), dimension ( NDIM ) :: Lspin = 0.0_DP !! System spin angular momentum vector real ( DP ), dimension ( NDIM ) :: Ltot = 0.0_DP !! System angular momentum vector logical :: lbeg !! True if this is the beginning of a step. This is used so that test particle steps can be calculated !!    separately from massive bodies.  Massive body variables are saved at half steps, and passed to !!    the test particles contains !> Each integrator will have its own version of the step procedure ( abstract_step_system ), deferred :: step ! Concrete classes that are common to the basic integrator (only test particles considered for discard) procedure :: discard => discard_system !! Perform a discard step on the system procedure :: conservation_report => io_conservation_report !! Compute energy and momentum and print out the change with time procedure :: dump => io_dump_system !! Dump the state of the system to a file procedure :: get_old_t_final => io_get_old_t_final_system !! Validates the dump file to check whether the dump file initial conditions duplicate the last frame of the binary output. procedure :: read_frame => io_read_frame_system !! Read in a frame of input data from file procedure :: read_particle_info => io_read_particle_info_system !! Read in particle metadata from file procedure :: write_discard => io_write_discard !! Write out information about discarded test particles procedure :: write_frame => io_write_frame_system !! Append a frame of output data to file procedure :: write_hdr_bin => io_write_hdr_system !! Write a header for an output frame in Fortran binary format procedure :: write_hdr_netcdf => netcdf_write_hdr_system !! Write a header for an output frame in NetCDF format procedure :: obl_pot => obl_pot_system !! Compute the contribution to the total gravitational potential due solely to the oblateness of the central body procedure :: initialize => setup_initialize_system !! Initialize the system from input files procedure :: init_particle_info => setup_initialize_particle_info_system !! Initialize the system from input files procedure :: step_spin => tides_step_spin_system !! Steps the spins of the massive & central bodies due to tides. procedure :: set_msys => util_set_msys !! Sets the value of msys from the masses of system bodies. procedure :: get_energy_and_momentum => util_get_energy_momentum_system !! Calculates the total system energy and momentum procedure :: rescale => util_rescale_system !! Rescales the system into a new set of units procedure :: validate_ids => util_valid_id_system !! Validate the numerical ids passed to the system and save the maximum value generic :: write_hdr => write_hdr_bin , write_hdr_netcdf !! Generic method call for writing headers end type swiftest_nbody_system type :: swiftest_encounter integer ( I4B ) :: nenc !! Total number of encounters logical , dimension (:), allocatable :: lvdotr !! relative vdotr flag integer ( I4B ), dimension (:), allocatable :: status !! status of the interaction integer ( I8B ), dimension (:), allocatable :: kidx !! index value of the encounter from the master k_plpl encounter list integer ( I4B ), dimension (:), allocatable :: index1 !! position of the first body in the encounter integer ( I4B ), dimension (:), allocatable :: index2 !! position of the second body in the encounter integer ( I4B ), dimension (:), allocatable :: id1 !! id of the first body in the encounter integer ( I4B ), dimension (:), allocatable :: id2 !! id of the second body in the encounter real ( DP ), dimension (:,:), allocatable :: x1 !! the position of body 1 in the encounter real ( DP ), dimension (:,:), allocatable :: x2 !! the position of body 2 in the encounter real ( DP ), dimension (:,:), allocatable :: v1 !! the velocity of body 1 in the encounter real ( DP ), dimension (:,:), allocatable :: v2 !! the velocity of body 2 in the encounter real ( DP ), dimension (:), allocatable :: t !! Time of encounter contains procedure :: setup => setup_encounter !! A constructor that sets the number of encounters and allocates and initializes all arrays procedure :: append => util_append_encounter !! Appends elements from one structure to another procedure :: copy => util_copy_encounter !! Copies elements from the source encounter list into self. procedure :: spill => util_spill_encounter !! \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure :: resize => util_resize_encounter !! Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small. procedure :: write => io_write_encounter !! Write close encounter data to output binary file end type swiftest_encounter abstract interface subroutine abstract_discard_body ( self , system , param ) import swiftest_body , swiftest_nbody_system , swiftest_parameters class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine abstract_discard_body subroutine abstract_accel ( self , system , param , t , lbeg ) import swiftest_body , swiftest_nbody_system , swiftest_parameters , DP class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time logical , intent ( in ) :: lbeg !! Optional argument that determines whether or not this is the beginning or end of the step end subroutine abstract_accel subroutine abstract_kick_body ( self , system , param , t , dt , lbeg ) import swiftest_body , swiftest_nbody_system , swiftest_parameters , DP implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest generic body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system objec class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Logical flag indicating whether this is the beginning of the half step or not. end subroutine abstract_kick_body function abstract_read_frame ( self , iu , param ) result ( ierr ) import DP , I4B , swiftest_base , swiftest_parameters class ( swiftest_base ), intent ( inout ) :: self !! Swiftest base object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters integer ( I4B ) :: ierr !! Error code: returns 0 if the read is successful end function abstract_read_frame subroutine abstract_set_mu ( self , cb ) import swiftest_body , swiftest_cb class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine abstract_set_mu subroutine abstract_step_body ( self , system , param , t , dt ) import DP , swiftest_body , swiftest_nbody_system , swiftest_parameters implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize end subroutine abstract_step_body subroutine abstract_step_system ( self , param , t , dt ) import DP , swiftest_nbody_system , swiftest_parameters implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize end subroutine abstract_step_system end interface interface module subroutine discard_pl ( self , system , param ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameter end subroutine discard_pl module subroutine discard_system ( self , param ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine discard_system module subroutine discard_tp ( self , system , param ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine discard_tp module subroutine drift_all ( mu , x , v , n , param , dt , lmask , iflag ) implicit none real ( DP ), dimension (:), intent ( in ) :: mu !! Vector of gravitational constants real ( DP ), dimension (:,:), intent ( inout ) :: x , v !! Position and velocity vectors integer ( I4B ), intent ( in ) :: n !! number of bodies class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize logical , dimension (:), intent ( in ) :: lmask !! Logical mask of size self%nbody that determines which bodies to drift. integer ( I4B ), dimension (:), intent ( out ) :: iflag !! Vector of error flags. 0 means no problem end subroutine drift_all module subroutine drift_body ( self , system , param , dt ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: dt !! Stepsize end subroutine drift_body module pure elemental subroutine drift_one ( mu , px , py , pz , vx , vy , vz , dt , iflag ) implicit none real ( DP ), intent ( in ) :: mu !! G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body to drift real ( DP ), intent ( inout ) :: px , py , pz , vx , vy , vz !! Position and velocity of body to drift real ( DP ), intent ( in ) :: dt !! Step size integer ( I4B ), intent ( out ) :: iflag !! iflag : error status flag for Danby drift (0 = OK, nonzero = ERROR) end subroutine drift_one module pure subroutine util_index_eucl_ij_to_k ( n , i , j , k ) !$omp declare simd(util_index_eucl_ij_to_k) implicit none integer ( I4B ), intent ( in ) :: n !! Number of bodies integer ( I4B ), intent ( in ) :: i !! Index of the ith body integer ( I4B ), intent ( in ) :: j !! Index of the jth body integer ( I8B ), intent ( out ) :: k !! Index of the flattened matrix end subroutine util_index_eucl_ij_to_k module pure subroutine util_index_eucl_k_to_ij ( n , k , i , j ) implicit none integer ( I4B ), intent ( in ) :: n !! Number of bodies integer ( I8B ), intent ( in ) :: k !! Index of the flattened matrix integer ( I4B ), intent ( out ) :: i !! Index of the ith body integer ( I4B ), intent ( out ) :: j !! Index of the jth body end subroutine util_index_eucl_k_to_ij module subroutine util_index_eucl_plpl ( self , param ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine module subroutine util_index_eucl_pltp ( self , pl , param ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_pl ), intent ( in ) :: pl !! Swiftest massive body object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine module pure subroutine gr_kick_getaccb_ns_body ( self , system , param ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest generic body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine gr_kick_getaccb_ns_body module pure subroutine gr_kick_getacch ( mu , x , lmask , n , inv_c2 , agr ) implicit none real ( DP ), dimension (:), intent ( in ) :: mu !! Gravitational constant real ( DP ), dimension (:,:), intent ( in ) :: x !! Position vectors logical , dimension (:), intent ( in ) :: lmask !! Logical mask indicating which bodies to compute integer ( I4B ), intent ( in ) :: n !! Total number of bodies real ( DP ), intent ( in ) :: inv_c2 !! Inverse speed of light squared: 1 / c**2 real ( DP ), dimension (:,:), intent ( out ) :: agr !! Accelerations end subroutine gr_kick_getacch module pure subroutine gr_p4_pos_kick ( param , x , v , dt ) implicit none class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), dimension (:), intent ( inout ) :: x !! Position vector real ( DP ), dimension (:), intent ( in ) :: v !! Velocity vector real ( DP ), intent ( in ) :: dt !! Step size end subroutine gr_p4_pos_kick module pure subroutine gr_pseudovel2vel ( param , mu , xh , pv , vh ) implicit none class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: mu !! G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real ( DP ), dimension (:), intent ( in ) :: xh !! Swiftestcentric position vector real ( DP ), dimension (:), intent ( in ) :: pv !! Pseudovelocity velocity vector - see Saha & Tremain (1994), eq. (32) real ( DP ), dimension (:), intent ( out ) :: vh !! Swiftestcentric velocity vector end subroutine gr_pseudovel2vel module pure subroutine gr_pv2vh_body ( self , param ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine gr_pv2vh_body module pure subroutine gr_vel2pseudovel ( param , mu , xh , vh , pv ) implicit none class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: mu !! G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real ( DP ), dimension (:), intent ( in ) :: xh !! Swiftestcentric position vector real ( DP ), dimension (:), intent ( in ) :: vh !! Swiftestcentric velocity vector real ( DP ), dimension (:), intent ( out ) :: pv !! Pseudovelocity vector - see Saha & Tremain (1994), eq. (32) end subroutine gr_vel2pseudovel module pure subroutine gr_vh2pv_body ( self , param ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest particle object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine gr_vh2pv_body module subroutine io_conservation_report ( self , param , lterminal ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Input colleciton of user-defined parameters logical , intent ( in ) :: lterminal !! Indicates whether to output information to the terminal screen end subroutine io_conservation_report module subroutine io_dump_param ( self , param_file_name ) implicit none class ( swiftest_parameters ), intent ( in ) :: self !! Output collection of parameters character ( len =* ), intent ( in ) :: param_file_name !! Parameter input file name (i.e. param.in) end subroutine io_dump_param module subroutine io_dump_particle_info_base ( self , param , idx ) implicit none class ( swiftest_base ), intent ( inout ) :: self !! Swiftest base object (can be cb, pl, or tp) class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters integer ( I4B ), dimension (:), optional , intent ( in ) :: idx !! Array of test particle indices to append to the particle file end subroutine io_dump_particle_info_base module subroutine io_dump_particle_info ( self , iu ) implicit none class ( swiftest_particle_info ), intent ( in ) :: self !! Swiftest particle info metadata object integer ( I4B ), intent ( in ) :: iu !! Open unformatted file unit number end subroutine io_dump_particle_info module subroutine io_dump_base ( self , param ) implicit none class ( swiftest_base ), intent ( inout ) :: self !! Swiftest base object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine io_dump_base module subroutine io_dump_system ( self , param ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine io_dump_system module function io_get_args ( integrator , param_file_name ) result ( ierr ) implicit none integer ( I4B ) :: integrator !! Symbolic code of the requested integrator character ( len = :), allocatable :: param_file_name !! Name of the input parameters file integer ( I4B ) :: ierr !! I/O error code end function io_get_args module function io_get_old_t_final_system ( self , param ) result ( old_t_final ) implicit none class ( swiftest_nbody_system ), intent ( in ) :: self class ( swiftest_parameters ), intent ( in ) :: param real ( DP ) :: old_t_final end function io_get_old_t_final_system module function io_get_token ( buffer , ifirst , ilast , ierr ) result ( token ) implicit none character ( len =* ), intent ( in ) :: buffer !! Input string buffer integer ( I4B ), intent ( inout ) :: ifirst !! Index of the buffer at which to start the search for a token integer ( I4B ), intent ( out ) :: ilast !! Index of the buffer at the end of the returned token integer ( I4B ), intent ( out ) :: ierr !! Error code character ( len = :), allocatable :: token !! Returned token string end function io_get_token module subroutine io_param_reader ( self , unit , iotype , v_list , iostat , iomsg ) implicit none class ( swiftest_parameters ), intent ( inout ) :: self !! Collection of parameters integer ( I4B ), intent ( in ) :: unit !! File unit number character ( len =* ), intent ( in ) :: iotype !! Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. !!    If you do not include a char-literal-constant, the iotype argument contains only DT. integer ( I4B ), intent ( in ) :: v_list (:) !! The first element passes the integrator code to the reader integer ( I4B ), intent ( out ) :: iostat !! IO status code character ( len =* ), intent ( inout ) :: iomsg !! Message to pass if iostat /= 0 end subroutine io_param_reader module subroutine io_param_writer ( self , unit , iotype , v_list , iostat , iomsg ) implicit none class ( swiftest_parameters ), intent ( in ) :: self !! Collection of parameters integer ( I4B ), intent ( in ) :: unit !! File unit number character ( len =* ), intent ( in ) :: iotype !! Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. !!    If you do not include a char-literal-constant, the iotype argument contains only DT. integer ( I4B ), intent ( in ) :: v_list (:) !! Not used in this procedure integer ( I4B ), intent ( out ) :: iostat !! IO status code character ( len =* ), intent ( inout ) :: iomsg !! Message to pass if iostat /= 0 end subroutine io_param_writer module subroutine io_read_in_body ( self , param ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine io_read_in_body module subroutine io_read_in_cb ( self , param ) implicit none class ( swiftest_cb ), intent ( inout ) :: self !! Swiftest central body object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine io_read_in_cb module subroutine io_read_in_param ( self , param_file_name ) implicit none class ( swiftest_parameters ), intent ( inout ) :: self !! Current run configuration parameters character ( len =* ), intent ( in ) :: param_file_name !! Parameter input file name (i.e. param.in) end subroutine io_read_in_param module subroutine io_read_in_particle_info ( self , iu ) implicit none class ( swiftest_particle_info ), intent ( inout ) :: self !! Particle metadata information object integer ( I4B ), intent ( in ) :: iu !! Open file unit number end subroutine io_read_in_particle_info module function io_read_frame_body ( self , iu , param ) result ( ierr ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters integer ( I4B ) :: ierr !! Error code: returns 0 if the read is successful end function io_read_frame_body module function io_read_frame_cb ( self , iu , param ) result ( ierr ) implicit none class ( swiftest_cb ), intent ( inout ) :: self !! Swiftest central body object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters integer ( I4B ) :: ierr !! Error code: returns 0 if the read is successful end function io_read_frame_cb module function io_read_frame_system ( self , iu , param ) result ( ierr ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters integer ( I4B ) :: ierr !! Error code: returns 0 if the read is successful end function io_read_frame_system module subroutine io_read_particle_info_system ( self , param ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine io_read_particle_info_system module subroutine io_write_discard ( self , param ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine io_write_discard module subroutine io_toupper ( string ) implicit none character ( * ), intent ( inout ) :: string !! String to make upper case end subroutine io_toupper module subroutine io_write_encounter ( self , pl , encbody , param ) implicit none class ( swiftest_encounter ), intent ( in ) :: self !! Swiftest encounter list object class ( swiftest_pl ), intent ( in ) :: pl !! Swiftest massive body object class ( swiftest_body ), intent ( in ) :: encbody !! Encountering body - Swiftest generic body object (pl or tp) class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine io_write_encounter module subroutine io_write_frame_body ( self , iu , param ) implicit none class ( swiftest_body ), intent ( in ) :: self !! Swiftest body object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine io_write_frame_body module subroutine io_write_frame_cb ( self , iu , param ) implicit none class ( swiftest_cb ), intent ( in ) :: self !! Swiftest central body object integer ( I4B ), intent ( inout ) :: iu !! Unit number for the output file to write frame to class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine io_write_frame_cb module subroutine io_write_frame_encounter ( iu , t , id1 , id2 , Gmass1 , Gmass2 , radius1 , radius2 , xh1 , xh2 , vh1 , vh2 ) implicit none integer ( I4B ), intent ( in ) :: iu !! Open file unit number real ( DP ), intent ( in ) :: t !! Time of encounter integer ( I4B ), intent ( in ) :: id1 , id2 !! ids of the two encountering bodies real ( DP ), intent ( in ) :: Gmass1 , Gmass2 !! G*mass of the two encountering bodies real ( DP ), intent ( in ) :: radius1 , radius2 !! Radii of the two encountering bodies real ( DP ), dimension (:), intent ( in ) :: xh1 , xh2 !! Swiftestcentric position vectors of the two encountering bodies real ( DP ), dimension (:), intent ( in ) :: vh1 , vh2 !! Swiftestcentric velocity vectors of the two encountering bodies end subroutine io_write_frame_encounter module subroutine io_write_frame_system ( self , param ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine io_write_frame_system module subroutine io_write_hdr_system ( self , iu , param ) implicit none class ( swiftest_nbody_system ), intent ( in ) :: self !! Swiftest nbody system object integer ( I4B ), intent ( inout ) :: iu !! Output file unit number class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine io_write_hdr_system module subroutine kick_getacch_int_pl ( self ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object end subroutine kick_getacch_int_pl module subroutine kick_getacch_int_tp ( self , GMpl , xhp , npl ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle real ( DP ), dimension (:), intent ( in ) :: GMpl !! Massive body masses real ( DP ), dimension (:,:), intent ( in ) :: xhp !! Massive body position vectors integer ( I4B ), intent ( in ) :: npl !! Number of active massive bodies end subroutine kick_getacch_int_tp module subroutine kick_getacch_int_all_pl ( npl , nplpl , k_plpl , x , Gmass , radius , acc ) implicit none integer ( I4B ), intent ( in ) :: npl !! Number of massive bodies integer ( I8B ), intent ( in ) :: nplpl !! Number of massive body interactions to compute integer ( I4B ), dimension (:,:), intent ( in ) :: k_plpl !! Array of interaction pair indices (flattened upper triangular matrix) real ( DP ), dimension (:,:), intent ( in ) :: x !! Position vector array real ( DP ), dimension (:), intent ( in ) :: Gmass !! Array of massive body G*mass real ( DP ), dimension (:), intent ( in ) :: radius !! Array of massive body radii real ( DP ), dimension (:,:), intent ( inout ) :: acc !! Acceleration vector array end subroutine kick_getacch_int_all_pl module subroutine kick_getacch_int_all_tp ( ntp , npl , xtp , xpl , GMpl , lmask , acc ) implicit none integer ( I4B ), intent ( in ) :: ntp !! Number of test particles integer ( I4B ), intent ( in ) :: npl !! Number of massive bodies real ( DP ), dimension (:,:), intent ( in ) :: xtp !! Test particle position vector array real ( DP ), dimension (:,:), intent ( in ) :: xpl !! Massive body particle position vector array real ( DP ), dimension (:), intent ( in ) :: GMpl !! Array of massive body G*mass logical , dimension (:), intent ( in ) :: lmask !! Logical mask indicating which test particles should be computed real ( DP ), dimension (:,:), intent ( inout ) :: acc !! Acceleration vector array end subroutine kick_getacch_int_all_tp module pure subroutine kick_getacch_int_one_pl ( rji2 , xr , yr , zr , Gmi , Gmj , axi , ayi , azi , axj , ayj , azj ) !$omp declare simd(kick_getacch_int_one_pl) implicit none real ( DP ), intent ( in ) :: rji2 !! Square of distance between the two bodies real ( DP ), intent ( in ) :: xr , yr , zr !! Distances between the two bodies in x, y, and z directions real ( DP ), intent ( in ) :: Gmi !! G*mass of body i real ( DP ), intent ( in ) :: Gmj !! G*mass of body j real ( DP ), intent ( inout ) :: axi , ayi , azi !! Acceleration vector components of body i real ( DP ), intent ( inout ) :: axj , ayj , azj !! Acceleration vector components of body j end subroutine kick_getacch_int_one_pl module pure subroutine kick_getacch_int_one_tp ( rji2 , xr , yr , zr , Gmpl , ax , ay , az ) !$omp declare simd(kick_getacch_int_one_tp) implicit none real ( DP ), intent ( in ) :: rji2 !! Square of distance between the test particle and massive body real ( DP ), intent ( in ) :: xr , yr , zr !! Distances between the two bodies in x, y, and z directions real ( DP ), intent ( in ) :: Gmpl !! G*mass of massive body real ( DP ), intent ( inout ) :: ax , ay , az !! Acceleration vector components of test particle end subroutine kick_getacch_int_one_tp module subroutine netcdf_close ( self , param ) implicit none class ( netcdf_parameters ), intent ( inout ) :: self !! Parameters used to identify a particular NetCDF dataset class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine netcdf_close module subroutine netcdf_initialize_output ( self , param ) implicit none class ( netcdf_parameters ), intent ( inout ) :: self !! Parameters used to for writing a NetCDF dataset to file class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine netcdf_initialize_output module subroutine netcdf_open ( self , param ) implicit none class ( netcdf_parameters ), intent ( inout ) :: self !! Parameters used to identify a particular NetCDF dataset class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine netcdf_open module subroutine netcdf_write_frame_base ( self , iu , param ) implicit none class ( swiftest_base ), intent ( in ) :: self !! Swiftest base object class ( netcdf_parameters ), intent ( inout ) :: iu !! Parameters used to for writing a NetCDF dataset to file class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine netcdf_write_frame_base module subroutine netcdf_write_frame_system ( self , iu , param ) implicit none class ( swiftest_nbody_system ), intent ( in ) :: self !! Swiftest system object integer ( I4B ), intent ( inout ) :: iu !! Parameters used to for writing a NetCDF dataset to file class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine netcdf_write_frame_system module subroutine netcdf_write_hdr_system ( self , iu , param ) implicit none class ( swiftest_nbody_system ), intent ( in ) :: self !! Swiftest nbody system object class ( netcdf_parameters ), intent ( inout ) :: iu !! Parameters used to for writing a NetCDF dataset to file class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine netcdf_write_hdr_system module subroutine netcdf_write_particle_info_base ( self , iu ) implicit none class ( swiftest_base ), intent ( in ) :: self !! Swiftest particle object class ( netcdf_parameters ), intent ( inout ) :: iu !! Parameters used to identify a particular NetCDF dataset end subroutine netcdf_write_particle_info_base module subroutine obl_acc_body ( self , system ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object end subroutine obl_acc_body module subroutine obl_acc_pl ( self , system ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object end subroutine obl_acc_pl module subroutine obl_acc_tp ( self , system ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object end subroutine obl_acc_tp module subroutine obl_pot_system ( self ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object end subroutine obl_pot_system module subroutine orbel_el2xv_vec ( self , cb ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine orbel_el2xv_vec module pure subroutine orbel_scget ( angle , sx , cx ) implicit none real ( DP ), intent ( in ) :: angle real ( DP ), intent ( out ) :: sx , cx end subroutine orbel_scget module pure subroutine orbel_xv2aeq ( mu , x , v , a , e , q ) implicit none real ( DP ), intent ( in ) :: mu !! Gravitational constant real ( DP ), dimension (:), intent ( in ) :: x !! Position vector real ( DP ), dimension (:), intent ( in ) :: v !! Velocity vector real ( DP ), intent ( out ) :: a !! semimajor axis real ( DP ), intent ( out ) :: e !! eccentricity real ( DP ), intent ( out ) :: q !! periapsis end subroutine orbel_xv2aeq module pure subroutine orbel_xv2aqt ( mu , x , v , a , q , capm , tperi ) implicit none real ( DP ), intent ( in ) :: mu !! Gravitational constant real ( DP ), dimension (:), intent ( in ) :: x !! Position vector real ( DP ), dimension (:), intent ( in ) :: v !! Velocity vector real ( DP ), intent ( out ) :: a !! semimajor axis real ( DP ), intent ( out ) :: q !! periapsis real ( DP ), intent ( out ) :: capm !! mean anomaly real ( DP ), intent ( out ) :: tperi !! time of pericenter passage end subroutine orbel_xv2aqt module pure subroutine orbel_xv2el ( mu , x , v , a , e , inc , capom , omega , capm ) implicit none real ( DP ), intent ( in ) :: mu !! Gravitational constant real ( DP ), dimension (:), intent ( in ) :: x !! Position vector real ( DP ), dimension (:), intent ( in ) :: v !! Velocity vector real ( DP ), intent ( out ) :: a !! semimajor axis real ( DP ), intent ( out ) :: e !! eccentricity real ( DP ), intent ( out ) :: inc !! inclination real ( DP ), intent ( out ) :: capom !! longitude of ascending node real ( DP ), intent ( out ) :: omega !! argument of periapsis real ( DP ), intent ( out ) :: capm !! mean anomaly end subroutine orbel_xv2el module subroutine orbel_xv2el_vec ( self , cb ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine orbel_xv2el_vec module subroutine setup_body ( self , n , param ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine setup_body module subroutine setup_construct_system ( system , param ) implicit none class ( swiftest_nbody_system ), allocatable , intent ( inout ) :: system !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine setup_construct_system module subroutine setup_encounter ( self , n ) implicit none class ( swiftest_encounter ), intent ( inout ) :: self !! Swiftest encounter structure integer ( I4B ), intent ( in ) :: n !! Number of encounters to allocate space for end subroutine setup_encounter module subroutine setup_initialize_particle_info_system ( self , param ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine setup_initialize_particle_info_system module subroutine setup_initialize_system ( self , param ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine setup_initialize_system module subroutine setup_pl ( self , n , param ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine setup_pl module subroutine setup_tp ( self , n , param ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parametersr end subroutine setup_tp module subroutine tides_kick_getacch_pl ( self , system ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object end subroutine tides_kick_getacch_pl module subroutine tides_step_spin_system ( self , param , t , dt ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize end subroutine tides_step_spin_system module subroutine user_kick_getacch_body ( self , system , param , t , lbeg ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest massive body particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody_system_object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Optional argument that determines whether or not this is the beginning or end of the step end subroutine user_kick_getacch_body end interface interface util_append module subroutine util_append_arr_char_string ( arr , source , nold , nsrc , lsource_mask ) implicit none character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array character ( len = STRMAX ), dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine util_append_arr_char_string module subroutine util_append_arr_DP ( arr , source , nold , nsrc , lsource_mask ) implicit none real ( DP ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array real ( DP ), dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine util_append_arr_DP module subroutine util_append_arr_DPvec ( arr , source , nold , nsrc , lsource_mask ) implicit none real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: arr !! Destination array real ( DP ), dimension (:,:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine util_append_arr_DPvec module subroutine util_append_arr_I4B ( arr , source , nold , nsrc , lsource_mask ) implicit none integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array integer ( I4B ), dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine util_append_arr_I4B module subroutine util_append_arr_info ( arr , source , nold , nsrc , lsource_mask ) implicit none type ( swiftest_particle_info ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array type ( swiftest_particle_info ), dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine util_append_arr_info module subroutine util_append_arr_logical ( arr , source , nold , nsrc , lsource_mask ) implicit none logical , dimension (:), allocatable , intent ( inout ) :: arr !! Destination array logical , dimension (:), allocatable , intent ( in ) :: source !! Array to append integer ( I4B ), intent ( in ) :: nold , nsrc !! Extend of the old array and the source array, respectively logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine util_append_arr_logical end interface interface module subroutine util_append_body ( self , source , lsource_mask ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine util_append_body module subroutine util_append_encounter ( self , source , lsource_mask ) implicit none class ( swiftest_encounter ), intent ( inout ) :: self !! Swiftest encounter list object class ( swiftest_encounter ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine util_append_encounter module subroutine util_append_pl ( self , source , lsource_mask ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine util_append_pl module subroutine util_append_tp ( self , source , lsource_mask ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to end subroutine util_append_tp module subroutine util_coord_b2h_pl ( self , cb ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine util_coord_b2h_pl module subroutine util_coord_b2h_tp ( self , cb ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_cb ), intent ( in ) :: cb !! Swiftest central body object end subroutine util_coord_b2h_tp module subroutine util_coord_h2b_pl ( self , cb ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine util_coord_h2b_pl module subroutine util_coord_h2b_tp ( self , cb ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_cb ), intent ( in ) :: cb !! Swiftest central body object end subroutine util_coord_h2b_tp module subroutine util_coord_vb2vh_pl ( self , cb ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine util_coord_vb2vh_pl module subroutine util_coord_vb2vh_tp ( self , vbcb ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object real ( DP ), dimension (:), intent ( in ) :: vbcb !! Barycentric velocity of the central body end subroutine util_coord_vb2vh_tp module subroutine util_coord_vh2vb_pl ( self , cb ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine util_coord_vh2vb_pl module subroutine util_coord_vh2vb_tp ( self , vbcb ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object real ( DP ), dimension (:), intent ( in ) :: vbcb !! Barycentric velocity of the central body end subroutine util_coord_vh2vb_tp module subroutine util_coord_xh2xb_pl ( self , cb ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine util_coord_xh2xb_pl module subroutine util_coord_xh2xb_tp ( self , cb ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_cb ), intent ( in ) :: cb !! Swiftest central body object end subroutine util_coord_xh2xb_tp module subroutine util_copy_encounter ( self , source ) implicit none class ( swiftest_encounter ), intent ( inout ) :: self !! Encounter list class ( swiftest_encounter ), intent ( in ) :: source !! Source object to copy into end subroutine util_copy_encounter module subroutine util_copy_particle_info ( self , source ) implicit none class ( swiftest_particle_info ), intent ( inout ) :: self class ( swiftest_particle_info ), intent ( in ) :: source end subroutine util_copy_particle_info module subroutine util_copy_particle_info_arr ( source , dest , idx ) implicit none class ( swiftest_particle_info ), dimension (:), intent ( in ) :: source !! Source object to copy into class ( swiftest_particle_info ), dimension (:), intent ( inout ) :: dest !! Swiftest body object with particle metadata information object integer ( I4B ), dimension (:), intent ( in ), optional :: idx !! Optional array of indices to draw the source object end subroutine util_copy_particle_info_arr module subroutine util_exit ( code ) implicit none integer ( I4B ), intent ( in ) :: code !! Failure exit code end subroutine util_exit module subroutine util_fill_body ( self , inserts , lfill_list ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_body ), intent ( in ) :: inserts !! Swiftest body object to be inserted logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine util_fill_body module subroutine util_fill_pl ( self , inserts , lfill_list ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_body ), intent ( in ) :: inserts !! Swiftest body object to be inserted logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine util_fill_pl module subroutine util_fill_tp ( self , inserts , lfill_list ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_body ), intent ( in ) :: inserts !! Swiftest body object to be inserted logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine util_fill_tp end interface interface util_fill module subroutine util_fill_arr_char_string ( keeps , inserts , lfill_list ) implicit none character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep character ( len = STRMAX ), dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine util_fill_arr_char_string module subroutine util_fill_arr_DP ( keeps , inserts , lfill_list ) implicit none real ( DP ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep real ( DP ), dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine util_fill_arr_DP module subroutine util_fill_arr_DPvec ( keeps , inserts , lfill_list ) implicit none real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: keeps !! Array of values to keep real ( DP ), dimension (:,:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine util_fill_arr_DPvec module subroutine util_fill_arr_I4B ( keeps , inserts , lfill_list ) implicit none integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep integer ( I4B ), dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine util_fill_arr_I4B module subroutine util_fill_arr_info ( keeps , inserts , lfill_list ) implicit none type ( swiftest_particle_info ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep type ( swiftest_particle_info ), dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine util_fill_arr_info module subroutine util_fill_arr_logical ( keeps , inserts , lfill_list ) implicit none logical , dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep logical , dimension (:), allocatable , intent ( in ) :: inserts !! Array of values to insert into keep logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps end subroutine util_fill_arr_logical end interface interface module subroutine util_rescale_system ( self , param , mscale , dscale , tscale ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters. Returns with new values of the scale vactors and GU real ( DP ), intent ( in ) :: mscale , dscale , tscale !! Scale factors for mass, distance, and time units, respectively. end subroutine util_rescale_system module function util_minimize_bfgs ( f , N , x0 , eps , maxloop , lerr ) result ( x1 ) use lambda_function implicit none integer ( I4B ), intent ( in ) :: N class ( lambda_obj ), intent ( inout ) :: f real ( DP ), dimension (:), intent ( in ) :: x0 real ( DP ), intent ( in ) :: eps logical , intent ( out ) :: lerr integer ( I4B ), intent ( in ) :: maxloop real ( DP ), dimension (:), allocatable :: x1 end function util_minimize_bfgs module subroutine util_peri_tp ( self , system , param ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine util_peri_tp end interface interface util_resize module subroutine util_resize_arr_char_string ( arr , nnew ) implicit none character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size end subroutine util_resize_arr_char_string module subroutine util_resize_arr_DP ( arr , nnew ) implicit none real ( DP ), dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size end subroutine util_resize_arr_DP module subroutine util_resize_arr_DPvec ( arr , nnew ) implicit none real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size end subroutine util_resize_arr_DPvec module subroutine util_resize_arr_I4B ( arr , nnew ) implicit none integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size end subroutine util_resize_arr_I4B module subroutine util_resize_arr_info ( arr , nnew ) implicit none type ( swiftest_particle_info ), dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size end subroutine util_resize_arr_info module subroutine util_resize_arr_logical ( arr , nnew ) implicit none logical , dimension (:), allocatable , intent ( inout ) :: arr !! Array to resize integer ( I4B ), intent ( in ) :: nnew !! New size end subroutine util_resize_arr_logical end interface interface module subroutine util_resize_body ( self , nnew ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object integer ( I4B ), intent ( in ) :: nnew !! New size neded end subroutine util_resize_body module subroutine util_resize_encounter ( self , nnew ) implicit none class ( swiftest_encounter ), intent ( inout ) :: self !! Swiftest encounter list integer ( I4B ), intent ( in ) :: nnew !! New size of list needed end subroutine util_resize_encounter module subroutine util_resize_pl ( self , nnew ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object integer ( I4B ), intent ( in ) :: nnew !! New size neded end subroutine util_resize_pl module subroutine util_resize_tp ( self , nnew ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object integer ( I4B ), intent ( in ) :: nnew !! New size neded end subroutine util_resize_tp module subroutine util_get_energy_momentum_system ( self , param ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters end subroutine util_get_energy_momentum_system module subroutine util_set_beg_end_pl ( self , xbeg , xend , vbeg ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object real ( DP ), dimension (:,:), intent ( in ), optional :: xbeg !! Position vectors at beginning of step real ( DP ), dimension (:,:), intent ( in ), optional :: xend !! Positions vectors at end of step real ( DP ), dimension (:,:), intent ( in ), optional :: vbeg !! vbeg is an unused variable to keep this method forward compatible with RMVS end subroutine util_set_beg_end_pl module subroutine util_set_ir3h ( self ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object end subroutine util_set_ir3h module subroutine util_set_msys ( self ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest system object end subroutine util_set_msys module subroutine util_set_mu_pl ( self , cb ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine util_set_mu_pl module subroutine util_set_mu_tp ( self , cb ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine util_set_mu_tp module subroutine util_set_particle_info ( self , name , particle_type , status , origin_type , origin_time , origin_xh , origin_vh , discard_time , discard_xh , discard_vh , discard_body_id ) implicit none class ( swiftest_particle_info ), intent ( inout ) :: self character ( len =* ), intent ( in ), optional :: name !! Non-unique name character ( len =* ), intent ( in ), optional :: particle_type !! String containing a description of the particle type (e.g. Central Body, Massive Body, Test Particle) character ( len =* ), intent ( in ), optional :: status !! Particle status description: Active, Merged, Fragmented, etc. character ( len =* ), intent ( in ), optional :: origin_type !! String containing a description of the origin of the particle (e.g. Initial Conditions, Supercatastrophic, Disruption, etc.) real ( DP ), intent ( in ), optional :: origin_time !! The time of the particle's formation real ( DP ), dimension (:), intent ( in ), optional :: origin_xh !! The heliocentric distance vector at the time of the particle's formation real ( DP ), dimension (:), intent ( in ), optional :: origin_vh !! The heliocentric velocity vector at the time of the particle's formation real ( DP ), intent ( in ), optional :: discard_time !! The time of the particle's discard real ( DP ), dimension (:), intent ( in ), optional :: discard_xh !! The heliocentric distance vector at the time of the particle's discard real ( DP ), dimension (:), intent ( in ), optional :: discard_vh !! The heliocentric velocity vector at the time of the particle's discard integer ( I4B ), intent ( in ), optional :: discard_body_id !! The id of the other body involved in the discard (0 if no other body involved) end subroutine util_set_particle_info module subroutine util_set_rhill ( self , cb ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine util_set_rhill module subroutine util_set_rhill_approximate ( self , cb ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_cb ), intent ( inout ) :: cb !! Swiftest central body object end subroutine util_set_rhill_approximate end interface interface util_solve_linear_system module function util_solve_linear_system_d ( A , b , n , lerr ) result ( x ) implicit none integer ( I4B ), intent ( in ) :: n real ( DP ), dimension (:,:), intent ( in ) :: A real ( DP ), dimension (:), intent ( in ) :: b logical , intent ( out ) :: lerr real ( DP ), dimension ( n ) :: x end function util_solve_linear_system_d module function util_solve_linear_system_q ( A , b , n , lerr ) result ( x ) implicit none integer ( I4B ), intent ( in ) :: n real ( QP ), dimension (:,:), intent ( in ) :: A real ( QP ), dimension (:), intent ( in ) :: b logical , intent ( out ) :: lerr real ( QP ), dimension ( n ) :: x end function util_solve_linear_system_q end interface interface module function util_solve_rkf45 ( f , y0in , t1 , dt0 , tol ) result ( y1 ) use lambda_function implicit none class ( lambda_obj ), intent ( inout ) :: f !! lambda function object that has been initialized to be a function of derivatives. The object will return with components lastarg and lasteval set real ( DP ), dimension (:), intent ( in ) :: y0in !! Initial value at t=0 real ( DP ), intent ( in ) :: t1 !! Final time real ( DP ), intent ( in ) :: dt0 !! Initial step size guess real ( DP ), intent ( in ) :: tol !! Tolerance on solution real ( DP ), dimension (:), allocatable :: y1 !! Final result end function util_solve_rkf45 end interface interface util_sort module subroutine util_sort_i4b ( arr ) implicit none integer ( I4B ), dimension (:), intent ( inout ) :: arr end subroutine util_sort_i4b module subroutine util_sort_index_i4b ( arr , ind ) implicit none integer ( I4B ), dimension (:), intent ( in ) :: arr integer ( I4B ), dimension (:), intent ( out ) :: ind end subroutine util_sort_index_i4b module subroutine util_sort_sp ( arr ) implicit none real ( SP ), dimension (:), intent ( inout ) :: arr end subroutine util_sort_sp module subroutine util_sort_index_sp ( arr , ind ) implicit none real ( SP ), dimension (:), intent ( in ) :: arr integer ( I4B ), dimension (:), intent ( out ) :: ind end subroutine util_sort_index_sp module subroutine util_sort_dp ( arr ) implicit none real ( DP ), dimension (:), intent ( inout ) :: arr end subroutine util_sort_dp module subroutine util_sort_index_dp ( arr , ind ) implicit none real ( DP ), dimension (:), intent ( in ) :: arr integer ( I4B ), dimension (:), intent ( out ) :: ind end subroutine util_sort_index_dp end interface util_sort interface util_sort_rearrange module subroutine util_sort_rearrange_arr_char_string ( arr , ind , n ) implicit none character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index to rearrange against integer ( I4B ), intent ( in ) :: n !! Number of elements in arr and ind to rearrange end subroutine util_sort_rearrange_arr_char_string module subroutine util_sort_rearrange_arr_DP ( arr , ind , n ) implicit none real ( DP ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index to rearrange against integer ( I4B ), intent ( in ) :: n !! Number of elements in arr and ind to rearrange end subroutine util_sort_rearrange_arr_DP module subroutine util_sort_rearrange_arr_DPvec ( arr , ind , n ) implicit none real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: arr !! Destination array integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index to rearrange against integer ( I4B ), intent ( in ) :: n !! Number of elements in arr and ind to rearrange end subroutine util_sort_rearrange_arr_DPvec module subroutine util_sort_rearrange_arr_I4B ( arr , ind , n ) implicit none integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index to rearrange against integer ( I4B ), intent ( in ) :: n !! Number of elements in arr and ind to rearrange end subroutine util_sort_rearrange_arr_I4B module subroutine util_sort_rearrange_arr_info ( arr , ind , n ) implicit none type ( swiftest_particle_info ), dimension (:), allocatable , intent ( inout ) :: arr !! Destination array integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index to rearrange against integer ( I4B ), intent ( in ) :: n !! Number of elements in arr and ind to rearrange end subroutine util_sort_rearrange_arr_info module subroutine util_sort_rearrange_arr_logical ( arr , ind , n ) implicit none logical , dimension (:), allocatable , intent ( inout ) :: arr !! Destination array integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index to rearrange against integer ( I4B ), intent ( in ) :: n !! Number of elements in arr and ind to rearrange end subroutine util_sort_rearrange_arr_logical end interface util_sort_rearrange interface module subroutine util_sort_rearrange_body ( self , ind ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) end subroutine util_sort_rearrange_body module subroutine util_sort_rearrange_pl ( self , ind ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) end subroutine util_sort_rearrange_pl module subroutine util_sort_rearrange_tp ( self , ind ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) end subroutine util_sort_rearrange_tp module subroutine util_sort_body ( self , sortby , ascending ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order end subroutine util_sort_body module subroutine util_sort_pl ( self , sortby , ascending ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order end subroutine util_sort_pl module subroutine util_sort_tp ( self , sortby , ascending ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order end subroutine util_sort_tp end interface interface util_spill module subroutine util_spill_arr_char_string ( keeps , discards , lspill_list , ldestructive ) implicit none character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep character ( len = STRMAX ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discardss logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine util_spill_arr_char_string module subroutine util_spill_arr_DP ( keeps , discards , lspill_list , ldestructive ) implicit none real ( DP ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep real ( DP ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine util_spill_arr_DP module subroutine util_spill_arr_DPvec ( keeps , discards , lspill_list , ldestructive ) implicit none real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: keeps !! Array of values to keep real ( DP ), dimension (:,:), allocatable , intent ( inout ) :: discards !! Array discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine util_spill_arr_DPvec module subroutine util_spill_arr_I4B ( keeps , discards , lspill_list , ldestructive ) implicit none integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep integer ( I4B ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discardss logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine util_spill_arr_I4B module subroutine util_spill_arr_I8B ( keeps , discards , lspill_list , ldestructive ) implicit none integer ( I8B ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep integer ( I8B ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discardss logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine util_spill_arr_I8B module subroutine util_spill_arr_info ( keeps , discards , lspill_list , ldestructive ) implicit none type ( swiftest_particle_info ), dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep type ( swiftest_particle_info ), dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discardss logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine util_spill_arr_info module subroutine util_spill_arr_logical ( keeps , discards , lspill_list , ldestructive ) implicit none logical , dimension (:), allocatable , intent ( inout ) :: keeps !! Array of values to keep logical , dimension (:), allocatable , intent ( inout ) :: discards !! Array of discards logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discardss logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine util_spill_arr_logical end interface interface module subroutine util_spill_body ( self , discards , lspill_list , ldestructive ) implicit none class ( swiftest_body ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine util_spill_body module subroutine util_spill_encounter ( self , discards , lspill_list , ldestructive ) implicit none class ( swiftest_encounter ), intent ( inout ) :: self !! Swiftest encounter list class ( swiftest_encounter ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter body by removing the discard list end subroutine util_spill_encounter module subroutine util_spill_pl ( self , discards , lspill_list , ldestructive ) implicit none class ( swiftest_pl ), intent ( inout ) :: self !! Swiftest massive body object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine util_spill_pl module subroutine util_spill_tp ( self , discards , lspill_list , ldestructive ) implicit none class ( swiftest_tp ), intent ( inout ) :: self !! Swiftest test particle object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not end subroutine util_spill_tp module subroutine util_valid_id_system ( self , param ) implicit none class ( swiftest_nbody_system ), intent ( inout ) :: self !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters end subroutine util_valid_id_system module subroutine util_version () implicit none end subroutine util_version end interface end module swiftest_classes","tags":"","loc":"sourcefile/swiftest_classes.f90.html"},{"title":"lambda_function.f90 – swiftest","text":"This file depends on sourcefile~~lambda_function.f90~~EfferentGraph sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~lambda_function.f90~~AfferentGraph sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~symba_collision.f90 symba_collision.f90 sourcefile~symba_collision.f90->sourcefile~swiftest.f90 sourcefile~kick.f90 kick.f90 sourcefile~kick.f90->sourcefile~swiftest.f90 sourcefile~util_exit.f90 util_exit.f90 sourcefile~util_exit.f90->sourcefile~swiftest.f90 sourcefile~util_index.f90 util_index.f90 sourcefile~util_index.f90->sourcefile~swiftest.f90 sourcefile~symba_kick.f90 symba_kick.f90 sourcefile~symba_kick.f90->sourcefile~swiftest.f90 sourcefile~symba_discard.f90 symba_discard.f90 sourcefile~symba_discard.f90->sourcefile~swiftest.f90 sourcefile~tides_spin_step.f90 tides_spin_step.f90 sourcefile~tides_spin_step.f90->sourcefile~swiftest.f90 sourcefile~whm_drift.f90 whm_drift.f90 sourcefile~whm_drift.f90->sourcefile~swiftest.f90 sourcefile~util_rescale.f90 util_rescale.f90 sourcefile~util_rescale.f90->sourcefile~swiftest.f90 sourcefile~symba_step.f90 symba_step.f90 sourcefile~symba_step.f90->sourcefile~swiftest.f90 sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~util_sort.f90 util_sort.f90 sourcefile~util_sort.f90->sourcefile~swiftest.f90 sourcefile~util_get_energy_momentum.f90 util_get_energy_momentum.f90 sourcefile~util_get_energy_momentum.f90->sourcefile~swiftest.f90 sourcefile~operator_cross.f90 operator_cross.f90 sourcefile~operator_cross.f90->sourcefile~swiftest.f90 sourcefile~util_spill.f90 util_spill.f90 sourcefile~util_spill.f90->sourcefile~swiftest.f90 sourcefile~fraggle_regime.f90 fraggle_regime.f90 sourcefile~fraggle_regime.f90->sourcefile~swiftest.f90 sourcefile~util_copy.f90 util_copy.f90 sourcefile~util_copy.f90->sourcefile~swiftest.f90 sourcefile~fraggle_io.f90 fraggle_io.f90 sourcefile~fraggle_io.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90~2 orbel.f90 sourcefile~orbel.f90~2->sourcefile~swiftest.f90 sourcefile~fraggle_generate.f90 fraggle_generate.f90 sourcefile~fraggle_generate.f90->sourcefile~swiftest.f90 sourcefile~netcdf.f90 netcdf.f90 sourcefile~netcdf.f90->sourcefile~swiftest.f90 sourcefile~util_coord.f90 util_coord.f90 sourcefile~util_coord.f90->sourcefile~swiftest.f90 sourcefile~whm_gr.f90 whm_gr.f90 sourcefile~whm_gr.f90->sourcefile~swiftest.f90 sourcefile~tides_getacch_pl.f90 tides_getacch_pl.f90 sourcefile~tides_getacch_pl.f90->sourcefile~swiftest.f90 sourcefile~helio_drift.f90 helio_drift.f90 sourcefile~helio_drift.f90->sourcefile~swiftest.f90 sourcefile~gr.f90 gr.f90 sourcefile~gr.f90->sourcefile~swiftest.f90 sourcefile~util_set.f90 util_set.f90 sourcefile~util_set.f90->sourcefile~swiftest.f90 sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~symba_io.f90 symba_io.f90 sourcefile~symba_io.f90->sourcefile~swiftest.f90 sourcefile~fraggle_set.f90 fraggle_set.f90 sourcefile~fraggle_set.f90->sourcefile~swiftest.f90 sourcefile~util_append.f90 util_append.f90 sourcefile~util_append.f90->sourcefile~swiftest.f90 sourcefile~util_resize.f90 util_resize.f90 sourcefile~util_resize.f90->sourcefile~swiftest.f90 sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~io.f90 io.f90 sourcefile~io.f90->sourcefile~swiftest.f90 sourcefile~drift.f90 drift.f90 sourcefile~drift.f90->sourcefile~swiftest.f90 sourcefile~helio_gr.f90 helio_gr.f90 sourcefile~helio_gr.f90->sourcefile~swiftest.f90 sourcefile~symba_util.f90 symba_util.f90 sourcefile~symba_util.f90->sourcefile~swiftest.f90 sourcefile~swiftest_driver.f90 swiftest_driver.f90 sourcefile~swiftest_driver.f90->sourcefile~swiftest.f90 sourcefile~whm_step.f90 whm_step.f90 sourcefile~whm_step.f90->sourcefile~swiftest.f90 sourcefile~fraggle_placeholder.f90 fraggle_placeholder.f90 sourcefile~fraggle_placeholder.f90->sourcefile~swiftest.f90 sourcefile~rmvs_io.f90 rmvs_io.f90 sourcefile~rmvs_io.f90->sourcefile~swiftest.f90 sourcefile~whm_kick.f90 whm_kick.f90 sourcefile~whm_kick.f90->sourcefile~swiftest.f90 sourcefile~util_peri.f90 util_peri.f90 sourcefile~util_peri.f90->sourcefile~swiftest.f90 sourcefile~helio_kick.f90 helio_kick.f90 sourcefile~helio_kick.f90->sourcefile~swiftest.f90 sourcefile~whm_coord.f90 whm_coord.f90 sourcefile~whm_coord.f90->sourcefile~swiftest.f90 sourcefile~discard.f90 discard.f90 sourcefile~discard.f90->sourcefile~swiftest.f90 sourcefile~orbel.f90 orbel.f90 sourcefile~orbel.f90->sourcefile~swiftest.f90 sourcefile~whm_setup.f90 whm_setup.f90 sourcefile~whm_setup.f90->sourcefile~swiftest.f90 sourcefile~user_getacch.f90 user_getacch.f90 sourcefile~user_getacch.f90->sourcefile~swiftest.f90 sourcefile~fraggle_setup.f90 fraggle_setup.f90 sourcefile~fraggle_setup.f90->sourcefile~swiftest.f90 sourcefile~obl.f90 obl.f90 sourcefile~obl.f90->sourcefile~swiftest.f90 sourcefile~whm_util.f90 whm_util.f90 sourcefile~whm_util.f90->sourcefile~swiftest.f90 sourcefile~util_version.f90 util_version.f90 sourcefile~util_version.f90->sourcefile~swiftest.f90 sourcefile~setup.f90 setup.f90 sourcefile~setup.f90->sourcefile~swiftest.f90 sourcefile~util_fill.f90 util_fill.f90 sourcefile~util_fill.f90->sourcefile~swiftest.f90 sourcefile~util_valid.f90 util_valid.f90 sourcefile~util_valid.f90->sourcefile~swiftest.f90 sourcefile~symba_encounter_check.f90 symba_encounter_check.f90 sourcefile~symba_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~symba_drift.f90 symba_drift.f90 sourcefile~symba_drift.f90->sourcefile~swiftest.f90 sourcefile~fraggle_util.f90 fraggle_util.f90 sourcefile~fraggle_util.f90->sourcefile~swiftest.f90 sourcefile~helio_setup.f90 helio_setup.f90 sourcefile~helio_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~util_solve.f90 util_solve.f90 sourcefile~util_solve.f90->sourcefile~swiftest.f90 sourcefile~helio_step.f90 helio_step.f90 sourcefile~helio_step.f90->sourcefile~swiftest.f90 sourcefile~util_minimize_bfgs.f90 util_minimize_bfgs.f90 sourcefile~util_minimize_bfgs.f90->sourcefile~swiftest.f90 sourcefile~symba_setup.f90 symba_setup.f90 sourcefile~symba_setup.f90->sourcefile~swiftest.f90 sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules lambda_function Source Code lambda_function.f90 Source Code module lambda_function !! author: David A. Minton !! !! Defines a class that can enable objects that behave like lambda functions. !! !! To use this class, define a type of either lambda_obj or lambda_obj_err, or extend the lambda_obj class as necessary, such that an interface that matches the function you wish to lambdafy. !! Once defined, the lambda object can evaluate itself by calling the type-bound procedure eval. e.g. f%eval(x) (or f%eval(x, lerr), f%eval(x, [argument list], etc)) !! !! ******************************************************************************************************************************************************************************************** !! Example - Defining a lambda function f(x,rval,ival) where rval and ival are a real and integer argument, respectively. This implementation uses an abstract interface, though this is not !! strictly necessary unless you want to bind more than one function with the same interface. !! ******************************************************************************************************************************************************************************************** !! !! module lambda_new !!    use swiftest ! This will bring in the lambda_function module !!    ! Define types in a module !! !!    type, extends(lambda_obj) :: lambda_obj_ri_args !!       procedure(abstract_lambda_ri_args), pointer, nopass :: lambdaptr_ri_args => null() !!       real(DP)                                            :: rval     !! Real parameter !!       integer(I4B)                                        :: ival     !! Integer paramete !!    contains !!       generic           :: init => lambda_ri_args_init !!       procedure         :: eval => lambda_ri_args_eval !!       procedure, nopass :: lambda_ri_args_init !!       final             :: lambda_ri_args_destroy !!    end type !!    interface lambda_obj !!       module procedure lambda_ri_args_init !!    end interface !! !!    abstract interface !!       function abstract_lambda_ri_args(x, rval, ival) result(y) !!          !Template for the lambda function !!          import DP, I4B !!          real(DP), dimension(:), intent(in) :: x        !! Dependent variable !!          real(DP),               intent(in) :: rval     !! Real parameter !!          integer(I4B),           intent(in) :: ival     !! Integer parameter !!          real(DP)                           :: y        !! Real result !!       end function !!    end interface !! !! contains !!    type(lambda_obj_ri_args) function lambda_ri_args_init(lambda, rval, ival) !!       !! Initializes the lambda function parameters (can be used as a structure constructor) !!       implicit none !!       procedure(abstract_lambda_ri_args)  :: lambda !! The lambda function that will be passed !!       real(DP),     intent(in)            :: rval     !! Real parameter !!       integer(I4B), intent(in)            :: ival     !! Integer parameter !! !!       ! Assign the procedure passed to this function to the procedure pointer !!       lambda_ri_args_init%lambdaptr_ri_args => lambda !! !!       ! Assign the argument values !!       lambda_ri_args_init%rval = rval !!       lambda_ri_args_init%ival = ival !!       return !!    end function lambda_ri_args_init !! !!    function lambda_ri_args_eval(self, x) result(y) !!       !! Defines the evaluation method, allowing the lambda function to be called with a single argument !!       implicit none !!       class(lambda_obj_ri_args),      intent(inout) :: self !!       real(DP), dimension(:),         intent(in) :: x !!       real(DP)                                   :: y !! !!      if (associated(self%lambdaptr_ri_args)) then !!         y = self%lambdaptr_ri_args(x, self%rval, self%ival) !!          self%lastval = y !!          if (allocated(self%lastarg)) deallocate(self%lastarg) !!          allocate(self%lastarg, source=x) !!       else !!          error stop \"Lambda function was not initialized\" !!       end if !!    end function lambda_ri_args_eval !! !!    subroutine lambda_ri_args_destroy(self) !!       !! Finalizer method. Use this as a template for cleaning up the object upon destruction, such as nullifying pointers !!       implicit none !!       type(lambda_obj_ri_args) :: self !!       if (associated(self%lambdaptr_ri_args)) nullify(self%lambdaptr_ri_args) !!    end subroutine lambda_ri_args_destroy !! !!    function example_function(x, rval, ival) result(y) !!       !This is the actual function you are going to use as the lambda function. Its interface must match the abstract interface previously defined !!       implicit none !!       ! Arguments !!       real(DP), dimension(:), intent(in) :: x !!       real(DP),               intent(in) :: rval !!       integer(I4B),           intent(in) :: ival !!       ! Result !!       real(DP)                           :: y !!       ! Internals !!       integer(I4B) :: i, n !!       n = size(x) !!       y = 42._DP * ival !!       do i = 1, n !!          y = y + x(i)**2 !!       end do !!       return !!    end function example_function !! end module lambda_new !! !! program usage !!    use swiftest !!    use lambda_new !!    implicit none !!    type(lambda_obj_ri_args) :: f !!    real(DP) :: sigma_par !!    integer(I4B) :: iwonky, i,j !!    real(DP), dimension(12) :: xarr !! !!    sigma_par = 3.14_DP !!    iwonky = 13 !! !!    f = lambda_obj(example_function, sigma_par, iwonky) !!    do i = 1, 10 !!       xarr(:) = [(j * 0.25_DP / i, j=1, 12)] !!       write(*,*) i,f%eval(xarr) !!    end do !! end program usage !! ******************************************************************************************************************************************************************************************** use swiftest_globals implicit none public type :: lambda_obj !! Base class for an lambda function object. This object takes no additional arguments other than the dependent variable x, an array of real numbers procedure ( lambda0 ), pointer , nopass :: lambdaptr => null () real ( DP ) :: lastval real ( DP ), dimension (:), allocatable :: lastarg contains generic :: init => lambda_init_0 procedure :: eval => lambda_eval_0 procedure , nopass :: lambda_init_0 final :: lambda_destroy end type type , extends ( lambda_obj ) :: lambda_obj_err !! Extended class for an lambda function object. This object takes allows for the return of a logical error flag during evaluation of the function. procedure ( lambda0err ), pointer , nopass :: lambdaptr_err => null () logical :: lerr contains generic :: init => lambda_init_0_err procedure :: eval => lambda_eval_0_err procedure , nopass :: lambda_init_0_err end type type , extends ( lambda_obj ) :: lambda_obj_tvar !! Base class for an lambda function object. This object takes no additional arguments other than the dependent variable x, an array of real numbers procedure ( lambda0tvar ), pointer , nopass :: lambdaptr_tvar => null () contains generic :: init => lambda_init_tvar procedure :: evalt => lambda_eval_tvar procedure , nopass :: lambda_init_tvar end type interface lambda_obj module procedure lambda_init_0 module procedure lambda_init_0_err module procedure lambda_init_tvar end interface abstract interface function lambda0 ( x ) result ( y ) ! Template for a 0 argument function import DP real ( DP ), dimension (:), intent ( in ) :: x real ( DP ) :: y end function function lambda0err ( x , lerr ) result ( y ) ! Template for a 0 argument function that returns an error value import DP real ( DP ), dimension (:), intent ( in ) :: x logical , intent ( out ) :: lerr real ( DP ) :: y end function function lambda0tvar ( x , t ) result ( y ) ! Template for a 0 argument function that returns an error value import DP real ( DP ), dimension (:), intent ( in ) :: x real ( DP ), intent ( in ) :: t real ( DP ), dimension (:), allocatable :: y end function end interface contains type ( lambda_obj ) function lambda_init_0 ( lambda ) implicit none ! Arguments procedure ( lambda0 ) :: lambda lambda_init_0 % lambdaptr => lambda return end function lambda_init_0 type ( lambda_obj_err ) function lambda_init_0_err ( lambda , lerr ) implicit none ! Arguments procedure ( lambda0err ) :: lambda logical , intent ( in ) :: lerr lambda_init_0_err % lambdaptr_err => lambda lambda_init_0_err % lerr = lerr return end function lambda_init_0_err type ( lambda_obj_tvar ) function lambda_init_tvar ( lambda , t ) implicit none ! Arguments procedure ( lambda0tvar ) :: lambda real ( DP ), intent ( in ) :: t lambda_init_tvar % lambdaptr_tvar => lambda return end function lambda_init_tvar function lambda_eval_0 ( self , x ) result ( y ) implicit none ! Arguments class ( lambda_obj ), intent ( inout ) :: self real ( DP ), dimension (:), intent ( in ) :: x ! Result real ( DP ) :: y if ( associated ( self % lambdaptr )) then y = self % lambdaptr ( x ) self % lastval = y if ( allocated ( self % lastarg )) deallocate ( self % lastarg ) allocate ( self % lastarg , source = x ) else error stop \"Lambda function was not initialized\" end if end function lambda_eval_0 function lambda_eval_0_err ( self , x ) result ( y ) implicit none ! Arguments class ( lambda_obj_err ), intent ( inout ) :: self real ( DP ), dimension (:), intent ( in ) :: x ! Result real ( DP ) :: y if ( associated ( self % lambdaptr_err )) then y = self % lambdaptr_err ( x , self % lerr ) self % lastval = y if ( allocated ( self % lastarg )) deallocate ( self % lastarg ) allocate ( self % lastarg , source = x ) else error stop \"Lambda function was not initialized\" end if end function lambda_eval_0_err function lambda_eval_tvar ( self , x , t ) result ( y ) implicit none ! Arguments class ( lambda_obj_tvar ), intent ( inout ) :: self real ( DP ), dimension (:), intent ( in ) :: x real ( DP ), intent ( in ) :: t ! Result real ( DP ), dimension (:), allocatable :: y if ( associated ( self % lambdaptr_tvar )) then y = self % lambdaptr_tvar ( x , t ) else error stop \"Lambda function was not initialized\" end if end function lambda_eval_tvar subroutine lambda_destroy ( self ) implicit none type ( lambda_obj ) :: self if ( associated ( self % lambdaptr )) nullify ( self % lambdaptr ) end subroutine lambda_destroy end module lambda_function","tags":"","loc":"sourcefile/lambda_function.f90.html"},{"title":"fraggle_util.f90 – swiftest","text":"This file depends on sourcefile~~fraggle_util.f90~~EfferentGraph sourcefile~fraggle_util.f90 fraggle_util.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~fraggle_util.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~fraggle_util.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_fraggle_util Source Code fraggle_util.f90 Source Code submodule ( fraggle_classes ) s_fraggle_util use swiftest contains module subroutine fraggle_util_add_fragments_to_system ( frag , colliders , system , param ) !! Author: David A. Minton !! !! Adds fragments to the temporary system pl object implicit none ! Arguments class ( fraggle_fragments ), intent ( in ) :: frag !! Fraggle fragment system object class ( fraggle_colliders ), intent ( in ) :: colliders !! Fraggle collider system object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current swiftest run configuration parameters ! Internals integer ( I4B ) :: i , npl_before , npl_after logical , dimension (:), allocatable :: lexclude associate ( nfrag => frag % nbody , pl => system % pl , cb => system % cb ) npl_after = pl % nbody npl_before = npl_after - nfrag allocate ( lexclude ( npl_after )) pl % status ( npl_before + 1 : npl_after ) = ACTIVE pl % mass ( npl_before + 1 : npl_after ) = frag % mass ( 1 : nfrag ) pl % Gmass ( npl_before + 1 : npl_after ) = frag % mass ( 1 : nfrag ) * param % GU pl % radius ( npl_before + 1 : npl_after ) = frag % radius ( 1 : nfrag ) do concurrent ( i = 1 : nfrag ) pl % xb (:, npl_before + i ) = frag % xb (:, i ) pl % vb (:, npl_before + i ) = frag % vb (:, i ) pl % xh (:, npl_before + i ) = frag % xb (:, i ) - cb % xb (:) pl % vh (:, npl_before + i ) = frag % vb (:, i ) - cb % vb (:) end do if ( param % lrotation ) then pl % Ip (:, npl_before + 1 : npl_after ) = frag % Ip (:, 1 : nfrag ) pl % rot (:, npl_before + 1 : npl_after ) = frag % rot (:, 1 : nfrag ) end if ! This will remove the colliders from the system since we've replaced them with fragments lexclude ( 1 : npl_after ) = . false . lexclude ( colliders % idx ( 1 : colliders % ncoll )) = . true . where ( lexclude ( 1 : npl_after )) pl % status ( 1 : npl_after ) = INACTIVE elsewhere pl % status ( 1 : npl_after ) = ACTIVE endwhere end associate return end subroutine fraggle_util_add_fragments_to_system module subroutine fraggle_util_ang_mtm ( self ) !! Author: David A. Minton !! !! Calcualtes the current angular momentum of the fragments implicit none ! Arguments class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object ! Internals integer ( I4B ) :: i associate ( frag => self , nfrag => self % nbody ) frag % L_orbit (:) = 0.0_DP frag % L_spin (:) = 0.0_DP do i = 1 , nfrag frag % L_orbit (:) = frag % L_orbit (:) + frag % mass ( i ) * ( frag % x_coll (:, i ) . cross . frag % v_coll (:, i )) frag % L_spin (:) = frag % L_spin (:) + frag % mass ( i ) * frag % radius ( i ) ** 2 * frag % Ip (:, i ) * frag % rot (:, i ) end do end associate return end subroutine fraggle_util_ang_mtm module subroutine fraggle_util_construct_temporary_system ( frag , system , param , tmpsys , tmpparam ) !! Author: David A. Minton !! !! Constructs a temporary internal system consisting of active bodies and additional fragments. This internal temporary system is used to calculate system energy with and without fragments !! and optionally including fragments. implicit none ! Arguments class ( fraggle_fragments ), intent ( in ) :: frag !! Fraggle fragment system object class ( swiftest_nbody_system ), intent ( in ) :: system !! Original swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current swiftest run configuration parameters class ( swiftest_nbody_system ), allocatable , intent ( out ) :: tmpsys !! Output temporary swiftest nbody system object class ( swiftest_parameters ), allocatable , intent ( out ) :: tmpparam !! Output temporary configuration run parameters ! Internals logical , dimension (:), allocatable :: linclude integer ( I4B ) :: npl_tot associate ( nfrag => frag % nbody , pl => system % pl , npl => system % pl % nbody , cb => system % cb ) ! Set up a new system based on the original if ( allocated ( tmpparam )) deallocate ( tmpparam ) if ( allocated ( tmpsys )) deallocate ( tmpsys ) allocate ( tmpparam , source = param ) call setup_construct_system ( tmpsys , tmpparam ) ! No test particles necessary for energy/momentum calcs call tmpsys % tp % setup ( 0 , param ) ! Replace the empty central body object with a copy of the original deallocate ( tmpsys % cb ) allocate ( tmpsys % cb , source = cb ) ! Make space for the fragments npl_tot = npl + nfrag call tmpsys % pl % setup ( npl_tot , tmpparam ) allocate ( linclude ( npl_tot )) ! Fill up the temporary system with all of the original bodies, leaving the spaces for fragments empty until we add them in later linclude ( 1 : npl ) = . true . linclude ( npl + 1 : npl_tot ) = . false . call tmpsys % pl % fill ( pl , linclude ) ! Scale the temporary system to the natural units of the current Fraggle calculation call tmpsys % rescale ( tmpparam , frag % mscale , frag % dscale , frag % tscale ) end associate return end subroutine fraggle_util_construct_temporary_system module subroutine fraggle_util_get_energy_momentum ( self , colliders , system , param , lbefore ) !! Author: David A. Minton !! !! Calculates total system energy in either the pre-collision outcome state (lbefore = .true.) or the post-collision outcome state (lbefore = .false.) !! This subrourtine works by building a temporary internal massive body object out of the non-excluded bodies and optionally with fragments appended. !! This will get passed to the energy calculation subroutine so that energy is computed exactly the same way is it is in the main program. !! This will temporarily expand the massive body object in a temporary system object called tmpsys to feed it into symba_energy implicit none ! Arguments class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle collider system object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current swiftest run configuration parameters logical , intent ( in ) :: lbefore !! Flag indicating that this the \"before\" state of the system, with colliders included and fragments excluded or vice versa ! Internals integer ( I4B ) :: i , nplm logical , dimension (:), allocatable :: lexclude logical :: lk_plpl logical , save :: ladd_frags class ( swiftest_nbody_system ), allocatable , save :: tmpsys class ( swiftest_parameters ), allocatable , save :: tmpparam integer ( I4B ) :: npl_before , npl_after associate ( frag => self , nfrag => self % nbody , pl => system % pl , cb => system % cb ) ! Because we're making a copy of the massive body object with the excludes/fragments appended, we need to deallocate the ! big k_plpl array and recreate it when we're done, otherwise we run the risk of blowing up the memory by ! allocating two of these ginormous arrays simulteouously. This is not particularly efficient, but as this ! subroutine should be called relatively infrequently, it shouldn't matter too much. npl_before = pl % nbody npl_after = npl_before + nfrag ! Build the exluded body logical mask allocate ( lexclude ( npl_after )) if ( lbefore ) then lexclude ( 1 : npl_before ) = . false . lexclude ( npl_before + 1 : npl_after ) = . true . call fraggle_util_construct_temporary_system ( frag , system , param , tmpsys , tmpparam ) else lexclude ( 1 : npl_after ) = . false . lexclude ( colliders % idx ( 1 : colliders % ncoll )) = . true . if (. not . allocated ( tmpsys )) then write ( * , * ) \"Error in fraggle_util_get_energy_momentum. This must be called with lbefore=.true. at least once before calling it with lbefore=.false.\" call util_exit ( FAILURE ) end if call fraggle_util_add_fragments_to_system ( frag , colliders , tmpsys , tmpparam ) end if call tmpsys % pl % index ( param ) call tmpsys % get_energy_and_momentum ( param ) ! Calculate the current fragment energy and momentum balances if ( lbefore ) then frag % Lorbit_before (:) = tmpsys % Lorbit (:) frag % Lspin_before (:) = tmpsys % Lspin (:) frag % Ltot_before (:) = tmpsys % Ltot (:) frag % ke_orbit_before = tmpsys % ke_orbit frag % ke_spin_before = tmpsys % ke_spin frag % pe_before = tmpsys % pe frag % Etot_before = tmpsys % te else frag % Lorbit_after (:) = tmpsys % Lorbit (:) frag % Lspin_after (:) = tmpsys % Lspin (:) frag % Ltot_after (:) = tmpsys % Ltot (:) frag % ke_orbit_after = tmpsys % ke_orbit frag % ke_spin_after = tmpsys % ke_spin frag % pe_after = tmpsys % pe frag % Etot_after = tmpsys % te end if end associate return end subroutine fraggle_util_get_energy_momentum module subroutine fraggle_util_restructure ( self , colliders , try , f_spin , r_max_start ) !! Author: David A. Minton !! !! Restructure the inputs after a failed attempt failed to find a set of positions and velocities that satisfy the energy and momentum constraints implicit none ! Arguments class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object class ( fraggle_colliders ), intent ( in ) :: colliders !! Fraggle collider system object integer ( I4B ), intent ( in ) :: try !! The current number of times Fraggle has tried to find a solution real ( DP ), intent ( inout ) :: f_spin !! Fraction of energy/momentum that goes into spin. This decreases ater a failed attempt real ( DP ), intent ( inout ) :: r_max_start !! The maximum radial distance that the position calculation starts with. This increases after a failed attempt ! Internals integer ( I4B ) :: i real ( DP ), save :: ke_tot_deficit , r_max_start_old , ke_avg_deficit_old real ( DP ), dimension (:), allocatable :: m_frag_new , rad_frag_new real ( DP ), dimension (:,:), allocatable :: xb_frag_new , vb_frag_new , Ip_frag_new , rot_frag_new real ( DP ) :: delta_r , delta_r_max , ke_avg_deficit real ( DP ), parameter :: ke_avg_deficit_target = 0.0_DP ! Introduce a bit of noise in the radius determination so we don't just flip flop between similar failed positions associate ( frag => self ) call random_number ( delta_r_max ) delta_r_max = sum ( colliders % radius (:)) * ( 1.0_DP + 2e-1_DP * ( delta_r_max - 0.5_DP )) if ( try == 1 ) then ke_tot_deficit = - ( frag % ke_budget - frag % ke_orbit - frag % ke_spin ) ke_avg_deficit = ke_tot_deficit delta_r = delta_r_max else ! Linearly interpolate the last two failed solution ke deficits to find a new distance value to try ke_tot_deficit = ke_tot_deficit - ( frag % ke_budget - frag % ke_orbit - frag % ke_spin ) ke_avg_deficit = ke_tot_deficit / try delta_r = ( r_max_start - r_max_start_old ) * ( ke_avg_deficit_target - ke_avg_deficit_old ) / ( ke_avg_deficit - ke_avg_deficit_old ) if ( abs ( delta_r ) > delta_r_max ) delta_r = sign ( delta_r_max , delta_r ) end if r_max_start_old = r_max_start r_max_start = r_max_start + delta_r ! The larger lever arm can help if the problem is in the angular momentum step ke_avg_deficit_old = ke_avg_deficit if ( f_spin > epsilon ( 1.0_DP )) then ! Try reducing the fraction in spin f_spin = f_spin / 2 else f_spin = 0.0_DP end if end associate return end subroutine fraggle_util_restructure module subroutine fraggle_util_shift_vector_to_origin ( m_frag , vec_frag ) !! Author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Adjusts the position or velocity of the fragments as needed to align them with the origin implicit none ! Arguments real ( DP ), dimension (:), intent ( in ) :: m_frag !! Fragment masses real ( DP ), dimension (:,:), intent ( inout ) :: vec_frag !! Fragment positions or velocities in the center of mass frame ! Internals real ( DP ), dimension ( NDIM ) :: mvec_frag , COM_offset integer ( I4B ) :: i , nfrag real ( DP ) :: mtot mvec_frag (:) = 0.0_DP mtot = sum ( m_frag ) nfrag = size ( m_frag ) do i = 1 , nfrag mvec_frag = mvec_frag (:) + vec_frag (:, i ) * m_frag ( i ) end do COM_offset (:) = - mvec_frag (:) / mtot do i = 1 , nfrag vec_frag (:, i ) = vec_frag (:, i ) + COM_offset (:) end do return end subroutine fraggle_util_shift_vector_to_origin module function fraggle_util_vmag_to_vb ( v_r_mag , v_r_unit , v_t_mag , v_t_unit , m_frag , vcom ) result ( vb ) !! Author: David A. Minton !! !! Converts radial and tangential velocity magnitudes into barycentric velocity implicit none ! Arguments real ( DP ), dimension (:), intent ( in ) :: v_r_mag !! Unknown radial component of fragment velocity vector real ( DP ), dimension (:), intent ( in ) :: v_t_mag !! Tangential component of velocity vector set previously by angular momentum constraint real ( DP ), dimension (:,:), intent ( in ) :: v_r_unit , v_t_unit !! Radial and tangential unit vectors for each fragment real ( DP ), dimension (:), intent ( in ) :: m_frag !! Fragment masses real ( DP ), dimension (:), intent ( in ) :: vcom !! Barycentric velocity of collisional system center of mass ! Result real ( DP ), dimension (:,:), allocatable :: vb ! Internals integer ( I4B ) :: i , nfrag allocate ( vb , mold = v_r_unit ) ! Make sure the velocity magnitude stays positive nfrag = size ( m_frag ) do i = 1 , nfrag vb (:, i ) = abs ( v_r_mag ( i )) * v_r_unit (:, i ) end do ! In order to keep satisfying the kinetic energy constraint, we must shift the origin of the radial component of the velocities to the center of mass call fraggle_util_shift_vector_to_origin ( m_frag , vb ) do i = 1 , nfrag vb (:, i ) = vb (:, i ) + v_t_mag ( i ) * v_t_unit (:, i ) + vcom (:) end do return end function fraggle_util_vmag_to_vb end submodule s_fraggle_util","tags":"","loc":"sourcefile/fraggle_util.f90.html"},{"title":"fraggle_io.f90 – swiftest","text":"This file depends on sourcefile~~fraggle_io.f90~~EfferentGraph sourcefile~fraggle_io.f90 fraggle_io.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~fraggle_io.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~fraggle_io.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_fraggle_io Source Code fraggle_io.f90 Source Code submodule ( fraggle_classes ) s_fraggle_io use swiftest contains module subroutine fraggle_io_log_generate ( frag ) !! author: David A. Minton !! !! Writes a log of the results of the fragment generation implicit none ! Arguments class ( fraggle_fragments ), intent ( in ) :: frag ! Internals integer ( I4B ) :: i character ( STRMAX ) :: errmsg character ( len =* ), parameter :: fmtlabel = \"(A14,10(ES11.4,1X,:))\" open ( unit = FRAGGLE_LOG_UNIT , file = FRAGGLE_LOG_OUT , status = 'OLD' , position = 'APPEND' , form = 'FORMATTED' , err = 667 , iomsg = errmsg ) write ( FRAGGLE_LOG_UNIT , * , err = 667 , iomsg = errmsg ) write ( FRAGGLE_LOG_UNIT , * ) \"--------------------------------------------------------------------\" write ( FRAGGLE_LOG_UNIT , * ) \"           Fraggle fragment generation results\" write ( FRAGGLE_LOG_UNIT , * ) \"--------------------------------------------------------------------\" write ( FRAGGLE_LOG_UNIT , \"(' dL_tot should be very small' )\" ) write ( FRAGGLE_LOG_UNIT , fmtlabel ) ' dL_tot      |' , (. mag .( frag % Ltot_after (:) - frag % Ltot_before (:))) / (. mag . frag % Ltot_before (:)) write ( FRAGGLE_LOG_UNIT , \"(' dE_tot should be negative and equal to Qloss' )\" ) write ( FRAGGLE_LOG_UNIT , fmtlabel ) ' dE_tot      |' , ( frag % Etot_after - frag % Etot_before ) / abs ( frag % Etot_before ) write ( FRAGGLE_LOG_UNIT , fmtlabel ) ' Qloss       |' , - frag % Qloss / abs ( frag % Etot_before ) write ( FRAGGLE_LOG_UNIT , fmtlabel ) ' dE - Qloss  |' , ( frag % Etot_after - frag % Etot_before + frag % Qloss ) / abs ( frag % Etot_before ) write ( FRAGGLE_LOG_UNIT , \"(' -------------------------------------------------------------------------------------')\" ) write ( FRAGGLE_LOG_UNIT , * ) \"Individual fragment values (collisional system natural units)\" write ( FRAGGLE_LOG_UNIT , * ) \"mass\" do i = 1 , frag % nbody write ( FRAGGLE_LOG_UNIT , * ) i , frag % mass ( i ) end do write ( FRAGGLE_LOG_UNIT , * ) \"x_coll\" do i = 1 , frag % nbody write ( FRAGGLE_LOG_UNIT , * ) i , frag % x_coll (:, i ) end do write ( FRAGGLE_LOG_UNIT , * ) \"v_coll\" do i = 1 , frag % nbody write ( FRAGGLE_LOG_UNIT , * ) i , frag % v_coll (:, i ) end do write ( FRAGGLE_LOG_UNIT , * ) \"xb\" do i = 1 , frag % nbody write ( FRAGGLE_LOG_UNIT , * ) i , frag % xb (:, i ) end do write ( FRAGGLE_LOG_UNIT , * ) \"vb\" do i = 1 , frag % nbody write ( FRAGGLE_LOG_UNIT , * ) i , frag % vb (:, i ) end do write ( FRAGGLE_LOG_UNIT , * ) \"rot\" do i = 1 , frag % nbody write ( FRAGGLE_LOG_UNIT , * ) i , frag % rot (:, i ) end do close ( FRAGGLE_LOG_UNIT ) return 667 continue write ( * , * ) \"Error writing Fraggle message to log file: \" // trim ( adjustl ( errmsg )) end subroutine fraggle_io_log_generate module subroutine fraggle_io_log_one_message ( message ) !! author: David A. Minton !! !! Writes a single message to the fraggle log file implicit none ! Arguments character ( len =* ), intent ( in ) :: message ! Internals character ( STRMAX ) :: errmsg open ( unit = FRAGGLE_LOG_UNIT , file = FRAGGLE_LOG_OUT , status = 'OLD' , position = 'APPEND' , form = 'FORMATTED' , err = 667 , iomsg = errmsg ) write ( FRAGGLE_LOG_UNIT , * ) trim ( adjustl ( message )) close ( FRAGGLE_LOG_UNIT ) return 667 continue write ( * , * ) \"Error writing Fraggle message to log file: \" // trim ( adjustl ( errmsg )) end subroutine fraggle_io_log_one_message module subroutine fraggle_io_log_pl ( pl , param ) !! author: David A. Minton !! !! Writes a single message to the fraggle log file implicit none ! Arguments class ( swiftest_pl ), intent ( in ) :: pl !! Swiftest massive body object (only the new bodies generated in a collision) class ( swiftest_parameters ), intent ( in ) :: param !! Current swiftest run configuration parameters ! Internals integer ( I4B ) :: i character ( STRMAX ) :: errmsg open ( unit = FRAGGLE_LOG_UNIT , file = FRAGGLE_LOG_OUT , status = 'OLD' , position = 'APPEND' , form = 'FORMATTED' , err = 667 , iomsg = errmsg ) write ( FRAGGLE_LOG_UNIT , * , err = 667 , iomsg = errmsg ) write ( FRAGGLE_LOG_UNIT , * ) \"--------------------------------------------------------------------\" write ( FRAGGLE_LOG_UNIT , * ) \"           Fraggle fragment final body properties\" write ( FRAGGLE_LOG_UNIT , * ) \"--------------------------------------------------------------------\" write ( FRAGGLE_LOG_UNIT , * ) \"id, name\" do i = 1 , pl % nbody write ( FRAGGLE_LOG_UNIT , * ) i , pl % id ( i ), pl % info ( i )% name end do write ( FRAGGLE_LOG_UNIT , * ) \"mass, Gmass\" do i = 1 , pl % nbody write ( FRAGGLE_LOG_UNIT , * ) i , pl % mass ( i ), pl % Gmass ( i ) end do write ( FRAGGLE_LOG_UNIT , * ) \"radius\" do i = 1 , pl % nbody write ( FRAGGLE_LOG_UNIT , * ) i , pl % radius ( i ) end do write ( FRAGGLE_LOG_UNIT , * ) \"xb\" do i = 1 , pl % nbody write ( FRAGGLE_LOG_UNIT , * ) i , pl % xb (:, i ) end do write ( FRAGGLE_LOG_UNIT , * ) \"vb\" do i = 1 , pl % nbody write ( FRAGGLE_LOG_UNIT , * ) i , pl % vb (:, i ) end do write ( FRAGGLE_LOG_UNIT , * ) \"xh\" do i = 1 , pl % nbody write ( FRAGGLE_LOG_UNIT , * ) i , pl % xh (:, i ) end do write ( FRAGGLE_LOG_UNIT , * ) \"vh\" do i = 1 , pl % nbody write ( FRAGGLE_LOG_UNIT , * ) i , pl % vh (:, i ) end do if ( param % lrotation ) then write ( FRAGGLE_LOG_UNIT , * ) \"rot\" do i = 1 , pl % nbody write ( FRAGGLE_LOG_UNIT , * ) i , pl % rot (:, i ) end do write ( FRAGGLE_LOG_UNIT , * ) \"Ip\" do i = 1 , pl % nbody write ( FRAGGLE_LOG_UNIT , * ) i , pl % Ip (:, i ) end do end if if ( param % ltides ) then write ( FRAGGLE_LOG_UNIT , * ) \"Q\" do i = 1 , pl % nbody write ( FRAGGLE_LOG_UNIT , * ) i , pl % Q ( i ) end do write ( FRAGGLE_LOG_UNIT , * ) \"k2\" do i = 1 , pl % nbody write ( FRAGGLE_LOG_UNIT , * ) i , pl % k2 ( i ) end do write ( FRAGGLE_LOG_UNIT , * ) \"tlag\" do i = 1 , pl % nbody write ( FRAGGLE_LOG_UNIT , * ) i , pl % tlag ( i ) end do end if close ( FRAGGLE_LOG_UNIT ) return 667 continue write ( * , * ) \"Error writing Fraggle message to log file: \" // trim ( adjustl ( errmsg )) end subroutine fraggle_io_log_pl module subroutine fraggle_io_log_regime ( colliders , frag ) !! author: David A. Minton !! !! Writes a log of the results of the collisional regime determination implicit none ! Arguments class ( fraggle_colliders ), intent ( in ) :: colliders !! Fraggle collider system object class ( fraggle_fragments ), intent ( in ) :: frag !! Fraggle fragment object ! Internals character ( STRMAX ) :: errmsg open ( unit = FRAGGLE_LOG_UNIT , file = FRAGGLE_LOG_OUT , status = 'OLD' , position = 'APPEND' , form = 'FORMATTED' , err = 667 , iomsg = errmsg ) write ( FRAGGLE_LOG_UNIT , * , err = 667 , iomsg = errmsg ) write ( FRAGGLE_LOG_UNIT , * ) \"--------------------------------------------------------------------\" write ( FRAGGLE_LOG_UNIT , * ) \"           Fraggle collisional regime determination results\" write ( FRAGGLE_LOG_UNIT , * ) \"--------------------------------------------------------------------\" write ( FRAGGLE_LOG_UNIT , * ) \"----------------------- Collider information -----------------------\" write ( FRAGGLE_LOG_UNIT , * ) \"True number of colliders : \" , colliders % ncoll write ( FRAGGLE_LOG_UNIT , * ) \"Index list of true colliders  : \" , colliders % idx ( 1 : colliders % ncoll ) write ( FRAGGLE_LOG_UNIT , * ) \"-------------------- Two-body equialent values ---------------------\" write ( FRAGGLE_LOG_UNIT , * ) \"mass1    : \" , colliders % mass ( 1 ) write ( FRAGGLE_LOG_UNIT , * ) \"radius1  : \" , colliders % radius ( 1 ) write ( FRAGGLE_LOG_UNIT , * ) \"xb1      : \" , colliders % xb (:, 1 ) write ( FRAGGLE_LOG_UNIT , * ) \"vb1      : \" , colliders % vb (:, 1 ) write ( FRAGGLE_LOG_UNIT , * ) \"rot1     : \" , colliders % rot (:, 1 ) write ( FRAGGLE_LOG_UNIT , * ) \"Ip1      : \" , colliders % Ip (:, 1 ) write ( FRAGGLE_LOG_UNIT , * ) \"L_spin1  : \" , colliders % L_spin (:, 1 ) write ( FRAGGLE_LOG_UNIT , * ) \"L_orbit1 : \" , colliders % L_orbit (:, 1 ) write ( FRAGGLE_LOG_UNIT , * ) \"mass2    : \" , colliders % mass ( 2 ) write ( FRAGGLE_LOG_UNIT , * ) \"radius2  : \" , colliders % radius ( 2 ) write ( FRAGGLE_LOG_UNIT , * ) \"xb2      : \" , colliders % xb (:, 2 ) write ( FRAGGLE_LOG_UNIT , * ) \"vb2      : \" , colliders % vb (:, 2 ) write ( FRAGGLE_LOG_UNIT , * ) \"rot2     : \" , colliders % rot (:, 2 ) write ( FRAGGLE_LOG_UNIT , * ) \"Ip2      : \" , colliders % Ip (:, 2 ) write ( FRAGGLE_LOG_UNIT , * ) \"L_spin2  : \" , colliders % L_spin (:, 2 ) write ( FRAGGLE_LOG_UNIT , * ) \"L_orbit2 : \" , colliders % L_orbit (:, 2 ) write ( FRAGGLE_LOG_UNIT , * ) \"------------------------------ Regime -----------------------------\" select case ( frag % regime ) case ( COLLRESOLVE_REGIME_MERGE ) write ( FRAGGLE_LOG_UNIT , * ) \"Merge\" case ( COLLRESOLVE_REGIME_DISRUPTION ) write ( FRAGGLE_LOG_UNIT , * ) \"Disruption\" case ( COLLRESOLVE_REGIME_SUPERCATASTROPHIC ) write ( FRAGGLE_LOG_UNIT , * ) \"Supercatastrophic disruption\" case ( COLLRESOLVE_REGIME_GRAZE_AND_MERGE ) write ( FRAGGLE_LOG_UNIT , * ) \"Graze and merge\" case ( COLLRESOLVE_REGIME_HIT_AND_RUN ) write ( FRAGGLE_LOG_UNIT , * ) \"Hit and run\" end select write ( FRAGGLE_LOG_UNIT , * ) \"----------------------- Fragment information ----------------------\" write ( FRAGGLE_LOG_UNIT , * ) \"Total mass of fragments      : \" , frag % mtot write ( FRAGGLE_LOG_UNIT , * ) \"Largest fragment mass        : \" , frag % mass_dist ( 1 ) write ( FRAGGLE_LOG_UNIT , * ) \"Second-largest fragment mass : \" , frag % mass_dist ( 2 ) write ( FRAGGLE_LOG_UNIT , * ) \"Remaining fragment mass      : \" , frag % mass_dist ( 3 ) write ( FRAGGLE_LOG_UNIT , * ) \"Center of mass position      : \" , frag % xbcom (:) write ( FRAGGLE_LOG_UNIT , * ) \"Center of mass velocity      : \" , frag % vbcom (:) write ( FRAGGLE_LOG_UNIT , * ) \"Energy loss                  : \" , frag % Qloss write ( FRAGGLE_LOG_UNIT , * ) \"--------------------------------------------------------------------\" close ( FRAGGLE_LOG_UNIT ) return 667 continue write ( * , * ) \"Error writing Fraggle regime information to log file: \" // trim ( adjustl ( errmsg )) end subroutine fraggle_io_log_regime module subroutine fraggle_io_log_start ( param ) !! author: David A. Minton !! !! Checks to see if the Fraggle log file needs to be replaced if this is a new run, or appended if this is a restarted run implicit none ! Arguments class ( swiftest_parameters ), intent ( in ) :: param ! Internals character ( STRMAX ) :: errmsg logical :: fileExists inquire ( file = FRAGGLE_LOG_OUT , exist = fileExists ) if (. not . param % lrestart . or . . not . fileExists ) then open ( unit = FRAGGLE_LOG_UNIT , file = FRAGGLE_LOG_OUT , status = \"REPLACE\" , err = 667 , iomsg = errmsg ) write ( FRAGGLE_LOG_UNIT , * , err = 667 , iomsg = errmsg ) \"Fraggle logfile\" end if close ( FRAGGLE_LOG_UNIT ) return 667 continue write ( * , * ) \"Error writing Fraggle log file: \" // trim ( adjustl ( errmsg )) end subroutine fraggle_io_log_start end submodule s_fraggle_io","tags":"","loc":"sourcefile/fraggle_io.f90.html"},{"title":"fraggle_generate.f90 – swiftest","text":"This file depends on sourcefile~~fraggle_generate.f90~~EfferentGraph sourcefile~fraggle_generate.f90 fraggle_generate.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~fraggle_generate.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~fraggle_generate.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_fraggle_generate Source Code fraggle_generate.f90 Source Code submodule ( fraggle_classes ) s_fraggle_generate use swiftest integer ( I4B ), parameter :: NFRAG_MIN = 7 !! The minimum allowable number of fragments (set to 6 because that's how many unknowns are needed in the tangential velocity calculation) real ( DP ), parameter :: F_SPIN_FIRST = 0.05_DP !! The initial try value of the fraction of energy or momenum in spin (whichever has the lowest kinetic energy) real ( DP ), parameter :: FRAGGLE_LTOL = 10 * epsilon ( 1.0_DP ) real ( DP ), parameter :: FRAGGLE_ETOL = 1e-8_DP contains module subroutine fraggle_generate_fragments ( self , colliders , system , param , lfailure ) !! Author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Generates a system of fragments in barycentric coordinates that conserves energy and momentum. use , intrinsic :: ieee_exceptions implicit none ! Arguments class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle system object the outputs will be the fragmentation class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle colliders object containing the two-body equivalent values of the colliding bodies class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters logical , intent ( out ) :: lfailure !! Answers the question: Should this have been a merger instead? ! Internals integer ( I4B ) :: i integer ( I4B ) :: try real ( DP ) :: r_max_start , f_spin , dEtot , dLmag integer ( I4B ), parameter :: MAXTRY = 100 logical :: lk_plpl logical , dimension ( size ( IEEE_ALL )) :: fpe_halting_modes , fpe_quiet_modes logical , dimension ( size ( IEEE_USUAL )) :: fpe_flag character ( len = STRMAX ) :: message ! The minimization and linear solvers can sometimes lead to floating point exceptions. Rather than halting the code entirely if this occurs, we ! can simply fail the attempt and try again. So we need to turn off any floating point exception halting modes temporarily call ieee_get_halting_mode ( IEEE_ALL , fpe_halting_modes ) ! Save the current halting modes so we can turn them off temporarily fpe_quiet_modes (:) = . false . call ieee_set_halting_mode ( IEEE_ALL , fpe_quiet_modes ) associate ( frag => self , nfrag => self % nbody , pl => system % pl ) write ( message , * ) nfrag call fraggle_io_log_one_message ( \"Fraggle generating \" // trim ( adjustl ( message )) // \" fragments.\" ) if ( nfrag < NFRAG_MIN ) then write ( message , * ) \"Fraggle needs at least \" , NFRAG_MIN , \" fragments, but only \" , nfrag , \" were given.\" call fraggle_io_log_one_message ( message ) lfailure = . true . return end if f_spin = F_SPIN_FIRST lk_plpl = allocated ( pl % k_plpl ) if ( lk_plpl ) deallocate ( pl % k_plpl ) call frag % set_natural_scale ( colliders ) call frag % reset () ! Calculate the initial energy of the system without the collisional family call frag % get_energy_and_momentum ( colliders , system , param , lbefore = . true .) ! Start out the fragments close to the initial separation distance. This will be increased if there is any overlap or we fail to find a solution r_max_start = 1 * norm2 ( colliders % xb (:, 2 ) - colliders % xb (:, 1 )) lfailure = . false . try = 1 do while ( try < MAXTRY ) write ( message , * ) try call fraggle_io_log_one_message ( \"Fraggle try \" // trim ( adjustl ( message ))) if ( lfailure ) then call frag % restructure ( colliders , try , f_spin , r_max_start ) call frag % reset () try = try + 1 end if lfailure = . false . call ieee_set_flag ( ieee_all , . false .) ! Set all fpe flags to quiet call fraggle_generate_pos_vec ( frag , colliders , r_max_start ) call frag % set_coordinate_system ( colliders ) ! Initial velocity guess will be the barycentric velocity of the colliding system so that the budgets are based on the much smaller collisional-frame velocities do concurrent ( i = 1 : nfrag ) frag % vb (:, i ) = frag % vbcom (:) end do call frag % get_energy_and_momentum ( colliders , system , param , lbefore = . false .) call frag % set_budgets ( colliders ) call fraggle_generate_spins ( frag , colliders , f_spin , lfailure ) if ( lfailure ) then call fraggle_io_log_one_message ( \"Fraggle failed to find spins\" ) cycle end if call fraggle_generate_tan_vel ( frag , colliders , lfailure ) if ( lfailure ) then call fraggle_io_log_one_message ( \"Fraggle failed to find tangential velocities\" ) cycle end if call fraggle_generate_rad_vel ( frag , colliders , lfailure ) if ( lfailure ) then call fraggle_io_log_one_message ( \"Fraggle failed to find radial velocities\" ) cycle end if call frag % get_energy_and_momentum ( colliders , system , param , lbefore = . false .) dEtot = frag % Etot_after - frag % Etot_before dLmag = . mag . ( frag % Ltot_after (:) - frag % Ltot_before (:)) lfailure = (( abs ( dEtot + frag % Qloss ) > FRAGGLE_ETOL ) . or . ( dEtot > 0.0_DP )) if ( lfailure ) then write ( message , * ) dEtot , abs ( dEtot + frag % Qloss ) / FRAGGLE_ETOL call fraggle_io_log_one_message ( \"Fraggle failed due to high energy error: \" // trim ( adjustl ( message ))) cycle end if lfailure = (( abs ( dLmag ) / (. mag . frag % Ltot_before )) > FRAGGLE_LTOL ) if ( lfailure ) then write ( message , * ) dLmag / (. mag . frag % Ltot_before (:)) call fraggle_io_log_one_message ( \"Fraggle failed due to high angular momentum error: \" // trim ( adjustl ( message ))) cycle end if ! Check if any of the usual floating point exceptions happened, and fail the try if so call ieee_get_flag ( ieee_usual , fpe_flag ) lfailure = any ( fpe_flag ) if (. not . lfailure ) exit write ( message , * ) \"Fraggle failed due to a floating point exception: \" , fpe_flag call fraggle_io_log_one_message ( message ) end do write ( message , * ) try if ( lfailure ) then call fraggle_io_log_one_message ( \"Fraggle fragment generation failed after \" // trim ( adjustl ( message )) // \" tries\" ) else call fraggle_io_log_one_message ( \"Fraggle fragment generation succeeded after \" // trim ( adjustl ( message )) // \" tries\" ) call fraggle_io_log_generate ( frag ) end if call frag % set_original_scale ( colliders ) ! Restore the big array if ( lk_plpl ) call pl % index ( param ) end associate call ieee_set_halting_mode ( IEEE_ALL , fpe_halting_modes ) ! Save the current halting modes so we can turn them off temporarily return end subroutine fraggle_generate_fragments subroutine fraggle_generate_pos_vec ( frag , colliders , r_max_start ) !! Author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Initializes the orbits of the fragments around the center of mass. The fragments are initially placed on a plane defined by the !! pre-impact angular momentum. They are distributed on an ellipse surrounding the center of mass. !! The initial positions do not conserve energy or momentum, so these need to be adjusted later. implicit none ! Arguments class ( fraggle_fragments ), intent ( inout ) :: frag !! Fraggle fragment system object class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle collider system object real ( DP ), intent ( in ) :: r_max_start !! Initial guess for the starting maximum radial distance of fragments ! Internals real ( DP ) :: dis , rad , r_max logical , dimension (:), allocatable :: loverlap integer ( I4B ) :: i , j associate ( nfrag => frag % nbody ) allocate ( loverlap ( nfrag )) ! Place the fragments into a region that is big enough that we should usually not have overlapping bodies ! An overlapping bodies will collide in the next time step, so it's not a major problem if they do (it just slows the run down) r_max = r_max_start rad = sum ( colliders % radius (:)) ! We will treat the first two fragments of the list as special cases. They get initialized the maximum distances apart along the original impactor distance vector. ! This is done because in a regular disruption, the first body is the largest, the second the second largest, and the rest are smaller equal-mass fragments. call random_number ( frag % x_coll (:, 3 : nfrag )) loverlap (:) = . true . do while ( any ( loverlap ( 3 : nfrag ))) frag % x_coll (:, 1 ) = colliders % xb (:, 1 ) - frag % xbcom (:) frag % x_coll (:, 2 ) = colliders % xb (:, 2 ) - frag % xbcom (:) r_max = r_max + 0.1_DP * rad do i = 3 , nfrag if ( loverlap ( i )) then call random_number ( frag % x_coll (:, i )) frag % x_coll (:, i ) = 2 * ( frag % x_coll (:, i ) - 0.5_DP ) * r_max end if end do loverlap (:) = . false . do j = 1 , nfrag do i = j + 1 , nfrag dis = norm2 ( frag % x_coll (:, j ) - frag % x_coll (:, i )) loverlap ( i ) = loverlap ( i ) . or . ( dis <= ( frag % radius ( i ) + frag % radius ( j ))) end do end do end do call fraggle_util_shift_vector_to_origin ( frag % mass , frag % x_coll ) call frag % set_coordinate_system ( colliders ) do i = 1 , nfrag frag % xb (:, i ) = frag % x_coll (:, i ) + frag % xbcom (:) end do frag % xbcom (:) = 0.0_DP do i = 1 , nfrag frag % xbcom (:) = frag % xbcom (:) + frag % mass ( i ) * frag % xb (:, i ) end do frag % xbcom (:) = frag % xbcom (:) / frag % mtot end associate return end subroutine fraggle_generate_pos_vec subroutine fraggle_generate_spins ( frag , colliders , f_spin , lfailure ) !! Author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Calculates the spins of a collection of fragments such that they conserve angular momentum without blowing the fragment kinetic energy budget. !! !! A failure will trigger a restructuring of the fragments so we will try new values of the radial position distribution. implicit none ! Arguments class ( fraggle_fragments ), intent ( inout ) :: frag !! Fraggle fragment system object class ( fraggle_colliders ), intent ( in ) :: colliders !! Fraggle collider system object real ( DP ), intent ( in ) :: f_spin !! Fraction of energy or momentum that goes into spin (whichever gives the lowest kinetic energy) logical , intent ( out ) :: lfailure !! Logical flag indicating whether this step fails or succeeds! ! Internals real ( DP ), dimension ( NDIM ) :: L_remainder , rot_L , rot_ke integer ( I4B ) :: i character ( len = STRMAX ) :: message associate ( nfrag => frag % nbody ) lfailure = . false . ! Start the first two bodies with the same rotation as the original two impactors, then distribute the remaining angular momentum among the rest L_remainder (:) = frag % L_budget (:) frag % rot (:,:) = 0.0_DP frag % ke_spin = 0.0_DP do i = 1 , nfrag ! Convert a fraction (f_spin) of either the remaining angular momentum or kinetic energy budget into spin, whichever gives the smaller rotation so as not to blow any budgets rot_ke (:) = sqrt ( 2 * f_spin * frag % ke_budget / ( nfrag * frag % mass ( i ) * frag % radius ( i ) ** 2 * frag % Ip ( 3 , i ))) * L_remainder (:) / norm2 ( L_remainder (:)) rot_L (:) = f_spin * L_remainder (:) / ( nfrag * frag % mass ( i ) * frag % radius ( i ) ** 2 * frag % Ip ( 3 , i )) if ( norm2 ( rot_ke ) < norm2 ( rot_L )) then frag % rot (:, i ) = rot_ke (:) else frag % rot (:, i ) = rot_L (:) end if frag % ke_spin = frag % ke_spin + frag % mass ( i ) * frag % Ip ( 3 , i ) * frag % radius ( i ) ** 2 * dot_product ( frag % rot (:, i ), frag % rot (:, i )) end do frag % ke_spin = 0.5_DP * frag % ke_spin lfailure = (( frag % ke_budget - frag % ke_spin - frag % ke_orbit ) < 0.0_DP ) if ( lfailure ) then call fraggle_io_log_one_message ( \" \" ) call fraggle_io_log_one_message ( \"Spin failure diagnostics\" ) write ( message , * ) frag % ke_budget call fraggle_io_log_one_message ( \"ke_budget     : \" // trim ( adjustl ( message ))) write ( message , * ) frag % ke_spin call fraggle_io_log_one_message ( \"ke_spin       : \" // trim ( adjustl ( message ))) write ( message , * ) frag % ke_orbit call fraggle_io_log_one_message ( \"ke_orbit      : \" // trim ( adjustl ( message ))) write ( message , * ) frag % ke_budget - frag % ke_spin - frag % ke_orbit call fraggle_io_log_one_message ( \"ke_remainder  : \" // trim ( adjustl ( message ))) end if end associate return end subroutine fraggle_generate_spins subroutine fraggle_generate_tan_vel ( frag , colliders , lfailure ) !! Author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Adjusts the tangential velocities and spins of a collection of fragments such that they conserve angular momentum without blowing the fragment kinetic energy budget. !! This procedure works in several stages, with a goal to solve the angular and linear momentum constraints on the fragments, while still leaving a positive balance of !! our fragment kinetic energy (frag%ke_budget) that we can put into the radial velocity distribution. !! !! The first thing we'll try to do is solve for the tangential velocities of the first 6 fragments, using angular and linear momentum as constraints and an initial !! tangential velocity distribution for the remaining bodies (if there are any) that distributes their angular momentum equally between them. !! If that doesn't work and we blow our kinetic energy budget, we will attempt to find a tangential velocity distribution that minimizes the kinetic energy while !! conserving momentum. !! !! A failure will trigger a restructuring of the fragments so we will try new values of the radial position distribution. implicit none ! Arguments class ( fraggle_fragments ), intent ( inout ) :: frag !! Fraggle fragment system object class ( fraggle_colliders ), intent ( in ) :: colliders !! Fraggle collider system object logical , intent ( out ) :: lfailure !! Logical flag indicating whether this step fails or succeeds ! Internals integer ( I4B ) :: i real ( DP ), parameter :: TOL_MIN = 1e-1_DP ! This doesn't have to be very accurate, as we really just want a tangential velocity distribution with less kinetic energy than our initial guess. real ( DP ), parameter :: TOL_INIT = 1e-14_DP real ( DP ), parameter :: VNOISE_MAG = 1e-3_DP !! Magnitude of the noise to apply to initial conditions to help minimizer find a solution in case of failure integer ( I4B ), parameter :: MAXLOOP = 10 real ( DP ) :: tol , ke_remainder real ( DP ), dimension (:), allocatable :: v_t_initial real ( DP ), dimension ( frag % nbody ) :: kefrag , vnoise type ( lambda_obj ) :: spinfunc type ( lambda_obj_err ) :: objective_function real ( DP ), dimension ( NDIM ) :: Li , L_remainder , L_frag_tot character ( len = STRMAX ) :: message associate ( nfrag => frag % nbody ) lfailure = . false . allocate ( v_t_initial , mold = frag % v_t_mag ) v_t_initial (:) = 0.0_DP frag % v_coll (:,:) = 0.0_DP ! Next we will solve for the tangential component of the velocities that both conserves linear momentum and uses the remaining angular momentum not used in spin. ! This will be done using a linear solver that solves for the tangential velocities of the first 6 fragments, constrained by the linear and angular momentum vectors, ! which is embedded in a non-linear minimizer that will adjust the tangential velocities of the remaining i>6 fragments to minimize kinetic energy for a given momentum solution ! The initial conditions fed to the minimizer for the fragments will be the remaining angular momentum distributed between the fragments. call frag % get_ang_mtm () L_remainder (:) = frag % L_budget (:) - frag % L_spin (:) do i = 1 , nfrag v_t_initial ( i ) = norm2 ( L_remainder (:)) / (( nfrag - i + 1 ) * frag % mass ( i ) * norm2 ( frag % x_coll (:, i ))) Li (:) = frag % mass ( i ) * ( frag % x_coll (:, i ) . cross . ( v_t_initial ( i ) * frag % v_t_unit (:, i ))) L_remainder (:) = L_remainder (:) - Li (:) end do ! Find the local kinetic energy minimum for the system that conserves linear and angular momentum objective_function = lambda_obj ( tangential_objective_function , lfailure ) tol = TOL_INIT do while ( tol < TOL_MIN ) frag % v_t_mag ( 7 : nfrag ) = util_minimize_bfgs ( objective_function , nfrag - 6 , v_t_initial ( 7 : nfrag ), tol , MAXLOOP , lfailure ) ! Now that the KE-minimized values of the i>6 fragments are found, calculate the momentum-conserving solution for tangential velociteis v_t_initial ( 7 : nfrag ) = frag % v_t_mag ( 7 : nfrag ) if (. not . lfailure ) exit tol = tol * 2_DP ! Keep increasing the tolerance until we converge on a solution call random_number ( vnoise ( 1 : nfrag )) ! Adding a bit of noise to the initial conditions helps it find a solution more often vnoise (:) = 1.0_DP + VNOISE_MAG * ( 2 * vnoise (:) - 1._DP ) v_t_initial (:) = v_t_initial (:) * vnoise (:) end do frag % v_t_mag ( 1 : nfrag ) = solve_fragment_tan_vel ( v_t_mag_input = v_t_initial ( 7 : nfrag ), lfailure = lfailure ) ! Perform one final shift of the radial velocity vectors to align with the center of mass of the collisional system (the origin) frag % vb (:, 1 : nfrag ) = fraggle_util_vmag_to_vb ( frag % v_r_mag ( 1 : nfrag ), frag % v_r_unit (:, 1 : nfrag ), frag % v_t_mag ( 1 : nfrag ), frag % v_t_unit (:, 1 : nfrag ), frag % mass ( 1 : nfrag ), frag % vbcom (:)) do concurrent ( i = 1 : nfrag ) frag % v_coll (:, i ) = frag % vb (:, i ) - frag % vbcom (:) end do ! Now do a kinetic energy budget check to make sure we are still within the budget. kefrag = 0.0_DP do concurrent ( i = 1 : nfrag ) kefrag ( i ) = frag % mass ( i ) * dot_product ( frag % vb (:, i ), frag % vb (:, i )) end do frag % ke_orbit = 0.5_DP * sum ( kefrag (:)) ! If we are over the energy budget, flag this as a failure so we can try again lfailure = (( frag % ke_budget - frag % ke_spin - frag % ke_orbit ) < 0.0_DP ) if ( lfailure ) then call fraggle_io_log_one_message ( \" \" ) call fraggle_io_log_one_message ( \"Tangential velocity failure diagnostics\" ) call frag % get_ang_mtm () L_frag_tot = frag % L_spin (:) + frag % L_orbit (:) write ( message , * ) . mag .( frag % L_budget (:) - L_frag_tot (:)) / (. mag . frag % Ltot_before (:)) call fraggle_io_log_one_message ( \"|L_remainder| : \" // trim ( adjustl ( message ))) write ( message , * ) frag % ke_budget call fraggle_io_log_one_message ( \"ke_budget     : \" // trim ( adjustl ( message ))) write ( message , * ) frag % ke_spin call fraggle_io_log_one_message ( \"ke_spin       : \" // trim ( adjustl ( message ))) write ( message , * ) frag % ke_orbit call fraggle_io_log_one_message ( \"ke_tangential : \" // trim ( adjustl ( message ))) write ( message , * ) frag % ke_budget - frag % ke_spin - frag % ke_orbit call fraggle_io_log_one_message ( \"ke_radial     : \" // trim ( adjustl ( message ))) end if end associate return contains function solve_fragment_tan_vel ( lfailure , v_t_mag_input ) result ( v_t_mag_output ) !! Author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Adjusts the positions, velocities, and spins of a collection of fragments such that they conserve angular momentum implicit none ! Arguments logical , intent ( out ) :: lfailure !! Error flag real ( DP ), dimension (:), optional , intent ( in ) :: v_t_mag_input !! Unknown tangential velocities for fragments 7:nfrag ! Internals integer ( I4B ) :: i ! Result real ( DP ), dimension (:), allocatable :: v_t_mag_output real ( DP ), dimension ( 2 * NDIM , 2 * NDIM ) :: A ! LHS of linear equation used to solve for momentum constraint in Gauss elimination code real ( DP ), dimension ( 2 * NDIM ) :: b ! RHS of linear equation used to solve for momentum constraint in Gauss elimination code real ( DP ), dimension ( NDIM ) :: L_lin_others , L_orb_others , L , vtmp associate ( nfrag => frag % nbody ) lfailure = . false . ! We have 6 constraint equations (2 vector constraints in 3 dimensions each) ! The first 3 are that the linear momentum of the fragments is zero with respect to the collisional barycenter ! The second 3 are that the sum of the angular momentum of the fragments is conserved from the pre-impact state L_lin_others (:) = 0.0_DP L_orb_others (:) = 0.0_DP do i = 1 , nfrag if ( i <= 2 * NDIM ) then ! The tangential velocities of the first set of bodies will be the unknowns we will solve for to satisfy the constraints A ( 1 : 3 , i ) = frag % mass ( i ) * frag % v_t_unit (:, i ) A ( 4 : 6 , i ) = frag % mass ( i ) * frag % rmag ( i ) * ( frag % v_r_unit (:, i ) . cross . frag % v_t_unit (:, i )) else if ( present ( v_t_mag_input )) then vtmp (:) = v_t_mag_input ( i - 6 ) * frag % v_t_unit (:, i ) L_lin_others (:) = L_lin_others (:) + frag % mass ( i ) * vtmp (:) L (:) = frag % mass ( i ) * ( frag % x_coll (:, i ) . cross . vtmp (:)) L_orb_others (:) = L_orb_others (:) + L (:) end if end do b ( 1 : 3 ) = - L_lin_others (:) b ( 4 : 6 ) = frag % L_budget (:) - frag % L_spin (:) - L_orb_others (:) allocate ( v_t_mag_output ( nfrag )) v_t_mag_output ( 1 : 6 ) = util_solve_linear_system ( A , b , 6 , lfailure ) if ( present ( v_t_mag_input )) v_t_mag_output ( 7 : nfrag ) = v_t_mag_input (:) end associate return end function solve_fragment_tan_vel function tangential_objective_function ( v_t_mag_input , lfailure ) result ( fval ) !! Author: David A. Minton !! !! Objective function for evaluating how close our fragment velocities get to minimizing KE error from our required value implicit none ! Arguments real ( DP ), dimension (:), intent ( in ) :: v_t_mag_input !! Unknown tangential component of velocity vector set previously by angular momentum constraint logical , intent ( out ) :: lfailure !! Error flag ! Result real ( DP ) :: fval ! Internals integer ( I4B ) :: i real ( DP ), dimension ( NDIM , frag % nbody ) :: v_shift real ( DP ), dimension ( frag % nbody ) :: v_t_new , kearr real ( DP ) :: keo associate ( nfrag => frag % nbody ) lfailure = . false . v_t_new (:) = solve_fragment_tan_vel ( v_t_mag_input = v_t_mag_input (:), lfailure = lfailure ) v_shift (:,:) = fraggle_util_vmag_to_vb ( frag % v_r_mag , frag % v_r_unit , v_t_new , frag % v_t_unit , frag % mass , frag % vbcom ) kearr = 0.0_DP do concurrent ( i = 1 : nfrag ) kearr ( i ) = frag % mass ( i ) * dot_product ( v_shift (:, i ), v_shift (:, i )) end do keo = 0.5_DP * sum ( kearr (:)) fval = keo lfailure = . false . end associate return end function tangential_objective_function end subroutine fraggle_generate_tan_vel subroutine fraggle_generate_rad_vel ( frag , colliders , lfailure ) !! Author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! !! Adjust the fragment velocities to set the fragment orbital kinetic energy. This will minimize the difference between the fragment kinetic energy and the energy budget implicit none ! Arguments class ( fraggle_fragments ), intent ( inout ) :: frag !! Fraggle fragment system object class ( fraggle_colliders ), intent ( in ) :: colliders !! Fraggle collider system object logical , intent ( out ) :: lfailure !! Logical flag indicating whether this step fails or succeeds! ! Internals real ( DP ), parameter :: TOL_MIN = FRAGGLE_ETOL ! This needs to be more accurate than the tangential step, as we are trying to minimize the total residual energy real ( DP ), parameter :: TOL_INIT = 1e-14_DP real ( DP ), parameter :: VNOISE_MAG = 1e-10_DP !! Magnitude of the noise to apply to initial conditions to help minimizer find a solution in case of failure integer ( I4B ), parameter :: MAXLOOP = 100 real ( DP ) :: ke_radial , tol integer ( I4B ) :: i , j real ( DP ), dimension (:), allocatable :: v_r_initial real ( DP ), dimension (:,:), allocatable :: v_r real ( DP ), dimension ( frag % nbody ) :: vnoise type ( lambda_obj ) :: objective_function character ( len = STRMAX ) :: message associate ( nfrag => frag % nbody ) ! Set the \"target\" ke for the radial component ke_radial = frag % ke_budget - frag % ke_spin - frag % ke_orbit allocate ( v_r_initial , source = frag % v_r_mag ) ! Initialize radial velocity magnitudes with a random value that related to equipartition of kinetic energy with some noise call random_number ( vnoise ( 1 : nfrag )) vnoise (:) = 1.0_DP + VNOISE_MAG * ( 2 * vnoise (:) - 1.0_DP ) v_r_initial ( 1 : nfrag ) = sqrt ( abs ( 2 * ke_radial ) / ( frag % mass ( 1 : nfrag ) * nfrag )) * vnoise ( 1 : nfrag ) ! Initialize the lambda function using a structure constructor that calls the init method ! Minimize the ke objective function using the BFGS optimizer objective_function = lambda_obj ( radial_objective_function ) tol = TOL_INIT do while ( tol < TOL_MIN ) frag % v_r_mag = util_minimize_bfgs ( objective_function , nfrag , v_r_initial , tol , MAXLOOP , lfailure ) if (. not . lfailure ) exit tol = tol * 2 ! Keep increasing the tolerance until we converge on a solution v_r_initial (:) = frag % v_r_mag (:) call random_number ( vnoise ( 1 : nfrag )) ! Adding a bit of noise to the initial conditions helps it find a solution more often vnoise (:) = 1.0_DP + VNOISE_MAG * ( 2 * vnoise (:) - 1._DP ) v_r_initial (:) = v_r_initial (:) * vnoise (:) end do ! Shift the radial velocity vectors to align with the center of mass of the collisional system (the origin) frag % ke_orbit = 0.0_DP frag % vb (:, 1 : nfrag ) = fraggle_util_vmag_to_vb ( frag % v_r_mag ( 1 : nfrag ), frag % v_r_unit (:, 1 : nfrag ), frag % v_t_mag ( 1 : nfrag ), frag % v_t_unit (:, 1 : nfrag ), frag % mass ( 1 : nfrag ), frag % vbcom (:)) do i = 1 , nfrag frag % v_coll (:, i ) = frag % vb (:, i ) - frag % vbcom (:) frag % ke_orbit = frag % ke_orbit + frag % mass ( i ) * dot_product ( frag % vb (:, i ), frag % vb (:, i )) end do frag % ke_orbit = 0.5_DP * frag % ke_orbit lfailure = abs (( frag % ke_budget - ( frag % ke_orbit + frag % ke_spin )) / frag % ke_budget ) > FRAGGLE_ETOL if ( lfailure ) then call fraggle_io_log_one_message ( \" \" ) call fraggle_io_log_one_message ( \"Radial velocity failure diagnostics\" ) write ( message , * ) frag % ke_budget call fraggle_io_log_one_message ( \"ke_budget     : \" // trim ( adjustl ( message ))) write ( message , * ) frag % ke_spin call fraggle_io_log_one_message ( \"ke_spin       : \" // trim ( adjustl ( message ))) write ( message , * ) frag % ke_orbit call fraggle_io_log_one_message ( \"ke_orbit : \" // trim ( adjustl ( message ))) write ( message , * ) frag % ke_budget - ( frag % ke_orbit + frag % ke_spin ) call fraggle_io_log_one_message ( \"ke_remainder  : \" // trim ( adjustl ( message ))) end if end associate return contains function radial_objective_function ( v_r_mag_input ) result ( fval ) !! Author: David A. Minton !! !! Objective function for evaluating how close our fragment velocities get to minimizing KE error from our required value implicit none ! Arguments real ( DP ), dimension (:), intent ( in ) :: v_r_mag_input !! Unknown radial component of fragment velocity vector ! Result real ( DP ) :: fval !! The objective function result, which is the square of the difference between the calculated fragment kinetic energy and our target !! Minimizing this brings us closer to our objective ! Internals integer ( I4B ) :: i real ( DP ), dimension (:,:), allocatable :: v_shift real ( DP ), dimension ( frag % nbody ) :: kearr real ( DP ) :: keo , ke_radial , rotmag2 , vmag2 associate ( nfrag => frag % nbody ) allocate ( v_shift , mold = frag % vb ) v_shift (:,:) = fraggle_util_vmag_to_vb ( v_r_mag_input , frag % v_r_unit , frag % v_t_mag , frag % v_t_unit , frag % mass , frag % vbcom ) !$omp do simd do i = 1 , nfrag rotmag2 = frag % rot ( 1 , i ) ** 2 + frag % rot ( 2 , i ) ** 2 + frag % rot ( 3 , i ) ** 2 vmag2 = v_shift ( 1 , i ) ** 2 + v_shift ( 2 , i ) ** 2 + v_shift ( 3 , i ) ** 2 kearr ( i ) = frag % mass ( i ) * ( frag % Ip ( 3 , i ) * frag % radius ( i ) ** 2 * rotmag2 + vmag2 ) end do !$omp end do simd keo = 2 * frag % ke_budget - sum ( kearr (:)) ke_radial = frag % ke_budget - frag % ke_orbit - frag % ke_spin ! The following ensures that fval = 0 is a local minimum, which is what the BFGS method is searching for fval = ( keo / ( 2 * ke_radial )) ** 2 end associate return end function radial_objective_function end subroutine fraggle_generate_rad_vel end submodule s_fraggle_generate","tags":"","loc":"sourcefile/fraggle_generate.f90.html"},{"title":"fraggle_regime.f90 – swiftest","text":"This file depends on sourcefile~~fraggle_regime.f90~~EfferentGraph sourcefile~fraggle_regime.f90 fraggle_regime.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~fraggle_regime.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~fraggle_regime.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_fraggle_regime Source Code fraggle_regime.f90 Source Code submodule ( fraggle_classes ) s_fraggle_regime use swiftest contains module subroutine fraggle_regime_colliders ( self , frag , system , param ) !! Author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Determine which fragmentation regime the set of colliders will be. This subroutine is a wrapper for the non-polymorphic raggle_regime_collresolve subroutine. !! It converts to SI units prior to calling implicit none ! Arguments class ( fraggle_colliders ), intent ( inout ) :: self !! Fraggle colliders object class ( fraggle_fragments ), intent ( inout ) :: frag !! Fraggle fragment system object class ( swiftest_nbody_system ), intent ( in ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current Swiftest run configuration parameters ! Internals integer ( I4B ) :: jtarg , jproj , regime real ( DP ), dimension ( 2 ) :: radius_si , mass_si , density_si real ( DP ) :: min_mfrag_si , Mcb_si real ( DP ), dimension ( NDIM ) :: x1_si , v1_si , x2_si , v2_si real ( DP ) :: mlr , mslr , mtot , dentot , msys , msys_new , Qloss , impact_parameter logical :: fileExists associate ( colliders => self ) ! Convert all quantities to SI units and determine which of the pair is the projectile vs. target before sending them to the regime determination subroutine if ( colliders % mass ( 1 ) > colliders % mass ( 2 )) then jtarg = 1 jproj = 2 else jtarg = 2 jproj = 1 end if mass_si (:) = colliders % mass ([ jtarg , jproj ]) * param % MU2KG !! The two-body equivalent masses of the collider system radius_si (:) = colliders % radius ([ jtarg , jproj ]) * param % DU2M !! The two-body equivalent radii of the collider system density_si (:) = mass_si (:) / ( 4.0_DP / 3._DP * PI * radius_si (:) ** 3 ) !! The two-body equivalent density of the collider system x1_si (:) = colliders % xb (:, jtarg ) * param % DU2M !! The first body of the two-body equivalent position vector the collider system v1_si (:) = colliders % vb (:, jtarg ) * param % DU2M / param % TU2S !! The first body of the two-body equivalent velocity vector the collider system x2_si (:) = colliders % xb (:, jproj ) * param % DU2M !! The second body of the two-body equivalent position vector the collider system v2_si (:) = colliders % vb (:, jproj ) * param % DU2M / param % TU2S !! The second body of the two-body equivalent velocity vector the collider system Mcb_si = system % cb % mass * param % MU2KG !! The central body mass of the system select type ( param ) class is ( symba_parameters ) min_mfrag_si = ( param % min_GMfrag / param % GU ) * param % MU2KG !! The minimum fragment mass to generate. Collider systems that would otherwise generate less massive fragments than this value will be forced to merge instead class default min_mfrag_si = 0.0_DP end select mtot = sum ( mass_si (:)) dentot = sum ( mass_si (:) * density_si (:)) / mtot !! Use the positions and velocities of the parents from indside the step (at collision) to calculate the collisional regime call fraggle_regime_collresolve ( Mcb_si , mass_si ( jtarg ), mass_si ( jproj ), radius_si ( jtarg ), radius_si ( jproj ), x1_si (:), x2_si (:),& v1_si (:), v2_si (:), density_si ( jtarg ), density_si ( jproj ), min_mfrag_si , frag % regime , mlr , mslr , frag % Qloss ) frag % mass_dist ( 1 ) = min ( max ( mlr , 0.0_DP ), mtot ) frag % mass_dist ( 2 ) = min ( max ( mslr , 0.0_DP ), mtot ) frag % mass_dist ( 3 ) = min ( max ( mtot - mlr - mslr , 0.0_DP ), mtot ) ! Find the center of mass of the collisional system frag % mtot = sum ( colliders % mass (:)) frag % xbcom (:) = ( colliders % mass ( 1 ) * colliders % xb (:, 1 ) + colliders % mass ( 2 ) * colliders % xb (:, 2 )) / frag % mtot frag % vbcom (:) = ( colliders % mass ( 1 ) * colliders % vb (:, 1 ) + colliders % mass ( 2 ) * colliders % vb (:, 2 )) / frag % mtot ! Convert quantities back to the system units and save them into the fragment system frag % mass_dist (:) = ( frag % mass_dist (:) / param % MU2KG ) frag % Qloss = frag % Qloss * ( param % TU2S / param % DU2M ) ** 2 / param % MU2KG call fraggle_io_log_regime ( colliders , frag ) end associate return end subroutine fraggle_regime_colliders subroutine fraggle_regime_collresolve ( Mcb , m1 , m2 , rad1 , rad2 , xh1 , xh2 , vb1 , vb2 , den1 , den2 , min_mfrag , regime , Mlr , Mslr , Qloss ) !! Author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Determine the collisional regime of two colliding bodies. !! Current version requires all values to be converted to SI units prior to calling the function !!       References: !!       Kokubo, E., Genda, H., 2010. Formation of Terrestrial Planets from Protoplanets Under a Realistic Accretion !!          Condition. ApJL 714, L21. https://doi.org/10.1088/2041-8205/714/1/L21 !!       Leinhardt, Z.M., Stewart, S.T., 2012. Collisions between Gravity-dominated Bodies. I. Outcome Regimes and Scaling !!          Laws 745, 79. https://doi.org/10.1088/0004-637X/745/1/79 !!       Mustill, A.J., Davies, M.B., Johansen, A., 2018. The dynamical evolution of transiting planetary systems including !!          a realistic collision prescription. Mon Not R Astron Soc 478, 2896–2908. https://doi.org/10.1093/mnras/sty1273 !!       Rufu, R., Aharonson, O., 2019. Impact Dynamics of Moons Within a Planetary Potential. J. Geophys. Res. Planets 124, !!          1008–1019. https://doi.org/10.1029/2018JE005798 !!       Stewart, S.T., Leinhardt, Z.M., 2012. Collisions between Gravity-dominated Bodies. II. The Diversity of Impact !!          Outcomes during the End Stage of Planet Formation. ApJ 751, 32. https://doi.org/10.1088/0004-637X/751/1/32 !! implicit none ! Arguments real ( DP ), intent ( in ) :: Mcb , m1 , m2 , rad1 , rad2 , den1 , den2 , min_mfrag real ( DP ), dimension (:), intent ( in ) :: xh1 , xh2 , vb1 , vb2 integer ( I4B ), intent ( out ) :: regime real ( DP ), intent ( out ) :: Mlr , Mslr real ( DP ), intent ( out ) :: Qloss !! The residual energy after the collision ! Constants integer ( I4B ), parameter :: N1 = 1 !number of objects with mass equal to the largest remnant from LS12 integer ( I4B ), parameter :: N2 = 2 !number of objects with mass larger than second largest remnant from LS12 real ( DP ), parameter :: DENSITY1 = 100 0.0_DP !standard density parameter from LS12 [kg/m3] real ( DP ), parameter :: MU_BAR = 0.37_DP !0.385#0.37#0.3333# 3.978 # 1/3 material parameter for hydrodynamic planet-size bodies (LS12) real ( DP ), parameter :: BETA = 2.85_DP !slope of sfd for remnants from LS12 2.85 real ( DP ), parameter :: ETA = - 1.50_DP !! LS12 eq. (44) real ( DP ), parameter :: C1 = 2.43_DP !! Kokubo & Genda (2010) eq. (3) real ( DP ), parameter :: C2 = - 0.0408_DP !! Kokubo & Genda (2010) eq. (3) real ( DP ), parameter :: C3 = 1.86_DP !! Kokubo & Genda (2010) eq. (3) real ( DP ), parameter :: C4 = 1.08_DP !! Kokubo & Genda (2010) eq. (3) real ( DP ), parameter :: CRUFU = 2.0_DP - 3 * MU_BAR ! central potential variable from Rufu and Aharonson (2019) real ( DP ), parameter :: SUPERCAT_QRATIO = 1.8_DP ! See Section 4.1 of LS12 ! Internals real ( DP ) :: a1 , alpha , aint , b , bcrit , c_star , egy , zeta , l , lint , mu , phi , theta real ( DP ) :: Qr , Qrd_pstar , Qr_erosion , Qr_supercat real ( DP ) :: Vhr , Verosion , Vescp , Vhill , Vimp , Vsupercat real ( DP ) :: Mint , Mtot , Mtmp real ( DP ) :: Rp , rhill real ( DP ) :: Mresidual real ( DP ) :: U_binding Vimp = norm2 ( vb2 (:) - vb1 (:)) b = calc_b ( xh2 , vb2 , xh1 , vb1 ) l = ( rad1 + rad2 ) * ( 1 - b ) egy = 0.5_DP * dot_product ( vb1 , vb1 ) - GC * Mcb / norm2 ( xh1 ) a1 = - GC * Mcb / 2.0_DP / egy Mtot = m1 + m2 mu = ( m1 * m2 ) / Mtot if ( l < 2 * rad2 ) then !calculate Mint phi = 2 * acos (( l - rad2 ) / rad2 ) aint = rad2 ** 2 * ( PI - ( phi - sin ( phi )) / 2.0_DP ) lint = 2 * sqrt ( rad2 ** 2 - ( rad2 - l / 2.0_DP ) ** 2 ) Mint = aint * lint ![kg] alpha = ( l ** 2 ) * ( 3 * rad2 - l ) / ( 4 * ( rad2 ** 3 )) else alpha = 1.0_DP Mint = m2 end if Rp = ( 3 * ( m1 / den1 + alpha * m2 / den2 ) / ( 4 * PI )) ** ( 1.0_DP / 3.0_DP ) ! (Mustill et al. 2018) c_star = calc_c_star ( Rp ) !calculate Vescp Vescp = sqrt ( 2 * GC * Mtot / Rp ) !Mustill et al. 2018 eq 6 !calculate rhill rhill = a1 * ( m1 / 3.0_DP / ( Mcb + m1 )) ** ( 1.0_DP / 3.0_DP ) !calculate Vhill if (( rad2 + rad1 ) < rhill ) then Vhill = sqrt ( 2 * GC * m1 * (( rhill ** 2 - rhill * ( rad1 + rad2 )) / & ( rhill ** 2 - 0.5_DP * ( rad1 + rad2 ) ** 2 )) / ( rad1 + rad2 )) else Vhill = Vescp end if !calculate Qr_pstar Qrd_pstar = calc_Qrd_pstar ( m1 , m2 , alpha , c_star ) * ( Vhill / Vescp ) ** CRUFU !Rufu and Aharaonson eq (3) !calculate Verosion Qr_erosion = 2 * ( 1.0_DP - m1 / Mtot ) * Qrd_pstar Verosion = ( 2 * Qr_erosion * Mtot / mu ) ** ( 1.0_DP / 2.0_DP ) Qr = mu * ( Vimp ** 2 ) / Mtot / 2.0_DP !calculate mass largest remnant Mlr Mlr = max (( 1.0_DP - Qr / Qrd_pstar / 2.0_DP ) * Mtot , min_mfrag ) ! [kg] # LS12 eq (5) !calculate Vsupercat Qr_supercat = SUPERCAT_QRATIO * Qrd_pstar ! See LS12 Section 4.1 Vsupercat = sqrt ( 2 * Qr_supercat * Mtot / mu ) !calculate Vhr zeta = ( m1 - m2 ) / Mtot theta = 1.0_DP - b Vhr = Vescp * ( C1 * zeta ** 2 * theta ** ( 2.5_DP ) + C2 * zeta ** 2 + C3 * theta ** ( 2.5_DP ) + C4 ) ! Kokubo & Genda (2010) eq. (3) bcrit = rad1 / ( rad1 + rad2 ) Qloss = 0.0_DP U_binding = ( 3.0_DP * Mtot ) / ( 5.0_DP * Rp ) ! LS12 eq. 27 if (( m1 < min_mfrag ). or .( m2 < min_mfrag )) then regime = COLLRESOLVE_REGIME_MERGE !perfect merging regime Mlr = Mtot Mslr = 0.0_DP Qloss = 0.0_DP call fraggle_io_log_one_message ( \"Fragments would have mass below the minimum. Converting this collision into a merger.\" ) else if ( Vimp < Vescp ) then regime = COLLRESOLVE_REGIME_MERGE !perfect merging regime Mlr = Mtot Mslr = 0.0_DP Qloss = 0.0_DP else if ( Vimp < Verosion ) then if ( b < bcrit ) then regime = COLLRESOLVE_REGIME_MERGE !partial accretion regime\" Mlr = Mtot Mslr = 0.0_DP Qloss = 0.0_DP else if (( b > bcrit ) . and . ( Vimp < Vhr )) then regime = COLLRESOLVE_REGIME_MERGE ! graze and merge Mlr = Mtot Mslr = 0.0_DP Qloss = 0.0_DP else Mlr = m1 Mslr = max ( calc_Qrd_rev ( m2 , m1 , Mint , den1 , den2 , Vimp , c_star ), min_mfrag ) regime = COLLRESOLVE_REGIME_HIT_AND_RUN !hit and run Qloss = ( c_star + 1.0_DP ) * U_binding ! Qr end if else if ( Vimp > Verosion . and . Vimp < Vsupercat ) then if ( m2 < 0.001_DP * m1 ) then regime = COLLRESOLVE_REGIME_MERGE !cratering regime\" Mlr = Mtot Mslr = 0.0_DP Qloss = 0.0_DP else Mslr = max ( Mtot * ( 3.0_DP - BETA ) * ( 1.0_DP - N1 * Mlr / Mtot ) / ( N2 * BETA ), min_mfrag ) ! LS12 eq (37) regime = COLLRESOLVE_REGIME_DISRUPTION !disruption Qloss = ( c_star + 1.0_DP ) * U_binding ! Qr - Qr_erosion end if else if ( Vimp > Vsupercat ) then Mlr = max ( Mtot * 0.1_DP * ( Qr / ( Qrd_pstar * SUPERCAT_QRATIO )) ** ( ETA ), min_mfrag ) !LS12 eq (44) Mslr = max ( Mtot * ( 3.0_DP - BETA ) * ( 1.0_DP - N1 * Mlr / Mtot ) / ( N2 * BETA ), min_mfrag ) !LS12 eq (37) regime = COLLRESOLVE_REGIME_SUPERCATASTROPHIC ! supercatastrophic Qloss = ( c_star + 1.0_DP ) * U_binding ! Qr - Qr_supercat else write ( * , * ) \"Error no regime found in symba_regime\" end if end if if ( Mslr > Mlr ) then ! The second-largest fragment is actually larger than the largest, so we will swap them Mtmp = Mlr Mlr = Mslr Mslr = Mtmp end if Mresidual = Mtot - Mlr - Mslr if ( Mresidual < 0.0_DP ) then ! prevents final masses from going negative Mlr = Mlr + Mresidual end if return ! Internal functions contains function calc_Qrd_pstar ( Mtarg , Mp , alpha , c_star ) result ( Qrd_pstar ) !! author: Jennifer L.L. Pouplin and Carlisle A. Wishard !! !! Calculates the corrected Q* for oblique impacts. See Eq. (15) of LS12. !!       Reference: !!       Leinhardt, Z.M., Stewart, S.T., 2012. Collisions between Gravity-dominated Bodies. I. Outcome Regimes and Scaling !!          Laws 745, 79. https://doi.org/10.1088/0004-637X/745/1/79 !! implicit none ! Arguments real ( DP ), intent ( in ) :: Mtarg , Mp , alpha , c_star ! Result real ( DP ) :: Qrd_pstar ! Internals real ( DP ) :: Qrd_star1 , mu_alpha , mu , Qrd_star ! calc mu, mu_alpha mu = ( Mtarg * Mp ) / ( Mtarg + Mp ) ! [kg] mu_alpha = ( Mtarg * alpha * Mp ) / ( Mtarg + alpha * Mp ) ! [kg] ! calc Qrd_star1 Qrd_star1 = ( c_star * 4 * PI * DENSITY1 * GC * Rp ** 2 ) / 5.0_DP ! calc Qrd_star Qrd_star = Qrd_star1 * ((( Mp / Mtarg + 1.0_DP ) ** 2 ) / ( 4 * Mp / Mtarg )) ** ( 2.0_DP / ( 3.0_DP * MU_BAR ) - 1.0_DP ) !(eq 23) ! calc Qrd_pstar, v_pstar Qrd_pstar = (( mu / mu_alpha ) ** ( 2.0_DP - 3.0_DP * MU_BAR / 2.0_DP )) * Qrd_star ! (eq 15) return end function calc_Qrd_pstar function calc_Qrd_rev ( Mp , Mtarg , Mint , den1 , den2 , Vimp , c_star ) result ( Mslr ) !! author: Jennifer L.L. Pouplin and Carlisle A. Wishard !! !! Calculates mass of second largest fragment. !! implicit none ! Arguments real ( DP ), intent ( in ) :: Mp , Mtarg , Mint , den1 , den2 , Vimp , c_star ! Result real ( DP ) :: Mslr ! Internals real ( DP ) :: mtot_rev , mu_rev , gamma_rev , Qrd_star1 , Qrd_star , mu_alpha_rev real ( DP ) :: Qrd_pstar , Rc1 , Qr_rev , Qrd_pstar_rev , Qr_supercat_rev ! calc Mslr, Rc1, mu, gammalr mtot_rev = Mint + Mp Rc1 = ( 3 * ( Mint / den1 + Mp / den2 ) / ( 4 * PI )) ** ( 1.0_DP / 3.0_DP ) ! [m] Mustill et al 2018 mu_rev = ( Mint * Mp ) / mtot_rev ! [kg] eq 49 LS12 mu_alpha_rev = ( Mtarg * alpha * Mp ) / ( Mtarg + alpha * Mp ) gamma_rev = Mint / Mp ! eq 50 LS12 !calc Qr_rev Qr_rev = mu_rev * ( Vimp ** 2 ) / ( 2 * mtot_rev ) ! calc Qrd_star1, v_star1 Qrd_star1 = ( c_star * 4 * PI * mtot_rev * GC ) / Rc1 / 5.0_DP ! calc Qrd_pstar_rev Qrd_star = Qrd_star1 * ((( gamma_rev + 1.0_DP ) ** 2 ) / ( 4 * gamma_rev )) ** ( 2.0_DP / ( 3.0_DP * MU_BAR ) - 1.0_DP ) !(eq 52) Qrd_pstar = Qrd_star * (( mu_rev / mu_alpha_rev ) ** ( 2.0_DP - 3.0_DP * MU_BAR / 2.0_DP )) Qrd_pstar_rev = Qrd_pstar * ( Vhill / Vescp ) ** CRUFU !Rufu and Aharaonson eq (3) !calc Qr_supercat_rev Qr_supercat_rev = 1.8_DP * Qrd_pstar_rev if ( Qr_rev > Qr_supercat_rev ) then Mslr = mtot_rev * ( 0.1_DP * (( Qr_rev / ( Qrd_pstar_rev * 1.8_DP )) ** ( - 1.5_DP ))) !eq (44) else if ( Qr_rev < Qrd_pstar_rev ) then Mslr = Mp else Mslr = ( 1.0_DP - Qr_rev / Qrd_pstar_rev / 2.0_DP ) * ( mtot_rev ) ! [kg] #(eq 5) end if if ( Mslr > Mp ) Mslr = Mp !check conservation of mass return end function calc_Qrd_rev function calc_b ( proj_pos , proj_vel , targ_pos , targ_vel ) result ( sintheta ) !! author: Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton !! !! Calculates the impact factor b = sin(theta), where theta is the angle between the relative velocity !! and distance vectors of the target and projectile bodies. See Fig. 2 of Leinhardt and Stewart (2012) !! implicit none !! Arguments real ( DP ), dimension (:), intent ( in ) :: proj_pos , proj_vel , targ_pos , targ_vel !! Result real ( DP ) :: sintheta !! Internals real ( DP ), dimension ( NDIM ) :: imp_vel , distance , x_cross_v imp_vel (:) = proj_vel (:) - targ_vel (:) distance (:) = proj_pos (:) - targ_pos (:) x_cross_v (:) = distance (:) . cross . imp_vel (:) sintheta = norm2 ( x_cross_v (:)) / norm2 ( distance (:)) / norm2 ( imp_vel (:)) return end function calc_b function calc_c_star ( Rc1 ) result ( c_star ) !! author: David A. Minton !! !! Calculates c_star as a function of impact equivalent radius. It inteRpolates between 5 for ~1 km sized bodies to !! 1.8 for ~10000 km sized bodies. See LS12 Fig. 4 for details. !! implicit none !! Arguments real ( DP ), intent ( in ) :: Rc1 !! Result real ( DP ) :: c_star !! Internals real ( DP ), parameter :: loR = 1.0e3_DP ! Lower bound of inteRpolation size (m) real ( DP ), parameter :: hiR = 1.0e7_DP ! Upper bound of inteRpolation size (m) real ( DP ), parameter :: loval = 5.0_DP ! Value of C* at lower bound real ( DP ), parameter :: hival = 1.9_DP ! Value of C* at upper bound if ( Rc1 < loR ) then c_star = loval else if ( Rc1 < hiR ) then c_star = loval + ( hival - loval ) * log ( Rc1 / loR ) / log ( hiR / loR ) else c_star = hival end if return end function calc_c_star end subroutine fraggle_regime_collresolve end submodule s_fraggle_regime","tags":"","loc":"sourcefile/fraggle_regime.f90.html"},{"title":"fraggle_placeholder.f90 – swiftest","text":"This file depends on sourcefile~~fraggle_placeholder.f90~~EfferentGraph sourcefile~fraggle_placeholder.f90 fraggle_placeholder.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~fraggle_placeholder.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~fraggle_placeholder.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_fraggle_placeholder Source Code fraggle_placeholder.f90 Source Code submodule ( fraggle_classes ) s_fraggle_placeholder use swiftest contains !> The following interfaces are placeholders intended to satisfy the required abstract methods given by the parent class module subroutine fraggle_placeholder_accel ( self , system , param , t , lbeg ) implicit none class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time logical , intent ( in ) :: lbeg !! Optional argument that determines whether or not this is the beginning or end of the step write ( * , * ) \"The type-bound procedure 'accel' is not defined for type fraggle_fragments\" return end subroutine fraggle_placeholder_accel module subroutine fraggle_placeholder_kick ( self , system , param , t , dt , lbeg ) implicit none class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system objec class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time real ( DP ), intent ( in ) :: dt !! Stepsize logical , intent ( in ) :: lbeg !! Logical flag indicating whether this is the beginning of the half step or not. write ( * , * ) \"The type-bound procedure 'kick' is not defined for type fraggle_fragments\" return end subroutine fraggle_placeholder_kick module subroutine fraggle_placeholder_step ( self , system , param , t , dt ) implicit none class ( fraggle_fragments ), intent ( inout ) :: self !! Swiftest body object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Simulation time real ( DP ), intent ( in ) :: dt !! Current stepsize write ( * , * ) \"The type-bound procedure 'step' is not defined for type fraggle_fragments\" return end subroutine fraggle_placeholder_step end submodule s_fraggle_placeholder","tags":"","loc":"sourcefile/fraggle_placeholder.f90.html"},{"title":"fraggle_setup.f90 – swiftest","text":"This file depends on sourcefile~~fraggle_setup.f90~~EfferentGraph sourcefile~fraggle_setup.f90 fraggle_setup.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~fraggle_setup.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~fraggle_setup.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_fraggle_setup Source Code fraggle_setup.f90 Source Code submodule ( fraggle_classes ) s_fraggle_setup use swiftest contains module subroutine fraggle_setup_reset_fragments ( self ) !! author: David A. Minton !! !! Resets all position and velocity-dependent fragment quantities in order to do a fresh calculation (does not reset mass, radius, or other values that get set prior to the call to fraggle_generate) implicit none ! Arguments class ( fraggle_fragments ), intent ( inout ) :: self self % xb (:,:) = 0.0_DP self % vb (:,:) = 0.0_DP self % rot (:,:) = 0.0_DP self % x_coll (:,:) = 0.0_DP self % v_coll (:,:) = 0.0_DP self % v_r_unit (:,:) = 0.0_DP self % v_t_unit (:,:) = 0.0_DP self % v_n_unit (:,:) = 0.0_DP self % rmag (:) = 0.0_DP self % rotmag (:) = 0.0_DP self % v_r_mag (:) = 0.0_DP self % v_t_mag (:) = 0.0_DP self % ke_orbit = 0.0_DP self % ke_spin = 0.0_DP self % L_orbit (:) = 0.0_DP self % L_spin (:) = 0.0_DP return end subroutine fraggle_setup_reset_fragments module subroutine fraggle_setup_fragments ( self , n , param ) !! author: David A. Minton !! !! Allocates arrays for n fragments in a Fraggle system. Passing n = 0 deallocates all arrays. implicit none ! Arguments class ( fraggle_fragments ), intent ( inout ) :: self integer ( I4B ), intent ( in ) :: n class ( swiftest_parameters ), intent ( in ) :: param call setup_pl ( self , n , param ) if ( n < 0 ) return if ( allocated ( self % x_coll )) deallocate ( self % x_coll ) if ( allocated ( self % v_coll )) deallocate ( self % v_coll ) if ( allocated ( self % v_r_unit )) deallocate ( self % v_r_unit ) if ( allocated ( self % v_t_unit )) deallocate ( self % v_t_unit ) if ( allocated ( self % v_n_unit )) deallocate ( self % v_n_unit ) if ( allocated ( self % rmag )) deallocate ( self % rmag ) if ( allocated ( self % rotmag )) deallocate ( self % rotmag ) if ( allocated ( self % v_r_mag )) deallocate ( self % v_r_mag ) if ( allocated ( self % v_t_mag )) deallocate ( self % v_t_mag ) if ( n == 0 ) return allocate ( self % x_coll ( NDIM , n )) allocate ( self % v_coll ( NDIM , n )) allocate ( self % v_r_unit ( NDIM , n )) allocate ( self % v_t_unit ( NDIM , n )) allocate ( self % v_n_unit ( NDIM , n )) allocate ( self % rmag ( n )) allocate ( self % rotmag ( n )) allocate ( self % v_r_mag ( n )) allocate ( self % v_t_mag ( n )) call self % reset () return end subroutine fraggle_setup_fragments end submodule s_fraggle_setup","tags":"","loc":"sourcefile/fraggle_setup.f90.html"},{"title":"fraggle_set.f90 – swiftest","text":"This file depends on sourcefile~~fraggle_set.f90~~EfferentGraph sourcefile~fraggle_set.f90 fraggle_set.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~fraggle_set.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~fraggle_set.f90->sourcefile~swiftest.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_fraggle_set Source Code fraggle_set.f90 Source Code submodule ( fraggle_classes ) s_fraggle_set use swiftest contains module subroutine fraggle_set_budgets_fragments ( self , colliders ) !! author: David A. Minton !! !! Sets the energy and momentum budgets of the fragments based on the collider values and the before/after values of energy and momentum implicit none ! Arguments class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle collider system object ! Internals real ( DP ) :: dEtot real ( DP ), dimension ( NDIM ) :: dL associate ( frag => self ) dEtot = frag % Etot_after - frag % Etot_before dL (:) = frag % Ltot_after (:) - frag % Ltot_before (:) frag % L_budget (:) = - dL (:) frag % ke_budget = - ( dEtot - 0.5_DP * frag % mtot * dot_product ( frag % vbcom (:), frag % vbcom (:))) - frag % Qloss end associate return end subroutine fraggle_set_budgets_fragments module subroutine fraggle_set_mass_dist_fragments ( self , colliders , param ) !! author: David A. Minton !! !! Sets the mass of fragments based on the mass distribution returned by the regime calculation. !! This subroutine must be run after the the setup rourtine has been run on the fragments implicit none ! Arguments class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle collider system object class ( swiftest_parameters ), intent ( in ) :: param !! Current Swiftest run configuration parameters ! Internals integer ( I4B ) :: i , jproj , jtarg , nfrag , istart real ( DP ), dimension ( 2 ) :: volume real ( DP ), dimension ( NDIM ) :: Ip_avg real ( DP ) :: mfrag , mremaining , min_mfrag real ( DP ), parameter :: BETA = 2.85_DP integer ( I4B ), parameter :: NFRAGMAX = 100 !! Maximum number of fragments that can be generated integer ( I4B ), parameter :: NFRAGMIN = 7 !! Minimum number of fragments that can be generated (set by the fraggle_generate algorithm for constraining momentum and energy) integer ( I4B ), parameter :: NFRAG_SIZE_MULTIPLIER = 3 !! Log-space scale factor that scales the number of fragments by the collisional system mass integer ( I4B ), parameter :: iMlr = 1 integer ( I4B ), parameter :: iMslr = 2 integer ( I4B ), parameter :: iMrem = 3 associate ( frag => self ) ! Get mass weighted mean of Ip and density volume ( 1 : 2 ) = 4._DP / 3._DP * PI * colliders % radius ( 1 : 2 ) ** 3 Ip_avg (:) = ( colliders % mass ( 1 ) * colliders % Ip (:, 1 ) + colliders % mass ( 2 ) * colliders % Ip (:, 2 )) / frag % mtot if ( colliders % mass ( 1 ) > colliders % mass ( 2 )) then jtarg = 1 jproj = 2 else jtarg = 2 jproj = 1 end if select type ( param ) class is ( symba_parameters ) min_mfrag = ( param % min_GMfrag / param % GU ) ! The number of fragments we generate is bracked by the minimum required by fraggle_generate (7) and the ! maximum set by the NFRAG_SIZE_MULTIPLIER which limits the total number of fragments to prevent the nbody ! code from getting an overwhelmingly large number of fragments nfrag = ceiling ( NFRAG_SIZE_MULTIPLIER * log ( frag % mtot / min_mfrag )) nfrag = max ( min ( nfrag , NFRAGMAX ), NFRAGMIN ) class default min_mfrag = 0.0_DP nfrag = NFRAGMAX end select select case ( frag % regime ) case ( COLLRESOLVE_REGIME_DISRUPTION , COLLRESOLVE_REGIME_SUPERCATASTROPHIC , COLLRESOLVE_REGIME_HIT_AND_RUN ) ! The first two bins of the mass_dist are the largest and second-largest fragments that came out of fraggle_regime. ! The remainder from the third bin will be distributed among nfrag-2 bodies. The following code will determine nfrag based on ! the limits bracketed above and the model size distribution of fragments. ! Check to see if our size distribution would give us a smaller number of fragments than the maximum number i = iMrem mremaining = frag % mass_dist ( iMrem ) do while ( i <= nfrag ) mfrag = ( 1 + i - iMslr ) ** ( - 3._DP / BETA ) * frag % mass_dist ( iMslr ) if ( mremaining - mfrag < 0.0_DP ) exit mremaining = mremaining - mfrag i = i + 1 end do if ( i < nfrag ) nfrag = max ( i , NFRAGMIN ) ! The sfd would actually give us fewer fragments than our maximum call frag % setup ( nfrag , param ) case ( COLLRESOLVE_REGIME_MERGE , COLLRESOLVE_REGIME_GRAZE_AND_MERGE ) call frag % setup ( 1 , param ) frag % mass ( 1 ) = frag % mass_dist ( 1 ) frag % radius ( 1 ) = colliders % radius ( jtarg ) frag % density ( 1 ) = frag % mass_dist ( 1 ) / volume ( jtarg ) frag % Ip (:, 1 ) = colliders % Ip (:, 1 ) return case default write ( * , * ) \"fraggle_set_mass_dist_fragments error: Unrecognized regime code\" , frag % regime end select ! Make the first two bins the same as the Mlr and Mslr values that came from fraggle_regime frag % mass ( 1 ) = frag % mass_dist ( iMlr ) frag % mass ( 2 ) = frag % mass_dist ( iMslr ) ! Distribute the remaining mass the 3:nfrag bodies following the model SFD given by slope BETA mremaining = frag % mass_dist ( iMrem ) do i = iMrem , nfrag mfrag = ( 1 + i - iMslr ) ** ( - 3._DP / BETA ) * frag % mass_dist ( iMslr ) frag % mass ( i ) = mfrag mremaining = mremaining - mfrag end do ! If there is any residual mass (either positive or negative) we will distribute remaining mass proportionally among the the fragments if ( mremaining < 0.0_DP ) then ! If the remainder is negative, this means that that the number of fragments required by the SFD is smaller than our lower limit set by fraggle_generate. istart = iMrem ! We will reduce the mass of the 3:nfrag bodies to prevent the second-largest fragment from going smaller else ! If the remainder is postiive, this means that the number of fragments required by the SFD is larger than our upper limit set by computational expediency. istart = iMslr ! We will increase the mass of the 2:nfrag bodies to compensate, which ensures that the second largest fragment remains the second largest end if mfrag = 1._DP + mremaining / sum ( frag % mass ( istart : nfrag )) frag % mass ( istart : nfrag ) = frag % mass ( istart : nfrag ) * mfrag ! There may still be some small residual due to round-off error. If so, simply add it to the last bin of the mass distribution. mremaining = frag % mtot - sum ( frag % mass ( 1 : nfrag )) frag % mass ( nfrag ) = frag % mass ( nfrag ) + mremaining ! Compute physical properties of the new fragments select case ( frag % regime ) case ( COLLRESOLVE_REGIME_HIT_AND_RUN ) ! The hit and run case always preserves the largest body intact, so there is no need to recompute the physical properties of the first fragment frag % radius ( 1 ) = colliders % radius ( jtarg ) frag % density ( 1 ) = frag % mass_dist ( iMlr ) / volume ( jtarg ) frag % Ip (:, 1 ) = colliders % Ip (:, 1 ) istart = 2 case default istart = 1 end select frag % density ( istart : nfrag ) = frag % mtot / sum ( volume (:)) frag % radius ( istart : nfrag ) = ( 3 * frag % mass ( istart : nfrag ) / ( 4 * PI * frag % density ( istart : nfrag ))) ** ( 1.0_DP / 3.0_DP ) do i = istart , nfrag frag % Ip (:, i ) = Ip_avg (:) end do end associate return end subroutine fraggle_set_mass_dist_fragments module subroutine fraggle_set_coordinate_system ( self , colliders ) !! author: David A. Minton !! !! Defines the collisional coordinate system, including the unit vectors of both the system and individual fragments. implicit none ! Arguments class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle collider system object ! Internals integer ( I4B ) :: i real ( DP ), dimension ( NDIM ) :: x_cross_v , delta_r , delta_v , Ltot real ( DP ) :: r_col_norm , v_col_norm real ( DP ), dimension ( NDIM , self % nbody ) :: L_sigma associate ( frag => self , nfrag => self % nbody ) delta_v (:) = colliders % vb (:, 2 ) - colliders % vb (:, 1 ) v_col_norm = . mag . delta_v (:) delta_r (:) = colliders % xb (:, 2 ) - colliders % xb (:, 1 ) r_col_norm = . mag . delta_r (:) ! We will initialize fragments on a plane defined by the pre-impact system, with the z-axis aligned with the angular momentum vector ! and the y-axis aligned with the pre-impact distance vector. Ltot = colliders % L_orbit (:, 1 ) + colliders % L_orbit (:, 2 ) + colliders % L_spin (:, 1 ) + colliders % L_spin (:, 2 ) frag % y_coll_unit (:) = delta_r (:) / r_col_norm frag % z_coll_unit (:) = Ltot (:) / (. mag . Ltot (:)) ! The cross product of the y- by z-axis will give us the x-axis frag % x_coll_unit (:) = frag % y_coll_unit (:) . cross . frag % z_coll_unit (:) if (. not . any ( frag % x_coll (:,:) > 0.0_DP )) return frag % rmag (:) = . mag . frag % x_coll (:,:) call random_number ( L_sigma (:,:)) ! Randomize the tangential velocity direction. This helps to ensure that the tangential velocity doesn't completely line up with the angular momentum vector, ! otherwise we can get an ill-conditioned system do concurrent ( i = 1 : nfrag , frag % rmag ( i ) > 0.0_DP ) frag % v_r_unit (:, i ) = frag % x_coll (:, i ) / frag % rmag ( i ) frag % v_n_unit (:, i ) = frag % z_coll_unit (:) + 2e-1_DP * ( L_sigma (:, i ) - 0.5_DP ) frag % v_n_unit (:, i ) = frag % v_n_unit (:, i ) / (. mag . frag % v_n_unit (:, i )) frag % v_t_unit (:, i ) = frag % v_n_unit (:, i ) . cross . frag % v_r_unit (:, i ) frag % v_t_unit (:, i ) = frag % v_t_unit (:, i ) / (. mag . frag % v_t_unit (:, i )) end do end associate return end subroutine fraggle_set_coordinate_system ! module subroutine symba_set_collresolve_colliders(self, cb, pl, idx) !    !! author: David A. Minton !    !! !    !! Calculate the two-body equivalent values given a set of input collider indices !    use swiftest_classes, only : swiftest_nbody_system !    implicit none !    ! Arguments !    class(fraggle_colliders),               intent(inout) :: self !! Fraggle collider object !    class(symba_cb),                     intent(in)    :: cb   !! Swiftest central body object system object !    class(symba_pl),                     intent(in)    :: pl   !! Swiftest central body object system object !    integer(I4B),             dimension(:), intent(in)    :: idx  !! Index array of bodies from the pl object to use to calculate a \"two-body equivalent\" collisional pair !    ! Internals !    real(DP), dimension(NDIM, 2)  :: mxc, vc !    real(DP), dimension(NDIM) :: vcom, xcom !    associate(colliders => self) !       ! Compute orbital angular momentum of pre-impact system !       xcom(:) = (colliders%mass(1) * colliders%xb(:, 1) + colliders%mass(2) * colliders%xb(:, 2)) / sum(colliders%mass(:)) !       vcom(:) = (colliders%mass(1) * colliders%vb(:, 1) + colliders%mass(2) * colliders%vb(:, 2)) / sum(colliders%mass(:)) !       mxc(:, 1) = colliders%mass(1) * (colliders%xb(:, 1) - xcom(:)) !       mxc(:, 2) = colliders%mass(2) * (colliders%xb(:, 2) - xcom(:)) !       vc(:, 1) = colliders%vb(:, 1) - vcom(:) !       vc(:, 2) = colliders%vb(:, 2) - vcom(:) !       colliders%L_orbit(:,:) = mxc(:,:) .cross. vc(:,:) !    end associate !    return ! end subroutine symbe_set_collresolve_colliders module subroutine fraggle_set_natural_scale_factors ( self , colliders ) !! author: David A. Minton !! !! Scales dimenional quantities to ~O(1) with respect to the collisional system. !! This scaling makes it easier for the non-linear minimization to converge on a solution implicit none ! Arguments class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle collider system object ! Internals integer ( I4B ) :: i associate ( frag => self ) ! Set scale factors frag % Escale = 0.5_DP * ( colliders % mass ( 1 ) * dot_product ( colliders % vb (:, 1 ), colliders % vb (:, 1 )) + colliders % mass ( 2 ) * dot_product ( colliders % vb (:, 2 ), colliders % vb (:, 2 ))) frag % dscale = sum ( colliders % radius (:)) frag % mscale = frag % mtot frag % vscale = sqrt ( frag % Escale / frag % mscale ) frag % tscale = frag % dscale / frag % vscale frag % Lscale = frag % mscale * frag % dscale * frag % vscale ! Scale all dimensioned quantities of colliders and fragments frag % xbcom (:) = frag % xbcom (:) / frag % dscale frag % vbcom (:) = frag % vbcom (:) / frag % vscale colliders % xb (:,:) = colliders % xb (:,:) / frag % dscale colliders % vb (:,:) = colliders % vb (:,:) / frag % vscale colliders % mass (:) = colliders % mass (:) / frag % mscale colliders % radius (:) = colliders % radius (:) / frag % dscale colliders % L_spin (:,:) = colliders % L_spin (:,:) / frag % Lscale do i = 1 , 2 colliders % rot (:, i ) = colliders % L_spin (:, i ) / ( colliders % mass ( i ) * colliders % radius ( i ) ** 2 * colliders % Ip ( 3 , i )) end do frag % mtot = frag % mtot / frag % mscale frag % mass = frag % mass / frag % mscale frag % radius = frag % radius / frag % dscale frag % Qloss = frag % Qloss / frag % Escale end associate return end subroutine fraggle_set_natural_scale_factors module subroutine fraggle_set_original_scale_factors ( self , colliders ) !! author: David A. Minton !! !! Restores dimenional quantities back to the system units use , intrinsic :: ieee_exceptions implicit none ! Arguments class ( fraggle_fragments ), intent ( inout ) :: self !! Fraggle fragment system object class ( fraggle_colliders ), intent ( inout ) :: colliders !! Fraggle collider system object ! Internals integer ( I4B ) :: i logical , dimension ( size ( IEEE_ALL )) :: fpe_halting_modes call ieee_get_halting_mode ( IEEE_ALL , fpe_halting_modes ) ! Save the current halting modes so we can turn them off temporarily call ieee_set_halting_mode ( IEEE_ALL ,. false .) associate ( frag => self ) ! Restore scale factors frag % xbcom (:) = frag % xbcom (:) * frag % dscale frag % vbcom (:) = frag % vbcom (:) * frag % vscale colliders % mass = colliders % mass * frag % mscale colliders % radius = colliders % radius * frag % dscale colliders % xb = colliders % xb * frag % dscale colliders % vb = colliders % vb * frag % vscale colliders % L_spin = colliders % L_spin * frag % Lscale do i = 1 , 2 colliders % rot (:, i ) = colliders % L_spin (:, i ) * ( colliders % mass ( i ) * colliders % radius ( i ) ** 2 * colliders % Ip ( 3 , i )) end do frag % Qloss = frag % Qloss * frag % Escale frag % mtot = frag % mtot * frag % mscale frag % mass = frag % mass * frag % mscale frag % radius = frag % radius * frag % dscale frag % rot = frag % rot / frag % tscale frag % x_coll = frag % x_coll * frag % dscale frag % v_coll = frag % v_coll * frag % vscale do i = 1 , frag % nbody frag % xb (:, i ) = frag % x_coll (:, i ) + frag % xbcom (:) frag % vb (:, i ) = frag % v_coll (:, i ) + frag % vbcom (:) end do frag % mscale = 1.0_DP frag % dscale = 1.0_DP frag % vscale = 1.0_DP frag % tscale = 1.0_DP frag % Lscale = 1.0_DP frag % Escale = 1.0_DP end associate call ieee_set_halting_mode ( IEEE_ALL , fpe_halting_modes ) return end subroutine fraggle_set_original_scale_factors end submodule s_fraggle_set","tags":"","loc":"sourcefile/fraggle_set.f90.html"},{"title":"rmvs_discard.f90 – swiftest","text":"This file depends on sourcefile~~rmvs_discard.f90~~EfferentGraph sourcefile~rmvs_discard.f90 rmvs_discard.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~rmvs_discard.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~rmvs_discard.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_rmvs_discard Source Code rmvs_discard.f90 Source Code submodule ( rmvs_classes ) s_rmvs_discard use swiftest contains module subroutine rmvs_discard_tp ( self , system , param ) !! author: David A. Minton !! !! Check to see if test particles should be discarded based on pericenter passage distances with respect to planets encountered !! !! Adapted from Hal Levison's Swift routine discard_pl.f !! Adapted from Hal Levison's Swift routine rmvs_discard_pl.f90 implicit none ! Arguments class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i character ( len = STRMAX ) :: timestr , idstri , idstrj if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody , pl => system % pl , t => param % t ) do i = 1 , ntp associate ( iplperP => tp % plperP ( i )) if (( tp % status ( i ) == ACTIVE ) . and . ( tp % lperi ( i ))) then if (( tp % peri ( i ) < pl % radius ( iplperP ))) then tp % status ( i ) = DISCARDED_PLQ write ( idstri , * ) tp % id ( i ) write ( idstrj , * ) pl % id ( iplperP ) write ( timestr , * ) t write ( * , * ) \"Particle \" // trim ( adjustl ( tp % info ( i )% name )) // \" (\" // trim ( adjustl ( idstri )) & // \") q with respect to massive body \" // trim ( adjustl ( pl % info ( iplperP )% name )) // \" (\" // trim ( adjustl ( idstrj )) & // \") is too small at t = \" // trim ( adjustl ( timestr )) tp % ldiscard ( i ) = . true . tp % lmask ( i ) = . false . call tp % info ( i )% set_value ( status = \"DISCARDED_PLQ\" , discard_time = t , discard_xh = tp % xh (:, i ), discard_vh = tp % vh (:, i ), discard_body_id = pl % id ( iplperP )) end if end if end associate end do ! Call the base method that this overrides call discard_tp ( tp , system , param ) end associate end subroutine rmvs_discard_tp end submodule s_rmvs_discard","tags":"","loc":"sourcefile/rmvs_discard.f90.html"},{"title":"rmvs_util.f90 – swiftest","text":"This file depends on sourcefile~~rmvs_util.f90~~EfferentGraph sourcefile~rmvs_util.f90 rmvs_util.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~rmvs_util.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~rmvs_util.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_rmvs_util Source Code rmvs_util.f90 Source Code submodule ( rmvs_classes ) s_rmvs_util use swiftest contains module subroutine rmvs_util_append_pl ( self , source , lsource_mask ) !! author: David A. Minton !! !! Append components from one massive body object to another. !! This method will automatically resize the destination body if it is too small implicit none !! Arguments class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to select type ( source ) class is ( rmvs_pl ) associate ( nold => self % nbody , nsrc => source % nbody ) call util_append ( self % nenc , source % nenc , nold , nsrc , lsource_mask ) call util_append ( self % tpenc1P , source % tpenc1P , nold , nsrc , lsource_mask ) call util_append ( self % plind , source % plind , nold , nsrc , lsource_mask ) ! The following are not implemented as RMVS doesn't make use of fill operations on pl type ! So they are here as a placeholder in case someone wants to extend the RMVS class for some reason !call util_append(self%outer, source%outer, nold, nsrc, lsource_mask) !call util_append(self%inner, source%inner, nold, nsrc, lsource_mask) !call util_append(self%planetocentric, source%planetocentric, nold, nsrc, lsource_mask) call whm_util_append_pl ( self , source , lsource_mask ) end associate class default write ( * , * ) \"Invalid object passed to the append method. Source must be of class rmvs_pl or its descendents!\" call util_exit ( FAILURE ) end select return end subroutine rmvs_util_append_pl module subroutine rmvs_util_append_tp ( self , source , lsource_mask ) !! author: David A. Minton !! !! Append components from test particle object to another. !! This method will automatically resize the destination body if it is too small implicit none !! Arguments class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object class ( swiftest_body ), intent ( in ) :: source !! Source object to append logical , dimension (:), intent ( in ) :: lsource_mask !! Logical mask indicating which elements to append to select type ( source ) class is ( rmvs_tp ) associate ( nold => self % nbody , nsrc => source % nbody ) call util_append ( self % lperi , source % lperi , nold , nsrc , lsource_mask ) call util_append ( self % plperP , source % plperP , nold , nsrc , lsource_mask ) call util_append ( self % plencP , source % plencP , nold , nsrc , lsource_mask ) call util_append_tp ( self , source , lsource_mask ) ! Note: whm_tp does not have its own append method, so we skip back to the base class end associate class default write ( * , * ) \"Invalid object passed to the append method. Source must be of class rmvs_tp or its descendents!\" call util_exit ( FAILURE ) end select return end subroutine rmvs_util_append_tp module subroutine rmvs_util_fill_pl ( self , inserts , lfill_list ) !! author: David A. Minton !! !! Insert new RMVS massive body structure into an old one. !! This is the inverse of a fill operation. !! implicit none ! Arguments class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object class ( swiftest_body ), intent ( in ) :: inserts !! Inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps ! Internals integer ( I4B ) :: i associate ( keeps => self ) select type ( inserts ) class is ( rmvs_pl ) call util_fill ( keeps % nenc , inserts % nenc , lfill_list ) call util_fill ( keeps % tpenc1P , inserts % tpenc1P , lfill_list ) call util_fill ( keeps % plind , inserts % plind , lfill_list ) ! The following are not implemented as RMVS doesn't make use of fill operations on pl type ! So they are here as a placeholder in case someone wants to extend the RMVS class for some reason !call util_fill(keeps%outer, inserts%outer, lfill_list) !call util_fill(keeps%inner, inserts%inner, lfill_list) !call util_fill(keeps%planetocentric, inserts%planetocentric, lfill_list) call whm_util_fill_pl ( keeps , inserts , lfill_list ) class default write ( * , * ) \"Invalid object passed to the fill method. Source must be of class rmvs_pl or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine rmvs_util_fill_pl module subroutine rmvs_util_fill_tp ( self , inserts , lfill_list ) !! author: David A. Minton !! !! Insert new RMVS test particle structure into an old one. !! This is the inverse of a fill operation. !! implicit none ! Arguments class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object class ( swiftest_body ), intent ( in ) :: inserts !! Inserted object logical , dimension (:), intent ( in ) :: lfill_list !! Logical array of bodies to merge into the keeps associate ( keeps => self ) select type ( inserts ) class is ( rmvs_tp ) call util_fill ( keeps % lperi , inserts % lperi , lfill_list ) call util_fill ( keeps % plperP , inserts % plperP , lfill_list ) call util_fill ( keeps % plencP , inserts % plencP , lfill_list ) call util_fill_tp ( keeps , inserts , lfill_list ) ! Note: whm_tp does not have its own fill method, so we skip back to the base class class default write ( * , * ) \"Invalid object passed to the fill method. Source must be of class rmvs_tp or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine rmvs_util_fill_tp module subroutine rmvs_util_resize_pl ( self , nnew ) !! author: David A. Minton !! !! Checks the current size of a massive body object against the requested size and resizes it if it is too small. implicit none ! Arguments class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object integer ( I4B ), intent ( in ) :: nnew !! New size neded call util_resize ( self % nenc , nnew ) call util_resize ( self % tpenc1P , nnew ) call util_resize ( self % plind , nnew ) ! The following are not implemented as RMVS doesn't make use of resize operations on pl type ! So they are here as a placeholder in case someone wants to extend the RMVS class for some reason !call util_resize(self%outer, nnew) !call util_resize(self%inner, nnew) !call util_resize(self%planetocentric, nnew) call whm_util_resize_pl ( self , nnew ) return end subroutine rmvs_util_resize_pl module subroutine rmvs_util_resize_tp ( self , nnew ) !! author: David A. Minton !! !! Checks the current size of a test particle object against the requested size and resizes it if it is too small. implicit none ! Arguments class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object integer ( I4B ), intent ( in ) :: nnew !! New size neded call util_resize ( self % lperi , nnew ) call util_resize ( self % plperP , nnew ) call util_resize ( self % plencP , nnew ) call util_resize ( self % xheliocentric , nnew ) call util_resize_tp ( self , nnew ) return end subroutine rmvs_util_resize_tp module subroutine rmvs_util_sort_pl ( self , sortby , ascending ) !! author: David A. Minton !! !! Sort a RMVS massive body object in-place. !! sortby is a string indicating which array component to sort. implicit none ! Arguments class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order ! Internals integer ( I4B ), dimension (:), allocatable :: ind integer ( I4B ) :: direction if ( self % nbody == 0 ) return if ( ascending ) then direction = 1 else direction = - 1 end if associate ( pl => self , npl => self % nbody ) allocate ( ind ( npl )) select case ( sortby ) case ( \"nenc\" ) call util_sort ( direction * pl % nenc ( 1 : npl ), ind ( 1 : npl )) case ( \"tpenc1P\" ) call util_sort ( direction * pl % tpenc1P ( 1 : npl ), ind ( 1 : npl )) case ( \"plind\" ) call util_sort ( direction * pl % plind ( 1 : npl ), ind ( 1 : npl )) case ( \"outer\" , \"inner\" , \"planetocentric\" , \"lplanetocentric\" ) write ( * , * ) 'Cannot sort by ' // trim ( adjustl ( sortby )) // '. Component not sortable!' case default ! Look for components in the parent class call whm_util_sort_pl ( pl , sortby , ascending ) return end select call pl % rearrange ( ind ) end associate return end subroutine rmvs_util_sort_pl module subroutine rmvs_util_sort_tp ( self , sortby , ascending ) !! author: David A. Minton !! !! Sort a RMVS test particle object in-place. !! sortby is a string indicating which array component to sort. implicit none ! Arguments class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object character ( * ), intent ( in ) :: sortby !! Sorting attribute logical , intent ( in ) :: ascending !! Logical flag indicating whether or not the sorting should be in ascending or descending order ! Internals integer ( I4B ), dimension (:), allocatable :: ind integer ( I4B ) :: direction if ( self % nbody == 0 ) return if ( ascending ) then direction = 1 else direction = - 1 end if associate ( tp => self , ntp => self % nbody ) allocate ( ind ( ntp )) select case ( sortby ) case ( \"plperP\" ) call util_sort ( direction * tp % plperP ( 1 : ntp ), ind ( 1 : ntp )) case ( \"plencP\" ) call util_sort ( direction * tp % plencP ( 1 : ntp ), ind ( 1 : ntp )) case ( \"lperi\" , \"cb_heliocentric\" , \"xheliocentric\" , \"index\" , \"ipleP\" , \"lplanetocentric\" ) write ( * , * ) 'Cannot sort by ' // trim ( adjustl ( sortby )) // '. Component not sortable!' case default ! Look for components in the parent class (*NOTE whm_tp does not need its own sort method, so we go straight to the swiftest_tp method) call util_sort_tp ( tp , sortby , ascending ) return end select call tp % rearrange ( ind ) end associate return end subroutine rmvs_util_sort_tp module subroutine rmvs_util_sort_rearrange_pl ( self , ind ) !! author: David A. Minton !! !! Rearrange RMVS massive body structure in-place from an index list. !! This is a helper utility used to make polymorphic sorting work on Swiftest structures. implicit none ! Arguments class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) if ( self % nbody == 0 ) return associate ( pl => self , npl => self % nbody ) call util_sort_rearrange ( pl % nenc , ind , npl ) call util_sort_rearrange ( pl % tpenc1P , ind , npl ) call util_sort_rearrange ( pl % plind , ind , npl ) call util_sort_rearrange_pl ( pl , ind ) end associate return end subroutine rmvs_util_sort_rearrange_pl module subroutine rmvs_util_sort_rearrange_tp ( self , ind ) !! author: David A. Minton !! !! Rearrange RMVS test particle object in-place from an index list. !! This is a helper utility used to make polymorphic sorting work on Swiftest structures. implicit none ! Arguments class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object integer ( I4B ), dimension (:), intent ( in ) :: ind !! Index array used to restructure the body (should contain all 1:n index values in the desired order) if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody ) call util_sort_rearrange ( tp % lperi , ind , ntp ) call util_sort_rearrange ( tp % plperP , ind , ntp ) call util_sort_rearrange ( tp % plencP , ind , ntp ) call util_sort_rearrange ( tp % xheliocentric , ind , ntp ) call util_sort_rearrange_tp ( tp , ind ) end associate return end subroutine rmvs_util_sort_rearrange_tp module subroutine rmvs_util_spill_pl ( self , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Move spilled (discarded) RMVS test particle structure from active list to discard list !! !! Adapted from David E. Kaufmann's Swifter routine discard_discard_spill.f90 implicit none ! Arguments class ( rmvs_pl ), intent ( inout ) :: self !! RMVS massive body body object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not ! Internals integer ( I4B ) :: i associate ( keeps => self ) select type ( discards ) class is ( rmvs_pl ) call util_spill ( keeps % nenc , discards % nenc , lspill_list , ldestructive ) call util_spill ( keeps % tpenc1P , discards % tpenc1P , lspill_list , ldestructive ) call util_spill ( keeps % plind , discards % plind , lspill_list , ldestructive ) call whm_util_spill_pl ( keeps , discards , lspill_list , ldestructive ) class default write ( * , * ) \"Invalid object passed to the spill method. Source must be of class rmvs_pl or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine rmvs_util_spill_pl module subroutine rmvs_util_spill_tp ( self , discards , lspill_list , ldestructive ) !! author: David A. Minton !! !! Move spilled (discarded) RMVS test particle structure from active list to discard list !! !! Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 implicit none ! Arguments class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object class ( swiftest_body ), intent ( inout ) :: discards !! Discarded object logical , dimension (:), intent ( in ) :: lspill_list !! Logical array of bodies to spill into the discards logical , intent ( in ) :: ldestructive !! Logical flag indicating whether or not this operation should alter the keeps array or not ! Internals integer ( I4B ) :: i associate ( keeps => self ) select type ( discards ) class is ( rmvs_tp ) call util_spill ( keeps % lperi , discards % lperi , lspill_list , ldestructive ) call util_spill ( keeps % plperP , discards % plperP , lspill_list , ldestructive ) call util_spill ( keeps % plencP , discards % plencP , lspill_list , ldestructive ) call util_spill_tp ( keeps , discards , lspill_list , ldestructive ) class default write ( * , * ) \"Invalid object passed to the spill method. Source must be of class rmvs_tp or its descendents!\" call util_exit ( FAILURE ) end select end associate return end subroutine rmvs_util_spill_tp end submodule s_rmvs_util","tags":"","loc":"sourcefile/rmvs_util.f90.html"},{"title":"rmvs_kick.f90 – swiftest","text":"This file depends on sourcefile~~rmvs_kick.f90~~EfferentGraph sourcefile~rmvs_kick.f90 rmvs_kick.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~rmvs_kick.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~rmvs_kick.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_rmvs_kick Source Code rmvs_kick.f90 Source Code submodule ( rmvs_classes ) s_rmvs_kick use swiftest contains module subroutine rmvs_kick_getacch_tp ( self , system , param , t , lbeg ) !! author: David A. Minton !! !! Compute the oblateness acceleration in the inner encounter region with planets !! !! Performs a similar task as David E. Kaufmann's Swifter routine rmvs_kick_getacch_tp.f90, but !! uses object polymorphism, and so is not directly adapted. implicit none ! Arguments class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle data structure class ( swiftest_nbody_system ), intent ( inout ) :: system !! Swiftest central body particle data structuree class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current time logical , intent ( in ) :: lbeg !! Logical flag that determines whether or not this is the beginning or end of the step ! Internals class ( swiftest_parameters ), allocatable :: param_planetocen real ( DP ), dimension (:, :), allocatable :: xh_original real ( DP ) :: GMcb_original integer ( I4B ) :: i if ( self % nbody == 0 ) return associate ( tp => self , ntp => self % nbody , ipleP => self % ipleP , inner_index => self % index ) select type ( system ) class is ( rmvs_nbody_system ) if ( system % lplanetocentric ) then ! This is a close encounter step, so any accelerations requiring heliocentric position values ! must be handeled outside the normal WHM method call select type ( pl => system % pl ) class is ( rmvs_pl ) select type ( cb => system % cb ) class is ( rmvs_cb ) associate ( xpc => pl % xh , xpct => self % xh , apct => self % ah , system_planetocen => system ) system_planetocen % lbeg = lbeg ! Save the original heliocentric position for later allocate ( xh_original , source = tp % xh ) ! Temporarily turn off the heliocentric-dependent acceleration terms during an inner encounter using a copy of the parameter list with all of the heliocentric-specific acceleration terms turned off allocate ( param_planetocen , source = param ) param_planetocen % loblatecb = . false . param_planetocen % lextra_force = . false . param_planetocen % lgr = . false . ! Compute the planetocentric values of acceleration call whm_kick_getacch_tp ( tp , system_planetocen , param_planetocen , t , lbeg ) ! Now compute any heliocentric values of acceleration if ( tp % lfirst ) then do concurrent ( i = 1 : ntp , tp % lmask ( i )) tp % xheliocentric (:, i ) = tp % xh (:, i ) + cb % inner ( inner_index - 1 )% x (:, 1 ) end do else do concurrent ( i = 1 : ntp , tp % lmask ( i )) tp % xheliocentric (:, i ) = tp % xh (:, i ) + cb % inner ( inner_index )% x (:, 1 ) end do end if ! Swap the planetocentric and heliocentric position vectors and central body masses do concurrent ( i = 1 : ntp , tp % lmask ( i )) tp % xh (:, i ) = tp % xheliocentric (:, i ) end do GMcb_original = cb % Gmass cb % Gmass = tp % cb_heliocentric % Gmass ! If the heliocentric-specifc acceleration terms are requested, compute those now if ( param % loblatecb ) call tp % accel_obl ( system_planetocen ) if ( param % lextra_force ) call tp % accel_user ( system_planetocen , param , t , lbeg ) if ( param % lgr ) call tp % accel_gr ( param ) ! Put everything back the way we found it call move_alloc ( xh_original , tp % xh ) cb % Gmass = GMcb_original end associate end select end select else ! Not a close encounter, so just proceded with the standard WHM method call whm_kick_getacch_tp ( tp , system , param , t , lbeg ) end if end select end associate return end subroutine rmvs_kick_getacch_tp end submodule s_rmvs_kick","tags":"","loc":"sourcefile/rmvs_kick.f90.html"},{"title":"rmvs_io.f90 – swiftest","text":"This file depends on sourcefile~~rmvs_io.f90~~EfferentGraph sourcefile~rmvs_io.f90 rmvs_io.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~rmvs_io.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~rmvs_io.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_rmvs_io Source Code rmvs_io.f90 Source Code submodule ( rmvs_classes ) s_rmvs_io use swiftest contains module subroutine rmvs_io_write_encounter ( t , id1 , id2 , Gmass1 , Gmass2 , radius1 , radius2 , & xh1 , xh2 , vh1 , vh2 , enc_out ) !! author: David A. Minton !! !! Write close encounter data from RMVS to output binary files !!  There is no direct file output from this subroutine !! !! Adapted from David E. Kaufmann's Swifter routine: io_write_encounter.f90 !! Adapted from Hal Levison's Swift routine io_write_encounter.f implicit none ! Arguments integer ( I4B ), intent ( in ) :: id1 , id2 real ( DP ), intent ( in ) :: t , Gmass1 , Gmass2 , radius1 , radius2 real ( DP ), dimension (:), intent ( in ) :: xh1 , xh2 , vh1 , vh2 character ( * ), intent ( in ) :: enc_out ! Internals logical , save :: lfirst = . true . integer ( I4B ), parameter :: LUN = 30 integer ( I4B ) :: ierr if ( enc_out == \"\" ) return open ( unit = LUN , file = enc_out , status = 'OLD' , position = 'APPEND' , form = 'UNFORMATTED' , iostat = ierr ) if (( ierr /= 0 ) . and . lfirst ) then open ( unit = LUN , file = enc_out , status = 'NEW' , form = 'UNFORMATTED' , iostat = ierr ) end if if ( ierr /= 0 ) then write ( * , * ) \"Swiftest Error:\" write ( * , * ) \"   Unable to open binary encounter file\" call util_exit ( FAILURE ) end if lfirst = . false . call io_write_frame_encounter ( LUN , t , id1 , id2 , Gmass1 , Gmass2 , radius1 , radius2 , xh1 , xh2 , vh1 , vh2 ) close ( unit = LUN , iostat = ierr ) if ( ierr /= 0 ) then write ( * , * ) \"Swiftest Error:\" write ( * , * ) \"   Unable to close binary encounter file\" call util_exit ( FAILURE ) end if return end subroutine rmvs_io_write_encounter end submodule s_rmvs_io","tags":"","loc":"sourcefile/rmvs_io.f90.html"},{"title":"rmvs_setup.f90 – swiftest","text":"This file depends on sourcefile~~rmvs_setup.f90~~EfferentGraph sourcefile~rmvs_setup.f90 rmvs_setup.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~rmvs_setup.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~rmvs_setup.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_rmvs_setup Source Code rmvs_setup.f90 Source Code submodule ( rmvs_classes ) s_rmvs_setup use swiftest contains module subroutine rmvs_setup_pl ( self , n , param ) !! author: David A. Minton !! !! Allocate RMVS test particle structure !! !! Equivalent in functionality to David E. Kaufmann's Swifter routine rmvs_setup.f90 implicit none ! Arguments class ( rmvs_pl ), intent ( inout ) :: self !! RMVS test particle object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameter ! Internals integer ( I4B ) :: i , j !> Call allocation method for parent class associate ( pl => self ) call whm_setup_pl ( pl , n , param ) if ( n < 0 ) return if ( allocated ( pl % outer )) deallocate ( pl % outer ) if ( allocated ( pl % inner )) deallocate ( pl % inner ) if ( allocated ( pl % nenc )) deallocate ( pl % nenc ) if ( n == 0 ) return allocate ( pl % outer ( 0 : NTENC )) allocate ( pl % inner ( 0 : NTPHENC )) if (. not . pl % lplanetocentric ) then allocate ( pl % nenc ( n )) pl % nenc (:) = 0 ! Set up inner and outer planet interpolation vector storage containers do i = 0 , NTENC allocate ( pl % outer ( i )% x ( NDIM , n )) allocate ( pl % outer ( i )% v ( NDIM , n )) pl % outer ( i )% x (:,:) = 0.0_DP pl % outer ( i )% v (:,:) = 0.0_DP end do do i = 0 , NTPHENC allocate ( pl % inner ( i )% x ( NDIM , n )) allocate ( pl % inner ( i )% v ( NDIM , n )) pl % inner ( i )% x (:,:) = 0.0_DP pl % inner ( i )% v (:,:) = 0.0_DP end do if ( param % loblatecb ) then do i = 0 , NTPHENC allocate ( pl % inner ( i )% aobl ( NDIM , n )) pl % inner ( i )% aobl (:,:) = 0.0_DP end do end if if ( param % ltides ) then do i = 0 , NTPHENC allocate ( pl % inner ( i )% atide ( NDIM , n )) pl % inner ( i )% atide (:,:) = 0.0_DP end do end if end if end associate return end subroutine rmvs_setup_pl module subroutine rmvs_setup_initialize_system ( self , param ) !! author: David A. Minton !! !! Initialize an RMVS nbody system from files and sets up the planetocentric structures. !! !! We currently rearrange the pl order to keep it consistent with the way Swifter does it !! In Swifter, the central body occupies the first position in the pl list, and during !! encounters, the encountering planet is skipped in loops. In Swiftest, we instantiate an !! RMVS nbody system object attached to each pl to store planetocentric versions of the system !! to use during close encounters. implicit none ! Arguments class ( rmvs_nbody_system ), intent ( inout ) :: self !! RMVS system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i , j ! Call parent method call whm_setup_initialize_system ( self , param ) ! Set up the pl-tp planetocentric encounter structures for pl and cb. The planetocentric tp structures are ! generated as necessary during close encounter steps. select type ( pl => self % pl ) class is ( rmvs_pl ) select type ( cb => self % cb ) class is ( rmvs_cb ) select type ( tp => self % tp ) class is ( rmvs_tp ) tp % cb_heliocentric = cb pl % lplanetocentric = . false . tp % lplanetocentric = . false . cb % lplanetocentric = . false . associate ( npl => pl % nbody ) allocate ( pl % planetocentric ( npl )) pl % planetocentric (:)% lplanetocentric = . true . do i = 1 , npl allocate ( pl % planetocentric ( i )% cb , source = cb ) allocate ( rmvs_pl :: pl % planetocentric ( i )% pl ) select type ( cbenci => pl % planetocentric ( i )% cb ) class is ( rmvs_cb ) select type ( plenci => pl % planetocentric ( i )% pl ) class is ( rmvs_pl ) cbenci % lplanetocentric = . true . plenci % lplanetocentric = . true . call plenci % setup ( npl , param ) plenci % status (:) = ACTIVE plenci % lmask (:) = . true . ! plind stores the heliocentric index value of a planetocentric planet ! e.g. Consider an encounter with planet 3. ! Then the following will be the values of plind: ! pl%planetocentric(3)%pl%plind(1) = 0 (central body - never used) ! pl%planetocentric(3)%pl%plind(2) = 1 ! pl%planetocentric(3)%pl%plind(3) = 2 ! pl%planetocentric(3)%pl%plind(4) = 4 ! pl%planetocentric(3)%pl%plind(5) = 5 ! etc. allocate ( plenci % plind ( npl )) plenci % plind ( 1 : npl ) = [( j , j = 1 , npl )] plenci % plind ( 2 : npl ) = pack ( plenci % plind ( 1 : npl ), plenci % plind ( 1 : npl ) /= i ) plenci % plind ( 1 ) = 0 plenci % Gmass ( 1 ) = cb % Gmass plenci % Gmass ( 2 : npl ) = pl % Gmass ( plenci % plind ( 2 : npl )) cbenci % Gmass = pl % Gmass ( i ) end select end select end do end associate end select end select end select return end subroutine rmvs_setup_initialize_system module subroutine rmvs_setup_tp ( self , n , param ) !! author: David A. Minton !! !! Allocate WHM test particle structure !! !! Equivalent in functionality to David E. Kaufmann's Swifter routine whm_setup.f90 implicit none ! Arguments class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object integer ( I4B ), intent ( in ) :: n !! Number of particles to allocate space for class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameter !> Call allocation method for parent class. In this case, whm does not have its own setup method, so we use the base method for swiftest_tp call setup_tp ( self , n , param ) if ( n < 0 ) return if ( allocated ( self % lperi )) deallocate ( self % lperi ) if ( allocated ( self % plperP )) deallocate ( self % plperP ) if ( allocated ( self % plencP )) deallocate ( self % plencP ) if ( n == 0 ) return allocate ( self % lperi ( n )) allocate ( self % plperP ( n )) allocate ( self % plencP ( n )) if ( self % lplanetocentric ) then if ( allocated ( self % xheliocentric )) deallocate ( self % xheliocentric ) allocate ( self % xheliocentric ( NDIM , n )) end if self % lperi (:) = . false . return end subroutine rmvs_setup_tp end submodule s_rmvs_setup","tags":"","loc":"sourcefile/rmvs_setup.f90.html"},{"title":"rmvs_step.f90 – swiftest","text":"This file depends on sourcefile~~rmvs_step.f90~~EfferentGraph sourcefile~rmvs_step.f90 rmvs_step.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~rmvs_step.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~rmvs_step.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_rmvs_step Source Code rmvs_step.f90 Source Code submodule ( rmvs_classes ) s_rmvs_step use swiftest contains module subroutine rmvs_step_system ( self , param , t , dt ) !! author: David A. Minton !! !! Step massive bodies and and active test particles ahead in heliocentric coordinates !! !! Adapted from Hal Levison's Swift routine rmvs3_step.f !! Adapted from David E. Kaufmann's Swifter routine rmvs_step.f90 implicit none ! Arguments class ( rmvs_nbody_system ), intent ( inout ) :: self !! RMVS nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Current stepsiz ! Internals logical :: lencounter , lfirstpl , lfirsttp real ( DP ) :: rts real ( DP ), dimension (:,:), allocatable :: xbeg , xend , vbeg integer ( I4B ) :: i if ( self % tp % nbody == 0 ) call whm_step_system ( self , param , t , dt ) select type ( cb => self % cb ) class is ( rmvs_cb ) select type ( pl => self % pl ) class is ( rmvs_pl ) select type ( tp => self % tp ) class is ( rmvs_tp ) associate ( system => self , ntp => tp % nbody , npl => pl % nbody ) allocate ( xbeg , source = pl % xh ) allocate ( vbeg , source = pl % vh ) call pl % set_beg_end ( xbeg = xbeg , vbeg = vbeg ) ! ****** Check for close encounters ***** ! system % rts = RHSCALE lencounter = tp % encounter_check ( system , dt ) if ( lencounter ) then lfirstpl = pl % lfirst pl % outer ( 0 )% x (:, 1 : npl ) = xbeg (:, 1 : npl ) pl % outer ( 0 )% v (:, 1 : npl ) = vbeg (:, 1 : npl ) call pl % step ( system , param , t , dt ) pl % outer ( NTENC )% x (:, 1 : npl ) = pl % xh (:, 1 : npl ) pl % outer ( NTENC )% v (:, 1 : npl ) = pl % vh (:, 1 : npl ) call rmvs_interp_out ( cb , pl , dt ) call rmvs_step_out ( cb , pl , tp , system , param , t , dt ) tp % lmask ( 1 : ntp ) = . not . tp % lmask ( 1 : ntp ) call pl % set_beg_end ( xbeg = xbeg , xend = xend ) tp % lfirst = . true . call tp % step ( system , param , t , dt ) tp % lmask ( 1 : ntp ) = . true . pl % lfirst = lfirstpl tp % lfirst = . true . if ( param % ltides ) call system % step_spin ( param , t , dt ) else call whm_step_system ( system , param , t , dt ) end if end associate end select end select end select return end subroutine rmvs_step_system subroutine rmvs_interp_out ( cb , pl , dt ) !! author: David A. Minton !! !! Interpolate planet positions between two Keplerian orbits in outer encounter region !! !! Adapted from David E. Kaufmann's Swifter routine rmvs_interp_out.f90 !! !! Adapted from Hal Levison's Swift routine rmvs3_interp.f implicit none ! Arguments class ( rmvs_cb ), intent ( inout ) :: cb !! RMVS central body object class ( rmvs_pl ), intent ( inout ) :: pl !! RMVS massive body object real ( DP ), intent ( in ) :: dt !! Step size ! Internals integer ( I4B ) :: i , outer_index real ( DP ) :: frac , dntenc real ( DP ), dimension (:,:), allocatable :: xtmp , vtmp real ( DP ), dimension (:), allocatable :: GMcb , dto integer ( I4B ), dimension (:), allocatable :: iflag dntenc = real ( NTENC , kind = DP ) associate ( npl => pl % nbody ) allocate ( xtmp , mold = pl % xh ) allocate ( vtmp , mold = pl % vh ) allocate ( GMcb ( npl )) allocate ( dto ( npl )) allocate ( iflag ( npl )) dto ( 1 : npl ) = dt / dntenc GMcb ( 1 : npl ) = cb % Gmass xtmp (:, 1 : npl ) = pl % outer ( 0 )% x (:, 1 : npl ) vtmp (:, 1 : npl ) = pl % outer ( 0 )% v (:, 1 : npl ) do outer_index = 1 , NTENC - 1 call drift_one ( GMcb ( 1 : npl ), xtmp ( 1 , 1 : npl ), xtmp ( 2 , 1 : npl ), xtmp ( 3 , 1 : npl ), & vtmp ( 1 , 1 : npl ), vtmp ( 2 , 1 : npl ), vtmp ( 3 , 1 : npl ), & dto ( 1 : npl ), iflag ( 1 : npl )) if ( any ( iflag ( 1 : npl ) /= 0 )) then do i = 1 , npl if ( iflag ( i ) /= 0 ) then write ( * , * ) \" Planet \" , pl % id ( i ), \" is lost!!!!!!!!!!\" write ( * , * ) GMcb ( i ), dto ( i ) write ( * , * ) xtmp (:, i ) write ( * , * ) vtmp (:, i ) write ( * , * ) \" STOPPING \" call util_exit ( FAILURE ) end if end do end if frac = 1.0_DP - outer_index / dntenc pl % outer ( outer_index )% x (:, 1 : npl ) = frac * xtmp (:, 1 : npl ) pl % outer ( outer_index )% v (:, 1 : npl ) = frac * vtmp (:, 1 : npl ) end do xtmp (:, 1 : npl ) = pl % outer ( NTENC )% x (:, 1 : npl ) vtmp (:, 1 : npl ) = pl % outer ( NTENC )% v (:, 1 : npl ) do outer_index = NTENC - 1 , 1 , - 1 call drift_one ( GMcb ( 1 : npl ), xtmp ( 1 , 1 : npl ), xtmp ( 2 , 1 : npl ), xtmp ( 3 , 1 : npl ), & vtmp ( 1 , 1 : npl ), vtmp ( 2 , 1 : npl ), vtmp ( 3 , 1 : npl ), & - dto ( 1 : npl ), iflag ( 1 : npl )) if ( any ( iflag ( 1 : npl ) /= 0 )) then do i = 1 , npl if ( iflag ( i ) /= 0 ) then write ( * , * ) \" Planet \" , pl % id ( i ), \" is lost!!!!!!!!!!\" write ( * , * ) GMcb ( i ), - dto ( i ) write ( * , * ) xtmp (:, i ) write ( * , * ) vtmp (:, i ) write ( * , * ) \" STOPPING \" call util_exit ( FAILURE ) end if end do end if frac = outer_index / dntenc pl % outer ( outer_index )% x (:, 1 : npl ) = pl % outer ( outer_index )% x (:, 1 : npl ) + frac * xtmp (:, 1 : npl ) pl % outer ( outer_index )% v (:, 1 : npl ) = pl % outer ( outer_index )% v (:, 1 : npl ) + frac * vtmp (:, 1 : npl ) end do end associate return end subroutine rmvs_interp_out subroutine rmvs_step_out ( cb , pl , tp , system , param , t , dt ) !! author: David A. Minton !! !! Step ACTIVE test particles ahead in the outer encounter region, setting up and calling the inner region !!    integration if necessar !! !! Adapted from Hal Levison's Swift routines rmvs3_step_out.f and rmvs3_step_out2.f !! Adapted from David E. Kaufmann's Swifter routines rmvs_step_out.f90 and rmvs_step_out2.f90 implicit none ! Arguments class ( rmvs_cb ), intent ( inout ) :: cb !! RMVS central body object class ( rmvs_pl ), intent ( inout ) :: pl !! RMVS massive body object class ( rmvs_tp ), intent ( inout ) :: tp !! RMVS test particle object class ( rmvs_nbody_system ), intent ( inout ) :: system !! RMVS nbody system object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: t !! Current simulation time real ( DP ), intent ( in ) :: dt !! Current stepsiz ! Internals integer ( I4B ) :: outer_index , j , k real ( DP ) :: dto , outer_time , rts logical :: lencounter , lfirsttp associate ( npl => pl % nbody , ntp => tp % nbody ) dto = dt / NTENC where ( tp % plencP ( 1 : ntp ) == 0 ) tp % lmask ( 1 : ntp ) = . false . elsewhere tp % lperi ( 1 : ntp ) = . false . end where do outer_index = 1 , NTENC outer_time = t + ( outer_index - 1 ) * dto call pl % set_beg_end ( xbeg = pl % outer ( outer_index - 1 )% x (:, 1 : npl ), & vbeg = pl % outer ( outer_index - 1 )% v (:, 1 : npl ), & xend = pl % outer ( outer_index )% x (:, 1 : npl )) system % rts = RHPSCALE lencounter = tp % encounter_check ( system , dto ) if ( lencounter ) then ! Interpolate planets in inner encounter region call rmvs_interp_in ( cb , pl , system , param , dto , outer_index ) ! Step through the inner region call rmvs_step_in ( cb , pl , tp , param , outer_time , dto ) lfirsttp = tp % lfirst tp % lfirst = . true . call tp % step ( system , param , outer_time , dto ) tp % lfirst = lfirsttp else call tp % step ( system , param , outer_time , dto ) end if do j = 1 , npl if ( pl % nenc ( j ) == 0 ) cycle tp % lfirst = . true . where (( tp % plencP ( 1 : ntp ) == j ) . and . (. not . tp % lmask ( 1 : ntp ))) tp % lmask ( 1 : ntp ) = . true . end where end do end do end associate return end subroutine rmvs_step_out subroutine rmvs_interp_in ( cb , pl , system , param , dt , outer_index ) !! author: David A. Minton !! !! Interpolate planet positions between two Keplerian orbits in inner encounter regio !! !! Adapted from David E. Kaufmann's Swifter routine rmvs_interp_in.f90 !! !! Adapted from Hal Levison's Swift routine rmvs3_interp.f implicit none ! Arguments class ( rmvs_cb ), intent ( inout ) :: cb !! RMVS cenral body object class ( rmvs_pl ), intent ( inout ) :: pl !! RMVS massive body object class ( rmvs_nbody_system ), intent ( inout ) :: system !! RMVS nbody system object class ( swiftest_parameters ), intent ( in ) :: param !! Swiftest parameters file real ( DP ), intent ( in ) :: dt !! Step size integer ( I4B ), intent ( in ) :: outer_index !! Outer substep number within current set ! Internals integer ( I4B ) :: i , inner_index real ( DP ) :: frac , dntphenc real ( DP ), dimension (:,:), allocatable :: xtmp , vtmp , xh_original , ah_original real ( DP ), dimension (:), allocatable :: GMcb , dti integer ( I4B ), dimension (:), allocatable :: iflag associate ( npl => system % pl % nbody ) dntphenc = real ( NTPHENC , kind = DP ) ! Set the endpoints of the inner region from the outer region values in the current outer step index pl % inner ( 0 )% x (:, 1 : npl ) = pl % outer ( outer_index - 1 )% x (:, 1 : npl ) pl % inner ( 0 )% v (:, 1 : npl ) = pl % outer ( outer_index - 1 )% v (:, 1 : npl ) pl % inner ( NTPHENC )% x (:, 1 : npl ) = pl % outer ( outer_index )% x (:, 1 : npl ) pl % inner ( NTPHENC )% v (:, 1 : npl ) = pl % outer ( outer_index )% v (:, 1 : npl ) allocate ( xtmp , mold = pl % xh ) allocate ( vtmp , mold = pl % vh ) allocate ( GMcb ( npl )) allocate ( dti ( npl )) allocate ( iflag ( npl )) dti ( 1 : npl ) = dt / dntphenc GMcb ( 1 : npl ) = cb % Gmass xtmp (:, 1 : npl ) = pl % inner ( 0 )% x (:, 1 : npl ) vtmp (:, 1 : npl ) = pl % inner ( 0 )% v (:, 1 : npl ) if (( param % loblatecb ) . or . ( param % ltides )) then allocate ( xh_original , source = pl % xh ) allocate ( ah_original , source = pl % ah ) pl % xh (:, 1 : npl ) = xtmp (:, 1 : npl ) ! Temporarily replace heliocentric position with inner substep values to calculate the oblateness terms end if if ( param % loblatecb ) then call pl % accel_obl ( system ) pl % inner ( 0 )% aobl (:, 1 : npl ) = pl % aobl (:, 1 : npl ) ! Save the oblateness acceleration on the planet for this substep end if if ( param % ltides ) then call pl % accel_tides ( system ) pl % inner ( 0 )% atide (:, 1 : npl ) = pl % atide (:, 1 : npl ) ! Save the oblateness acceleration on the planet for this substep end if do inner_index = 1 , NTPHENC - 1 call drift_one ( GMcb ( 1 : npl ), xtmp ( 1 , 1 : npl ), xtmp ( 2 , 1 : npl ), xtmp ( 3 , 1 : npl ), & vtmp ( 1 , 1 : npl ), vtmp ( 2 , 1 : npl ), vtmp ( 3 , 1 : npl ), & dti ( 1 : npl ), iflag ( 1 : npl )) if ( any ( iflag ( 1 : npl ) /= 0 )) then do i = 1 , npl if ( iflag ( i ) /= 0 ) then write ( * , * ) \" Planet \" , pl % id ( i ), \" is lost!!!!!!!!!!\" write ( * , * ) GMcb ( i ), dti ( i ) write ( * , * ) xtmp (:, i ) write ( * , * ) vtmp (:, i ) write ( * , * ) \" STOPPING \" call util_exit ( failure ) end if end do end if frac = 1.0_DP - inner_index / dntphenc pl % inner ( inner_index )% x (:, 1 : npl ) = frac * xtmp (:, 1 : npl ) pl % inner ( inner_index )% v (:, 1 : npl ) = frac * vtmp (:, 1 : npl ) end do xtmp (:, 1 : npl ) = pl % inner ( NTPHENC )% x (:, 1 : npl ) vtmp (:, 1 : npl ) = pl % inner ( NTPHENC )% v (:, 1 : npl ) do inner_index = NTPHENC - 1 , 1 , - 1 call drift_one ( GMcb ( 1 : npl ), xtmp ( 1 , 1 : npl ), xtmp ( 2 , 1 : npl ), xtmp ( 3 , 1 : npl ), & vtmp ( 1 , 1 : npl ), vtmp ( 2 , 1 : npl ), vtmp ( 3 , 1 : npl ), & - dti ( 1 : npl ), iflag ( 1 : npl )) if ( any ( iflag ( 1 : npl ) /= 0 )) then do i = 1 , npl if ( iflag ( i ) /= 0 ) then write ( * , * ) \" Planet \" , pl % id ( i ), \" is lost!!!!!!!!!!\" write ( * , * ) GMcb ( i ), - dti ( i ) write ( * , * ) xtmp (:, i ) write ( * , * ) vtmp (:, i ) write ( * , * ) \" STOPPING \" call util_exit ( failure ) end if end do end if frac = inner_index / dntphenc pl % inner ( inner_index )% x (:, 1 : npl ) = pl % inner ( inner_index )% x (:, 1 : npl ) + frac * xtmp (:, 1 : npl ) pl % inner ( inner_index )% v (:, 1 : npl ) = pl % inner ( inner_index )% v (:, 1 : npl ) + frac * vtmp (:, 1 : npl ) if ( param % loblatecb ) then pl % xh (:, 1 : npl ) = pl % inner ( inner_index )% x (:, 1 : npl ) call pl % accel_obl ( system ) pl % inner ( inner_index )% aobl (:, 1 : npl ) = pl % aobl (:, 1 : npl ) end if if ( param % ltides ) then call pl % accel_tides ( system ) pl % inner ( inner_index )% atide (:, 1 : npl ) = pl % atide (:, 1 : npl ) end if end do if ( param % loblatecb ) then ! Calculate the final value of oblateness accelerations at the final inner substep pl % xh (:, 1 : npl ) = pl % inner ( NTPHENC )% x (:, 1 : npl ) call pl % accel_obl ( system ) pl % inner ( NTPHENC )% aobl (:, 1 : npl ) = pl % aobl (:, 1 : npl ) end if if ( param % ltides ) then call pl % accel_tides ( system ) pl % inner ( NTPHENC )% atide (:, 1 : npl ) = pl % atide (:, 1 : npl ) end if ! Put the planet positions and accelerations back into place if ( allocated ( xh_original )) call move_alloc ( xh_original , pl % xh ) if ( allocated ( ah_original )) call move_alloc ( ah_original , pl % ah ) end associate return end subroutine rmvs_interp_in subroutine rmvs_step_in ( cb , pl , tp , param , outer_time , dto ) !! author: David A. Minton !! !! Step active test particles ahead in the inner encounter region !! !! Adapted from Hal Levison's Swift routine rmvs3_step_in.f !! Adapted from David E. Kaufmann's Swifter routine rmvs_step_in.f90 implicit none ! Arguments class ( rmvs_cb ), intent ( inout ) :: cb !! RMVS central body object class ( rmvs_pl ), intent ( inout ) :: pl !! RMVS massive body object class ( rmvs_tp ), intent ( inout ) :: tp !! RMVS test particle object class ( swiftest_parameters ), intent ( inout ) :: param !! Current run configuration parameters real ( DP ), intent ( in ) :: outer_time !! Current time real ( DP ), intent ( in ) :: dto !! Outer step size ! Internals logical :: lfirsttp integer ( I4B ) :: i , j , ipleP real ( DP ) :: dti , inner_time associate ( npl => pl % nbody ) dti = dto / NTPHENC call rmvs_make_planetocentric ( param , cb , pl , tp ) do i = 1 , npl if ( pl % nenc ( i ) == 0 ) cycle select type ( planetocen_system => pl % planetocentric ( i )) class is ( rmvs_nbody_system ) select type ( cbenci => planetocen_system % cb ) class is ( rmvs_cb ) select type ( plenci => planetocen_system % pl ) class is ( rmvs_pl ) select type ( tpenci => planetocen_system % tp ) class is ( rmvs_tp ) associate ( inner_index => tpenci % index ) ! There are inner encounters with this planet...switch to planetocentric coordinates to proceed tpenci % lfirst = . true . inner_time = outer_time call rmvs_peri_tp ( tpenci , pl , inner_time , dti , . true ., 0 , i , param ) ! now step the encountering test particles fully through the inner encounter lfirsttp = . true . do inner_index = 1 , NTPHENC ! Integrate over the encounter region, using the \"substitute\" planetocentric systems at each level plenci % xh (:, 1 : npl ) = plenci % inner ( inner_index - 1 )% x (:, 1 : npl ) call plenci % set_beg_end ( xbeg = plenci % inner ( inner_index - 1 )% x , & xend = plenci % inner ( inner_index )% x ) if ( param % loblatecb ) then cbenci % aoblbeg = cbenci % inner ( inner_index - 1 )% aobl (:, 1 ) cbenci % aoblend = cbenci % inner ( inner_index )% aobl (:, 1 ) end if if ( param % ltides ) then cbenci % atidebeg = cbenci % inner ( inner_index - 1 )% atide (:, 1 ) cbenci % atideend = cbenci % inner ( inner_index )% atide (:, 1 ) end if call tpenci % step ( planetocen_system , param , inner_time , dti ) do j = 1 , pl % nenc ( i ) tpenci % xheliocentric (:, j ) = tpenci % xh (:, j ) + pl % inner ( inner_index )% x (:, i ) end do inner_time = outer_time + j * dti call rmvs_peri_tp ( tpenci , pl , inner_time , dti , . false ., inner_index , i , param ) end do tpenci % lmask (:) = . false . end associate end select end select end select end select end do call rmvs_end_planetocentric ( pl , tp ) end associate return end subroutine rmvs_step_in subroutine rmvs_make_planetocentric ( param , cb , pl , tp ) !! author: David A. Minton !! !! When encounters are detected, this method will call the interpolation methods for the planets and !! creates a Swiftest test particle structure for each planet's encountering test particles to simplify the !! planetocentric calculations. This subroutine is not based on an existing one from Swift and Swifter !! implicit none ! Arguments class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration paramete class ( rmvs_cb ), intent ( inout ) :: cb !! RMVS central body object class ( rmvs_pl ), intent ( inout ) :: pl !! RMVS massive body object class ( rmvs_tp ), intent ( inout ) :: tp !! RMVS test particle object ! Internals integer ( I4B ) :: i , j , inner_index , ipc2hc logical , dimension (:), allocatable :: encmask associate ( npl => pl % nbody , ntp => tp % nbody ) do i = 1 , npl if ( pl % nenc ( i ) == 0 ) cycle ! There are inner encounters with this planet if ( allocated ( encmask )) deallocate ( encmask ) allocate ( encmask ( ntp )) encmask ( 1 : ntp ) = tp % plencP ( 1 : ntp ) == i allocate ( rmvs_tp :: pl % planetocentric ( i )% tp ) ! Create encountering test particle structure select type ( cbenci => pl % planetocentric ( i )% cb ) class is ( rmvs_cb ) select type ( plenci => pl % planetocentric ( i )% pl ) class is ( rmvs_pl ) select type ( tpenci => pl % planetocentric ( i )% tp ) class is ( rmvs_tp ) tpenci % lplanetocentric = . true . associate ( nenci => pl % nenc ( i )) call tpenci % setup ( nenci , param ) tpenci % cb_heliocentric = cb tpenci % ipleP = i tpenci % lmask ( 1 : nenci ) = . true . tpenci % status ( 1 : nenci ) = ACTIVE ! Grab all the encountering test particles and convert them to a planetocentric frame tpenci % id ( 1 : nenci ) = pack ( tp % id ( 1 : ntp ), encmask ( 1 : ntp )) do j = 1 , NDIM tpenci % xheliocentric ( j , 1 : nenci ) = pack ( tp % xh ( j , 1 : ntp ), encmask (:)) tpenci % xh ( j , 1 : nenci ) = tpenci % xheliocentric ( j , 1 : nenci ) - pl % inner ( 0 )% x ( j , i ) tpenci % vh ( j , 1 : nenci ) = pack ( tp % vh ( j , 1 : ntp ), encmask ( 1 : ntp )) - pl % inner ( 0 )% v ( j , i ) end do tpenci % lperi ( 1 : nenci ) = pack ( tp % lperi ( 1 : ntp ), encmask ( 1 : ntp )) tpenci % plperP ( 1 : nenci ) = pack ( tp % plperP ( 1 : ntp ), encmask ( 1 : ntp )) ! Make sure that the test particles get the planetocentric value of mu allocate ( cbenci % inner ( 0 : NTPHENC )) do inner_index = 0 , NTPHENC allocate ( plenci % inner ( inner_index )% x , mold = pl % inner ( inner_index )% x ) allocate ( plenci % inner ( inner_index )% v , mold = pl % inner ( inner_index )% x ) allocate ( cbenci % inner ( inner_index )% x ( NDIM , 1 )) allocate ( cbenci % inner ( inner_index )% v ( NDIM , 1 )) cbenci % inner ( inner_index )% x (:, 1 ) = pl % inner ( inner_index )% x (:, i ) cbenci % inner ( inner_index )% v (:, 1 ) = pl % inner ( inner_index )% v (:, i ) plenci % inner ( inner_index )% x (:, 1 ) = - cbenci % inner ( inner_index )% x (:, 1 ) plenci % inner ( inner_index )% v (:, 1 ) = - cbenci % inner ( inner_index )% v (:, 1 ) if ( param % loblatecb ) then allocate ( plenci % inner ( inner_index )% aobl , mold = pl % inner ( inner_index )% aobl ) allocate ( cbenci % inner ( inner_index )% aobl ( NDIM , 1 )) cbenci % inner ( inner_index )% aobl (:, 1 ) = pl % inner ( inner_index )% aobl (:, i ) end if if ( param % ltides ) then allocate ( plenci % inner ( inner_index )% atide , mold = pl % inner ( inner_index )% atide ) allocate ( cbenci % inner ( inner_index )% atide ( NDIM , 1 )) cbenci % inner ( inner_index )% atide (:, 1 ) = pl % inner ( inner_index )% atide (:, i ) end if do j = 2 , npl ipc2hc = plenci % plind ( j ) plenci % inner ( inner_index )% x (:, j ) = pl % inner ( inner_index )% x (:, ipc2hc ) - cbenci % inner ( inner_index )% x (:, 1 ) plenci % inner ( inner_index )% v (:, j ) = pl % inner ( inner_index )% v (:, ipc2hc ) - cbenci % inner ( inner_index )% v (:, 1 ) end do end do call tpenci % set_mu ( cbenci ) end associate end select end select end select end do end associate return end subroutine rmvs_make_planetocentric subroutine rmvs_peri_tp ( tp , pl , t , dt , lfirst , inner_index , ipleP , param ) !! author: David A. Minton !! !! Determine planetocentric pericenter passages for test particles in close encounters with a planet !! !! Adapted from Hal Levison's Swift routine Adapted from Hal Levison's Swift routine util_peri.f !! Adapted from David E. Kaufmann's Swifter routine rmvs_peri.f90 implicit none ! Arguments class ( rmvs_tp ), intent ( inout ) :: tp !! RMVS test particle object (planetocentric) class ( rmvs_pl ), intent ( inout ) :: pl !! RMVS massive body object (heliocentric) real ( DP ), intent ( in ) :: t !! current time real ( DP ), intent ( in ) :: dt !! step size logical , intent ( in ) :: lfirst !! Logical flag indicating whether current invocation is the first integer ( I4B ), intent ( in ) :: inner_index !! Outer substep number within current set integer ( I4B ), intent ( in ) :: ipleP !!  index of RMVS planet being closely encountered class ( swiftest_parameters ), intent ( in ) :: param !! Current run configuration parameters ! Internals integer ( I4B ) :: i , id1 , id2 real ( DP ) :: r2 , mu , rhill2 , vdotr , a , peri , capm , tperi , rpl real ( DP ), dimension ( NDIM ) :: xh1 , xh2 , vh1 , vh2 rhill2 = pl % rhill ( ipleP ) ** 2 mu = pl % Gmass ( ipleP ) associate ( nenc => tp % nbody , xpc => tp % xh , vpc => tp % vh ) if ( lfirst ) then do i = 1 , nenc if ( tp % lmask ( i )) then vdotr = dot_product ( xpc (:, i ), vpc (:, i )) if ( vdotr > 0.0_DP ) then tp % isperi ( i ) = 1 else tp % isperi ( i ) = - 1 end if end if end do else do i = 1 , nenc if ( tp % lmask ( i )) then vdotr = dot_product ( xpc (:, i ), vpc (:, i )) if ( tp % isperi ( i ) == - 1 ) then if ( vdotr >= 0.0_DP ) then tp % isperi ( i ) = 0 call orbel_xv2aqt ( mu , xpc (:, i ), vpc (:, i ), a , peri , capm , tperi ) r2 = dot_product ( xpc (:, i ), xpc (:, i )) if (( abs ( tperi ) > FACQDT * dt ) . or . ( r2 > rhill2 )) peri = sqrt ( r2 ) if ( param % enc_out /= \"\" ) then id1 = pl % id ( ipleP ) rpl = pl % radius ( ipleP ) xh1 (:) = pl % inner ( inner_index )% x (:, ipleP ) vh1 (:) = pl % inner ( inner_index )% v (:, ipleP ) id2 = tp % id ( i ) xh2 (:) = xpc (:, i ) + xh1 (:) vh2 (:) = xpc (:, i ) + vh1 (:) call rmvs_io_write_encounter ( t , id1 , id2 , mu , 0.0_DP , rpl , 0.0_DP , xh1 (:), xh2 (:), vh1 (:), vh2 (:), param % enc_out ) end if if ( tp % lperi ( i )) then if ( peri < tp % peri ( i )) then tp % peri ( i ) = peri tp % plperP ( i ) = ipleP end if else tp % lperi ( i ) = . true . tp % peri ( i ) = peri tp % plperP ( i ) = ipleP end if end if else if ( vdotr > 0.0_DP ) then tp % isperi ( i ) = 1 else tp % isperi ( i ) = - 1 end if end if end if end do end if end associate return end subroutine rmvs_peri_tp subroutine rmvs_end_planetocentric ( pl , tp ) !! author: David A. Minton !! !! Deallocates all of the encountering particle data structures for next time !! implicit none ! Arguments class ( rmvs_pl ), intent ( inout ) :: pl !! RMVS massive body object class ( rmvs_tp ), intent ( inout ) :: tp !! RMVS test particle objec ! Internals integer ( I4B ) :: i , j , inner_index integer ( I4B ), dimension (:), allocatable :: tpind logical , dimension (:), allocatable :: encmask associate ( npl => pl % nbody , ntp => tp % nbody ) do i = 1 , npl if ( pl % nenc ( i ) == 0 ) cycle select type ( cbenci => pl % planetocentric ( i )% cb ) class is ( rmvs_cb ) select type ( plenci => pl % planetocentric ( i )% pl ) class is ( rmvs_pl ) select type ( tpenci => pl % planetocentric ( i )% tp ) class is ( rmvs_tp ) associate ( nenci => pl % nenc ( i )) if ( allocated ( tpind )) deallocate ( tpind ) allocate ( tpind ( nenci )) ! Index array of encountering test particles if ( allocated ( encmask )) deallocate ( encmask ) allocate ( encmask ( ntp )) encmask ( 1 : ntp ) = tp % plencP ( 1 : ntp ) == i tpind ( 1 : nenci ) = pack ([( j , j = 1 , ntp )], encmask ( 1 : ntp )) ! Copy the results of the integration back over and shift back to heliocentric reference tp % status ( tpind ( 1 : nenci )) = tpenci % status ( 1 : nenci ) tp % lmask ( tpind ( 1 : nenci )) = tpenci % lmask ( 1 : nenci ) do j = 1 , NDIM tp % xh ( j , tpind ( 1 : nenci )) = tpenci % xh ( j , 1 : nenci ) + pl % inner ( NTPHENC )% x ( j , i ) tp % vh ( j , tpind ( 1 : nenci )) = tpenci % vh ( j , 1 : nenci ) + pl % inner ( NTPHENC )% v ( j , i ) end do tp % lperi ( tpind ( 1 : nenci )) = tpenci % lperi ( 1 : nenci ) tp % plperP ( tpind ( 1 : nenci )) = tpenci % plperP ( 1 : nenci ) deallocate ( pl % planetocentric ( i )% tp ) deallocate ( cbenci % inner ) do inner_index = 0 , NTPHENC deallocate ( plenci % inner ( inner_index )% x ) deallocate ( plenci % inner ( inner_index )% v ) if ( allocated ( plenci % inner ( inner_index )% aobl )) deallocate ( plenci % inner ( inner_index )% aobl ) if ( allocated ( plenci % inner ( inner_index )% atide )) deallocate ( plenci % inner ( inner_index )% atide ) end do end associate end select end select end select end do end associate return end subroutine rmvs_end_planetocentric end submodule s_rmvs_step","tags":"","loc":"sourcefile/rmvs_step.f90.html"},{"title":"rmvs_encounter_check.f90 – swiftest","text":"This file depends on sourcefile~~rmvs_encounter_check.f90~~EfferentGraph sourcefile~rmvs_encounter_check.f90 rmvs_encounter_check.f90 sourcefile~rmvs_classes.f90 rmvs_classes.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~rmvs_classes.f90 sourcefile~swiftest.f90 swiftest.f90 sourcefile~rmvs_encounter_check.f90->sourcefile~swiftest.f90 sourcefile~whm_classes.f90 whm_classes.f90 sourcefile~rmvs_classes.f90->sourcefile~whm_classes.f90 sourcefile~swiftest_globals.f90 swiftest_globals.f90 sourcefile~rmvs_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest.f90->sourcefile~rmvs_classes.f90 sourcefile~fraggle_classes.f90 fraggle_classes.f90 sourcefile~swiftest.f90->sourcefile~fraggle_classes.f90 sourcefile~swiftest_operators.f90 swiftest_operators.f90 sourcefile~swiftest.f90->sourcefile~swiftest_operators.f90 sourcefile~symba_classes.f90 symba_classes.f90 sourcefile~swiftest.f90->sourcefile~symba_classes.f90 sourcefile~walltime_classes.f90 walltime_classes.f90 sourcefile~swiftest.f90->sourcefile~walltime_classes.f90 sourcefile~helio_classes.f90 helio_classes.f90 sourcefile~swiftest.f90->sourcefile~helio_classes.f90 sourcefile~swiftest.f90->sourcefile~whm_classes.f90 sourcefile~lambda_function.f90 lambda_function.f90 sourcefile~swiftest.f90->sourcefile~lambda_function.f90 sourcefile~swiftest.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90 swiftest_classes.f90 sourcefile~swiftest.f90->sourcefile~swiftest_classes.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~fraggle_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~swiftest_operators.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~fraggle_classes.f90 sourcefile~symba_classes.f90->sourcefile~helio_classes.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~symba_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~walltime_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~whm_classes.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~helio_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_globals.f90 sourcefile~whm_classes.f90->sourcefile~swiftest_classes.f90 sourcefile~lambda_function.f90->sourcefile~swiftest_globals.f90 sourcefile~swiftest_classes.f90->sourcefile~swiftest_globals.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules s_rmvs_chk Source Code rmvs_encounter_check.f90 Source Code submodule ( rmvs_classes ) s_rmvs_chk use swiftest contains module function rmvs_encounter_check_tp ( self , system , dt ) result ( lencounter ) !! author: David A. Minton !! !! Determine whether a test particle and planet are having or will have an encounter within the next time step !! !! Adapted from David E. Kaufmann's Swifter routine: rmvs_chk.f90 !! Adapted from Hal Levison's Swift routine rmvs3_chk.f implicit none ! Arguments class ( rmvs_tp ), intent ( inout ) :: self !! RMVS test particle object class ( rmvs_nbody_system ), intent ( inout ) :: system !! RMVS nbody system object real ( DP ), intent ( in ) :: dt !! step size ! Result logical :: lencounter !! Returns true if there is at least one close encounter ! Internals integer ( I4B ) :: i , j real ( DP ) :: xr , yr , zr , vxr , vyr , vzr real ( DP ), dimension ( system % pl % nbody ) :: r2crit logical :: lflag , lvdotr ! The minimization and linear solvers can sometimes lead to floating point exceptions. Rather than halting the code entirely if this occurs, we ! can simply fail the attempt and try again. So we need to turn off any floating point exception halting modes temporarily lencounter = . false . if ( self % nbody == 0 ) return select type ( pl => system % pl ) class is ( rmvs_pl ) associate ( tp => self , ntp => self % nbody , npl => pl % nbody , rts => system % rts ) r2crit ( 1 : npl ) = ( rts * pl % rhill ( 1 : npl )) ** 2 tp % plencP ( 1 : ntp ) = 0 !$omp parallel do default(private)& !$omp shared(npl, ntp, tp, pl, dt, r2crit) do j = 1 , npl do i = 1 , ntp if ((. not . tp % lmask ( i )). or .( tp % plencP ( i ) /= 0 )) cycle xr = tp % xh ( 1 , i ) - pl % xbeg ( 1 , j ) yr = tp % xh ( 2 , i ) - pl % xbeg ( 2 , j ) zr = tp % xh ( 3 , i ) - pl % xbeg ( 3 , j ) vxr = tp % vh ( 1 , i ) - pl % vbeg ( 1 , j ) vyr = tp % vh ( 2 , i ) - pl % vbeg ( 2 , j ) vzr = tp % vh ( 3 , i ) - pl % vbeg ( 3 , j ) call rmvs_chk_ind ( xr , yr , zr , vxr , vyr , vzr , dt , r2crit ( j ), lflag , lvdotr ) if ( lflag ) tp % plencP ( i ) = j end do pl % nenc ( j ) = count ( tp % plencP ( 1 : ntp ) == j ) end do !$omp end parallel do lencounter = any ( pl % nenc ( 1 : npl ) > 0 ) end associate end select return end function rmvs_encounter_check_tp module pure subroutine rmvs_chk_ind ( xr , yr , zr , vxr , vyr , vzr , dt , r2crit , lencounter , lvdotr ) !$omp declare simd(rmvs_chk_ind) !! author: David A. Minton !! !! Determine whether a test particle and planet are having or will have an encounter within the next time step !! !! Adapted from David E. Kaufmann's Swifter routine: rmvs_chk_ind.f90 !! Adapted from Hal Levison's Swift routine rmvs_chk_ind.f implicit none ! Arguments real ( DP ), intent ( in ) :: xr , yr , zr !! Relative distance vector components real ( DP ), intent ( in ) :: vxr , vyr , vzr !! Relative velocity vector components real ( DP ), intent ( in ) :: dt !! Step size real ( DP ), intent ( in ) :: r2crit !! Square of the critical encounter distance logical , intent ( out ) :: lencounter !! Flag indicating that an encounter has occurred logical , intent ( out ) :: lvdotr !! Logical flag indicating the direction of the v .dot. r vector ! Internals real ( DP ) :: r2min , r2 , v2 , vdotr r2 = xr ** 2 + yr ** 2 + zr ** 2 lencounter = ( r2 < r2crit ) if ( lencounter ) return vdotr = vxr * xr + vyr * yr + vzr * zr lvdotr = ( vdotr < 0.0_DP ) if (. not . lvdotr ) return v2 = vxr ** 2 + vyr ** 2 + vzr ** 2 if ( - vdotr < v2 * dt ) then r2min = r2 - vdotr ** 2 / v2 else r2min = r2 + 2 * vdotr * dt + v2 * dt ** 2 end if lencounter = ( r2min <= r2crit ) return end subroutine rmvs_chk_ind end submodule s_rmvs_chk","tags":"","loc":"sourcefile/rmvs_encounter_check.f90.html"},{"title":"tides_derivs_func – swiftest ","text":"type, extends(lambda_obj_tvar) :: tides_derivs_func Base class for an lambda function object. This object takes no additional arguments other than the dependent variable x, an array of real numbers Inherits type~~tides_derivs_func~~InheritsGraph type~tides_derivs_func tides_derivs_func lambda_obj_tvar lambda_obj_tvar type~tides_derivs_func->lambda_obj_tvar Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lambdaptr_tides_deriv xbeg xend dt Type-Bound Procedures init evalt tides_derivs_init Components Type Visibility Attributes Name Initial procedure( tidederiv ), public, pointer, nopass :: lambdaptr_tides_deriv real(kind=DP), public, dimension(:,:), allocatable :: xbeg real(kind=DP), public, dimension(:,:), allocatable :: xend real(kind=DP), public :: dt Type-Bound Procedures generic, public :: init => tides_derivs_init function tides_derivs_init (lambda, dt, xbeg, xend) result(f) Arguments Type Intent Optional Attributes Name procedure( tidederiv ) :: lambda real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), dimension(:,:) :: xbeg real(kind=DP), intent(in), dimension(:,:) :: xend Return Value type( tides_derivs_func ) procedure, public :: evalt => tides_derivs_eval function tides_derivs_eval (self, x, t) result(y) Arguments Type Intent Optional Attributes Name class( tides_derivs_func ), intent(inout) :: self real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in) :: t Return Value real(kind=DP),\n  dimension(:), allocatable procedure, public, nopass :: tides_derivs_init function tides_derivs_init (lambda, dt, xbeg, xend) result(f) Arguments Type Intent Optional Attributes Name procedure( tidederiv ) :: lambda real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), dimension(:,:) :: xbeg real(kind=DP), intent(in), dimension(:,:) :: xend Return Value type( tides_derivs_func )","tags":"","loc":"type/tides_derivs_func.html"},{"title":"rmvs_nbody_system – swiftest ","text":"type, public, extends( whm_nbody_system ) :: rmvs_nbody_system Inherits type~~rmvs_nbody_system~~InheritsGraph type~rmvs_nbody_system rmvs_nbody_system type~whm_nbody_system whm_nbody_system type~rmvs_nbody_system->type~whm_nbody_system type~swiftest_nbody_system swiftest_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~swiftest_cb swiftest_cb type~swiftest_nbody_system->type~swiftest_cb cb type~swiftest_pl swiftest_pl type~swiftest_nbody_system->type~swiftest_pl pl, pl_discards type~swiftest_tp swiftest_tp type~swiftest_nbody_system->type~swiftest_tp tp, tp_discards type~swiftest_particle_info swiftest_particle_info type~swiftest_cb->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_cb->type~swiftest_base type~swiftest_body swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_tp->type~swiftest_body type~swiftest_body->type~swiftest_particle_info info type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~rmvs_nbody_system~~InheritedByGraph type~rmvs_nbody_system rmvs_nbody_system type~rmvs_pl rmvs_pl type~rmvs_pl->type~rmvs_nbody_system planetocentric Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables cb pl tp tp_discards pl_discards GMtot ke_orbit ke_spin pe te oblpot Lorbit Lspin Ltot lbeg lplanetocentric rts vbeg Type-Bound Procedures discard conservation_report dump get_old_t_final read_frame read_particle_info write_discard write_frame write_hdr_bin write_hdr_netcdf obl_pot init_particle_info step_spin set_msys get_energy_and_momentum rescale validate_ids write_hdr initialize step Components Type Visibility Attributes Name Initial class( swiftest_cb ), public, allocatable :: cb Central body data structure class( swiftest_pl ), public, allocatable :: pl Massive body data structure class( swiftest_tp ), public, allocatable :: tp Test particle data structure class( swiftest_tp ), public, allocatable :: tp_discards Discarded test particle data structure class( swiftest_pl ), public, allocatable :: pl_discards Discarded massive body particle data structure real(kind=DP), public :: GMtot = 0.0_DP Total system mass - used for barycentric coordinate conversion real(kind=DP), public :: ke_orbit = 0.0_DP System orbital kinetic energy real(kind=DP), public :: ke_spin = 0.0_DP System spin kinetic energy real(kind=DP), public :: pe = 0.0_DP System potential energy real(kind=DP), public :: te = 0.0_DP System total energy real(kind=DP), public :: oblpot = 0.0_DP System potential energy due to oblateness of the central body real(kind=DP), public, dimension(NDIM) :: Lorbit = 0.0_DP System orbital angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lspin = 0.0_DP System spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Ltot = 0.0_DP System angular momentum vector logical, public :: lbeg True if this is the beginning of a step. This is used so that test particle steps can be calculated \n    separately from massive bodies.  Massive body variables are saved at half steps, and passed to \n    the test particles logical, public :: lplanetocentric = .false. In the RMVS integrator, only test particles are discarded\n Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations real(kind=DP), public :: rts fraction of Hill's sphere radius to use as radius of encounter region real(kind=DP), public, dimension(:,:), allocatable :: vbeg Planet velocities at beginning ot step Type-Bound Procedures procedure, public :: discard => discard_system Perform a discard step on the system interface public module subroutine discard_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: conservation_report => io_conservation_report Compute energy and momentum and print out the change with time interface public module subroutine io_conservation_report(self, param, lterminal) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Input colleciton of user-defined parameters logical, intent(in) :: lterminal Indicates whether to output information to the terminal screen procedure, public :: dump => io_dump_system Dump the state of the system to a file interface public module subroutine io_dump_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: get_old_t_final => io_get_old_t_final_system Validates the dump file to check whether the dump file initial conditions duplicate the last frame of the binary output. interface public module function io_get_old_t_final_system(self, param) result(old_t_final) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self class( swiftest_parameters ), intent(in) :: param Return Value real(kind=DP) procedure, public :: read_frame => io_read_frame_system Read in a frame of input data from file interface public module function io_read_frame_system(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: read_particle_info => io_read_particle_info_system Read in particle metadata from file interface public module subroutine io_read_particle_info_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: write_discard => io_write_discard Write out information about discarded test particles interface public module subroutine io_write_discard(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: write_frame => io_write_frame_system Append a frame of output data to file interface public module subroutine io_write_frame_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: write_hdr_bin => io_write_hdr_system Write a header for an output frame in Fortran binary format interface public module subroutine io_write_hdr_system(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest nbody system object integer(kind=I4B), intent(inout) :: iu Output file unit number class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_hdr_netcdf => netcdf_write_hdr_system Write a header for an output frame in NetCDF format interface public module subroutine netcdf_write_hdr_system(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest nbody system object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: obl_pot => obl_pot_system Compute the contribution to the total gravitational potential due solely to the oblateness of the central body interface public module subroutine obl_pot_system(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object procedure, public :: init_particle_info => setup_initialize_particle_info_system Initialize the system from input files interface public module subroutine setup_initialize_particle_info_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: step_spin => tides_step_spin_system Steps the spins of the massive & central bodies due to tides. interface public module subroutine tides_step_spin_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure, public :: set_msys => util_set_msys Sets the value of msys from the masses of system bodies. interface public module subroutine util_set_msys(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object procedure, public :: get_energy_and_momentum => util_get_energy_momentum_system Calculates the total system energy and momentum interface public module subroutine util_get_energy_momentum_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: rescale => util_rescale_system Rescales the system into a new set of units interface public module subroutine util_rescale_system(self, param, mscale, dscale, tscale) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters. Returns with new values of the scale vactors and GU real(kind=DP), intent(in) :: mscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: dscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: tscale Scale factors for mass, distance, and time units, respectively. procedure, public :: validate_ids => util_valid_id_system Validate the numerical ids passed to the system and save the maximum value interface public module subroutine util_valid_id_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters generic, public :: write_hdr => write_hdr_bin , write_hdr_netcdf Generic method call for writing headers public interface io_write_hdr_system () Arguments None public interface netcdf_write_hdr_system () Arguments None procedure, public :: initialize => rmvs_setup_initialize_system Replace the abstract procedures with concrete ones\n Performs RMVS-specific initilization steps, including generating the close encounter planetocentric structures interface public module subroutine rmvs_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_nbody_system ), intent(inout) :: self RMVS system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters procedure, public :: step => rmvs_step_system Advance the RMVS nbody system forward in time by one step interface public module subroutine rmvs_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_nbody_system ), intent(inout) :: self RMVS nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"type/rmvs_nbody_system.html"},{"title":"rmvs_interp – swiftest ","text":"type, private :: rmvs_interp Inherited by type~~rmvs_interp~~InheritedByGraph type~rmvs_interp rmvs_interp type~rmvs_pl rmvs_pl type~rmvs_pl->type~rmvs_interp outer, inner type~rmvs_cb rmvs_cb type~rmvs_cb->type~rmvs_interp outer, inner type~rmvs_tp rmvs_tp type~rmvs_tp->type~rmvs_cb cb_heliocentric Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables x v aobl atide Components Type Visibility Attributes Name Initial real(kind=DP), public, dimension(:, :), allocatable :: x interpolated heliocentric planet position for outer encounter real(kind=DP), public, dimension(:, :), allocatable :: v interpolated heliocentric planet velocity for outer encounter real(kind=DP), public, dimension(:, :), allocatable :: aobl Encountering planet's oblateness acceleration value real(kind=DP), public, dimension(:, :), allocatable :: atide Encountering planet's tidal acceleration value","tags":"","loc":"type/rmvs_interp.html"},{"title":"rmvs_cb – swiftest ","text":"type, public, extends( whm_cb ) :: rmvs_cb RMVS central body particle class Inherits type~~rmvs_cb~~InheritsGraph type~rmvs_cb rmvs_cb type~rmvs_interp rmvs_interp type~rmvs_cb->type~rmvs_interp outer, inner type~whm_cb whm_cb type~rmvs_cb->type~whm_cb type~swiftest_cb swiftest_cb type~whm_cb->type~swiftest_cb type~swiftest_particle_info swiftest_particle_info type~swiftest_cb->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_cb->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~rmvs_cb~~InheritedByGraph type~rmvs_cb rmvs_cb type~rmvs_tp rmvs_tp type~rmvs_tp->type~rmvs_cb cb_heliocentric Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables info id mass Gmass radius density j2rp2 j4rp4 aobl atide aoblbeg aoblend atidebeg atideend xb vb agr Ip rot k2 Q tlag L0 dL outer inner lplanetocentric Type-Bound Procedures dump dump_particle_info write_frame_netcdf write_particle_info_netcdf write_particle_info read_in read_frame write_frame_bin write_frame Components Type Visibility Attributes Name Initial type( swiftest_particle_info ), public :: info Particle metadata information integer(kind=I4B), public :: id = 0 External identifier (unique) real(kind=DP), public :: mass = 0.0_DP Central body mass (units MU) real(kind=DP), public :: Gmass = 0.0_DP Central mass gravitational term G * mass (units GU * MU) real(kind=DP), public :: radius = 0.0_DP Central body radius (units DU) real(kind=DP), public :: density = 1.0_DP Central body mass density - calculated internally (units MU / DU**3) real(kind=DP), public :: j2rp2 = 0.0_DP J2*R&#94;2 term for central body real(kind=DP), public :: j4rp4 = 0.0_DP J4*R&#94;2 term for central body real(kind=DP), public, dimension(NDIM) :: aobl = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: atide = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: aoblbeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: aoblend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: atidebeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: atideend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: xb = 0.0_DP Barycentric position (units DU) real(kind=DP), public, dimension(NDIM) :: vb = 0.0_DP Barycentric velocity (units DU / TU) real(kind=DP), public, dimension(NDIM) :: agr = 0.0_DP Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(NDIM) :: Ip = 0.0_DP Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(NDIM) :: rot = 0.0_DP Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public :: k2 = 0.0_DP Tidal Love number real(kind=DP), public :: Q = 0.0_DP Tidal quality factor real(kind=DP), public :: tlag = 0.0_DP Tidal phase lag angle real(kind=DP), public, dimension(NDIM) :: L0 = 0.0_DP Initial angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: dL = 0.0_DP Change in angular momentum of the central body type( rmvs_interp ), public, dimension(:), allocatable :: outer interpolated heliocentric central body position for outer encounters type( rmvs_interp ), public, dimension(:), allocatable :: inner interpolated heliocentric central body position for inner encounters logical, public :: lplanetocentric = .false. Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file interface public module subroutine io_dump_base(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file interface public module subroutine io_dump_particle_info_base(self, param, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format interface public module subroutine netcdf_write_frame_base(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file interface public module subroutine netcdf_write_particle_info_base(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset generic, public :: write_particle_info => write_particle_info_netcdf public interface netcdf_write_particle_info_base () Arguments None procedure, public :: read_in => io_read_in_cb I/O routine for reading in central body data interface public module subroutine io_read_in_cb(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_cb I/O routine for reading out a single frame of time-series data for the central body interface public module function io_read_frame_cb(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: write_frame_bin => io_write_frame_cb I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_cb(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters generic, public :: write_frame => write_frame_netcdf , write_frame_bin Write a frame (either binary or NetCDF, using generic procedures) public interface netcdf_write_frame_base () Arguments None public interface io_write_frame_cb () Arguments None","tags":"","loc":"type/rmvs_cb.html"},{"title":"rmvs_tp – swiftest ","text":"type, public, extends( whm_tp ) :: rmvs_tp Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the\n    component list, such as rmvs_setup_tp and rmvs_util_spill_tp Inherits type~~rmvs_tp~~InheritsGraph type~rmvs_tp rmvs_tp type~whm_tp whm_tp type~rmvs_tp->type~whm_tp type~rmvs_cb rmvs_cb type~rmvs_tp->type~rmvs_cb cb_heliocentric type~swiftest_tp swiftest_tp type~whm_tp->type~swiftest_tp type~rmvs_interp rmvs_interp type~rmvs_cb->type~rmvs_interp outer, inner type~whm_cb whm_cb type~rmvs_cb->type~whm_cb type~swiftest_cb swiftest_cb type~whm_cb->type~swiftest_cb type~swiftest_body swiftest_body type~swiftest_tp->type~swiftest_body type~swiftest_particle_info swiftest_particle_info type~swiftest_cb->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_cb->type~swiftest_base type~swiftest_body->type~swiftest_particle_info info type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lfirst nbody info id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm isperi peri atp k_pltp npltp lperi plperP plencP cb_heliocentric xheliocentric index ipleP lplanetocentric Type-Bound Procedures dump dump_particle_info write_frame_netcdf write_particle_info_netcdf write_particle_info drift v2pv pv2v read_in read_frame write_frame_bin el2xv xv2el accel_user set_ir3 write_frame accel_int accel_obl h2b b2h vb2vh vh2vb xh2xb get_peri set_mu accel_gr gr_pos_kick kick step discard encounter_check accel setup append fill resize sort rearrange spill Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill integer(kind=I4B), public, dimension(:), allocatable :: isperi Perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri Perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp Semimajor axis following perihelion passage integer(kind=I4B), public, dimension(:,:), allocatable :: k_pltp Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: npltp Number of pl-tp comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_tp and util_spill_tp logical, public, dimension(:), allocatable :: lperi planetocentric pericenter passage flag (persistent for a full rmvs time step) over a full RMVS time step) integer(kind=I4B), public, dimension(:), allocatable :: plperP index of planet associated with pericenter distance peri (persistent over a full RMVS time step) integer(kind=I4B), public, dimension(:), allocatable :: plencP index of planet that test particle is encountering (not persistent for a full RMVS time step) type( rmvs_cb ), public :: cb_heliocentric Copy of original central body object passed to close encounter (used for oblateness acceleration during planetocentric encoountters) real(kind=DP), public, dimension(:,:), allocatable :: xheliocentric original heliocentric position (used for oblateness calculation during close encounters) integer(kind=I4B), public :: index inner substep number within current set integer(kind=I4B), public :: ipleP index value of encountering planet logical, public :: lplanetocentric = .false. Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file interface public module subroutine io_dump_base(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file interface public module subroutine io_dump_particle_info_base(self, param, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format interface public module subroutine netcdf_write_frame_base(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file interface public module subroutine netcdf_write_particle_info_base(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset generic, public :: write_particle_info => write_particle_info_netcdf public interface netcdf_write_particle_info_base () Arguments None procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables interface public module subroutine drift_body(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file interface public module subroutine io_read_in_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module function io_read_frame_body(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object generic, public :: write_frame => write_frame_netcdf , write_frame_bin Add the generic write frame for Fortran binary files public interface netcdf_write_frame_base () Arguments None public interface io_write_frame_body () Arguments None procedure, public :: accel_int => kick_getacch_int_tp Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies interface public module subroutine kick_getacch_int_tp(self, GMpl, xhp, npl) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle real(kind=DP), intent(in), dimension(:) :: GMpl Massive body masses real(kind=DP), intent(in), dimension(:,:) :: xhp Massive body position vectors integer(kind=I4B), intent(in) :: npl Number of active massive bodies procedure, public :: accel_obl => obl_acc_tp Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_tp(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: h2b => util_coord_h2b_tp Convert test particles from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_tp Convert test particles from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: vb2vh => util_coord_vb2vh_tp Convert test particles from barycentric to heliocentric coordinates (velocity only) interface public module subroutine util_coord_vb2vh_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body procedure, public :: vh2vb => util_coord_vh2vb_tp Convert test particles from heliocentric to barycentric coordinates (velocity only) interface public module subroutine util_coord_vh2vb_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body procedure, public :: xh2xb => util_coord_xh2xb_tp Convert test particles from heliocentric to barycentric coordinates (position only) interface public module subroutine util_coord_xh2xb_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: get_peri => util_peri_tp Determine system pericenter passages for test particles interface public module subroutine util_peri_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: set_mu => util_set_mu_tp Method used to construct the vectorized form of the central body mass interface public module subroutine util_set_mu_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_gr => whm_gr_kick_getacch_tp Acceleration term arising from the post-Newtonian correction interface public pure module subroutine whm_gr_kick_getacch_tp(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: gr_pos_kick => whm_gr_p4_tp Position kick due to p**4 term in the post-Newtonian correction interface public pure module subroutine whm_gr_p4_tp(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size procedure, public :: kick => whm_kick_vh_tp Kick heliocentric velocities of test particles interface public module subroutine whm_kick_vh_tp(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure, public :: step => whm_step_tp Steps the particle forward one stepsize interface public module subroutine whm_step_tp(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize procedure, public :: discard => rmvs_discard_tp Check to see if test particles should be discarded based on pericenter passage distances with respect to planets encountered interface public module subroutine rmvs_discard_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters procedure, public :: encounter_check => rmvs_encounter_check_tp Checks if any test particles are undergoing a close encounter with a massive body interface public module function rmvs_encounter_check_tp(self, system, dt) result(lencounter) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class( rmvs_nbody_system ), intent(inout) :: system RMVS nbody system object real(kind=DP), intent(in) :: dt step size Return Value logical Returns true if there is at least one close encounter procedure, public :: accel => rmvs_kick_getacch_tp Calculates either the standard or modified version of the acceleration depending if the\n    if the test particle is undergoing a close encounter or not interface public module subroutine rmvs_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest central body particle data structuree class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step procedure, public :: setup => rmvs_setup_tp Constructor method - Allocates space for the input number of bodiess interface public module subroutine rmvs_setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parametere procedure, public :: append => rmvs_util_append_tp Appends elements from one structure to another interface public module subroutine rmvs_util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: fill => rmvs_util_fill_tp \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine rmvs_util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: resize => rmvs_util_resize_tp Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. interface public module subroutine rmvs_util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: sort => rmvs_util_sort_tp Sorts body arrays by a sortable componen interface public module subroutine rmvs_util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => rmvs_util_sort_rearrange_tp Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine rmvs_util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => rmvs_util_spill_tp \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine rmvs_util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"type/rmvs_tp.html"},{"title":"rmvs_pl – swiftest ","text":"type, public, extends( whm_pl ) :: rmvs_pl RMVS massive body particle class Inherits type~~rmvs_pl~~InheritsGraph type~rmvs_pl rmvs_pl type~whm_pl whm_pl type~rmvs_pl->type~whm_pl type~rmvs_interp rmvs_interp type~rmvs_pl->type~rmvs_interp outer, inner type~rmvs_nbody_system rmvs_nbody_system type~rmvs_pl->type~rmvs_nbody_system planetocentric type~swiftest_pl swiftest_pl type~whm_pl->type~swiftest_pl type~whm_nbody_system whm_nbody_system type~rmvs_nbody_system->type~whm_nbody_system type~swiftest_nbody_system swiftest_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~swiftest_body swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_particle_info swiftest_particle_info type~swiftest_body->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base type~swiftest_nbody_system->type~swiftest_pl pl, pl_discards type~swiftest_cb swiftest_cb type~swiftest_nbody_system->type~swiftest_cb cb type~swiftest_tp swiftest_tp type~swiftest_nbody_system->type~swiftest_tp tp, tp_discards type~swiftest_cb->type~swiftest_particle_info info type~swiftest_cb->type~swiftest_base type~swiftest_tp->type~swiftest_body Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lfirst nbody info id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm mass Gmass rhill radius xbeg xend vbeg density Ip rot k2 Q tlag k_plpl nplpl eta xj vj muj ir3j nenc tpenc1P plind outer inner planetocentric lplanetocentric Type-Bound Procedures dump dump_particle_info write_frame_netcdf write_particle_info_netcdf write_particle_info v2pv pv2v read_in read_frame write_frame_bin el2xv xv2el accel_user write_frame discard index accel_int accel_obl accel_tides h2b b2h vh2vb vb2vh xh2xb set_beg_end set_rhill h2j j2h vh2vj drift accel_gr gr_pos_kick accel kick set_ir3 set_mu step setup append fill resize sort rearrange spill Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl real(kind=DP), public, dimension(:), allocatable :: eta Jacobi mass real(kind=DP), public, dimension(:,:), allocatable :: xj Jacobi position real(kind=DP), public, dimension(:,:), allocatable :: vj Jacobi velocity real(kind=DP), public, dimension(:), allocatable :: muj Jacobi mu: GMcb * eta(i) / eta(i - 1) real(kind=DP), public, dimension(:), allocatable :: ir3j Third term of heliocentric acceleration\n Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the\n    component list, such as whm_setup_pl and whm_util_spill_pl integer(kind=I4B), public, dimension(:), allocatable :: nenc number of test particles encountering planet this full rmvs time step integer(kind=I4B), public, dimension(:), allocatable :: tpenc1P index of first test particle encountering planet integer(kind=I4B), public, dimension(:), allocatable :: plind Connects the planetocentric indices back to the heliocentric planet list type( rmvs_interp ), public, dimension(:), allocatable :: outer interpolated heliocentric central body position for outer encounters type( rmvs_interp ), public, dimension(:), allocatable :: inner interpolated heliocentric central body position for inner encounters class( rmvs_nbody_system ), public, dimension(:), allocatable :: planetocentric Planetocentric version of the massive body objects (one for each massive body) logical, public :: lplanetocentric = .false. Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file interface public module subroutine io_dump_base(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file interface public module subroutine io_dump_particle_info_base(self, param, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format interface public module subroutine netcdf_write_frame_base(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file interface public module subroutine netcdf_write_particle_info_base(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset generic, public :: write_particle_info => write_particle_info_netcdf public interface netcdf_write_particle_info_base () Arguments None procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file interface public module subroutine io_read_in_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module function io_read_frame_body(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step generic, public :: write_frame => write_frame_netcdf , write_frame_bin Add the generic write frame for Fortran binary files public interface netcdf_write_frame_base () Arguments None public interface io_write_frame_body () Arguments None procedure, public :: discard => discard_pl Placeholder method for discarding massive bodies interface public module subroutine discard_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameter procedure, public :: index => util_index_eucl_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix interface public module subroutine util_index_eucl_plpl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies interface public module subroutine kick_getacch_int_pl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body interface public module subroutine tides_kick_getacch_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: vh2vb => util_coord_vh2vb_pl Convert massive bodies from heliocentric to barycentric coordinates (velocity only) interface public module subroutine util_coord_vh2vb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: vb2vh => util_coord_vb2vh_pl Convert massive bodies from barycentric to heliocentric coordinates (velocity only) interface public module subroutine util_coord_vb2vh_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xh2xb => util_coord_xh2xb_pl Convert massive bodies from heliocentric to barycentric coordinates (position only) interface public module subroutine util_coord_xh2xb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. interface public module subroutine util_set_beg_end_pl(self, xbeg, xend, vbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object real(kind=DP), intent(in), optional dimension(:,:) :: xbeg Position vectors at beginning of step real(kind=DP), intent(in), optional dimension(:,:) :: xend Positions vectors at end of step real(kind=DP), intent(in), optional dimension(:,:) :: vbeg vbeg is an unused variable to keep this method forward compatible with RMVS procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body interface public module subroutine util_set_rhill(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: h2j => whm_coord_h2j_pl Convert position and velcoity vectors from heliocentric to Jacobi coordinates interface public module subroutine whm_coord_h2j_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree procedure, public :: j2h => whm_coord_j2h_pl Convert position and velcoity vectors from Jacobi to helliocentric coordinates interface public module subroutine whm_coord_j2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree procedure, public :: vh2vj => whm_coord_vh2vj_pl Convert velocity vectors from heliocentric to Jacobi coordinates interface public module subroutine whm_coord_vh2vj_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree procedure, public :: drift => whm_drift_pl Loop through massive bodies and call Danby drift routine to jacobi coordinates interface public module subroutine whm_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: accel_gr => whm_gr_kick_getacch_pl Acceleration term arising from the post-Newtonian correction interface public pure module subroutine whm_gr_kick_getacch_pl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: gr_pos_kick => whm_gr_p4_pl Position kick due to p**4 term in the post-Newtonian correction interface public pure module subroutine whm_gr_p4_pl(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size procedure, public :: accel => whm_kick_getacch_pl Compute heliocentric accelerations of massive bodies interface public module subroutine whm_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Get heliocentric accelration of massive bodies Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step procedure, public :: kick => whm_kick_vh_pl Kick heliocentric velocities of massive bodies interface public module subroutine whm_kick_vh_pl(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure, public :: set_ir3 => whm_util_set_ir3j Sets both the heliocentric and jacobi inverse radius terms (1/rj 3 and 1/rh 3) interface public module subroutine whm_util_set_ir3j(self) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object procedure, public :: set_mu => whm_util_set_mu_eta_pl Sets the Jacobi mass value for all massive bodies. interface public module subroutine whm_util_set_mu_eta_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: step => whm_step_pl Steps the body forward one stepsize interface public module subroutine whm_step_pl(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure, public :: setup => rmvs_setup_pl Constructor method - Allocates space for the input number of bodiess interface public module subroutine rmvs_setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: append => rmvs_util_append_pl Appends elements from one structure to another interface public module subroutine rmvs_util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: fill => rmvs_util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine rmvs_util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: resize => rmvs_util_resize_pl Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. interface public module subroutine rmvs_util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: sort => rmvs_util_sort_pl Sorts body arrays by a sortable componen interface public module subroutine rmvs_util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => rmvs_util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine rmvs_util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => rmvs_util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine rmvs_util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"type/rmvs_pl.html"},{"title":"walltimer – swiftest ","text":"type, public :: walltimer Contents Variables count_rate count_max count_start_main count_start_step count_finish_step lmain_is_started Type-Bound Procedures reset start finish Components Type Visibility Attributes Name Initial integer(kind=I8B), public :: count_rate Rate at wich the clock ticks integer(kind=I8B), public :: count_max Maximum value of the clock ticker integer(kind=I8B), public :: count_start_main Value of the clock ticker at when the timer is first called integer(kind=I8B), public :: count_start_step Value of the clock ticker at the start of a timed step integer(kind=I8B), public :: count_finish_step Value of the clock ticker at the end of a timed step logical, public :: lmain_is_started = .false. Logical flag indicating whether or not the main timer has been reset or not Type-Bound Procedures procedure, public :: reset => walltime_reset Resets the clock ticker, settting main_start to the current ticker value interface public subroutine walltime_reset(self) Arguments Type Intent Optional Attributes Name class( walltimer ), intent(inout) :: self Walltimer object procedure, public :: start => walltime_start Starts the timer, setting step_start to the current ticker value interface public subroutine walltime_start(self) Arguments Type Intent Optional Attributes Name class( walltimer ), intent(inout) :: self Walltimer object procedure, public :: finish => walltime_finish Ends the timer, setting step_finish to the current ticker value and printing the elapsed time information to the terminal interface public subroutine walltime_finish(self, nsubsteps, message) Arguments Type Intent Optional Attributes Name class( walltimer ), intent(inout) :: self Walltimer object integer(kind=I4B), intent(in) :: nsubsteps Number of substeps used to compute the time per step character(len=*), intent(in) :: message Message to prepend to the wall time terminal output","tags":"","loc":"type/walltimer.html"},{"title":"helio_nbody_system – swiftest ","text":"type, public, extends( whm_nbody_system ) :: helio_nbody_system Inherits type~~helio_nbody_system~~InheritsGraph type~helio_nbody_system helio_nbody_system type~whm_nbody_system whm_nbody_system type~helio_nbody_system->type~whm_nbody_system type~swiftest_nbody_system swiftest_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~swiftest_cb swiftest_cb type~swiftest_nbody_system->type~swiftest_cb cb type~swiftest_pl swiftest_pl type~swiftest_nbody_system->type~swiftest_pl pl, pl_discards type~swiftest_tp swiftest_tp type~swiftest_nbody_system->type~swiftest_tp tp, tp_discards type~swiftest_particle_info swiftest_particle_info type~swiftest_cb->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_cb->type~swiftest_base type~swiftest_body swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_tp->type~swiftest_body type~swiftest_body->type~swiftest_particle_info info type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~helio_nbody_system~~InheritedByGraph type~helio_nbody_system helio_nbody_system type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~helio_nbody_system Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables cb pl tp tp_discards pl_discards GMtot ke_orbit ke_spin pe te oblpot Lorbit Lspin Ltot lbeg Type-Bound Procedures discard conservation_report dump get_old_t_final read_frame read_particle_info write_discard write_frame write_hdr_bin write_hdr_netcdf obl_pot init_particle_info step_spin set_msys get_energy_and_momentum rescale validate_ids write_hdr step initialize Components Type Visibility Attributes Name Initial class( swiftest_cb ), public, allocatable :: cb Central body data structure class( swiftest_pl ), public, allocatable :: pl Massive body data structure class( swiftest_tp ), public, allocatable :: tp Test particle data structure class( swiftest_tp ), public, allocatable :: tp_discards Discarded test particle data structure class( swiftest_pl ), public, allocatable :: pl_discards Discarded massive body particle data structure real(kind=DP), public :: GMtot = 0.0_DP Total system mass - used for barycentric coordinate conversion real(kind=DP), public :: ke_orbit = 0.0_DP System orbital kinetic energy real(kind=DP), public :: ke_spin = 0.0_DP System spin kinetic energy real(kind=DP), public :: pe = 0.0_DP System potential energy real(kind=DP), public :: te = 0.0_DP System total energy real(kind=DP), public :: oblpot = 0.0_DP System potential energy due to oblateness of the central body real(kind=DP), public, dimension(NDIM) :: Lorbit = 0.0_DP System orbital angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lspin = 0.0_DP System spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Ltot = 0.0_DP System angular momentum vector logical, public :: lbeg True if this is the beginning of a step. This is used so that test particle steps can be calculated \n    separately from massive bodies.  Massive body variables are saved at half steps, and passed to \n    the test particles Type-Bound Procedures procedure, public :: discard => discard_system Perform a discard step on the system interface public module subroutine discard_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: conservation_report => io_conservation_report Compute energy and momentum and print out the change with time interface public module subroutine io_conservation_report(self, param, lterminal) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Input colleciton of user-defined parameters logical, intent(in) :: lterminal Indicates whether to output information to the terminal screen procedure, public :: dump => io_dump_system Dump the state of the system to a file interface public module subroutine io_dump_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: get_old_t_final => io_get_old_t_final_system Validates the dump file to check whether the dump file initial conditions duplicate the last frame of the binary output. interface public module function io_get_old_t_final_system(self, param) result(old_t_final) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self class( swiftest_parameters ), intent(in) :: param Return Value real(kind=DP) procedure, public :: read_frame => io_read_frame_system Read in a frame of input data from file interface public module function io_read_frame_system(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: read_particle_info => io_read_particle_info_system Read in particle metadata from file interface public module subroutine io_read_particle_info_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: write_discard => io_write_discard Write out information about discarded test particles interface public module subroutine io_write_discard(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: write_frame => io_write_frame_system Append a frame of output data to file interface public module subroutine io_write_frame_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: write_hdr_bin => io_write_hdr_system Write a header for an output frame in Fortran binary format interface public module subroutine io_write_hdr_system(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest nbody system object integer(kind=I4B), intent(inout) :: iu Output file unit number class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_hdr_netcdf => netcdf_write_hdr_system Write a header for an output frame in NetCDF format interface public module subroutine netcdf_write_hdr_system(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest nbody system object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: obl_pot => obl_pot_system Compute the contribution to the total gravitational potential due solely to the oblateness of the central body interface public module subroutine obl_pot_system(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object procedure, public :: init_particle_info => setup_initialize_particle_info_system Initialize the system from input files interface public module subroutine setup_initialize_particle_info_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: step_spin => tides_step_spin_system Steps the spins of the massive & central bodies due to tides. interface public module subroutine tides_step_spin_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure, public :: set_msys => util_set_msys Sets the value of msys from the masses of system bodies. interface public module subroutine util_set_msys(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object procedure, public :: get_energy_and_momentum => util_get_energy_momentum_system Calculates the total system energy and momentum interface public module subroutine util_get_energy_momentum_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: rescale => util_rescale_system Rescales the system into a new set of units interface public module subroutine util_rescale_system(self, param, mscale, dscale, tscale) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters. Returns with new values of the scale vactors and GU real(kind=DP), intent(in) :: mscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: dscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: tscale Scale factors for mass, distance, and time units, respectively. procedure, public :: validate_ids => util_valid_id_system Validate the numerical ids passed to the system and save the maximum value interface public module subroutine util_valid_id_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters generic, public :: write_hdr => write_hdr_bin , write_hdr_netcdf Generic method call for writing headers public interface io_write_hdr_system () Arguments None public interface netcdf_write_hdr_system () Arguments None procedure, public :: step => helio_step_system Advance the Helio nbody system forward in time by one step interface public module subroutine helio_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_nbody_system ), intent(inout) :: self Helio nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure, public :: initialize => helio_setup_initialize_system Performs Helio-specific initilization steps, including converting to DH coordinates interface public module subroutine helio_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( helio_nbody_system ), intent(inout) :: self Helio nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters","tags":"","loc":"type/helio_nbody_system.html"},{"title":"helio_cb – swiftest ","text":"type, public, extends( swiftest_cb ) :: helio_cb Helio central body particle class Inherits type~~helio_cb~~InheritsGraph type~helio_cb helio_cb type~swiftest_cb swiftest_cb type~helio_cb->type~swiftest_cb type~swiftest_particle_info swiftest_particle_info type~swiftest_cb->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_cb->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~helio_cb~~InheritedByGraph type~helio_cb helio_cb type~symba_cb symba_cb type~symba_cb->type~helio_cb Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables info id mass Gmass radius density j2rp2 j4rp4 aobl atide aoblbeg aoblend atidebeg atideend xb vb agr Ip rot k2 Q tlag L0 dL ptbeg ptend Type-Bound Procedures dump dump_particle_info write_frame_netcdf write_particle_info_netcdf write_particle_info read_in read_frame write_frame_bin write_frame Components Type Visibility Attributes Name Initial type( swiftest_particle_info ), public :: info Particle metadata information integer(kind=I4B), public :: id = 0 External identifier (unique) real(kind=DP), public :: mass = 0.0_DP Central body mass (units MU) real(kind=DP), public :: Gmass = 0.0_DP Central mass gravitational term G * mass (units GU * MU) real(kind=DP), public :: radius = 0.0_DP Central body radius (units DU) real(kind=DP), public :: density = 1.0_DP Central body mass density - calculated internally (units MU / DU**3) real(kind=DP), public :: j2rp2 = 0.0_DP J2*R&#94;2 term for central body real(kind=DP), public :: j4rp4 = 0.0_DP J4*R&#94;2 term for central body real(kind=DP), public, dimension(NDIM) :: aobl = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: atide = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: aoblbeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: aoblend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: atidebeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: atideend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: xb = 0.0_DP Barycentric position (units DU) real(kind=DP), public, dimension(NDIM) :: vb = 0.0_DP Barycentric velocity (units DU / TU) real(kind=DP), public, dimension(NDIM) :: agr = 0.0_DP Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(NDIM) :: Ip = 0.0_DP Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(NDIM) :: rot = 0.0_DP Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public :: k2 = 0.0_DP Tidal Love number real(kind=DP), public :: Q = 0.0_DP Tidal quality factor real(kind=DP), public :: tlag = 0.0_DP Tidal phase lag angle real(kind=DP), public, dimension(NDIM) :: L0 = 0.0_DP Initial angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: dL = 0.0_DP Change in angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: ptbeg negative barycentric velocity of the central body at the beginning of time step real(kind=DP), public, dimension(NDIM) :: ptend negative barycentric velocity of the central body at the end of time step Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file interface public module subroutine io_dump_base(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file interface public module subroutine io_dump_particle_info_base(self, param, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format interface public module subroutine netcdf_write_frame_base(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file interface public module subroutine netcdf_write_particle_info_base(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset generic, public :: write_particle_info => write_particle_info_netcdf public interface netcdf_write_particle_info_base () Arguments None procedure, public :: read_in => io_read_in_cb I/O routine for reading in central body data interface public module subroutine io_read_in_cb(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_cb I/O routine for reading out a single frame of time-series data for the central body interface public module function io_read_frame_cb(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: write_frame_bin => io_write_frame_cb I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_cb(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters generic, public :: write_frame => write_frame_netcdf , write_frame_bin Write a frame (either binary or NetCDF, using generic procedures) public interface netcdf_write_frame_base () Arguments None public interface io_write_frame_cb () Arguments None","tags":"","loc":"type/helio_cb.html"},{"title":"helio_pl – swiftest ","text":"type, public, extends( swiftest_pl ) :: helio_pl Inherits type~~helio_pl~~InheritsGraph type~helio_pl helio_pl type~swiftest_pl swiftest_pl type~helio_pl->type~swiftest_pl type~swiftest_body swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_particle_info swiftest_particle_info type~swiftest_body->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~helio_pl~~InheritedByGraph type~helio_pl helio_pl type~symba_pl symba_pl type~symba_pl->type~helio_pl type~symba_merger symba_merger type~symba_merger->type~symba_pl type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~symba_merger pl_adds Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lfirst nbody info id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm mass Gmass rhill radius xbeg xend vbeg density Ip rot k2 Q tlag k_plpl nplpl Type-Bound Procedures dump dump_particle_info write_frame_netcdf write_particle_info_netcdf write_particle_info v2pv pv2v read_in read_frame write_frame_bin el2xv xv2el accel_user set_ir3 write_frame discard index accel_int accel_obl setup accel_tides append h2b b2h vh2vb vb2vh xh2xb fill resize set_beg_end set_mu set_rhill sort rearrange spill drift lindrift accel_gr gr_pos_kick accel kick step Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file interface public module subroutine io_dump_base(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file interface public module subroutine io_dump_particle_info_base(self, param, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format interface public module subroutine netcdf_write_frame_base(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file interface public module subroutine netcdf_write_particle_info_base(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset generic, public :: write_particle_info => write_particle_info_netcdf public interface netcdf_write_particle_info_base () Arguments None procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file interface public module subroutine io_read_in_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module function io_read_frame_body(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object generic, public :: write_frame => write_frame_netcdf , write_frame_bin Add the generic write frame for Fortran binary files public interface netcdf_write_frame_base () Arguments None public interface io_write_frame_body () Arguments None procedure, public :: discard => discard_pl Placeholder method for discarding massive bodies interface public module subroutine discard_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameter procedure, public :: index => util_index_eucl_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix interface public module subroutine util_index_eucl_plpl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies interface public module subroutine kick_getacch_int_pl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: setup => setup_pl A base constructor that sets the number of bodies and allocates and initializes all arrays interface public module subroutine setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body interface public module subroutine tides_kick_getacch_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: append => util_append_pl Appends elements from one structure to another interface public module subroutine util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: vh2vb => util_coord_vh2vb_pl Convert massive bodies from heliocentric to barycentric coordinates (velocity only) interface public module subroutine util_coord_vh2vb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: vb2vh => util_coord_vb2vh_pl Convert massive bodies from barycentric to heliocentric coordinates (velocity only) interface public module subroutine util_coord_vb2vh_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xh2xb => util_coord_xh2xb_pl Convert massive bodies from heliocentric to barycentric coordinates (position only) interface public module subroutine util_coord_xh2xb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: fill => util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: resize => util_resize_pl Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. interface public module subroutine util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. interface public module subroutine util_set_beg_end_pl(self, xbeg, xend, vbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object real(kind=DP), intent(in), optional dimension(:,:) :: xbeg Position vectors at beginning of step real(kind=DP), intent(in), optional dimension(:,:) :: xend Positions vectors at end of step real(kind=DP), intent(in), optional dimension(:,:) :: vbeg vbeg is an unused variable to keep this method forward compatible with RMVS procedure, public :: set_mu => util_set_mu_pl Method used to construct the vectorized form of the central body mass interface public module subroutine util_set_mu_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body interface public module subroutine util_set_rhill(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: sort => util_sort_pl Sorts body arrays by a sortable component interface public module subroutine util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not procedure, public :: drift => helio_drift_pl Method for Danby drift in Democratic Heliocentric coordinates interface public module subroutine helio_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: lindrift => helio_drift_linear_pl Method for linear drift of massive bodies due to barycentric momentum of Sun interface public module subroutine helio_drift_linear_pl(self, cb, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( helio_cb ), intent(inout) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step procedure, public :: accel_gr => helio_gr_kick_getacch_pl Acceleration term arising from the post-Newtonian correction interface public pure module subroutine helio_gr_kick_getacch_pl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: gr_pos_kick => helio_gr_p4_pl Position kick due to p**4 term in the post-Newtonian correction interface public pure module subroutine helio_gr_p4_pl(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size procedure, public :: accel => helio_kick_getacch_pl Compute heliocentric accelerations of massive bodies interface public module subroutine helio_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step procedure, public :: kick => helio_kick_vb_pl Kicks the barycentric velocities interface public module subroutine helio_kick_vb_pl(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure, public :: step => helio_step_pl Steps the body forward one stepsize interface public module subroutine helio_step_pl(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nboody system class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"type/helio_pl.html"},{"title":"helio_tp – swiftest ","text":"type, public, extends( swiftest_tp ) :: helio_tp Inherits type~~helio_tp~~InheritsGraph type~helio_tp helio_tp type~swiftest_tp swiftest_tp type~helio_tp->type~swiftest_tp type~swiftest_body swiftest_body type~swiftest_tp->type~swiftest_body type~swiftest_particle_info swiftest_particle_info type~swiftest_body->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~helio_tp~~InheritedByGraph type~helio_tp helio_tp type~symba_tp symba_tp type~symba_tp->type~helio_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lfirst nbody info id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm isperi peri atp k_pltp npltp Type-Bound Procedures dump dump_particle_info write_frame_netcdf write_particle_info_netcdf write_particle_info v2pv pv2v read_in read_frame write_frame_bin el2xv xv2el accel_user set_ir3 write_frame discard accel_int accel_obl setup append h2b b2h vb2vh vh2vb xh2xb fill get_peri resize set_mu sort rearrange spill lindrift drift accel_gr gr_pos_kick accel kick step Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill integer(kind=I4B), public, dimension(:), allocatable :: isperi Perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri Perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp Semimajor axis following perihelion passage integer(kind=I4B), public, dimension(:,:), allocatable :: k_pltp Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: npltp Number of pl-tp comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_tp and util_spill_tp Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file interface public module subroutine io_dump_base(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file interface public module subroutine io_dump_particle_info_base(self, param, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format interface public module subroutine netcdf_write_frame_base(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file interface public module subroutine netcdf_write_particle_info_base(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset generic, public :: write_particle_info => write_particle_info_netcdf public interface netcdf_write_particle_info_base () Arguments None procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file interface public module subroutine io_read_in_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module function io_read_frame_body(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object generic, public :: write_frame => write_frame_netcdf , write_frame_bin Add the generic write frame for Fortran binary files public interface netcdf_write_frame_base () Arguments None public interface io_write_frame_body () Arguments None procedure, public :: discard => discard_tp Check to see if test particles should be discarded based on their positions relative to the massive bodies interface public module subroutine discard_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: accel_int => kick_getacch_int_tp Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies interface public module subroutine kick_getacch_int_tp(self, GMpl, xhp, npl) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle real(kind=DP), intent(in), dimension(:) :: GMpl Massive body masses real(kind=DP), intent(in), dimension(:,:) :: xhp Massive body position vectors integer(kind=I4B), intent(in) :: npl Number of active massive bodies procedure, public :: accel_obl => obl_acc_tp Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_tp(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: setup => setup_tp A base constructor that sets the number of bodies and interface public module subroutine setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parametersr procedure, public :: append => util_append_tp Appends elements from one structure to another interface public module subroutine util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: h2b => util_coord_h2b_tp Convert test particles from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_tp Convert test particles from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: vb2vh => util_coord_vb2vh_tp Convert test particles from barycentric to heliocentric coordinates (velocity only) interface public module subroutine util_coord_vb2vh_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body procedure, public :: vh2vb => util_coord_vh2vb_tp Convert test particles from heliocentric to barycentric coordinates (velocity only) interface public module subroutine util_coord_vh2vb_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body procedure, public :: xh2xb => util_coord_xh2xb_tp Convert test particles from heliocentric to barycentric coordinates (position only) interface public module subroutine util_coord_xh2xb_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: fill => util_fill_tp \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: get_peri => util_peri_tp Determine system pericenter passages for test particles interface public module subroutine util_peri_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: resize => util_resize_tp Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. interface public module subroutine util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: set_mu => util_set_mu_tp Method used to construct the vectorized form of the central body mass interface public module subroutine util_set_mu_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: sort => util_sort_tp Sorts body arrays by a sortable component interface public module subroutine util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => util_sort_rearrange_tp Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => util_spill_tp \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not procedure, public :: lindrift => helio_drift_linear_tp Method for linear drift of massive bodies due to barycentric momentum of Sun interface public module subroutine helio_drift_linear_tp(self, cb, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( helio_cb ), intent(in) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step procedure, public :: drift => helio_drift_tp Method for Danby drift in Democratic Heliocentric coordinates interface public module subroutine helio_drift_tp(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: accel_gr => helio_gr_kick_getacch_tp Acceleration term arising from the post-Newtonian correction interface public pure module subroutine helio_gr_kick_getacch_tp(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: gr_pos_kick => helio_gr_p4_tp Position kick due to p**4 term in the post-Newtonian correction interface public pure module subroutine helio_gr_p4_tp(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size procedure, public :: accel => helio_kick_getacch_tp Compute heliocentric accelerations of massive bodies interface public module subroutine helio_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step procedure, public :: kick => helio_kick_vb_tp Kicks the barycentric velocities interface public module subroutine helio_kick_vb_tp(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure, public :: step => helio_step_tp Steps the body forward one stepsize interface public module subroutine helio_step_tp(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsizee","tags":"","loc":"type/helio_tp.html"},{"title":"whm_cb – swiftest ","text":"type, public, extends( swiftest_cb ) :: whm_cb Swiftest central body particle class Inherits type~~whm_cb~~InheritsGraph type~whm_cb whm_cb type~swiftest_cb swiftest_cb type~whm_cb->type~swiftest_cb type~swiftest_particle_info swiftest_particle_info type~swiftest_cb->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_cb->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~whm_cb~~InheritedByGraph type~whm_cb whm_cb type~rmvs_cb rmvs_cb type~rmvs_cb->type~whm_cb type~rmvs_tp rmvs_tp type~rmvs_tp->type~rmvs_cb cb_heliocentric Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables info id mass Gmass radius density j2rp2 j4rp4 aobl atide aoblbeg aoblend atidebeg atideend xb vb agr Ip rot k2 Q tlag L0 dL Type-Bound Procedures dump dump_particle_info write_frame_netcdf write_particle_info_netcdf write_particle_info read_in read_frame write_frame_bin write_frame Components Type Visibility Attributes Name Initial type( swiftest_particle_info ), public :: info Particle metadata information integer(kind=I4B), public :: id = 0 External identifier (unique) real(kind=DP), public :: mass = 0.0_DP Central body mass (units MU) real(kind=DP), public :: Gmass = 0.0_DP Central mass gravitational term G * mass (units GU * MU) real(kind=DP), public :: radius = 0.0_DP Central body radius (units DU) real(kind=DP), public :: density = 1.0_DP Central body mass density - calculated internally (units MU / DU**3) real(kind=DP), public :: j2rp2 = 0.0_DP J2*R&#94;2 term for central body real(kind=DP), public :: j4rp4 = 0.0_DP J4*R&#94;2 term for central body real(kind=DP), public, dimension(NDIM) :: aobl = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: atide = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: aoblbeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: aoblend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: atidebeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: atideend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: xb = 0.0_DP Barycentric position (units DU) real(kind=DP), public, dimension(NDIM) :: vb = 0.0_DP Barycentric velocity (units DU / TU) real(kind=DP), public, dimension(NDIM) :: agr = 0.0_DP Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(NDIM) :: Ip = 0.0_DP Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(NDIM) :: rot = 0.0_DP Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public :: k2 = 0.0_DP Tidal Love number real(kind=DP), public :: Q = 0.0_DP Tidal quality factor real(kind=DP), public :: tlag = 0.0_DP Tidal phase lag angle real(kind=DP), public, dimension(NDIM) :: L0 = 0.0_DP Initial angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: dL = 0.0_DP Change in angular momentum of the central body Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file interface public module subroutine io_dump_base(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file interface public module subroutine io_dump_particle_info_base(self, param, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format interface public module subroutine netcdf_write_frame_base(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file interface public module subroutine netcdf_write_particle_info_base(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset generic, public :: write_particle_info => write_particle_info_netcdf public interface netcdf_write_particle_info_base () Arguments None procedure, public :: read_in => io_read_in_cb I/O routine for reading in central body data interface public module subroutine io_read_in_cb(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_cb I/O routine for reading out a single frame of time-series data for the central body interface public module function io_read_frame_cb(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: write_frame_bin => io_write_frame_cb I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_cb(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters generic, public :: write_frame => write_frame_netcdf , write_frame_bin Write a frame (either binary or NetCDF, using generic procedures) public interface netcdf_write_frame_base () Arguments None public interface io_write_frame_cb () Arguments None","tags":"","loc":"type/whm_cb.html"},{"title":"whm_pl – swiftest ","text":"type, public, extends( swiftest_pl ) :: whm_pl WHM massive body particle class Inherits type~~whm_pl~~InheritsGraph type~whm_pl whm_pl type~swiftest_pl swiftest_pl type~whm_pl->type~swiftest_pl type~swiftest_body swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_particle_info swiftest_particle_info type~swiftest_body->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~whm_pl~~InheritedByGraph type~whm_pl whm_pl type~rmvs_pl rmvs_pl type~rmvs_pl->type~whm_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lfirst nbody info id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm mass Gmass rhill radius xbeg xend vbeg density Ip rot k2 Q tlag k_plpl nplpl eta xj vj muj ir3j Type-Bound Procedures dump dump_particle_info write_frame_netcdf write_particle_info_netcdf write_particle_info v2pv pv2v read_in read_frame write_frame_bin el2xv xv2el accel_user write_frame discard index accel_int accel_obl accel_tides h2b b2h vh2vb vb2vh xh2xb set_beg_end set_rhill h2j j2h vh2vj drift accel_gr gr_pos_kick accel kick append fill resize set_ir3 set_mu sort rearrange spill setup step Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl real(kind=DP), public, dimension(:), allocatable :: eta Jacobi mass real(kind=DP), public, dimension(:,:), allocatable :: xj Jacobi position real(kind=DP), public, dimension(:,:), allocatable :: vj Jacobi velocity real(kind=DP), public, dimension(:), allocatable :: muj Jacobi mu: GMcb * eta(i) / eta(i - 1) real(kind=DP), public, dimension(:), allocatable :: ir3j Third term of heliocentric acceleration\n Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the\n    component list, such as whm_setup_pl and whm_util_spill_pl Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file interface public module subroutine io_dump_base(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file interface public module subroutine io_dump_particle_info_base(self, param, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format interface public module subroutine netcdf_write_frame_base(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file interface public module subroutine netcdf_write_particle_info_base(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset generic, public :: write_particle_info => write_particle_info_netcdf public interface netcdf_write_particle_info_base () Arguments None procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file interface public module subroutine io_read_in_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module function io_read_frame_body(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step generic, public :: write_frame => write_frame_netcdf , write_frame_bin Add the generic write frame for Fortran binary files public interface netcdf_write_frame_base () Arguments None public interface io_write_frame_body () Arguments None procedure, public :: discard => discard_pl Placeholder method for discarding massive bodies interface public module subroutine discard_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameter procedure, public :: index => util_index_eucl_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix interface public module subroutine util_index_eucl_plpl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies interface public module subroutine kick_getacch_int_pl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body interface public module subroutine tides_kick_getacch_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: vh2vb => util_coord_vh2vb_pl Convert massive bodies from heliocentric to barycentric coordinates (velocity only) interface public module subroutine util_coord_vh2vb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: vb2vh => util_coord_vb2vh_pl Convert massive bodies from barycentric to heliocentric coordinates (velocity only) interface public module subroutine util_coord_vb2vh_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xh2xb => util_coord_xh2xb_pl Convert massive bodies from heliocentric to barycentric coordinates (position only) interface public module subroutine util_coord_xh2xb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. interface public module subroutine util_set_beg_end_pl(self, xbeg, xend, vbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object real(kind=DP), intent(in), optional dimension(:,:) :: xbeg Position vectors at beginning of step real(kind=DP), intent(in), optional dimension(:,:) :: xend Positions vectors at end of step real(kind=DP), intent(in), optional dimension(:,:) :: vbeg vbeg is an unused variable to keep this method forward compatible with RMVS procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body interface public module subroutine util_set_rhill(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: h2j => whm_coord_h2j_pl Convert position and velcoity vectors from heliocentric to Jacobi coordinates interface public module subroutine whm_coord_h2j_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree procedure, public :: j2h => whm_coord_j2h_pl Convert position and velcoity vectors from Jacobi to helliocentric coordinates interface public module subroutine whm_coord_j2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree procedure, public :: vh2vj => whm_coord_vh2vj_pl Convert velocity vectors from heliocentric to Jacobi coordinates interface public module subroutine whm_coord_vh2vj_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree procedure, public :: drift => whm_drift_pl Loop through massive bodies and call Danby drift routine to jacobi coordinates interface public module subroutine whm_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: accel_gr => whm_gr_kick_getacch_pl Acceleration term arising from the post-Newtonian correction interface public pure module subroutine whm_gr_kick_getacch_pl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: gr_pos_kick => whm_gr_p4_pl Position kick due to p**4 term in the post-Newtonian correction interface public pure module subroutine whm_gr_p4_pl(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size procedure, public :: accel => whm_kick_getacch_pl Compute heliocentric accelerations of massive bodies interface public module subroutine whm_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Get heliocentric accelration of massive bodies Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step procedure, public :: kick => whm_kick_vh_pl Kick heliocentric velocities of massive bodies interface public module subroutine whm_kick_vh_pl(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure, public :: append => whm_util_append_pl Appends elements from one structure to another interface public module subroutine whm_util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: fill => whm_util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine whm_util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(in) :: inserts inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: resize => whm_util_resize_pl Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. interface public module subroutine whm_util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: set_ir3 => whm_util_set_ir3j Sets both the heliocentric and jacobi inverse radius terms (1/rj 3 and 1/rh 3) interface public module subroutine whm_util_set_ir3j(self) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object procedure, public :: set_mu => whm_util_set_mu_eta_pl Sets the Jacobi mass value for all massive bodies. interface public module subroutine whm_util_set_mu_eta_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: sort => whm_util_sort_pl Sort a WHM massive body object in-place. interface public module subroutine whm_util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => whm_util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine whm_util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => whm_util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine whm_util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not procedure, public :: setup => whm_setup_pl Constructor method - Allocates space for the input number of bodiess interface public module subroutine whm_setup_pl(self, n, param) Implementation → Reads WHM massive body object in from file Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body objectobject integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: step => whm_step_pl Steps the body forward one stepsize interface public module subroutine whm_step_pl(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"type/whm_pl.html"},{"title":"whm_tp – swiftest ","text":"type, public, extends( swiftest_tp ) :: whm_tp Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the\n    component list, such as whm_util_spill_tp Inherits type~~whm_tp~~InheritsGraph type~whm_tp whm_tp type~swiftest_tp swiftest_tp type~whm_tp->type~swiftest_tp type~swiftest_body swiftest_body type~swiftest_tp->type~swiftest_body type~swiftest_particle_info swiftest_particle_info type~swiftest_body->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~whm_tp~~InheritedByGraph type~whm_tp whm_tp type~rmvs_tp rmvs_tp type~rmvs_tp->type~whm_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lfirst nbody info id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm isperi peri atp k_pltp npltp Type-Bound Procedures dump dump_particle_info write_frame_netcdf write_particle_info_netcdf write_particle_info drift v2pv pv2v read_in read_frame write_frame_bin el2xv xv2el accel_user set_ir3 write_frame discard accel_int accel_obl setup append h2b b2h vb2vh vh2vb xh2xb fill get_peri resize set_mu sort rearrange spill accel_gr gr_pos_kick accel kick step Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill integer(kind=I4B), public, dimension(:), allocatable :: isperi Perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri Perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp Semimajor axis following perihelion passage integer(kind=I4B), public, dimension(:,:), allocatable :: k_pltp Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: npltp Number of pl-tp comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_tp and util_spill_tp Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file interface public module subroutine io_dump_base(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file interface public module subroutine io_dump_particle_info_base(self, param, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format interface public module subroutine netcdf_write_frame_base(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file interface public module subroutine netcdf_write_particle_info_base(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset generic, public :: write_particle_info => write_particle_info_netcdf public interface netcdf_write_particle_info_base () Arguments None procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables interface public module subroutine drift_body(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file interface public module subroutine io_read_in_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module function io_read_frame_body(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object generic, public :: write_frame => write_frame_netcdf , write_frame_bin Add the generic write frame for Fortran binary files public interface netcdf_write_frame_base () Arguments None public interface io_write_frame_body () Arguments None procedure, public :: discard => discard_tp Check to see if test particles should be discarded based on their positions relative to the massive bodies interface public module subroutine discard_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: accel_int => kick_getacch_int_tp Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies interface public module subroutine kick_getacch_int_tp(self, GMpl, xhp, npl) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle real(kind=DP), intent(in), dimension(:) :: GMpl Massive body masses real(kind=DP), intent(in), dimension(:,:) :: xhp Massive body position vectors integer(kind=I4B), intent(in) :: npl Number of active massive bodies procedure, public :: accel_obl => obl_acc_tp Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_tp(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: setup => setup_tp A base constructor that sets the number of bodies and interface public module subroutine setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parametersr procedure, public :: append => util_append_tp Appends elements from one structure to another interface public module subroutine util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: h2b => util_coord_h2b_tp Convert test particles from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_tp Convert test particles from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: vb2vh => util_coord_vb2vh_tp Convert test particles from barycentric to heliocentric coordinates (velocity only) interface public module subroutine util_coord_vb2vh_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body procedure, public :: vh2vb => util_coord_vh2vb_tp Convert test particles from heliocentric to barycentric coordinates (velocity only) interface public module subroutine util_coord_vh2vb_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body procedure, public :: xh2xb => util_coord_xh2xb_tp Convert test particles from heliocentric to barycentric coordinates (position only) interface public module subroutine util_coord_xh2xb_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: fill => util_fill_tp \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: get_peri => util_peri_tp Determine system pericenter passages for test particles interface public module subroutine util_peri_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: resize => util_resize_tp Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. interface public module subroutine util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: set_mu => util_set_mu_tp Method used to construct the vectorized form of the central body mass interface public module subroutine util_set_mu_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: sort => util_sort_tp Sorts body arrays by a sortable component interface public module subroutine util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => util_sort_rearrange_tp Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => util_spill_tp \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not procedure, public :: accel_gr => whm_gr_kick_getacch_tp Acceleration term arising from the post-Newtonian correction interface public pure module subroutine whm_gr_kick_getacch_tp(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: gr_pos_kick => whm_gr_p4_tp Position kick due to p**4 term in the post-Newtonian correction interface public pure module subroutine whm_gr_p4_tp(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size procedure, public :: accel => whm_kick_getacch_tp Compute heliocentric accelerations of test particles interface public module subroutine whm_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Get heliocentric accelration of the test particle Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step procedure, public :: kick => whm_kick_vh_tp Kick heliocentric velocities of test particles interface public module subroutine whm_kick_vh_tp(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure, public :: step => whm_step_tp Steps the particle forward one stepsize interface public module subroutine whm_step_tp(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"type/whm_tp.html"},{"title":"whm_nbody_system – swiftest ","text":"type, public, extends( swiftest_nbody_system ) :: whm_nbody_system An abstract class for the WHM integrator nbody system Inherits type~~whm_nbody_system~~InheritsGraph type~whm_nbody_system whm_nbody_system type~swiftest_nbody_system swiftest_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~swiftest_cb swiftest_cb type~swiftest_nbody_system->type~swiftest_cb cb type~swiftest_pl swiftest_pl type~swiftest_nbody_system->type~swiftest_pl pl, pl_discards type~swiftest_tp swiftest_tp type~swiftest_nbody_system->type~swiftest_tp tp, tp_discards type~swiftest_particle_info swiftest_particle_info type~swiftest_cb->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_cb->type~swiftest_base type~swiftest_body swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_tp->type~swiftest_body type~swiftest_body->type~swiftest_particle_info info type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~whm_nbody_system~~InheritedByGraph type~whm_nbody_system whm_nbody_system type~rmvs_nbody_system rmvs_nbody_system type~rmvs_nbody_system->type~whm_nbody_system type~helio_nbody_system helio_nbody_system type~helio_nbody_system->type~whm_nbody_system type~rmvs_pl rmvs_pl type~rmvs_pl->type~rmvs_nbody_system planetocentric type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~helio_nbody_system Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables cb pl tp tp_discards pl_discards GMtot ke_orbit ke_spin pe te oblpot Lorbit Lspin Ltot lbeg Type-Bound Procedures discard conservation_report dump get_old_t_final read_frame read_particle_info write_discard write_frame write_hdr_bin write_hdr_netcdf obl_pot init_particle_info step_spin set_msys get_energy_and_momentum rescale validate_ids write_hdr initialize step Components Type Visibility Attributes Name Initial class( swiftest_cb ), public, allocatable :: cb Central body data structure class( swiftest_pl ), public, allocatable :: pl Massive body data structure class( swiftest_tp ), public, allocatable :: tp Test particle data structure class( swiftest_tp ), public, allocatable :: tp_discards Discarded test particle data structure class( swiftest_pl ), public, allocatable :: pl_discards Discarded massive body particle data structure real(kind=DP), public :: GMtot = 0.0_DP Total system mass - used for barycentric coordinate conversion real(kind=DP), public :: ke_orbit = 0.0_DP System orbital kinetic energy real(kind=DP), public :: ke_spin = 0.0_DP System spin kinetic energy real(kind=DP), public :: pe = 0.0_DP System potential energy real(kind=DP), public :: te = 0.0_DP System total energy real(kind=DP), public :: oblpot = 0.0_DP System potential energy due to oblateness of the central body real(kind=DP), public, dimension(NDIM) :: Lorbit = 0.0_DP System orbital angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lspin = 0.0_DP System spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Ltot = 0.0_DP System angular momentum vector logical, public :: lbeg True if this is the beginning of a step. This is used so that test particle steps can be calculated \n    separately from massive bodies.  Massive body variables are saved at half steps, and passed to \n    the test particles Type-Bound Procedures procedure, public :: discard => discard_system Perform a discard step on the system interface public module subroutine discard_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: conservation_report => io_conservation_report Compute energy and momentum and print out the change with time interface public module subroutine io_conservation_report(self, param, lterminal) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Input colleciton of user-defined parameters logical, intent(in) :: lterminal Indicates whether to output information to the terminal screen procedure, public :: dump => io_dump_system Dump the state of the system to a file interface public module subroutine io_dump_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: get_old_t_final => io_get_old_t_final_system Validates the dump file to check whether the dump file initial conditions duplicate the last frame of the binary output. interface public module function io_get_old_t_final_system(self, param) result(old_t_final) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self class( swiftest_parameters ), intent(in) :: param Return Value real(kind=DP) procedure, public :: read_frame => io_read_frame_system Read in a frame of input data from file interface public module function io_read_frame_system(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: read_particle_info => io_read_particle_info_system Read in particle metadata from file interface public module subroutine io_read_particle_info_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: write_discard => io_write_discard Write out information about discarded test particles interface public module subroutine io_write_discard(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: write_frame => io_write_frame_system Append a frame of output data to file interface public module subroutine io_write_frame_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: write_hdr_bin => io_write_hdr_system Write a header for an output frame in Fortran binary format interface public module subroutine io_write_hdr_system(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest nbody system object integer(kind=I4B), intent(inout) :: iu Output file unit number class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_hdr_netcdf => netcdf_write_hdr_system Write a header for an output frame in NetCDF format interface public module subroutine netcdf_write_hdr_system(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest nbody system object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: obl_pot => obl_pot_system Compute the contribution to the total gravitational potential due solely to the oblateness of the central body interface public module subroutine obl_pot_system(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object procedure, public :: init_particle_info => setup_initialize_particle_info_system Initialize the system from input files interface public module subroutine setup_initialize_particle_info_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: step_spin => tides_step_spin_system Steps the spins of the massive & central bodies due to tides. interface public module subroutine tides_step_spin_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure, public :: set_msys => util_set_msys Sets the value of msys from the masses of system bodies. interface public module subroutine util_set_msys(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object procedure, public :: get_energy_and_momentum => util_get_energy_momentum_system Calculates the total system energy and momentum interface public module subroutine util_get_energy_momentum_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: rescale => util_rescale_system Rescales the system into a new set of units interface public module subroutine util_rescale_system(self, param, mscale, dscale, tscale) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters. Returns with new values of the scale vactors and GU real(kind=DP), intent(in) :: mscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: dscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: tscale Scale factors for mass, distance, and time units, respectively. procedure, public :: validate_ids => util_valid_id_system Validate the numerical ids passed to the system and save the maximum value interface public module subroutine util_valid_id_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters generic, public :: write_hdr => write_hdr_bin , write_hdr_netcdf Generic method call for writing headers public interface io_write_hdr_system () Arguments None public interface netcdf_write_hdr_system () Arguments None procedure, public :: initialize => whm_setup_initialize_system Replace the abstract procedures with concrete ones interface public module subroutine whm_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_nbody_system ), intent(inout) :: self WHM nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters procedure, public :: step => whm_step_system Advance the WHM nbody system forward in time by one step interface public module subroutine whm_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_nbody_system ), intent(inout) :: self WHM system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"type/whm_nbody_system.html"},{"title":"fraggle_colliders – swiftest ","text":"type, public :: fraggle_colliders Class definition for the variables that describe the bodies involved in the collision Contents Variables ncoll idx xb vb rot L_spin L_orbit Ip mass radius Type-Bound Procedures regime Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: ncoll Number of bodies involved in the collision integer(kind=I4B), public, dimension(:), allocatable :: idx Index of bodies involved in the collision real(kind=DP), public, dimension(NDIM,2) :: xb Two-body equivalent position vectors of the collider bodies prior to collision real(kind=DP), public, dimension(NDIM,2) :: vb Two-body equivalent velocity vectors of the collider bodies prior to collision real(kind=DP), public, dimension(NDIM,2) :: rot Two-body equivalent principal axes moments of inertia the collider bodies prior to collision real(kind=DP), public, dimension(NDIM,2) :: L_spin Two-body equivalent spin angular momentum vectors of the collider bodies prior to collision real(kind=DP), public, dimension(NDIM,2) :: L_orbit Two-body equivalent orbital angular momentum vectors of the collider bodies prior to collision real(kind=DP), public, dimension(NDIM,2) :: Ip Two-body equivalent principal axes moments of inertia the collider bodies prior to collision real(kind=DP), public, dimension(2) :: mass Two-body equivalent mass of the collider bodies prior to the collision real(kind=DP), public, dimension(2) :: radius Two-body equivalent radii of the collider bodies prior to the collision Type-Bound Procedures procedure, public :: regime => fraggle_regime_colliders Determine which fragmentation regime the set of colliders will be interface public module subroutine fraggle_regime_colliders(self, frag, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_colliders ), intent(inout) :: self Fraggle colliders object class( fraggle_fragments ), intent(inout) :: frag Fraggle fragment system object class( swiftest_nbody_system ), intent(in) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current Swiftest run configuration parameters","tags":"","loc":"type/fraggle_colliders.html"},{"title":"fraggle_fragments – swiftest ","text":"type, public, extends( swiftest_pl ) :: fraggle_fragments Class definition for the variables that describe a collection of fragments by Fraggle barycentric coordinates Inherits type~~fraggle_fragments~~InheritsGraph type~fraggle_fragments fraggle_fragments type~swiftest_pl swiftest_pl type~fraggle_fragments->type~swiftest_pl type~swiftest_body swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_particle_info swiftest_particle_info type~swiftest_body->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lfirst nbody info id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm mass Gmass rhill radius xbeg xend vbeg density Ip rot k2 Q tlag k_plpl nplpl mtot Qloss mass_dist regime xbcom vbcom x_coll_unit y_coll_unit z_coll_unit x_coll v_coll v_r_unit v_t_unit v_n_unit rmag rotmag v_r_mag v_t_mag ke_orbit ke_spin L_orbit L_spin ke_budget L_budget Lorbit_before Lorbit_after Lspin_before Lspin_after Ltot_before Ltot_after ke_orbit_before ke_orbit_after ke_spin_before ke_spin_after pe_before pe_after Etot_before Etot_after dscale mscale tscale vscale Escale Lscale Type-Bound Procedures dump dump_particle_info write_frame_netcdf write_particle_info_netcdf write_particle_info drift v2pv pv2v read_in read_frame write_frame_bin el2xv xv2el accel_user set_ir3 write_frame discard index accel_int accel_obl accel_tides append h2b b2h vh2vb vb2vh xh2xb fill resize set_beg_end set_mu set_rhill sort rearrange spill generate_fragments accel kick step set_budgets set_coordinate_system set_mass_dist set_natural_scale set_original_scale setup reset get_ang_mtm get_energy_and_momentum restructure Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl real(kind=DP), public :: mtot Total mass of fragments real(kind=DP), public :: Qloss Energy lost during the collision real(kind=DP), public, dimension(FRAGGLE_NMASS_DIST) :: mass_dist Distribution of fragment mass determined by the regime calculation (largest fragment, second largest, and remainder) integer(kind=I4B), public :: regime Collresolve regime code for this collision real(kind=DP), public, dimension(NDIM) :: xbcom Center of mass position vector of the collider system in system barycentric coordinates real(kind=DP), public, dimension(NDIM) :: vbcom Velocity vector of the center of mass of the collider system in system barycentric coordinates real(kind=DP), public, dimension(NDIM) :: x_coll_unit x-direction unit vector of collisional system real(kind=DP), public, dimension(NDIM) :: y_coll_unit y-direction unit vector of collisional system real(kind=DP), public, dimension(NDIM) :: z_coll_unit z-direction unit vector of collisional system real(kind=DP), public, dimension(:,:), allocatable :: x_coll Array of fragment position vectors in the collisional coordinate frame real(kind=DP), public, dimension(:,:), allocatable :: v_coll Array of fragment velocity vectors in the collisional coordinate frame real(kind=DP), public, dimension(:,:), allocatable :: v_r_unit Array of radial direction unit vectors of individual fragments in the collisional coordinate frame real(kind=DP), public, dimension(:,:), allocatable :: v_t_unit Array of tangential direction unit vectors of individual fragments in the collisional coordinate frame real(kind=DP), public, dimension(:,:), allocatable :: v_n_unit Array of normal direction unit vectors of individual fragments in the collisional coordinate frame real(kind=DP), public, dimension(:), allocatable :: rmag Array of radial distance magnitudes of individual fragments in the collisional coordinate frame real(kind=DP), public, dimension(:), allocatable :: rotmag Array of rotation magnitudes of individual fragments real(kind=DP), public, dimension(:), allocatable :: v_r_mag Array of radial direction velocity magnitudes of individual fragments real(kind=DP), public, dimension(:), allocatable :: v_t_mag Array of tangential direction velocity magnitudes of individual fragments real(kind=DP), public :: ke_orbit Current orbital kinetic energy of the system of fragments in the collisional frame real(kind=DP), public :: ke_spin Current spin kinetic energy of the system of fragments in the collisional frame real(kind=DP), public, dimension(NDIM) :: L_orbit Current orbital angular momentum of the system of fragments in the collisional frame real(kind=DP), public, dimension(NDIM) :: L_spin Current spin angular momentum of the system of fragments in the collisional frame real(kind=DP), public :: ke_budget Total kinetic energy budget for the system of fragmens in the collisional frame real(kind=DP), public, dimension(NDIM) :: L_budget Total angular momentum budget for the system of fragmens in the collisional frame real(kind=DP), public, dimension(NDIM) :: Lorbit_before Before/after orbital angular momentum real(kind=DP), public, dimension(NDIM) :: Lorbit_after Before/after orbital angular momentum real(kind=DP), public, dimension(NDIM) :: Lspin_before Before/after spin angular momentum real(kind=DP), public, dimension(NDIM) :: Lspin_after Before/after spin angular momentum real(kind=DP), public, dimension(NDIM) :: Ltot_before Before/after total system angular momentum real(kind=DP), public, dimension(NDIM) :: Ltot_after Before/after total system angular momentum real(kind=DP), public :: ke_orbit_before Before/after orbital kinetic energy real(kind=DP), public :: ke_orbit_after Before/after orbital kinetic energy real(kind=DP), public :: ke_spin_before Before/after spin kinetic energy real(kind=DP), public :: ke_spin_after Before/after spin kinetic energy real(kind=DP), public :: pe_before Before/after potential energy real(kind=DP), public :: pe_after Before/after potential energy real(kind=DP), public :: Etot_before Before/after total system energy real(kind=DP), public :: Etot_after Before/after total system energy real(kind=DP), public :: dscale Distance dimension scale factor real(kind=DP), public :: mscale Mass scale factor real(kind=DP), public :: tscale Time scale factor real(kind=DP), public :: vscale Velocity scale factor (a convenience unit that is derived from dscale and tscale) real(kind=DP), public :: Escale Energy scale factor (a convenience unit that is derived from dscale, tscale, and mscale) real(kind=DP), public :: Lscale Angular momentum scale factor (a convenience unit that is derived from dscale, tscale, and mscale) Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file interface public module subroutine io_dump_base(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file interface public module subroutine io_dump_particle_info_base(self, param, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format interface public module subroutine netcdf_write_frame_base(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file interface public module subroutine netcdf_write_particle_info_base(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset generic, public :: write_particle_info => write_particle_info_netcdf public interface netcdf_write_particle_info_base () Arguments None procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables interface public module subroutine drift_body(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file interface public module subroutine io_read_in_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module function io_read_frame_body(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object generic, public :: write_frame => write_frame_netcdf , write_frame_bin Add the generic write frame for Fortran binary files public interface netcdf_write_frame_base () Arguments None public interface io_write_frame_body () Arguments None procedure, public :: discard => discard_pl Placeholder method for discarding massive bodies interface public module subroutine discard_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameter procedure, public :: index => util_index_eucl_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix interface public module subroutine util_index_eucl_plpl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies interface public module subroutine kick_getacch_int_pl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body interface public module subroutine tides_kick_getacch_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: append => util_append_pl Appends elements from one structure to another interface public module subroutine util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: vh2vb => util_coord_vh2vb_pl Convert massive bodies from heliocentric to barycentric coordinates (velocity only) interface public module subroutine util_coord_vh2vb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: vb2vh => util_coord_vb2vh_pl Convert massive bodies from barycentric to heliocentric coordinates (velocity only) interface public module subroutine util_coord_vb2vh_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xh2xb => util_coord_xh2xb_pl Convert massive bodies from heliocentric to barycentric coordinates (position only) interface public module subroutine util_coord_xh2xb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: fill => util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: resize => util_resize_pl Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. interface public module subroutine util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. interface public module subroutine util_set_beg_end_pl(self, xbeg, xend, vbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object real(kind=DP), intent(in), optional dimension(:,:) :: xbeg Position vectors at beginning of step real(kind=DP), intent(in), optional dimension(:,:) :: xend Positions vectors at end of step real(kind=DP), intent(in), optional dimension(:,:) :: vbeg vbeg is an unused variable to keep this method forward compatible with RMVS procedure, public :: set_mu => util_set_mu_pl Method used to construct the vectorized form of the central body mass interface public module subroutine util_set_mu_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body interface public module subroutine util_set_rhill(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: sort => util_sort_pl Sorts body arrays by a sortable component interface public module subroutine util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not procedure, public :: generate_fragments => fraggle_generate_fragments Generates a system of fragments in barycentric coordinates that conserves energy and momentum. interface public module subroutine fraggle_generate_fragments(self, colliders, system, param, lfailure) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle colliders object containing the two-body equivalent values of the colliding bodies class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters logical, intent(out) :: lfailure Answers the question: Should this have been a merger instead? procedure, public :: accel => fraggle_placeholder_accel Placeholder subroutine to fulfill requirement for an accel method interface public module subroutine fraggle_placeholder_accel(self, system, param, t, lbeg) Implementation → The following interfaces are placeholders intended to satisfy the required abstract methods given by the parent class Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: kick => fraggle_placeholder_kick Placeholder subroutine to fulfill requirement for a kick method interface public module subroutine fraggle_placeholder_kick(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system objec class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure, public :: step => fraggle_placeholder_step Placeholder subroutine to fulfill requirement for a step method interface public module subroutine fraggle_placeholder_step(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Helio massive body particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nboody system class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsiz procedure, public :: set_budgets => fraggle_set_budgets_fragments Sets the energy and momentum budgets of the fragments based on the collider value interface public module subroutine fraggle_set_budgets_fragments(self, colliders) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object procedure, public :: set_coordinate_system => fraggle_set_coordinate_system Defines the collisional coordinate system, including the unit vectors of both the system and individual fragments. interface public module subroutine fraggle_set_coordinate_system(self, colliders) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object procedure, public :: set_mass_dist => fraggle_set_mass_dist_fragments Sets the distribution of mass among the fragments depending on the regime type interface public module subroutine fraggle_set_mass_dist_fragments(self, colliders, param) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object class( swiftest_parameters ), intent(in) :: param Current Swiftest run configuration parameters procedure, public :: set_natural_scale => fraggle_set_natural_scale_factors Scales dimenional quantities to ~O(1) with respect to the collisional system. interface public module subroutine fraggle_set_natural_scale_factors(self, colliders) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object procedure, public :: set_original_scale => fraggle_set_original_scale_factors Restores dimenional quantities back to the original system units interface public module subroutine fraggle_set_original_scale_factors(self, colliders) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object procedure, public :: setup => fraggle_setup_fragments Allocates arrays for n fragments in a Fraggle system. Passing n = 0 deallocates all arrays. interface public module subroutine fraggle_setup_fragments(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object integer(kind=I4B), intent(in) :: n Number of fragments class( swiftest_parameters ), intent(in) :: param Current swiftest run configuration parameters procedure, public :: reset => fraggle_setup_reset_fragments Resets all position and velocity-dependent fragment quantities in order to do a fresh calculation (does not reset mass, radius, or other values that get set prior to the call to fraggle_generate) interface public module subroutine fraggle_setup_reset_fragments(self) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self procedure, public :: get_ang_mtm => fraggle_util_ang_mtm Calcualtes the current angular momentum of the fragments interface public module subroutine fraggle_util_ang_mtm(self) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object procedure, public :: get_energy_and_momentum => fraggle_util_get_energy_momentum Calculates total system energy in either the pre-collision outcome state (lbefore = .true.) or the post-collision outcome state (lbefore = .false.) interface public module subroutine fraggle_util_get_energy_momentum(self, colliders, system, param, lbefore) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current swiftest run configuration parameters logical, intent(in) :: lbefore Flag indicating that this the \"before\" state of the system, with colliders included and fragments excluded or vice versa procedure, public :: restructure => fraggle_util_restructure Restructure the inputs after a failed attempt failed to find a set of positions and velocities that satisfy the energy and momentum constraints interface public module subroutine fraggle_util_restructure(self, colliders, try, f_spin, r_max_start) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(in) :: colliders Fraggle collider system object integer(kind=I4B), intent(in) :: try The current number of times Fraggle has tried to find a solution real(kind=DP), intent(inout) :: f_spin Fraction of energy/momentum that goes into spin. This decreases ater a failed attempt real(kind=DP), intent(inout) :: r_max_start The maximum radial distance that the position calculation starts with. This increases after a failed attempt","tags":"","loc":"type/fraggle_fragments.html"},{"title":"symba_parameters – swiftest ","text":"type, public, extends( swiftest_parameters ) :: symba_parameters Inherits type~~symba_parameters~~InheritsGraph type~symba_parameters symba_parameters type~swiftest_parameters swiftest_parameters type~symba_parameters->type~swiftest_parameters type~netcdf_parameters netcdf_parameters type~swiftest_parameters->type~netcdf_parameters nciu Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables integrator maxid t0 t tstop dt ioutput incbfile inplfile intpfile in_type in_form istep_out outfile out_type out_form out_stat particle_out istep_dump rmin rmax rmaxu qmin qmin_coord qmin_alo qmin_ahi enc_out discard_out MU2KG TU2S DU2M GU inv_c2 energy_out lrhill_present lextra_force lbig_discard lclose lenergy loblatecb lrotation ltides Eorbit_orig GMtot_orig Ltot_orig Lorbit_orig Lspin_orig Lescape GMescape Ecollisions Euntracked lfirstenergy lfirstkick lrestart lgr lyarkovsky lyorp nciu GMTINY min_GMfrag seed lfragmentation Type-Bound Procedures dump read_in reader writer Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: integrator = UNKNOWN_INTEGRATOR Symbolic name of the nbody integrator  used integer(kind=I4B), public :: maxid = -1 The current maximum particle id number real(kind=DP), public :: t0 = -1.0_DP Integration start time real(kind=DP), public :: t = -1.0_DP Integration current time real(kind=DP), public :: tstop = -1.0_DP Integration stop time real(kind=DP), public :: dt = -1.0_DP Time step integer(kind=I8B), public :: ioutput = 0_I8B Output counter character(len=STRMAX), public :: incbfile = CB_INFILE Name of input file for the central body character(len=STRMAX), public :: inplfile = PL_INFILE Name of input file for massive bodies character(len=STRMAX), public :: intpfile = TP_INFILE Name of input file for test particles character(len=STRMAX), public :: in_type = ASCII_TYPE Data representation type of input data files character(len=STRMAX), public :: in_form = XV Format of input data files (EL or XV) integer(kind=I4B), public :: istep_out = -1 Number of time steps between binary outputs character(len=STRMAX), public :: outfile = NETCDF_OUTFILE Name of output binary file character(len=STRMAX), public :: out_type = NETCDF_DOUBLE_TYPE Binary format of output file character(len=STRMAX), public :: out_form = XVEL Data to write to output file character(len=STRMAX), public :: out_stat = 'NEW' Open status for output binary file character(len=STRMAX), public :: particle_out = PARTICLE_OUTFILE Name of output particle information file integer(kind=I4B), public :: istep_dump = -1 Number of time steps between dumps real(kind=DP), public :: rmin = -1.0_DP Minimum heliocentric radius for test particle real(kind=DP), public :: rmax = -1.0_DP Maximum heliocentric radius for test particle real(kind=DP), public :: rmaxu = -1.0_DP Maximum unbound heliocentric radius for test particle real(kind=DP), public :: qmin = -1.0_DP Minimum pericenter distance for test particle character(len=STRMAX), public :: qmin_coord = 'HELIO' Coordinate frame to use for qmin real(kind=DP), public :: qmin_alo = -1.0_DP Minimum semimajor axis for qmin real(kind=DP), public :: qmin_ahi = -1.0_DP Maximum semimajor axis for qmin character(len=STRMAX), public :: enc_out = \"\" Name of output file for encounters character(len=STRMAX), public :: discard_out = \"\" Name of output file for discards real(kind=QP), public :: MU2KG = -1.0_QP Converts mass units to grams real(kind=QP), public :: TU2S = -1.0_QP Converts time units to seconds real(kind=QP), public :: DU2M = -1.0_QP Converts distance unit to centimeters real(kind=DP), public :: GU = -1.0_DP Universal gravitational constant in the system units real(kind=DP), public :: inv_c2 = -1.0_DP Inverse speed of light squared in the system units character(len=STRMAX), public :: energy_out = \"\" Name of output energy and momentum report file logical, public :: lrhill_present = .false. Hill radii are given as an input rather than calculated by the code (can be used to inflate close encounter regions manually) logical, public :: lextra_force = .false. User defined force function turned on logical, public :: lbig_discard = .false. Save big bodies on every discard logical, public :: lclose = .false. Turn on close encounters logical, public :: lenergy = .false. Track the total energy of the system logical, public :: loblatecb = .false. Calculate acceleration from oblate central body (automatically turns true if nonzero J2 is input) logical, public :: lrotation = .false. Include rotation states of big bodies logical, public :: ltides = .false. Include tidal dissipation real(kind=DP), public :: Eorbit_orig = 0.0_DP Initial orbital energy real(kind=DP), public :: GMtot_orig = 0.0_DP Initial system mass real(kind=DP), public, dimension(NDIM) :: Ltot_orig = 0.0_DP Initial total angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lorbit_orig = 0.0_DP Initial orbital angular momentum real(kind=DP), public, dimension(NDIM) :: Lspin_orig = 0.0_DP Initial spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lescape = 0.0_DP Angular momentum of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: GMescape = 0.0_DP Mass of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Ecollisions = 0.0_DP Energy lost from system due to collisions real(kind=DP), public :: Euntracked = 0.0_DP Energy gained from system due to escaped bodies logical, public :: lfirstenergy = .true. This is the first time computing energe logical, public :: lfirstkick = .true. Initiate the first kick in a symplectic step logical, public :: lrestart = .false. Indicates whether or not this is a restarted run logical, public :: lgr = .false. Turn on GR logical, public :: lyarkovsky = .false. Turn on Yarkovsky effect logical, public :: lyorp = .false. Turn on YORP effect type( netcdf_parameters ), public :: nciu Object containing NetCDF parameters real(kind=DP), public :: GMTINY = -1.0_DP Smallest G*mass that is fully gravitating real(kind=DP), public :: min_GMfrag = -1.0_DP Smallest G*mass that can be produced in a fragmentation event integer(kind=I4B), public, dimension(:), allocatable :: seed Random seeds logical, public :: lfragmentation = .false. Do fragmentation modeling instead of simple merger. Type-Bound Procedures procedure, public :: dump => io_dump_param interface public module subroutine io_dump_param(self, param_file_name) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Output collection of parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in) procedure, public :: read_in => io_read_in_param interface public module subroutine io_read_in_param(self, param_file_name) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Current run configuration parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in) procedure, public :: reader => symba_io_param_reader interface public module subroutine symba_io_param_reader(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_parameters ), intent(inout) :: self Current run configuration parameters with SyMBA additionss integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) The first element passes the integrator code to the reader integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 procedure, public :: writer => symba_io_param_writer interface public module subroutine symba_io_param_writer(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_parameters ), intent(in) :: self Current run configuration parameters with SyMBA additions integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) Not used in this procedure integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0","tags":"","loc":"type/symba_parameters.html"},{"title":"symba_kinship – swiftest ","text":"type, public :: symba_kinship Class definition for the kinship relationships used in bookkeeping multiple collisions bodies in a single time step. Inherited by type~~symba_kinship~~InheritedByGraph type~symba_kinship symba_kinship type~symba_pl symba_pl type~symba_pl->type~symba_kinship kin type~symba_merger symba_merger type~symba_merger->type~symba_pl type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~symba_merger pl_adds Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables parent nchild child Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: parent Index of parent particle integer(kind=I4B), public :: nchild number of children in merger list integer(kind=I4B), public, dimension(:), allocatable :: child Index of children particles","tags":"","loc":"type/symba_kinship.html"},{"title":"symba_cb – swiftest ","text":"type, public, extends( helio_cb ) :: symba_cb SyMBA central body particle class Inherits type~~symba_cb~~InheritsGraph type~symba_cb symba_cb type~helio_cb helio_cb type~symba_cb->type~helio_cb type~swiftest_cb swiftest_cb type~helio_cb->type~swiftest_cb type~swiftest_particle_info swiftest_particle_info type~swiftest_cb->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_cb->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables info id mass Gmass radius density j2rp2 j4rp4 aobl atide aoblbeg aoblend atidebeg atideend xb vb agr Ip rot k2 Q tlag L0 dL ptbeg ptend GM0 dGM R0 dR Type-Bound Procedures dump dump_particle_info write_frame_netcdf write_particle_info_netcdf write_particle_info read_in read_frame write_frame_bin write_frame Components Type Visibility Attributes Name Initial type( swiftest_particle_info ), public :: info Particle metadata information integer(kind=I4B), public :: id = 0 External identifier (unique) real(kind=DP), public :: mass = 0.0_DP Central body mass (units MU) real(kind=DP), public :: Gmass = 0.0_DP Central mass gravitational term G * mass (units GU * MU) real(kind=DP), public :: radius = 0.0_DP Central body radius (units DU) real(kind=DP), public :: density = 1.0_DP Central body mass density - calculated internally (units MU / DU**3) real(kind=DP), public :: j2rp2 = 0.0_DP J2*R&#94;2 term for central body real(kind=DP), public :: j4rp4 = 0.0_DP J4*R&#94;2 term for central body real(kind=DP), public, dimension(NDIM) :: aobl = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: atide = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: aoblbeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: aoblend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: atidebeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: atideend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: xb = 0.0_DP Barycentric position (units DU) real(kind=DP), public, dimension(NDIM) :: vb = 0.0_DP Barycentric velocity (units DU / TU) real(kind=DP), public, dimension(NDIM) :: agr = 0.0_DP Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(NDIM) :: Ip = 0.0_DP Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(NDIM) :: rot = 0.0_DP Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public :: k2 = 0.0_DP Tidal Love number real(kind=DP), public :: Q = 0.0_DP Tidal quality factor real(kind=DP), public :: tlag = 0.0_DP Tidal phase lag angle real(kind=DP), public, dimension(NDIM) :: L0 = 0.0_DP Initial angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: dL = 0.0_DP Change in angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: ptbeg negative barycentric velocity of the central body at the beginning of time step real(kind=DP), public, dimension(NDIM) :: ptend negative barycentric velocity of the central body at the end of time step real(kind=DP), public :: GM0 = 0.0_DP Initial G*mass of the central body real(kind=DP), public :: dGM = 0.0_DP Change in G*mass of the central body real(kind=DP), public :: R0 = 0.0_DP Initial radius of the central body real(kind=DP), public :: dR = 0.0_DP Change in the radius of the central body Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file interface public module subroutine io_dump_base(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file interface public module subroutine io_dump_particle_info_base(self, param, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format interface public module subroutine netcdf_write_frame_base(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file interface public module subroutine netcdf_write_particle_info_base(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset generic, public :: write_particle_info => write_particle_info_netcdf public interface netcdf_write_particle_info_base () Arguments None procedure, public :: read_in => io_read_in_cb I/O routine for reading in central body data interface public module subroutine io_read_in_cb(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_cb I/O routine for reading out a single frame of time-series data for the central body interface public module function io_read_frame_cb(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: write_frame_bin => io_write_frame_cb I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_cb(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters generic, public :: write_frame => write_frame_netcdf , write_frame_bin Write a frame (either binary or NetCDF, using generic procedures) public interface netcdf_write_frame_base () Arguments None public interface io_write_frame_cb () Arguments None","tags":"","loc":"type/symba_cb.html"},{"title":"symba_pl – swiftest ","text":"type, public, extends( helio_pl ) :: symba_pl SyMBA massive body class Inherits type~~symba_pl~~InheritsGraph type~symba_pl symba_pl type~symba_kinship symba_kinship type~symba_pl->type~symba_kinship kin type~helio_pl helio_pl type~symba_pl->type~helio_pl type~swiftest_pl swiftest_pl type~helio_pl->type~swiftest_pl type~swiftest_body swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_particle_info swiftest_particle_info type~swiftest_body->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~symba_pl~~InheritedByGraph type~symba_pl symba_pl type~symba_merger symba_merger type~symba_merger->type~symba_pl type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~symba_merger pl_adds Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lfirst nbody info id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm mass Gmass rhill radius xbeg xend vbeg density Ip rot k2 Q tlag k_plpl nplpl lcollision lencounter lmtiny nplm nplplm nplenc ntpenc levelg levelm isperi peri atp kin Type-Bound Procedures dump dump_particle_info write_frame_netcdf write_particle_info_netcdf write_particle_info v2pv pv2v read_in read_frame write_frame_bin el2xv xv2el accel_user set_ir3 write_frame accel_obl accel_tides h2b b2h vh2vb vb2vh xh2xb set_beg_end set_mu set_rhill lindrift accel_gr gr_pos_kick kick step make_colliders index discard drift encounter_check accel_int accel setup append fill get_peri rearray reset_kinship resize sort rearrange spill Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl logical, public, dimension(:), allocatable :: lcollision flag indicating whether body has merged with another this time step logical, public, dimension(:), allocatable :: lencounter flag indicating whether body is part of an encounter this time step logical, public, dimension(:), allocatable :: lmtiny flag indicating whether this body is below the GMTINY cutoff value integer(kind=I4B), public :: nplm number of bodies above the GMTINY limit integer(kind=I8B), public :: nplplm Number of body (all massive)-body (only those above GMTINY) comparisons in the flattened upper triangular matrix integer(kind=I4B), public, dimension(:), allocatable :: nplenc number of encounters with other planets this time step integer(kind=I4B), public, dimension(:), allocatable :: ntpenc number of encounters with test particles this time step integer(kind=I4B), public, dimension(:), allocatable :: levelg level at which this body should be moved integer(kind=I4B), public, dimension(:), allocatable :: levelm deepest encounter level achieved this time step integer(kind=I4B), public, dimension(:), allocatable :: isperi perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp semimajor axis following perihelion passage type( symba_kinship ), public, dimension(:), allocatable :: kin Array of merger relationship structures that can account for multiple pairwise mergers in a single step Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file interface public module subroutine io_dump_base(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file interface public module subroutine io_dump_particle_info_base(self, param, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format interface public module subroutine netcdf_write_frame_base(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file interface public module subroutine netcdf_write_particle_info_base(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset generic, public :: write_particle_info => write_particle_info_netcdf public interface netcdf_write_particle_info_base () Arguments None procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file interface public module subroutine io_read_in_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module function io_read_frame_body(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object generic, public :: write_frame => write_frame_netcdf , write_frame_bin Add the generic write frame for Fortran binary files public interface netcdf_write_frame_base () Arguments None public interface io_write_frame_body () Arguments None procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body interface public module subroutine tides_kick_getacch_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: vh2vb => util_coord_vh2vb_pl Convert massive bodies from heliocentric to barycentric coordinates (velocity only) interface public module subroutine util_coord_vh2vb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: vb2vh => util_coord_vb2vh_pl Convert massive bodies from barycentric to heliocentric coordinates (velocity only) interface public module subroutine util_coord_vb2vh_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xh2xb => util_coord_xh2xb_pl Convert massive bodies from heliocentric to barycentric coordinates (position only) interface public module subroutine util_coord_xh2xb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. interface public module subroutine util_set_beg_end_pl(self, xbeg, xend, vbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object real(kind=DP), intent(in), optional dimension(:,:) :: xbeg Position vectors at beginning of step real(kind=DP), intent(in), optional dimension(:,:) :: xend Positions vectors at end of step real(kind=DP), intent(in), optional dimension(:,:) :: vbeg vbeg is an unused variable to keep this method forward compatible with RMVS procedure, public :: set_mu => util_set_mu_pl Method used to construct the vectorized form of the central body mass interface public module subroutine util_set_mu_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body interface public module subroutine util_set_rhill(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: lindrift => helio_drift_linear_pl Method for linear drift of massive bodies due to barycentric momentum of Sun interface public module subroutine helio_drift_linear_pl(self, cb, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( helio_cb ), intent(inout) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step procedure, public :: accel_gr => helio_gr_kick_getacch_pl Acceleration term arising from the post-Newtonian correction interface public pure module subroutine helio_gr_kick_getacch_pl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: gr_pos_kick => helio_gr_p4_pl Position kick due to p**4 term in the post-Newtonian correction interface public pure module subroutine helio_gr_p4_pl(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size procedure, public :: kick => helio_kick_vb_pl Kicks the barycentric velocities interface public module subroutine helio_kick_vb_pl(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure, public :: step => helio_step_pl Steps the body forward one stepsize interface public module subroutine helio_step_pl(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nboody system class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize procedure, public :: make_colliders => symba_collision_make_colliders_pl When a single body is involved in more than one collision in a single step, it becomes part of a family interface public module subroutine symba_collision_make_colliders_pl(self, idx) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(2) :: idx Array holding the indices of the two bodies involved in the collision procedure, public :: index => symba_util_index_eucl_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix interface public module subroutine symba_util_index_eucl_plpl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: discard => symba_discard_pl Process massive body discards interface public module subroutine symba_discard_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: drift => symba_drift_pl Method for Danby drift in Democratic Heliocentric coordinates. Sets the mask to the current recursion level interface public module subroutine symba_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: encounter_check => symba_encounter_check_pl Checks if massive bodies are going through close encounters with each other interface public module function symba_encounter_check_pl(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter procedure, public :: accel_int => symba_kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodiess, with no mutual interactions between bodies below GMTINY interface public module subroutine symba_kick_getacch_int_pl(self) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self procedure, public :: accel => symba_kick_getacch_pl Compute heliocentric accelerations of massive bodies interface public module subroutine symba_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step procedure, public :: setup => symba_setup_pl Constructor method - Allocates space for the input number of bodies interface public module subroutine symba_setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: append => symba_util_append_pl Appends elements from one structure to another interface public module subroutine symba_util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: fill => symba_util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine symba_util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: get_peri => symba_util_peri_pl Determine system pericenter passages for massive bodies interface public module subroutine symba_util_peri_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: rearray => symba_util_rearray_pl Clean up the massive body structures to remove discarded bodies and add new bodies interface public module subroutine symba_util_rearray_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions procedure, public :: reset_kinship => symba_util_reset_kinship Resets the kinship status of bodies interface public module subroutine symba_util_reset_kinship(self, idx) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: idx Index array of bodies to reset procedure, public :: resize => symba_util_resize_pl Checks the current size of a SyMBA massive body against the requested size and resizes it if it is too small. interface public module subroutine symba_util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: sort => symba_util_sort_pl Sorts body arrays by a sortable componen interface public module subroutine symba_util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => symba_util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine symba_util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => symba_util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine symba_util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"type/symba_pl.html"},{"title":"symba_merger – swiftest ","text":"type, public, extends( symba_pl ) :: symba_merger Inherits type~~symba_merger~~InheritsGraph type~symba_merger symba_merger type~symba_pl symba_pl type~symba_merger->type~symba_pl type~symba_kinship symba_kinship type~symba_pl->type~symba_kinship kin type~helio_pl helio_pl type~symba_pl->type~helio_pl type~swiftest_pl swiftest_pl type~helio_pl->type~swiftest_pl type~swiftest_body swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_particle_info swiftest_particle_info type~swiftest_body->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~symba_merger~~InheritedByGraph type~symba_merger symba_merger type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~symba_merger pl_adds Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lfirst nbody info id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm mass Gmass rhill radius xbeg xend vbeg density Ip rot k2 Q tlag k_plpl nplpl lcollision lencounter lmtiny nplm nplplm nplenc ntpenc levelg levelm isperi peri atp kin ncomp Type-Bound Procedures dump dump_particle_info write_frame_netcdf write_particle_info_netcdf write_particle_info v2pv pv2v read_in read_frame write_frame_bin el2xv xv2el accel_user set_ir3 write_frame accel_obl accel_tides h2b b2h vh2vb vb2vh xh2xb set_beg_end set_mu set_rhill lindrift accel_gr gr_pos_kick kick step make_colliders index discard drift encounter_check accel_int accel fill get_peri rearray reset_kinship sort rearrange spill append resize setup Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl logical, public, dimension(:), allocatable :: lcollision flag indicating whether body has merged with another this time step logical, public, dimension(:), allocatable :: lencounter flag indicating whether body is part of an encounter this time step logical, public, dimension(:), allocatable :: lmtiny flag indicating whether this body is below the GMTINY cutoff value integer(kind=I4B), public :: nplm number of bodies above the GMTINY limit integer(kind=I8B), public :: nplplm Number of body (all massive)-body (only those above GMTINY) comparisons in the flattened upper triangular matrix integer(kind=I4B), public, dimension(:), allocatable :: nplenc number of encounters with other planets this time step integer(kind=I4B), public, dimension(:), allocatable :: ntpenc number of encounters with test particles this time step integer(kind=I4B), public, dimension(:), allocatable :: levelg level at which this body should be moved integer(kind=I4B), public, dimension(:), allocatable :: levelm deepest encounter level achieved this time step integer(kind=I4B), public, dimension(:), allocatable :: isperi perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp semimajor axis following perihelion passage type( symba_kinship ), public, dimension(:), allocatable :: kin Array of merger relationship structures that can account for multiple pairwise mergers in a single step integer(kind=I4B), public, dimension(:), allocatable :: ncomp Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file interface public module subroutine io_dump_base(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file interface public module subroutine io_dump_particle_info_base(self, param, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format interface public module subroutine netcdf_write_frame_base(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file interface public module subroutine netcdf_write_particle_info_base(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset generic, public :: write_particle_info => write_particle_info_netcdf public interface netcdf_write_particle_info_base () Arguments None procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file interface public module subroutine io_read_in_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module function io_read_frame_body(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object generic, public :: write_frame => write_frame_netcdf , write_frame_bin Add the generic write frame for Fortran binary files public interface netcdf_write_frame_base () Arguments None public interface io_write_frame_body () Arguments None procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body interface public module subroutine tides_kick_getacch_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: vh2vb => util_coord_vh2vb_pl Convert massive bodies from heliocentric to barycentric coordinates (velocity only) interface public module subroutine util_coord_vh2vb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: vb2vh => util_coord_vb2vh_pl Convert massive bodies from barycentric to heliocentric coordinates (velocity only) interface public module subroutine util_coord_vb2vh_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xh2xb => util_coord_xh2xb_pl Convert massive bodies from heliocentric to barycentric coordinates (position only) interface public module subroutine util_coord_xh2xb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. interface public module subroutine util_set_beg_end_pl(self, xbeg, xend, vbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object real(kind=DP), intent(in), optional dimension(:,:) :: xbeg Position vectors at beginning of step real(kind=DP), intent(in), optional dimension(:,:) :: xend Positions vectors at end of step real(kind=DP), intent(in), optional dimension(:,:) :: vbeg vbeg is an unused variable to keep this method forward compatible with RMVS procedure, public :: set_mu => util_set_mu_pl Method used to construct the vectorized form of the central body mass interface public module subroutine util_set_mu_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body interface public module subroutine util_set_rhill(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: lindrift => helio_drift_linear_pl Method for linear drift of massive bodies due to barycentric momentum of Sun interface public module subroutine helio_drift_linear_pl(self, cb, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( helio_cb ), intent(inout) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step procedure, public :: accel_gr => helio_gr_kick_getacch_pl Acceleration term arising from the post-Newtonian correction interface public pure module subroutine helio_gr_kick_getacch_pl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: gr_pos_kick => helio_gr_p4_pl Position kick due to p**4 term in the post-Newtonian correction interface public pure module subroutine helio_gr_p4_pl(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size procedure, public :: kick => helio_kick_vb_pl Kicks the barycentric velocities interface public module subroutine helio_kick_vb_pl(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure, public :: step => helio_step_pl Steps the body forward one stepsize interface public module subroutine helio_step_pl(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nboody system class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize procedure, public :: make_colliders => symba_collision_make_colliders_pl When a single body is involved in more than one collision in a single step, it becomes part of a family interface public module subroutine symba_collision_make_colliders_pl(self, idx) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(2) :: idx Array holding the indices of the two bodies involved in the collision procedure, public :: index => symba_util_index_eucl_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix interface public module subroutine symba_util_index_eucl_plpl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: discard => symba_discard_pl Process massive body discards interface public module subroutine symba_discard_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: drift => symba_drift_pl Method for Danby drift in Democratic Heliocentric coordinates. Sets the mask to the current recursion level interface public module subroutine symba_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: encounter_check => symba_encounter_check_pl Checks if massive bodies are going through close encounters with each other interface public module function symba_encounter_check_pl(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter procedure, public :: accel_int => symba_kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodiess, with no mutual interactions between bodies below GMTINY interface public module subroutine symba_kick_getacch_int_pl(self) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self procedure, public :: accel => symba_kick_getacch_pl Compute heliocentric accelerations of massive bodies interface public module subroutine symba_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step procedure, public :: fill => symba_util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine symba_util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: get_peri => symba_util_peri_pl Determine system pericenter passages for massive bodies interface public module subroutine symba_util_peri_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: rearray => symba_util_rearray_pl Clean up the massive body structures to remove discarded bodies and add new bodies interface public module subroutine symba_util_rearray_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions procedure, public :: reset_kinship => symba_util_reset_kinship Resets the kinship status of bodies interface public module subroutine symba_util_reset_kinship(self, idx) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: idx Index array of bodies to reset procedure, public :: sort => symba_util_sort_pl Sorts body arrays by a sortable componen interface public module subroutine symba_util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => symba_util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine symba_util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => symba_util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine symba_util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not procedure, public :: append => symba_util_append_merger Appends elements from one structure to another interface public module subroutine symba_util_append_merger(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: resize => symba_util_resize_merger Checks the current size of a SyMBA merger list against the requested size and resizes it if it is too small. interface public module subroutine symba_util_resize_merger(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA merger list object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: setup => symba_setup_merger Constructor method - Allocates space for the input number of bodies interface public module subroutine symba_setup_merger(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA merger list object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"type/symba_merger.html"},{"title":"symba_tp – swiftest ","text":"type, public, extends( helio_tp ) :: symba_tp SyMBA test particle class Inherits type~~symba_tp~~InheritsGraph type~symba_tp symba_tp type~helio_tp helio_tp type~symba_tp->type~helio_tp type~swiftest_tp swiftest_tp type~helio_tp->type~swiftest_tp type~swiftest_body swiftest_body type~swiftest_tp->type~swiftest_body type~swiftest_particle_info swiftest_particle_info type~swiftest_body->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lfirst nbody info id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm isperi peri atp k_pltp npltp nplenc levelg levelm Type-Bound Procedures dump dump_particle_info write_frame_netcdf write_particle_info_netcdf write_particle_info v2pv pv2v read_in read_frame write_frame_bin el2xv xv2el accel_user set_ir3 write_frame discard accel_int accel_obl h2b b2h vb2vh vh2vb xh2xb get_peri set_mu lindrift accel_gr gr_pos_kick kick step drift encounter_check accel setup append fill resize sort rearrange spill Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill integer(kind=I4B), public, dimension(:), allocatable :: isperi Perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri Perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp Semimajor axis following perihelion passage integer(kind=I4B), public, dimension(:,:), allocatable :: k_pltp Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: npltp Number of pl-tp comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_tp and util_spill_tp integer(kind=I4B), public, dimension(:), allocatable :: nplenc number of encounters with planets this time step integer(kind=I4B), public, dimension(:), allocatable :: levelg level at which this particle should be moved integer(kind=I4B), public, dimension(:), allocatable :: levelm deepest encounter level achieved this time step Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file interface public module subroutine io_dump_base(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file interface public module subroutine io_dump_particle_info_base(self, param, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format interface public module subroutine netcdf_write_frame_base(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file interface public module subroutine netcdf_write_particle_info_base(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset generic, public :: write_particle_info => write_particle_info_netcdf public interface netcdf_write_particle_info_base () Arguments None procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file interface public module subroutine io_read_in_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module function io_read_frame_body(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object generic, public :: write_frame => write_frame_netcdf , write_frame_bin Add the generic write frame for Fortran binary files public interface netcdf_write_frame_base () Arguments None public interface io_write_frame_body () Arguments None procedure, public :: discard => discard_tp Check to see if test particles should be discarded based on their positions relative to the massive bodies interface public module subroutine discard_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: accel_int => kick_getacch_int_tp Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies interface public module subroutine kick_getacch_int_tp(self, GMpl, xhp, npl) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle real(kind=DP), intent(in), dimension(:) :: GMpl Massive body masses real(kind=DP), intent(in), dimension(:,:) :: xhp Massive body position vectors integer(kind=I4B), intent(in) :: npl Number of active massive bodies procedure, public :: accel_obl => obl_acc_tp Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_tp(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: h2b => util_coord_h2b_tp Convert test particles from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_tp Convert test particles from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: vb2vh => util_coord_vb2vh_tp Convert test particles from barycentric to heliocentric coordinates (velocity only) interface public module subroutine util_coord_vb2vh_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body procedure, public :: vh2vb => util_coord_vh2vb_tp Convert test particles from heliocentric to barycentric coordinates (velocity only) interface public module subroutine util_coord_vh2vb_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body procedure, public :: xh2xb => util_coord_xh2xb_tp Convert test particles from heliocentric to barycentric coordinates (position only) interface public module subroutine util_coord_xh2xb_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: get_peri => util_peri_tp Determine system pericenter passages for test particles interface public module subroutine util_peri_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: set_mu => util_set_mu_tp Method used to construct the vectorized form of the central body mass interface public module subroutine util_set_mu_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: lindrift => helio_drift_linear_tp Method for linear drift of massive bodies due to barycentric momentum of Sun interface public module subroutine helio_drift_linear_tp(self, cb, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( helio_cb ), intent(in) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step procedure, public :: accel_gr => helio_gr_kick_getacch_tp Acceleration term arising from the post-Newtonian correction interface public pure module subroutine helio_gr_kick_getacch_tp(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters procedure, public :: gr_pos_kick => helio_gr_p4_tp Position kick due to p**4 term in the post-Newtonian correction interface public pure module subroutine helio_gr_p4_tp(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size procedure, public :: kick => helio_kick_vb_tp Kicks the barycentric velocities interface public module subroutine helio_kick_vb_tp(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure, public :: step => helio_step_tp Steps the body forward one stepsize interface public module subroutine helio_step_tp(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsizee procedure, public :: drift => symba_drift_tp Method for Danby drift in Democratic Heliocentric coordinates. Sets the mask to the current recursion level interface public module subroutine symba_drift_tp(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: encounter_check => symba_encounter_check_tp Checks if any test particles are undergoing a close encounter with a massive body interface public module function symba_encounter_check_tp(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter procedure, public :: accel => symba_kick_getacch_tp Compute heliocentric accelerations of test particles interface public module subroutine symba_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step procedure, public :: setup => symba_setup_tp Constructor method - Allocates space for the input number of bodies interface public module subroutine symba_setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter procedure, public :: append => symba_util_append_tp Appends elements from one structure to another interface public module subroutine symba_util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: fill => symba_util_fill_tp \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine symba_util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: resize => symba_util_resize_tp Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. interface public module subroutine symba_util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: sort => symba_util_sort_tp Sorts body arrays by a sortable componen interface public module subroutine symba_util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => symba_util_sort_rearrange_tp Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine symba_util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => symba_util_spill_tp \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine symba_util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"type/symba_tp.html"},{"title":"symba_encounter – swiftest ","text":"type, public, extends( swiftest_encounter ) :: symba_encounter SyMBA class for tracking close encounters in a step Inherits type~~symba_encounter~~InheritsGraph type~symba_encounter symba_encounter type~swiftest_encounter swiftest_encounter type~symba_encounter->type~swiftest_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~symba_encounter~~InheritedByGraph type~symba_encounter symba_encounter type~symba_pltpenc symba_pltpenc type~symba_pltpenc->type~symba_encounter type~symba_plplenc symba_plplenc type~symba_plplenc->type~symba_encounter type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~symba_pltpenc pltpenc_list type~symba_nbody_system->type~symba_plplenc plplenc_list, plplcollision_list Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nenc lvdotr status kidx index1 index2 id1 id2 x1 x2 v1 v2 t level Type-Bound Procedures resize write collision_check encounter_check kick setup copy spill append Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: nenc Total number of encounters logical, public, dimension(:), allocatable :: lvdotr relative vdotr flag integer(kind=I4B), public, dimension(:), allocatable :: status status of the interaction integer(kind=I8B), public, dimension(:), allocatable :: kidx index value of the encounter from the master k_plpl encounter list integer(kind=I4B), public, dimension(:), allocatable :: index1 position of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: index2 position of the second body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: id1 id of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: id2 id of the second body in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x1 the position of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x2 the position of body 2 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v1 the velocity of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v2 the velocity of body 2 in the encounter real(kind=DP), public, dimension(:), allocatable :: t Time of encounter integer(kind=I4B), public, dimension(:), allocatable :: level encounter recursion level Type-Bound Procedures procedure, public :: resize => util_resize_encounter Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small. interface public module subroutine util_resize_encounter(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list integer(kind=I4B), intent(in) :: nnew New size of list needed procedure, public :: write => io_write_encounter Write close encounter data to output binary file interface public module subroutine io_write_encounter(self, pl, encbody, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(in) :: self Swiftest encounter list object class( swiftest_pl ), intent(in) :: pl Swiftest massive body object class( swiftest_body ), intent(in) :: encbody Encountering body - Swiftest generic body object (pl or tp) class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: collision_check => symba_collision_check_encounter Checks if a test particle is going to collide with a massive body interface public module function symba_collision_check_encounter(self, system, param, t, dt, irec) result(lany_collision) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t current time real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if cany pair of encounters resulted in a collision n procedure, public :: encounter_check => symba_encounter_check Checks if massive bodies are going through close encounters with each other interface public module function symba_encounter_check(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-pl encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter procedure, public :: kick => symba_kick_encounter Kick barycentric velocities of active test particles within SyMBA recursion interface public module subroutine symba_kick_encounter(self, system, dt, irec, sgn) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(in) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level integer(kind=I4B), intent(in) :: sgn sign to be applied to acceleration procedure, public :: setup => symba_setup_encounter A constructor that sets the number of encounters and allocates and initializes all arrays interface public module subroutine symba_setup_encounter(self, n) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-tp encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for procedure, public :: copy => symba_util_copy_encounter Copies elements from the source encounter list into self. interface public module subroutine symba_util_copy_encounter(self, source) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self Encounter list class( swiftest_encounter ), intent(in) :: source Source object to copy into procedure, public :: spill => symba_util_spill_encounter \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine symba_util_spill_encounter(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-tp encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list procedure, public :: append => symba_util_append_encounter Appends elements from one structure to another interface public module subroutine symba_util_append_encounter(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA encounter list object class( swiftest_encounter ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"type/symba_encounter.html"},{"title":"symba_pltpenc – swiftest ","text":"type, public, extends( symba_encounter ) :: symba_pltpenc SyMBA class for tracking pl-tp close encounters in a step Inherits type~~symba_pltpenc~~InheritsGraph type~symba_pltpenc symba_pltpenc type~symba_encounter symba_encounter type~symba_pltpenc->type~symba_encounter type~swiftest_encounter swiftest_encounter type~symba_encounter->type~swiftest_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~symba_pltpenc~~InheritedByGraph type~symba_pltpenc symba_pltpenc type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~symba_pltpenc pltpenc_list Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nenc lvdotr status kidx index1 index2 id1 id2 x1 x2 v1 v2 t level Type-Bound Procedures resize write collision_check encounter_check kick setup copy spill append resolve_collision Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: nenc Total number of encounters logical, public, dimension(:), allocatable :: lvdotr relative vdotr flag integer(kind=I4B), public, dimension(:), allocatable :: status status of the interaction integer(kind=I8B), public, dimension(:), allocatable :: kidx index value of the encounter from the master k_plpl encounter list integer(kind=I4B), public, dimension(:), allocatable :: index1 position of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: index2 position of the second body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: id1 id of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: id2 id of the second body in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x1 the position of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x2 the position of body 2 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v1 the velocity of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v2 the velocity of body 2 in the encounter real(kind=DP), public, dimension(:), allocatable :: t Time of encounter integer(kind=I4B), public, dimension(:), allocatable :: level encounter recursion level Type-Bound Procedures procedure, public :: resize => util_resize_encounter Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small. interface public module subroutine util_resize_encounter(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list integer(kind=I4B), intent(in) :: nnew New size of list needed procedure, public :: write => io_write_encounter Write close encounter data to output binary file interface public module subroutine io_write_encounter(self, pl, encbody, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(in) :: self Swiftest encounter list object class( swiftest_pl ), intent(in) :: pl Swiftest massive body object class( swiftest_body ), intent(in) :: encbody Encountering body - Swiftest generic body object (pl or tp) class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: collision_check => symba_collision_check_encounter Checks if a test particle is going to collide with a massive body interface public module function symba_collision_check_encounter(self, system, param, t, dt, irec) result(lany_collision) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t current time real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if cany pair of encounters resulted in a collision n procedure, public :: encounter_check => symba_encounter_check Checks if massive bodies are going through close encounters with each other interface public module function symba_encounter_check(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-pl encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter procedure, public :: kick => symba_kick_encounter Kick barycentric velocities of active test particles within SyMBA recursion interface public module subroutine symba_kick_encounter(self, system, dt, irec, sgn) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(in) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level integer(kind=I4B), intent(in) :: sgn sign to be applied to acceleration procedure, public :: setup => symba_setup_encounter A constructor that sets the number of encounters and allocates and initializes all arrays interface public module subroutine symba_setup_encounter(self, n) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-tp encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for procedure, public :: copy => symba_util_copy_encounter Copies elements from the source encounter list into self. interface public module subroutine symba_util_copy_encounter(self, source) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self Encounter list class( swiftest_encounter ), intent(in) :: source Source object to copy into procedure, public :: spill => symba_util_spill_encounter \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine symba_util_spill_encounter(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-tp encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list procedure, public :: append => symba_util_append_encounter Appends elements from one structure to another interface public module subroutine symba_util_append_encounter(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA encounter list object class( swiftest_encounter ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: resolve_collision => symba_collision_resolve_pltpenc Process the pl-tp collision list, then modifiy the massive bodies based on the outcome of the c interface public module subroutine symba_collision_resolve_pltpenc(self, system, param, t, dt, irec) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-tp encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current simulation step size integer(kind=I4B), intent(in) :: irec Current recursion level","tags":"","loc":"type/symba_pltpenc.html"},{"title":"symba_plplenc – swiftest ","text":"type, public, extends( symba_encounter ) :: symba_plplenc SyMBA class for tracking pl-pl close encounters in a step Inherits type~~symba_plplenc~~InheritsGraph type~symba_plplenc symba_plplenc type~symba_encounter symba_encounter type~symba_plplenc->type~symba_encounter type~swiftest_encounter swiftest_encounter type~symba_encounter->type~swiftest_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~symba_plplenc~~InheritedByGraph type~symba_plplenc symba_plplenc type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~symba_plplenc plplenc_list, plplcollision_list Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nenc lvdotr status kidx index1 index2 id1 id2 x1 x2 v1 v2 t level Type-Bound Procedures resize write collision_check encounter_check kick setup copy spill append extract_collisions resolve_fragmentations resolve_mergers resolve_collision Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: nenc Total number of encounters logical, public, dimension(:), allocatable :: lvdotr relative vdotr flag integer(kind=I4B), public, dimension(:), allocatable :: status status of the interaction integer(kind=I8B), public, dimension(:), allocatable :: kidx index value of the encounter from the master k_plpl encounter list integer(kind=I4B), public, dimension(:), allocatable :: index1 position of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: index2 position of the second body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: id1 id of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: id2 id of the second body in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x1 the position of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x2 the position of body 2 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v1 the velocity of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v2 the velocity of body 2 in the encounter real(kind=DP), public, dimension(:), allocatable :: t Time of encounter integer(kind=I4B), public, dimension(:), allocatable :: level encounter recursion level Type-Bound Procedures procedure, public :: resize => util_resize_encounter Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small. interface public module subroutine util_resize_encounter(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list integer(kind=I4B), intent(in) :: nnew New size of list needed procedure, public :: write => io_write_encounter Write close encounter data to output binary file interface public module subroutine io_write_encounter(self, pl, encbody, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(in) :: self Swiftest encounter list object class( swiftest_pl ), intent(in) :: pl Swiftest massive body object class( swiftest_body ), intent(in) :: encbody Encountering body - Swiftest generic body object (pl or tp) class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: collision_check => symba_collision_check_encounter Checks if a test particle is going to collide with a massive body interface public module function symba_collision_check_encounter(self, system, param, t, dt, irec) result(lany_collision) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t current time real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if cany pair of encounters resulted in a collision n procedure, public :: encounter_check => symba_encounter_check Checks if massive bodies are going through close encounters with each other interface public module function symba_encounter_check(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-pl encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter procedure, public :: kick => symba_kick_encounter Kick barycentric velocities of active test particles within SyMBA recursion interface public module subroutine symba_kick_encounter(self, system, dt, irec, sgn) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(in) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level integer(kind=I4B), intent(in) :: sgn sign to be applied to acceleration procedure, public :: setup => symba_setup_encounter A constructor that sets the number of encounters and allocates and initializes all arrays interface public module subroutine symba_setup_encounter(self, n) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-tp encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for procedure, public :: copy => symba_util_copy_encounter Copies elements from the source encounter list into self. interface public module subroutine symba_util_copy_encounter(self, source) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self Encounter list class( swiftest_encounter ), intent(in) :: source Source object to copy into procedure, public :: spill => symba_util_spill_encounter \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine symba_util_spill_encounter(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-tp encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list procedure, public :: append => symba_util_append_encounter Appends elements from one structure to another interface public module subroutine symba_util_append_encounter(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA encounter list object class( swiftest_encounter ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: extract_collisions => symba_collision_encounter_extract_collisions Processes the pl-pl encounter list remove only those encounters that led to a collision interface public module subroutine symba_collision_encounter_extract_collisions(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: resolve_fragmentations => symba_collision_resolve_fragmentations Process list of collisions, determine the collisional regime, and then create fragments interface public module subroutine symba_collision_resolve_fragmentations(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions procedure, public :: resolve_mergers => symba_collision_resolve_mergers Process list of collisions and merge colliding bodies together interface public module subroutine symba_collision_resolve_mergers(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions procedure, public :: resolve_collision => symba_collision_resolve_plplenc Process the pl-pl collision list, then modifiy the massive bodies based on the outcome of the c interface public module subroutine symba_collision_resolve_plplenc(self, system, param, t, dt, irec) Implementation → Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current simulation step size integer(kind=I4B), intent(in) :: irec Current recursion level","tags":"","loc":"type/symba_plplenc.html"},{"title":"symba_nbody_system – swiftest ","text":"type, public, extends( helio_nbody_system ) :: symba_nbody_system Inherits type~~symba_nbody_system~~InheritsGraph type~symba_nbody_system symba_nbody_system type~symba_pltpenc symba_pltpenc type~symba_nbody_system->type~symba_pltpenc pltpenc_list type~symba_plplenc symba_plplenc type~symba_nbody_system->type~symba_plplenc plplenc_list, plplcollision_list type~symba_merger symba_merger type~symba_nbody_system->type~symba_merger pl_adds type~helio_nbody_system helio_nbody_system type~symba_nbody_system->type~helio_nbody_system type~symba_encounter symba_encounter type~symba_pltpenc->type~symba_encounter type~symba_plplenc->type~symba_encounter type~symba_pl symba_pl type~symba_merger->type~symba_pl type~whm_nbody_system whm_nbody_system type~helio_nbody_system->type~whm_nbody_system type~swiftest_encounter swiftest_encounter type~symba_encounter->type~swiftest_encounter type~swiftest_nbody_system swiftest_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~symba_kinship symba_kinship type~symba_pl->type~symba_kinship kin type~helio_pl helio_pl type~symba_pl->type~helio_pl type~swiftest_pl swiftest_pl type~helio_pl->type~swiftest_pl type~swiftest_cb swiftest_cb type~swiftest_nbody_system->type~swiftest_cb cb type~swiftest_nbody_system->type~swiftest_pl pl, pl_discards type~swiftest_tp swiftest_tp type~swiftest_nbody_system->type~swiftest_tp tp, tp_discards type~swiftest_particle_info swiftest_particle_info type~swiftest_cb->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_cb->type~swiftest_base type~swiftest_body swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_tp->type~swiftest_body type~swiftest_body->type~swiftest_particle_info info type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables cb pl tp tp_discards pl_discards GMtot ke_orbit ke_spin pe te oblpot Lorbit Lspin Ltot lbeg pl_adds pltpenc_list plplenc_list plplcollision_list irec Type-Bound Procedures discard conservation_report dump get_old_t_final read_frame read_particle_info write_frame write_hdr_bin write_hdr_netcdf obl_pot init_particle_info step_spin set_msys get_energy_and_momentum rescale validate_ids write_hdr write_discard initialize step interp set_recur_levels recursive_step reset Components Type Visibility Attributes Name Initial class( swiftest_cb ), public, allocatable :: cb Central body data structure class( swiftest_pl ), public, allocatable :: pl Massive body data structure class( swiftest_tp ), public, allocatable :: tp Test particle data structure class( swiftest_tp ), public, allocatable :: tp_discards Discarded test particle data structure class( swiftest_pl ), public, allocatable :: pl_discards Discarded massive body particle data structure real(kind=DP), public :: GMtot = 0.0_DP Total system mass - used for barycentric coordinate conversion real(kind=DP), public :: ke_orbit = 0.0_DP System orbital kinetic energy real(kind=DP), public :: ke_spin = 0.0_DP System spin kinetic energy real(kind=DP), public :: pe = 0.0_DP System potential energy real(kind=DP), public :: te = 0.0_DP System total energy real(kind=DP), public :: oblpot = 0.0_DP System potential energy due to oblateness of the central body real(kind=DP), public, dimension(NDIM) :: Lorbit = 0.0_DP System orbital angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lspin = 0.0_DP System spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Ltot = 0.0_DP System angular momentum vector logical, public :: lbeg True if this is the beginning of a step. This is used so that test particle steps can be calculated \n    separately from massive bodies.  Massive body variables are saved at half steps, and passed to \n    the test particles class( symba_merger ), public, allocatable :: pl_adds List of added bodies in mergers or collisions class( symba_pltpenc ), public, allocatable :: pltpenc_list List of massive body-test particle encounters in a single step class( symba_plplenc ), public, allocatable :: plplenc_list List of massive body-massive body encounters in a single step class( symba_plplenc ), public, allocatable :: plplcollision_list List of massive body-massive body collisions in a single step integer(kind=I4B), public :: irec System recursion level Type-Bound Procedures procedure, public :: discard => discard_system Perform a discard step on the system interface public module subroutine discard_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: conservation_report => io_conservation_report Compute energy and momentum and print out the change with time interface public module subroutine io_conservation_report(self, param, lterminal) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Input colleciton of user-defined parameters logical, intent(in) :: lterminal Indicates whether to output information to the terminal screen procedure, public :: dump => io_dump_system Dump the state of the system to a file interface public module subroutine io_dump_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: get_old_t_final => io_get_old_t_final_system Validates the dump file to check whether the dump file initial conditions duplicate the last frame of the binary output. interface public module function io_get_old_t_final_system(self, param) result(old_t_final) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self class( swiftest_parameters ), intent(in) :: param Return Value real(kind=DP) procedure, public :: read_frame => io_read_frame_system Read in a frame of input data from file interface public module function io_read_frame_system(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: read_particle_info => io_read_particle_info_system Read in particle metadata from file interface public module subroutine io_read_particle_info_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: write_frame => io_write_frame_system Append a frame of output data to file interface public module subroutine io_write_frame_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: write_hdr_bin => io_write_hdr_system Write a header for an output frame in Fortran binary format interface public module subroutine io_write_hdr_system(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest nbody system object integer(kind=I4B), intent(inout) :: iu Output file unit number class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_hdr_netcdf => netcdf_write_hdr_system Write a header for an output frame in NetCDF format interface public module subroutine netcdf_write_hdr_system(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest nbody system object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: obl_pot => obl_pot_system Compute the contribution to the total gravitational potential due solely to the oblateness of the central body interface public module subroutine obl_pot_system(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object procedure, public :: init_particle_info => setup_initialize_particle_info_system Initialize the system from input files interface public module subroutine setup_initialize_particle_info_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: step_spin => tides_step_spin_system Steps the spins of the massive & central bodies due to tides. interface public module subroutine tides_step_spin_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure, public :: set_msys => util_set_msys Sets the value of msys from the masses of system bodies. interface public module subroutine util_set_msys(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object procedure, public :: get_energy_and_momentum => util_get_energy_momentum_system Calculates the total system energy and momentum interface public module subroutine util_get_energy_momentum_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: rescale => util_rescale_system Rescales the system into a new set of units interface public module subroutine util_rescale_system(self, param, mscale, dscale, tscale) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters. Returns with new values of the scale vactors and GU real(kind=DP), intent(in) :: mscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: dscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: tscale Scale factors for mass, distance, and time units, respectively. procedure, public :: validate_ids => util_valid_id_system Validate the numerical ids passed to the system and save the maximum value interface public module subroutine util_valid_id_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters generic, public :: write_hdr => write_hdr_bin , write_hdr_netcdf Generic method call for writing headers public interface io_write_hdr_system () Arguments None public interface netcdf_write_hdr_system () Arguments None procedure, public :: write_discard => symba_io_write_discard Write out information about discarded and merged planets and test particles in SyMBA interface public module subroutine symba_io_write_discard(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: initialize => symba_setup_initialize_system Performs SyMBA-specific initilization steps interface public module subroutine symba_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: step => symba_step_system Advance the SyMBA nbody system forward in time by one step interface public module subroutine symba_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure, public :: interp => symba_step_interp_system Perform an interpolation step on the SymBA nbody system interface public module subroutine symba_step_interp_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure, public :: set_recur_levels => symba_step_set_recur_levels_system Sets recursion levels of bodies and encounter lists to the current system level interface public module subroutine symba_step_set_recur_levels_system(self, ireci) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system objec integer(kind=I4B), intent(in) :: ireci Input recursion level procedure, public :: recursive_step => symba_step_recur_system Step interacting planets and active test particles ahead in democratic heliocentric coordinates at the current recursion level, if applicable, and descend to the next deeper level if necessary interface public recursive module subroutine symba_step_recur_system(self, param, t, ireci) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: ireci input recursion level procedure, public :: reset => symba_step_reset_system Resets pl, tp,and encounter structures at the start of a new step interface public module subroutine symba_step_reset_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions","tags":"","loc":"type/symba_nbody_system.html"},{"title":"netcdf_parameters – swiftest ","text":"type, public :: netcdf_parameters Inherited by type~~netcdf_parameters~~InheritedByGraph type~netcdf_parameters netcdf_parameters type~swiftest_parameters swiftest_parameters type~swiftest_parameters->type~netcdf_parameters nciu type~symba_parameters symba_parameters type~symba_parameters->type~swiftest_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables out_type ncid dimids time_dimid id_dimid str_dimid time_varid id_varid name_varid ptype_varid npl_varid ntp_varid a_varid e_varid inc_varid capom_varid omega_varid capm_varid xhx_varid xhy_varid xhz_varid vhx_varid vhy_varid vhz_varid Gmass_varid rhill_varid radius_varid Ip1_varid Ip2_varid Ip3_varid rotx_varid roty_varid rotz_varid k2_varid Q_varid KE_orb_varid KE_spin_varid PE_varid L_orbx_varid L_orby_varid L_orbz_varid L_spinx_varid L_spiny_varid L_spinz_varid L_escapex_varid L_escapey_varid L_escapez_varid Ecollisions_varid Euntracked_varid GMescape_varid status_varid origin_type_varid origin_time_varid origin_xhx_varid origin_xhy_varid origin_xhz_varid origin_vhx_varid origin_vhy_varid origin_vhz_varid discard_time_varid discard_xhx_varid discard_xhy_varid discard_xhz_varid discard_vhx_varid discard_vhy_varid discard_vhz_varid discard_body_id_varid Type-Bound Procedures close initialize open Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: out_type NetCDF output type (will be assigned either NF90_DOUBLE or NF90_FLOAT, depending on the user parameter) integer(kind=I4B), public :: ncid NetCDF ID for the output file integer(kind=I4B), public :: dimids (3) Dimensions of the NetCDF file integer(kind=I4B), public :: time_dimid NetCDF ID for the time dimension integer(kind=I4B), public :: id_dimid NetCDF ID for the particle id dimension integer(kind=I4B), public :: str_dimid NetCDF ID for the character string dimension integer(kind=I4B), public :: time_varid NetCDF ID for the time variable integer(kind=I4B), public :: id_varid NetCDF ID for the particle name variable integer(kind=I4B), public :: name_varid NetCDF ID for the namevariable integer(kind=I4B), public :: ptype_varid NetCDF ID for the particle type variable integer(kind=I4B), public :: npl_varid NetCDF ID for the number of active massive bodies variable integer(kind=I4B), public :: ntp_varid NetCDF ID for the number of active test particles variable integer(kind=I4B), public :: a_varid NetCDF ID for the semimajor axis variable integer(kind=I4B), public :: e_varid NetCDF ID for the eccentricity variable integer(kind=I4B), public :: inc_varid NetCDF ID for the inclination variable integer(kind=I4B), public :: capom_varid NetCDF ID for the long. asc. node variable integer(kind=I4B), public :: omega_varid NetCDF ID for the arg. periapsis variable integer(kind=I4B), public :: capm_varid NetCDF ID for the mean anomaly variable integer(kind=I4B), public :: xhx_varid NetCDF ID for the heliocentric position x variable integer(kind=I4B), public :: xhy_varid NetCDF ID for the heliocentric position y variable integer(kind=I4B), public :: xhz_varid NetCDF ID for the heliocentric position z variable integer(kind=I4B), public :: vhx_varid NetCDF ID for the heliocentric velocity x variable integer(kind=I4B), public :: vhy_varid NetCDF ID for the heliocentric velocity y variable integer(kind=I4B), public :: vhz_varid NetCDF ID for the heliocentric velocity z variable integer(kind=I4B), public :: Gmass_varid NetCDF ID for the mass variable integer(kind=I4B), public :: rhill_varid NetCDF ID for the hill radius variable integer(kind=I4B), public :: radius_varid NetCDF ID for the radius variable integer(kind=I4B), public :: Ip1_varid NetCDF ID for the axis 1 principal moment of inertia variable integer(kind=I4B), public :: Ip2_varid NetCDF ID for the axis 2 principal moment of inertia variable integer(kind=I4B), public :: Ip3_varid NetCDF ID for the axis 3 principal moment of inertia variable integer(kind=I4B), public :: rotx_varid NetCDF ID for the rotation x variable integer(kind=I4B), public :: roty_varid NetCDF ID for the rotation y variable integer(kind=I4B), public :: rotz_varid NetCDF ID for the rotation z variable integer(kind=I4B), public :: k2_varid NetCDF ID for the Love number variable integer(kind=I4B), public :: Q_varid NetCDF ID for the energy dissipation variable integer(kind=I4B), public :: KE_orb_varid NetCDF ID for the system orbital kinetic energy variable integer(kind=I4B), public :: KE_spin_varid NetCDF ID for the system spin kinetic energy variable integer(kind=I4B), public :: PE_varid NetCDF ID for the system potential energy variable integer(kind=I4B), public :: L_orbx_varid NetCDF ID for the system orbital angular momentum x variable integer(kind=I4B), public :: L_orby_varid NetCDF ID for the system orbital angular momentum y variable integer(kind=I4B), public :: L_orbz_varid NetCDF ID for the system orbital angular momentum z variable integer(kind=I4B), public :: L_spinx_varid NetCDF ID for the system spin angular momentum x variable integer(kind=I4B), public :: L_spiny_varid NetCDF ID for the system spin angular momentum y variable integer(kind=I4B), public :: L_spinz_varid NetCDF ID for the system spin angular momentum z variable integer(kind=I4B), public :: L_escapex_varid NetCDF ID for the escaped angular momentum x variable integer(kind=I4B), public :: L_escapey_varid NetCDF ID for the escaped angular momentum x variable integer(kind=I4B), public :: L_escapez_varid NetCDF ID for the escaped angular momentum x variable integer(kind=I4B), public :: Ecollisions_varid NetCDF ID for the energy lost in collisions variable integer(kind=I4B), public :: Euntracked_varid NetCDF ID for the energy that is untracked due to loss (untracked potential energy due to mergers and body energy for escaped bodies) integer(kind=I4B), public :: GMescape_varid NetCDF ID for the G*Mass of bodies that escape the system integer(kind=I4B), public :: status_varid NetCDF ID for the status variable integer(kind=I4B), public :: origin_type_varid NetCDF ID for the origin type integer(kind=I4B), public :: origin_time_varid NetCDF ID for the origin time integer(kind=I4B), public :: origin_xhx_varid NetCDF ID for the origin xh x component integer(kind=I4B), public :: origin_xhy_varid NetCDF ID for the origin xh y component integer(kind=I4B), public :: origin_xhz_varid NetCDF ID for the origin xh z component integer(kind=I4B), public :: origin_vhx_varid NetCDF ID for the origin xh x component integer(kind=I4B), public :: origin_vhy_varid NetCDF ID for the origin xh y component integer(kind=I4B), public :: origin_vhz_varid NetCDF ID for the origin xh z component integer(kind=I4B), public :: discard_time_varid NetCDF ID for the time of discard variable integer(kind=I4B), public :: discard_xhx_varid NetCDF ID for the heliocentric position of the body at the time of discard x variable integer(kind=I4B), public :: discard_xhy_varid NetCDF ID for the heliocentric position of the body at the time of discard y variable integer(kind=I4B), public :: discard_xhz_varid NetCDF ID for the heliocentric position of the body at the time of discard z variable integer(kind=I4B), public :: discard_vhx_varid NetCDF ID for the heliocentric velocity of the body at the time of discard x variable integer(kind=I4B), public :: discard_vhy_varid NetCDF ID for the heliocentric velocity of the body at the time of discard y variable integer(kind=I4B), public :: discard_vhz_varid NetCDF ID for the heliocentric velocity of the body at the time of discard z variable integer(kind=I4B), public :: discard_body_id_varid NetCDF ID for the id of the other body involved in the discard Type-Bound Procedures procedure, public :: close => netcdf_close Closes an open NetCDF file interface public module subroutine netcdf_close(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( netcdf_parameters ), intent(inout) :: self Parameters used to identify a particular NetCDF dataset class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: initialize => netcdf_initialize_output Initialize a set of parameters used to identify a NetCDF output object interface public module subroutine netcdf_initialize_output(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( netcdf_parameters ), intent(inout) :: self Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: open => netcdf_open Opens a NetCDF file interface public module subroutine netcdf_open(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( netcdf_parameters ), intent(inout) :: self Parameters used to identify a particular NetCDF dataset class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"type/netcdf_parameters.html"},{"title":"swiftest_parameters – swiftest ","text":"type, public :: swiftest_parameters User defined parameters that are read in from the parameters input file. \n    Each paramter is initialized to a default values. Inherits type~~swiftest_parameters~~InheritsGraph type~swiftest_parameters swiftest_parameters type~netcdf_parameters netcdf_parameters type~swiftest_parameters->type~netcdf_parameters nciu Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~swiftest_parameters~~InheritedByGraph type~swiftest_parameters swiftest_parameters type~symba_parameters symba_parameters type~symba_parameters->type~swiftest_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables integrator maxid t0 t tstop dt ioutput incbfile inplfile intpfile in_type in_form istep_out outfile out_type out_form out_stat particle_out istep_dump rmin rmax rmaxu qmin qmin_coord qmin_alo qmin_ahi enc_out discard_out MU2KG TU2S DU2M GU inv_c2 energy_out lrhill_present lextra_force lbig_discard lclose lenergy loblatecb lrotation ltides Eorbit_orig GMtot_orig Ltot_orig Lorbit_orig Lspin_orig Lescape GMescape Ecollisions Euntracked lfirstenergy lfirstkick lrestart lgr lyarkovsky lyorp nciu Type-Bound Procedures reader writer dump read_in Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: integrator = UNKNOWN_INTEGRATOR Symbolic name of the nbody integrator  used integer(kind=I4B), public :: maxid = -1 The current maximum particle id number real(kind=DP), public :: t0 = -1.0_DP Integration start time real(kind=DP), public :: t = -1.0_DP Integration current time real(kind=DP), public :: tstop = -1.0_DP Integration stop time real(kind=DP), public :: dt = -1.0_DP Time step integer(kind=I8B), public :: ioutput = 0_I8B Output counter character(len=STRMAX), public :: incbfile = CB_INFILE Name of input file for the central body character(len=STRMAX), public :: inplfile = PL_INFILE Name of input file for massive bodies character(len=STRMAX), public :: intpfile = TP_INFILE Name of input file for test particles character(len=STRMAX), public :: in_type = ASCII_TYPE Data representation type of input data files character(len=STRMAX), public :: in_form = XV Format of input data files (EL or XV) integer(kind=I4B), public :: istep_out = -1 Number of time steps between binary outputs character(len=STRMAX), public :: outfile = NETCDF_OUTFILE Name of output binary file character(len=STRMAX), public :: out_type = NETCDF_DOUBLE_TYPE Binary format of output file character(len=STRMAX), public :: out_form = XVEL Data to write to output file character(len=STRMAX), public :: out_stat = 'NEW' Open status for output binary file character(len=STRMAX), public :: particle_out = PARTICLE_OUTFILE Name of output particle information file integer(kind=I4B), public :: istep_dump = -1 Number of time steps between dumps real(kind=DP), public :: rmin = -1.0_DP Minimum heliocentric radius for test particle real(kind=DP), public :: rmax = -1.0_DP Maximum heliocentric radius for test particle real(kind=DP), public :: rmaxu = -1.0_DP Maximum unbound heliocentric radius for test particle real(kind=DP), public :: qmin = -1.0_DP Minimum pericenter distance for test particle character(len=STRMAX), public :: qmin_coord = 'HELIO' Coordinate frame to use for qmin real(kind=DP), public :: qmin_alo = -1.0_DP Minimum semimajor axis for qmin real(kind=DP), public :: qmin_ahi = -1.0_DP Maximum semimajor axis for qmin character(len=STRMAX), public :: enc_out = \"\" Name of output file for encounters character(len=STRMAX), public :: discard_out = \"\" Name of output file for discards real(kind=QP), public :: MU2KG = -1.0_QP Converts mass units to grams real(kind=QP), public :: TU2S = -1.0_QP Converts time units to seconds real(kind=QP), public :: DU2M = -1.0_QP Converts distance unit to centimeters real(kind=DP), public :: GU = -1.0_DP Universal gravitational constant in the system units real(kind=DP), public :: inv_c2 = -1.0_DP Inverse speed of light squared in the system units character(len=STRMAX), public :: energy_out = \"\" Name of output energy and momentum report file logical, public :: lrhill_present = .false. Hill radii are given as an input rather than calculated by the code (can be used to inflate close encounter regions manually) logical, public :: lextra_force = .false. User defined force function turned on logical, public :: lbig_discard = .false. Save big bodies on every discard logical, public :: lclose = .false. Turn on close encounters logical, public :: lenergy = .false. Track the total energy of the system logical, public :: loblatecb = .false. Calculate acceleration from oblate central body (automatically turns true if nonzero J2 is input) logical, public :: lrotation = .false. Include rotation states of big bodies logical, public :: ltides = .false. Include tidal dissipation real(kind=DP), public :: Eorbit_orig = 0.0_DP Initial orbital energy real(kind=DP), public :: GMtot_orig = 0.0_DP Initial system mass real(kind=DP), public, dimension(NDIM) :: Ltot_orig = 0.0_DP Initial total angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lorbit_orig = 0.0_DP Initial orbital angular momentum real(kind=DP), public, dimension(NDIM) :: Lspin_orig = 0.0_DP Initial spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lescape = 0.0_DP Angular momentum of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: GMescape = 0.0_DP Mass of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Ecollisions = 0.0_DP Energy lost from system due to collisions real(kind=DP), public :: Euntracked = 0.0_DP Energy gained from system due to escaped bodies logical, public :: lfirstenergy = .true. This is the first time computing energe logical, public :: lfirstkick = .true. Initiate the first kick in a symplectic step logical, public :: lrestart = .false. Indicates whether or not this is a restarted run logical, public :: lgr = .false. Turn on GR logical, public :: lyarkovsky = .false. Turn on Yarkovsky effect logical, public :: lyorp = .false. Turn on YORP effect type( netcdf_parameters ), public :: nciu Object containing NetCDF parameters Type-Bound Procedures procedure, public :: reader => io_param_reader interface public module subroutine io_param_reader(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Collection of parameters integer(kind=I4B), intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer(kind=I4B), intent(in) :: v_list (:) The first element passes the integrator code to the reader integer(kind=I4B), intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 procedure, public :: writer => io_param_writer interface public module subroutine io_param_writer(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Collection of parameters integer(kind=I4B), intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer(kind=I4B), intent(in) :: v_list (:) Not used in this procedure integer(kind=I4B), intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 procedure, public :: dump => io_dump_param interface public module subroutine io_dump_param(self, param_file_name) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Output collection of parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in) procedure, public :: read_in => io_read_in_param interface public module subroutine io_read_in_param(self, param_file_name) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Current run configuration parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in)","tags":"","loc":"type/swiftest_parameters.html"},{"title":"swiftest_particle_info – swiftest ","text":"type, public :: swiftest_particle_info Class definition for the particle origin information object. This object is used to track time, location, and collisional regime\n of fragments produced in collisional events. Inherited by type~~swiftest_particle_info~~InheritedByGraph type~swiftest_particle_info swiftest_particle_info type~swiftest_cb swiftest_cb type~swiftest_cb->type~swiftest_particle_info info type~swiftest_body swiftest_body type~swiftest_body->type~swiftest_particle_info info type~swiftest_tp swiftest_tp type~swiftest_tp->type~swiftest_body type~helio_cb helio_cb type~helio_cb->type~swiftest_cb type~swiftest_nbody_system swiftest_nbody_system type~swiftest_nbody_system->type~swiftest_cb cb type~swiftest_nbody_system->type~swiftest_tp tp, tp_discards type~swiftest_pl swiftest_pl type~swiftest_nbody_system->type~swiftest_pl pl, pl_discards type~whm_cb whm_cb type~whm_cb->type~swiftest_cb type~swiftest_pl->type~swiftest_body type~symba_cb symba_cb type~symba_cb->type~helio_cb type~whm_pl whm_pl type~whm_pl->type~swiftest_pl type~fraggle_fragments fraggle_fragments type~fraggle_fragments->type~swiftest_pl type~whm_tp whm_tp type~whm_tp->type~swiftest_tp type~whm_nbody_system whm_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~helio_tp helio_tp type~helio_tp->type~swiftest_tp type~rmvs_cb rmvs_cb type~rmvs_cb->type~whm_cb type~helio_pl helio_pl type~helio_pl->type~swiftest_pl type~rmvs_tp rmvs_tp type~rmvs_tp->type~whm_tp type~rmvs_tp->type~rmvs_cb cb_heliocentric type~helio_nbody_system helio_nbody_system type~helio_nbody_system->type~whm_nbody_system type~symba_tp symba_tp type~symba_tp->type~helio_tp type~rmvs_nbody_system rmvs_nbody_system type~rmvs_nbody_system->type~whm_nbody_system type~rmvs_pl rmvs_pl type~rmvs_pl->type~whm_pl type~rmvs_pl->type~rmvs_nbody_system planetocentric type~symba_pl symba_pl type~symba_pl->type~helio_pl type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~helio_nbody_system type~symba_merger symba_merger type~symba_nbody_system->type~symba_merger pl_adds type~symba_merger->type~symba_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables name particle_type origin_type origin_time origin_xh origin_vh discard_time status discard_xh discard_vh discard_body_id Type-Bound Procedures dump read_in copy set_value Components Type Visibility Attributes Name Initial character(len=NAMELEN), public :: name Non-unique name character(len=NAMELEN), public :: particle_type String containing a description of the particle type (e.g. Central Body, Massive Body, Test Particle) character(len=NAMELEN), public :: origin_type String containing a description of the origin of the particle (e.g. Initial Conditions, Supercatastrophic, Disruption, etc.) real(kind=DP), public :: origin_time The time of the particle's formation real(kind=DP), public, dimension(NDIM) :: origin_xh The heliocentric distance vector at the time of the particle's formation real(kind=DP), public, dimension(NDIM) :: origin_vh The heliocentric velocity vector at the time of the particle's formation real(kind=DP), public :: discard_time The time of the particle's discard character(len=NAMELEN), public :: status Particle status description: Active, Merged, Fragmented, etc. real(kind=DP), public, dimension(NDIM) :: discard_xh The heliocentric distance vector at the time of the particle's discard real(kind=DP), public, dimension(NDIM) :: discard_vh The heliocentric velocity vector at the time of the particle's discard integer(kind=I4B), public :: discard_body_id The id of the other body involved in the discard (0 if no other body involved) Type-Bound Procedures procedure, public :: dump => io_dump_particle_info Dumps contents of particle information to file interface public module subroutine io_dump_particle_info(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(in) :: self Swiftest particle info metadata object integer(kind=I4B), intent(in) :: iu Open unformatted file unit number procedure, public :: read_in => io_read_in_particle_info Read in a particle information object from an open file interface public module subroutine io_read_in_particle_info(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(inout) :: self Particle metadata information object integer(kind=I4B), intent(in) :: iu Open file unit number procedure, public :: copy => util_copy_particle_info Copies one set of information object components into another, component-by-component interface public module subroutine util_copy_particle_info(self, source) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(inout) :: self class( swiftest_particle_info ), intent(in) :: source procedure, public :: set_value => util_set_particle_info Sets one or more values of the particle information metadata object interface public module subroutine util_set_particle_info(self, name, particle_type, status, origin_type, origin_time, origin_xh, origin_vh, discard_time, discard_xh, discard_vh, discard_body_id) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(inout) :: self character(len=*), intent(in), optional :: name Non-unique name character(len=*), intent(in), optional :: particle_type String containing a description of the particle type (e.g. Central Body, Massive Body, Test Particle) character(len=*), intent(in), optional :: status Particle status description: Active, Merged, Fragmented, etc. character(len=*), intent(in), optional :: origin_type String containing a description of the origin of the particle (e.g. Initial Conditions, Supercatastrophic, Disruption, etc.) real(kind=DP), intent(in), optional :: origin_time The time of the particle's formation real(kind=DP), intent(in), optional dimension(:) :: origin_xh The heliocentric distance vector at the time of the particle's formation real(kind=DP), intent(in), optional dimension(:) :: origin_vh The heliocentric velocity vector at the time of the particle's formation real(kind=DP), intent(in), optional :: discard_time The time of the particle's discard real(kind=DP), intent(in), optional dimension(:) :: discard_xh The heliocentric distance vector at the time of the particle's discard real(kind=DP), intent(in), optional dimension(:) :: discard_vh The heliocentric velocity vector at the time of the particle's discard integer(kind=I4B), intent(in), optional :: discard_body_id The id of the other body involved in the discard (0 if no other body involved)","tags":"","loc":"type/swiftest_particle_info.html"},{"title":"swiftest_base – swiftest ","text":"type, public, abstract :: swiftest_base An abstract superclass for a generic Swiftest object\n The minimal methods that all systems must have Inherited by type~~swiftest_base~~InheritedByGraph type~swiftest_base swiftest_base type~swiftest_cb swiftest_cb type~swiftest_cb->type~swiftest_base type~swiftest_body swiftest_body type~swiftest_body->type~swiftest_base type~swiftest_tp swiftest_tp type~swiftest_tp->type~swiftest_body type~helio_cb helio_cb type~helio_cb->type~swiftest_cb type~swiftest_nbody_system swiftest_nbody_system type~swiftest_nbody_system->type~swiftest_cb cb type~swiftest_nbody_system->type~swiftest_tp tp, tp_discards type~swiftest_pl swiftest_pl type~swiftest_nbody_system->type~swiftest_pl pl, pl_discards type~whm_cb whm_cb type~whm_cb->type~swiftest_cb type~swiftest_pl->type~swiftest_body type~symba_cb symba_cb type~symba_cb->type~helio_cb type~whm_pl whm_pl type~whm_pl->type~swiftest_pl type~fraggle_fragments fraggle_fragments type~fraggle_fragments->type~swiftest_pl type~whm_tp whm_tp type~whm_tp->type~swiftest_tp type~whm_nbody_system whm_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~helio_tp helio_tp type~helio_tp->type~swiftest_tp type~rmvs_cb rmvs_cb type~rmvs_cb->type~whm_cb type~helio_pl helio_pl type~helio_pl->type~swiftest_pl type~rmvs_tp rmvs_tp type~rmvs_tp->type~whm_tp type~rmvs_tp->type~rmvs_cb cb_heliocentric type~helio_nbody_system helio_nbody_system type~helio_nbody_system->type~whm_nbody_system type~symba_tp symba_tp type~symba_tp->type~helio_tp type~rmvs_nbody_system rmvs_nbody_system type~rmvs_nbody_system->type~whm_nbody_system type~rmvs_pl rmvs_pl type~rmvs_pl->type~whm_pl type~rmvs_pl->type~rmvs_nbody_system planetocentric type~symba_pl symba_pl type~symba_pl->type~helio_pl type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~helio_nbody_system type~symba_merger symba_merger type~symba_nbody_system->type~symba_merger pl_adds type~symba_merger->type~symba_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures dump dump_particle_info write_frame_netcdf write_particle_info_netcdf write_frame write_particle_info Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file interface public module subroutine io_dump_base(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file interface public module subroutine io_dump_particle_info_base(self, param, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format interface public module subroutine netcdf_write_frame_base(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file interface public module subroutine netcdf_write_particle_info_base(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset generic, public :: write_frame => write_frame_netcdf Set up generic procedure that will switch between NetCDF or Fortran binary depending on arguments public interface netcdf_write_frame_base () Arguments None generic, public :: write_particle_info => write_particle_info_netcdf public interface netcdf_write_particle_info_base () Arguments None","tags":"","loc":"type/swiftest_base.html"},{"title":"swiftest_cb – swiftest ","text":"type, public, abstract, extends( swiftest_base ) :: swiftest_cb A concrete lass for the central body in a Swiftest simulation Inherits type~~swiftest_cb~~InheritsGraph type~swiftest_cb swiftest_cb type~swiftest_particle_info swiftest_particle_info type~swiftest_cb->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_cb->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~swiftest_cb~~InheritedByGraph type~swiftest_cb swiftest_cb type~whm_cb whm_cb type~whm_cb->type~swiftest_cb type~helio_cb helio_cb type~helio_cb->type~swiftest_cb type~swiftest_nbody_system swiftest_nbody_system type~swiftest_nbody_system->type~swiftest_cb cb type~symba_cb symba_cb type~symba_cb->type~helio_cb type~whm_nbody_system whm_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~rmvs_cb rmvs_cb type~rmvs_cb->type~whm_cb type~rmvs_nbody_system rmvs_nbody_system type~rmvs_nbody_system->type~whm_nbody_system type~rmvs_tp rmvs_tp type~rmvs_tp->type~rmvs_cb cb_heliocentric type~helio_nbody_system helio_nbody_system type~helio_nbody_system->type~whm_nbody_system type~rmvs_pl rmvs_pl type~rmvs_pl->type~rmvs_nbody_system planetocentric type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~helio_nbody_system Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables info id mass Gmass radius density j2rp2 j4rp4 aobl atide aoblbeg aoblend atidebeg atideend xb vb agr Ip rot k2 Q tlag L0 dL Type-Bound Procedures dump dump_particle_info write_frame_netcdf write_particle_info_netcdf write_particle_info read_in read_frame write_frame_bin write_frame Components Type Visibility Attributes Name Initial type( swiftest_particle_info ), public :: info Particle metadata information integer(kind=I4B), public :: id = 0 External identifier (unique) real(kind=DP), public :: mass = 0.0_DP Central body mass (units MU) real(kind=DP), public :: Gmass = 0.0_DP Central mass gravitational term G * mass (units GU * MU) real(kind=DP), public :: radius = 0.0_DP Central body radius (units DU) real(kind=DP), public :: density = 1.0_DP Central body mass density - calculated internally (units MU / DU**3) real(kind=DP), public :: j2rp2 = 0.0_DP J2*R&#94;2 term for central body real(kind=DP), public :: j4rp4 = 0.0_DP J4*R&#94;2 term for central body real(kind=DP), public, dimension(NDIM) :: aobl = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: atide = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: aoblbeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: aoblend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: atidebeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: atideend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: xb = 0.0_DP Barycentric position (units DU) real(kind=DP), public, dimension(NDIM) :: vb = 0.0_DP Barycentric velocity (units DU / TU) real(kind=DP), public, dimension(NDIM) :: agr = 0.0_DP Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(NDIM) :: Ip = 0.0_DP Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(NDIM) :: rot = 0.0_DP Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public :: k2 = 0.0_DP Tidal Love number real(kind=DP), public :: Q = 0.0_DP Tidal quality factor real(kind=DP), public :: tlag = 0.0_DP Tidal phase lag angle real(kind=DP), public, dimension(NDIM) :: L0 = 0.0_DP Initial angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: dL = 0.0_DP Change in angular momentum of the central body Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file interface public module subroutine io_dump_base(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file interface public module subroutine io_dump_particle_info_base(self, param, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format interface public module subroutine netcdf_write_frame_base(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file interface public module subroutine netcdf_write_particle_info_base(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset generic, public :: write_particle_info => write_particle_info_netcdf public interface netcdf_write_particle_info_base () Arguments None procedure, public :: read_in => io_read_in_cb I/O routine for reading in central body data interface public module subroutine io_read_in_cb(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_cb I/O routine for reading out a single frame of time-series data for the central body interface public module function io_read_frame_cb(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: write_frame_bin => io_write_frame_cb I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_cb(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters generic, public :: write_frame => write_frame_netcdf , write_frame_bin Write a frame (either binary or NetCDF, using generic procedures) public interface netcdf_write_frame_base () Arguments None public interface io_write_frame_cb () Arguments None","tags":"","loc":"type/swiftest_cb.html"},{"title":"swiftest_body – swiftest ","text":"type, public, abstract, extends( swiftest_base ) :: swiftest_body An abstract class for a generic collection of Swiftest bodies\n Superclass that defines the generic elements of a Swiftest particle Inherits type~~swiftest_body~~InheritsGraph type~swiftest_body swiftest_body type~swiftest_particle_info swiftest_particle_info type~swiftest_body->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~swiftest_body~~InheritedByGraph type~swiftest_body swiftest_body type~swiftest_pl swiftest_pl type~swiftest_pl->type~swiftest_body type~swiftest_tp swiftest_tp type~swiftest_tp->type~swiftest_body type~whm_pl whm_pl type~whm_pl->type~swiftest_pl type~fraggle_fragments fraggle_fragments type~fraggle_fragments->type~swiftest_pl type~whm_tp whm_tp type~whm_tp->type~swiftest_tp type~helio_tp helio_tp type~helio_tp->type~swiftest_tp type~swiftest_nbody_system swiftest_nbody_system type~swiftest_nbody_system->type~swiftest_pl pl, pl_discards type~swiftest_nbody_system->type~swiftest_tp tp, tp_discards type~helio_pl helio_pl type~helio_pl->type~swiftest_pl type~rmvs_tp rmvs_tp type~rmvs_tp->type~whm_tp type~whm_nbody_system whm_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~symba_tp symba_tp type~symba_tp->type~helio_tp type~rmvs_pl rmvs_pl type~rmvs_pl->type~whm_pl type~rmvs_nbody_system rmvs_nbody_system type~rmvs_pl->type~rmvs_nbody_system planetocentric type~symba_pl symba_pl type~symba_pl->type~helio_pl type~rmvs_nbody_system->type~whm_nbody_system type~symba_merger symba_merger type~symba_merger->type~symba_pl type~helio_nbody_system helio_nbody_system type~helio_nbody_system->type~whm_nbody_system type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~symba_merger pl_adds type~symba_nbody_system->type~helio_nbody_system Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lfirst nbody info id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm Type-Bound Procedures dump dump_particle_info write_frame_netcdf write_particle_info_netcdf write_particle_info discard kick set_mu step accel drift v2pv pv2v read_in read_frame write_frame_bin accel_obl el2xv xv2el setup accel_user append fill resize set_ir3 sort rearrange spill write_frame Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file interface public module subroutine io_dump_base(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file interface public module subroutine io_dump_particle_info_base(self, param, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format interface public module subroutine netcdf_write_frame_base(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file interface public module subroutine netcdf_write_particle_info_base(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset generic, public :: write_particle_info => write_particle_info_netcdf public interface netcdf_write_particle_info_base () Arguments None procedure( abstract_discard_body ), public, deferred :: discard subroutine abstract_discard_body(self, system, param) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure( abstract_kick_body ), public, deferred :: kick subroutine abstract_kick_body(self, system, param, t, dt, lbeg) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system objec class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure( abstract_set_mu ), public, deferred :: set_mu subroutine abstract_set_mu(self, cb) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure( abstract_step_body ), public, deferred :: step subroutine abstract_step_body(self, system, param, t, dt) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure( abstract_accel ), public, deferred :: accel subroutine abstract_accel(self, system, param, t, lbeg) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables interface public module subroutine drift_body(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file interface public module subroutine io_read_in_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module function io_read_frame_body(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: accel_obl => obl_acc_body Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_body(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: setup => setup_body A constructor that sets the number of bodies and allocates all allocatable arrays interface public module subroutine setup_body(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: append => util_append_body Appends elements from one structure to another interface public module subroutine util_append_body(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: fill => util_fill_body \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine util_fill_body(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: resize => util_resize_body Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. interface public module subroutine util_resize_body(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object procedure, public :: sort => util_sort_body Sorts body arrays by a sortable componen interface public module subroutine util_sort_body(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => util_sort_rearrange_body Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine util_sort_rearrange_body(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => util_spill_body \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine util_spill_body(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not generic, public :: write_frame => write_frame_netcdf , write_frame_bin Add the generic write frame for Fortran binary files public interface netcdf_write_frame_base () Arguments None public interface io_write_frame_body () Arguments None","tags":"","loc":"type/swiftest_body.html"},{"title":"swiftest_pl – swiftest ","text":"type, public, abstract, extends( swiftest_body ) :: swiftest_pl An abstract class for a generic collection of Swiftest massive bodies\n Superclass that defines the generic elements of a Swiftest particle Inherits type~~swiftest_pl~~InheritsGraph type~swiftest_pl swiftest_pl type~swiftest_body swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_particle_info swiftest_particle_info type~swiftest_body->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~swiftest_pl~~InheritedByGraph type~swiftest_pl swiftest_pl type~whm_pl whm_pl type~whm_pl->type~swiftest_pl type~fraggle_fragments fraggle_fragments type~fraggle_fragments->type~swiftest_pl type~helio_pl helio_pl type~helio_pl->type~swiftest_pl type~swiftest_nbody_system swiftest_nbody_system type~swiftest_nbody_system->type~swiftest_pl pl, pl_discards type~whm_nbody_system whm_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~rmvs_pl rmvs_pl type~rmvs_pl->type~whm_pl type~rmvs_nbody_system rmvs_nbody_system type~rmvs_pl->type~rmvs_nbody_system planetocentric type~symba_pl symba_pl type~symba_pl->type~helio_pl type~rmvs_nbody_system->type~whm_nbody_system type~symba_merger symba_merger type~symba_merger->type~symba_pl type~helio_nbody_system helio_nbody_system type~helio_nbody_system->type~whm_nbody_system type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~symba_merger pl_adds type~symba_nbody_system->type~helio_nbody_system Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lfirst nbody info id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm mass Gmass rhill radius xbeg xend vbeg density Ip rot k2 Q tlag k_plpl nplpl Type-Bound Procedures dump dump_particle_info write_frame_netcdf write_particle_info_netcdf write_particle_info kick step accel drift v2pv pv2v read_in read_frame write_frame_bin el2xv xv2el accel_user set_ir3 write_frame discard index accel_int accel_obl setup accel_tides append h2b b2h vh2vb vb2vh xh2xb fill resize set_beg_end set_mu set_rhill sort rearrange spill Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file interface public module subroutine io_dump_base(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file interface public module subroutine io_dump_particle_info_base(self, param, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format interface public module subroutine netcdf_write_frame_base(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file interface public module subroutine netcdf_write_particle_info_base(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset generic, public :: write_particle_info => write_particle_info_netcdf public interface netcdf_write_particle_info_base () Arguments None procedure( abstract_kick_body ), public, deferred :: kick subroutine abstract_kick_body(self, system, param, t, dt, lbeg) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system objec class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure( abstract_step_body ), public, deferred :: step subroutine abstract_step_body(self, system, param, t, dt) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure( abstract_accel ), public, deferred :: accel subroutine abstract_accel(self, system, param, t, lbeg) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables interface public module subroutine drift_body(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file interface public module subroutine io_read_in_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module function io_read_frame_body(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object generic, public :: write_frame => write_frame_netcdf , write_frame_bin Add the generic write frame for Fortran binary files public interface netcdf_write_frame_base () Arguments None public interface io_write_frame_body () Arguments None procedure, public :: discard => discard_pl Placeholder method for discarding massive bodies interface public module subroutine discard_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameter procedure, public :: index => util_index_eucl_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix interface public module subroutine util_index_eucl_plpl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies interface public module subroutine kick_getacch_int_pl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: setup => setup_pl A base constructor that sets the number of bodies and allocates and initializes all arrays interface public module subroutine setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body interface public module subroutine tides_kick_getacch_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: append => util_append_pl Appends elements from one structure to another interface public module subroutine util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: vh2vb => util_coord_vh2vb_pl Convert massive bodies from heliocentric to barycentric coordinates (velocity only) interface public module subroutine util_coord_vh2vb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: vb2vh => util_coord_vb2vh_pl Convert massive bodies from barycentric to heliocentric coordinates (velocity only) interface public module subroutine util_coord_vb2vh_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xh2xb => util_coord_xh2xb_pl Convert massive bodies from heliocentric to barycentric coordinates (position only) interface public module subroutine util_coord_xh2xb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: fill => util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: resize => util_resize_pl Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. interface public module subroutine util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. interface public module subroutine util_set_beg_end_pl(self, xbeg, xend, vbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object real(kind=DP), intent(in), optional dimension(:,:) :: xbeg Position vectors at beginning of step real(kind=DP), intent(in), optional dimension(:,:) :: xend Positions vectors at end of step real(kind=DP), intent(in), optional dimension(:,:) :: vbeg vbeg is an unused variable to keep this method forward compatible with RMVS procedure, public :: set_mu => util_set_mu_pl Method used to construct the vectorized form of the central body mass interface public module subroutine util_set_mu_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body interface public module subroutine util_set_rhill(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: sort => util_sort_pl Sorts body arrays by a sortable component interface public module subroutine util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"type/swiftest_pl.html"},{"title":"swiftest_tp – swiftest ","text":"type, public, abstract, extends( swiftest_body ) :: swiftest_tp An abstract class for a generic collection of Swiftest test particles\n Superclass that defines the generic elements of a Swiftest test particle Inherits type~~swiftest_tp~~InheritsGraph type~swiftest_tp swiftest_tp type~swiftest_body swiftest_body type~swiftest_tp->type~swiftest_body type~swiftest_particle_info swiftest_particle_info type~swiftest_body->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~swiftest_tp~~InheritedByGraph type~swiftest_tp swiftest_tp type~whm_tp whm_tp type~whm_tp->type~swiftest_tp type~helio_tp helio_tp type~helio_tp->type~swiftest_tp type~swiftest_nbody_system swiftest_nbody_system type~swiftest_nbody_system->type~swiftest_tp tp, tp_discards type~symba_tp symba_tp type~symba_tp->type~helio_tp type~whm_nbody_system whm_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~rmvs_tp rmvs_tp type~rmvs_tp->type~whm_tp type~rmvs_nbody_system rmvs_nbody_system type~rmvs_nbody_system->type~whm_nbody_system type~helio_nbody_system helio_nbody_system type~helio_nbody_system->type~whm_nbody_system type~rmvs_pl rmvs_pl type~rmvs_pl->type~rmvs_nbody_system planetocentric type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~helio_nbody_system Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lfirst nbody info id status ldiscard lmask mu xh vh xb vb ah aobl atide agr ir3h a e inc capom omega capm isperi peri atp k_pltp npltp Type-Bound Procedures dump dump_particle_info write_frame_netcdf write_particle_info_netcdf write_particle_info kick step accel drift v2pv pv2v read_in read_frame write_frame_bin el2xv xv2el accel_user set_ir3 write_frame discard accel_int accel_obl setup append h2b b2h vb2vh vh2vb xh2xb fill get_peri resize set_mu sort rearrange spill Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill integer(kind=I4B), public, dimension(:), allocatable :: isperi Perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri Perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp Semimajor axis following perihelion passage integer(kind=I4B), public, dimension(:,:), allocatable :: k_pltp Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: npltp Number of pl-tp comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_tp and util_spill_tp Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file interface public module subroutine io_dump_base(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file interface public module subroutine io_dump_particle_info_base(self, param, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format interface public module subroutine netcdf_write_frame_base(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file interface public module subroutine netcdf_write_particle_info_base(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset generic, public :: write_particle_info => write_particle_info_netcdf public interface netcdf_write_particle_info_base () Arguments None procedure( abstract_kick_body ), public, deferred :: kick subroutine abstract_kick_body(self, system, param, t, dt, lbeg) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system objec class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. procedure( abstract_step_body ), public, deferred :: step subroutine abstract_step_body(self, system, param, t, dt) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure( abstract_accel ), public, deferred :: accel subroutine abstract_accel(self, system, param, t, lbeg) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables interface public module subroutine drift_body(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file interface public module subroutine io_read_in_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module function io_read_frame_body(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object generic, public :: write_frame => write_frame_netcdf , write_frame_bin Add the generic write frame for Fortran binary files public interface netcdf_write_frame_base () Arguments None public interface io_write_frame_body () Arguments None procedure, public :: discard => discard_tp Check to see if test particles should be discarded based on their positions relative to the massive bodies interface public module subroutine discard_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: accel_int => kick_getacch_int_tp Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies interface public module subroutine kick_getacch_int_tp(self, GMpl, xhp, npl) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle real(kind=DP), intent(in), dimension(:) :: GMpl Massive body masses real(kind=DP), intent(in), dimension(:,:) :: xhp Massive body position vectors integer(kind=I4B), intent(in) :: npl Number of active massive bodies procedure, public :: accel_obl => obl_acc_tp Compute the barycentric accelerations of bodies due to the oblateness of the central body interface public module subroutine obl_acc_tp(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object procedure, public :: setup => setup_tp A base constructor that sets the number of bodies and interface public module subroutine setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parametersr procedure, public :: append => util_append_tp Appends elements from one structure to another interface public module subroutine util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: h2b => util_coord_h2b_tp Convert test particles from heliocentric to barycentric coordinates (position and velocity) interface public module subroutine util_coord_h2b_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: b2h => util_coord_b2h_tp Convert test particles from barycentric to heliocentric coordinates (position and velocity) interface public module subroutine util_coord_b2h_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: vb2vh => util_coord_vb2vh_tp Convert test particles from barycentric to heliocentric coordinates (velocity only) interface public module subroutine util_coord_vb2vh_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body procedure, public :: vh2vb => util_coord_vh2vb_tp Convert test particles from heliocentric to barycentric coordinates (velocity only) interface public module subroutine util_coord_vh2vb_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body procedure, public :: xh2xb => util_coord_xh2xb_tp Convert test particles from heliocentric to barycentric coordinates (position only) interface public module subroutine util_coord_xh2xb_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object procedure, public :: fill => util_fill_tp \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) interface public module subroutine util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps procedure, public :: get_peri => util_peri_tp Determine system pericenter passages for test particles interface public module subroutine util_peri_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: resize => util_resize_tp Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. interface public module subroutine util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: nnew New size neded procedure, public :: set_mu => util_set_mu_tp Method used to construct the vectorized form of the central body mass interface public module subroutine util_set_mu_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object procedure, public :: sort => util_sort_tp Sorts body arrays by a sortable component interface public module subroutine util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order procedure, public :: rearrange => util_sort_rearrange_tp Rearranges the order of array elements of body based on an input index array. Used in sorting methods interface public module subroutine util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) procedure, public :: spill => util_spill_tp \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"type/swiftest_tp.html"},{"title":"swiftest_nbody_system – swiftest ","text":"type, public, abstract :: swiftest_nbody_system An abstract class for a basic Swiftest nbody system \n  This superclass contains a minimial system of a set of test particles (tp), massive bodies (pl), and a central body (cb) Inherits type~~swiftest_nbody_system~~InheritsGraph type~swiftest_nbody_system swiftest_nbody_system type~swiftest_cb swiftest_cb type~swiftest_nbody_system->type~swiftest_cb cb type~swiftest_pl swiftest_pl type~swiftest_nbody_system->type~swiftest_pl pl, pl_discards type~swiftest_tp swiftest_tp type~swiftest_nbody_system->type~swiftest_tp tp, tp_discards type~swiftest_particle_info swiftest_particle_info type~swiftest_cb->type~swiftest_particle_info info type~swiftest_base swiftest_base type~swiftest_cb->type~swiftest_base type~swiftest_body swiftest_body type~swiftest_pl->type~swiftest_body type~swiftest_tp->type~swiftest_body type~swiftest_body->type~swiftest_particle_info info type~swiftest_body->type~swiftest_base Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~swiftest_nbody_system~~InheritedByGraph type~swiftest_nbody_system swiftest_nbody_system type~whm_nbody_system whm_nbody_system type~whm_nbody_system->type~swiftest_nbody_system type~rmvs_nbody_system rmvs_nbody_system type~rmvs_nbody_system->type~whm_nbody_system type~helio_nbody_system helio_nbody_system type~helio_nbody_system->type~whm_nbody_system type~rmvs_pl rmvs_pl type~rmvs_pl->type~rmvs_nbody_system planetocentric type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~helio_nbody_system Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables cb pl tp tp_discards pl_discards GMtot ke_orbit ke_spin pe te oblpot Lorbit Lspin Ltot lbeg Type-Bound Procedures step discard conservation_report dump get_old_t_final read_frame read_particle_info write_discard write_frame write_hdr_bin write_hdr_netcdf obl_pot initialize init_particle_info step_spin set_msys get_energy_and_momentum rescale validate_ids write_hdr Components Type Visibility Attributes Name Initial class( swiftest_cb ), public, allocatable :: cb Central body data structure class( swiftest_pl ), public, allocatable :: pl Massive body data structure class( swiftest_tp ), public, allocatable :: tp Test particle data structure class( swiftest_tp ), public, allocatable :: tp_discards Discarded test particle data structure class( swiftest_pl ), public, allocatable :: pl_discards Discarded massive body particle data structure real(kind=DP), public :: GMtot = 0.0_DP Total system mass - used for barycentric coordinate conversion real(kind=DP), public :: ke_orbit = 0.0_DP System orbital kinetic energy real(kind=DP), public :: ke_spin = 0.0_DP System spin kinetic energy real(kind=DP), public :: pe = 0.0_DP System potential energy real(kind=DP), public :: te = 0.0_DP System total energy real(kind=DP), public :: oblpot = 0.0_DP System potential energy due to oblateness of the central body real(kind=DP), public, dimension(NDIM) :: Lorbit = 0.0_DP System orbital angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lspin = 0.0_DP System spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Ltot = 0.0_DP System angular momentum vector logical, public :: lbeg True if this is the beginning of a step. This is used so that test particle steps can be calculated \n    separately from massive bodies.  Massive body variables are saved at half steps, and passed to \n    the test particles Type-Bound Procedures procedure( abstract_step_system ), public, deferred :: step Each integrator will have its own version of the step subroutine abstract_step_system(self, param, t, dt) Prototype Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure, public :: discard => discard_system Perform a discard step on the system interface public module subroutine discard_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: conservation_report => io_conservation_report Compute energy and momentum and print out the change with time interface public module subroutine io_conservation_report(self, param, lterminal) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Input colleciton of user-defined parameters logical, intent(in) :: lterminal Indicates whether to output information to the terminal screen procedure, public :: dump => io_dump_system Dump the state of the system to a file interface public module subroutine io_dump_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: get_old_t_final => io_get_old_t_final_system Validates the dump file to check whether the dump file initial conditions duplicate the last frame of the binary output. interface public module function io_get_old_t_final_system(self, param) result(old_t_final) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self class( swiftest_parameters ), intent(in) :: param Return Value real(kind=DP) procedure, public :: read_frame => io_read_frame_system Read in a frame of input data from file interface public module function io_read_frame_system(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful procedure, public :: read_particle_info => io_read_particle_info_system Read in particle metadata from file interface public module subroutine io_read_particle_info_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: write_discard => io_write_discard Write out information about discarded test particles interface public module subroutine io_write_discard(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: write_frame => io_write_frame_system Append a frame of output data to file interface public module subroutine io_write_frame_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: write_hdr_bin => io_write_hdr_system Write a header for an output frame in Fortran binary format interface public module subroutine io_write_hdr_system(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest nbody system object integer(kind=I4B), intent(inout) :: iu Output file unit number class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: write_hdr_netcdf => netcdf_write_hdr_system Write a header for an output frame in NetCDF format interface public module subroutine netcdf_write_hdr_system(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest nbody system object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: obl_pot => obl_pot_system Compute the contribution to the total gravitational potential due solely to the oblateness of the central body interface public module subroutine obl_pot_system(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object procedure, public :: initialize => setup_initialize_system Initialize the system from input files interface public module subroutine setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: init_particle_info => setup_initialize_particle_info_system Initialize the system from input files interface public module subroutine setup_initialize_particle_info_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters procedure, public :: step_spin => tides_step_spin_system Steps the spins of the massive & central bodies due to tides. interface public module subroutine tides_step_spin_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize procedure, public :: set_msys => util_set_msys Sets the value of msys from the masses of system bodies. interface public module subroutine util_set_msys(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object procedure, public :: get_energy_and_momentum => util_get_energy_momentum_system Calculates the total system energy and momentum interface public module subroutine util_get_energy_momentum_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters procedure, public :: rescale => util_rescale_system Rescales the system into a new set of units interface public module subroutine util_rescale_system(self, param, mscale, dscale, tscale) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters. Returns with new values of the scale vactors and GU real(kind=DP), intent(in) :: mscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: dscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: tscale Scale factors for mass, distance, and time units, respectively. procedure, public :: validate_ids => util_valid_id_system Validate the numerical ids passed to the system and save the maximum value interface public module subroutine util_valid_id_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters generic, public :: write_hdr => write_hdr_bin , write_hdr_netcdf Generic method call for writing headers public interface io_write_hdr_system () Arguments None public interface netcdf_write_hdr_system () Arguments None","tags":"","loc":"type/swiftest_nbody_system.html"},{"title":"swiftest_encounter – swiftest ","text":"type, public :: swiftest_encounter Inherited by type~~swiftest_encounter~~InheritedByGraph type~swiftest_encounter swiftest_encounter type~symba_encounter symba_encounter type~symba_encounter->type~swiftest_encounter type~symba_pltpenc symba_pltpenc type~symba_pltpenc->type~symba_encounter type~symba_plplenc symba_plplenc type~symba_plplenc->type~symba_encounter type~symba_nbody_system symba_nbody_system type~symba_nbody_system->type~symba_pltpenc pltpenc_list type~symba_nbody_system->type~symba_plplenc plplenc_list, plplcollision_list Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nenc lvdotr status kidx index1 index2 id1 id2 x1 x2 v1 v2 t Type-Bound Procedures setup append copy spill resize write Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: nenc Total number of encounters logical, public, dimension(:), allocatable :: lvdotr relative vdotr flag integer(kind=I4B), public, dimension(:), allocatable :: status status of the interaction integer(kind=I8B), public, dimension(:), allocatable :: kidx index value of the encounter from the master k_plpl encounter list integer(kind=I4B), public, dimension(:), allocatable :: index1 position of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: index2 position of the second body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: id1 id of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: id2 id of the second body in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x1 the position of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x2 the position of body 2 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v1 the velocity of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v2 the velocity of body 2 in the encounter real(kind=DP), public, dimension(:), allocatable :: t Time of encounter Type-Bound Procedures procedure, public :: setup => setup_encounter A constructor that sets the number of encounters and allocates and initializes all arrays interface public module subroutine setup_encounter(self, n) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for procedure, public :: append => util_append_encounter Appends elements from one structure to another interface public module subroutine util_append_encounter(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list object class( swiftest_encounter ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to procedure, public :: copy => util_copy_encounter Copies elements from the source encounter list into self. interface public module subroutine util_copy_encounter(self, source) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Encounter list class( swiftest_encounter ), intent(in) :: source Source object to copy into procedure, public :: spill => util_spill_encounter \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) interface public module subroutine util_spill_encounter(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list procedure, public :: resize => util_resize_encounter Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small. interface public module subroutine util_resize_encounter(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list integer(kind=I4B), intent(in) :: nnew New size of list needed procedure, public :: write => io_write_encounter Write close encounter data to output binary file interface public module subroutine io_write_encounter(self, pl, encbody, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(in) :: self Swiftest encounter list object class( swiftest_pl ), intent(in) :: pl Swiftest massive body object class( swiftest_body ), intent(in) :: encbody Encountering body - Swiftest generic body object (pl or tp) class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"type/swiftest_encounter.html"},{"title":"lambda_obj – swiftest ","text":"type, public :: lambda_obj Base class for an lambda function object. This object takes no additional arguments other than the dependent variable x, an array of real numbers Inherited by type~~lambda_obj~~InheritedByGraph type~lambda_obj lambda_obj type~lambda_obj_err lambda_obj_err type~lambda_obj_err->type~lambda_obj type~lambda_obj_tvar lambda_obj_tvar type~lambda_obj_tvar->type~lambda_obj Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lambdaptr lastval lastarg Constructor lambda_obj Finalization Procedures lambda_destroy Type-Bound Procedures init eval lambda_init_0 Components Type Visibility Attributes Name Initial procedure( lambda0 ), public, pointer, nopass :: lambdaptr => null() real(kind=DP), public :: lastval real(kind=DP), public, dimension(:), allocatable :: lastarg Constructor public interface lambda_obj public function lambda_init_0 (lambda) Arguments Type Intent Optional Attributes Name procedure( lambda0 ) :: lambda Return Value type( lambda_obj ) public function lambda_init_0_err (lambda, lerr) Arguments Type Intent Optional Attributes Name procedure( lambda0err ) :: lambda logical, intent(in) :: lerr Return Value type( lambda_obj_err ) public function lambda_init_tvar (lambda, t) Arguments Type Intent Optional Attributes Name procedure( lambda0tvar ) :: lambda real(kind=DP), intent(in) :: t Return Value type( lambda_obj_tvar ) Finalization Procedures final :: lambda_destroy public subroutine lambda_destroy (self) Arguments Type Intent Optional Attributes Name type( lambda_obj ) :: self Type-Bound Procedures generic, public :: init => lambda_init_0 public function lambda_init_0 (lambda) Arguments Type Intent Optional Attributes Name procedure( lambda0 ) :: lambda Return Value type( lambda_obj ) procedure, public :: eval => lambda_eval_0 public function lambda_eval_0 (self, x) result(y) Arguments Type Intent Optional Attributes Name class( lambda_obj ), intent(inout) :: self real(kind=DP), intent(in), dimension(:) :: x Return Value real(kind=DP) procedure, public, nopass :: lambda_init_0 public function lambda_init_0 (lambda) Arguments Type Intent Optional Attributes Name procedure( lambda0 ) :: lambda Return Value type( lambda_obj )","tags":"","loc":"type/lambda_obj.html"},{"title":"lambda_obj_err – swiftest ","text":"type, public, extends( lambda_obj ) :: lambda_obj_err Extended class for an lambda function object. This object takes allows for the return of a logical error flag during evaluation of the function. Inherits type~~lambda_obj_err~~InheritsGraph type~lambda_obj_err lambda_obj_err type~lambda_obj lambda_obj type~lambda_obj_err->type~lambda_obj Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lambdaptr lastval lastarg lambdaptr_err lerr Type-Bound Procedures lambda_init_0 init eval lambda_init_0_err Components Type Visibility Attributes Name Initial procedure( lambda0 ), public, pointer, nopass :: lambdaptr => null() real(kind=DP), public :: lastval real(kind=DP), public, dimension(:), allocatable :: lastarg procedure( lambda0err ), public, pointer, nopass :: lambdaptr_err => null() logical, public :: lerr Type-Bound Procedures procedure, public, nopass :: lambda_init_0 public function lambda_init_0 (lambda) Arguments Type Intent Optional Attributes Name procedure( lambda0 ) :: lambda Return Value type( lambda_obj ) generic, public :: init => lambda_init_0 , lambda_init_0_err public function lambda_init_0 (lambda) Arguments Type Intent Optional Attributes Name procedure( lambda0 ) :: lambda Return Value type( lambda_obj ) public function lambda_init_0_err (lambda, lerr) Arguments Type Intent Optional Attributes Name procedure( lambda0err ) :: lambda logical, intent(in) :: lerr Return Value type( lambda_obj_err ) procedure, public :: eval => lambda_eval_0_err public function lambda_eval_0_err (self, x) result(y) Arguments Type Intent Optional Attributes Name class( lambda_obj_err ), intent(inout) :: self real(kind=DP), intent(in), dimension(:) :: x Return Value real(kind=DP) procedure, public, nopass :: lambda_init_0_err public function lambda_init_0_err (lambda, lerr) Arguments Type Intent Optional Attributes Name procedure( lambda0err ) :: lambda logical, intent(in) :: lerr Return Value type( lambda_obj_err )","tags":"","loc":"type/lambda_obj_err.html"},{"title":"lambda_obj_tvar – swiftest ","text":"type, public, extends( lambda_obj ) :: lambda_obj_tvar Base class for an lambda function object. This object takes no additional arguments other than the dependent variable x, an array of real numbers Inherits type~~lambda_obj_tvar~~InheritsGraph type~lambda_obj_tvar lambda_obj_tvar type~lambda_obj lambda_obj type~lambda_obj_tvar->type~lambda_obj Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lambdaptr lastval lastarg lambdaptr_tvar Type-Bound Procedures eval lambda_init_0 init evalt lambda_init_tvar Components Type Visibility Attributes Name Initial procedure( lambda0 ), public, pointer, nopass :: lambdaptr => null() real(kind=DP), public :: lastval real(kind=DP), public, dimension(:), allocatable :: lastarg procedure( lambda0tvar ), public, pointer, nopass :: lambdaptr_tvar => null() Type-Bound Procedures procedure, public :: eval => lambda_eval_0 public function lambda_eval_0 (self, x) result(y) Arguments Type Intent Optional Attributes Name class( lambda_obj ), intent(inout) :: self real(kind=DP), intent(in), dimension(:) :: x Return Value real(kind=DP) procedure, public, nopass :: lambda_init_0 public function lambda_init_0 (lambda) Arguments Type Intent Optional Attributes Name procedure( lambda0 ) :: lambda Return Value type( lambda_obj ) generic, public :: init => lambda_init_0 , lambda_init_tvar public function lambda_init_0 (lambda) Arguments Type Intent Optional Attributes Name procedure( lambda0 ) :: lambda Return Value type( lambda_obj ) public function lambda_init_tvar (lambda, t) Arguments Type Intent Optional Attributes Name procedure( lambda0tvar ) :: lambda real(kind=DP), intent(in) :: t Return Value type( lambda_obj_tvar ) procedure, public :: evalt => lambda_eval_tvar public function lambda_eval_tvar (self, x, t) result(y) Arguments Type Intent Optional Attributes Name class( lambda_obj_tvar ), intent(inout) :: self real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in) :: t Return Value real(kind=DP),\n  dimension(:), allocatable procedure, public, nopass :: lambda_init_tvar public function lambda_init_tvar (lambda, t) Arguments Type Intent Optional Attributes Name procedure( lambda0tvar ) :: lambda real(kind=DP), intent(in) :: t Return Value type( lambda_obj_tvar )","tags":"","loc":"type/lambda_obj_tvar.html"},{"title":"tidederiv – swiftest","text":"abstract interface function tidederiv(x, t, dt, xbeg, xend) result(y) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), dimension(:,:) :: xbeg real(kind=DP), intent(in), dimension(:,:) :: xend Return Value real(kind=DP),\n  dimension(:),allocatable","tags":"","loc":"interface/tidederiv.html"},{"title":"abstract_read_frame – swiftest","text":"abstract interface public function abstract_read_frame(self, iu, param) result(ierr) Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful","tags":"","loc":"interface/abstract_read_frame.html"},{"title":"abstract_discard_body – swiftest","text":"abstract interface public subroutine abstract_discard_body(self, system, param) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/abstract_discard_body.html"},{"title":"abstract_accel – swiftest","text":"abstract interface public subroutine abstract_accel(self, system, param, t, lbeg) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step","tags":"","loc":"interface/abstract_accel.html"},{"title":"abstract_kick_body – swiftest","text":"abstract interface public subroutine abstract_kick_body(self, system, param, t, dt, lbeg) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system objec class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not.","tags":"","loc":"interface/abstract_kick_body.html"},{"title":"abstract_set_mu – swiftest","text":"abstract interface public subroutine abstract_set_mu(self, cb) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/abstract_set_mu.html"},{"title":"abstract_step_body – swiftest","text":"abstract interface public subroutine abstract_step_body(self, system, param, t, dt) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"interface/abstract_step_body.html"},{"title":"abstract_step_system – swiftest","text":"abstract interface public subroutine abstract_step_system(self, param, t, dt) Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"interface/abstract_step_system.html"},{"title":"lambda0 – swiftest","text":"abstract interface public function lambda0(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: x Return Value real(kind=DP)","tags":"","loc":"interface/lambda0.html"},{"title":"lambda0err – swiftest","text":"abstract interface public function lambda0err(x, lerr) result(y) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: x logical, intent(out) :: lerr Return Value real(kind=DP)","tags":"","loc":"interface/lambda0err.html"},{"title":"lambda0tvar – swiftest","text":"abstract interface public function lambda0tvar(x, t) result(y) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in) :: t Return Value real(kind=DP),\n  dimension(:),allocatable","tags":"","loc":"interface/lambda0tvar.html"},{"title":"tides_spin_derivs – swiftest","text":"function tides_spin_derivs(rot_pl_cb, t, dt, xbeg, xend) result(drot) Need to add more arguments so we can pull in mass, radius, Ip, J2, etc...\n author: Jennifer L.L. Pouplin and David A. Minton function used to calculate the derivatives that are fed to the ODE solver Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: rot_pl_cb Array of rotations. The last element is the central body, and all others are massive bodies real(kind=DP), intent(in) :: t Current time, which is used to interpolate the massive body positions real(kind=DP), intent(in) :: dt Total step size real(kind=DP), intent(in), dimension(:,:) :: xbeg real(kind=DP), intent(in), dimension(:,:) :: xend Return Value real(kind=DP),\n  dimension(:,:),allocatable Contents None","tags":"","loc":"proc/tides_spin_derivs.html"},{"title":"tides_derivs_eval – swiftest","text":"function tides_derivs_eval(self, x, t) result(y) Arguments Type Intent Optional Attributes Name class( tides_derivs_func ), intent(inout) :: self real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in) :: t Return Value real(kind=DP),\n  dimension(:),allocatable Contents None","tags":"","loc":"proc/tides_derivs_eval.html"},{"title":"tides_derivs_init – swiftest","text":"function tides_derivs_init(lambda, dt, xbeg, xend) result(f) Arguments Type Intent Optional Attributes Name procedure( tidederiv ) :: lambda real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), dimension(:,:) :: xbeg real(kind=DP), intent(in), dimension(:,:) :: xend Return Value type( tides_derivs_func ) Called by proc~~tides_derivs_init~~CalledByGraph proc~tides_derivs_init tides_derivs_init interface~lambda_obj lambda_obj interface~lambda_obj->proc~tides_derivs_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/tides_derivs_init.html"},{"title":"lambda_obj – swiftest","text":"private interface lambda_obj Calls interface~~lambda_obj~~CallsGraph interface~lambda_obj lambda_obj proc~tides_derivs_init tides_derivs_init interface~lambda_obj->proc~tides_derivs_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures tides_derivs_init Module Procedures function tides_derivs_init (lambda, dt, xbeg, xend) result(f) Arguments Type Intent Optional Attributes Name procedure( tidederiv ) :: lambda real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), dimension(:,:) :: xbeg real(kind=DP), intent(in), dimension(:,:) :: xend Return Value type( tides_derivs_func )","tags":"","loc":"interface/lambda_obj.html"},{"title":"obl_pot_one – swiftest","text":"elemental function obl_pot_one(npl, GMcb, GMpl, j2rp2, j4rp4, zh, irh) result(oblpot) Compute the contribution to the total gravitational potential due solely to the oblateness of the central body from a single massive body\n    Returned value does not include monopole term or terms higher than J4 Reference : MacMillan , W . D . 1958 . The Theory of the Potential , ( Dover Publications ), 363 . Adapted from David E. Kaufmann's Swifter routine: obl_pot.f90 \n Adapted from Hal Levison's Swift routine obl_pot.f Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl Number of massive bodies real(kind=DP), intent(in) :: GMcb G*mass of the central body real(kind=DP), intent(in) :: GMpl G*mass of the massive body real(kind=DP), intent(in) :: j2rp2 J_2 / R**2 of the central body real(kind=DP), intent(in) :: j4rp4 J_2 / R**4 of the central body real(kind=DP), intent(in) :: zh z-component of the heliocentric distance vector of the massive body real(kind=DP), intent(in) :: irh Inverse of the heliocentric distance magnitude of the massive body Return Value real(kind=DP) Gravitational potential Called by proc~~obl_pot_one~~CalledByGraph proc~obl_pot_one obl_pot_one proc~obl_pot_system obl_pot_system proc~obl_pot_system->proc~obl_pot_one interface~obl_pot_system obl_pot_system interface~obl_pot_system->proc~obl_pot_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/obl_pot_one.html"},{"title":"orbel_flon – swiftest","text":"pure function orbel_flon(e, icapn) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: icapn Return Value real(kind=DP) Calls proc~~orbel_flon~~CallsGraph proc~orbel_flon orbel_flon 3 3 proc~orbel_flon->3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~orbel_flon~~CalledByGraph proc~orbel_flon orbel_flon proc~orbel_fhybrid orbel_fhybrid proc~orbel_fhybrid->proc~orbel_flon proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->proc~orbel_fhybrid proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_flon.html"},{"title":"orbel_fget – swiftest","text":"pure function orbel_fget(e, capn) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: capn Return Value real(kind=DP) Calls proc~~orbel_fget~~CallsGraph proc~orbel_fget orbel_fget proc~orbel_schget orbel_schget proc~orbel_fget->proc~orbel_schget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~orbel_fget~~CalledByGraph proc~orbel_fget orbel_fget proc~orbel_fhybrid orbel_fhybrid proc~orbel_fhybrid->proc~orbel_fget proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->proc~orbel_fhybrid proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_fget.html"},{"title":"orbel_zget – swiftest","text":"pure function orbel_zget(iq) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: iq Return Value real(kind=DP) Called by proc~~orbel_zget~~CalledByGraph proc~orbel_zget orbel_zget proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->proc~orbel_zget proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_zget.html"},{"title":"orbel_esolmd – swiftest","text":"pure function orbel_esolmd(e, m) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: m Return Value real(kind=DP) Calls proc~~orbel_esolmd~~CallsGraph proc~orbel_esolmd orbel_esolmd interface~orbel_scget orbel_scget proc~orbel_esolmd->interface~orbel_scget proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~orbel_esolmd~~CalledByGraph proc~orbel_esolmd orbel_esolmd proc~orbel_ehybrid orbel_ehybrid proc~orbel_ehybrid->proc~orbel_esolmd proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->proc~orbel_ehybrid proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_esolmd.html"},{"title":"orbel_ehie – swiftest","text":"pure function orbel_ehie(e, im) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: im Return Value real(kind=DP) Calls proc~~orbel_ehie~~CallsGraph proc~orbel_ehie orbel_ehie interface~orbel_scget orbel_scget proc~orbel_ehie->interface~orbel_scget proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~orbel_ehie~~CalledByGraph proc~orbel_ehie orbel_ehie proc~orbel_ehybrid orbel_ehybrid proc~orbel_ehybrid->proc~orbel_ehie proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->proc~orbel_ehybrid proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_ehie.html"},{"title":"orbel_eget – swiftest","text":"pure function orbel_eget(e, m) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: m Return Value real(kind=DP) Calls proc~~orbel_eget~~CallsGraph proc~orbel_eget orbel_eget interface~orbel_scget orbel_scget proc~orbel_eget->interface~orbel_scget proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~orbel_eget~~CalledByGraph proc~orbel_eget orbel_eget proc~orbel_ehybrid orbel_ehybrid proc~orbel_ehybrid->proc~orbel_eget proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->proc~orbel_ehybrid proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_eget.html"},{"title":"orbel_ehybrid – swiftest","text":"pure function orbel_ehybrid(e, m) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: m Return Value real(kind=DP) Calls proc~~orbel_ehybrid~~CallsGraph proc~orbel_ehybrid orbel_ehybrid proc~orbel_esolmd orbel_esolmd proc~orbel_ehybrid->proc~orbel_esolmd proc~orbel_ehie orbel_ehie proc~orbel_ehybrid->proc~orbel_ehie proc~orbel_eget orbel_eget proc~orbel_ehybrid->proc~orbel_eget interface~orbel_scget orbel_scget proc~orbel_esolmd->interface~orbel_scget proc~orbel_ehie->interface~orbel_scget proc~orbel_eget->interface~orbel_scget proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~orbel_ehybrid~~CalledByGraph proc~orbel_ehybrid orbel_ehybrid proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->proc~orbel_ehybrid proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_ehybrid.html"},{"title":"orbel_fhybrid – swiftest","text":"pure function orbel_fhybrid(e, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: n Return Value real(kind=DP) Calls proc~~orbel_fhybrid~~CallsGraph proc~orbel_fhybrid orbel_fhybrid proc~orbel_fget orbel_fget proc~orbel_fhybrid->proc~orbel_fget proc~orbel_flon orbel_flon proc~orbel_fhybrid->proc~orbel_flon proc~orbel_schget orbel_schget proc~orbel_fget->proc~orbel_schget 3 3 proc~orbel_flon->3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~orbel_fhybrid~~CalledByGraph proc~orbel_fhybrid orbel_fhybrid proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->proc~orbel_fhybrid proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_fhybrid.html"},{"title":"orbel_el2xv – swiftest","text":"pure subroutine orbel_el2xv(mu, a, ie, inc, capom, omega, capm, x, v) Compute osculating orbital elements from relative C)rtesian position and velocity\n  All angular measures are returned in radians\n      If inclination < TINY, longitude of the ascending node is arbitrarily set to 0 If eccentricity < sqrt ( TINY ), argument of pericenter is arbitrarily set to 0 ALGORITHM : See Fitzpatrick \"Principles of Cel. Mech.\" Adapted from Martin Duncan's el2xv.f\n DATE WRITTEN:  May 11, 1992.\n REVISIONS: May 26 - now use better Kepler solver for ellipses\n  and hyperbolae called EHYBRID.F and FHYBRID.F Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: a real(kind=DP), intent(in) :: ie real(kind=DP), intent(in) :: inc real(kind=DP), intent(in) :: capom real(kind=DP), intent(in) :: omega real(kind=DP), intent(in) :: capm real(kind=DP), intent(out), dimension(:) :: x real(kind=DP), intent(out), dimension(:) :: v Calls proc~~orbel_el2xv~~CallsGraph proc~orbel_el2xv orbel_el2xv proc~orbel_zget orbel_zget proc~orbel_el2xv->proc~orbel_zget proc~orbel_fhybrid orbel_fhybrid proc~orbel_el2xv->proc~orbel_fhybrid proc~orbel_schget orbel_schget proc~orbel_el2xv->proc~orbel_schget proc~orbel_ehybrid orbel_ehybrid proc~orbel_el2xv->proc~orbel_ehybrid interface~orbel_scget orbel_scget proc~orbel_el2xv->interface~orbel_scget proc~orbel_flon orbel_flon proc~orbel_fhybrid->proc~orbel_flon proc~orbel_fget orbel_fget proc~orbel_fhybrid->proc~orbel_fget proc~orbel_eget orbel_eget proc~orbel_ehybrid->proc~orbel_eget proc~orbel_esolmd orbel_esolmd proc~orbel_ehybrid->proc~orbel_esolmd proc~orbel_ehie orbel_ehie proc~orbel_ehybrid->proc~orbel_ehie proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget 3 3 proc~orbel_flon->3 proc~orbel_eget->interface~orbel_scget proc~orbel_esolmd->interface~orbel_scget proc~orbel_fget->proc~orbel_schget proc~orbel_ehie->interface~orbel_scget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~orbel_el2xv~~CalledByGraph proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_el2xv.html"},{"title":"orbel_schget – swiftest","text":"pure subroutine orbel_schget(angle, shx, chx) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: angle real(kind=DP), intent(out) :: shx real(kind=DP), intent(out) :: chx Called by proc~~orbel_schget~~CalledByGraph proc~orbel_schget orbel_schget proc~orbel_fget orbel_fget proc~orbel_fget->proc~orbel_schget proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->proc~orbel_schget proc~orbel_fhybrid orbel_fhybrid proc~orbel_el2xv->proc~orbel_fhybrid proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv proc~orbel_fhybrid->proc~orbel_fget interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_schget.html"},{"title":"whm_kick_getacch_ah0 – swiftest","text":"function whm_kick_getacch_ah0(mu, xhp, n) result(ah0) Compute zeroth term heliocentric accelerations of planets Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: mu real(kind=DP), intent(in), dimension(:,:) :: xhp integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  dimension(NDIM) Called by proc~~whm_kick_getacch_ah0~~CalledByGraph proc~whm_kick_getacch_ah0 whm_kick_getacch_ah0 proc~whm_kick_getacch_tp whm_kick_getacch_tp proc~whm_kick_getacch_tp->proc~whm_kick_getacch_ah0 proc~whm_kick_getacch_pl whm_kick_getacch_pl proc~whm_kick_getacch_pl->proc~whm_kick_getacch_ah0 interface~whm_kick_getacch_pl whm_kick_getacch_pl interface~whm_kick_getacch_pl->proc~whm_kick_getacch_pl interface~whm_kick_getacch_tp whm_kick_getacch_tp interface~whm_kick_getacch_tp->proc~whm_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_kick_getacch_ah0.html"},{"title":"whm_kick_getacch_ah1 – swiftest","text":"pure subroutine whm_kick_getacch_ah1(cb, pl) Compute first term heliocentric accelerations of planets Adapted from Hal Levison's Swift routine getacch_ah1.f\n Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah1.f90 Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: cb WHM central body object class( whm_pl ), intent(inout) :: pl WHM massive body object Called by proc~~whm_kick_getacch_ah1~~CalledByGraph proc~whm_kick_getacch_ah1 whm_kick_getacch_ah1 proc~whm_kick_getacch_pl whm_kick_getacch_pl proc~whm_kick_getacch_pl->proc~whm_kick_getacch_ah1 interface~whm_kick_getacch_pl whm_kick_getacch_pl interface~whm_kick_getacch_pl->proc~whm_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_kick_getacch_ah1.html"},{"title":"whm_kick_getacch_ah2 – swiftest","text":"pure subroutine whm_kick_getacch_ah2(cb, pl) Compute second term heliocentric accelerations of planets Adapted from Hal Levison's Swift routine getacch_ah2.f\n Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah2.f90 Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: cb Swiftest central body object class( whm_pl ), intent(inout) :: pl WHM massive body object Called by proc~~whm_kick_getacch_ah2~~CalledByGraph proc~whm_kick_getacch_ah2 whm_kick_getacch_ah2 proc~whm_kick_getacch_pl whm_kick_getacch_pl proc~whm_kick_getacch_pl->proc~whm_kick_getacch_ah2 interface~whm_kick_getacch_pl whm_kick_getacch_pl interface~whm_kick_getacch_pl->proc~whm_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_kick_getacch_ah2.html"},{"title":"solve_wbs – swiftest","text":"function solve_wbs(u) result(x) Uses ieee_exceptions swiftest proc~~solve_wbs~~UsesGraph proc~solve_wbs solve_wbs module~swiftest swiftest proc~solve_wbs->module~swiftest ieee_exceptions ieee_exceptions proc~solve_wbs->ieee_exceptions module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Based on code available on Rosetta Code: https://rosettacode.org/wiki/Gaussian_elimination#Fortran Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:), allocatable :: u Return Value real(kind=QP),\n  dimension(:),allocatable Called by proc~~solve_wbs~~CalledByGraph proc~solve_wbs solve_wbs proc~util_solve_linear_system_q util_solve_linear_system_q proc~util_solve_linear_system_q->proc~solve_wbs proc~util_solve_linear_system_d util_solve_linear_system_d proc~util_solve_linear_system_d->proc~solve_wbs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/solve_wbs.html"},{"title":"ge_wpp – swiftest","text":"function ge_wpp(A, b) result(u) Uses ieee_exceptions swiftest proc~~ge_wpp~~UsesGraph proc~ge_wpp ge_wpp module~swiftest swiftest proc~ge_wpp->module~swiftest ieee_exceptions ieee_exceptions proc~ge_wpp->ieee_exceptions module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Solve  Ax=b  using Gaussian elimination then backwards substitution.\n   A being an n by n matrix.\n   x and b are n by 1 vectors. \n Based on code available on Rosetta Code: https://rosettacode.org/wiki/Gaussian_elimination#Fortran Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A real(kind=QP), intent(in), dimension(:) :: b Return Value real(kind=QP),\n  dimension(:,:),allocatable Called by proc~~ge_wpp~~CalledByGraph proc~ge_wpp ge_wpp proc~util_solve_linear_system_q util_solve_linear_system_q proc~util_solve_linear_system_q->proc~ge_wpp proc~util_solve_linear_system_d util_solve_linear_system_d proc~util_solve_linear_system_d->proc~ge_wpp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ge_wpp.html"},{"title":"util_get_energy_potential – swiftest","text":"subroutine util_get_energy_potential(npl, nplpl, k_plpl, lmask, GMcb, Gmass, mass, xb, pe) Compute total system potential energy Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl integer(kind=I8B), intent(in) :: nplpl integer(kind=I4B), intent(in), dimension(:,:) :: k_plpl logical, intent(in), dimension(:) :: lmask real(kind=DP), intent(in) :: GMcb real(kind=DP), intent(in), dimension(:) :: Gmass real(kind=DP), intent(in), dimension(:) :: mass real(kind=DP), intent(in), dimension(:,:) :: xb real(kind=DP), intent(out) :: pe Called by proc~~util_get_energy_potential~~CalledByGraph proc~util_get_energy_potential util_get_energy_potential proc~util_get_energy_momentum_system util_get_energy_momentum_system proc~util_get_energy_momentum_system->proc~util_get_energy_potential interface~util_get_energy_momentum_system util_get_energy_momentum_system interface~util_get_energy_momentum_system->proc~util_get_energy_momentum_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_get_energy_potential.html"},{"title":"discard_cb_tp – swiftest","text":"subroutine discard_cb_tp(tp, system, param) Check to see if test particles should be discarded based on their positions relative to the Sun\n        or because they are unbound from the system Adapted from David E. Kaufmann's Swifter routine: discard_sun.f90\n Adapted from Hal Levison's Swift routine discard_sun.f Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: tp Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Contents None","tags":"","loc":"proc/discard_cb_tp.html"},{"title":"discard_peri_tp – swiftest","text":"subroutine discard_peri_tp(tp, system, param) Check to see if a test particle should be discarded because its perihelion distance becomes too small Adapted from David E. Kaufmann's Swifter routine: discard_peri.f90\n Adapted from Hal Levison's Swift routine discard_peri.f Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: tp Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameterss Contents None","tags":"","loc":"proc/discard_peri_tp.html"},{"title":"discard_pl_tp – swiftest","text":"subroutine discard_pl_tp(tp, system, param) Check to see if test particles should be discarded based on their positions relative to the massive bodies Adapted from David E. Kaufmann's Swifter routine: discard_pl.f90\n Adapted from Hal Levison's Swift routine discard_pl.f Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: tp Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Contents None","tags":"","loc":"proc/discard_pl_tp.html"},{"title":"discard_pl_close – swiftest","text":"subroutine discard_pl_close(dx, dv, dt, r2crit, iflag, r2min) Check to see if a test particle and massive body are having, or will have within the next time step, an encounter such\n          that the separation distance r is less than some critical radius rcrit (or r 2 < rcrit 2 = r2crit) Adapted from David E. Kaufmann's Swifter routine: discard_pl_close.f90\n Adapted from Hal Levison's Swift routine discard_pl_close.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: dx real(kind=DP), intent(in), dimension(:) :: dv real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r2crit integer(kind=I4B), intent(out) :: iflag real(kind=DP), intent(out) :: r2min Contents None","tags":"","loc":"proc/discard_pl_close.html"},{"title":"io_read_encounter – swiftest","text":"function io_read_encounter(t, id1, id2, Gmass1, Gmass2, radius1, radius2, xh1, xh2, vh1, vh2, enc_out, out_type) result(ierr) Read close encounter data from input binary files\n     Other than time t, there is no direct file input from this function\n     Function returns read error status (0 = OK, nonzero = ERROR)\n Adapted from David E. Kaufmann's Swifter routine: io_read_encounter.f90 Arguments Type Intent Optional Attributes Name real(kind=DP), intent(out) :: t integer(kind=I4B), intent(out) :: id1 integer(kind=I4B), intent(out) :: id2 real(kind=DP), intent(out) :: Gmass1 real(kind=DP), intent(out) :: Gmass2 real(kind=DP), intent(out) :: radius1 real(kind=DP), intent(out) :: radius2 real(kind=DP), intent(out), dimension(:) :: xh1 real(kind=DP), intent(out), dimension(:) :: xh2 real(kind=DP), intent(out), dimension(:) :: vh1 real(kind=DP), intent(out), dimension(:) :: vh2 character(len=*), intent(in) :: enc_out character(len=*), intent(in) :: out_type Return Value integer(kind=I4B) Calls proc~~io_read_encounter~~CallsGraph proc~io_read_encounter io_read_encounter interface~util_exit util_exit proc~io_read_encounter->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_encounter.html"},{"title":"io_read_hdr – swiftest","text":"function io_read_hdr(iu, t, npl, ntp, out_form, out_type) result(ierr) Read frame header from input binary files\n     Function returns read error status (0 = OK, nonzero = ERROR)\n Adapted from David E. Kaufmann's Swifter routine: io_read_hdr.f90\n Adapted from Hal Levison's Swift routine io_read_hdr.f Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu real(kind=DP), intent(out) :: t integer(kind=I4B), intent(out) :: npl integer(kind=I4B), intent(out) :: ntp character(len=*), intent(out) :: out_form character(len=*), intent(in) :: out_type Return Value integer(kind=I4B) Called by proc~~io_read_hdr~~CalledByGraph proc~io_read_hdr io_read_hdr proc~io_read_frame_system io_read_frame_system proc~io_read_frame_system->proc~io_read_hdr interface~io_read_frame_system io_read_frame_system interface~io_read_frame_system->proc~io_read_frame_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_hdr.html"},{"title":"drift_dan – swiftest","text":"pure subroutine drift_dan(mu, x0, v0, dt0, iflag) Perform Kepler drift, solving Kepler's equation in appropriate variables Adapted from David E. Kaufmann's Swifter routine: drift_dan.f90\n Adapted from Hal Levison and Martin Duncan's Swift routine drift_dan.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu real(kind=DP), intent(inout), dimension(:) :: x0 real(kind=DP), intent(inout), dimension(:) :: v0 real(kind=DP), intent(in) :: dt0 integer(kind=I4B), intent(out) :: iflag Calls proc~~drift_dan~~CallsGraph proc~drift_dan drift_dan proc~drift_kepmd drift_kepmd proc~drift_dan->proc~drift_kepmd proc~drift_kepu drift_kepu proc~drift_dan->proc~drift_kepu proc~drift_kepu_fchk drift_kepu_fchk proc~drift_kepu->proc~drift_kepu_fchk proc~drift_kepu_lag drift_kepu_lag proc~drift_kepu->proc~drift_kepu_lag proc~drift_kepu_guess drift_kepu_guess proc~drift_kepu->proc~drift_kepu_guess proc~drift_kepu_new drift_kepu_new proc~drift_kepu->proc~drift_kepu_new proc~drift_kepu_stumpff drift_kepu_stumpff proc~drift_kepu_fchk->proc~drift_kepu_stumpff proc~drift_kepu_lag->proc~drift_kepu_stumpff interface~orbel_scget orbel_scget proc~drift_kepu_guess->interface~orbel_scget proc~drift_kepu_p3solve drift_kepu_p3solve proc~drift_kepu_guess->proc~drift_kepu_p3solve proc~drift_kepu_new->proc~drift_kepu_stumpff proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_dan.html"},{"title":"drift_kepmd – swiftest","text":"pure subroutine drift_kepmd(dm, es, ec, x, s, c) Solve Kepler's equation in difference form for an ellipse for small input dm and eccentricity\n    Original disclaimer: built for speed, does not check how well the original equation is solved\n    Can do that in calling routine by checking how close (x - ec s + es (1.0 - c) - dm) is to zero Adapted from David E. Kaufmann's Swifter routine: drift_kepmd.f90\n Adapted from Martin Duncan's Swift routine drift_kepmd.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dm real(kind=DP), intent(in) :: es real(kind=DP), intent(in) :: ec real(kind=DP), intent(out) :: x real(kind=DP), intent(out) :: s real(kind=DP), intent(out) :: c Called by proc~~drift_kepmd~~CalledByGraph proc~drift_kepmd drift_kepmd proc~drift_dan drift_dan proc~drift_dan->proc~drift_kepmd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_kepmd.html"},{"title":"drift_kepu – swiftest","text":"pure subroutine drift_kepu(dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Solve Kepler's equation in universal variables Adapted from David E. Kaufmann's Swifter routine: drift_kepu.f90\n Adapted from Hal Levison's Swift routine drift_kepu.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: fp real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 integer(kind=I4B), intent(out) :: iflag Calls proc~~drift_kepu~~CallsGraph proc~drift_kepu drift_kepu proc~drift_kepu_fchk drift_kepu_fchk proc~drift_kepu->proc~drift_kepu_fchk proc~drift_kepu_lag drift_kepu_lag proc~drift_kepu->proc~drift_kepu_lag proc~drift_kepu_guess drift_kepu_guess proc~drift_kepu->proc~drift_kepu_guess proc~drift_kepu_new drift_kepu_new proc~drift_kepu->proc~drift_kepu_new proc~drift_kepu_stumpff drift_kepu_stumpff proc~drift_kepu_fchk->proc~drift_kepu_stumpff proc~drift_kepu_lag->proc~drift_kepu_stumpff interface~orbel_scget orbel_scget proc~drift_kepu_guess->interface~orbel_scget proc~drift_kepu_p3solve drift_kepu_p3solve proc~drift_kepu_guess->proc~drift_kepu_p3solve proc~drift_kepu_new->proc~drift_kepu_stumpff proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~drift_kepu~~CalledByGraph proc~drift_kepu drift_kepu proc~drift_dan drift_dan proc~drift_dan->proc~drift_kepu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_kepu.html"},{"title":"drift_kepu_fchk – swiftest","text":"pure subroutine drift_kepu_fchk(dt, r0, mu, alpha, u, s, f) Computes the value of f, the function whose root we are trying to find in universal variables Adapted from David E. Kaufmann's Swifter routine: drift_kepu_fchk.f90\n Adapted from Martin Duncan's Swift routine drift_kepu_fchk.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(in) :: s real(kind=DP), intent(out) :: f Calls proc~~drift_kepu_fchk~~CallsGraph proc~drift_kepu_fchk drift_kepu_fchk proc~drift_kepu_stumpff drift_kepu_stumpff proc~drift_kepu_fchk->proc~drift_kepu_stumpff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~drift_kepu_fchk~~CalledByGraph proc~drift_kepu_fchk drift_kepu_fchk proc~drift_kepu drift_kepu proc~drift_kepu->proc~drift_kepu_fchk proc~drift_dan drift_dan proc~drift_dan->proc~drift_kepu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_kepu_fchk.html"},{"title":"drift_kepu_guess – swiftest","text":"pure subroutine drift_kepu_guess(dt, r0, mu, alpha, u, s) Compute initial guess for solving Kepler's equation using universal variables Adapted from David E. Kaufmann's Swifter routine: drift_kepu_guess.f90\n Adapted from Hal Levison and Martin Duncan's Swift routine drift_kepu_guess.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: s Calls proc~~drift_kepu_guess~~CallsGraph proc~drift_kepu_guess drift_kepu_guess interface~orbel_scget orbel_scget proc~drift_kepu_guess->interface~orbel_scget proc~drift_kepu_p3solve drift_kepu_p3solve proc~drift_kepu_guess->proc~drift_kepu_p3solve proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~drift_kepu_guess~~CalledByGraph proc~drift_kepu_guess drift_kepu_guess proc~drift_kepu drift_kepu proc~drift_kepu->proc~drift_kepu_guess proc~drift_dan drift_dan proc~drift_dan->proc~drift_kepu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_kepu_guess.html"},{"title":"drift_kepu_lag – swiftest","text":"pure subroutine drift_kepu_lag(s, dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Solve Kepler's equation in universal variables using Laguerre's method\n      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 178 - 180. Adapted from David E. Kaufmann's Swifter routine: drift_kepu_lag.f90\n Adapted from Hal Levison's Swift routine drift_kepu_lag.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout) :: s real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: fp real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 integer(kind=I4B), intent(out) :: iflag Calls proc~~drift_kepu_lag~~CallsGraph proc~drift_kepu_lag drift_kepu_lag proc~drift_kepu_stumpff drift_kepu_stumpff proc~drift_kepu_lag->proc~drift_kepu_stumpff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~drift_kepu_lag~~CalledByGraph proc~drift_kepu_lag drift_kepu_lag proc~drift_kepu drift_kepu proc~drift_kepu->proc~drift_kepu_lag proc~drift_dan drift_dan proc~drift_dan->proc~drift_kepu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_kepu_lag.html"},{"title":"drift_kepu_new – swiftest","text":"pure subroutine drift_kepu_new(s, dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Solve Kepler's equation in universal variables using Newton's method\n      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 174 - 175. Adapted from David E. Kaufmann's Swifter routine: drift_kepu_new.f90\n Adapted from Hal Levison's Swift routine drift_kepu_new.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout) :: s real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: fp real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 integer(kind=I4B), intent(out) :: iflag Calls proc~~drift_kepu_new~~CallsGraph proc~drift_kepu_new drift_kepu_new proc~drift_kepu_stumpff drift_kepu_stumpff proc~drift_kepu_new->proc~drift_kepu_stumpff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~drift_kepu_new~~CalledByGraph proc~drift_kepu_new drift_kepu_new proc~drift_kepu drift_kepu proc~drift_kepu->proc~drift_kepu_new proc~drift_dan drift_dan proc~drift_dan->proc~drift_kepu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_kepu_new.html"},{"title":"drift_kepu_p3solve – swiftest","text":"pure subroutine drift_kepu_p3solve(dt, r0, mu, alpha, u, s, iflag) Computes real root of cubic involved in setting initial guess for solving Kepler's equation in universal variables\n      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 177 - 178. Adapted from David E. Kaufmann's Swifter routine: drift_kepu_p3solve.f90\n Adapted from Martin Duncan's Swift routine drift_kepu_p3solve.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: s integer(kind=I4B), intent(out) :: iflag Called by proc~~drift_kepu_p3solve~~CalledByGraph proc~drift_kepu_p3solve drift_kepu_p3solve proc~drift_kepu_guess drift_kepu_guess proc~drift_kepu_guess->proc~drift_kepu_p3solve proc~drift_kepu drift_kepu proc~drift_kepu->proc~drift_kepu_guess proc~drift_dan drift_dan proc~drift_dan->proc~drift_kepu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_kepu_p3solve.html"},{"title":"drift_kepu_stumpff – swiftest","text":"pure subroutine drift_kepu_stumpff(x, c0, c1, c2, c3) Compute Stumpff functions needed for Kepler drift in universal variables\n      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 171 - 172. Adapted from David E. Kaufmann's Swifter routine: drift_kepu_stumpff.f90\n Adapted from Hal Levison's Swift routine drift_kepu_stumpff.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout) :: x real(kind=DP), intent(out) :: c0 real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 Called by proc~~drift_kepu_stumpff~~CalledByGraph proc~drift_kepu_stumpff drift_kepu_stumpff proc~drift_kepu_fchk drift_kepu_fchk proc~drift_kepu_fchk->proc~drift_kepu_stumpff proc~drift_kepu_lag drift_kepu_lag proc~drift_kepu_lag->proc~drift_kepu_stumpff proc~drift_kepu_new drift_kepu_new proc~drift_kepu_new->proc~drift_kepu_stumpff proc~drift_kepu drift_kepu proc~drift_kepu->proc~drift_kepu_fchk proc~drift_kepu->proc~drift_kepu_lag proc~drift_kepu->proc~drift_kepu_new proc~drift_dan drift_dan proc~drift_dan->proc~drift_kepu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_kepu_stumpff.html"},{"title":"symba_collision_check_one – swiftest","text":"pure elemental function symba_collision_check_one(xr, yr, zr, vxr, vyr, vzr, Gmtot, rlim, dt, lvdotr) result(lcollision) Check for a merger between a single pair of particles Adapted from David E. Kaufmann's Swifter routines symba_merge_tp.f90 and symba_merge_pl.f90 Adapted from Hal Levison's Swift routine symba5_merge.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: xr Relative position vector components real(kind=DP), intent(in) :: yr Relative position vector components real(kind=DP), intent(in) :: zr Relative position vector components real(kind=DP), intent(in) :: vxr Relative velocity vector components real(kind=DP), intent(in) :: vyr Relative velocity vector components real(kind=DP), intent(in) :: vzr Relative velocity vector components real(kind=DP), intent(in) :: Gmtot Sum of G*mass of colliding bodies real(kind=DP), intent(in) :: rlim Collision limit - Typically the sum of the radii of colliding bodies real(kind=DP), intent(in) :: dt Step size logical, intent(in) :: lvdotr Logical flag indicating that these two bodies are approaching in the current substep Return Value logical Logical flag indicating whether these two bodies will collide or not Calls proc~~symba_collision_check_one~~CallsGraph proc~symba_collision_check_one symba_collision_check_one orbel_xv2aeq orbel_xv2aeq proc~symba_collision_check_one->orbel_xv2aeq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_collision_check_one~~CalledByGraph proc~symba_collision_check_one symba_collision_check_one proc~symba_collision_check_encounter symba_collision_check_encounter proc~symba_collision_check_encounter->proc~symba_collision_check_one interface~symba_collision_check_encounter symba_collision_check_encounter interface~symba_collision_check_encounter->proc~symba_collision_check_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_collision_check_one.html"},{"title":"symba_collision_consolidate_colliders – swiftest","text":"function symba_collision_consolidate_colliders(pl, cb, param, idx_parent, colliders) result(lflag) Loops through the pl-pl collision list and groups families together by index. Outputs the indices of all colliders%idx members, \n and pairs of quantities (x and v vectors, mass, radius, L_spin, and Ip) that can be used to resolve the collisional outcome. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl SyMBA massive body object class( symba_cb ), intent(inout) :: cb SyMBA central body object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(inout), dimension(2) :: idx_parent Index of the two bodies considered the \"parents\" of the collision class( fraggle_colliders ), intent(out) :: colliders Return Value logical Logical flag indicating whether a colliders%idx was successfully created or not Calls proc~~symba_collision_consolidate_colliders~~CallsGraph proc~symba_collision_consolidate_colliders symba_collision_consolidate_colliders idx_arr idx_arr proc~symba_collision_consolidate_colliders->idx_arr id_arr id_arr proc~symba_collision_consolidate_colliders->id_arr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_collision_consolidate_colliders~~CalledByGraph proc~symba_collision_consolidate_colliders symba_collision_consolidate_colliders proc~symba_collision_resolve_mergers symba_collision_resolve_mergers proc~symba_collision_resolve_mergers->proc~symba_collision_consolidate_colliders proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations proc~symba_collision_resolve_fragmentations->proc~symba_collision_consolidate_colliders interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations interface~symba_collision_resolve_mergers symba_collision_resolve_mergers interface~symba_collision_resolve_mergers->proc~symba_collision_resolve_mergers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_collision_consolidate_colliders.html"},{"title":"symba_collision_collider_message – swiftest","text":"subroutine symba_collision_collider_message(pl, collidx, collider_message) Prints a nicely formatted message about which bodies collided, including their names and ids.\n This subroutine appends the body names and ids to an input message. Arguments Type Intent Optional Attributes Name class(swiftest_pl), intent(in) :: pl Swiftest massive body object integer(kind=I4B), intent(in), dimension(:) :: collidx Index of collisional colliders%idx members character(len=*), intent(inout) :: collider_message The message to print to the screen. Called by proc~~symba_collision_collider_message~~CalledByGraph proc~symba_collision_collider_message symba_collision_collider_message proc~symba_collision_casedisruption symba_collision_casedisruption proc~symba_collision_casedisruption->proc~symba_collision_collider_message proc~symba_collision_casemerge symba_collision_casemerge proc~symba_collision_casemerge->proc~symba_collision_collider_message proc~symba_collision_casehitandrun symba_collision_casehitandrun proc~symba_collision_casehitandrun->proc~symba_collision_collider_message interface~symba_collision_casehitandrun symba_collision_casehitandrun interface~symba_collision_casehitandrun->proc~symba_collision_casehitandrun interface~symba_collision_casedisruption symba_collision_casedisruption interface~symba_collision_casedisruption->proc~symba_collision_casedisruption interface~symba_collision_casemerge symba_collision_casemerge interface~symba_collision_casemerge->proc~symba_collision_casemerge proc~symba_collision_resolve_mergers symba_collision_resolve_mergers proc~symba_collision_resolve_mergers->interface~symba_collision_casemerge proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations proc~symba_collision_resolve_fragmentations->interface~symba_collision_casehitandrun proc~symba_collision_resolve_fragmentations->interface~symba_collision_casedisruption proc~symba_collision_resolve_fragmentations->interface~symba_collision_casemerge interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations interface~symba_collision_resolve_mergers symba_collision_resolve_mergers interface~symba_collision_resolve_mergers->proc~symba_collision_resolve_mergers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_collision_collider_message.html"},{"title":"symba_collision_mergeaddsub – swiftest","text":"subroutine symba_collision_mergeaddsub(system, param, colliders, frag, status) Fills the pl_discards and pl_adds with removed and added bodies Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions class( fraggle_colliders ), intent(inout) :: colliders Fraggle colliders object class( fraggle_fragments ), intent(inout) :: frag Fraggle fragmentation system object integer(kind=I4B), intent(in) :: status Status flag to assign to adds Calls proc~~symba_collision_mergeaddsub~~CallsGraph proc~symba_collision_mergeaddsub symba_collision_mergeaddsub fraggle_io_log_pl fraggle_io_log_pl proc~symba_collision_mergeaddsub->fraggle_io_log_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_collision_mergeaddsub~~CalledByGraph proc~symba_collision_mergeaddsub symba_collision_mergeaddsub proc~symba_collision_casedisruption symba_collision_casedisruption proc~symba_collision_casedisruption->proc~symba_collision_mergeaddsub proc~symba_collision_casemerge symba_collision_casemerge proc~symba_collision_casemerge->proc~symba_collision_mergeaddsub proc~symba_collision_casehitandrun symba_collision_casehitandrun proc~symba_collision_casehitandrun->proc~symba_collision_mergeaddsub interface~symba_collision_casehitandrun symba_collision_casehitandrun interface~symba_collision_casehitandrun->proc~symba_collision_casehitandrun interface~symba_collision_casedisruption symba_collision_casedisruption interface~symba_collision_casedisruption->proc~symba_collision_casedisruption interface~symba_collision_casemerge symba_collision_casemerge interface~symba_collision_casemerge->proc~symba_collision_casemerge proc~symba_collision_resolve_mergers symba_collision_resolve_mergers proc~symba_collision_resolve_mergers->interface~symba_collision_casemerge proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations proc~symba_collision_resolve_fragmentations->interface~symba_collision_casehitandrun proc~symba_collision_resolve_fragmentations->interface~symba_collision_casedisruption proc~symba_collision_resolve_fragmentations->interface~symba_collision_casemerge interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations interface~symba_collision_resolve_mergers symba_collision_resolve_mergers interface~symba_collision_resolve_mergers->proc~symba_collision_resolve_mergers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_collision_mergeaddsub.html"},{"title":"symba_encounter_check_all – swiftest","text":"subroutine symba_encounter_check_all(nplplm, k_plpl, x, v, rhill, dt, irec, lencounter, loc_lvdotr) Check for encounters between massive bodies. Split off from the main subroutine for performance Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: nplplm integer(kind=I4B), intent(in), dimension(:,:) :: k_plpl real(kind=DP), intent(in), dimension(:,:) :: x real(kind=DP), intent(in), dimension(:,:) :: v real(kind=DP), intent(in), dimension(:) :: rhill real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: irec logical, intent(out), dimension(:) :: lencounter logical, intent(out), dimension(:) :: loc_lvdotr Called by proc~~symba_encounter_check_all~~CalledByGraph proc~symba_encounter_check_all symba_encounter_check_all proc~symba_encounter_check_pl symba_encounter_check_pl proc~symba_encounter_check_pl->proc~symba_encounter_check_all interface~symba_encounter_check_pl symba_encounter_check_pl interface~symba_encounter_check_pl->proc~symba_encounter_check_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_encounter_check_all.html"},{"title":"symba_discard_cb_pl – swiftest","text":"subroutine symba_discard_cb_pl(pl, system, param) Check to see if planets should be discarded based on their positions relative to the central body.\n If a body gets flagged here when it has also been previously flagged for a collision with another massive body,\n its collisional status will be revoked. Discards due to colliding with or escaping the central body take precedence \n over pl-pl collisions Adapted from David E. Kaufmann's Swifter routine: symba_discard_sun.f90\n Adapted from Hal Levison's Swift routine discard_massive5.f Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl SyMBA massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~symba_discard_cb_pl~~CallsGraph proc~symba_discard_cb_pl symba_discard_cb_pl fraggle_io_log_one_message fraggle_io_log_one_message proc~symba_discard_cb_pl->fraggle_io_log_one_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_discard_cb_pl~~CalledByGraph proc~symba_discard_cb_pl symba_discard_cb_pl proc~symba_discard_nonplpl symba_discard_nonplpl proc~symba_discard_nonplpl->proc~symba_discard_cb_pl proc~symba_discard_pl symba_discard_pl proc~symba_discard_pl->proc~symba_discard_nonplpl interface~symba_discard_pl symba_discard_pl interface~symba_discard_pl->proc~symba_discard_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_discard_cb_pl.html"},{"title":"symba_discard_conserve_mtm – swiftest","text":"subroutine symba_discard_conserve_mtm(pl, system, param, ipl, lescape_body) Conserves system momentum when a body is lost from the system or collides with central body Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl class( symba_nbody_system ), intent(inout) :: system class( symba_parameters ), intent(inout) :: param integer(kind=I4B), intent(in) :: ipl logical, intent(in) :: lescape_body Contents None","tags":"","loc":"proc/symba_discard_conserve_mtm.html"},{"title":"symba_discard_nonplpl – swiftest","text":"subroutine symba_discard_nonplpl(pl, system, param) Check to see if planets should be discarded based on their positions or because they are unbound Adapted from David E. Kaufmann's Swifter routine: symba_discard_pl.f90\n Adapted from Hal Levison's Swift routine discard_massive5.f Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl SyMBA test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~symba_discard_nonplpl~~CallsGraph proc~symba_discard_nonplpl symba_discard_nonplpl proc~symba_discard_cb_pl symba_discard_cb_pl proc~symba_discard_nonplpl->proc~symba_discard_cb_pl fraggle_io_log_one_message fraggle_io_log_one_message proc~symba_discard_cb_pl->fraggle_io_log_one_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_discard_nonplpl~~CalledByGraph proc~symba_discard_nonplpl symba_discard_nonplpl proc~symba_discard_pl symba_discard_pl proc~symba_discard_pl->proc~symba_discard_nonplpl interface~symba_discard_pl symba_discard_pl interface~symba_discard_pl->proc~symba_discard_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_discard_nonplpl.html"},{"title":"symba_discard_nonplpl_conservation – swiftest","text":"subroutine symba_discard_nonplpl_conservation(pl, system, param) If there are any bodies that are removed due to either colliding with the central body or escaping the systme,\n we need to track the conserved quantities with the system bookkeeping terms. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters Called by proc~~symba_discard_nonplpl_conservation~~CalledByGraph proc~symba_discard_nonplpl_conservation symba_discard_nonplpl_conservation proc~symba_discard_pl symba_discard_pl proc~symba_discard_pl->proc~symba_discard_nonplpl_conservation interface~symba_discard_pl symba_discard_pl interface~symba_discard_pl->proc~symba_discard_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_discard_nonplpl_conservation.html"},{"title":"symba_discard_peri_pl – swiftest","text":"subroutine symba_discard_peri_pl(pl, system, param) Check to see if a test particle should be discarded because its perihelion distance becomes too small Adapted from David E. Kaufmann's Swifter routine: symba_discard_peri_pl.f90\n Adapted from Hal Levison's Swift routine discard_mass_peri.f Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl SyMBA massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Contents None","tags":"","loc":"proc/symba_discard_peri_pl.html"},{"title":"xv2el – swiftest","text":"public pure elemental subroutine xv2el(mu, px, py, pz, vx, vy, vz, a, e, inc, capom, omega, capm) Uses swiftest_classes proc~~xv2el~~UsesGraph proc~xv2el xv2el module~swiftest_classes swiftest_classes proc~xv2el->module~swiftest_classes module~swiftest_globals swiftest_globals module~swiftest_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: mu real(kind=8), intent(in) :: px real(kind=8), intent(in) :: py real(kind=8), intent(in) :: pz real(kind=8), intent(in) :: vx real(kind=8), intent(in) :: vy real(kind=8), intent(in) :: vz real(kind=8), intent(out) :: a real(kind=8), intent(out) :: e real(kind=8), intent(out) :: inc real(kind=8), intent(out) :: capom real(kind=8), intent(out) :: omega real(kind=8), intent(out) :: capm Contents None","tags":"","loc":"proc/xv2el.html"},{"title":"check – swiftest","text":"subroutine check(status) Checks the status of all NetCDF operations to catch errors Arguments Type Intent Optional Attributes Name integer, intent(in) :: status Calls proc~~check~~CallsGraph proc~check check interface~util_exit util_exit proc~check->interface~util_exit nf90_strerror nf90_strerror proc~check->nf90_strerror proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/check.html"},{"title":"rmvs_encounter_check_tp – swiftest","text":"interface Calls interface~~rmvs_encounter_check_tp~~CallsGraph interface~rmvs_encounter_check_tp rmvs_encounter_check_tp proc~rmvs_encounter_check_tp rmvs_encounter_check_tp interface~rmvs_encounter_check_tp->proc~rmvs_encounter_check_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function rmvs_encounter_check_tp(self, system, dt) result(lencounter) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class( rmvs_nbody_system ), intent(inout) :: system RMVS nbody system object real(kind=DP), intent(in) :: dt step size Return Value logical Returns true if there is at least one close encounter","tags":"","loc":"interface/rmvs_encounter_check_tp.html"},{"title":"rmvs_chk_ind – swiftest","text":"interface Calls interface~~rmvs_chk_ind~~CallsGraph interface~rmvs_chk_ind rmvs_chk_ind proc~rmvs_chk_ind rmvs_chk_ind interface~rmvs_chk_ind->proc~rmvs_chk_ind Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine rmvs_chk_ind(xr, yr, zr, vxr, vyr, vzr, dt, r2crit, lencounter, lvdotr) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: xr Relative distance vector components real(kind=DP), intent(in) :: yr Relative distance vector components real(kind=DP), intent(in) :: zr Relative distance vector components real(kind=DP), intent(in) :: vxr Relative velocity vector components real(kind=DP), intent(in) :: vyr Relative velocity vector components real(kind=DP), intent(in) :: vzr Relative velocity vector components real(kind=DP), intent(in) :: dt Step size real(kind=DP), intent(in) :: r2crit Square of the critical encounter distance logical, intent(out) :: lencounter Flag indicating that an encounter has occurred logical, intent(out) :: lvdotr Logical flag indicating the direction of the v .dot. r vector","tags":"","loc":"interface/rmvs_chk_ind.html"},{"title":"rmvs_discard_tp – swiftest","text":"interface Calls interface~~rmvs_discard_tp~~CallsGraph interface~rmvs_discard_tp rmvs_discard_tp proc~rmvs_discard_tp rmvs_discard_tp interface~rmvs_discard_tp->proc~rmvs_discard_tp discard_tp discard_tp proc~rmvs_discard_tp->discard_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_discard_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/rmvs_discard_tp.html"},{"title":"rmvs_io_write_encounter – swiftest","text":"interface Calls interface~~rmvs_io_write_encounter~~CallsGraph interface~rmvs_io_write_encounter rmvs_io_write_encounter proc~rmvs_io_write_encounter rmvs_io_write_encounter interface~rmvs_io_write_encounter->proc~rmvs_io_write_encounter util_exit util_exit proc~rmvs_io_write_encounter->util_exit io_write_frame_encounter io_write_frame_encounter proc~rmvs_io_write_encounter->io_write_frame_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_io_write_encounter(t, id1, id2, Gmass1, Gmass2, radius1, radius2, xh1, xh2, vh1, vh2, enc_out) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: id1 integer(kind=I4B), intent(in) :: id2 real(kind=DP), intent(in) :: Gmass1 real(kind=DP), intent(in) :: Gmass2 real(kind=DP), intent(in) :: radius1 real(kind=DP), intent(in) :: radius2 real(kind=DP), intent(in), dimension(:) :: xh1 real(kind=DP), intent(in), dimension(:) :: xh2 real(kind=DP), intent(in), dimension(:) :: vh1 real(kind=DP), intent(in), dimension(:) :: vh2 character(len=*), intent(in) :: enc_out","tags":"","loc":"interface/rmvs_io_write_encounter.html"},{"title":"rmvs_kick_getacch_tp – swiftest","text":"interface Calls interface~~rmvs_kick_getacch_tp~~CallsGraph interface~rmvs_kick_getacch_tp rmvs_kick_getacch_tp proc~rmvs_kick_getacch_tp rmvs_kick_getacch_tp interface~rmvs_kick_getacch_tp->proc~rmvs_kick_getacch_tp whm_kick_getacch_tp whm_kick_getacch_tp proc~rmvs_kick_getacch_tp->whm_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest central body particle data structuree class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step","tags":"","loc":"interface/rmvs_kick_getacch_tp.html"},{"title":"rmvs_setup_pl – swiftest","text":"interface Calls interface~~rmvs_setup_pl~~CallsGraph interface~rmvs_setup_pl rmvs_setup_pl proc~rmvs_setup_pl rmvs_setup_pl interface~rmvs_setup_pl->proc~rmvs_setup_pl whm_setup_pl whm_setup_pl proc~rmvs_setup_pl->whm_setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/rmvs_setup_pl.html"},{"title":"rmvs_setup_initialize_system – swiftest","text":"interface Calls interface~~rmvs_setup_initialize_system~~CallsGraph interface~rmvs_setup_initialize_system rmvs_setup_initialize_system proc~rmvs_setup_initialize_system rmvs_setup_initialize_system interface~rmvs_setup_initialize_system->proc~rmvs_setup_initialize_system whm_setup_initialize_system whm_setup_initialize_system proc~rmvs_setup_initialize_system->whm_setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_nbody_system ), intent(inout) :: self RMVS system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/rmvs_setup_initialize_system.html"},{"title":"rmvs_setup_tp – swiftest","text":"interface Calls interface~~rmvs_setup_tp~~CallsGraph interface~rmvs_setup_tp rmvs_setup_tp proc~rmvs_setup_tp rmvs_setup_tp interface~rmvs_setup_tp->proc~rmvs_setup_tp setup_tp setup_tp proc~rmvs_setup_tp->setup_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parametere","tags":"","loc":"interface/rmvs_setup_tp.html"},{"title":"rmvs_util_append_pl – swiftest","text":"interface Calls interface~~rmvs_util_append_pl~~CallsGraph interface~rmvs_util_append_pl rmvs_util_append_pl proc~rmvs_util_append_pl rmvs_util_append_pl interface~rmvs_util_append_pl->proc~rmvs_util_append_pl util_exit util_exit proc~rmvs_util_append_pl->util_exit util_append util_append proc~rmvs_util_append_pl->util_append whm_util_append_pl whm_util_append_pl proc~rmvs_util_append_pl->whm_util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/rmvs_util_append_pl.html"},{"title":"rmvs_util_append_tp – swiftest","text":"interface Calls interface~~rmvs_util_append_tp~~CallsGraph interface~rmvs_util_append_tp rmvs_util_append_tp proc~rmvs_util_append_tp rmvs_util_append_tp interface~rmvs_util_append_tp->proc~rmvs_util_append_tp util_exit util_exit proc~rmvs_util_append_tp->util_exit util_append_tp util_append_tp proc~rmvs_util_append_tp->util_append_tp util_append util_append proc~rmvs_util_append_tp->util_append Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/rmvs_util_append_tp.html"},{"title":"rmvs_util_fill_pl – swiftest","text":"interface Calls interface~~rmvs_util_fill_pl~~CallsGraph interface~rmvs_util_fill_pl rmvs_util_fill_pl proc~rmvs_util_fill_pl rmvs_util_fill_pl interface~rmvs_util_fill_pl->proc~rmvs_util_fill_pl util_exit util_exit proc~rmvs_util_fill_pl->util_exit util_fill util_fill proc~rmvs_util_fill_pl->util_fill whm_util_fill_pl whm_util_fill_pl proc~rmvs_util_fill_pl->whm_util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"interface/rmvs_util_fill_pl.html"},{"title":"rmvs_util_fill_tp – swiftest","text":"interface Calls interface~~rmvs_util_fill_tp~~CallsGraph interface~rmvs_util_fill_tp rmvs_util_fill_tp proc~rmvs_util_fill_tp rmvs_util_fill_tp interface~rmvs_util_fill_tp->proc~rmvs_util_fill_tp util_exit util_exit proc~rmvs_util_fill_tp->util_exit util_fill_tp util_fill_tp proc~rmvs_util_fill_tp->util_fill_tp util_fill util_fill proc~rmvs_util_fill_tp->util_fill Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"interface/rmvs_util_fill_tp.html"},{"title":"rmvs_util_resize_pl – swiftest","text":"interface Calls interface~~rmvs_util_resize_pl~~CallsGraph interface~rmvs_util_resize_pl rmvs_util_resize_pl proc~rmvs_util_resize_pl rmvs_util_resize_pl interface~rmvs_util_resize_pl->proc~rmvs_util_resize_pl util_resize util_resize proc~rmvs_util_resize_pl->util_resize whm_util_resize_pl whm_util_resize_pl proc~rmvs_util_resize_pl->whm_util_resize_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in) :: nnew New size neded","tags":"","loc":"interface/rmvs_util_resize_pl.html"},{"title":"rmvs_util_resize_tp – swiftest","text":"interface Calls interface~~rmvs_util_resize_tp~~CallsGraph interface~rmvs_util_resize_tp rmvs_util_resize_tp proc~rmvs_util_resize_tp rmvs_util_resize_tp interface~rmvs_util_resize_tp->proc~rmvs_util_resize_tp util_resize_tp util_resize_tp proc~rmvs_util_resize_tp->util_resize_tp util_resize util_resize proc~rmvs_util_resize_tp->util_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: nnew New size neded","tags":"","loc":"interface/rmvs_util_resize_tp.html"},{"title":"rmvs_util_sort_pl – swiftest","text":"interface Calls interface~~rmvs_util_sort_pl~~CallsGraph interface~rmvs_util_sort_pl rmvs_util_sort_pl proc~rmvs_util_sort_pl rmvs_util_sort_pl interface~rmvs_util_sort_pl->proc~rmvs_util_sort_pl whm_util_sort_pl whm_util_sort_pl proc~rmvs_util_sort_pl->whm_util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order","tags":"","loc":"interface/rmvs_util_sort_pl.html"},{"title":"rmvs_util_sort_tp – swiftest","text":"interface Calls interface~~rmvs_util_sort_tp~~CallsGraph interface~rmvs_util_sort_tp rmvs_util_sort_tp proc~rmvs_util_sort_tp rmvs_util_sort_tp interface~rmvs_util_sort_tp->proc~rmvs_util_sort_tp util_sort_tp util_sort_tp proc~rmvs_util_sort_tp->util_sort_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order","tags":"","loc":"interface/rmvs_util_sort_tp.html"},{"title":"rmvs_util_sort_rearrange_pl – swiftest","text":"interface Calls interface~~rmvs_util_sort_rearrange_pl~~CallsGraph interface~rmvs_util_sort_rearrange_pl rmvs_util_sort_rearrange_pl proc~rmvs_util_sort_rearrange_pl rmvs_util_sort_rearrange_pl interface~rmvs_util_sort_rearrange_pl->proc~rmvs_util_sort_rearrange_pl util_sort_rearrange_pl util_sort_rearrange_pl proc~rmvs_util_sort_rearrange_pl->util_sort_rearrange_pl util_sort_rearrange util_sort_rearrange proc~rmvs_util_sort_rearrange_pl->util_sort_rearrange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order)","tags":"","loc":"interface/rmvs_util_sort_rearrange_pl.html"},{"title":"rmvs_util_sort_rearrange_tp – swiftest","text":"interface Calls interface~~rmvs_util_sort_rearrange_tp~~CallsGraph interface~rmvs_util_sort_rearrange_tp rmvs_util_sort_rearrange_tp proc~rmvs_util_sort_rearrange_tp rmvs_util_sort_rearrange_tp interface~rmvs_util_sort_rearrange_tp->proc~rmvs_util_sort_rearrange_tp util_sort_rearrange util_sort_rearrange proc~rmvs_util_sort_rearrange_tp->util_sort_rearrange util_sort_rearrange_tp util_sort_rearrange_tp proc~rmvs_util_sort_rearrange_tp->util_sort_rearrange_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order)","tags":"","loc":"interface/rmvs_util_sort_rearrange_tp.html"},{"title":"rmvs_util_spill_pl – swiftest","text":"interface Calls interface~~rmvs_util_spill_pl~~CallsGraph interface~rmvs_util_spill_pl rmvs_util_spill_pl proc~rmvs_util_spill_pl rmvs_util_spill_pl interface~rmvs_util_spill_pl->proc~rmvs_util_spill_pl util_exit util_exit proc~rmvs_util_spill_pl->util_exit whm_util_spill_pl whm_util_spill_pl proc~rmvs_util_spill_pl->whm_util_spill_pl util_spill util_spill proc~rmvs_util_spill_pl->util_spill Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"interface/rmvs_util_spill_pl.html"},{"title":"rmvs_util_spill_tp – swiftest","text":"interface Calls interface~~rmvs_util_spill_tp~~CallsGraph interface~rmvs_util_spill_tp rmvs_util_spill_tp proc~rmvs_util_spill_tp rmvs_util_spill_tp interface~rmvs_util_spill_tp->proc~rmvs_util_spill_tp util_exit util_exit proc~rmvs_util_spill_tp->util_exit util_spill util_spill proc~rmvs_util_spill_tp->util_spill util_spill_tp util_spill_tp proc~rmvs_util_spill_tp->util_spill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"interface/rmvs_util_spill_tp.html"},{"title":"rmvs_step_system – swiftest","text":"interface Calls interface~~rmvs_step_system~~CallsGraph interface~rmvs_step_system rmvs_step_system proc~rmvs_step_system rmvs_step_system interface~rmvs_step_system->proc~rmvs_step_system proc~rmvs_step_out rmvs_step_out proc~rmvs_step_system->proc~rmvs_step_out whm_step_system whm_step_system proc~rmvs_step_system->whm_step_system proc~rmvs_interp_out rmvs_interp_out proc~rmvs_step_system->proc~rmvs_interp_out proc~rmvs_interp_in rmvs_interp_in proc~rmvs_step_out->proc~rmvs_interp_in proc~rmvs_step_in rmvs_step_in proc~rmvs_step_out->proc~rmvs_step_in util_exit util_exit proc~rmvs_interp_out->util_exit proc~rmvs_interp_in->util_exit proc~rmvs_make_planetocentric rmvs_make_planetocentric proc~rmvs_step_in->proc~rmvs_make_planetocentric proc~rmvs_peri_tp rmvs_peri_tp proc~rmvs_step_in->proc~rmvs_peri_tp proc~rmvs_end_planetocentric rmvs_end_planetocentric proc~rmvs_step_in->proc~rmvs_end_planetocentric vpc vpc proc~rmvs_peri_tp->vpc xpc xpc proc~rmvs_peri_tp->xpc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine rmvs_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_nbody_system ), intent(inout) :: self RMVS nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"interface/rmvs_step_system.html"},{"title":"walltime_finish – swiftest","text":"public subroutine walltime_finish(self, nsubsteps, message) Uses swiftest_globals proc~~walltime_finish~~UsesGraph proc~walltime_finish walltime_finish module~swiftest_globals swiftest_globals proc~walltime_finish->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Ends the timer, setting step_finish to the current ticker value and printing the elapsed time information to the terminal Arguments Type Intent Optional Attributes Name class( walltimer ), intent(inout) :: self Walltimer object integer(kind=I4B), intent(in) :: nsubsteps Number of substeps used to compute the time per step character(len=*), intent(in) :: message Message to prepend to the wall time terminal output Contents None","tags":"","loc":"proc/walltime_finish.html"},{"title":"walltime_reset – swiftest","text":"public subroutine walltime_reset(self) Uses swiftest_globals proc~~walltime_reset~~UsesGraph proc~walltime_reset walltime_reset module~swiftest_globals swiftest_globals proc~walltime_reset->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Resets the clock ticker, settting main_start to the current ticker value Arguments Type Intent Optional Attributes Name class( walltimer ), intent(inout) :: self Contents None","tags":"","loc":"proc/walltime_reset.html"},{"title":"walltime_start – swiftest","text":"public subroutine walltime_start(self) Uses swiftest_globals proc~~walltime_start~~UsesGraph proc~walltime_start walltime_start module~swiftest_globals swiftest_globals proc~walltime_start->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Starts the timer, setting step_start to the current ticker value Arguments Type Intent Optional Attributes Name class( walltimer ), intent(inout) :: self Contents None","tags":"","loc":"proc/walltime_start.html"},{"title":"walltime_finish – swiftest","text":"interface public subroutine walltime_finish(self, nsubsteps, message) Arguments Type Intent Optional Attributes Name class( walltimer ), intent(inout) :: self Walltimer object integer(kind=I4B), intent(in) :: nsubsteps Number of substeps used to compute the time per step character(len=*), intent(in) :: message Message to prepend to the wall time terminal output","tags":"","loc":"interface/walltime_finish.html"},{"title":"walltime_reset – swiftest","text":"interface public subroutine walltime_reset(self) Arguments Type Intent Optional Attributes Name class( walltimer ), intent(inout) :: self Walltimer object","tags":"","loc":"interface/walltime_reset.html"},{"title":"walltime_start – swiftest","text":"interface public subroutine walltime_start(self) Arguments Type Intent Optional Attributes Name class( walltimer ), intent(inout) :: self Walltimer object","tags":"","loc":"interface/walltime_start.html"},{"title":"operator(.cross.) – swiftest","text":"public interface operator(.cross.) Contents Functions operator_cross_sp operator_cross_dp operator_cross_qp operator_cross_i1b operator_cross_i2b operator_cross_i4b operator_cross_i8b operator_cross_el_sp operator_cross_el_dp operator_cross_el_qp operator_cross_el_i1b operator_cross_el_i2b operator_cross_el_i4b operator_cross_el_i8b Functions public pure function operator_cross_sp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: A real(kind=SP), intent(in), dimension(:) :: B Return Value real(kind=SP),\n  dimension(3) public pure function operator_cross_dp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: A real(kind=DP), intent(in), dimension(:) :: B Return Value real(kind=DP),\n  dimension(3) public pure function operator_cross_qp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:) :: A real(kind=QP), intent(in), dimension(:) :: B Return Value real(kind=QP),\n  dimension(3) public pure function operator_cross_i1b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in), dimension(:) :: A integer(kind=I1B), intent(in), dimension(:) :: B Return Value integer(kind=I1B),\n  dimension(3) public pure function operator_cross_i2b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in), dimension(:) :: A integer(kind=I2B), intent(in), dimension(:) :: B Return Value integer(kind=I2B),\n  dimension(3) public pure function operator_cross_i4b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:) :: A integer(kind=I4B), intent(in), dimension(:) :: B Return Value integer(kind=I4B),\n  dimension(3) public pure function operator_cross_i8b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in), dimension(:) :: A integer(kind=I8B), intent(in), dimension(:) :: B Return Value integer(kind=I8B),\n  dimension(3) public pure function operator_cross_el_sp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:,:) :: A real(kind=SP), intent(in), dimension(:,:) :: B Return Value real(kind=SP),\n  dimension(:,:), allocatable public pure function operator_cross_el_dp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A real(kind=DP), intent(in), dimension(:,:) :: B Return Value real(kind=DP),\n  dimension(:,:), allocatable public pure function operator_cross_el_qp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A real(kind=QP), intent(in), dimension(:,:) :: B Return Value real(kind=QP),\n  dimension(:,:), allocatable public pure function operator_cross_el_i1b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in), dimension(:,:) :: A integer(kind=I1B), intent(in), dimension(:,:) :: B Return Value integer(kind=I1B),\n  dimension(:,:), allocatable public pure function operator_cross_el_i2b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in), dimension(:,:) :: A integer(kind=I2B), intent(in), dimension(:,:) :: B Return Value integer(kind=I2B),\n  dimension(:,:), allocatable public pure function operator_cross_el_i4b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:,:) :: A integer(kind=I4B), intent(in), dimension(:,:) :: B Return Value integer(kind=I4B),\n  dimension(:,:), allocatable public pure function operator_cross_el_i8b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in), dimension(:,:) :: A integer(kind=I8B), intent(in), dimension(:,:) :: B Return Value integer(kind=I8B),\n  dimension(:,:), allocatable","tags":"","loc":"interface/operator(.cross.).html"},{"title":"operator(.mag.) – swiftest","text":"public interface operator(.mag.) Contents Functions operator_mag_sp operator_mag_dp operator_mag_qp operator_mag_el_sp operator_mag_el_dp operator_mag_el_qp Functions public pure function operator_mag_sp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: A Return Value real(kind=SP) public pure function operator_mag_dp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: A Return Value real(kind=DP) public pure function operator_mag_qp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:) :: A Return Value real(kind=QP) public pure function operator_mag_el_sp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:,:) :: A Return Value real(kind=SP),\n  dimension(:), allocatable public pure function operator_mag_el_dp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A Return Value real(kind=DP),\n  dimension(:), allocatable public pure function operator_mag_el_qp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A Return Value real(kind=QP),\n  dimension(:), allocatable","tags":"","loc":"interface/operator(.mag.).html"},{"title":"helio_drift_body – swiftest","text":"interface Calls interface~~helio_drift_body~~CallsGraph interface~helio_drift_body helio_drift_body proc~helio_drift_body helio_drift_body interface~helio_drift_body->proc~helio_drift_body drift_all drift_all proc~helio_drift_body->drift_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~helio_drift_body~~CalledByGraph interface~helio_drift_body helio_drift_body proc~helio_drift_pl helio_drift_pl proc~helio_drift_pl->interface~helio_drift_body proc~helio_drift_tp helio_drift_tp proc~helio_drift_tp->interface~helio_drift_body interface~helio_drift_pl helio_drift_pl interface~helio_drift_pl->proc~helio_drift_pl interface~helio_drift_tp helio_drift_tp interface~helio_drift_tp->proc~helio_drift_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_drift_body(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class(swiftest_body), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"interface/helio_drift_body.html"},{"title":"helio_drift_pl – swiftest","text":"interface Calls interface~~helio_drift_pl~~CallsGraph interface~helio_drift_pl helio_drift_pl proc~helio_drift_pl helio_drift_pl interface~helio_drift_pl->proc~helio_drift_pl interface~helio_drift_body helio_drift_body proc~helio_drift_pl->interface~helio_drift_body proc~helio_drift_body helio_drift_body interface~helio_drift_body->proc~helio_drift_body drift_all drift_all proc~helio_drift_body->drift_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"interface/helio_drift_pl.html"},{"title":"helio_drift_tp – swiftest","text":"interface Calls interface~~helio_drift_tp~~CallsGraph interface~helio_drift_tp helio_drift_tp proc~helio_drift_tp helio_drift_tp interface~helio_drift_tp->proc~helio_drift_tp interface~helio_drift_body helio_drift_body proc~helio_drift_tp->interface~helio_drift_body proc~helio_drift_body helio_drift_body interface~helio_drift_body->proc~helio_drift_body drift_all drift_all proc~helio_drift_body->drift_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_drift_tp(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"interface/helio_drift_tp.html"},{"title":"helio_drift_linear_pl – swiftest","text":"interface Calls interface~~helio_drift_linear_pl~~CallsGraph interface~helio_drift_linear_pl helio_drift_linear_pl proc~helio_drift_linear_pl helio_drift_linear_pl interface~helio_drift_linear_pl->proc~helio_drift_linear_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_drift_linear_pl(self, cb, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( helio_cb ), intent(inout) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step","tags":"","loc":"interface/helio_drift_linear_pl.html"},{"title":"helio_drift_linear_tp – swiftest","text":"interface Calls interface~~helio_drift_linear_tp~~CallsGraph interface~helio_drift_linear_tp helio_drift_linear_tp proc~helio_drift_linear_tp helio_drift_linear_tp interface~helio_drift_linear_tp->proc~helio_drift_linear_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_drift_linear_tp(self, cb, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( helio_cb ), intent(in) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step","tags":"","loc":"interface/helio_drift_linear_tp.html"},{"title":"helio_gr_kick_getacch_pl – swiftest","text":"interface Calls interface~~helio_gr_kick_getacch_pl~~CallsGraph interface~helio_gr_kick_getacch_pl helio_gr_kick_getacch_pl proc~helio_gr_kick_getacch_pl helio_gr_kick_getacch_pl interface~helio_gr_kick_getacch_pl->proc~helio_gr_kick_getacch_pl gr_kick_getacch gr_kick_getacch proc~helio_gr_kick_getacch_pl->gr_kick_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine helio_gr_kick_getacch_pl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/helio_gr_kick_getacch_pl.html"},{"title":"helio_gr_kick_getacch_tp – swiftest","text":"interface Calls interface~~helio_gr_kick_getacch_tp~~CallsGraph interface~helio_gr_kick_getacch_tp helio_gr_kick_getacch_tp proc~helio_gr_kick_getacch_tp helio_gr_kick_getacch_tp interface~helio_gr_kick_getacch_tp->proc~helio_gr_kick_getacch_tp gr_kick_getacch gr_kick_getacch proc~helio_gr_kick_getacch_tp->gr_kick_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine helio_gr_kick_getacch_tp(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/helio_gr_kick_getacch_tp.html"},{"title":"helio_gr_p4_pl – swiftest","text":"interface Calls interface~~helio_gr_p4_pl~~CallsGraph interface~helio_gr_p4_pl helio_gr_p4_pl proc~helio_gr_p4_pl helio_gr_p4_pl interface~helio_gr_p4_pl->proc~helio_gr_p4_pl gr_p4_pos_kick gr_p4_pos_kick proc~helio_gr_p4_pl->gr_p4_pos_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine helio_gr_p4_pl(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size","tags":"","loc":"interface/helio_gr_p4_pl.html"},{"title":"helio_gr_p4_tp – swiftest","text":"interface Calls interface~~helio_gr_p4_tp~~CallsGraph interface~helio_gr_p4_tp helio_gr_p4_tp proc~helio_gr_p4_tp helio_gr_p4_tp interface~helio_gr_p4_tp->proc~helio_gr_p4_tp gr_p4_pos_kick gr_p4_pos_kick proc~helio_gr_p4_tp->gr_p4_pos_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine helio_gr_p4_tp(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size","tags":"","loc":"interface/helio_gr_p4_tp.html"},{"title":"helio_kick_getacch_pl – swiftest","text":"interface Calls interface~~helio_kick_getacch_pl~~CallsGraph interface~helio_kick_getacch_pl helio_kick_getacch_pl proc~helio_kick_getacch_pl helio_kick_getacch_pl interface~helio_kick_getacch_pl->proc~helio_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step","tags":"","loc":"interface/helio_kick_getacch_pl.html"},{"title":"helio_kick_getacch_tp – swiftest","text":"interface Calls interface~~helio_kick_getacch_tp~~CallsGraph interface~helio_kick_getacch_tp helio_kick_getacch_tp proc~helio_kick_getacch_tp helio_kick_getacch_tp interface~helio_kick_getacch_tp->proc~helio_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step","tags":"","loc":"interface/helio_kick_getacch_tp.html"},{"title":"helio_kick_vb_pl – swiftest","text":"interface Calls interface~~helio_kick_vb_pl~~CallsGraph interface~helio_kick_vb_pl helio_kick_vb_pl proc~helio_kick_vb_pl helio_kick_vb_pl interface~helio_kick_vb_pl->proc~helio_kick_vb_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_kick_vb_pl(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not.","tags":"","loc":"interface/helio_kick_vb_pl.html"},{"title":"helio_kick_vb_tp – swiftest","text":"interface Calls interface~~helio_kick_vb_tp~~CallsGraph interface~helio_kick_vb_tp helio_kick_vb_tp proc~helio_kick_vb_tp helio_kick_vb_tp interface~helio_kick_vb_tp->proc~helio_kick_vb_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_kick_vb_tp(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not.","tags":"","loc":"interface/helio_kick_vb_tp.html"},{"title":"helio_setup_initialize_system – swiftest","text":"interface Calls interface~~helio_setup_initialize_system~~CallsGraph interface~helio_setup_initialize_system helio_setup_initialize_system proc~helio_setup_initialize_system helio_setup_initialize_system interface~helio_setup_initialize_system->proc~helio_setup_initialize_system whm_setup_initialize_system whm_setup_initialize_system proc~helio_setup_initialize_system->whm_setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( helio_nbody_system ), intent(inout) :: self Helio nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/helio_setup_initialize_system.html"},{"title":"helio_step_pl – swiftest","text":"interface Calls interface~~helio_step_pl~~CallsGraph interface~helio_step_pl helio_step_pl proc~helio_step_pl helio_step_pl interface~helio_step_pl->proc~helio_step_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_step_pl(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nboody system class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"interface/helio_step_pl.html"},{"title":"helio_step_system – swiftest","text":"interface Calls interface~~helio_step_system~~CallsGraph interface~helio_step_system helio_step_system proc~helio_step_system helio_step_system interface~helio_step_system->proc~helio_step_system whm_step_system whm_step_system proc~helio_step_system->whm_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_nbody_system ), intent(inout) :: self Helio nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"interface/helio_step_system.html"},{"title":"helio_step_tp – swiftest","text":"interface Calls interface~~helio_step_tp~~CallsGraph interface~helio_step_tp helio_step_tp proc~helio_step_tp helio_step_tp interface~helio_step_tp->proc~helio_step_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine helio_step_tp(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsizee","tags":"","loc":"interface/helio_step_tp.html"},{"title":"whm_coord_h2j_pl – swiftest","text":"interface Calls interface~~whm_coord_h2j_pl~~CallsGraph interface~whm_coord_h2j_pl whm_coord_h2j_pl proc~whm_coord_h2j_pl whm_coord_h2j_pl interface~whm_coord_h2j_pl->proc~whm_coord_h2j_pl vh vh proc~whm_coord_h2j_pl->vh xj xj proc~whm_coord_h2j_pl->xj eta eta proc~whm_coord_h2j_pl->eta xh xh proc~whm_coord_h2j_pl->xh vj vj proc~whm_coord_h2j_pl->vj gmpl gmpl proc~whm_coord_h2j_pl->gmpl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_coord_h2j_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree","tags":"","loc":"interface/whm_coord_h2j_pl.html"},{"title":"whm_coord_j2h_pl – swiftest","text":"interface Calls interface~~whm_coord_j2h_pl~~CallsGraph interface~whm_coord_j2h_pl whm_coord_j2h_pl proc~whm_coord_j2h_pl whm_coord_j2h_pl interface~whm_coord_j2h_pl->proc~whm_coord_j2h_pl vh vh proc~whm_coord_j2h_pl->vh xj xj proc~whm_coord_j2h_pl->xj eta eta proc~whm_coord_j2h_pl->eta xh xh proc~whm_coord_j2h_pl->xh vj vj proc~whm_coord_j2h_pl->vj gmpl gmpl proc~whm_coord_j2h_pl->gmpl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_coord_j2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree","tags":"","loc":"interface/whm_coord_j2h_pl.html"},{"title":"whm_coord_vh2vj_pl – swiftest","text":"interface Calls interface~~whm_coord_vh2vj_pl~~CallsGraph interface~whm_coord_vh2vj_pl whm_coord_vh2vj_pl proc~whm_coord_vh2vj_pl whm_coord_vh2vj_pl interface~whm_coord_vh2vj_pl->proc~whm_coord_vh2vj_pl vj vj proc~whm_coord_vh2vj_pl->vj vh vh proc~whm_coord_vh2vj_pl->vh gmpl gmpl proc~whm_coord_vh2vj_pl->gmpl eta eta proc~whm_coord_vh2vj_pl->eta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_coord_vh2vj_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree","tags":"","loc":"interface/whm_coord_vh2vj_pl.html"},{"title":"whm_drift_pl – swiftest","text":"interface Calls interface~~whm_drift_pl~~CallsGraph interface~whm_drift_pl whm_drift_pl proc~whm_drift_pl whm_drift_pl interface~whm_drift_pl->proc~whm_drift_pl util_exit util_exit proc~whm_drift_pl->util_exit drift_all drift_all proc~whm_drift_pl->drift_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"interface/whm_drift_pl.html"},{"title":"whm_util_index_eucl_plpl – swiftest","text":"interface public subroutine whm_util_index_eucl_plpl(self, param) Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_parameters), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/whm_util_index_eucl_plpl.html"},{"title":"whm_kick_getacch_pl – swiftest","text":"interface Calls interface~~whm_kick_getacch_pl~~CallsGraph interface~whm_kick_getacch_pl whm_kick_getacch_pl proc~whm_kick_getacch_pl whm_kick_getacch_pl interface~whm_kick_getacch_pl->proc~whm_kick_getacch_pl proc~whm_kick_getacch_ah0 whm_kick_getacch_ah0 proc~whm_kick_getacch_pl->proc~whm_kick_getacch_ah0 proc~whm_kick_getacch_ah1 whm_kick_getacch_ah1 proc~whm_kick_getacch_pl->proc~whm_kick_getacch_ah1 proc~whm_kick_getacch_ah2 whm_kick_getacch_ah2 proc~whm_kick_getacch_pl->proc~whm_kick_getacch_ah2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step Description Get heliocentric accelration of massive bodies","tags":"","loc":"interface/whm_kick_getacch_pl.html"},{"title":"whm_kick_getacch_tp – swiftest","text":"interface Calls interface~~whm_kick_getacch_tp~~CallsGraph interface~whm_kick_getacch_tp whm_kick_getacch_tp proc~whm_kick_getacch_tp whm_kick_getacch_tp interface~whm_kick_getacch_tp->proc~whm_kick_getacch_tp proc~whm_kick_getacch_ah0 whm_kick_getacch_ah0 proc~whm_kick_getacch_tp->proc~whm_kick_getacch_ah0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step Description Get heliocentric accelration of the test particle","tags":"","loc":"interface/whm_kick_getacch_tp.html"},{"title":"whm_kick_vh_pl – swiftest","text":"interface Calls interface~~whm_kick_vh_pl~~CallsGraph interface~whm_kick_vh_pl whm_kick_vh_pl proc~whm_kick_vh_pl whm_kick_vh_pl interface~whm_kick_vh_pl->proc~whm_kick_vh_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_kick_vh_pl(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not.","tags":"","loc":"interface/whm_kick_vh_pl.html"},{"title":"whm_kick_vh_tp – swiftest","text":"interface Calls interface~~whm_kick_vh_tp~~CallsGraph interface~whm_kick_vh_tp whm_kick_vh_tp proc~whm_kick_vh_tp whm_kick_vh_tp interface~whm_kick_vh_tp->proc~whm_kick_vh_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_kick_vh_tp(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not.","tags":"","loc":"interface/whm_kick_vh_tp.html"},{"title":"whm_gr_kick_getacch_pl – swiftest","text":"interface Calls interface~~whm_gr_kick_getacch_pl~~CallsGraph interface~whm_gr_kick_getacch_pl whm_gr_kick_getacch_pl proc~whm_gr_kick_getacch_pl whm_gr_kick_getacch_pl interface~whm_gr_kick_getacch_pl->proc~whm_gr_kick_getacch_pl gr_kick_getacch gr_kick_getacch proc~whm_gr_kick_getacch_pl->gr_kick_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine whm_gr_kick_getacch_pl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/whm_gr_kick_getacch_pl.html"},{"title":"whm_gr_kick_getacch_tp – swiftest","text":"interface Calls interface~~whm_gr_kick_getacch_tp~~CallsGraph interface~whm_gr_kick_getacch_tp whm_gr_kick_getacch_tp proc~whm_gr_kick_getacch_tp whm_gr_kick_getacch_tp interface~whm_gr_kick_getacch_tp->proc~whm_gr_kick_getacch_tp gr_kick_getacch gr_kick_getacch proc~whm_gr_kick_getacch_tp->gr_kick_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine whm_gr_kick_getacch_tp(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/whm_gr_kick_getacch_tp.html"},{"title":"whm_gr_p4_pl – swiftest","text":"interface Calls interface~~whm_gr_p4_pl~~CallsGraph interface~whm_gr_p4_pl whm_gr_p4_pl proc~whm_gr_p4_pl whm_gr_p4_pl interface~whm_gr_p4_pl->proc~whm_gr_p4_pl gr_p4_pos_kick gr_p4_pos_kick proc~whm_gr_p4_pl->gr_p4_pos_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine whm_gr_p4_pl(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size","tags":"","loc":"interface/whm_gr_p4_pl.html"},{"title":"whm_gr_p4_tp – swiftest","text":"interface Calls interface~~whm_gr_p4_tp~~CallsGraph interface~whm_gr_p4_tp whm_gr_p4_tp proc~whm_gr_p4_tp whm_gr_p4_tp interface~whm_gr_p4_tp->proc~whm_gr_p4_tp gr_p4_pos_kick gr_p4_pos_kick proc~whm_gr_p4_tp->gr_p4_pos_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine whm_gr_p4_tp(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size","tags":"","loc":"interface/whm_gr_p4_tp.html"},{"title":"whm_setup_pl – swiftest","text":"interface Calls interface~~whm_setup_pl~~CallsGraph interface~whm_setup_pl whm_setup_pl proc~whm_setup_pl whm_setup_pl interface~whm_setup_pl->proc~whm_setup_pl setup_pl setup_pl proc~whm_setup_pl->setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body objectobject integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameters Description Reads WHM massive body object in from file","tags":"","loc":"interface/whm_setup_pl.html"},{"title":"whm_setup_initialize_system – swiftest","text":"interface Calls interface~~whm_setup_initialize_system~~CallsGraph interface~whm_setup_initialize_system whm_setup_initialize_system proc~whm_setup_initialize_system whm_setup_initialize_system interface~whm_setup_initialize_system->proc~whm_setup_initialize_system util_set_ir3h util_set_ir3h proc~whm_setup_initialize_system->util_set_ir3h setup_initialize_system setup_initialize_system proc~whm_setup_initialize_system->setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_nbody_system ), intent(inout) :: self WHM nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/whm_setup_initialize_system.html"},{"title":"whm_step_pl – swiftest","text":"interface Calls interface~~whm_step_pl~~CallsGraph interface~whm_step_pl whm_step_pl proc~whm_step_pl whm_step_pl interface~whm_step_pl->proc~whm_step_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_step_pl(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"interface/whm_step_pl.html"},{"title":"whm_step_system – swiftest","text":"interface Calls interface~~whm_step_system~~CallsGraph interface~whm_step_system whm_step_system proc~whm_step_system whm_step_system interface~whm_step_system->proc~whm_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_nbody_system ), intent(inout) :: self WHM system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"interface/whm_step_system.html"},{"title":"whm_step_tp – swiftest","text":"interface Calls interface~~whm_step_tp~~CallsGraph interface~whm_step_tp whm_step_tp proc~whm_step_tp whm_step_tp interface~whm_step_tp->proc~whm_step_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_step_tp(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"interface/whm_step_tp.html"},{"title":"whm_util_append_pl – swiftest","text":"interface Calls interface~~whm_util_append_pl~~CallsGraph interface~whm_util_append_pl whm_util_append_pl proc~whm_util_append_pl whm_util_append_pl interface~whm_util_append_pl->proc~whm_util_append_pl util_exit util_exit proc~whm_util_append_pl->util_exit util_append_pl util_append_pl proc~whm_util_append_pl->util_append_pl util_append util_append proc~whm_util_append_pl->util_append Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/whm_util_append_pl.html"},{"title":"whm_util_spill_pl – swiftest","text":"interface Calls interface~~whm_util_spill_pl~~CallsGraph interface~whm_util_spill_pl whm_util_spill_pl proc~whm_util_spill_pl whm_util_spill_pl interface~whm_util_spill_pl->proc~whm_util_spill_pl util_exit util_exit proc~whm_util_spill_pl->util_exit util_spill util_spill proc~whm_util_spill_pl->util_spill util_spill_pl util_spill_pl proc~whm_util_spill_pl->util_spill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"interface/whm_util_spill_pl.html"},{"title":"whm_util_fill_pl – swiftest","text":"interface Calls interface~~whm_util_fill_pl~~CallsGraph interface~whm_util_fill_pl whm_util_fill_pl proc~whm_util_fill_pl whm_util_fill_pl interface~whm_util_fill_pl->proc~whm_util_fill_pl util_exit util_exit proc~whm_util_fill_pl->util_exit util_fill util_fill proc~whm_util_fill_pl->util_fill util_fill_pl util_fill_pl proc~whm_util_fill_pl->util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(in) :: inserts inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"interface/whm_util_fill_pl.html"},{"title":"whm_util_resize_pl – swiftest","text":"interface Calls interface~~whm_util_resize_pl~~CallsGraph interface~whm_util_resize_pl whm_util_resize_pl proc~whm_util_resize_pl whm_util_resize_pl interface~whm_util_resize_pl->proc~whm_util_resize_pl util_resize_pl util_resize_pl proc~whm_util_resize_pl->util_resize_pl util_resize util_resize proc~whm_util_resize_pl->util_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object integer(kind=I4B), intent(in) :: nnew New size neded","tags":"","loc":"interface/whm_util_resize_pl.html"},{"title":"whm_util_set_ir3j – swiftest","text":"interface Calls interface~~whm_util_set_ir3j~~CallsGraph interface~whm_util_set_ir3j whm_util_set_ir3j proc~whm_util_set_ir3j whm_util_set_ir3j interface~whm_util_set_ir3j->proc~whm_util_set_ir3j Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_util_set_ir3j(self) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object","tags":"","loc":"interface/whm_util_set_ir3j.html"},{"title":"whm_util_set_mu_eta_pl – swiftest","text":"interface Calls interface~~whm_util_set_mu_eta_pl~~CallsGraph interface~whm_util_set_mu_eta_pl whm_util_set_mu_eta_pl proc~whm_util_set_mu_eta_pl whm_util_set_mu_eta_pl interface~whm_util_set_mu_eta_pl->proc~whm_util_set_mu_eta_pl util_set_mu_pl util_set_mu_pl proc~whm_util_set_mu_eta_pl->util_set_mu_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_util_set_mu_eta_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/whm_util_set_mu_eta_pl.html"},{"title":"whm_util_sort_pl – swiftest","text":"interface Calls interface~~whm_util_sort_pl~~CallsGraph interface~whm_util_sort_pl whm_util_sort_pl proc~whm_util_sort_pl whm_util_sort_pl interface~whm_util_sort_pl->proc~whm_util_sort_pl util_sort_pl util_sort_pl proc~whm_util_sort_pl->util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order","tags":"","loc":"interface/whm_util_sort_pl.html"},{"title":"whm_util_sort_rearrange_pl – swiftest","text":"interface Calls interface~~whm_util_sort_rearrange_pl~~CallsGraph interface~whm_util_sort_rearrange_pl whm_util_sort_rearrange_pl proc~whm_util_sort_rearrange_pl whm_util_sort_rearrange_pl interface~whm_util_sort_rearrange_pl->proc~whm_util_sort_rearrange_pl util_sort_rearrange_pl util_sort_rearrange_pl proc~whm_util_sort_rearrange_pl->util_sort_rearrange_pl util_sort_rearrange util_sort_rearrange proc~whm_util_sort_rearrange_pl->util_sort_rearrange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine whm_util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order)","tags":"","loc":"interface/whm_util_sort_rearrange_pl.html"},{"title":"fraggle_util_vmag_to_vb – swiftest","text":"interface Calls interface~~fraggle_util_vmag_to_vb~~CallsGraph interface~fraggle_util_vmag_to_vb fraggle_util_vmag_to_vb proc~fraggle_util_vmag_to_vb fraggle_util_vmag_to_vb interface~fraggle_util_vmag_to_vb->proc~fraggle_util_vmag_to_vb interface~fraggle_util_shift_vector_to_origin fraggle_util_shift_vector_to_origin proc~fraggle_util_vmag_to_vb->interface~fraggle_util_shift_vector_to_origin proc~fraggle_util_shift_vector_to_origin fraggle_util_shift_vector_to_origin interface~fraggle_util_shift_vector_to_origin->proc~fraggle_util_shift_vector_to_origin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~fraggle_util_vmag_to_vb~~CalledByGraph interface~fraggle_util_vmag_to_vb fraggle_util_vmag_to_vb proc~fraggle_generate_tan_vel fraggle_generate_tan_vel proc~fraggle_generate_tan_vel->interface~fraggle_util_vmag_to_vb proc~fraggle_generate_rad_vel fraggle_generate_rad_vel proc~fraggle_generate_rad_vel->interface~fraggle_util_vmag_to_vb proc~fraggle_generate_fragments fraggle_generate_fragments proc~fraggle_generate_fragments->proc~fraggle_generate_tan_vel proc~fraggle_generate_fragments->proc~fraggle_generate_rad_vel interface~fraggle_generate_fragments fraggle_generate_fragments interface~fraggle_generate_fragments->proc~fraggle_generate_fragments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function fraggle_util_vmag_to_vb(v_r_mag, v_r_unit, v_t_mag, v_t_unit, m_frag, vcom) result(vb) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: v_r_mag Unknown radial component of fragment velocity vector real(kind=DP), intent(in), dimension(:,:) :: v_r_unit Radial and tangential unit vectors for each fragment real(kind=DP), intent(in), dimension(:) :: v_t_mag Tangential component of velocity vector set previously by angular momentum constraint real(kind=DP), intent(in), dimension(:,:) :: v_t_unit Radial and tangential unit vectors for each fragment real(kind=DP), intent(in), dimension(:) :: m_frag Fragment masses real(kind=DP), intent(in), dimension(:) :: vcom Barycentric velocity of collisional system center of mass Return Value real(kind=DP),\n  dimension(:,:),allocatable","tags":"","loc":"interface/fraggle_util_vmag_to_vb.html"},{"title":"fraggle_generate_fragments – swiftest","text":"interface Calls interface~~fraggle_generate_fragments~~CallsGraph interface~fraggle_generate_fragments fraggle_generate_fragments proc~fraggle_generate_fragments fraggle_generate_fragments interface~fraggle_generate_fragments->proc~fraggle_generate_fragments interface~fraggle_io_log_generate fraggle_io_log_generate proc~fraggle_generate_fragments->interface~fraggle_io_log_generate proc~fraggle_generate_pos_vec fraggle_generate_pos_vec proc~fraggle_generate_fragments->proc~fraggle_generate_pos_vec proc~fraggle_generate_rad_vel fraggle_generate_rad_vel proc~fraggle_generate_fragments->proc~fraggle_generate_rad_vel interface~fraggle_io_log_one_message fraggle_io_log_one_message proc~fraggle_generate_fragments->interface~fraggle_io_log_one_message proc~fraggle_generate_tan_vel fraggle_generate_tan_vel proc~fraggle_generate_fragments->proc~fraggle_generate_tan_vel proc~fraggle_generate_spins fraggle_generate_spins proc~fraggle_generate_fragments->proc~fraggle_generate_spins proc~fraggle_io_log_generate fraggle_io_log_generate interface~fraggle_io_log_generate->proc~fraggle_io_log_generate interface~fraggle_util_shift_vector_to_origin fraggle_util_shift_vector_to_origin proc~fraggle_generate_pos_vec->interface~fraggle_util_shift_vector_to_origin proc~fraggle_generate_rad_vel->interface~fraggle_io_log_one_message lambda_obj lambda_obj proc~fraggle_generate_rad_vel->lambda_obj util_minimize_bfgs util_minimize_bfgs proc~fraggle_generate_rad_vel->util_minimize_bfgs interface~fraggle_util_vmag_to_vb fraggle_util_vmag_to_vb proc~fraggle_generate_rad_vel->interface~fraggle_util_vmag_to_vb proc~fraggle_io_log_one_message fraggle_io_log_one_message interface~fraggle_io_log_one_message->proc~fraggle_io_log_one_message proc~fraggle_generate_tan_vel->interface~fraggle_io_log_one_message proc~fraggle_generate_tan_vel->lambda_obj proc~fraggle_generate_tan_vel->util_minimize_bfgs proc~fraggle_generate_tan_vel->interface~fraggle_util_vmag_to_vb proc~fraggle_generate_spins->interface~fraggle_io_log_one_message proc~fraggle_util_vmag_to_vb fraggle_util_vmag_to_vb interface~fraggle_util_vmag_to_vb->proc~fraggle_util_vmag_to_vb proc~fraggle_util_shift_vector_to_origin fraggle_util_shift_vector_to_origin interface~fraggle_util_shift_vector_to_origin->proc~fraggle_util_shift_vector_to_origin proc~fraggle_util_vmag_to_vb->interface~fraggle_util_shift_vector_to_origin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_generate_fragments(self, colliders, system, param, lfailure) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle colliders object containing the two-body equivalent values of the colliding bodies class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters logical, intent(out) :: lfailure Answers the question: Should this have been a merger instead?","tags":"","loc":"interface/fraggle_generate_fragments.html"},{"title":"fraggle_io_log_generate – swiftest","text":"interface Calls interface~~fraggle_io_log_generate~~CallsGraph interface~fraggle_io_log_generate fraggle_io_log_generate proc~fraggle_io_log_generate fraggle_io_log_generate interface~fraggle_io_log_generate->proc~fraggle_io_log_generate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~fraggle_io_log_generate~~CalledByGraph interface~fraggle_io_log_generate fraggle_io_log_generate proc~fraggle_generate_fragments fraggle_generate_fragments proc~fraggle_generate_fragments->interface~fraggle_io_log_generate interface~fraggle_generate_fragments fraggle_generate_fragments interface~fraggle_generate_fragments->proc~fraggle_generate_fragments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_io_log_generate(frag) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(in) :: frag","tags":"","loc":"interface/fraggle_io_log_generate.html"},{"title":"fraggle_io_log_one_message – swiftest","text":"interface Calls interface~~fraggle_io_log_one_message~~CallsGraph interface~fraggle_io_log_one_message fraggle_io_log_one_message proc~fraggle_io_log_one_message fraggle_io_log_one_message interface~fraggle_io_log_one_message->proc~fraggle_io_log_one_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~fraggle_io_log_one_message~~CalledByGraph interface~fraggle_io_log_one_message fraggle_io_log_one_message proc~fraggle_generate_fragments fraggle_generate_fragments proc~fraggle_generate_fragments->interface~fraggle_io_log_one_message proc~fraggle_generate_rad_vel fraggle_generate_rad_vel proc~fraggle_generate_fragments->proc~fraggle_generate_rad_vel proc~fraggle_generate_tan_vel fraggle_generate_tan_vel proc~fraggle_generate_fragments->proc~fraggle_generate_tan_vel proc~fraggle_generate_spins fraggle_generate_spins proc~fraggle_generate_fragments->proc~fraggle_generate_spins proc~fraggle_generate_rad_vel->interface~fraggle_io_log_one_message proc~fraggle_regime_collresolve fraggle_regime_collresolve proc~fraggle_regime_collresolve->interface~fraggle_io_log_one_message proc~fraggle_generate_tan_vel->interface~fraggle_io_log_one_message proc~fraggle_generate_spins->interface~fraggle_io_log_one_message interface~fraggle_generate_fragments fraggle_generate_fragments interface~fraggle_generate_fragments->proc~fraggle_generate_fragments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_io_log_one_message(message) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message","tags":"","loc":"interface/fraggle_io_log_one_message.html"},{"title":"fraggle_io_log_pl – swiftest","text":"interface Calls interface~~fraggle_io_log_pl~~CallsGraph interface~fraggle_io_log_pl fraggle_io_log_pl proc~fraggle_io_log_pl fraggle_io_log_pl interface~fraggle_io_log_pl->proc~fraggle_io_log_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_io_log_pl(pl, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(in) :: pl Swiftest massive body object (only the new bodies generated in a collision) class( swiftest_parameters ), intent(in) :: param Current swiftest run configuration parameters","tags":"","loc":"interface/fraggle_io_log_pl.html"},{"title":"fraggle_io_log_regime – swiftest","text":"interface Calls interface~~fraggle_io_log_regime~~CallsGraph interface~fraggle_io_log_regime fraggle_io_log_regime proc~fraggle_io_log_regime fraggle_io_log_regime interface~fraggle_io_log_regime->proc~fraggle_io_log_regime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~fraggle_io_log_regime~~CalledByGraph interface~fraggle_io_log_regime fraggle_io_log_regime proc~fraggle_regime_colliders fraggle_regime_colliders proc~fraggle_regime_colliders->interface~fraggle_io_log_regime interface~fraggle_regime_colliders fraggle_regime_colliders interface~fraggle_regime_colliders->proc~fraggle_regime_colliders Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_io_log_regime(colliders, frag) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_colliders ), intent(in) :: colliders class( fraggle_fragments ), intent(in) :: frag","tags":"","loc":"interface/fraggle_io_log_regime.html"},{"title":"fraggle_io_log_start – swiftest","text":"interface Calls interface~~fraggle_io_log_start~~CallsGraph interface~fraggle_io_log_start fraggle_io_log_start proc~fraggle_io_log_start fraggle_io_log_start interface~fraggle_io_log_start->proc~fraggle_io_log_start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_io_log_start(param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param","tags":"","loc":"interface/fraggle_io_log_start.html"},{"title":"fraggle_placeholder_accel – swiftest","text":"interface Calls interface~~fraggle_placeholder_accel~~CallsGraph interface~fraggle_placeholder_accel fraggle_placeholder_accel proc~fraggle_placeholder_accel fraggle_placeholder_accel interface~fraggle_placeholder_accel->proc~fraggle_placeholder_accel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_placeholder_accel(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step Description The following interfaces are placeholders intended to satisfy the required abstract methods given by the parent class","tags":"","loc":"interface/fraggle_placeholder_accel.html"},{"title":"fraggle_placeholder_kick – swiftest","text":"interface Calls interface~~fraggle_placeholder_kick~~CallsGraph interface~fraggle_placeholder_kick fraggle_placeholder_kick proc~fraggle_placeholder_kick fraggle_placeholder_kick interface~fraggle_placeholder_kick->proc~fraggle_placeholder_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_placeholder_kick(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system objec class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not.","tags":"","loc":"interface/fraggle_placeholder_kick.html"},{"title":"fraggle_placeholder_step – swiftest","text":"interface Calls interface~~fraggle_placeholder_step~~CallsGraph interface~fraggle_placeholder_step fraggle_placeholder_step proc~fraggle_placeholder_step fraggle_placeholder_step interface~fraggle_placeholder_step->proc~fraggle_placeholder_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_placeholder_step(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Helio massive body particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nboody system class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsiz","tags":"","loc":"interface/fraggle_placeholder_step.html"},{"title":"fraggle_regime_colliders – swiftest","text":"interface Calls interface~~fraggle_regime_colliders~~CallsGraph interface~fraggle_regime_colliders fraggle_regime_colliders proc~fraggle_regime_colliders fraggle_regime_colliders interface~fraggle_regime_colliders->proc~fraggle_regime_colliders interface~fraggle_io_log_regime fraggle_io_log_regime proc~fraggle_regime_colliders->interface~fraggle_io_log_regime proc~fraggle_io_log_regime fraggle_io_log_regime interface~fraggle_io_log_regime->proc~fraggle_io_log_regime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_regime_colliders(self, frag, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_colliders ), intent(inout) :: self Fraggle colliders object class( fraggle_fragments ), intent(inout) :: frag Fraggle fragment system object class( swiftest_nbody_system ), intent(in) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current Swiftest run configuration parameters","tags":"","loc":"interface/fraggle_regime_colliders.html"},{"title":"fraggle_set_budgets_fragments – swiftest","text":"interface Calls interface~~fraggle_set_budgets_fragments~~CallsGraph interface~fraggle_set_budgets_fragments fraggle_set_budgets_fragments proc~fraggle_set_budgets_fragments fraggle_set_budgets_fragments interface~fraggle_set_budgets_fragments->proc~fraggle_set_budgets_fragments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_set_budgets_fragments(self, colliders) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object","tags":"","loc":"interface/fraggle_set_budgets_fragments.html"},{"title":"fraggle_set_coordinate_system – swiftest","text":"interface Calls interface~~fraggle_set_coordinate_system~~CallsGraph interface~fraggle_set_coordinate_system fraggle_set_coordinate_system proc~fraggle_set_coordinate_system fraggle_set_coordinate_system interface~fraggle_set_coordinate_system->proc~fraggle_set_coordinate_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_set_coordinate_system(self, colliders) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object","tags":"","loc":"interface/fraggle_set_coordinate_system.html"},{"title":"fraggle_set_mass_dist_fragments – swiftest","text":"interface Calls interface~~fraggle_set_mass_dist_fragments~~CallsGraph interface~fraggle_set_mass_dist_fragments fraggle_set_mass_dist_fragments proc~fraggle_set_mass_dist_fragments fraggle_set_mass_dist_fragments interface~fraggle_set_mass_dist_fragments->proc~fraggle_set_mass_dist_fragments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_set_mass_dist_fragments(self, colliders, param) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object class( swiftest_parameters ), intent(in) :: param Current Swiftest run configuration parameters","tags":"","loc":"interface/fraggle_set_mass_dist_fragments.html"},{"title":"fraggle_set_natural_scale_factors – swiftest","text":"interface Calls interface~~fraggle_set_natural_scale_factors~~CallsGraph interface~fraggle_set_natural_scale_factors fraggle_set_natural_scale_factors proc~fraggle_set_natural_scale_factors fraggle_set_natural_scale_factors interface~fraggle_set_natural_scale_factors->proc~fraggle_set_natural_scale_factors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_set_natural_scale_factors(self, colliders) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object","tags":"","loc":"interface/fraggle_set_natural_scale_factors.html"},{"title":"fraggle_set_original_scale_factors – swiftest","text":"interface Calls interface~~fraggle_set_original_scale_factors~~CallsGraph interface~fraggle_set_original_scale_factors fraggle_set_original_scale_factors proc~fraggle_set_original_scale_factors fraggle_set_original_scale_factors interface~fraggle_set_original_scale_factors->proc~fraggle_set_original_scale_factors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_set_original_scale_factors(self, colliders) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object","tags":"","loc":"interface/fraggle_set_original_scale_factors.html"},{"title":"fraggle_setup_fragments – swiftest","text":"interface Calls interface~~fraggle_setup_fragments~~CallsGraph interface~fraggle_setup_fragments fraggle_setup_fragments proc~fraggle_setup_fragments fraggle_setup_fragments interface~fraggle_setup_fragments->proc~fraggle_setup_fragments setup_pl setup_pl proc~fraggle_setup_fragments->setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_setup_fragments(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object integer(kind=I4B), intent(in) :: n Number of fragments class( swiftest_parameters ), intent(in) :: param Current swiftest run configuration parameters","tags":"","loc":"interface/fraggle_setup_fragments.html"},{"title":"fraggle_setup_reset_fragments – swiftest","text":"interface Calls interface~~fraggle_setup_reset_fragments~~CallsGraph interface~fraggle_setup_reset_fragments fraggle_setup_reset_fragments proc~fraggle_setup_reset_fragments fraggle_setup_reset_fragments interface~fraggle_setup_reset_fragments->proc~fraggle_setup_reset_fragments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_setup_reset_fragments(self) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self","tags":"","loc":"interface/fraggle_setup_reset_fragments.html"},{"title":"fraggle_util_add_fragments_to_system – swiftest","text":"interface Calls interface~~fraggle_util_add_fragments_to_system~~CallsGraph interface~fraggle_util_add_fragments_to_system fraggle_util_add_fragments_to_system proc~fraggle_util_add_fragments_to_system fraggle_util_add_fragments_to_system interface~fraggle_util_add_fragments_to_system->proc~fraggle_util_add_fragments_to_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~fraggle_util_add_fragments_to_system~~CalledByGraph interface~fraggle_util_add_fragments_to_system fraggle_util_add_fragments_to_system proc~fraggle_util_get_energy_momentum fraggle_util_get_energy_momentum proc~fraggle_util_get_energy_momentum->interface~fraggle_util_add_fragments_to_system interface~fraggle_util_get_energy_momentum fraggle_util_get_energy_momentum interface~fraggle_util_get_energy_momentum->proc~fraggle_util_get_energy_momentum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_util_add_fragments_to_system(frag, colliders, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(in) :: frag Fraggle fragment system object class( fraggle_colliders ), intent(in) :: colliders Fraggle collider system object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current swiftest run configuration parameters","tags":"","loc":"interface/fraggle_util_add_fragments_to_system.html"},{"title":"fraggle_util_ang_mtm – swiftest","text":"interface Calls interface~~fraggle_util_ang_mtm~~CallsGraph interface~fraggle_util_ang_mtm fraggle_util_ang_mtm proc~fraggle_util_ang_mtm fraggle_util_ang_mtm interface~fraggle_util_ang_mtm->proc~fraggle_util_ang_mtm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_util_ang_mtm(self) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object","tags":"","loc":"interface/fraggle_util_ang_mtm.html"},{"title":"fraggle_util_construct_temporary_system – swiftest","text":"interface Calls interface~~fraggle_util_construct_temporary_system~~CallsGraph interface~fraggle_util_construct_temporary_system fraggle_util_construct_temporary_system proc~fraggle_util_construct_temporary_system fraggle_util_construct_temporary_system interface~fraggle_util_construct_temporary_system->proc~fraggle_util_construct_temporary_system setup_construct_system setup_construct_system proc~fraggle_util_construct_temporary_system->setup_construct_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~fraggle_util_construct_temporary_system~~CalledByGraph interface~fraggle_util_construct_temporary_system fraggle_util_construct_temporary_system proc~fraggle_util_get_energy_momentum fraggle_util_get_energy_momentum proc~fraggle_util_get_energy_momentum->interface~fraggle_util_construct_temporary_system interface~fraggle_util_get_energy_momentum fraggle_util_get_energy_momentum interface~fraggle_util_get_energy_momentum->proc~fraggle_util_get_energy_momentum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_util_construct_temporary_system(frag, system, param, tmpsys, tmpparam) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(in) :: frag Fraggle fragment system object class( swiftest_nbody_system ), intent(in) :: system Original swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current swiftest run configuration parameters class( swiftest_nbody_system ), intent(out), allocatable :: tmpsys Output temporary swiftest nbody system object class( swiftest_parameters ), intent(out), allocatable :: tmpparam Output temporary configuration run parameters","tags":"","loc":"interface/fraggle_util_construct_temporary_system.html"},{"title":"fraggle_util_get_energy_momentum – swiftest","text":"interface Calls interface~~fraggle_util_get_energy_momentum~~CallsGraph interface~fraggle_util_get_energy_momentum fraggle_util_get_energy_momentum proc~fraggle_util_get_energy_momentum fraggle_util_get_energy_momentum interface~fraggle_util_get_energy_momentum->proc~fraggle_util_get_energy_momentum util_exit util_exit proc~fraggle_util_get_energy_momentum->util_exit interface~fraggle_util_add_fragments_to_system fraggle_util_add_fragments_to_system proc~fraggle_util_get_energy_momentum->interface~fraggle_util_add_fragments_to_system interface~fraggle_util_construct_temporary_system fraggle_util_construct_temporary_system proc~fraggle_util_get_energy_momentum->interface~fraggle_util_construct_temporary_system proc~fraggle_util_add_fragments_to_system fraggle_util_add_fragments_to_system interface~fraggle_util_add_fragments_to_system->proc~fraggle_util_add_fragments_to_system proc~fraggle_util_construct_temporary_system fraggle_util_construct_temporary_system interface~fraggle_util_construct_temporary_system->proc~fraggle_util_construct_temporary_system setup_construct_system setup_construct_system proc~fraggle_util_construct_temporary_system->setup_construct_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_util_get_energy_momentum(self, colliders, system, param, lbefore) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current swiftest run configuration parameters logical, intent(in) :: lbefore Flag indicating that this the \"before\" state of the system, with colliders included and fragments excluded or vice versa","tags":"","loc":"interface/fraggle_util_get_energy_momentum.html"},{"title":"fraggle_util_restructure – swiftest","text":"interface Calls interface~~fraggle_util_restructure~~CallsGraph interface~fraggle_util_restructure fraggle_util_restructure proc~fraggle_util_restructure fraggle_util_restructure interface~fraggle_util_restructure->proc~fraggle_util_restructure Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_util_restructure(self, colliders, try, f_spin, r_max_start) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(in) :: colliders Fraggle collider system object integer(kind=I4B), intent(in) :: try The current number of times Fraggle has tried to find a solution real(kind=DP), intent(inout) :: f_spin Fraction of energy/momentum that goes into spin. This decreases ater a failed attempt real(kind=DP), intent(inout) :: r_max_start The maximum radial distance that the position calculation starts with. This increases after a failed attempt","tags":"","loc":"interface/fraggle_util_restructure.html"},{"title":"fraggle_util_shift_vector_to_origin – swiftest","text":"interface Calls interface~~fraggle_util_shift_vector_to_origin~~CallsGraph interface~fraggle_util_shift_vector_to_origin fraggle_util_shift_vector_to_origin proc~fraggle_util_shift_vector_to_origin fraggle_util_shift_vector_to_origin interface~fraggle_util_shift_vector_to_origin->proc~fraggle_util_shift_vector_to_origin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~fraggle_util_shift_vector_to_origin~~CalledByGraph interface~fraggle_util_shift_vector_to_origin fraggle_util_shift_vector_to_origin proc~fraggle_util_vmag_to_vb fraggle_util_vmag_to_vb proc~fraggle_util_vmag_to_vb->interface~fraggle_util_shift_vector_to_origin proc~fraggle_generate_pos_vec fraggle_generate_pos_vec proc~fraggle_generate_pos_vec->interface~fraggle_util_shift_vector_to_origin interface~fraggle_util_vmag_to_vb fraggle_util_vmag_to_vb interface~fraggle_util_vmag_to_vb->proc~fraggle_util_vmag_to_vb proc~fraggle_generate_fragments fraggle_generate_fragments proc~fraggle_generate_fragments->proc~fraggle_generate_pos_vec proc~fraggle_generate_tan_vel fraggle_generate_tan_vel proc~fraggle_generate_fragments->proc~fraggle_generate_tan_vel proc~fraggle_generate_rad_vel fraggle_generate_rad_vel proc~fraggle_generate_fragments->proc~fraggle_generate_rad_vel proc~fraggle_generate_tan_vel->interface~fraggle_util_vmag_to_vb proc~fraggle_generate_rad_vel->interface~fraggle_util_vmag_to_vb interface~fraggle_generate_fragments fraggle_generate_fragments interface~fraggle_generate_fragments->proc~fraggle_generate_fragments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine fraggle_util_shift_vector_to_origin(m_frag, vec_frag) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: m_frag Fragment masses real(kind=DP), intent(inout), dimension(:,:) :: vec_frag Fragment positions or velocities in the center of mass frame","tags":"","loc":"interface/fraggle_util_shift_vector_to_origin.html"},{"title":"symba_collision_check_encounter – swiftest","text":"interface Calls interface~~symba_collision_check_encounter~~CallsGraph interface~symba_collision_check_encounter symba_collision_check_encounter proc~symba_collision_check_encounter symba_collision_check_encounter interface~symba_collision_check_encounter->proc~symba_collision_check_encounter proc~symba_collision_check_one symba_collision_check_one proc~symba_collision_check_encounter->proc~symba_collision_check_one fraggle_io_log_one_message fraggle_io_log_one_message proc~symba_collision_check_encounter->fraggle_io_log_one_message orbel_xv2aeq orbel_xv2aeq proc~symba_collision_check_one->orbel_xv2aeq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function symba_collision_check_encounter(self, system, param, t, dt, irec) result(lany_collision) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t current time real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if cany pair of encounters resulted in a collision n","tags":"","loc":"interface/symba_collision_check_encounter.html"},{"title":"symba_encounter_check_pl – swiftest","text":"interface Calls interface~~symba_encounter_check_pl~~CallsGraph interface~symba_encounter_check_pl symba_encounter_check_pl proc~symba_encounter_check_pl symba_encounter_check_pl interface~symba_encounter_check_pl->proc~symba_encounter_check_pl util_index_eucl_ij_to_k util_index_eucl_ij_to_k proc~symba_encounter_check_pl->util_index_eucl_ij_to_k proc~symba_encounter_check_all symba_encounter_check_all proc~symba_encounter_check_pl->proc~symba_encounter_check_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function symba_encounter_check_pl(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter","tags":"","loc":"interface/symba_encounter_check_pl.html"},{"title":"symba_encounter_check – swiftest","text":"interface Calls interface~~symba_encounter_check~~CallsGraph interface~symba_encounter_check symba_encounter_check proc~symba_encounter_check symba_encounter_check interface~symba_encounter_check->proc~symba_encounter_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function symba_encounter_check(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-pl encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter","tags":"","loc":"interface/symba_encounter_check.html"},{"title":"symba_encounter_check_tp – swiftest","text":"interface Calls interface~~symba_encounter_check_tp~~CallsGraph interface~symba_encounter_check_tp symba_encounter_check_tp proc~symba_encounter_check_tp symba_encounter_check_tp interface~symba_encounter_check_tp->proc~symba_encounter_check_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function symba_encounter_check_tp(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter","tags":"","loc":"interface/symba_encounter_check_tp.html"},{"title":"symba_collision_casedisruption – swiftest","text":"interface Calls interface~~symba_collision_casedisruption~~CallsGraph interface~symba_collision_casedisruption symba_collision_casedisruption proc~symba_collision_casedisruption symba_collision_casedisruption interface~symba_collision_casedisruption->proc~symba_collision_casedisruption proc~symba_collision_collider_message symba_collision_collider_message proc~symba_collision_casedisruption->proc~symba_collision_collider_message proc~symba_collision_mergeaddsub symba_collision_mergeaddsub proc~symba_collision_casedisruption->proc~symba_collision_mergeaddsub fraggle_io_log_one_message fraggle_io_log_one_message proc~symba_collision_casedisruption->fraggle_io_log_one_message fraggle_io_log_pl fraggle_io_log_pl proc~symba_collision_mergeaddsub->fraggle_io_log_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~symba_collision_casedisruption~~CalledByGraph interface~symba_collision_casedisruption symba_collision_casedisruption proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations proc~symba_collision_resolve_fragmentations->interface~symba_collision_casedisruption interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function symba_collision_casedisruption(system, param, colliders, frag) result(status) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions class( fraggle_colliders ), intent(inout) :: colliders Fraggle colliders object class( fraggle_fragments ), intent(inout) :: frag Fraggle fragmentation system object Return Value integer(kind=I4B) Status flag assigned to this outcome","tags":"","loc":"interface/symba_collision_casedisruption.html"},{"title":"symba_collision_casehitandrun – swiftest","text":"interface Calls interface~~symba_collision_casehitandrun~~CallsGraph interface~symba_collision_casehitandrun symba_collision_casehitandrun proc~symba_collision_casehitandrun symba_collision_casehitandrun interface~symba_collision_casehitandrun->proc~symba_collision_casehitandrun proc~symba_collision_collider_message symba_collision_collider_message proc~symba_collision_casehitandrun->proc~symba_collision_collider_message proc~symba_collision_mergeaddsub symba_collision_mergeaddsub proc~symba_collision_casehitandrun->proc~symba_collision_mergeaddsub fraggle_io_log_one_message fraggle_io_log_one_message proc~symba_collision_casehitandrun->fraggle_io_log_one_message fraggle_io_log_pl fraggle_io_log_pl proc~symba_collision_mergeaddsub->fraggle_io_log_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~symba_collision_casehitandrun~~CalledByGraph interface~symba_collision_casehitandrun symba_collision_casehitandrun proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations proc~symba_collision_resolve_fragmentations->interface~symba_collision_casehitandrun interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function symba_collision_casehitandrun(system, param, colliders, frag) result(status) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions class( fraggle_colliders ), intent(inout) :: colliders Fraggle colliders object class( fraggle_fragments ), intent(inout) :: frag Fraggle fragmentation system object Return Value integer(kind=I4B) Status flag assigned to this outcome","tags":"","loc":"interface/symba_collision_casehitandrun.html"},{"title":"symba_collision_casemerge – swiftest","text":"interface Calls interface~~symba_collision_casemerge~~CallsGraph interface~symba_collision_casemerge symba_collision_casemerge proc~symba_collision_casemerge symba_collision_casemerge interface~symba_collision_casemerge->proc~symba_collision_casemerge proc~symba_collision_collider_message symba_collision_collider_message proc~symba_collision_casemerge->proc~symba_collision_collider_message proc~symba_collision_mergeaddsub symba_collision_mergeaddsub proc~symba_collision_casemerge->proc~symba_collision_mergeaddsub fraggle_io_log_one_message fraggle_io_log_one_message proc~symba_collision_casemerge->fraggle_io_log_one_message fraggle_io_log_pl fraggle_io_log_pl proc~symba_collision_mergeaddsub->fraggle_io_log_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~symba_collision_casemerge~~CalledByGraph interface~symba_collision_casemerge symba_collision_casemerge proc~symba_collision_resolve_mergers symba_collision_resolve_mergers proc~symba_collision_resolve_mergers->interface~symba_collision_casemerge proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations proc~symba_collision_resolve_fragmentations->interface~symba_collision_casemerge interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations interface~symba_collision_resolve_mergers symba_collision_resolve_mergers interface~symba_collision_resolve_mergers->proc~symba_collision_resolve_mergers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function symba_collision_casemerge(system, param, colliders, frag) result(status) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions class( fraggle_colliders ), intent(inout) :: colliders Fraggle colliders object class( fraggle_fragments ), intent(inout) :: frag Fraggle fragmentation system object Return Value integer(kind=I4B) Status flag assigned to this outcome","tags":"","loc":"interface/symba_collision_casemerge.html"},{"title":"symba_collision_encounter_extract_collisions – swiftest","text":"interface Calls interface~~symba_collision_encounter_extract_collisions~~CallsGraph interface~symba_collision_encounter_extract_collisions symba_collision_encounter_extract_collisions proc~symba_collision_encounter_extract_collisions symba_collision_encounter_extract_collisions interface~symba_collision_encounter_extract_collisions->proc~symba_collision_encounter_extract_collisions idx2 idx2 proc~symba_collision_encounter_extract_collisions->idx2 idx1 idx1 proc~symba_collision_encounter_extract_collisions->idx1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_collision_encounter_extract_collisions(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/symba_collision_encounter_extract_collisions.html"},{"title":"symba_collision_make_colliders_pl – swiftest","text":"interface Calls interface~~symba_collision_make_colliders_pl~~CallsGraph interface~symba_collision_make_colliders_pl symba_collision_make_colliders_pl proc~symba_collision_make_colliders_pl symba_collision_make_colliders_pl interface~symba_collision_make_colliders_pl->proc~symba_collision_make_colliders_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_collision_make_colliders_pl(self, idx) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(2) :: idx Array holding the indices of the two bodies involved in the collision","tags":"","loc":"interface/symba_collision_make_colliders_pl.html"},{"title":"symba_collision_resolve_fragmentations – swiftest","text":"interface Calls interface~~symba_collision_resolve_fragmentations~~CallsGraph interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations idx2 idx2 proc~symba_collision_resolve_fragmentations->idx2 util_exit util_exit proc~symba_collision_resolve_fragmentations->util_exit idx1 idx1 proc~symba_collision_resolve_fragmentations->idx1 proc~symba_collision_consolidate_colliders symba_collision_consolidate_colliders proc~symba_collision_resolve_fragmentations->proc~symba_collision_consolidate_colliders interface~symba_collision_casedisruption symba_collision_casedisruption proc~symba_collision_resolve_fragmentations->interface~symba_collision_casedisruption interface~symba_collision_casemerge symba_collision_casemerge proc~symba_collision_resolve_fragmentations->interface~symba_collision_casemerge interface~symba_collision_casehitandrun symba_collision_casehitandrun proc~symba_collision_resolve_fragmentations->interface~symba_collision_casehitandrun idx_arr idx_arr proc~symba_collision_consolidate_colliders->idx_arr id_arr id_arr proc~symba_collision_consolidate_colliders->id_arr proc~symba_collision_casedisruption symba_collision_casedisruption interface~symba_collision_casedisruption->proc~symba_collision_casedisruption proc~symba_collision_casemerge symba_collision_casemerge interface~symba_collision_casemerge->proc~symba_collision_casemerge proc~symba_collision_casehitandrun symba_collision_casehitandrun interface~symba_collision_casehitandrun->proc~symba_collision_casehitandrun proc~symba_collision_collider_message symba_collision_collider_message proc~symba_collision_casedisruption->proc~symba_collision_collider_message proc~symba_collision_mergeaddsub symba_collision_mergeaddsub proc~symba_collision_casedisruption->proc~symba_collision_mergeaddsub fraggle_io_log_one_message fraggle_io_log_one_message proc~symba_collision_casedisruption->fraggle_io_log_one_message proc~symba_collision_casehitandrun->proc~symba_collision_collider_message proc~symba_collision_casehitandrun->proc~symba_collision_mergeaddsub proc~symba_collision_casehitandrun->fraggle_io_log_one_message proc~symba_collision_casemerge->proc~symba_collision_collider_message proc~symba_collision_casemerge->proc~symba_collision_mergeaddsub proc~symba_collision_casemerge->fraggle_io_log_one_message fraggle_io_log_pl fraggle_io_log_pl proc~symba_collision_mergeaddsub->fraggle_io_log_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_collision_resolve_fragmentations(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions","tags":"","loc":"interface/symba_collision_resolve_fragmentations.html"},{"title":"symba_collision_resolve_mergers – swiftest","text":"interface Calls interface~~symba_collision_resolve_mergers~~CallsGraph interface~symba_collision_resolve_mergers symba_collision_resolve_mergers proc~symba_collision_resolve_mergers symba_collision_resolve_mergers interface~symba_collision_resolve_mergers->proc~symba_collision_resolve_mergers idx2 idx2 proc~symba_collision_resolve_mergers->idx2 proc~symba_collision_consolidate_colliders symba_collision_consolidate_colliders proc~symba_collision_resolve_mergers->proc~symba_collision_consolidate_colliders idx1 idx1 proc~symba_collision_resolve_mergers->idx1 interface~symba_collision_casemerge symba_collision_casemerge proc~symba_collision_resolve_mergers->interface~symba_collision_casemerge idx_arr idx_arr proc~symba_collision_consolidate_colliders->idx_arr id_arr id_arr proc~symba_collision_consolidate_colliders->id_arr proc~symba_collision_casemerge symba_collision_casemerge interface~symba_collision_casemerge->proc~symba_collision_casemerge proc~symba_collision_collider_message symba_collision_collider_message proc~symba_collision_casemerge->proc~symba_collision_collider_message proc~symba_collision_mergeaddsub symba_collision_mergeaddsub proc~symba_collision_casemerge->proc~symba_collision_mergeaddsub fraggle_io_log_one_message fraggle_io_log_one_message proc~symba_collision_casemerge->fraggle_io_log_one_message fraggle_io_log_pl fraggle_io_log_pl proc~symba_collision_mergeaddsub->fraggle_io_log_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_collision_resolve_mergers(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions","tags":"","loc":"interface/symba_collision_resolve_mergers.html"},{"title":"symba_collision_resolve_plplenc – swiftest","text":"interface Calls interface~~symba_collision_resolve_plplenc~~CallsGraph interface~symba_collision_resolve_plplenc symba_collision_resolve_plplenc proc~symba_collision_resolve_plplenc symba_collision_resolve_plplenc interface~symba_collision_resolve_plplenc->proc~symba_collision_resolve_plplenc fraggle_io_log_one_message fraggle_io_log_one_message proc~symba_collision_resolve_plplenc->fraggle_io_log_one_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_collision_resolve_plplenc(self, system, param, t, dt, irec) Implementation → Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current simulation step size integer(kind=I4B), intent(in) :: irec Current recursion level","tags":"","loc":"interface/symba_collision_resolve_plplenc.html"},{"title":"symba_collision_resolve_pltpenc – swiftest","text":"interface Calls interface~~symba_collision_resolve_pltpenc~~CallsGraph interface~symba_collision_resolve_pltpenc symba_collision_resolve_pltpenc proc~symba_collision_resolve_pltpenc symba_collision_resolve_pltpenc interface~symba_collision_resolve_pltpenc->proc~symba_collision_resolve_pltpenc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_collision_resolve_pltpenc(self, system, param, t, dt, irec) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-tp encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current simulation step size integer(kind=I4B), intent(in) :: irec Current recursion level","tags":"","loc":"interface/symba_collision_resolve_pltpenc.html"},{"title":"symba_discard_pl – swiftest","text":"interface Calls interface~~symba_discard_pl~~CallsGraph interface~symba_discard_pl symba_discard_pl proc~symba_discard_pl symba_discard_pl interface~symba_discard_pl->proc~symba_discard_pl proc~symba_discard_nonplpl symba_discard_nonplpl proc~symba_discard_pl->proc~symba_discard_nonplpl proc~symba_discard_nonplpl_conservation symba_discard_nonplpl_conservation proc~symba_discard_pl->proc~symba_discard_nonplpl_conservation proc~symba_discard_cb_pl symba_discard_cb_pl proc~symba_discard_nonplpl->proc~symba_discard_cb_pl fraggle_io_log_one_message fraggle_io_log_one_message proc~symba_discard_cb_pl->fraggle_io_log_one_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_discard_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/symba_discard_pl.html"},{"title":"symba_drift_pl – swiftest","text":"interface Calls interface~~symba_drift_pl~~CallsGraph interface~symba_drift_pl symba_drift_pl proc~symba_drift_pl symba_drift_pl interface~symba_drift_pl->proc~symba_drift_pl helio_drift_body helio_drift_body proc~symba_drift_pl->helio_drift_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"interface/symba_drift_pl.html"},{"title":"symba_drift_tp – swiftest","text":"interface Calls interface~~symba_drift_tp~~CallsGraph interface~symba_drift_tp symba_drift_tp proc~symba_drift_tp symba_drift_tp interface~symba_drift_tp->proc~symba_drift_tp helio_drift_body helio_drift_body proc~symba_drift_tp->helio_drift_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_drift_tp(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"interface/symba_drift_tp.html"},{"title":"symba_encounter_check_one – swiftest","text":"interface Calls interface~~symba_encounter_check_one~~CallsGraph interface~symba_encounter_check_one symba_encounter_check_one proc~symba_encounter_check_one symba_encounter_check_one interface~symba_encounter_check_one->proc~symba_encounter_check_one rmvs_chk_ind rmvs_chk_ind proc~symba_encounter_check_one->rmvs_chk_ind Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine symba_encounter_check_one(xr, yr, zr, vxr, vyr, vzr, rhill1, rhill2, dt, irec, lencounter, lvdotr) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: xr real(kind=DP), intent(in) :: yr real(kind=DP), intent(in) :: zr real(kind=DP), intent(in) :: vxr real(kind=DP), intent(in) :: vyr real(kind=DP), intent(in) :: vzr real(kind=DP), intent(in) :: rhill1 real(kind=DP), intent(in) :: rhill2 real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: irec logical, intent(out) :: lencounter logical, intent(out) :: lvdotr","tags":"","loc":"interface/symba_encounter_check_one.html"},{"title":"symba_util_index_eucl_plpl – swiftest","text":"interface Calls interface~~symba_util_index_eucl_plpl~~CallsGraph interface~symba_util_index_eucl_plpl symba_util_index_eucl_plpl proc~symba_util_index_eucl_plpl symba_util_index_eucl_plpl interface~symba_util_index_eucl_plpl->proc~symba_util_index_eucl_plpl util_index_eucl_ij_to_k util_index_eucl_ij_to_k proc~symba_util_index_eucl_plpl->util_index_eucl_ij_to_k Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_index_eucl_plpl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/symba_util_index_eucl_plpl.html"},{"title":"symba_io_param_reader – swiftest","text":"interface Calls interface~~symba_io_param_reader~~CallsGraph interface~symba_io_param_reader symba_io_param_reader proc~symba_io_param_reader symba_io_param_reader interface~symba_io_param_reader->proc~symba_io_param_reader io_get_token io_get_token proc~symba_io_param_reader->io_get_token io_toupper io_toupper proc~symba_io_param_reader->io_toupper io_param_reader io_param_reader proc~symba_io_param_reader->io_param_reader fraggle_io_log_start fraggle_io_log_start proc~symba_io_param_reader->fraggle_io_log_start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_io_param_reader(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_parameters ), intent(inout) :: self Current run configuration parameters with SyMBA additionss integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) The first element passes the integrator code to the reader integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0","tags":"","loc":"interface/symba_io_param_reader.html"},{"title":"symba_io_param_writer – swiftest","text":"interface Calls interface~~symba_io_param_writer~~CallsGraph interface~symba_io_param_writer symba_io_param_writer proc~symba_io_param_writer symba_io_param_writer interface~symba_io_param_writer->proc~symba_io_param_writer io_param_writer io_param_writer proc~symba_io_param_writer->io_param_writer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_io_param_writer(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_parameters ), intent(in) :: self Current run configuration parameters with SyMBA additions integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) Not used in this procedure integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0","tags":"","loc":"interface/symba_io_param_writer.html"},{"title":"symba_io_write_discard – swiftest","text":"interface Calls interface~~symba_io_write_discard~~CallsGraph interface~symba_io_write_discard symba_io_write_discard proc~symba_io_write_discard symba_io_write_discard interface~symba_io_write_discard->proc~symba_io_write_discard util_exit util_exit proc~symba_io_write_discard->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_io_write_discard(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/symba_io_write_discard.html"},{"title":"symba_kick_getacch_int_pl – swiftest","text":"interface Calls interface~~symba_kick_getacch_int_pl~~CallsGraph interface~symba_kick_getacch_int_pl symba_kick_getacch_int_pl proc~symba_kick_getacch_int_pl symba_kick_getacch_int_pl interface~symba_kick_getacch_int_pl->proc~symba_kick_getacch_int_pl kick_getacch_int_all_pl kick_getacch_int_all_pl proc~symba_kick_getacch_int_pl->kick_getacch_int_all_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_kick_getacch_int_pl(self) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self","tags":"","loc":"interface/symba_kick_getacch_int_pl.html"},{"title":"symba_kick_getacch_pl – swiftest","text":"interface Calls interface~~symba_kick_getacch_pl~~CallsGraph interface~symba_kick_getacch_pl symba_kick_getacch_pl proc~symba_kick_getacch_pl symba_kick_getacch_pl interface~symba_kick_getacch_pl->proc~symba_kick_getacch_pl kick_getacch_int_all_pl kick_getacch_int_all_pl proc~symba_kick_getacch_pl->kick_getacch_int_all_pl helio_kick_getacch_pl helio_kick_getacch_pl proc~symba_kick_getacch_pl->helio_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step","tags":"","loc":"interface/symba_kick_getacch_pl.html"},{"title":"symba_kick_getacch_tp – swiftest","text":"interface Calls interface~~symba_kick_getacch_tp~~CallsGraph interface~symba_kick_getacch_tp symba_kick_getacch_tp proc~symba_kick_getacch_tp symba_kick_getacch_tp interface~symba_kick_getacch_tp->proc~symba_kick_getacch_tp helio_kick_getacch_tp helio_kick_getacch_tp proc~symba_kick_getacch_tp->helio_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step","tags":"","loc":"interface/symba_kick_getacch_tp.html"},{"title":"symba_kick_encounter – swiftest","text":"interface Calls interface~~symba_kick_encounter~~CallsGraph interface~symba_kick_encounter symba_kick_encounter proc~symba_kick_encounter symba_kick_encounter interface~symba_kick_encounter->proc~symba_kick_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_kick_encounter(self, system, dt, irec, sgn) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(in) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level integer(kind=I4B), intent(in) :: sgn sign to be applied to acceleration","tags":"","loc":"interface/symba_kick_encounter.html"},{"title":"symba_setup_initialize_system – swiftest","text":"interface Calls interface~~symba_setup_initialize_system~~CallsGraph interface~symba_setup_initialize_system symba_setup_initialize_system proc~symba_setup_initialize_system symba_setup_initialize_system interface~symba_setup_initialize_system->proc~symba_setup_initialize_system helio_setup_initialize_system helio_setup_initialize_system proc~symba_setup_initialize_system->helio_setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/symba_setup_initialize_system.html"},{"title":"symba_setup_merger – swiftest","text":"interface Calls interface~~symba_setup_merger~~CallsGraph interface~symba_setup_merger symba_setup_merger proc~symba_setup_merger symba_setup_merger interface~symba_setup_merger->proc~symba_setup_merger interface~symba_setup_pl symba_setup_pl proc~symba_setup_merger->interface~symba_setup_pl proc~symba_setup_pl symba_setup_pl interface~symba_setup_pl->proc~symba_setup_pl setup_pl setup_pl proc~symba_setup_pl->setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_setup_merger(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA merger list object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/symba_setup_merger.html"},{"title":"symba_setup_pl – swiftest","text":"interface Calls interface~~symba_setup_pl~~CallsGraph interface~symba_setup_pl symba_setup_pl proc~symba_setup_pl symba_setup_pl interface~symba_setup_pl->proc~symba_setup_pl setup_pl setup_pl proc~symba_setup_pl->setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~symba_setup_pl~~CalledByGraph interface~symba_setup_pl symba_setup_pl proc~symba_setup_merger symba_setup_merger proc~symba_setup_merger->interface~symba_setup_pl interface~symba_setup_merger symba_setup_merger interface~symba_setup_merger->proc~symba_setup_merger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/symba_setup_pl.html"},{"title":"symba_setup_encounter – swiftest","text":"interface Calls interface~~symba_setup_encounter~~CallsGraph interface~symba_setup_encounter symba_setup_encounter proc~symba_setup_encounter symba_setup_encounter interface~symba_setup_encounter->proc~symba_setup_encounter setup_encounter setup_encounter proc~symba_setup_encounter->setup_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_setup_encounter(self, n) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-tp encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for","tags":"","loc":"interface/symba_setup_encounter.html"},{"title":"symba_setup_tp – swiftest","text":"interface Calls interface~~symba_setup_tp~~CallsGraph interface~symba_setup_tp symba_setup_tp proc~symba_setup_tp symba_setup_tp interface~symba_setup_tp->proc~symba_setup_tp setup_tp setup_tp proc~symba_setup_tp->setup_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter","tags":"","loc":"interface/symba_setup_tp.html"},{"title":"symba_step_system – swiftest","text":"interface Calls interface~~symba_step_system~~CallsGraph interface~symba_step_system symba_step_system proc~symba_step_system symba_step_system interface~symba_step_system->proc~symba_step_system helio_step_system helio_step_system proc~symba_step_system->helio_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"interface/symba_step_system.html"},{"title":"symba_step_interp_system – swiftest","text":"interface Calls interface~~symba_step_interp_system~~CallsGraph interface~symba_step_interp_system symba_step_interp_system proc~symba_step_interp_system symba_step_interp_system interface~symba_step_interp_system->proc~symba_step_interp_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_step_interp_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"interface/symba_step_interp_system.html"},{"title":"symba_step_set_recur_levels_system – swiftest","text":"interface Calls interface~~symba_step_set_recur_levels_system~~CallsGraph interface~symba_step_set_recur_levels_system symba_step_set_recur_levels_system proc~symba_step_set_recur_levels_system symba_step_set_recur_levels_system interface~symba_step_set_recur_levels_system->proc~symba_step_set_recur_levels_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_step_set_recur_levels_system(self, ireci) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system objec integer(kind=I4B), intent(in) :: ireci Input recursion level","tags":"","loc":"interface/symba_step_set_recur_levels_system.html"},{"title":"symba_step_recur_system – swiftest","text":"interface Calls interface~~symba_step_recur_system~~CallsGraph interface~symba_step_recur_system symba_step_recur_system proc~symba_step_recur_system symba_step_recur_system interface~symba_step_recur_system->proc~symba_step_recur_system util_exit util_exit proc~symba_step_recur_system->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public recursive module subroutine symba_step_recur_system(self, param, t, ireci) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: ireci input recursion level","tags":"","loc":"interface/symba_step_recur_system.html"},{"title":"symba_step_reset_system – swiftest","text":"interface Calls interface~~symba_step_reset_system~~CallsGraph interface~symba_step_reset_system symba_step_reset_system proc~symba_step_reset_system symba_step_reset_system interface~symba_step_reset_system->proc~symba_step_reset_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_step_reset_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions","tags":"","loc":"interface/symba_step_reset_system.html"},{"title":"util_append – swiftest","text":"public interface util_append Called by interface~~util_append~~CalledByGraph interface~util_append util_append proc~symba_util_append_encounter symba_util_append_encounter proc~symba_util_append_encounter->interface~util_append proc~symba_util_append_merger symba_util_append_merger proc~symba_util_append_merger->interface~util_append interface~symba_util_append_pl symba_util_append_pl proc~symba_util_append_merger->interface~symba_util_append_pl proc~symba_util_append_tp symba_util_append_tp proc~symba_util_append_tp->interface~util_append proc~symba_util_append_pl symba_util_append_pl proc~symba_util_append_pl->interface~util_append interface~symba_util_append_pl->proc~symba_util_append_pl interface~symba_util_append_encounter symba_util_append_encounter interface~symba_util_append_encounter->proc~symba_util_append_encounter interface~symba_util_append_merger symba_util_append_merger interface~symba_util_append_merger->proc~symba_util_append_merger interface~symba_util_append_tp symba_util_append_tp interface~symba_util_append_tp->proc~symba_util_append_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines symba_util_append_arr_kin Subroutines public subroutine symba_util_append_arr_kin(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: arr Destination array type( symba_kinship ), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/util_append.html"},{"title":"symba_util_append_encounter – swiftest","text":"interface Calls interface~~symba_util_append_encounter~~CallsGraph interface~symba_util_append_encounter symba_util_append_encounter proc~symba_util_append_encounter symba_util_append_encounter interface~symba_util_append_encounter->proc~symba_util_append_encounter interface~util_append util_append proc~symba_util_append_encounter->interface~util_append util_append_encounter util_append_encounter proc~symba_util_append_encounter->util_append_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_append_encounter(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA encounter list object class( swiftest_encounter ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/symba_util_append_encounter.html"},{"title":"symba_util_append_merger – swiftest","text":"interface Calls interface~~symba_util_append_merger~~CallsGraph interface~symba_util_append_merger symba_util_append_merger proc~symba_util_append_merger symba_util_append_merger interface~symba_util_append_merger->proc~symba_util_append_merger interface~util_append util_append proc~symba_util_append_merger->interface~util_append util_exit util_exit proc~symba_util_append_merger->util_exit interface~symba_util_append_pl symba_util_append_pl proc~symba_util_append_merger->interface~symba_util_append_pl proc~symba_util_append_pl symba_util_append_pl interface~symba_util_append_pl->proc~symba_util_append_pl proc~symba_util_append_pl->interface~util_append proc~symba_util_append_pl->util_exit util_append_pl util_append_pl proc~symba_util_append_pl->util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_append_merger(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/symba_util_append_merger.html"},{"title":"symba_util_append_pl – swiftest","text":"interface Calls interface~~symba_util_append_pl~~CallsGraph interface~symba_util_append_pl symba_util_append_pl proc~symba_util_append_pl symba_util_append_pl interface~symba_util_append_pl->proc~symba_util_append_pl interface~util_append util_append proc~symba_util_append_pl->interface~util_append util_append_pl util_append_pl proc~symba_util_append_pl->util_append_pl util_exit util_exit proc~symba_util_append_pl->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~symba_util_append_pl~~CalledByGraph interface~symba_util_append_pl symba_util_append_pl proc~symba_util_append_merger symba_util_append_merger proc~symba_util_append_merger->interface~symba_util_append_pl interface~symba_util_append_merger symba_util_append_merger interface~symba_util_append_merger->proc~symba_util_append_merger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/symba_util_append_pl.html"},{"title":"symba_util_append_tp – swiftest","text":"interface Calls interface~~symba_util_append_tp~~CallsGraph interface~symba_util_append_tp symba_util_append_tp proc~symba_util_append_tp symba_util_append_tp interface~symba_util_append_tp->proc~symba_util_append_tp interface~util_append util_append proc~symba_util_append_tp->interface~util_append util_exit util_exit proc~symba_util_append_tp->util_exit util_append_tp util_append_tp proc~symba_util_append_tp->util_append_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/symba_util_append_tp.html"},{"title":"symba_util_copy_encounter – swiftest","text":"interface Calls interface~~symba_util_copy_encounter~~CallsGraph interface~symba_util_copy_encounter symba_util_copy_encounter proc~symba_util_copy_encounter symba_util_copy_encounter interface~symba_util_copy_encounter->proc~symba_util_copy_encounter util_copy_encounter util_copy_encounter proc~symba_util_copy_encounter->util_copy_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_copy_encounter(self, source) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self Encounter list class( swiftest_encounter ), intent(in) :: source Source object to copy into","tags":"","loc":"interface/symba_util_copy_encounter.html"},{"title":"util_fill – swiftest","text":"public interface util_fill Called by interface~~util_fill~~CalledByGraph interface~util_fill util_fill proc~symba_util_fill_tp symba_util_fill_tp proc~symba_util_fill_tp->interface~util_fill proc~symba_util_fill_pl symba_util_fill_pl proc~symba_util_fill_pl->interface~util_fill interface~symba_util_fill_pl symba_util_fill_pl interface~symba_util_fill_pl->proc~symba_util_fill_pl interface~symba_util_fill_tp symba_util_fill_tp interface~symba_util_fill_tp->proc~symba_util_fill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines symba_util_fill_arr_kin Subroutines public subroutine symba_util_fill_arr_kin(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_kinship ), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"interface/util_fill.html"},{"title":"symba_util_fill_pl – swiftest","text":"interface Calls interface~~symba_util_fill_pl~~CallsGraph interface~symba_util_fill_pl symba_util_fill_pl proc~symba_util_fill_pl symba_util_fill_pl interface~symba_util_fill_pl->proc~symba_util_fill_pl util_exit util_exit proc~symba_util_fill_pl->util_exit interface~util_fill util_fill proc~symba_util_fill_pl->interface~util_fill util_fill_pl util_fill_pl proc~symba_util_fill_pl->util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"interface/symba_util_fill_pl.html"},{"title":"symba_util_fill_tp – swiftest","text":"interface Calls interface~~symba_util_fill_tp~~CallsGraph interface~symba_util_fill_tp symba_util_fill_tp proc~symba_util_fill_tp symba_util_fill_tp interface~symba_util_fill_tp->proc~symba_util_fill_tp util_exit util_exit proc~symba_util_fill_tp->util_exit interface~util_fill util_fill proc~symba_util_fill_tp->interface~util_fill util_fill_tp util_fill_tp proc~symba_util_fill_tp->util_fill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"interface/symba_util_fill_tp.html"},{"title":"symba_util_peri_pl – swiftest","text":"interface Calls interface~~symba_util_peri_pl~~CallsGraph interface~symba_util_peri_pl symba_util_peri_pl proc~symba_util_peri_pl symba_util_peri_pl interface~symba_util_peri_pl->proc~symba_util_peri_pl orbel_xv2aeq orbel_xv2aeq proc~symba_util_peri_pl->orbel_xv2aeq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_peri_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/symba_util_peri_pl.html"},{"title":"symba_util_rearray_pl – swiftest","text":"interface Calls interface~~symba_util_rearray_pl~~CallsGraph interface~symba_util_rearray_pl symba_util_rearray_pl proc~symba_util_rearray_pl symba_util_rearray_pl interface~symba_util_rearray_pl->proc~symba_util_rearray_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_rearray_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions","tags":"","loc":"interface/symba_util_rearray_pl.html"},{"title":"symba_util_reset_kinship – swiftest","text":"interface Calls interface~~symba_util_reset_kinship~~CallsGraph interface~symba_util_reset_kinship symba_util_reset_kinship proc~symba_util_reset_kinship symba_util_reset_kinship interface~symba_util_reset_kinship->proc~symba_util_reset_kinship Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_reset_kinship(self, idx) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: idx Index array of bodies to reset","tags":"","loc":"interface/symba_util_reset_kinship.html"},{"title":"util_resize – swiftest","text":"public interface util_resize Called by interface~~util_resize~~CalledByGraph interface~util_resize util_resize proc~symba_util_resize_merger symba_util_resize_merger proc~symba_util_resize_merger->interface~util_resize interface~symba_util_resize_pl symba_util_resize_pl proc~symba_util_resize_merger->interface~symba_util_resize_pl proc~symba_util_append_arr_kin symba_util_append_arr_kin proc~symba_util_append_arr_kin->interface~util_resize proc~symba_util_resize_tp symba_util_resize_tp proc~symba_util_resize_tp->interface~util_resize proc~symba_util_resize_pl symba_util_resize_pl proc~symba_util_resize_pl->interface~util_resize interface~symba_util_resize_tp symba_util_resize_tp interface~symba_util_resize_tp->proc~symba_util_resize_tp interface~symba_util_resize_pl->proc~symba_util_resize_pl interface~symba_util_resize_merger symba_util_resize_merger interface~symba_util_resize_merger->proc~symba_util_resize_merger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines symba_util_resize_arr_kin Subroutines public subroutine symba_util_resize_arr_kin(arr, nnew) Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size","tags":"","loc":"interface/util_resize.html"},{"title":"symba_util_resize_merger – swiftest","text":"interface Calls interface~~symba_util_resize_merger~~CallsGraph interface~symba_util_resize_merger symba_util_resize_merger proc~symba_util_resize_merger symba_util_resize_merger interface~symba_util_resize_merger->proc~symba_util_resize_merger interface~symba_util_resize_pl symba_util_resize_pl proc~symba_util_resize_merger->interface~symba_util_resize_pl interface~util_resize util_resize proc~symba_util_resize_merger->interface~util_resize proc~symba_util_resize_pl symba_util_resize_pl interface~symba_util_resize_pl->proc~symba_util_resize_pl proc~symba_util_resize_pl->interface~util_resize util_resize_pl util_resize_pl proc~symba_util_resize_pl->util_resize_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_resize_merger(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA merger list object integer(kind=I4B), intent(in) :: nnew New size neded","tags":"","loc":"interface/symba_util_resize_merger.html"},{"title":"symba_util_resize_pl – swiftest","text":"interface Calls interface~~symba_util_resize_pl~~CallsGraph interface~symba_util_resize_pl symba_util_resize_pl proc~symba_util_resize_pl symba_util_resize_pl interface~symba_util_resize_pl->proc~symba_util_resize_pl util_resize_pl util_resize_pl proc~symba_util_resize_pl->util_resize_pl interface~util_resize util_resize proc~symba_util_resize_pl->interface~util_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~symba_util_resize_pl~~CalledByGraph interface~symba_util_resize_pl symba_util_resize_pl proc~symba_util_resize_merger symba_util_resize_merger proc~symba_util_resize_merger->interface~symba_util_resize_pl interface~symba_util_resize_merger symba_util_resize_merger interface~symba_util_resize_merger->proc~symba_util_resize_merger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: nnew New size neded","tags":"","loc":"interface/symba_util_resize_pl.html"},{"title":"symba_util_resize_tp – swiftest","text":"interface Calls interface~~symba_util_resize_tp~~CallsGraph interface~symba_util_resize_tp symba_util_resize_tp proc~symba_util_resize_tp symba_util_resize_tp interface~symba_util_resize_tp->proc~symba_util_resize_tp util_resize_tp util_resize_tp proc~symba_util_resize_tp->util_resize_tp interface~util_resize util_resize proc~symba_util_resize_tp->interface~util_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: nnew New size neded","tags":"","loc":"interface/symba_util_resize_tp.html"},{"title":"symba_util_sort_pl – swiftest","text":"interface Calls interface~~symba_util_sort_pl~~CallsGraph interface~symba_util_sort_pl symba_util_sort_pl proc~symba_util_sort_pl symba_util_sort_pl interface~symba_util_sort_pl->proc~symba_util_sort_pl util_sort_pl util_sort_pl proc~symba_util_sort_pl->util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order","tags":"","loc":"interface/symba_util_sort_pl.html"},{"title":"symba_util_sort_tp – swiftest","text":"interface Calls interface~~symba_util_sort_tp~~CallsGraph interface~symba_util_sort_tp symba_util_sort_tp proc~symba_util_sort_tp symba_util_sort_tp interface~symba_util_sort_tp->proc~symba_util_sort_tp util_sort_tp util_sort_tp proc~symba_util_sort_tp->util_sort_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order","tags":"","loc":"interface/symba_util_sort_tp.html"},{"title":"util_sort_rearrange – swiftest","text":"public interface util_sort_rearrange Called by interface~~util_sort_rearrange~~CalledByGraph interface~util_sort_rearrange util_sort_rearrange proc~symba_util_sort_rearrange_tp symba_util_sort_rearrange_tp proc~symba_util_sort_rearrange_tp->interface~util_sort_rearrange proc~symba_util_sort_rearrange_pl symba_util_sort_rearrange_pl proc~symba_util_sort_rearrange_pl->interface~util_sort_rearrange interface~symba_util_sort_rearrange_pl symba_util_sort_rearrange_pl interface~symba_util_sort_rearrange_pl->proc~symba_util_sort_rearrange_pl interface~symba_util_sort_rearrange_tp symba_util_sort_rearrange_tp interface~symba_util_sort_rearrange_tp->proc~symba_util_sort_rearrange_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines symba_util_sort_rearrange_arr_kin Subroutines public subroutine symba_util_sort_rearrange_arr_kin(arr, ind, n) Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange","tags":"","loc":"interface/util_sort_rearrange.html"},{"title":"symba_util_sort_rearrange_pl – swiftest","text":"interface Calls interface~~symba_util_sort_rearrange_pl~~CallsGraph interface~symba_util_sort_rearrange_pl symba_util_sort_rearrange_pl proc~symba_util_sort_rearrange_pl symba_util_sort_rearrange_pl interface~symba_util_sort_rearrange_pl->proc~symba_util_sort_rearrange_pl util_sort_rearrange_pl util_sort_rearrange_pl proc~symba_util_sort_rearrange_pl->util_sort_rearrange_pl interface~util_sort_rearrange util_sort_rearrange proc~symba_util_sort_rearrange_pl->interface~util_sort_rearrange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order)","tags":"","loc":"interface/symba_util_sort_rearrange_pl.html"},{"title":"symba_util_sort_rearrange_tp – swiftest","text":"interface Calls interface~~symba_util_sort_rearrange_tp~~CallsGraph interface~symba_util_sort_rearrange_tp symba_util_sort_rearrange_tp proc~symba_util_sort_rearrange_tp symba_util_sort_rearrange_tp interface~symba_util_sort_rearrange_tp->proc~symba_util_sort_rearrange_tp util_sort_rearrange_tp util_sort_rearrange_tp proc~symba_util_sort_rearrange_tp->util_sort_rearrange_tp interface~util_sort_rearrange util_sort_rearrange proc~symba_util_sort_rearrange_tp->interface~util_sort_rearrange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order)","tags":"","loc":"interface/symba_util_sort_rearrange_tp.html"},{"title":"util_spill – swiftest","text":"public interface util_spill Called by interface~~util_spill~~CalledByGraph interface~util_spill util_spill proc~symba_util_spill_tp symba_util_spill_tp proc~symba_util_spill_tp->interface~util_spill proc~symba_util_spill_encounter symba_util_spill_encounter proc~symba_util_spill_encounter->interface~util_spill proc~symba_util_spill_pl symba_util_spill_pl proc~symba_util_spill_pl->interface~util_spill interface~symba_util_spill_pl symba_util_spill_pl interface~symba_util_spill_pl->proc~symba_util_spill_pl interface~symba_util_spill_encounter symba_util_spill_encounter interface~symba_util_spill_encounter->proc~symba_util_spill_encounter interface~symba_util_spill_tp symba_util_spill_tp interface~symba_util_spill_tp->proc~symba_util_spill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines symba_util_spill_arr_kin Subroutines public subroutine symba_util_spill_arr_kin(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_kinship ), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"interface/util_spill.html"},{"title":"symba_util_spill_pl – swiftest","text":"interface Calls interface~~symba_util_spill_pl~~CallsGraph interface~symba_util_spill_pl symba_util_spill_pl proc~symba_util_spill_pl symba_util_spill_pl interface~symba_util_spill_pl->proc~symba_util_spill_pl util_exit util_exit proc~symba_util_spill_pl->util_exit interface~util_spill util_spill proc~symba_util_spill_pl->interface~util_spill util_spill_pl util_spill_pl proc~symba_util_spill_pl->util_spill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"interface/symba_util_spill_pl.html"},{"title":"symba_util_spill_encounter – swiftest","text":"interface Calls interface~~symba_util_spill_encounter~~CallsGraph interface~symba_util_spill_encounter symba_util_spill_encounter proc~symba_util_spill_encounter symba_util_spill_encounter interface~symba_util_spill_encounter->proc~symba_util_spill_encounter util_exit util_exit proc~symba_util_spill_encounter->util_exit interface~util_spill util_spill proc~symba_util_spill_encounter->interface~util_spill util_spill_encounter util_spill_encounter proc~symba_util_spill_encounter->util_spill_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_spill_encounter(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-tp encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list","tags":"","loc":"interface/symba_util_spill_encounter.html"},{"title":"symba_util_spill_tp – swiftest","text":"interface Calls interface~~symba_util_spill_tp~~CallsGraph interface~symba_util_spill_tp symba_util_spill_tp proc~symba_util_spill_tp symba_util_spill_tp interface~symba_util_spill_tp->proc~symba_util_spill_tp util_exit util_exit proc~symba_util_spill_tp->util_exit interface~util_spill util_spill proc~symba_util_spill_tp->interface~util_spill util_spill_tp util_spill_tp proc~symba_util_spill_tp->util_spill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine symba_util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"interface/symba_util_spill_tp.html"},{"title":"io_get_args – swiftest","text":"interface Calls interface~~io_get_args~~CallsGraph interface~io_get_args io_get_args proc~io_get_args io_get_args interface~io_get_args->proc~io_get_args interface~util_version util_version proc~io_get_args->interface~util_version interface~util_exit util_exit proc~io_get_args->interface~util_exit interface~io_toupper io_toupper proc~io_get_args->interface~io_toupper proc~util_version util_version interface~util_version->proc~util_version proc~util_exit util_exit interface~util_exit->proc~util_exit proc~io_toupper io_toupper interface~io_toupper->proc~io_toupper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function io_get_args(integrator, param_file_name) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=I4B) :: integrator Symbolic code of the requested integrator character(len=:), allocatable :: param_file_name Name of the input parameters file Return Value integer(kind=I4B) I/O error code","tags":"","loc":"interface/io_get_args.html"},{"title":"io_get_old_t_final_system – swiftest","text":"interface Calls interface~~io_get_old_t_final_system~~CallsGraph interface~io_get_old_t_final_system io_get_old_t_final_system proc~io_get_old_t_final_system io_get_old_t_final_system interface~io_get_old_t_final_system->proc~io_get_old_t_final_system interface~util_exit util_exit proc~io_get_old_t_final_system->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function io_get_old_t_final_system(self, param) result(old_t_final) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self class( swiftest_parameters ), intent(in) :: param Return Value real(kind=DP)","tags":"","loc":"interface/io_get_old_t_final_system.html"},{"title":"io_get_token – swiftest","text":"interface Calls interface~~io_get_token~~CallsGraph interface~io_get_token io_get_token proc~io_get_token io_get_token interface~io_get_token->proc~io_get_token Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~io_get_token~~CalledByGraph interface~io_get_token io_get_token proc~io_param_reader io_param_reader proc~io_param_reader->interface~io_get_token interface~io_param_reader io_param_reader interface~io_param_reader->proc~io_param_reader Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function io_get_token(buffer, ifirst, ilast, ierr) result(token) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: buffer Input string buffer integer(kind=I4B), intent(inout) :: ifirst Index of the buffer at which to start the search for a token integer(kind=I4B), intent(out) :: ilast Index of the buffer at the end of the returned token integer(kind=I4B), intent(out) :: ierr Error code Return Value character(len=:),\n  allocatable Returned token string","tags":"","loc":"interface/io_get_token.html"},{"title":"io_read_frame_body – swiftest","text":"interface Calls interface~~io_read_frame_body~~CallsGraph interface~io_read_frame_body io_read_frame_body proc~io_read_frame_body io_read_frame_body interface~io_read_frame_body->proc~io_read_frame_body interface~util_exit util_exit proc~io_read_frame_body->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function io_read_frame_body(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful","tags":"","loc":"interface/io_read_frame_body.html"},{"title":"io_read_frame_cb – swiftest","text":"interface Calls interface~~io_read_frame_cb~~CallsGraph interface~io_read_frame_cb io_read_frame_cb proc~io_read_frame_cb io_read_frame_cb interface~io_read_frame_cb->proc~io_read_frame_cb interface~util_exit util_exit proc~io_read_frame_cb->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function io_read_frame_cb(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful","tags":"","loc":"interface/io_read_frame_cb.html"},{"title":"io_read_frame_system – swiftest","text":"interface Calls interface~~io_read_frame_system~~CallsGraph interface~io_read_frame_system io_read_frame_system proc~io_read_frame_system io_read_frame_system interface~io_read_frame_system->proc~io_read_frame_system proc~io_read_hdr io_read_hdr proc~io_read_frame_system->proc~io_read_hdr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function io_read_frame_system(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful","tags":"","loc":"interface/io_read_frame_system.html"},{"title":"discard_pl – swiftest","text":"interface Calls interface~~discard_pl~~CallsGraph interface~discard_pl discard_pl proc~discard_pl discard_pl interface~discard_pl->proc~discard_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine discard_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameter","tags":"","loc":"interface/discard_pl.html"},{"title":"discard_system – swiftest","text":"interface Calls interface~~discard_system~~CallsGraph interface~discard_system discard_system proc~discard_system discard_system interface~discard_system->proc~discard_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine discard_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/discard_system.html"},{"title":"discard_tp – swiftest","text":"interface Calls interface~~discard_tp~~CallsGraph interface~discard_tp discard_tp proc~discard_tp discard_tp interface~discard_tp->proc~discard_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine discard_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/discard_tp.html"},{"title":"drift_all – swiftest","text":"interface Calls interface~~drift_all~~CallsGraph interface~drift_all drift_all proc~drift_all drift_all interface~drift_all->proc~drift_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~drift_all~~CalledByGraph interface~drift_all drift_all proc~drift_body drift_body proc~drift_body->interface~drift_all interface~drift_body drift_body interface~drift_body->proc~drift_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine drift_all(mu, x, v, n, param, dt, lmask, iflag) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: mu Vector of gravitational constants real(kind=DP), intent(inout), dimension(:,:) :: x Position and velocity vectors real(kind=DP), intent(inout), dimension(:,:) :: v Position and velocity vectors integer(kind=I4B), intent(in) :: n number of bodies class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize logical, intent(in), dimension(:) :: lmask Logical mask of size self%nbody that determines which bodies to drift. integer(kind=I4B), intent(out), dimension(:) :: iflag Vector of error flags. 0 means no problem","tags":"","loc":"interface/drift_all.html"},{"title":"drift_body – swiftest","text":"interface Calls interface~~drift_body~~CallsGraph interface~drift_body drift_body proc~drift_body drift_body interface~drift_body->proc~drift_body interface~drift_all drift_all proc~drift_body->interface~drift_all proc~drift_all drift_all interface~drift_all->proc~drift_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine drift_body(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"interface/drift_body.html"},{"title":"drift_one – swiftest","text":"interface Calls interface~~drift_one~~CallsGraph interface~drift_one drift_one proc~drift_one drift_one interface~drift_one->proc~drift_one Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure elemental module subroutine drift_one(mu, px, py, pz, vx, vy, vz, dt, iflag) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body to drift real(kind=DP), intent(inout) :: px Position and velocity of body to drift real(kind=DP), intent(inout) :: py Position and velocity of body to drift real(kind=DP), intent(inout) :: pz Position and velocity of body to drift real(kind=DP), intent(inout) :: vx Position and velocity of body to drift real(kind=DP), intent(inout) :: vy Position and velocity of body to drift real(kind=DP), intent(inout) :: vz Position and velocity of body to drift real(kind=DP), intent(in) :: dt Step size integer(kind=I4B), intent(out) :: iflag iflag : error status flag for Danby drift (0 = OK, nonzero = ERROR)","tags":"","loc":"interface/drift_one.html"},{"title":"util_index_eucl_ij_to_k – swiftest","text":"interface Calls interface~~util_index_eucl_ij_to_k~~CallsGraph interface~util_index_eucl_ij_to_k util_index_eucl_ij_to_k proc~util_index_eucl_ij_to_k util_index_eucl_ij_to_k interface~util_index_eucl_ij_to_k->proc~util_index_eucl_ij_to_k Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~util_index_eucl_ij_to_k~~CalledByGraph interface~util_index_eucl_ij_to_k util_index_eucl_ij_to_k proc~util_index_eucl_plpl util_index_eucl_plpl proc~util_index_eucl_plpl->interface~util_index_eucl_ij_to_k interface~util_index_eucl_plpl util_index_eucl_plpl interface~util_index_eucl_plpl->proc~util_index_eucl_plpl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine util_index_eucl_ij_to_k(n, i, j, k) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n Number of bodies integer(kind=I4B), intent(in) :: i Index of the ith body integer(kind=I4B), intent(in) :: j Index of the jth body integer(kind=I8B), intent(out) :: k Index of the flattened matrix","tags":"","loc":"interface/util_index_eucl_ij_to_k.html"},{"title":"util_index_eucl_k_to_ij – swiftest","text":"interface Calls interface~~util_index_eucl_k_to_ij~~CallsGraph interface~util_index_eucl_k_to_ij util_index_eucl_k_to_ij proc~util_index_eucl_k_to_ij util_index_eucl_k_to_ij interface~util_index_eucl_k_to_ij->proc~util_index_eucl_k_to_ij Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine util_index_eucl_k_to_ij(n, k, i, j) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n Number of bodies integer(kind=I8B), intent(in) :: k Index of the flattened matrix integer(kind=I4B), intent(out) :: i Index of the ith body integer(kind=I4B), intent(out) :: j Index of the jth body","tags":"","loc":"interface/util_index_eucl_k_to_ij.html"},{"title":"util_index_eucl_plpl – swiftest","text":"interface Calls interface~~util_index_eucl_plpl~~CallsGraph interface~util_index_eucl_plpl util_index_eucl_plpl proc~util_index_eucl_plpl util_index_eucl_plpl interface~util_index_eucl_plpl->proc~util_index_eucl_plpl interface~util_index_eucl_ij_to_k util_index_eucl_ij_to_k proc~util_index_eucl_plpl->interface~util_index_eucl_ij_to_k proc~util_index_eucl_ij_to_k util_index_eucl_ij_to_k interface~util_index_eucl_ij_to_k->proc~util_index_eucl_ij_to_k Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_index_eucl_plpl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/util_index_eucl_plpl.html"},{"title":"util_index_eucl_pltp – swiftest","text":"interface Calls interface~~util_index_eucl_pltp~~CallsGraph interface~util_index_eucl_pltp util_index_eucl_pltp proc~util_index_eucl_pltp util_index_eucl_pltp interface~util_index_eucl_pltp->proc~util_index_eucl_pltp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_index_eucl_pltp(self, pl, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_pl ), intent(in) :: pl Swiftest massive body object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/util_index_eucl_pltp.html"},{"title":"gr_kick_getaccb_ns_body – swiftest","text":"interface Calls interface~~gr_kick_getaccb_ns_body~~CallsGraph interface~gr_kick_getaccb_ns_body gr_kick_getaccb_ns_body proc~gr_kick_getaccb_ns_body gr_kick_getaccb_ns_body interface~gr_kick_getaccb_ns_body->proc~gr_kick_getaccb_ns_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine gr_kick_getaccb_ns_body(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/gr_kick_getaccb_ns_body.html"},{"title":"gr_kick_getacch – swiftest","text":"interface Calls interface~~gr_kick_getacch~~CallsGraph interface~gr_kick_getacch gr_kick_getacch proc~gr_kick_getacch gr_kick_getacch interface~gr_kick_getacch->proc~gr_kick_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine gr_kick_getacch(mu, x, lmask, n, inv_c2, agr) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:,:) :: x Position vectors logical, intent(in), dimension(:) :: lmask Logical mask indicating which bodies to compute integer(kind=I4B), intent(in) :: n Total number of bodies real(kind=DP), intent(in) :: inv_c2 Inverse speed of light squared: 1 / c**2 real(kind=DP), intent(out), dimension(:,:) :: agr Accelerations","tags":"","loc":"interface/gr_kick_getacch.html"},{"title":"gr_p4_pos_kick – swiftest","text":"interface Calls interface~~gr_p4_pos_kick~~CallsGraph interface~gr_p4_pos_kick gr_p4_pos_kick proc~gr_p4_pos_kick gr_p4_pos_kick interface~gr_p4_pos_kick->proc~gr_p4_pos_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine gr_p4_pos_kick(param, x, v, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(inout), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(in) :: dt Step size","tags":"","loc":"interface/gr_p4_pos_kick.html"},{"title":"gr_pseudovel2vel – swiftest","text":"interface Calls interface~~gr_pseudovel2vel~~CallsGraph interface~gr_pseudovel2vel gr_pseudovel2vel proc~gr_pseudovel2vel gr_pseudovel2vel interface~gr_pseudovel2vel->proc~gr_pseudovel2vel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine gr_pseudovel2vel(param, mu, xh, pv, vh) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real(kind=DP), intent(in), dimension(:) :: xh Swiftestcentric position vector real(kind=DP), intent(in), dimension(:) :: pv Pseudovelocity velocity vector - see Saha & Tremain (1994), eq. (32) real(kind=DP), intent(out), dimension(:) :: vh Swiftestcentric velocity vector","tags":"","loc":"interface/gr_pseudovel2vel.html"},{"title":"gr_pv2vh_body – swiftest","text":"interface Calls interface~~gr_pv2vh_body~~CallsGraph interface~gr_pv2vh_body gr_pv2vh_body proc~gr_pv2vh_body gr_pv2vh_body interface~gr_pv2vh_body->proc~gr_pv2vh_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/gr_pv2vh_body.html"},{"title":"gr_vel2pseudovel – swiftest","text":"interface Calls interface~~gr_vel2pseudovel~~CallsGraph interface~gr_vel2pseudovel gr_vel2pseudovel proc~gr_vel2pseudovel gr_vel2pseudovel interface~gr_vel2pseudovel->proc~gr_vel2pseudovel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine gr_vel2pseudovel(param, mu, xh, vh, pv) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real(kind=DP), intent(in), dimension(:) :: xh Swiftestcentric position vector real(kind=DP), intent(in), dimension(:) :: vh Swiftestcentric velocity vector real(kind=DP), intent(out), dimension(:) :: pv Pseudovelocity vector - see Saha & Tremain (1994), eq. (32)","tags":"","loc":"interface/gr_vel2pseudovel.html"},{"title":"gr_vh2pv_body – swiftest","text":"interface Calls interface~~gr_vh2pv_body~~CallsGraph interface~gr_vh2pv_body gr_vh2pv_body proc~gr_vh2pv_body gr_vh2pv_body interface~gr_vh2pv_body->proc~gr_vh2pv_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/gr_vh2pv_body.html"},{"title":"io_conservation_report – swiftest","text":"interface Calls interface~~io_conservation_report~~CallsGraph interface~io_conservation_report io_conservation_report proc~io_conservation_report io_conservation_report interface~io_conservation_report->proc~io_conservation_report interface~util_exit util_exit proc~io_conservation_report->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_conservation_report(self, param, lterminal) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Input colleciton of user-defined parameters logical, intent(in) :: lterminal Indicates whether to output information to the terminal screen","tags":"","loc":"interface/io_conservation_report.html"},{"title":"io_dump_param – swiftest","text":"interface Calls interface~~io_dump_param~~CallsGraph interface~io_dump_param io_dump_param proc~io_dump_param io_dump_param interface~io_dump_param->proc~io_dump_param interface~util_exit util_exit proc~io_dump_param->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_dump_param(self, param_file_name) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Output collection of parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in)","tags":"","loc":"interface/io_dump_param.html"},{"title":"io_dump_particle_info_base – swiftest","text":"interface Calls interface~~io_dump_particle_info_base~~CallsGraph interface~io_dump_particle_info_base io_dump_particle_info_base proc~io_dump_particle_info_base io_dump_particle_info_base interface~io_dump_particle_info_base->proc~io_dump_particle_info_base interface~util_exit util_exit proc~io_dump_particle_info_base->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_dump_particle_info_base(self, param, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file","tags":"","loc":"interface/io_dump_particle_info_base.html"},{"title":"io_dump_particle_info – swiftest","text":"interface Calls interface~~io_dump_particle_info~~CallsGraph interface~io_dump_particle_info io_dump_particle_info proc~io_dump_particle_info io_dump_particle_info interface~io_dump_particle_info->proc~io_dump_particle_info interface~util_exit util_exit proc~io_dump_particle_info->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_dump_particle_info(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(in) :: self Swiftest particle info metadata object integer(kind=I4B), intent(in) :: iu Open unformatted file unit number","tags":"","loc":"interface/io_dump_particle_info.html"},{"title":"io_dump_base – swiftest","text":"interface Calls interface~~io_dump_base~~CallsGraph interface~io_dump_base io_dump_base proc~io_dump_base io_dump_base interface~io_dump_base->proc~io_dump_base interface~util_exit util_exit proc~io_dump_base->interface~util_exit interface~io_write_frame_cb io_write_frame_cb proc~io_dump_base->interface~io_write_frame_cb interface~io_write_frame_body io_write_frame_body proc~io_dump_base->interface~io_write_frame_body proc~util_exit util_exit interface~util_exit->proc~util_exit proc~io_write_frame_cb io_write_frame_cb interface~io_write_frame_cb->proc~io_write_frame_cb proc~io_write_frame_body io_write_frame_body interface~io_write_frame_body->proc~io_write_frame_body proc~io_write_frame_body->interface~util_exit proc~io_write_frame_cb->interface~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_dump_base(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/io_dump_base.html"},{"title":"io_dump_system – swiftest","text":"interface Calls interface~~io_dump_system~~CallsGraph interface~io_dump_system io_dump_system proc~io_dump_system io_dump_system interface~io_dump_system->proc~io_dump_system dump_tp_file dump_tp_file proc~io_dump_system->dump_tp_file dump_param_file dump_param_file proc~io_dump_system->dump_param_file dump_pl_file dump_pl_file proc~io_dump_system->dump_pl_file dump_cb_file dump_cb_file proc~io_dump_system->dump_cb_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_dump_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/io_dump_system.html"},{"title":"io_param_reader – swiftest","text":"interface Calls interface~~io_param_reader~~CallsGraph interface~io_param_reader io_param_reader proc~io_param_reader io_param_reader interface~io_param_reader->proc~io_param_reader interface~io_get_token io_get_token proc~io_param_reader->interface~io_get_token interface~io_toupper io_toupper proc~io_param_reader->interface~io_toupper proc~io_get_token io_get_token interface~io_get_token->proc~io_get_token proc~io_toupper io_toupper interface~io_toupper->proc~io_toupper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_param_reader(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Collection of parameters integer(kind=I4B), intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer(kind=I4B), intent(in) :: v_list (:) The first element passes the integrator code to the reader integer(kind=I4B), intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0","tags":"","loc":"interface/io_param_reader.html"},{"title":"io_param_writer – swiftest","text":"interface Calls interface~~io_param_writer~~CallsGraph interface~io_param_writer io_param_writer proc~io_param_writer io_param_writer interface~io_param_writer->proc~io_param_writer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_param_writer(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Collection of parameters integer(kind=I4B), intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer(kind=I4B), intent(in) :: v_list (:) Not used in this procedure integer(kind=I4B), intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0","tags":"","loc":"interface/io_param_writer.html"},{"title":"io_read_in_body – swiftest","text":"interface Calls interface~~io_read_in_body~~CallsGraph interface~io_read_in_body io_read_in_body proc~io_read_in_body io_read_in_body interface~io_read_in_body->proc~io_read_in_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_read_in_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/io_read_in_body.html"},{"title":"io_read_in_cb – swiftest","text":"interface Calls interface~~io_read_in_cb~~CallsGraph interface~io_read_in_cb io_read_in_cb proc~io_read_in_cb io_read_in_cb interface~io_read_in_cb->proc~io_read_in_cb interface~util_exit util_exit proc~io_read_in_cb->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_read_in_cb(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/io_read_in_cb.html"},{"title":"io_read_in_param – swiftest","text":"interface Calls interface~~io_read_in_param~~CallsGraph interface~io_read_in_param io_read_in_param proc~io_read_in_param io_read_in_param interface~io_read_in_param->proc~io_read_in_param interface~util_exit util_exit proc~io_read_in_param->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_read_in_param(self, param_file_name) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Current run configuration parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in)","tags":"","loc":"interface/io_read_in_param.html"},{"title":"io_read_in_particle_info – swiftest","text":"interface Calls interface~~io_read_in_particle_info~~CallsGraph interface~io_read_in_particle_info io_read_in_particle_info proc~io_read_in_particle_info io_read_in_particle_info interface~io_read_in_particle_info->proc~io_read_in_particle_info interface~util_exit util_exit proc~io_read_in_particle_info->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_read_in_particle_info(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(inout) :: self Particle metadata information object integer(kind=I4B), intent(in) :: iu Open file unit number","tags":"","loc":"interface/io_read_in_particle_info.html"},{"title":"io_read_particle_info_system – swiftest","text":"interface Calls interface~~io_read_particle_info_system~~CallsGraph interface~io_read_particle_info_system io_read_particle_info_system proc~io_read_particle_info_system io_read_particle_info_system interface~io_read_particle_info_system->proc~io_read_particle_info_system interface~util_exit util_exit proc~io_read_particle_info_system->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_read_particle_info_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/io_read_particle_info_system.html"},{"title":"io_write_discard – swiftest","text":"interface Calls interface~~io_write_discard~~CallsGraph interface~io_write_discard io_write_discard proc~io_write_discard io_write_discard interface~io_write_discard->proc~io_write_discard interface~util_exit util_exit proc~io_write_discard->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_write_discard(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/io_write_discard.html"},{"title":"io_toupper – swiftest","text":"interface Calls interface~~io_toupper~~CallsGraph interface~io_toupper io_toupper proc~io_toupper io_toupper interface~io_toupper->proc~io_toupper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~io_toupper~~CalledByGraph interface~io_toupper io_toupper proc~io_get_args io_get_args proc~io_get_args->interface~io_toupper proc~io_param_reader io_param_reader proc~io_param_reader->interface~io_toupper interface~io_get_args io_get_args interface~io_get_args->proc~io_get_args interface~io_param_reader io_param_reader interface~io_param_reader->proc~io_param_reader Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_toupper(string) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string String to make upper case","tags":"","loc":"interface/io_toupper.html"},{"title":"io_write_encounter – swiftest","text":"interface Calls interface~~io_write_encounter~~CallsGraph interface~io_write_encounter io_write_encounter proc~io_write_encounter io_write_encounter interface~io_write_encounter->proc~io_write_encounter ind1 ind1 proc~io_write_encounter->ind1 interface~util_exit util_exit proc~io_write_encounter->interface~util_exit ind2 ind2 proc~io_write_encounter->ind2 proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_write_encounter(self, pl, encbody, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(in) :: self Swiftest encounter list object class( swiftest_pl ), intent(in) :: pl Swiftest massive body object class( swiftest_body ), intent(in) :: encbody Encountering body - Swiftest generic body object (pl or tp) class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/io_write_encounter.html"},{"title":"io_write_frame_body – swiftest","text":"interface Calls interface~~io_write_frame_body~~CallsGraph interface~io_write_frame_body io_write_frame_body proc~io_write_frame_body io_write_frame_body interface~io_write_frame_body->proc~io_write_frame_body interface~util_exit util_exit proc~io_write_frame_body->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~io_write_frame_body~~CalledByGraph interface~io_write_frame_body io_write_frame_body proc~io_dump_base io_dump_base proc~io_dump_base->interface~io_write_frame_body interface~io_dump_base io_dump_base interface~io_dump_base->proc~io_dump_base Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/io_write_frame_body.html"},{"title":"io_write_frame_cb – swiftest","text":"interface Calls interface~~io_write_frame_cb~~CallsGraph interface~io_write_frame_cb io_write_frame_cb proc~io_write_frame_cb io_write_frame_cb interface~io_write_frame_cb->proc~io_write_frame_cb interface~util_exit util_exit proc~io_write_frame_cb->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~io_write_frame_cb~~CalledByGraph interface~io_write_frame_cb io_write_frame_cb proc~io_dump_base io_dump_base proc~io_dump_base->interface~io_write_frame_cb interface~io_dump_base io_dump_base interface~io_dump_base->proc~io_dump_base Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_write_frame_cb(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/io_write_frame_cb.html"},{"title":"io_write_frame_encounter – swiftest","text":"interface Calls interface~~io_write_frame_encounter~~CallsGraph interface~io_write_frame_encounter io_write_frame_encounter proc~io_write_frame_encounter io_write_frame_encounter interface~io_write_frame_encounter->proc~io_write_frame_encounter interface~util_exit util_exit proc~io_write_frame_encounter->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_write_frame_encounter(iu, t, id1, id2, Gmass1, Gmass2, radius1, radius2, xh1, xh2, vh1, vh2) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu Open file unit number real(kind=DP), intent(in) :: t Time of encounter integer(kind=I4B), intent(in) :: id1 ids of the two encountering bodies integer(kind=I4B), intent(in) :: id2 ids of the two encountering bodies real(kind=DP), intent(in) :: Gmass1 G*mass of the two encountering bodies real(kind=DP), intent(in) :: Gmass2 G*mass of the two encountering bodies real(kind=DP), intent(in) :: radius1 Radii of the two encountering bodies real(kind=DP), intent(in) :: radius2 Radii of the two encountering bodies real(kind=DP), intent(in), dimension(:) :: xh1 Swiftestcentric position vectors of the two encountering bodies real(kind=DP), intent(in), dimension(:) :: xh2 Swiftestcentric position vectors of the two encountering bodies real(kind=DP), intent(in), dimension(:) :: vh1 Swiftestcentric velocity vectors of the two encountering bodies real(kind=DP), intent(in), dimension(:) :: vh2 Swiftestcentric velocity vectors of the two encountering bodies","tags":"","loc":"interface/io_write_frame_encounter.html"},{"title":"io_write_frame_system – swiftest","text":"interface Calls interface~~io_write_frame_system~~CallsGraph interface~io_write_frame_system io_write_frame_system proc~io_write_frame_system io_write_frame_system interface~io_write_frame_system->proc~io_write_frame_system interface~util_exit util_exit proc~io_write_frame_system->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_write_frame_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/io_write_frame_system.html"},{"title":"io_write_hdr_system – swiftest","text":"interface Calls interface~~io_write_hdr_system~~CallsGraph interface~io_write_hdr_system io_write_hdr_system proc~io_write_hdr_system io_write_hdr_system interface~io_write_hdr_system->proc~io_write_hdr_system interface~util_exit util_exit proc~io_write_hdr_system->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine io_write_hdr_system(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest nbody system object integer(kind=I4B), intent(inout) :: iu Output file unit number class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/io_write_hdr_system.html"},{"title":"kick_getacch_int_pl – swiftest","text":"interface Calls interface~~kick_getacch_int_pl~~CallsGraph interface~kick_getacch_int_pl kick_getacch_int_pl proc~kick_getacch_int_pl kick_getacch_int_pl interface~kick_getacch_int_pl->proc~kick_getacch_int_pl interface~kick_getacch_int_all_pl kick_getacch_int_all_pl proc~kick_getacch_int_pl->interface~kick_getacch_int_all_pl proc~kick_getacch_int_all_pl kick_getacch_int_all_pl interface~kick_getacch_int_all_pl->proc~kick_getacch_int_all_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine kick_getacch_int_pl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object","tags":"","loc":"interface/kick_getacch_int_pl.html"},{"title":"kick_getacch_int_tp – swiftest","text":"interface Calls interface~~kick_getacch_int_tp~~CallsGraph interface~kick_getacch_int_tp kick_getacch_int_tp proc~kick_getacch_int_tp kick_getacch_int_tp interface~kick_getacch_int_tp->proc~kick_getacch_int_tp interface~kick_getacch_int_all_tp kick_getacch_int_all_tp proc~kick_getacch_int_tp->interface~kick_getacch_int_all_tp proc~kick_getacch_int_all_tp kick_getacch_int_all_tp interface~kick_getacch_int_all_tp->proc~kick_getacch_int_all_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine kick_getacch_int_tp(self, GMpl, xhp, npl) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle real(kind=DP), intent(in), dimension(:) :: GMpl Massive body masses real(kind=DP), intent(in), dimension(:,:) :: xhp Massive body position vectors integer(kind=I4B), intent(in) :: npl Number of active massive bodies","tags":"","loc":"interface/kick_getacch_int_tp.html"},{"title":"kick_getacch_int_all_pl – swiftest","text":"interface Calls interface~~kick_getacch_int_all_pl~~CallsGraph interface~kick_getacch_int_all_pl kick_getacch_int_all_pl proc~kick_getacch_int_all_pl kick_getacch_int_all_pl interface~kick_getacch_int_all_pl->proc~kick_getacch_int_all_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~kick_getacch_int_all_pl~~CalledByGraph interface~kick_getacch_int_all_pl kick_getacch_int_all_pl proc~kick_getacch_int_pl kick_getacch_int_pl proc~kick_getacch_int_pl->interface~kick_getacch_int_all_pl interface~kick_getacch_int_pl kick_getacch_int_pl interface~kick_getacch_int_pl->proc~kick_getacch_int_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine kick_getacch_int_all_pl(npl, nplpl, k_plpl, x, Gmass, radius, acc) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl Number of massive bodies integer(kind=I8B), intent(in) :: nplpl Number of massive body interactions to compute integer(kind=I4B), intent(in), dimension(:,:) :: k_plpl Array of interaction pair indices (flattened upper triangular matrix) real(kind=DP), intent(in), dimension(:,:) :: x Position vector array real(kind=DP), intent(in), dimension(:) :: Gmass Array of massive body G*mass real(kind=DP), intent(in), dimension(:) :: radius Array of massive body radii real(kind=DP), intent(inout), dimension(:,:) :: acc Acceleration vector array","tags":"","loc":"interface/kick_getacch_int_all_pl.html"},{"title":"kick_getacch_int_all_tp – swiftest","text":"interface Calls interface~~kick_getacch_int_all_tp~~CallsGraph interface~kick_getacch_int_all_tp kick_getacch_int_all_tp proc~kick_getacch_int_all_tp kick_getacch_int_all_tp interface~kick_getacch_int_all_tp->proc~kick_getacch_int_all_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~kick_getacch_int_all_tp~~CalledByGraph interface~kick_getacch_int_all_tp kick_getacch_int_all_tp proc~kick_getacch_int_tp kick_getacch_int_tp proc~kick_getacch_int_tp->interface~kick_getacch_int_all_tp interface~kick_getacch_int_tp kick_getacch_int_tp interface~kick_getacch_int_tp->proc~kick_getacch_int_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine kick_getacch_int_all_tp(ntp, npl, xtp, xpl, GMpl, lmask, acc) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp Number of test particles integer(kind=I4B), intent(in) :: npl Number of massive bodies real(kind=DP), intent(in), dimension(:,:) :: xtp Test particle position vector array real(kind=DP), intent(in), dimension(:,:) :: xpl Massive body particle position vector array real(kind=DP), intent(in), dimension(:) :: GMpl Array of massive body G*mass logical, intent(in), dimension(:) :: lmask Logical mask indicating which test particles should be computed real(kind=DP), intent(inout), dimension(:,:) :: acc Acceleration vector array","tags":"","loc":"interface/kick_getacch_int_all_tp.html"},{"title":"kick_getacch_int_one_pl – swiftest","text":"interface Calls interface~~kick_getacch_int_one_pl~~CallsGraph interface~kick_getacch_int_one_pl kick_getacch_int_one_pl proc~kick_getacch_int_one_pl kick_getacch_int_one_pl interface~kick_getacch_int_one_pl->proc~kick_getacch_int_one_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine kick_getacch_int_one_pl(rji2, xr, yr, zr, Gmi, Gmj, axi, ayi, azi, axj, ayj, azj) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: rji2 Square of distance between the two bodies real(kind=DP), intent(in) :: xr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: yr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: zr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: Gmi G*mass of body i real(kind=DP), intent(in) :: Gmj G*mass of body j real(kind=DP), intent(inout) :: axi Acceleration vector components of body i real(kind=DP), intent(inout) :: ayi Acceleration vector components of body i real(kind=DP), intent(inout) :: azi Acceleration vector components of body i real(kind=DP), intent(inout) :: axj Acceleration vector components of body j real(kind=DP), intent(inout) :: ayj Acceleration vector components of body j real(kind=DP), intent(inout) :: azj Acceleration vector components of body j","tags":"","loc":"interface/kick_getacch_int_one_pl.html"},{"title":"kick_getacch_int_one_tp – swiftest","text":"interface Calls interface~~kick_getacch_int_one_tp~~CallsGraph interface~kick_getacch_int_one_tp kick_getacch_int_one_tp proc~kick_getacch_int_one_tp kick_getacch_int_one_tp interface~kick_getacch_int_one_tp->proc~kick_getacch_int_one_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine kick_getacch_int_one_tp(rji2, xr, yr, zr, Gmpl, ax, ay, az) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: rji2 Square of distance between the test particle and massive body real(kind=DP), intent(in) :: xr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: yr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: zr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: Gmpl G*mass of massive body real(kind=DP), intent(inout) :: ax Acceleration vector components of test particle real(kind=DP), intent(inout) :: ay Acceleration vector components of test particle real(kind=DP), intent(inout) :: az Acceleration vector components of test particle","tags":"","loc":"interface/kick_getacch_int_one_tp.html"},{"title":"netcdf_close – swiftest","text":"interface Calls interface~~netcdf_close~~CallsGraph interface~netcdf_close netcdf_close proc~netcdf_close netcdf_close interface~netcdf_close->proc~netcdf_close nf90_close nf90_close proc~netcdf_close->nf90_close Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine netcdf_close(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( netcdf_parameters ), intent(inout) :: self Parameters used to identify a particular NetCDF dataset class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/netcdf_close.html"},{"title":"netcdf_initialize_output – swiftest","text":"interface Calls interface~~netcdf_initialize_output~~CallsGraph interface~netcdf_initialize_output netcdf_initialize_output proc~netcdf_initialize_output netcdf_initialize_output interface~netcdf_initialize_output->proc~netcdf_initialize_output nf90_def_var nf90_def_var proc~netcdf_initialize_output->nf90_def_var nf90_def_dim nf90_def_dim proc~netcdf_initialize_output->nf90_def_dim nf90_create nf90_create proc~netcdf_initialize_output->nf90_create nf90_def_var_fill nf90_def_var_fill proc~netcdf_initialize_output->nf90_def_var_fill nf90_inquire nf90_inquire proc~netcdf_initialize_output->nf90_inquire nf90_inquire_variable nf90_inquire_variable proc~netcdf_initialize_output->nf90_inquire_variable Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine netcdf_initialize_output(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( netcdf_parameters ), intent(inout) :: self Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/netcdf_initialize_output.html"},{"title":"netcdf_open – swiftest","text":"interface Calls interface~~netcdf_open~~CallsGraph interface~netcdf_open netcdf_open proc~netcdf_open netcdf_open interface~netcdf_open->proc~netcdf_open nf90_inq_varid nf90_inq_varid proc~netcdf_open->nf90_inq_varid nf90_open nf90_open proc~netcdf_open->nf90_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine netcdf_open(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( netcdf_parameters ), intent(inout) :: self Parameters used to identify a particular NetCDF dataset class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/netcdf_open.html"},{"title":"netcdf_write_frame_base – swiftest","text":"interface Calls interface~~netcdf_write_frame_base~~CallsGraph interface~netcdf_write_frame_base netcdf_write_frame_base proc~netcdf_write_frame_base netcdf_write_frame_base interface~netcdf_write_frame_base->proc~netcdf_write_frame_base nf90_set_fill nf90_set_fill proc~netcdf_write_frame_base->nf90_set_fill nf90_put_var nf90_put_var proc~netcdf_write_frame_base->nf90_put_var interface~util_sort util_sort proc~netcdf_write_frame_base->interface~util_sort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine netcdf_write_frame_base(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/netcdf_write_frame_base.html"},{"title":"netcdf_write_frame_system – swiftest","text":"interface public subroutine netcdf_write_frame_system(self, iu, param) Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/netcdf_write_frame_system.html"},{"title":"netcdf_write_hdr_system – swiftest","text":"interface Calls interface~~netcdf_write_hdr_system~~CallsGraph interface~netcdf_write_hdr_system netcdf_write_hdr_system proc~netcdf_write_hdr_system netcdf_write_hdr_system interface~netcdf_write_hdr_system->proc~netcdf_write_hdr_system nf90_put_var nf90_put_var proc~netcdf_write_hdr_system->nf90_put_var nf90_open nf90_open proc~netcdf_write_hdr_system->nf90_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine netcdf_write_hdr_system(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest nbody system object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/netcdf_write_hdr_system.html"},{"title":"netcdf_write_particle_info_base – swiftest","text":"interface Calls interface~~netcdf_write_particle_info_base~~CallsGraph interface~netcdf_write_particle_info_base netcdf_write_particle_info_base proc~netcdf_write_particle_info_base netcdf_write_particle_info_base interface~netcdf_write_particle_info_base->proc~netcdf_write_particle_info_base nf90_set_fill nf90_set_fill proc~netcdf_write_particle_info_base->nf90_set_fill nf90_put_var nf90_put_var proc~netcdf_write_particle_info_base->nf90_put_var interface~util_sort util_sort proc~netcdf_write_particle_info_base->interface~util_sort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine netcdf_write_particle_info_base(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset","tags":"","loc":"interface/netcdf_write_particle_info_base.html"},{"title":"obl_acc_body – swiftest","text":"interface Calls interface~~obl_acc_body~~CallsGraph interface~obl_acc_body obl_acc_body proc~obl_acc_body obl_acc_body interface~obl_acc_body->proc~obl_acc_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~obl_acc_body~~CalledByGraph interface~obl_acc_body obl_acc_body proc~obl_acc_pl obl_acc_pl proc~obl_acc_pl->interface~obl_acc_body proc~obl_acc_tp obl_acc_tp proc~obl_acc_tp->interface~obl_acc_body interface~obl_acc_tp obl_acc_tp interface~obl_acc_tp->proc~obl_acc_tp interface~obl_acc_pl obl_acc_pl interface~obl_acc_pl->proc~obl_acc_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine obl_acc_body(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object","tags":"","loc":"interface/obl_acc_body.html"},{"title":"obl_acc_pl – swiftest","text":"interface Calls interface~~obl_acc_pl~~CallsGraph interface~obl_acc_pl obl_acc_pl proc~obl_acc_pl obl_acc_pl interface~obl_acc_pl->proc~obl_acc_pl interface~obl_acc_body obl_acc_body proc~obl_acc_pl->interface~obl_acc_body proc~obl_acc_body obl_acc_body interface~obl_acc_body->proc~obl_acc_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine obl_acc_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object","tags":"","loc":"interface/obl_acc_pl.html"},{"title":"obl_acc_tp – swiftest","text":"interface Calls interface~~obl_acc_tp~~CallsGraph interface~obl_acc_tp obl_acc_tp proc~obl_acc_tp obl_acc_tp interface~obl_acc_tp->proc~obl_acc_tp interface~obl_acc_body obl_acc_body proc~obl_acc_tp->interface~obl_acc_body proc~obl_acc_body obl_acc_body interface~obl_acc_body->proc~obl_acc_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine obl_acc_tp(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object","tags":"","loc":"interface/obl_acc_tp.html"},{"title":"obl_pot_system – swiftest","text":"interface Calls interface~~obl_pot_system~~CallsGraph interface~obl_pot_system obl_pot_system proc~obl_pot_system obl_pot_system interface~obl_pot_system->proc~obl_pot_system proc~obl_pot_one obl_pot_one proc~obl_pot_system->proc~obl_pot_one Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine obl_pot_system(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object","tags":"","loc":"interface/obl_pot_system.html"},{"title":"orbel_el2xv_vec – swiftest","text":"interface Calls interface~~orbel_el2xv_vec~~CallsGraph interface~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv_vec->proc~orbel_el2xv proc~orbel_zget orbel_zget proc~orbel_el2xv->proc~orbel_zget proc~orbel_fhybrid orbel_fhybrid proc~orbel_el2xv->proc~orbel_fhybrid proc~orbel_schget orbel_schget proc~orbel_el2xv->proc~orbel_schget proc~orbel_ehybrid orbel_ehybrid proc~orbel_el2xv->proc~orbel_ehybrid interface~orbel_scget orbel_scget proc~orbel_el2xv->interface~orbel_scget proc~orbel_flon orbel_flon proc~orbel_fhybrid->proc~orbel_flon proc~orbel_fget orbel_fget proc~orbel_fhybrid->proc~orbel_fget proc~orbel_eget orbel_eget proc~orbel_ehybrid->proc~orbel_eget proc~orbel_esolmd orbel_esolmd proc~orbel_ehybrid->proc~orbel_esolmd proc~orbel_ehie orbel_ehie proc~orbel_ehybrid->proc~orbel_ehie proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget 3 3 proc~orbel_flon->3 proc~orbel_eget->interface~orbel_scget proc~orbel_esolmd->interface~orbel_scget proc~orbel_fget->proc~orbel_schget proc~orbel_ehie->interface~orbel_scget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/orbel_el2xv_vec.html"},{"title":"orbel_scget – swiftest","text":"interface Calls interface~~orbel_scget~~CallsGraph interface~orbel_scget orbel_scget proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~orbel_scget~~CalledByGraph interface~orbel_scget orbel_scget proc~drift_kepu_guess drift_kepu_guess proc~drift_kepu_guess->interface~orbel_scget proc~orbel_eget orbel_eget proc~orbel_eget->interface~orbel_scget proc~orbel_esolmd orbel_esolmd proc~orbel_esolmd->interface~orbel_scget proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->interface~orbel_scget proc~orbel_ehybrid orbel_ehybrid proc~orbel_el2xv->proc~orbel_ehybrid proc~orbel_ehie orbel_ehie proc~orbel_ehie->interface~orbel_scget proc~drift_kepu drift_kepu proc~drift_kepu->proc~drift_kepu_guess proc~orbel_ehybrid->proc~orbel_eget proc~orbel_ehybrid->proc~orbel_esolmd proc~orbel_ehybrid->proc~orbel_ehie proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec proc~drift_dan drift_dan proc~drift_dan->proc~drift_kepu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine orbel_scget(angle, sx, cx) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: angle real(kind=DP), intent(out) :: sx real(kind=DP), intent(out) :: cx","tags":"","loc":"interface/orbel_scget.html"},{"title":"orbel_xv2aeq – swiftest","text":"interface Calls interface~~orbel_xv2aeq~~CallsGraph interface~orbel_xv2aeq orbel_xv2aeq proc~orbel_xv2aeq orbel_xv2aeq interface~orbel_xv2aeq->proc~orbel_xv2aeq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~orbel_xv2aeq~~CalledByGraph interface~orbel_xv2aeq orbel_xv2aeq proc~util_peri_tp util_peri_tp proc~util_peri_tp->interface~orbel_xv2aeq interface~util_peri_tp util_peri_tp interface~util_peri_tp->proc~util_peri_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine orbel_xv2aeq(mu, x, v, a, e, q) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(out) :: a semimajor axis real(kind=DP), intent(out) :: e eccentricity real(kind=DP), intent(out) :: q periapsis","tags":"","loc":"interface/orbel_xv2aeq.html"},{"title":"orbel_xv2aqt – swiftest","text":"interface Calls interface~~orbel_xv2aqt~~CallsGraph interface~orbel_xv2aqt orbel_xv2aqt proc~orbel_xv2aqt orbel_xv2aqt interface~orbel_xv2aqt->proc~orbel_xv2aqt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine orbel_xv2aqt(mu, x, v, a, q, capm, tperi) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(out) :: a semimajor axis real(kind=DP), intent(out) :: q periapsis real(kind=DP), intent(out) :: capm mean anomaly real(kind=DP), intent(out) :: tperi time of pericenter passage","tags":"","loc":"interface/orbel_xv2aqt.html"},{"title":"orbel_xv2el – swiftest","text":"interface Calls interface~~orbel_xv2el~~CallsGraph interface~orbel_xv2el orbel_xv2el proc~orbel_xv2el orbel_xv2el interface~orbel_xv2el->proc~orbel_xv2el Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~orbel_xv2el~~CalledByGraph interface~orbel_xv2el orbel_xv2el proc~orbel_xv2el_vec orbel_xv2el_vec proc~orbel_xv2el_vec->interface~orbel_xv2el interface~orbel_xv2el_vec orbel_xv2el_vec interface~orbel_xv2el_vec->proc~orbel_xv2el_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public pure module subroutine orbel_xv2el(mu, x, v, a, e, inc, capom, omega, capm) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(out) :: a semimajor axis real(kind=DP), intent(out) :: e eccentricity real(kind=DP), intent(out) :: inc inclination real(kind=DP), intent(out) :: capom longitude of ascending node real(kind=DP), intent(out) :: omega argument of periapsis real(kind=DP), intent(out) :: capm mean anomaly","tags":"","loc":"interface/orbel_xv2el.html"},{"title":"orbel_xv2el_vec – swiftest","text":"interface Calls interface~~orbel_xv2el_vec~~CallsGraph interface~orbel_xv2el_vec orbel_xv2el_vec proc~orbel_xv2el_vec orbel_xv2el_vec interface~orbel_xv2el_vec->proc~orbel_xv2el_vec interface~orbel_xv2el orbel_xv2el proc~orbel_xv2el_vec->interface~orbel_xv2el proc~orbel_xv2el orbel_xv2el interface~orbel_xv2el->proc~orbel_xv2el Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/orbel_xv2el_vec.html"},{"title":"setup_body – swiftest","text":"interface Calls interface~~setup_body~~CallsGraph interface~setup_body setup_body proc~setup_body setup_body interface~setup_body->proc~setup_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~setup_body~~CalledByGraph interface~setup_body setup_body proc~setup_pl setup_pl proc~setup_pl->interface~setup_body proc~setup_tp setup_tp proc~setup_tp->interface~setup_body interface~setup_tp setup_tp interface~setup_tp->proc~setup_tp interface~setup_pl setup_pl interface~setup_pl->proc~setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine setup_body(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/setup_body.html"},{"title":"setup_construct_system – swiftest","text":"interface Calls interface~~setup_construct_system~~CallsGraph interface~setup_construct_system setup_construct_system proc~setup_construct_system setup_construct_system interface~setup_construct_system->proc~setup_construct_system interface~util_exit util_exit proc~setup_construct_system->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine setup_construct_system(system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout), allocatable :: system Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/setup_construct_system.html"},{"title":"setup_encounter – swiftest","text":"interface Calls interface~~setup_encounter~~CallsGraph interface~setup_encounter setup_encounter proc~setup_encounter setup_encounter interface~setup_encounter->proc~setup_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine setup_encounter(self, n) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for","tags":"","loc":"interface/setup_encounter.html"},{"title":"setup_initialize_particle_info_system – swiftest","text":"interface Calls interface~~setup_initialize_particle_info_system~~CallsGraph interface~setup_initialize_particle_info_system setup_initialize_particle_info_system proc~setup_initialize_particle_info_system setup_initialize_particle_info_system interface~setup_initialize_particle_info_system->proc~setup_initialize_particle_info_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine setup_initialize_particle_info_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/setup_initialize_particle_info_system.html"},{"title":"setup_initialize_system – swiftest","text":"interface Calls interface~~setup_initialize_system~~CallsGraph interface~setup_initialize_system setup_initialize_system proc~setup_initialize_system setup_initialize_system interface~setup_initialize_system->proc~setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/setup_initialize_system.html"},{"title":"setup_pl – swiftest","text":"interface Calls interface~~setup_pl~~CallsGraph interface~setup_pl setup_pl proc~setup_pl setup_pl interface~setup_pl->proc~setup_pl interface~setup_body setup_body proc~setup_pl->interface~setup_body proc~setup_body setup_body interface~setup_body->proc~setup_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/setup_pl.html"},{"title":"setup_tp – swiftest","text":"interface Calls interface~~setup_tp~~CallsGraph interface~setup_tp setup_tp proc~setup_tp setup_tp interface~setup_tp->proc~setup_tp interface~setup_body setup_body proc~setup_tp->interface~setup_body proc~setup_body setup_body interface~setup_body->proc~setup_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parametersr","tags":"","loc":"interface/setup_tp.html"},{"title":"tides_kick_getacch_pl – swiftest","text":"interface Calls interface~~tides_kick_getacch_pl~~CallsGraph interface~tides_kick_getacch_pl tides_kick_getacch_pl proc~tides_kick_getacch_pl tides_kick_getacch_pl interface~tides_kick_getacch_pl->proc~tides_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine tides_kick_getacch_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object","tags":"","loc":"interface/tides_kick_getacch_pl.html"},{"title":"tides_step_spin_system – swiftest","text":"interface Calls interface~~tides_step_spin_system~~CallsGraph interface~tides_step_spin_system tides_step_spin_system proc~tides_step_spin_system tides_step_spin_system interface~tides_step_spin_system->proc~tides_step_spin_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine tides_step_spin_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"interface/tides_step_spin_system.html"},{"title":"user_kick_getacch_body – swiftest","text":"interface Calls interface~~user_kick_getacch_body~~CallsGraph interface~user_kick_getacch_body user_kick_getacch_body proc~user_kick_getacch_body user_kick_getacch_body interface~user_kick_getacch_body->proc~user_kick_getacch_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step","tags":"","loc":"interface/user_kick_getacch_body.html"},{"title":"util_append – swiftest","text":"public interface util_append Called by interface~~util_append~2~~CalledByGraph interface~util_append~2 util_append proc~util_append_body util_append_body proc~util_append_body->interface~util_append~2 proc~util_append_pl util_append_pl proc~util_append_pl->interface~util_append~2 interface~util_append_body util_append_body proc~util_append_pl->interface~util_append_body proc~util_append_tp util_append_tp proc~util_append_tp->interface~util_append~2 proc~util_append_tp->interface~util_append_body proc~util_append_encounter util_append_encounter proc~util_append_encounter->interface~util_append~2 interface~util_append_body->proc~util_append_body interface~util_append_encounter util_append_encounter interface~util_append_encounter->proc~util_append_encounter interface~util_append_tp util_append_tp interface~util_append_tp->proc~util_append_tp interface~util_append_pl util_append_pl interface~util_append_pl->proc~util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines util_append_arr_char_string util_append_arr_DP util_append_arr_DPvec util_append_arr_I4B util_append_arr_info util_append_arr_logical Subroutines public subroutine util_append_arr_char_string(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: arr Destination array character(len=STRMAX), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to public subroutine util_append_arr_DP(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: arr Destination array real(kind=DP), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to public subroutine util_append_arr_DPvec(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: arr Destination array real(kind=DP), intent(in), dimension(:,:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to public subroutine util_append_arr_I4B(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to public subroutine util_append_arr_info(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: arr Destination array type( swiftest_particle_info ), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to public subroutine util_append_arr_logical(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: arr Destination array logical, intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/util_append~2.html"},{"title":"util_append_body – swiftest","text":"interface Calls interface~~util_append_body~~CallsGraph interface~util_append_body util_append_body proc~util_append_body util_append_body interface~util_append_body->proc~util_append_body interface~util_append~2 util_append proc~util_append_body->interface~util_append~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~util_append_body~~CalledByGraph interface~util_append_body util_append_body proc~util_append_pl util_append_pl proc~util_append_pl->interface~util_append_body proc~util_append_tp util_append_tp proc~util_append_tp->interface~util_append_body interface~util_append_tp util_append_tp interface~util_append_tp->proc~util_append_tp interface~util_append_pl util_append_pl interface~util_append_pl->proc~util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_append_body(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/util_append_body.html"},{"title":"util_append_encounter – swiftest","text":"interface Calls interface~~util_append_encounter~~CallsGraph interface~util_append_encounter util_append_encounter proc~util_append_encounter util_append_encounter interface~util_append_encounter->proc~util_append_encounter interface~util_append~2 util_append proc~util_append_encounter->interface~util_append~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_append_encounter(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list object class( swiftest_encounter ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/util_append_encounter.html"},{"title":"util_append_pl – swiftest","text":"interface Calls interface~~util_append_pl~~CallsGraph interface~util_append_pl util_append_pl proc~util_append_pl util_append_pl interface~util_append_pl->proc~util_append_pl interface~util_append_body util_append_body proc~util_append_pl->interface~util_append_body interface~util_append~2 util_append proc~util_append_pl->interface~util_append~2 interface~util_exit util_exit proc~util_append_pl->interface~util_exit proc~util_append_body util_append_body interface~util_append_body->proc~util_append_body proc~util_exit util_exit interface~util_exit->proc~util_exit proc~util_append_body->interface~util_append~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/util_append_pl.html"},{"title":"util_append_tp – swiftest","text":"interface Calls interface~~util_append_tp~~CallsGraph interface~util_append_tp util_append_tp proc~util_append_tp util_append_tp interface~util_append_tp->proc~util_append_tp interface~util_append_body util_append_body proc~util_append_tp->interface~util_append_body interface~util_append~2 util_append proc~util_append_tp->interface~util_append~2 interface~util_exit util_exit proc~util_append_tp->interface~util_exit proc~util_append_body util_append_body interface~util_append_body->proc~util_append_body proc~util_exit util_exit interface~util_exit->proc~util_exit proc~util_append_body->interface~util_append~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"interface/util_append_tp.html"},{"title":"util_coord_b2h_pl – swiftest","text":"interface Calls interface~~util_coord_b2h_pl~~CallsGraph interface~util_coord_b2h_pl util_coord_b2h_pl proc~util_coord_b2h_pl util_coord_b2h_pl interface~util_coord_b2h_pl->proc~util_coord_b2h_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_coord_b2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/util_coord_b2h_pl.html"},{"title":"util_coord_b2h_tp – swiftest","text":"interface Calls interface~~util_coord_b2h_tp~~CallsGraph interface~util_coord_b2h_tp util_coord_b2h_tp proc~util_coord_b2h_tp util_coord_b2h_tp interface~util_coord_b2h_tp->proc~util_coord_b2h_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_coord_b2h_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object","tags":"","loc":"interface/util_coord_b2h_tp.html"},{"title":"util_coord_h2b_pl – swiftest","text":"interface Calls interface~~util_coord_h2b_pl~~CallsGraph interface~util_coord_h2b_pl util_coord_h2b_pl proc~util_coord_h2b_pl util_coord_h2b_pl interface~util_coord_h2b_pl->proc~util_coord_h2b_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_coord_h2b_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/util_coord_h2b_pl.html"},{"title":"util_coord_h2b_tp – swiftest","text":"interface Calls interface~~util_coord_h2b_tp~~CallsGraph interface~util_coord_h2b_tp util_coord_h2b_tp proc~util_coord_h2b_tp util_coord_h2b_tp interface~util_coord_h2b_tp->proc~util_coord_h2b_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_coord_h2b_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object","tags":"","loc":"interface/util_coord_h2b_tp.html"},{"title":"util_coord_vb2vh_pl – swiftest","text":"interface Calls interface~~util_coord_vb2vh_pl~~CallsGraph interface~util_coord_vb2vh_pl util_coord_vb2vh_pl proc~util_coord_vb2vh_pl util_coord_vb2vh_pl interface~util_coord_vb2vh_pl->proc~util_coord_vb2vh_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_coord_vb2vh_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/util_coord_vb2vh_pl.html"},{"title":"util_coord_vb2vh_tp – swiftest","text":"interface Calls interface~~util_coord_vb2vh_tp~~CallsGraph interface~util_coord_vb2vh_tp util_coord_vb2vh_tp proc~util_coord_vb2vh_tp util_coord_vb2vh_tp interface~util_coord_vb2vh_tp->proc~util_coord_vb2vh_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_coord_vb2vh_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body","tags":"","loc":"interface/util_coord_vb2vh_tp.html"},{"title":"util_coord_vh2vb_pl – swiftest","text":"interface Calls interface~~util_coord_vh2vb_pl~~CallsGraph interface~util_coord_vh2vb_pl util_coord_vh2vb_pl proc~util_coord_vh2vb_pl util_coord_vh2vb_pl interface~util_coord_vh2vb_pl->proc~util_coord_vh2vb_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_coord_vh2vb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/util_coord_vh2vb_pl.html"},{"title":"util_coord_vh2vb_tp – swiftest","text":"interface Calls interface~~util_coord_vh2vb_tp~~CallsGraph interface~util_coord_vh2vb_tp util_coord_vh2vb_tp proc~util_coord_vh2vb_tp util_coord_vh2vb_tp interface~util_coord_vh2vb_tp->proc~util_coord_vh2vb_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_coord_vh2vb_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body","tags":"","loc":"interface/util_coord_vh2vb_tp.html"},{"title":"util_coord_xh2xb_pl – swiftest","text":"interface Calls interface~~util_coord_xh2xb_pl~~CallsGraph interface~util_coord_xh2xb_pl util_coord_xh2xb_pl proc~util_coord_xh2xb_pl util_coord_xh2xb_pl interface~util_coord_xh2xb_pl->proc~util_coord_xh2xb_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_coord_xh2xb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/util_coord_xh2xb_pl.html"},{"title":"util_coord_xh2xb_tp – swiftest","text":"interface Calls interface~~util_coord_xh2xb_tp~~CallsGraph interface~util_coord_xh2xb_tp util_coord_xh2xb_tp proc~util_coord_xh2xb_tp util_coord_xh2xb_tp interface~util_coord_xh2xb_tp->proc~util_coord_xh2xb_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_coord_xh2xb_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object","tags":"","loc":"interface/util_coord_xh2xb_tp.html"},{"title":"util_copy_encounter – swiftest","text":"interface Calls interface~~util_copy_encounter~~CallsGraph interface~util_copy_encounter util_copy_encounter proc~util_copy_encounter util_copy_encounter interface~util_copy_encounter->proc~util_copy_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_copy_encounter(self, source) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Encounter list class( swiftest_encounter ), intent(in) :: source Source object to copy into","tags":"","loc":"interface/util_copy_encounter.html"},{"title":"util_copy_particle_info – swiftest","text":"interface Calls interface~~util_copy_particle_info~~CallsGraph interface~util_copy_particle_info util_copy_particle_info proc~util_copy_particle_info util_copy_particle_info interface~util_copy_particle_info->proc~util_copy_particle_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_copy_particle_info(self, source) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(inout) :: self class( swiftest_particle_info ), intent(in) :: source","tags":"","loc":"interface/util_copy_particle_info.html"},{"title":"util_copy_particle_info_arr – swiftest","text":"interface Calls interface~~util_copy_particle_info_arr~~CallsGraph interface~util_copy_particle_info_arr util_copy_particle_info_arr proc~util_copy_particle_info_arr util_copy_particle_info_arr interface~util_copy_particle_info_arr->proc~util_copy_particle_info_arr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~util_copy_particle_info_arr~~CalledByGraph interface~util_copy_particle_info_arr util_copy_particle_info_arr proc~util_sort_rearrange_arr_info util_sort_rearrange_arr_info proc~util_sort_rearrange_arr_info->interface~util_copy_particle_info_arr proc~util_fill_arr_info util_fill_arr_info proc~util_fill_arr_info->interface~util_copy_particle_info_arr proc~util_spill_arr_info util_spill_arr_info proc~util_spill_arr_info->interface~util_copy_particle_info_arr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_copy_particle_info_arr(source, dest, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(in), dimension(:) :: source Source object to copy into class( swiftest_particle_info ), intent(inout), dimension(:) :: dest Swiftest body object with particle metadata information object integer(kind=I4B), intent(in), optional dimension(:) :: idx Optional array of indices to draw the source object","tags":"","loc":"interface/util_copy_particle_info_arr.html"},{"title":"util_exit – swiftest","text":"interface Calls interface~~util_exit~~CallsGraph interface~util_exit util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~util_exit~~CalledByGraph interface~util_exit util_exit proc~io_write_encounter io_write_encounter proc~io_write_encounter->interface~util_exit proc~io_read_in_cb io_read_in_cb proc~io_read_in_cb->interface~util_exit proc~util_append_pl util_append_pl proc~util_append_pl->interface~util_exit proc~util_append_tp util_append_tp proc~util_append_tp->interface~util_exit proc~io_read_encounter io_read_encounter proc~io_read_encounter->interface~util_exit proc~setup_construct_system setup_construct_system proc~setup_construct_system->interface~util_exit proc~io_read_particle_info_system io_read_particle_info_system proc~io_read_particle_info_system->interface~util_exit proc~check check proc~check->interface~util_exit proc~io_write_discard io_write_discard proc~io_write_discard->interface~util_exit proc~io_dump_particle_info_base io_dump_particle_info_base proc~io_dump_particle_info_base->interface~util_exit proc~io_dump_particle_info io_dump_particle_info proc~io_dump_particle_info->interface~util_exit proc~io_dump_param io_dump_param proc~io_dump_param->interface~util_exit proc~io_write_frame_encounter io_write_frame_encounter proc~io_write_frame_encounter->interface~util_exit proc~io_conservation_report io_conservation_report proc~io_conservation_report->interface~util_exit proc~io_read_frame_cb io_read_frame_cb proc~io_read_frame_cb->interface~util_exit proc~io_read_in_particle_info io_read_in_particle_info proc~io_read_in_particle_info->interface~util_exit proc~io_get_old_t_final_system io_get_old_t_final_system proc~io_get_old_t_final_system->interface~util_exit proc~io_dump_base io_dump_base proc~io_dump_base->interface~util_exit interface~io_write_frame_body io_write_frame_body proc~io_dump_base->interface~io_write_frame_body interface~io_write_frame_cb io_write_frame_cb proc~io_dump_base->interface~io_write_frame_cb proc~io_write_hdr_system io_write_hdr_system proc~io_write_hdr_system->interface~util_exit proc~io_read_in_param io_read_in_param proc~io_read_in_param->interface~util_exit proc~util_solve_rkf45 util_solve_rkf45 proc~util_solve_rkf45->interface~util_exit proc~io_read_frame_body io_read_frame_body proc~io_read_frame_body->interface~util_exit proc~io_write_frame_body io_write_frame_body proc~io_write_frame_body->interface~util_exit proc~util_valid_id_system util_valid_id_system proc~util_valid_id_system->interface~util_exit proc~io_write_frame_cb io_write_frame_cb proc~io_write_frame_cb->interface~util_exit proc~io_write_frame_system io_write_frame_system proc~io_write_frame_system->interface~util_exit proc~io_get_args io_get_args proc~io_get_args->interface~util_exit interface~io_conservation_report io_conservation_report interface~io_conservation_report->proc~io_conservation_report interface~util_solve_rkf45 util_solve_rkf45 interface~util_solve_rkf45->proc~util_solve_rkf45 interface~io_dump_particle_info_base io_dump_particle_info_base interface~io_dump_particle_info_base->proc~io_dump_particle_info_base interface~setup_construct_system setup_construct_system interface~setup_construct_system->proc~setup_construct_system interface~io_write_hdr_system io_write_hdr_system interface~io_write_hdr_system->proc~io_write_hdr_system interface~io_read_frame_cb io_read_frame_cb interface~io_read_frame_cb->proc~io_read_frame_cb interface~io_read_in_cb io_read_in_cb interface~io_read_in_cb->proc~io_read_in_cb interface~io_write_encounter io_write_encounter interface~io_write_encounter->proc~io_write_encounter interface~io_dump_param io_dump_param interface~io_dump_param->proc~io_dump_param interface~io_get_args io_get_args interface~io_get_args->proc~io_get_args interface~io_read_frame_body io_read_frame_body interface~io_read_frame_body->proc~io_read_frame_body interface~util_append_tp util_append_tp interface~util_append_tp->proc~util_append_tp interface~io_write_frame_encounter io_write_frame_encounter interface~io_write_frame_encounter->proc~io_write_frame_encounter interface~io_write_frame_body->proc~io_write_frame_body interface~util_valid_id_system util_valid_id_system interface~util_valid_id_system->proc~util_valid_id_system interface~io_read_particle_info_system io_read_particle_info_system interface~io_read_particle_info_system->proc~io_read_particle_info_system interface~io_write_discard io_write_discard interface~io_write_discard->proc~io_write_discard interface~io_dump_base io_dump_base interface~io_dump_base->proc~io_dump_base interface~util_append_pl util_append_pl interface~util_append_pl->proc~util_append_pl interface~io_dump_particle_info io_dump_particle_info interface~io_dump_particle_info->proc~io_dump_particle_info interface~io_write_frame_system io_write_frame_system interface~io_write_frame_system->proc~io_write_frame_system interface~io_read_in_param io_read_in_param interface~io_read_in_param->proc~io_read_in_param interface~io_write_frame_cb->proc~io_write_frame_cb interface~io_get_old_t_final_system io_get_old_t_final_system interface~io_get_old_t_final_system->proc~io_get_old_t_final_system interface~io_read_in_particle_info io_read_in_particle_info interface~io_read_in_particle_info->proc~io_read_in_particle_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_exit(code) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: code Failure exit code","tags":"","loc":"interface/util_exit.html"},{"title":"util_fill_body – swiftest","text":"interface Calls interface~~util_fill_body~~CallsGraph interface~util_fill_body util_fill_body proc~util_fill_body util_fill_body interface~util_fill_body->proc~util_fill_body interface~util_fill~2 util_fill proc~util_fill_body->interface~util_fill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~util_fill_body~~CalledByGraph interface~util_fill_body util_fill_body proc~util_fill_tp util_fill_tp proc~util_fill_tp->interface~util_fill_body proc~util_fill_pl util_fill_pl proc~util_fill_pl->interface~util_fill_body interface~util_fill_tp util_fill_tp interface~util_fill_tp->proc~util_fill_tp interface~util_fill_pl util_fill_pl interface~util_fill_pl->proc~util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_fill_body(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"interface/util_fill_body.html"},{"title":"util_fill_pl – swiftest","text":"interface Calls interface~~util_fill_pl~~CallsGraph interface~util_fill_pl util_fill_pl proc~util_fill_pl util_fill_pl interface~util_fill_pl->proc~util_fill_pl interface~util_fill~2 util_fill proc~util_fill_pl->interface~util_fill~2 interface~util_fill_body util_fill_body proc~util_fill_pl->interface~util_fill_body proc~util_fill_body util_fill_body interface~util_fill_body->proc~util_fill_body proc~util_fill_body->interface~util_fill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"interface/util_fill_pl.html"},{"title":"util_fill_tp – swiftest","text":"interface Calls interface~~util_fill_tp~~CallsGraph interface~util_fill_tp util_fill_tp proc~util_fill_tp util_fill_tp interface~util_fill_tp->proc~util_fill_tp interface~util_fill~2 util_fill proc~util_fill_tp->interface~util_fill~2 interface~util_fill_body util_fill_body proc~util_fill_tp->interface~util_fill_body proc~util_fill_body util_fill_body interface~util_fill_body->proc~util_fill_body proc~util_fill_body->interface~util_fill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"interface/util_fill_tp.html"},{"title":"util_fill – swiftest","text":"public interface util_fill Called by interface~~util_fill~2~~CalledByGraph interface~util_fill~2 util_fill proc~util_fill_tp util_fill_tp proc~util_fill_tp->interface~util_fill~2 interface~util_fill_body util_fill_body proc~util_fill_tp->interface~util_fill_body proc~util_fill_body util_fill_body proc~util_fill_body->interface~util_fill~2 proc~util_fill_pl util_fill_pl proc~util_fill_pl->interface~util_fill~2 proc~util_fill_pl->interface~util_fill_body interface~util_fill_tp util_fill_tp interface~util_fill_tp->proc~util_fill_tp interface~util_fill_body->proc~util_fill_body interface~util_fill_pl util_fill_pl interface~util_fill_pl->proc~util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines util_fill_arr_char_string util_fill_arr_DP util_fill_arr_DPvec util_fill_arr_I4B util_fill_arr_info util_fill_arr_logical Subroutines public subroutine util_fill_arr_char_string(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: keeps Array of values to keep character(len=STRMAX), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public subroutine util_fill_arr_DP(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: keeps Array of values to keep real(kind=DP), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public subroutine util_fill_arr_DPvec(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: keeps Array of values to keep real(kind=DP), intent(in), dimension(:,:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public subroutine util_fill_arr_I4B(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: keeps Array of values to keep integer(kind=I4B), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public subroutine util_fill_arr_info(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( swiftest_particle_info ), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public subroutine util_fill_arr_logical(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: keeps Array of values to keep logical, intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"interface/util_fill~2.html"},{"title":"util_minimize_bfgs – swiftest","text":"interface Calls interface~~util_minimize_bfgs~~CallsGraph interface~util_minimize_bfgs util_minimize_bfgs proc~util_minimize_bfgs util_minimize_bfgs interface~util_minimize_bfgs->proc~util_minimize_bfgs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function util_minimize_bfgs(f, N, x0, eps, maxloop, lerr) result(x1) Implementation → Arguments Type Intent Optional Attributes Name class(lambda_obj), intent(inout) :: f integer(kind=I4B), intent(in) :: N real(kind=DP), intent(in), dimension(:) :: x0 real(kind=DP), intent(in) :: eps integer(kind=I4B), intent(in) :: maxloop logical, intent(out) :: lerr Return Value real(kind=DP),\n  dimension(:),allocatable","tags":"","loc":"interface/util_minimize_bfgs.html"},{"title":"util_rescale_system – swiftest","text":"interface Calls interface~~util_rescale_system~~CallsGraph interface~util_rescale_system util_rescale_system proc~util_rescale_system util_rescale_system interface~util_rescale_system->proc~util_rescale_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_rescale_system(self, param, mscale, dscale, tscale) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters. Returns with new values of the scale vactors and GU real(kind=DP), intent(in) :: mscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: dscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: tscale Scale factors for mass, distance, and time units, respectively.","tags":"","loc":"interface/util_rescale_system.html"},{"title":"util_peri_tp – swiftest","text":"interface Calls interface~~util_peri_tp~~CallsGraph interface~util_peri_tp util_peri_tp proc~util_peri_tp util_peri_tp interface~util_peri_tp->proc~util_peri_tp interface~orbel_xv2aeq orbel_xv2aeq proc~util_peri_tp->interface~orbel_xv2aeq proc~orbel_xv2aeq orbel_xv2aeq interface~orbel_xv2aeq->proc~orbel_xv2aeq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_peri_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/util_peri_tp.html"},{"title":"util_resize – swiftest","text":"public interface util_resize Called by interface~~util_resize~2~~CalledByGraph interface~util_resize~2 util_resize proc~util_resize_tp util_resize_tp proc~util_resize_tp->interface~util_resize~2 interface~util_resize_body util_resize_body proc~util_resize_tp->interface~util_resize_body proc~util_append_arr_info util_append_arr_info proc~util_append_arr_info->interface~util_resize~2 proc~util_append_arr_dpvec util_append_arr_DPvec proc~util_append_arr_dpvec->interface~util_resize~2 proc~util_append_arr_char_string util_append_arr_char_string proc~util_append_arr_char_string->interface~util_resize~2 proc~util_resize_body util_resize_body proc~util_resize_body->interface~util_resize~2 proc~util_append_arr_i4b util_append_arr_I4B proc~util_append_arr_i4b->interface~util_resize~2 proc~util_resize_pl util_resize_pl proc~util_resize_pl->interface~util_resize~2 proc~util_resize_pl->interface~util_resize_body proc~util_append_arr_logical util_append_arr_logical proc~util_append_arr_logical->interface~util_resize~2 proc~util_append_arr_dp util_append_arr_DP proc~util_append_arr_dp->interface~util_resize~2 interface~util_resize_body->proc~util_resize_body interface~util_resize_pl util_resize_pl interface~util_resize_pl->proc~util_resize_pl interface~util_resize_tp util_resize_tp interface~util_resize_tp->proc~util_resize_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines util_resize_arr_char_string util_resize_arr_DP util_resize_arr_DPvec util_resize_arr_I4B util_resize_arr_info util_resize_arr_logical Subroutines public subroutine util_resize_arr_char_string(arr, nnew) Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size public subroutine util_resize_arr_DP(arr, nnew) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size public subroutine util_resize_arr_DPvec(arr, nnew) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size public subroutine util_resize_arr_I4B(arr, nnew) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size public subroutine util_resize_arr_info(arr, nnew) Arguments Type Intent Optional Attributes Name type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size public subroutine util_resize_arr_logical(arr, nnew) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size","tags":"","loc":"interface/util_resize~2.html"},{"title":"util_resize_body – swiftest","text":"interface Calls interface~~util_resize_body~~CallsGraph interface~util_resize_body util_resize_body proc~util_resize_body util_resize_body interface~util_resize_body->proc~util_resize_body interface~util_resize~2 util_resize proc~util_resize_body->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~util_resize_body~~CalledByGraph interface~util_resize_body util_resize_body proc~util_resize_tp util_resize_tp proc~util_resize_tp->interface~util_resize_body proc~util_resize_pl util_resize_pl proc~util_resize_pl->interface~util_resize_body interface~util_resize_pl util_resize_pl interface~util_resize_pl->proc~util_resize_pl interface~util_resize_tp util_resize_tp interface~util_resize_tp->proc~util_resize_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_resize_body(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in) :: nnew New size neded","tags":"","loc":"interface/util_resize_body.html"},{"title":"util_resize_encounter – swiftest","text":"interface Calls interface~~util_resize_encounter~~CallsGraph interface~util_resize_encounter util_resize_encounter proc~util_resize_encounter util_resize_encounter interface~util_resize_encounter->proc~util_resize_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_resize_encounter(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list integer(kind=I4B), intent(in) :: nnew New size of list needed","tags":"","loc":"interface/util_resize_encounter.html"},{"title":"util_resize_pl – swiftest","text":"interface Calls interface~~util_resize_pl~~CallsGraph interface~util_resize_pl util_resize_pl proc~util_resize_pl util_resize_pl interface~util_resize_pl->proc~util_resize_pl interface~util_resize~2 util_resize proc~util_resize_pl->interface~util_resize~2 interface~util_resize_body util_resize_body proc~util_resize_pl->interface~util_resize_body proc~util_resize_body util_resize_body interface~util_resize_body->proc~util_resize_body proc~util_resize_body->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: nnew New size neded","tags":"","loc":"interface/util_resize_pl.html"},{"title":"util_resize_tp – swiftest","text":"interface Calls interface~~util_resize_tp~~CallsGraph interface~util_resize_tp util_resize_tp proc~util_resize_tp util_resize_tp interface~util_resize_tp->proc~util_resize_tp interface~util_resize~2 util_resize proc~util_resize_tp->interface~util_resize~2 interface~util_resize_body util_resize_body proc~util_resize_tp->interface~util_resize_body proc~util_resize_body util_resize_body interface~util_resize_body->proc~util_resize_body proc~util_resize_body->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: nnew New size neded","tags":"","loc":"interface/util_resize_tp.html"},{"title":"util_get_energy_momentum_system – swiftest","text":"interface Calls interface~~util_get_energy_momentum_system~~CallsGraph interface~util_get_energy_momentum_system util_get_energy_momentum_system proc~util_get_energy_momentum_system util_get_energy_momentum_system interface~util_get_energy_momentum_system->proc~util_get_energy_momentum_system proc~util_get_energy_potential util_get_energy_potential proc~util_get_energy_momentum_system->proc~util_get_energy_potential Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_get_energy_momentum_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"interface/util_get_energy_momentum_system.html"},{"title":"util_set_beg_end_pl – swiftest","text":"interface Calls interface~~util_set_beg_end_pl~~CallsGraph interface~util_set_beg_end_pl util_set_beg_end_pl proc~util_set_beg_end_pl util_set_beg_end_pl interface~util_set_beg_end_pl->proc~util_set_beg_end_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_set_beg_end_pl(self, xbeg, xend, vbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object real(kind=DP), intent(in), optional dimension(:,:) :: xbeg Position vectors at beginning of step real(kind=DP), intent(in), optional dimension(:,:) :: xend Positions vectors at end of step real(kind=DP), intent(in), optional dimension(:,:) :: vbeg vbeg is an unused variable to keep this method forward compatible with RMVS","tags":"","loc":"interface/util_set_beg_end_pl.html"},{"title":"util_set_ir3h – swiftest","text":"interface Calls interface~~util_set_ir3h~~CallsGraph interface~util_set_ir3h util_set_ir3h proc~util_set_ir3h util_set_ir3h interface~util_set_ir3h->proc~util_set_ir3h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object","tags":"","loc":"interface/util_set_ir3h.html"},{"title":"util_set_msys – swiftest","text":"interface Calls interface~~util_set_msys~~CallsGraph interface~util_set_msys util_set_msys proc~util_set_msys util_set_msys interface~util_set_msys->proc~util_set_msys Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_set_msys(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object","tags":"","loc":"interface/util_set_msys.html"},{"title":"util_set_mu_pl – swiftest","text":"interface Calls interface~~util_set_mu_pl~~CallsGraph interface~util_set_mu_pl util_set_mu_pl proc~util_set_mu_pl util_set_mu_pl interface~util_set_mu_pl->proc~util_set_mu_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_set_mu_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/util_set_mu_pl.html"},{"title":"util_set_mu_tp – swiftest","text":"interface Calls interface~~util_set_mu_tp~~CallsGraph interface~util_set_mu_tp util_set_mu_tp proc~util_set_mu_tp util_set_mu_tp interface~util_set_mu_tp->proc~util_set_mu_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_set_mu_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/util_set_mu_tp.html"},{"title":"util_set_particle_info – swiftest","text":"interface Calls interface~~util_set_particle_info~~CallsGraph interface~util_set_particle_info util_set_particle_info proc~util_set_particle_info util_set_particle_info interface~util_set_particle_info->proc~util_set_particle_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_set_particle_info(self, name, particle_type, status, origin_type, origin_time, origin_xh, origin_vh, discard_time, discard_xh, discard_vh, discard_body_id) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(inout) :: self character(len=*), intent(in), optional :: name Non-unique name character(len=*), intent(in), optional :: particle_type String containing a description of the particle type (e.g. Central Body, Massive Body, Test Particle) character(len=*), intent(in), optional :: status Particle status description: Active, Merged, Fragmented, etc. character(len=*), intent(in), optional :: origin_type String containing a description of the origin of the particle (e.g. Initial Conditions, Supercatastrophic, Disruption, etc.) real(kind=DP), intent(in), optional :: origin_time The time of the particle's formation real(kind=DP), intent(in), optional dimension(:) :: origin_xh The heliocentric distance vector at the time of the particle's formation real(kind=DP), intent(in), optional dimension(:) :: origin_vh The heliocentric velocity vector at the time of the particle's formation real(kind=DP), intent(in), optional :: discard_time The time of the particle's discard real(kind=DP), intent(in), optional dimension(:) :: discard_xh The heliocentric distance vector at the time of the particle's discard real(kind=DP), intent(in), optional dimension(:) :: discard_vh The heliocentric velocity vector at the time of the particle's discard integer(kind=I4B), intent(in), optional :: discard_body_id The id of the other body involved in the discard (0 if no other body involved)","tags":"","loc":"interface/util_set_particle_info.html"},{"title":"util_set_rhill – swiftest","text":"interface Calls interface~~util_set_rhill~~CallsGraph interface~util_set_rhill util_set_rhill proc~util_set_rhill util_set_rhill interface~util_set_rhill->proc~util_set_rhill Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_set_rhill(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/util_set_rhill.html"},{"title":"util_set_rhill_approximate – swiftest","text":"interface Calls interface~~util_set_rhill_approximate~~CallsGraph interface~util_set_rhill_approximate util_set_rhill_approximate proc~util_set_rhill_approximate util_set_rhill_approximate interface~util_set_rhill_approximate->proc~util_set_rhill_approximate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_set_rhill_approximate(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"interface/util_set_rhill_approximate.html"},{"title":"util_solve_linear_system – swiftest","text":"public interface util_solve_linear_system Contents Functions util_solve_linear_system_d util_solve_linear_system_q Functions public function util_solve_linear_system_d(A, b, n, lerr) result(x) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A real(kind=DP), intent(in), dimension(:) :: b integer(kind=I4B), intent(in) :: n logical, intent(out) :: lerr Return Value real(kind=DP),\n  dimension(n) public function util_solve_linear_system_q(A, b, n, lerr) result(x) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A real(kind=QP), intent(in), dimension(:) :: b integer(kind=I4B), intent(in) :: n logical, intent(out) :: lerr Return Value real(kind=QP),\n  dimension(n)","tags":"","loc":"interface/util_solve_linear_system.html"},{"title":"util_solve_rkf45 – swiftest","text":"interface Calls interface~~util_solve_rkf45~~CallsGraph interface~util_solve_rkf45 util_solve_rkf45 proc~util_solve_rkf45 util_solve_rkf45 interface~util_solve_rkf45->proc~util_solve_rkf45 interface~util_exit util_exit proc~util_solve_rkf45->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function util_solve_rkf45(f, y0in, t1, dt0, tol) result(y1) Implementation → Arguments Type Intent Optional Attributes Name class(lambda_obj), intent(inout) :: f lambda function object that has been initialized to be a function of derivatives. The object will return with components lastarg and lasteval set real(kind=DP), intent(in), dimension(:) :: y0in Initial value at t=0 real(kind=DP), intent(in) :: t1 Final time real(kind=DP), intent(in) :: dt0 Initial step size guess real(kind=DP), intent(in) :: tol Tolerance on solution Return Value real(kind=DP),\n  dimension(:),allocatable Final result","tags":"","loc":"interface/util_solve_rkf45.html"},{"title":"util_sort – swiftest","text":"public interface util_sort Called by interface~~util_sort~~CalledByGraph interface~util_sort util_sort proc~netcdf_write_frame_base netcdf_write_frame_base proc~netcdf_write_frame_base->interface~util_sort proc~util_valid_id_system util_valid_id_system proc~util_valid_id_system->interface~util_sort proc~netcdf_write_particle_info_base netcdf_write_particle_info_base proc~netcdf_write_particle_info_base->interface~util_sort interface~netcdf_write_frame_base netcdf_write_frame_base interface~netcdf_write_frame_base->proc~netcdf_write_frame_base interface~netcdf_write_particle_info_base netcdf_write_particle_info_base interface~netcdf_write_particle_info_base->proc~netcdf_write_particle_info_base interface~util_valid_id_system util_valid_id_system interface~util_valid_id_system->proc~util_valid_id_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines util_sort_i4b util_sort_index_i4b util_sort_sp util_sort_index_sp util_sort_dp util_sort_index_dp Subroutines public subroutine util_sort_i4b(arr) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:) :: arr public subroutine util_sort_index_i4b(arr, ind) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind public subroutine util_sort_sp(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), dimension(:) :: arr public subroutine util_sort_index_sp(arr, ind) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind public subroutine util_sort_dp(arr) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:) :: arr public subroutine util_sort_index_dp(arr, ind) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind","tags":"","loc":"interface/util_sort.html"},{"title":"util_sort_rearrange – swiftest","text":"public interface util_sort_rearrange Called by interface~~util_sort_rearrange~2~~CalledByGraph interface~util_sort_rearrange~2 util_sort_rearrange proc~util_sort_rearrange_body util_sort_rearrange_body proc~util_sort_rearrange_body->interface~util_sort_rearrange~2 proc~util_sort_rearrange_pl util_sort_rearrange_pl proc~util_sort_rearrange_pl->interface~util_sort_rearrange~2 interface~util_sort_rearrange_body util_sort_rearrange_body proc~util_sort_rearrange_pl->interface~util_sort_rearrange_body proc~util_sort_rearrange_tp util_sort_rearrange_tp proc~util_sort_rearrange_tp->interface~util_sort_rearrange~2 proc~util_sort_rearrange_tp->interface~util_sort_rearrange_body interface~util_sort_rearrange_pl util_sort_rearrange_pl interface~util_sort_rearrange_pl->proc~util_sort_rearrange_pl interface~util_sort_rearrange_tp util_sort_rearrange_tp interface~util_sort_rearrange_tp->proc~util_sort_rearrange_tp interface~util_sort_rearrange_body->proc~util_sort_rearrange_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines util_sort_rearrange_arr_char_string util_sort_rearrange_arr_DP util_sort_rearrange_arr_DPvec util_sort_rearrange_arr_I4B util_sort_rearrange_arr_info util_sort_rearrange_arr_logical Subroutines public subroutine util_sort_rearrange_arr_char_string(arr, ind, n) Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange public subroutine util_sort_rearrange_arr_DP(arr, ind, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange public subroutine util_sort_rearrange_arr_DPvec(arr, ind, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange public subroutine util_sort_rearrange_arr_I4B(arr, ind, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange public subroutine util_sort_rearrange_arr_info(arr, ind, n) Arguments Type Intent Optional Attributes Name type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange public subroutine util_sort_rearrange_arr_logical(arr, ind, n) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange","tags":"","loc":"interface/util_sort_rearrange~2.html"},{"title":"util_sort_rearrange_body – swiftest","text":"interface Calls interface~~util_sort_rearrange_body~~CallsGraph interface~util_sort_rearrange_body util_sort_rearrange_body proc~util_sort_rearrange_body util_sort_rearrange_body interface~util_sort_rearrange_body->proc~util_sort_rearrange_body interface~util_sort_rearrange~2 util_sort_rearrange proc~util_sort_rearrange_body->interface~util_sort_rearrange~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~util_sort_rearrange_body~~CalledByGraph interface~util_sort_rearrange_body util_sort_rearrange_body proc~util_sort_rearrange_tp util_sort_rearrange_tp proc~util_sort_rearrange_tp->interface~util_sort_rearrange_body proc~util_sort_rearrange_pl util_sort_rearrange_pl proc~util_sort_rearrange_pl->interface~util_sort_rearrange_body interface~util_sort_rearrange_pl util_sort_rearrange_pl interface~util_sort_rearrange_pl->proc~util_sort_rearrange_pl interface~util_sort_rearrange_tp util_sort_rearrange_tp interface~util_sort_rearrange_tp->proc~util_sort_rearrange_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_sort_rearrange_body(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order)","tags":"","loc":"interface/util_sort_rearrange_body.html"},{"title":"util_sort_rearrange_pl – swiftest","text":"interface Calls interface~~util_sort_rearrange_pl~~CallsGraph interface~util_sort_rearrange_pl util_sort_rearrange_pl proc~util_sort_rearrange_pl util_sort_rearrange_pl interface~util_sort_rearrange_pl->proc~util_sort_rearrange_pl interface~util_sort_rearrange~2 util_sort_rearrange proc~util_sort_rearrange_pl->interface~util_sort_rearrange~2 interface~util_sort_rearrange_body util_sort_rearrange_body proc~util_sort_rearrange_pl->interface~util_sort_rearrange_body proc~util_sort_rearrange_body util_sort_rearrange_body interface~util_sort_rearrange_body->proc~util_sort_rearrange_body proc~util_sort_rearrange_body->interface~util_sort_rearrange~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order)","tags":"","loc":"interface/util_sort_rearrange_pl.html"},{"title":"util_sort_rearrange_tp – swiftest","text":"interface Calls interface~~util_sort_rearrange_tp~~CallsGraph interface~util_sort_rearrange_tp util_sort_rearrange_tp proc~util_sort_rearrange_tp util_sort_rearrange_tp interface~util_sort_rearrange_tp->proc~util_sort_rearrange_tp interface~util_sort_rearrange~2 util_sort_rearrange proc~util_sort_rearrange_tp->interface~util_sort_rearrange~2 interface~util_sort_rearrange_body util_sort_rearrange_body proc~util_sort_rearrange_tp->interface~util_sort_rearrange_body proc~util_sort_rearrange_body util_sort_rearrange_body interface~util_sort_rearrange_body->proc~util_sort_rearrange_body proc~util_sort_rearrange_body->interface~util_sort_rearrange~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order)","tags":"","loc":"interface/util_sort_rearrange_tp.html"},{"title":"util_sort_body – swiftest","text":"interface Calls interface~~util_sort_body~~CallsGraph interface~util_sort_body util_sort_body proc~util_sort_body util_sort_body interface~util_sort_body->proc~util_sort_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~util_sort_body~~CalledByGraph interface~util_sort_body util_sort_body proc~util_sort_pl util_sort_pl proc~util_sort_pl->interface~util_sort_body proc~util_sort_tp util_sort_tp proc~util_sort_tp->interface~util_sort_body interface~util_sort_tp util_sort_tp interface~util_sort_tp->proc~util_sort_tp interface~util_sort_pl util_sort_pl interface~util_sort_pl->proc~util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_sort_body(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order","tags":"","loc":"interface/util_sort_body.html"},{"title":"util_sort_pl – swiftest","text":"interface Calls interface~~util_sort_pl~~CallsGraph interface~util_sort_pl util_sort_pl proc~util_sort_pl util_sort_pl interface~util_sort_pl->proc~util_sort_pl interface~util_sort_body util_sort_body proc~util_sort_pl->interface~util_sort_body proc~util_sort_body util_sort_body interface~util_sort_body->proc~util_sort_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order","tags":"","loc":"interface/util_sort_pl.html"},{"title":"util_sort_tp – swiftest","text":"interface Calls interface~~util_sort_tp~~CallsGraph interface~util_sort_tp util_sort_tp proc~util_sort_tp util_sort_tp interface~util_sort_tp->proc~util_sort_tp interface~util_sort_body util_sort_body proc~util_sort_tp->interface~util_sort_body proc~util_sort_body util_sort_body interface~util_sort_body->proc~util_sort_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order","tags":"","loc":"interface/util_sort_tp.html"},{"title":"util_spill – swiftest","text":"public interface util_spill Called by interface~~util_spill~2~~CalledByGraph interface~util_spill~2 util_spill proc~util_spill_encounter util_spill_encounter proc~util_spill_encounter->interface~util_spill~2 proc~util_spill_body util_spill_body proc~util_spill_body->interface~util_spill~2 proc~util_spill_pl util_spill_pl proc~util_spill_pl->interface~util_spill~2 interface~util_spill_body util_spill_body proc~util_spill_pl->interface~util_spill_body proc~util_spill_tp util_spill_tp proc~util_spill_tp->interface~util_spill~2 proc~util_spill_tp->interface~util_spill_body interface~util_spill_body->proc~util_spill_body interface~util_spill_tp util_spill_tp interface~util_spill_tp->proc~util_spill_tp interface~util_spill_pl util_spill_pl interface~util_spill_pl->proc~util_spill_pl interface~util_spill_encounter util_spill_encounter interface~util_spill_encounter->proc~util_spill_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines util_spill_arr_char_string util_spill_arr_DP util_spill_arr_DPvec util_spill_arr_I4B util_spill_arr_I8B util_spill_arr_info util_spill_arr_logical Subroutines public subroutine util_spill_arr_char_string(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: keeps Array of values to keep character(len=STRMAX), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine util_spill_arr_DP(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: keeps Array of values to keep real(kind=DP), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine util_spill_arr_DPvec(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: keeps Array of values to keep real(kind=DP), intent(inout), dimension(:,:), allocatable :: discards Array discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine util_spill_arr_I4B(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: keeps Array of values to keep integer(kind=I4B), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine util_spill_arr_I8B(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(inout), dimension(:), allocatable :: keeps Array of values to keep integer(kind=I8B), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine util_spill_arr_info(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine util_spill_arr_logical(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: keeps Array of values to keep logical, intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"interface/util_spill~2.html"},{"title":"util_spill_body – swiftest","text":"interface Calls interface~~util_spill_body~~CallsGraph interface~util_spill_body util_spill_body proc~util_spill_body util_spill_body interface~util_spill_body->proc~util_spill_body interface~util_spill~2 util_spill proc~util_spill_body->interface~util_spill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~util_spill_body~~CalledByGraph interface~util_spill_body util_spill_body proc~util_spill_pl util_spill_pl proc~util_spill_pl->interface~util_spill_body proc~util_spill_tp util_spill_tp proc~util_spill_tp->interface~util_spill_body interface~util_spill_tp util_spill_tp interface~util_spill_tp->proc~util_spill_tp interface~util_spill_pl util_spill_pl interface~util_spill_pl->proc~util_spill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_spill_body(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"interface/util_spill_body.html"},{"title":"util_spill_encounter – swiftest","text":"interface Calls interface~~util_spill_encounter~~CallsGraph interface~util_spill_encounter util_spill_encounter proc~util_spill_encounter util_spill_encounter interface~util_spill_encounter->proc~util_spill_encounter interface~util_spill~2 util_spill proc~util_spill_encounter->interface~util_spill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_spill_encounter(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list","tags":"","loc":"interface/util_spill_encounter.html"},{"title":"util_spill_pl – swiftest","text":"interface Calls interface~~util_spill_pl~~CallsGraph interface~util_spill_pl util_spill_pl proc~util_spill_pl util_spill_pl interface~util_spill_pl->proc~util_spill_pl interface~util_spill~2 util_spill proc~util_spill_pl->interface~util_spill~2 interface~util_spill_body util_spill_body proc~util_spill_pl->interface~util_spill_body proc~util_spill_body util_spill_body interface~util_spill_body->proc~util_spill_body proc~util_spill_body->interface~util_spill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"interface/util_spill_pl.html"},{"title":"util_spill_tp – swiftest","text":"interface Calls interface~~util_spill_tp~~CallsGraph interface~util_spill_tp util_spill_tp proc~util_spill_tp util_spill_tp interface~util_spill_tp->proc~util_spill_tp interface~util_spill~2 util_spill proc~util_spill_tp->interface~util_spill~2 interface~util_spill_body util_spill_body proc~util_spill_tp->interface~util_spill_body proc~util_spill_body util_spill_body interface~util_spill_body->proc~util_spill_body proc~util_spill_body->interface~util_spill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"interface/util_spill_tp.html"},{"title":"util_valid_id_system – swiftest","text":"interface Calls interface~~util_valid_id_system~~CallsGraph interface~util_valid_id_system util_valid_id_system proc~util_valid_id_system util_valid_id_system interface~util_valid_id_system->proc~util_valid_id_system interface~util_exit util_exit proc~util_valid_id_system->interface~util_exit interface~util_sort util_sort proc~util_valid_id_system->interface~util_sort proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_valid_id_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"interface/util_valid_id_system.html"},{"title":"util_version – swiftest","text":"interface Calls interface~~util_version~~CallsGraph interface~util_version util_version proc~util_version util_version interface~util_version->proc~util_version Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~util_version~~CalledByGraph interface~util_version util_version proc~io_get_args io_get_args proc~io_get_args->interface~util_version interface~io_get_args io_get_args interface~io_get_args->proc~io_get_args Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine util_version() Implementation → Arguments None","tags":"","loc":"interface/util_version.html"},{"title":"lambda_init_0 – swiftest","text":"public function lambda_init_0(lambda) Arguments Type Intent Optional Attributes Name procedure( lambda0 ) :: lambda Return Value type( lambda_obj ) Called by proc~~lambda_init_0~~CalledByGraph proc~lambda_init_0 lambda_init_0 interface~lambda_obj~2 lambda_obj interface~lambda_obj~2->proc~lambda_init_0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lambda_init_0.html"},{"title":"lambda_init_0_err – swiftest","text":"public function lambda_init_0_err(lambda, lerr) Arguments Type Intent Optional Attributes Name procedure( lambda0err ) :: lambda logical, intent(in) :: lerr Return Value type( lambda_obj_err ) Called by proc~~lambda_init_0_err~~CalledByGraph proc~lambda_init_0_err lambda_init_0_err interface~lambda_obj~2 lambda_obj interface~lambda_obj~2->proc~lambda_init_0_err Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lambda_init_0_err.html"},{"title":"lambda_init_tvar – swiftest","text":"public function lambda_init_tvar(lambda, t) Arguments Type Intent Optional Attributes Name procedure( lambda0tvar ) :: lambda real(kind=DP), intent(in) :: t Return Value type( lambda_obj_tvar ) Called by proc~~lambda_init_tvar~~CalledByGraph proc~lambda_init_tvar lambda_init_tvar interface~lambda_obj~2 lambda_obj interface~lambda_obj~2->proc~lambda_init_tvar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lambda_init_tvar.html"},{"title":"lambda_eval_0 – swiftest","text":"public function lambda_eval_0(self, x) result(y) Arguments Type Intent Optional Attributes Name class( lambda_obj ), intent(inout) :: self real(kind=DP), intent(in), dimension(:) :: x Return Value real(kind=DP) Contents None","tags":"","loc":"proc/lambda_eval_0.html"},{"title":"lambda_eval_0_err – swiftest","text":"public function lambda_eval_0_err(self, x) result(y) Arguments Type Intent Optional Attributes Name class( lambda_obj_err ), intent(inout) :: self real(kind=DP), intent(in), dimension(:) :: x Return Value real(kind=DP) Contents None","tags":"","loc":"proc/lambda_eval_0_err.html"},{"title":"lambda_eval_tvar – swiftest","text":"public function lambda_eval_tvar(self, x, t) result(y) Arguments Type Intent Optional Attributes Name class( lambda_obj_tvar ), intent(inout) :: self real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in) :: t Return Value real(kind=DP),\n  dimension(:),allocatable Contents None","tags":"","loc":"proc/lambda_eval_tvar.html"},{"title":"lambda_destroy – swiftest","text":"public subroutine lambda_destroy(self) Arguments Type Intent Optional Attributes Name type( lambda_obj ) :: self Contents None","tags":"","loc":"proc/lambda_destroy.html"},{"title":"lambda_obj – swiftest","text":"public interface lambda_obj Calls interface~~lambda_obj~2~~CallsGraph interface~lambda_obj~2 lambda_obj proc~lambda_init_0_err lambda_init_0_err interface~lambda_obj~2->proc~lambda_init_0_err proc~lambda_init_tvar lambda_init_tvar interface~lambda_obj~2->proc~lambda_init_tvar proc~lambda_init_0 lambda_init_0 interface~lambda_obj~2->proc~lambda_init_0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures lambda_init_0 lambda_init_0_err lambda_init_tvar Module Procedures public function lambda_init_0 (lambda) Arguments Type Intent Optional Attributes Name procedure( lambda0 ) :: lambda Return Value type( lambda_obj ) public function lambda_init_0_err (lambda, lerr) Arguments Type Intent Optional Attributes Name procedure( lambda0err ) :: lambda logical, intent(in) :: lerr Return Value type( lambda_obj_err ) public function lambda_init_tvar (lambda, t) Arguments Type Intent Optional Attributes Name procedure( lambda0tvar ) :: lambda real(kind=DP), intent(in) :: t Return Value type( lambda_obj_tvar )","tags":"","loc":"interface/lambda_obj~2.html"},{"title":"fraggle_generate_pos_vec – swiftest","text":"subroutine fraggle_generate_pos_vec(frag, colliders, r_max_start) Initializes the orbits of the fragments around the center of mass. The fragments are initially placed on a plane defined by the \n pre-impact angular momentum. They are distributed on an ellipse surrounding the center of mass.\n The initial positions do not conserve energy or momentum, so these need to be adjusted later. Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: frag Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object real(kind=DP), intent(in) :: r_max_start Initial guess for the starting maximum radial distance of fragments Calls proc~~fraggle_generate_pos_vec~~CallsGraph proc~fraggle_generate_pos_vec fraggle_generate_pos_vec interface~fraggle_util_shift_vector_to_origin fraggle_util_shift_vector_to_origin proc~fraggle_generate_pos_vec->interface~fraggle_util_shift_vector_to_origin proc~fraggle_util_shift_vector_to_origin fraggle_util_shift_vector_to_origin interface~fraggle_util_shift_vector_to_origin->proc~fraggle_util_shift_vector_to_origin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fraggle_generate_pos_vec~~CalledByGraph proc~fraggle_generate_pos_vec fraggle_generate_pos_vec proc~fraggle_generate_fragments fraggle_generate_fragments proc~fraggle_generate_fragments->proc~fraggle_generate_pos_vec interface~fraggle_generate_fragments fraggle_generate_fragments interface~fraggle_generate_fragments->proc~fraggle_generate_fragments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_generate_pos_vec.html"},{"title":"fraggle_generate_spins – swiftest","text":"subroutine fraggle_generate_spins(frag, colliders, f_spin, lfailure) Calculates the spins of a collection of fragments such that they conserve angular momentum without blowing the fragment kinetic energy budget. A failure will trigger a restructuring of the fragments so we will try new values of the radial position distribution. Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: frag Fraggle fragment system object class( fraggle_colliders ), intent(in) :: colliders Fraggle collider system object real(kind=DP), intent(in) :: f_spin Fraction of energy or momentum that goes into spin (whichever gives the lowest kinetic energy) logical, intent(out) :: lfailure Logical flag indicating whether this step fails or succeeds! Calls proc~~fraggle_generate_spins~~CallsGraph proc~fraggle_generate_spins fraggle_generate_spins interface~fraggle_io_log_one_message fraggle_io_log_one_message proc~fraggle_generate_spins->interface~fraggle_io_log_one_message proc~fraggle_io_log_one_message fraggle_io_log_one_message interface~fraggle_io_log_one_message->proc~fraggle_io_log_one_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fraggle_generate_spins~~CalledByGraph proc~fraggle_generate_spins fraggle_generate_spins proc~fraggle_generate_fragments fraggle_generate_fragments proc~fraggle_generate_fragments->proc~fraggle_generate_spins interface~fraggle_generate_fragments fraggle_generate_fragments interface~fraggle_generate_fragments->proc~fraggle_generate_fragments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_generate_spins.html"},{"title":"fraggle_generate_tan_vel – swiftest","text":"subroutine fraggle_generate_tan_vel(frag, colliders, lfailure) Adjusts the tangential velocities and spins of a collection of fragments such that they conserve angular momentum without blowing the fragment kinetic energy budget.\n This procedure works in several stages, with a goal to solve the angular and linear momentum constraints on the fragments, while still leaving a positive balance of\n our fragment kinetic energy (frag%ke_budget) that we can put into the radial velocity distribution. The first thing we'll try to do is solve for the tangential velocities of the first 6 fragments, using angular and linear momentum as constraints and an initial\n tangential velocity distribution for the remaining bodies (if there are any) that distributes their angular momentum equally between them.\n If that doesn't work and we blow our kinetic energy budget, we will attempt to find a tangential velocity distribution that minimizes the kinetic energy while\n conserving momentum. A failure will trigger a restructuring of the fragments so we will try new values of the radial position distribution. Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: frag Fraggle fragment system object class( fraggle_colliders ), intent(in) :: colliders Fraggle collider system object logical, intent(out) :: lfailure Logical flag indicating whether this step fails or succeeds Calls proc~~fraggle_generate_tan_vel~~CallsGraph proc~fraggle_generate_tan_vel fraggle_generate_tan_vel interface~fraggle_util_vmag_to_vb fraggle_util_vmag_to_vb proc~fraggle_generate_tan_vel->interface~fraggle_util_vmag_to_vb lambda_obj lambda_obj proc~fraggle_generate_tan_vel->lambda_obj interface~fraggle_io_log_one_message fraggle_io_log_one_message proc~fraggle_generate_tan_vel->interface~fraggle_io_log_one_message util_minimize_bfgs util_minimize_bfgs proc~fraggle_generate_tan_vel->util_minimize_bfgs proc~fraggle_util_vmag_to_vb fraggle_util_vmag_to_vb interface~fraggle_util_vmag_to_vb->proc~fraggle_util_vmag_to_vb proc~fraggle_io_log_one_message fraggle_io_log_one_message interface~fraggle_io_log_one_message->proc~fraggle_io_log_one_message interface~fraggle_util_shift_vector_to_origin fraggle_util_shift_vector_to_origin proc~fraggle_util_vmag_to_vb->interface~fraggle_util_shift_vector_to_origin proc~fraggle_util_shift_vector_to_origin fraggle_util_shift_vector_to_origin interface~fraggle_util_shift_vector_to_origin->proc~fraggle_util_shift_vector_to_origin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fraggle_generate_tan_vel~~CalledByGraph proc~fraggle_generate_tan_vel fraggle_generate_tan_vel proc~fraggle_generate_fragments fraggle_generate_fragments proc~fraggle_generate_fragments->proc~fraggle_generate_tan_vel interface~fraggle_generate_fragments fraggle_generate_fragments interface~fraggle_generate_fragments->proc~fraggle_generate_fragments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_generate_tan_vel.html"},{"title":"fraggle_generate_rad_vel – swiftest","text":"subroutine fraggle_generate_rad_vel(frag, colliders, lfailure) Adjust the fragment velocities to set the fragment orbital kinetic energy. This will minimize the difference between the fragment kinetic energy and the energy budget Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: frag Fraggle fragment system object class( fraggle_colliders ), intent(in) :: colliders Fraggle collider system object logical, intent(out) :: lfailure Logical flag indicating whether this step fails or succeeds! Calls proc~~fraggle_generate_rad_vel~~CallsGraph proc~fraggle_generate_rad_vel fraggle_generate_rad_vel interface~fraggle_util_vmag_to_vb fraggle_util_vmag_to_vb proc~fraggle_generate_rad_vel->interface~fraggle_util_vmag_to_vb lambda_obj lambda_obj proc~fraggle_generate_rad_vel->lambda_obj interface~fraggle_io_log_one_message fraggle_io_log_one_message proc~fraggle_generate_rad_vel->interface~fraggle_io_log_one_message util_minimize_bfgs util_minimize_bfgs proc~fraggle_generate_rad_vel->util_minimize_bfgs proc~fraggle_util_vmag_to_vb fraggle_util_vmag_to_vb interface~fraggle_util_vmag_to_vb->proc~fraggle_util_vmag_to_vb proc~fraggle_io_log_one_message fraggle_io_log_one_message interface~fraggle_io_log_one_message->proc~fraggle_io_log_one_message interface~fraggle_util_shift_vector_to_origin fraggle_util_shift_vector_to_origin proc~fraggle_util_vmag_to_vb->interface~fraggle_util_shift_vector_to_origin proc~fraggle_util_shift_vector_to_origin fraggle_util_shift_vector_to_origin interface~fraggle_util_shift_vector_to_origin->proc~fraggle_util_shift_vector_to_origin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fraggle_generate_rad_vel~~CalledByGraph proc~fraggle_generate_rad_vel fraggle_generate_rad_vel proc~fraggle_generate_fragments fraggle_generate_fragments proc~fraggle_generate_fragments->proc~fraggle_generate_rad_vel interface~fraggle_generate_fragments fraggle_generate_fragments interface~fraggle_generate_fragments->proc~fraggle_generate_fragments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_generate_rad_vel.html"},{"title":"fraggle_regime_collresolve – swiftest","text":"subroutine fraggle_regime_collresolve(Mcb, m1, m2, rad1, rad2, xh1, xh2, vb1, vb2, den1, den2, min_mfrag, regime, Mlr, Mslr, Qloss) Determine the collisional regime of two colliding bodies. \n Current version requires all values to be converted to SI units prior to calling the function\n       References:\n       Kokubo, E., Genda, H., 2010. Formation of Terrestrial Planets from Protoplanets Under a Realistic Accretion \n          Condition. ApJL 714, L21. https://doi.org/10.1088/2041-8205/714/1/L21\n       Leinhardt, Z.M., Stewart, S.T., 2012. Collisions between Gravity-dominated Bodies. I. Outcome Regimes and Scaling \n          Laws 745, 79. https://doi.org/10.1088/0004-637X/745/1/79\n       Mustill, A.J., Davies, M.B., Johansen, A., 2018. The dynamical evolution of transiting planetary systems including \n          a realistic collision prescription. Mon Not R Astron Soc 478, 2896–2908. https://doi.org/10.1093/mnras/sty1273\n       Rufu, R., Aharonson, O., 2019. Impact Dynamics of Moons Within a Planetary Potential. J. Geophys. Res. Planets 124, \n          1008–1019. https://doi.org/10.1029/2018JE005798\n       Stewart, S.T., Leinhardt, Z.M., 2012. Collisions between Gravity-dominated Bodies. II. The Diversity of Impact \n          Outcomes during the End Stage of Planet Formation. ApJ 751, 32. https://doi.org/10.1088/0004-637X/751/1/32 Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: Mcb real(kind=DP), intent(in) :: m1 real(kind=DP), intent(in) :: m2 real(kind=DP), intent(in) :: rad1 real(kind=DP), intent(in) :: rad2 real(kind=DP), intent(in), dimension(:) :: xh1 real(kind=DP), intent(in), dimension(:) :: xh2 real(kind=DP), intent(in), dimension(:) :: vb1 real(kind=DP), intent(in), dimension(:) :: vb2 real(kind=DP), intent(in) :: den1 real(kind=DP), intent(in) :: den2 real(kind=DP), intent(in) :: min_mfrag integer(kind=I4B), intent(out) :: regime real(kind=DP), intent(out) :: Mlr real(kind=DP), intent(out) :: Mslr real(kind=DP), intent(out) :: Qloss The residual energy after the collision Calls proc~~fraggle_regime_collresolve~~CallsGraph proc~fraggle_regime_collresolve fraggle_regime_collresolve interface~fraggle_io_log_one_message fraggle_io_log_one_message proc~fraggle_regime_collresolve->interface~fraggle_io_log_one_message proc~fraggle_io_log_one_message fraggle_io_log_one_message interface~fraggle_io_log_one_message->proc~fraggle_io_log_one_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_regime_collresolve.html"},{"title":"rmvs_interp_out – swiftest","text":"subroutine rmvs_interp_out(cb, pl, dt) Interpolate planet positions between two Keplerian orbits in outer encounter region Adapted from David E. Kaufmann's Swifter routine rmvs_interp_out.f90 Adapted from Hal Levison's Swift routine rmvs3_interp.f Arguments Type Intent Optional Attributes Name class( rmvs_cb ), intent(inout) :: cb RMVS central body object class( rmvs_pl ), intent(inout) :: pl RMVS massive body object real(kind=DP), intent(in) :: dt Step size Calls proc~~rmvs_interp_out~~CallsGraph proc~rmvs_interp_out rmvs_interp_out util_exit util_exit proc~rmvs_interp_out->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_interp_out~~CalledByGraph proc~rmvs_interp_out rmvs_interp_out proc~rmvs_step_system rmvs_step_system proc~rmvs_step_system->proc~rmvs_interp_out interface~rmvs_step_system rmvs_step_system interface~rmvs_step_system->proc~rmvs_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_interp_out.html"},{"title":"rmvs_step_out – swiftest","text":"subroutine rmvs_step_out(cb, pl, tp, system, param, t, dt) Step ACTIVE test particles ahead in the outer encounter region, setting up and calling the inner region\n    integration if necessar Adapted from Hal Levison's Swift routines rmvs3_step_out.f and rmvs3_step_out2.f\n Adapted from David E. Kaufmann's Swifter routines rmvs_step_out.f90 and rmvs_step_out2.f90 Arguments Type Intent Optional Attributes Name class( rmvs_cb ), intent(inout) :: cb RMVS central body object class( rmvs_pl ), intent(inout) :: pl RMVS massive body object class( rmvs_tp ), intent(inout) :: tp RMVS test particle object class( rmvs_nbody_system ), intent(inout) :: system RMVS nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current stepsiz Calls proc~~rmvs_step_out~~CallsGraph proc~rmvs_step_out rmvs_step_out proc~rmvs_interp_in rmvs_interp_in proc~rmvs_step_out->proc~rmvs_interp_in proc~rmvs_step_in rmvs_step_in proc~rmvs_step_out->proc~rmvs_step_in util_exit util_exit proc~rmvs_interp_in->util_exit proc~rmvs_make_planetocentric rmvs_make_planetocentric proc~rmvs_step_in->proc~rmvs_make_planetocentric proc~rmvs_peri_tp rmvs_peri_tp proc~rmvs_step_in->proc~rmvs_peri_tp proc~rmvs_end_planetocentric rmvs_end_planetocentric proc~rmvs_step_in->proc~rmvs_end_planetocentric vpc vpc proc~rmvs_peri_tp->vpc xpc xpc proc~rmvs_peri_tp->xpc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_step_out~~CalledByGraph proc~rmvs_step_out rmvs_step_out proc~rmvs_step_system rmvs_step_system proc~rmvs_step_system->proc~rmvs_step_out interface~rmvs_step_system rmvs_step_system interface~rmvs_step_system->proc~rmvs_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_step_out.html"},{"title":"rmvs_interp_in – swiftest","text":"subroutine rmvs_interp_in(cb, pl, system, param, dt, outer_index) Interpolate planet positions between two Keplerian orbits in inner encounter regio Adapted from David E. Kaufmann's Swifter routine rmvs_interp_in.f90 Adapted from Hal Levison's Swift routine rmvs3_interp.f Arguments Type Intent Optional Attributes Name class( rmvs_cb ), intent(inout) :: cb RMVS cenral body object class( rmvs_pl ), intent(inout) :: pl RMVS massive body object class( rmvs_nbody_system ), intent(inout) :: system RMVS nbody system object class(swiftest_parameters), intent(in) :: param Swiftest parameters file real(kind=DP), intent(in) :: dt Step size integer(kind=I4B), intent(in) :: outer_index Outer substep number within current set Calls proc~~rmvs_interp_in~~CallsGraph proc~rmvs_interp_in rmvs_interp_in util_exit util_exit proc~rmvs_interp_in->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_interp_in~~CalledByGraph proc~rmvs_interp_in rmvs_interp_in proc~rmvs_step_out rmvs_step_out proc~rmvs_step_out->proc~rmvs_interp_in proc~rmvs_step_system rmvs_step_system proc~rmvs_step_system->proc~rmvs_step_out interface~rmvs_step_system rmvs_step_system interface~rmvs_step_system->proc~rmvs_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_interp_in.html"},{"title":"rmvs_step_in – swiftest","text":"subroutine rmvs_step_in(cb, pl, tp, param, outer_time, dto) Step active test particles ahead in the inner encounter region Adapted from Hal Levison's Swift routine rmvs3_step_in.f\n Adapted from David E. Kaufmann's Swifter routine rmvs_step_in.f90 Arguments Type Intent Optional Attributes Name class( rmvs_cb ), intent(inout) :: cb RMVS central body object class( rmvs_pl ), intent(inout) :: pl RMVS massive body object class( rmvs_tp ), intent(inout) :: tp RMVS test particle object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: outer_time Current time real(kind=DP), intent(in) :: dto Outer step size Calls proc~~rmvs_step_in~~CallsGraph proc~rmvs_step_in rmvs_step_in proc~rmvs_make_planetocentric rmvs_make_planetocentric proc~rmvs_step_in->proc~rmvs_make_planetocentric proc~rmvs_peri_tp rmvs_peri_tp proc~rmvs_step_in->proc~rmvs_peri_tp proc~rmvs_end_planetocentric rmvs_end_planetocentric proc~rmvs_step_in->proc~rmvs_end_planetocentric vpc vpc proc~rmvs_peri_tp->vpc xpc xpc proc~rmvs_peri_tp->xpc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_step_in~~CalledByGraph proc~rmvs_step_in rmvs_step_in proc~rmvs_step_out rmvs_step_out proc~rmvs_step_out->proc~rmvs_step_in proc~rmvs_step_system rmvs_step_system proc~rmvs_step_system->proc~rmvs_step_out interface~rmvs_step_system rmvs_step_system interface~rmvs_step_system->proc~rmvs_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_step_in.html"},{"title":"rmvs_make_planetocentric – swiftest","text":"subroutine rmvs_make_planetocentric(param, cb, pl, tp) When encounters are detected, this method will call the interpolation methods for the planets and \n creates a Swiftest test particle structure for each planet's encountering test particles to simplify the \n planetocentric calculations. This subroutine is not based on an existing one from Swift and Swifter Arguments Type Intent Optional Attributes Name class(swiftest_parameters), intent(in) :: param Current run configuration paramete class( rmvs_cb ), intent(inout) :: cb RMVS central body object class( rmvs_pl ), intent(inout) :: pl RMVS massive body object class( rmvs_tp ), intent(inout) :: tp RMVS test particle object Called by proc~~rmvs_make_planetocentric~~CalledByGraph proc~rmvs_make_planetocentric rmvs_make_planetocentric proc~rmvs_step_in rmvs_step_in proc~rmvs_step_in->proc~rmvs_make_planetocentric proc~rmvs_step_out rmvs_step_out proc~rmvs_step_out->proc~rmvs_step_in proc~rmvs_step_system rmvs_step_system proc~rmvs_step_system->proc~rmvs_step_out interface~rmvs_step_system rmvs_step_system interface~rmvs_step_system->proc~rmvs_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_make_planetocentric.html"},{"title":"rmvs_peri_tp – swiftest","text":"subroutine rmvs_peri_tp(tp, pl, t, dt, lfirst, inner_index, ipleP, param) Determine planetocentric pericenter passages for test particles in close encounters with a planet Adapted from Hal Levison's Swift routine Adapted from Hal Levison's Swift routine util_peri.f\n Adapted from David E. Kaufmann's Swifter routine rmvs_peri.f90 Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: tp RMVS test particle object (planetocentric) class( rmvs_pl ), intent(inout) :: pl RMVS massive body object (heliocentric) real(kind=DP), intent(in) :: t current time real(kind=DP), intent(in) :: dt step size logical, intent(in) :: lfirst Logical flag indicating whether current invocation is the first integer(kind=I4B), intent(in) :: inner_index Outer substep number within current set integer(kind=I4B), intent(in) :: ipleP index of RMVS planet being closely encountered class(swiftest_parameters), intent(in) :: param Current run configuration parameters Calls proc~~rmvs_peri_tp~~CallsGraph proc~rmvs_peri_tp rmvs_peri_tp vpc vpc proc~rmvs_peri_tp->vpc xpc xpc proc~rmvs_peri_tp->xpc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_peri_tp~~CalledByGraph proc~rmvs_peri_tp rmvs_peri_tp proc~rmvs_step_in rmvs_step_in proc~rmvs_step_in->proc~rmvs_peri_tp proc~rmvs_step_out rmvs_step_out proc~rmvs_step_out->proc~rmvs_step_in proc~rmvs_step_system rmvs_step_system proc~rmvs_step_system->proc~rmvs_step_out interface~rmvs_step_system rmvs_step_system interface~rmvs_step_system->proc~rmvs_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_peri_tp.html"},{"title":"rmvs_end_planetocentric – swiftest","text":"subroutine rmvs_end_planetocentric(pl, tp) Deallocates all of the encountering particle data structures for next time Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: pl RMVS massive body object class( rmvs_tp ), intent(inout) :: tp RMVS test particle objec Called by proc~~rmvs_end_planetocentric~~CalledByGraph proc~rmvs_end_planetocentric rmvs_end_planetocentric proc~rmvs_step_in rmvs_step_in proc~rmvs_step_in->proc~rmvs_end_planetocentric proc~rmvs_step_out rmvs_step_out proc~rmvs_step_out->proc~rmvs_step_in proc~rmvs_step_system rmvs_step_system proc~rmvs_step_system->proc~rmvs_step_out interface~rmvs_step_system rmvs_step_system interface~rmvs_step_system->proc~rmvs_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_end_planetocentric.html"},{"title":"kick_getacch_int_pl – swiftest","text":"module subroutine kick_getacch_int_pl(self) Interface → Compute direct cross (third) term heliocentric accelerations of massive bodies Adapted from Hal Levison's Swift routine getacch_ah3.f\n Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah3.f90 and helio_kick_getacch_int.f90 Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object Calls proc~~kick_getacch_int_pl~~CallsGraph proc~kick_getacch_int_pl kick_getacch_int_pl interface~kick_getacch_int_all_pl kick_getacch_int_all_pl proc~kick_getacch_int_pl->interface~kick_getacch_int_all_pl proc~kick_getacch_int_all_pl kick_getacch_int_all_pl interface~kick_getacch_int_all_pl->proc~kick_getacch_int_all_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~kick_getacch_int_pl~~CalledByGraph proc~kick_getacch_int_pl kick_getacch_int_pl interface~kick_getacch_int_pl kick_getacch_int_pl interface~kick_getacch_int_pl->proc~kick_getacch_int_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/kick_getacch_int_pl.html"},{"title":"kick_getacch_int_tp – swiftest","text":"module subroutine kick_getacch_int_tp(self, GMpl, xhp, npl) Interface → Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies Adapted from Hal Levison's Swift routine getacch_ah3_tp.f\n Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah3.f90 and helio_kick_getacch_int_tp.f90 Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object real(kind=DP), intent(in), dimension(:) :: GMpl Massive body masses real(kind=DP), intent(in), dimension(:,:) :: xhp Massive body position vectors integer(kind=I4B), intent(in) :: npl Number of active massive bodies Calls proc~~kick_getacch_int_tp~~CallsGraph proc~kick_getacch_int_tp kick_getacch_int_tp interface~kick_getacch_int_all_tp kick_getacch_int_all_tp proc~kick_getacch_int_tp->interface~kick_getacch_int_all_tp proc~kick_getacch_int_all_tp kick_getacch_int_all_tp interface~kick_getacch_int_all_tp->proc~kick_getacch_int_all_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~kick_getacch_int_tp~~CalledByGraph proc~kick_getacch_int_tp kick_getacch_int_tp interface~kick_getacch_int_tp kick_getacch_int_tp interface~kick_getacch_int_tp->proc~kick_getacch_int_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/kick_getacch_int_tp.html"},{"title":"kick_getacch_int_all_pl – swiftest","text":"module subroutine kick_getacch_int_all_pl(npl, nplpl, k_plpl, x, Gmass, radius, acc) Interface → Compute direct cross (third) term heliocentric accelerations for massive bodies, with parallelization Adapted from Hal Levison's Swift routine getacch_ah3.f\n Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah3.f90 and helio_kick_getacch_int.f9 Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl Number of massive bodies integer(kind=I8B), intent(in) :: nplpl Number of massive body interactions to compute integer(kind=I4B), intent(in), dimension(:,:) :: k_plpl Array of interaction pair indices (flattened upper triangular matrix) real(kind=DP), intent(in), dimension(:,:) :: x Position vector array real(kind=DP), intent(in), dimension(:) :: Gmass Array of massive body G*mass real(kind=DP), intent(in), dimension(:) :: radius Array of massive body radii real(kind=DP), intent(inout), dimension(:,:) :: acc Acceleration vector array Called by proc~~kick_getacch_int_all_pl~~CalledByGraph proc~kick_getacch_int_all_pl kick_getacch_int_all_pl interface~kick_getacch_int_all_pl kick_getacch_int_all_pl interface~kick_getacch_int_all_pl->proc~kick_getacch_int_all_pl proc~kick_getacch_int_pl kick_getacch_int_pl proc~kick_getacch_int_pl->interface~kick_getacch_int_all_pl interface~kick_getacch_int_pl kick_getacch_int_pl interface~kick_getacch_int_pl->proc~kick_getacch_int_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/kick_getacch_int_all_pl.html"},{"title":"kick_getacch_int_all_tp – swiftest","text":"module subroutine kick_getacch_int_all_tp(ntp, npl, xtp, xpl, GMpl, lmask, acc) Interface → Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies with parallelisim Adapted from Hal Levison's Swift routine getacch_ah3_tp.f\n Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah3.f90 and helio_kick_getacch_int_tp.f99 Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp Number of test particles integer(kind=I4B), intent(in) :: npl Number of massive bodies real(kind=DP), intent(in), dimension(:,:) :: xtp Test particle position vector array real(kind=DP), intent(in), dimension(:,:) :: xpl Massive body particle position vector array real(kind=DP), intent(in), dimension(:) :: GMpl Array of massive body G*mass logical, intent(in), dimension(:) :: lmask Logical mask indicating which test particles should be computed real(kind=DP), intent(inout), dimension(:,:) :: acc Acceleration vector array Called by proc~~kick_getacch_int_all_tp~~CalledByGraph proc~kick_getacch_int_all_tp kick_getacch_int_all_tp interface~kick_getacch_int_all_tp kick_getacch_int_all_tp interface~kick_getacch_int_all_tp->proc~kick_getacch_int_all_tp proc~kick_getacch_int_tp kick_getacch_int_tp proc~kick_getacch_int_tp->interface~kick_getacch_int_all_tp interface~kick_getacch_int_tp kick_getacch_int_tp interface~kick_getacch_int_tp->proc~kick_getacch_int_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/kick_getacch_int_all_tp.html"},{"title":"kick_getacch_int_one_pl – swiftest","text":"pure module subroutine kick_getacch_int_one_pl(rji2, xr, yr, zr, Gmi, Gmj, axi, ayi, azi, axj, ayj, azj) Interface → Compute direct cross (third) term heliocentric accelerations for a single pair of massive bodies Adapted from Hal Levison's Swift routine getacch_ah3.f\n Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah3.f90 and helio_kick_getacch_int.f9 Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: rji2 Square of distance between the two bodies real(kind=DP), intent(in) :: xr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: yr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: zr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: Gmi G*mass of body i real(kind=DP), intent(in) :: Gmj G*mass of body j real(kind=DP), intent(inout) :: axi Acceleration vector components of body i real(kind=DP), intent(inout) :: ayi Acceleration vector components of body i real(kind=DP), intent(inout) :: azi Acceleration vector components of body i real(kind=DP), intent(inout) :: axj Acceleration vector components of body j real(kind=DP), intent(inout) :: ayj Acceleration vector components of body j real(kind=DP), intent(inout) :: azj Acceleration vector components of body j Called by proc~~kick_getacch_int_one_pl~~CalledByGraph proc~kick_getacch_int_one_pl kick_getacch_int_one_pl interface~kick_getacch_int_one_pl kick_getacch_int_one_pl interface~kick_getacch_int_one_pl->proc~kick_getacch_int_one_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/kick_getacch_int_one_pl.html"},{"title":"kick_getacch_int_one_tp – swiftest","text":"pure module subroutine kick_getacch_int_one_tp(rji2, xr, yr, zr, Gmpl, ax, ay, az) Interface → Compute direct cross (third) term heliocentric accelerations of a single test particle massive body pair. Adapted from Hal Levison's Swift routine getacch_ah3_tp.f\n Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_ah3.f90 and helio_kick_getacch_int_tp.f90 Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: rji2 Square of distance between the test particle and massive body real(kind=DP), intent(in) :: xr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: yr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: zr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: Gmpl G*mass of massive body real(kind=DP), intent(inout) :: ax Acceleration vector components of test particle real(kind=DP), intent(inout) :: ay Acceleration vector components of test particle real(kind=DP), intent(inout) :: az Acceleration vector components of test particle Called by proc~~kick_getacch_int_one_tp~~CalledByGraph proc~kick_getacch_int_one_tp kick_getacch_int_one_tp interface~kick_getacch_int_one_tp kick_getacch_int_one_tp interface~kick_getacch_int_one_tp->proc~kick_getacch_int_one_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/kick_getacch_int_one_tp.html"},{"title":"tides_kick_getacch_pl – swiftest","text":"module subroutine tides_kick_getacch_pl(self, system) Interface → Calculated tidal torques from central body to any planet and from any planet to central body\n planet - planet interactions are considered negligable.\n This is a constant time lag model. Adapted from Mercury-T code from Bolmont et al. (2015) Reference:\n    Bolmont, E., Raymond, S.N., Leconte, J., Hersant, F., Correia, A.C.M., 2015. \n       Mercury-T : A new code to study tidally evolving multi-planet systems. \n       Applications to Kepler-62. A&A 583, A116. https://doi.org/10.1051/0004-6361/201525909 Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object Called by proc~~tides_kick_getacch_pl~~CalledByGraph proc~tides_kick_getacch_pl tides_kick_getacch_pl interface~tides_kick_getacch_pl tides_kick_getacch_pl interface~tides_kick_getacch_pl->proc~tides_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/tides_kick_getacch_pl.html"},{"title":"tides_step_spin_system – swiftest","text":"module subroutine tides_step_spin_system(self, param, t, dt) Interface → Integrates the spin equations for central and massive bodies of the system subjected to tides. Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize Called by proc~~tides_step_spin_system~~CalledByGraph proc~tides_step_spin_system tides_step_spin_system interface~tides_step_spin_system tides_step_spin_system interface~tides_step_spin_system->proc~tides_step_spin_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/tides_step_spin_system.html"},{"title":"obl_acc_body – swiftest","text":"module subroutine obl_acc_body(self, system) Interface → Compute the barycentric accelerations of bodies due to the oblateness of the central body\n      Returned values do not include monopole term or terms higher than J4 Adapted from David E. Kaufmann's Swifter routine: obl_acc.f90 and obl_acc_tp.f90\n Adapted from Hal Levison's Swift routine obl_acc.f and obl_acc_tp.f Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object Called by proc~~obl_acc_body~~CalledByGraph proc~obl_acc_body obl_acc_body interface~obl_acc_body obl_acc_body interface~obl_acc_body->proc~obl_acc_body proc~obl_acc_pl obl_acc_pl proc~obl_acc_pl->interface~obl_acc_body proc~obl_acc_tp obl_acc_tp proc~obl_acc_tp->interface~obl_acc_body interface~obl_acc_tp obl_acc_tp interface~obl_acc_tp->proc~obl_acc_tp interface~obl_acc_pl obl_acc_pl interface~obl_acc_pl->proc~obl_acc_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/obl_acc_body.html"},{"title":"obl_acc_pl – swiftest","text":"module subroutine obl_acc_pl(self, system) Interface → Compute the barycentric accelerations of massive bodies due to the oblateness of the central body Adapted from David E. Kaufmann's Swifter routine: obl_acc.f90 and obl_acc_tp.f90\n Adapted from Hal Levison's Swift routine obl_acc.f and obl_acc_tp.f Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object Calls proc~~obl_acc_pl~~CallsGraph proc~obl_acc_pl obl_acc_pl interface~obl_acc_body obl_acc_body proc~obl_acc_pl->interface~obl_acc_body proc~obl_acc_body obl_acc_body interface~obl_acc_body->proc~obl_acc_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~obl_acc_pl~~CalledByGraph proc~obl_acc_pl obl_acc_pl interface~obl_acc_pl obl_acc_pl interface~obl_acc_pl->proc~obl_acc_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/obl_acc_pl.html"},{"title":"obl_acc_tp – swiftest","text":"module subroutine obl_acc_tp(self, system) Interface → Compute the barycentric accelerations of massive bodies due to the oblateness of the central body Adapted from David E. Kaufmann's Swifter routine: obl_acc.f90 and obl_acc_tp.f90\n Adapted from Hal Levison's Swift routine obl_acc.f and obl_acc_tp.f Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object Calls proc~~obl_acc_tp~~CallsGraph proc~obl_acc_tp obl_acc_tp interface~obl_acc_body obl_acc_body proc~obl_acc_tp->interface~obl_acc_body proc~obl_acc_body obl_acc_body interface~obl_acc_body->proc~obl_acc_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~obl_acc_tp~~CalledByGraph proc~obl_acc_tp obl_acc_tp interface~obl_acc_tp obl_acc_tp interface~obl_acc_tp->proc~obl_acc_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/obl_acc_tp.html"},{"title":"obl_pot_system – swiftest","text":"module subroutine obl_pot_system(self) Interface → Compute the contribution to the total gravitational potential due solely to the oblateness of the central body\n    Returned value does not include monopole term or terms higher than J4 Reference : MacMillan , W . D . 1958 . The Theory of the Potential , ( Dover Publications ), 363 . Adapted from David E. Kaufmann's Swifter routine: obl_pot.f90 \n Adapted from Hal Levison's Swift routine obl_pot.f Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object Calls proc~~obl_pot_system~~CallsGraph proc~obl_pot_system obl_pot_system proc~obl_pot_one obl_pot_one proc~obl_pot_system->proc~obl_pot_one Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~obl_pot_system~~CalledByGraph proc~obl_pot_system obl_pot_system interface~obl_pot_system obl_pot_system interface~obl_pot_system->proc~obl_pot_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/obl_pot_system.html"},{"title":"orbel_el2xv_vec – swiftest","text":"module subroutine orbel_el2xv_vec(self, cb) Interface → A wrapper method that converts all of the orbital element vectors into cartesian position and velocity vectors for a Swiftest body object.\n This method deallocates all of the orbital elements after it is finished. Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body objec Calls proc~~orbel_el2xv_vec~~CallsGraph proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv_vec->proc~orbel_el2xv proc~orbel_zget orbel_zget proc~orbel_el2xv->proc~orbel_zget proc~orbel_fhybrid orbel_fhybrid proc~orbel_el2xv->proc~orbel_fhybrid proc~orbel_schget orbel_schget proc~orbel_el2xv->proc~orbel_schget proc~orbel_ehybrid orbel_ehybrid proc~orbel_el2xv->proc~orbel_ehybrid interface~orbel_scget orbel_scget proc~orbel_el2xv->interface~orbel_scget proc~orbel_flon orbel_flon proc~orbel_fhybrid->proc~orbel_flon proc~orbel_fget orbel_fget proc~orbel_fhybrid->proc~orbel_fget proc~orbel_eget orbel_eget proc~orbel_ehybrid->proc~orbel_eget proc~orbel_esolmd orbel_esolmd proc~orbel_ehybrid->proc~orbel_esolmd proc~orbel_ehie orbel_ehie proc~orbel_ehybrid->proc~orbel_ehie proc~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget 3 3 proc~orbel_flon->3 proc~orbel_eget->interface~orbel_scget proc~orbel_esolmd->interface~orbel_scget proc~orbel_fget->proc~orbel_schget proc~orbel_ehie->interface~orbel_scget Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~orbel_el2xv_vec~~CalledByGraph proc~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_el2xv_vec.html"},{"title":"orbel_scget – swiftest","text":"pure module subroutine orbel_scget(angle, sx, cx) Interface → Efficiently compute the sine and cosine of an input angle\n      Input angle must be in radians Adapted from David E. Kaufmann's Swifter routine: orbel_scget.f90\n Adapted from Hal Levison's Swift routine orbel_scget.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: angle real(kind=DP), intent(out) :: sx real(kind=DP), intent(out) :: cx Called by proc~~orbel_scget~~CalledByGraph proc~orbel_scget orbel_scget interface~orbel_scget orbel_scget interface~orbel_scget->proc~orbel_scget proc~drift_kepu_guess drift_kepu_guess proc~drift_kepu_guess->interface~orbel_scget proc~orbel_eget orbel_eget proc~orbel_eget->interface~orbel_scget proc~orbel_esolmd orbel_esolmd proc~orbel_esolmd->interface~orbel_scget proc~orbel_el2xv orbel_el2xv proc~orbel_el2xv->interface~orbel_scget proc~orbel_ehybrid orbel_ehybrid proc~orbel_el2xv->proc~orbel_ehybrid proc~orbel_ehie orbel_ehie proc~orbel_ehie->interface~orbel_scget proc~drift_kepu drift_kepu proc~drift_kepu->proc~drift_kepu_guess proc~orbel_ehybrid->proc~orbel_eget proc~orbel_ehybrid->proc~orbel_esolmd proc~orbel_ehybrid->proc~orbel_ehie proc~orbel_el2xv_vec orbel_el2xv_vec proc~orbel_el2xv_vec->proc~orbel_el2xv interface~orbel_el2xv_vec orbel_el2xv_vec interface~orbel_el2xv_vec->proc~orbel_el2xv_vec proc~drift_dan drift_dan proc~drift_dan->proc~drift_kepu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_scget.html"},{"title":"orbel_xv2aeq – swiftest","text":"pure module subroutine orbel_xv2aeq(mu, x, v, a, e, q) Interface → Compute semimajor axis, eccentricity, and pericentric distance from relative Cartesian position and velocity Adapted from David E. Kaufmann's Swifter routine: orbel_xv2aeq.f90\n Adapted from Luke Dones' Swift routine orbel_xv2aeq.f\n Arguments Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in), dimension(:) :: v real(kind=DP), intent(out) :: a real(kind=DP), intent(out) :: e real(kind=DP), intent(out) :: q Called by proc~~orbel_xv2aeq~~CalledByGraph proc~orbel_xv2aeq orbel_xv2aeq interface~orbel_xv2aeq orbel_xv2aeq interface~orbel_xv2aeq->proc~orbel_xv2aeq proc~util_peri_tp util_peri_tp proc~util_peri_tp->interface~orbel_xv2aeq interface~util_peri_tp util_peri_tp interface~util_peri_tp->proc~util_peri_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_xv2aeq.html"},{"title":"orbel_xv2aqt – swiftest","text":"pure module subroutine orbel_xv2aqt(mu, x, v, a, q, capm, tperi) Interface → Compute semimajor axis, pericentric distance, mean anomaly, and time to nearest pericenter passage from\n relative Cartesian position and velocity\n      tperi > 0 means nearest pericenter passage is in the future\n      tperi < 0 means nearest pericenter passage is in the past Adapted from David E. Kaufmann's Swifter routine: orbel_xv2aqt.f90 Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(out) :: a semimajor axis real(kind=DP), intent(out) :: q periapsis real(kind=DP), intent(out) :: capm mean anomaly real(kind=DP), intent(out) :: tperi time of pericenter passage Called by proc~~orbel_xv2aqt~~CalledByGraph proc~orbel_xv2aqt orbel_xv2aqt interface~orbel_xv2aqt orbel_xv2aqt interface~orbel_xv2aqt->proc~orbel_xv2aqt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_xv2aqt.html"},{"title":"orbel_xv2el_vec – swiftest","text":"module subroutine orbel_xv2el_vec(self, cb) Interface → A wrapper method that converts all of the cartesian position and velocity vectors of a Swiftest body object to orbital elements. Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object Calls proc~~orbel_xv2el_vec~~CallsGraph proc~orbel_xv2el_vec orbel_xv2el_vec interface~orbel_xv2el orbel_xv2el proc~orbel_xv2el_vec->interface~orbel_xv2el proc~orbel_xv2el orbel_xv2el interface~orbel_xv2el->proc~orbel_xv2el Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~orbel_xv2el_vec~~CalledByGraph proc~orbel_xv2el_vec orbel_xv2el_vec interface~orbel_xv2el_vec orbel_xv2el_vec interface~orbel_xv2el_vec->proc~orbel_xv2el_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_xv2el_vec.html"},{"title":"orbel_xv2el – swiftest","text":"pure module subroutine orbel_xv2el(mu, x, v, a, e, inc, capom, omega, capm) Interface → Compute osculating orbital elements from relative Cartesian position and velocity\n  All angular measures are returned in radians\n      If inclination < TINY, longitude of the ascending node is arbitrarily set to 0 If eccentricity < sqrt ( TINY ), argument of pericenter is arbitrarily set to 0 References : Danby , J . M . A . 1988 . Fundamentals of Celestial Mechanics , ( Willmann - Bell , Inc .), 201 - 206 . Fitzpatrick , P . M . 1970 . Principles of Celestial Mechanics , ( Academic Press ), 69 - 73 . Roy , A . E . 1982 . Orbital Motion , ( Adam Hilger , Ltd .), 75 - 95 Adapted from David E. Kaufmann's Swifter routine: orbel_xv2el.f90\n Adapted from Martin Duncan's Swift routine orbel_xv2el.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(out) :: a semimajor axis real(kind=DP), intent(out) :: e eccentricity real(kind=DP), intent(out) :: inc inclination real(kind=DP), intent(out) :: capom longitude of ascending node real(kind=DP), intent(out) :: omega argument of periapsis real(kind=DP), intent(out) :: capm mean anomaly Called by proc~~orbel_xv2el~~CalledByGraph proc~orbel_xv2el orbel_xv2el interface~orbel_xv2el orbel_xv2el interface~orbel_xv2el->proc~orbel_xv2el proc~orbel_xv2el_vec orbel_xv2el_vec proc~orbel_xv2el_vec->interface~orbel_xv2el interface~orbel_xv2el_vec orbel_xv2el_vec interface~orbel_xv2el_vec->proc~orbel_xv2el_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/orbel_xv2el.html"},{"title":"whm_coord_h2j_pl – swiftest","text":"module subroutine whm_coord_h2j_pl(self, cb) Interface → Convert from heliocentric to Jacobi coordinates, massive bodies only Uses pre-computed eta rather than computing it each time Adapted from David E. Kaufmann's Swifter routine coord_h2j.f90 Adapted from Hal Levison's Swift routine coord_h2j.f Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree Calls proc~~whm_coord_h2j_pl~~CallsGraph proc~whm_coord_h2j_pl whm_coord_h2j_pl vh vh proc~whm_coord_h2j_pl->vh xj xj proc~whm_coord_h2j_pl->xj eta eta proc~whm_coord_h2j_pl->eta xh xh proc~whm_coord_h2j_pl->xh vj vj proc~whm_coord_h2j_pl->vj gmpl gmpl proc~whm_coord_h2j_pl->gmpl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_coord_h2j_pl~~CalledByGraph proc~whm_coord_h2j_pl whm_coord_h2j_pl interface~whm_coord_h2j_pl whm_coord_h2j_pl interface~whm_coord_h2j_pl->proc~whm_coord_h2j_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_coord_h2j_pl.html"},{"title":"whm_coord_j2h_pl – swiftest","text":"module subroutine whm_coord_j2h_pl(self, cb) Interface → Convert from Jacobi to heliocentric coordinates, massive bodies only. Uses pre-computed eta rather than computing it each time Adapted from David E. Kaufmann's Swifter routine coord_j2h.f90 Adapted from Hal Levison's Swift routine coord_j2h.f Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree Calls proc~~whm_coord_j2h_pl~~CallsGraph proc~whm_coord_j2h_pl whm_coord_j2h_pl vh vh proc~whm_coord_j2h_pl->vh xj xj proc~whm_coord_j2h_pl->xj eta eta proc~whm_coord_j2h_pl->eta xh xh proc~whm_coord_j2h_pl->xh vj vj proc~whm_coord_j2h_pl->vj gmpl gmpl proc~whm_coord_j2h_pl->gmpl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_coord_j2h_pl~~CalledByGraph proc~whm_coord_j2h_pl whm_coord_j2h_pl interface~whm_coord_j2h_pl whm_coord_j2h_pl interface~whm_coord_j2h_pl->proc~whm_coord_j2h_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_coord_j2h_pl.html"},{"title":"whm_coord_vh2vj_pl – swiftest","text":"module subroutine whm_coord_vh2vj_pl(self, cb) Interface → Convert from heliocentric to Jadcobi coordinates, massive body velocities only Uses pre-computed eta rather than computing it each time Adapted from David E. Kaufmann's Swifter routine coord_vh2vj.f90 Adapted from Hal Levison's Swift routine coord_vh2vj.f Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree Calls proc~~whm_coord_vh2vj_pl~~CallsGraph proc~whm_coord_vh2vj_pl whm_coord_vh2vj_pl vj vj proc~whm_coord_vh2vj_pl->vj vh vh proc~whm_coord_vh2vj_pl->vh gmpl gmpl proc~whm_coord_vh2vj_pl->gmpl eta eta proc~whm_coord_vh2vj_pl->eta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_coord_vh2vj_pl~~CalledByGraph proc~whm_coord_vh2vj_pl whm_coord_vh2vj_pl interface~whm_coord_vh2vj_pl whm_coord_vh2vj_pl interface~whm_coord_vh2vj_pl->proc~whm_coord_vh2vj_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_coord_vh2vj_pl.html"},{"title":"whm_gr_kick_getacch_pl – swiftest","text":"pure module subroutine whm_gr_kick_getacch_pl(self, param) Interface → Compute relativisitic accelerations of massive bodies\n    Based on Saha & Tremaine (1994) Eq. 28 Adapted from David A. Minton's Swifter routine routine gr_whm_kick_getacch.f90 Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters Calls proc~~whm_gr_kick_getacch_pl~~CallsGraph proc~whm_gr_kick_getacch_pl whm_gr_kick_getacch_pl gr_kick_getacch gr_kick_getacch proc~whm_gr_kick_getacch_pl->gr_kick_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_gr_kick_getacch_pl~~CalledByGraph proc~whm_gr_kick_getacch_pl whm_gr_kick_getacch_pl interface~whm_gr_kick_getacch_pl whm_gr_kick_getacch_pl interface~whm_gr_kick_getacch_pl->proc~whm_gr_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_gr_kick_getacch_pl.html"},{"title":"whm_gr_kick_getacch_tp – swiftest","text":"pure module subroutine whm_gr_kick_getacch_tp(self, param) Interface → Compute relativisitic accelerations of test particles\n    Based on Saha & Tremaine (1994) Eq. 28 Adapted from David A. Minton's Swifter routine routine gr_whm_kick_getacch.f90 Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters Calls proc~~whm_gr_kick_getacch_tp~~CallsGraph proc~whm_gr_kick_getacch_tp whm_gr_kick_getacch_tp gr_kick_getacch gr_kick_getacch proc~whm_gr_kick_getacch_tp->gr_kick_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_gr_kick_getacch_tp~~CalledByGraph proc~whm_gr_kick_getacch_tp whm_gr_kick_getacch_tp interface~whm_gr_kick_getacch_tp whm_gr_kick_getacch_tp interface~whm_gr_kick_getacch_tp->proc~whm_gr_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_gr_kick_getacch_tp.html"},{"title":"whm_gr_p4_pl – swiftest","text":"pure module subroutine whm_gr_p4_pl(self, param, dt) Interface → Position kick to massive bodies due to p**4 term in the post-Newtonian correction\n    Based on Saha & Tremaine (1994) Eq. 28 Adapted from David A. Minton's Swifter routine routine gr_whm_p4.f90 Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size Calls proc~~whm_gr_p4_pl~~CallsGraph proc~whm_gr_p4_pl whm_gr_p4_pl gr_p4_pos_kick gr_p4_pos_kick proc~whm_gr_p4_pl->gr_p4_pos_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_gr_p4_pl~~CalledByGraph proc~whm_gr_p4_pl whm_gr_p4_pl interface~whm_gr_p4_pl whm_gr_p4_pl interface~whm_gr_p4_pl->proc~whm_gr_p4_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_gr_p4_pl.html"},{"title":"whm_gr_p4_tp – swiftest","text":"pure module subroutine whm_gr_p4_tp(self, param, dt) Interface → Position kick to test particles due to p**4 term in the post-Newtonian correction\n    Based on Saha & Tremaine (1994) Eq. 28 Adapted from David A. Minton's Swifter routine routine gr_whm_p4.f90 Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size Calls proc~~whm_gr_p4_tp~~CallsGraph proc~whm_gr_p4_tp whm_gr_p4_tp gr_p4_pos_kick gr_p4_pos_kick proc~whm_gr_p4_tp->gr_p4_pos_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_gr_p4_tp~~CalledByGraph proc~whm_gr_p4_tp whm_gr_p4_tp interface~whm_gr_p4_tp whm_gr_p4_tp interface~whm_gr_p4_tp->proc~whm_gr_p4_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_gr_p4_tp.html"},{"title":"whm_step_system – swiftest","text":"module subroutine whm_step_system(self, param, t, dt) Interface → Step massive bodies and and active test particles ahead in heliocentric coordinates Adapted from Hal Levison's Swift routine step_kdk.f\n Adapted from David E. Kaufmann's Swifter routine whm_step.f90 Arguments Type Intent Optional Attributes Name class( whm_nbody_system ), intent(inout) :: self WHM nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current stepsize Called by proc~~whm_step_system~~CalledByGraph proc~whm_step_system whm_step_system interface~whm_step_system whm_step_system interface~whm_step_system->proc~whm_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_step_system.html"},{"title":"whm_step_pl – swiftest","text":"module subroutine whm_step_pl(self, system, param, t, dt) Interface → Step planets ahead using kick-drift-kick algorithm Adapted from Hal Levison's Swift routine step_kdk_pl.f\n Adapted from David E. Kaufmann's Swifter routine whm_step_pl.f90 Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current stepsize Called by proc~~whm_step_pl~~CalledByGraph proc~whm_step_pl whm_step_pl interface~whm_step_pl whm_step_pl interface~whm_step_pl->proc~whm_step_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_step_pl.html"},{"title":"whm_step_tp – swiftest","text":"module subroutine whm_step_tp(self, system, param, t, dt) Interface → Step active test particles ahead using kick-drift-kick algorithm Adapted from Hal Levison's Swift routine step_kdk_tp.f\n Adapted from David E. Kaufmann's Swifter routine whm_step_tp.f90 Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current stepsize Called by proc~~whm_step_tp~~CalledByGraph proc~whm_step_tp whm_step_tp interface~whm_step_tp whm_step_tp interface~whm_step_tp->proc~whm_step_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_step_tp.html"},{"title":"whm_drift_pl – swiftest","text":"module subroutine whm_drift_pl(self, system, param, dt) Interface → Loop through planets and call Danby drift routine Adapted from Hal Levison's Swift routine drift.f\n Adapted from David E. Kaufmann's Swifter routine whm_drift.f90 Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize Calls proc~~whm_drift_pl~~CallsGraph proc~whm_drift_pl whm_drift_pl util_exit util_exit proc~whm_drift_pl->util_exit drift_all drift_all proc~whm_drift_pl->drift_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_drift_pl~~CalledByGraph proc~whm_drift_pl whm_drift_pl interface~whm_drift_pl whm_drift_pl interface~whm_drift_pl->proc~whm_drift_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_drift_pl.html"},{"title":"whm_kick_getacch_pl – swiftest","text":"module subroutine whm_kick_getacch_pl(self, system, param, t, lbeg) Interface → Compute heliocentric accelerations of planets Adapted from Hal Levison's Swift routine getacch.f\n Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch.f90 Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest central body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step Calls proc~~whm_kick_getacch_pl~~CallsGraph proc~whm_kick_getacch_pl whm_kick_getacch_pl proc~whm_kick_getacch_ah0 whm_kick_getacch_ah0 proc~whm_kick_getacch_pl->proc~whm_kick_getacch_ah0 proc~whm_kick_getacch_ah1 whm_kick_getacch_ah1 proc~whm_kick_getacch_pl->proc~whm_kick_getacch_ah1 proc~whm_kick_getacch_ah2 whm_kick_getacch_ah2 proc~whm_kick_getacch_pl->proc~whm_kick_getacch_ah2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_kick_getacch_pl~~CalledByGraph proc~whm_kick_getacch_pl whm_kick_getacch_pl interface~whm_kick_getacch_pl whm_kick_getacch_pl interface~whm_kick_getacch_pl->proc~whm_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_kick_getacch_pl.html"},{"title":"whm_kick_getacch_tp – swiftest","text":"module subroutine whm_kick_getacch_tp(self, system, param, t, lbeg) Interface → Compute heliocentric accelerations of test particles Adapted from Hal Levison's Swift routine getacch_tp.f\n Adapted from David E. Kaufmann's Swifter routine whm_kick_getacch_tp.f90 Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest central body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step Calls proc~~whm_kick_getacch_tp~~CallsGraph proc~whm_kick_getacch_tp whm_kick_getacch_tp proc~whm_kick_getacch_ah0 whm_kick_getacch_ah0 proc~whm_kick_getacch_tp->proc~whm_kick_getacch_ah0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_kick_getacch_tp~~CalledByGraph proc~whm_kick_getacch_tp whm_kick_getacch_tp interface~whm_kick_getacch_tp whm_kick_getacch_tp interface~whm_kick_getacch_tp->proc~whm_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_kick_getacch_tp.html"},{"title":"whm_kick_vh_pl – swiftest","text":"module subroutine whm_kick_vh_pl(self, system, param, t, dt, lbeg) Interface → Kick heliocentric velocities of massive bodies Adapted from Martin Duncan and Hal Levison's Swift routine kickvh.f \n Adapted from David E. Kaufmann's Swifter routine whm_kickvh.f90 Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. Called by proc~~whm_kick_vh_pl~~CalledByGraph proc~whm_kick_vh_pl whm_kick_vh_pl interface~whm_kick_vh_pl whm_kick_vh_pl interface~whm_kick_vh_pl->proc~whm_kick_vh_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_kick_vh_pl.html"},{"title":"whm_kick_vh_tp – swiftest","text":"module subroutine whm_kick_vh_tp(self, system, param, t, dt, lbeg) Interface → Kick heliocentric velocities of test particles Adapted from Martin Duncan and Hal Levison's Swift routine kickvh_tp.f\n Adapted from David E. Kaufmann's Swifter routine whm_kickvh_tp.f90 Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. Called by proc~~whm_kick_vh_tp~~CalledByGraph proc~whm_kick_vh_tp whm_kick_vh_tp interface~whm_kick_vh_tp whm_kick_vh_tp interface~whm_kick_vh_tp->proc~whm_kick_vh_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_kick_vh_tp.html"},{"title":"whm_setup_pl – swiftest","text":"module subroutine whm_setup_pl(self, n, param) Interface → Allocate WHM planet structure Equivalent in functionality to David E. Kaufmann's Swifter routine whm_setup.f90\n Call allocation method for parent class Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameter Calls proc~~whm_setup_pl~~CallsGraph proc~whm_setup_pl whm_setup_pl setup_pl setup_pl proc~whm_setup_pl->setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_setup_pl~~CalledByGraph proc~whm_setup_pl whm_setup_pl interface~whm_setup_pl whm_setup_pl interface~whm_setup_pl->proc~whm_setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_setup_pl.html"},{"title":"whm_util_set_mu_eta_pl – swiftest","text":"module subroutine whm_util_set_mu_eta_pl(self, cb) Interface → Sets the Jacobi mass value eta for all massive bodies Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM system object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object Calls proc~~whm_util_set_mu_eta_pl~~CallsGraph proc~whm_util_set_mu_eta_pl whm_util_set_mu_eta_pl util_set_mu_pl util_set_mu_pl proc~whm_util_set_mu_eta_pl->util_set_mu_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_util_set_mu_eta_pl~~CalledByGraph proc~whm_util_set_mu_eta_pl whm_util_set_mu_eta_pl interface~whm_util_set_mu_eta_pl whm_util_set_mu_eta_pl interface~whm_util_set_mu_eta_pl->proc~whm_util_set_mu_eta_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_util_set_mu_eta_pl.html"},{"title":"whm_setup_initialize_system – swiftest","text":"module subroutine whm_setup_initialize_system(self, param) Interface → Initialize a WHM nbody system from files Arguments Type Intent Optional Attributes Name class( whm_nbody_system ), intent(inout) :: self WHM nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters Calls proc~~whm_setup_initialize_system~~CallsGraph proc~whm_setup_initialize_system whm_setup_initialize_system util_set_ir3h util_set_ir3h proc~whm_setup_initialize_system->util_set_ir3h setup_initialize_system setup_initialize_system proc~whm_setup_initialize_system->setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_setup_initialize_system~~CalledByGraph proc~whm_setup_initialize_system whm_setup_initialize_system interface~whm_setup_initialize_system whm_setup_initialize_system interface~whm_setup_initialize_system->proc~whm_setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_setup_initialize_system.html"},{"title":"whm_util_append_pl – swiftest","text":"module subroutine whm_util_append_pl(self, source, lsource_mask) Interface → Append components from one massive body object to another. \n This method will automatically resize the destination body if it is too small\n Arguments Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~whm_util_append_pl~~CallsGraph proc~whm_util_append_pl whm_util_append_pl util_exit util_exit proc~whm_util_append_pl->util_exit util_append_pl util_append_pl proc~whm_util_append_pl->util_append_pl util_append util_append proc~whm_util_append_pl->util_append Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_util_append_pl~~CalledByGraph proc~whm_util_append_pl whm_util_append_pl interface~whm_util_append_pl whm_util_append_pl interface~whm_util_append_pl->proc~whm_util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_util_append_pl.html"},{"title":"whm_util_fill_pl – swiftest","text":"module subroutine whm_util_fill_pl(self, inserts, lfill_list) Interface → Insert new WHM test particle structure into an old one. \n This is the inverse of a fill operation. Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(in) :: inserts inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Calls proc~~whm_util_fill_pl~~CallsGraph proc~whm_util_fill_pl whm_util_fill_pl util_exit util_exit proc~whm_util_fill_pl->util_exit util_fill util_fill proc~whm_util_fill_pl->util_fill util_fill_pl util_fill_pl proc~whm_util_fill_pl->util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_util_fill_pl~~CalledByGraph proc~whm_util_fill_pl whm_util_fill_pl interface~whm_util_fill_pl whm_util_fill_pl interface~whm_util_fill_pl->proc~whm_util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_util_fill_pl.html"},{"title":"whm_util_resize_pl – swiftest","text":"module subroutine whm_util_resize_pl(self, nnew) Interface → Checks the current size of a massive body against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object integer(kind=I4B), intent(in) :: nnew New size neded Calls proc~~whm_util_resize_pl~~CallsGraph proc~whm_util_resize_pl whm_util_resize_pl util_resize_pl util_resize_pl proc~whm_util_resize_pl->util_resize_pl util_resize util_resize proc~whm_util_resize_pl->util_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_util_resize_pl~~CalledByGraph proc~whm_util_resize_pl whm_util_resize_pl interface~whm_util_resize_pl whm_util_resize_pl interface~whm_util_resize_pl->proc~whm_util_resize_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_util_resize_pl.html"},{"title":"whm_util_set_ir3j – swiftest","text":"module subroutine whm_util_set_ir3j(self) Interface → Sets the inverse Jacobi and heliocentric radii cubed (1/rj 3 and 1/rh 3) Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object Called by proc~~whm_util_set_ir3j~~CalledByGraph proc~whm_util_set_ir3j whm_util_set_ir3j interface~whm_util_set_ir3j whm_util_set_ir3j interface~whm_util_set_ir3j->proc~whm_util_set_ir3j Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_util_set_ir3j.html"},{"title":"whm_util_sort_pl – swiftest","text":"module subroutine whm_util_sort_pl(self, sortby, ascending) Interface → Sort a WHM massive body object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order Calls proc~~whm_util_sort_pl~~CallsGraph proc~whm_util_sort_pl whm_util_sort_pl util_sort_pl util_sort_pl proc~whm_util_sort_pl->util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_util_sort_pl~~CalledByGraph proc~whm_util_sort_pl whm_util_sort_pl interface~whm_util_sort_pl whm_util_sort_pl interface~whm_util_sort_pl->proc~whm_util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_util_sort_pl.html"},{"title":"whm_util_sort_rearrange_pl – swiftest","text":"module subroutine whm_util_sort_rearrange_pl(self, ind) Interface → Rearrange WHM massive body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) Calls proc~~whm_util_sort_rearrange_pl~~CallsGraph proc~whm_util_sort_rearrange_pl whm_util_sort_rearrange_pl util_sort_rearrange_pl util_sort_rearrange_pl proc~whm_util_sort_rearrange_pl->util_sort_rearrange_pl util_sort_rearrange util_sort_rearrange proc~whm_util_sort_rearrange_pl->util_sort_rearrange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_util_sort_rearrange_pl~~CalledByGraph proc~whm_util_sort_rearrange_pl whm_util_sort_rearrange_pl interface~whm_util_sort_rearrange_pl whm_util_sort_rearrange_pl interface~whm_util_sort_rearrange_pl->proc~whm_util_sort_rearrange_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_util_sort_rearrange_pl.html"},{"title":"whm_util_spill_pl – swiftest","text":"module subroutine whm_util_spill_pl(self, discards, lspill_list, ldestructive) Interface → Move spilled (discarded) WHM test particle structure from active list to discard list Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not Calls proc~~whm_util_spill_pl~~CallsGraph proc~whm_util_spill_pl whm_util_spill_pl util_exit util_exit proc~whm_util_spill_pl->util_exit util_spill util_spill proc~whm_util_spill_pl->util_spill util_spill_pl util_spill_pl proc~whm_util_spill_pl->util_spill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~whm_util_spill_pl~~CalledByGraph proc~whm_util_spill_pl whm_util_spill_pl interface~whm_util_spill_pl whm_util_spill_pl interface~whm_util_spill_pl->proc~whm_util_spill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/whm_util_spill_pl.html"},{"title":"operator_cross_sp – swiftest","text":"pure function operator_cross_sp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: A real(kind=SP), intent(in), dimension(:) :: B Return Value real(kind=SP),\n  dimension(3) Contents None","tags":"","loc":"proc/operator_cross_sp.html"},{"title":"operator_cross_dp – swiftest","text":"pure function operator_cross_dp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: A real(kind=DP), intent(in), dimension(:) :: B Return Value real(kind=DP),\n  dimension(3) Contents None","tags":"","loc":"proc/operator_cross_dp.html"},{"title":"operator_cross_qp – swiftest","text":"pure function operator_cross_qp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:) :: A real(kind=QP), intent(in), dimension(:) :: B Return Value real(kind=QP),\n  dimension(3) Contents None","tags":"","loc":"proc/operator_cross_qp.html"},{"title":"operator_cross_i1b – swiftest","text":"pure function operator_cross_i1b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in), dimension(:) :: A integer(kind=I1B), intent(in), dimension(:) :: B Return Value integer(kind=I1B),\n  dimension(3) Contents None","tags":"","loc":"proc/operator_cross_i1b.html"},{"title":"operator_cross_i2b – swiftest","text":"pure function operator_cross_i2b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in), dimension(:) :: A integer(kind=I2B), intent(in), dimension(:) :: B Return Value integer(kind=I2B),\n  dimension(3) Contents None","tags":"","loc":"proc/operator_cross_i2b.html"},{"title":"operator_cross_i4b – swiftest","text":"pure function operator_cross_i4b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:) :: A integer(kind=I4B), intent(in), dimension(:) :: B Return Value integer(kind=I4B),\n  dimension(3) Contents None","tags":"","loc":"proc/operator_cross_i4b.html"},{"title":"operator_cross_i8b – swiftest","text":"pure function operator_cross_i8b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in), dimension(:) :: A integer(kind=I8B), intent(in), dimension(:) :: B Return Value integer(kind=I8B),\n  dimension(3) Contents None","tags":"","loc":"proc/operator_cross_i8b.html"},{"title":"operator_cross_el_sp – swiftest","text":"pure function operator_cross_el_sp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:,:) :: A real(kind=SP), intent(in), dimension(:,:) :: B Return Value real(kind=SP),\n  dimension(:,:),allocatable Contents None","tags":"","loc":"proc/operator_cross_el_sp.html"},{"title":"operator_cross_el_dp – swiftest","text":"pure function operator_cross_el_dp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A real(kind=DP), intent(in), dimension(:,:) :: B Return Value real(kind=DP),\n  dimension(:,:),allocatable Contents None","tags":"","loc":"proc/operator_cross_el_dp.html"},{"title":"operator_cross_el_qp – swiftest","text":"pure function operator_cross_el_qp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A real(kind=QP), intent(in), dimension(:,:) :: B Return Value real(kind=QP),\n  dimension(:,:),allocatable Contents None","tags":"","loc":"proc/operator_cross_el_qp.html"},{"title":"operator_cross_el_i1b – swiftest","text":"pure function operator_cross_el_i1b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in), dimension(:,:) :: A integer(kind=I1B), intent(in), dimension(:,:) :: B Return Value integer(kind=I1B),\n  dimension(:,:),allocatable Contents None","tags":"","loc":"proc/operator_cross_el_i1b.html"},{"title":"operator_cross_el_i2b – swiftest","text":"pure function operator_cross_el_i2b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in), dimension(:,:) :: A integer(kind=I2B), intent(in), dimension(:,:) :: B Return Value integer(kind=I2B),\n  dimension(:,:),allocatable Contents None","tags":"","loc":"proc/operator_cross_el_i2b.html"},{"title":"operator_cross_el_i4b – swiftest","text":"pure function operator_cross_el_i4b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:,:) :: A integer(kind=I4B), intent(in), dimension(:,:) :: B Return Value integer(kind=I4B),\n  dimension(:,:),allocatable Contents None","tags":"","loc":"proc/operator_cross_el_i4b.html"},{"title":"operator_cross_el_i8b – swiftest","text":"pure function operator_cross_el_i8b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in), dimension(:,:) :: A integer(kind=I8B), intent(in), dimension(:,:) :: B Return Value integer(kind=I8B),\n  dimension(:,:),allocatable Contents None","tags":"","loc":"proc/operator_cross_el_i8b.html"},{"title":"operator_mag_sp – swiftest","text":"pure function operator_mag_sp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: A Return Value real(kind=SP) Contents None","tags":"","loc":"proc/operator_mag_sp.html"},{"title":"operator_mag_dp – swiftest","text":"pure function operator_mag_dp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: A Return Value real(kind=DP) Contents None","tags":"","loc":"proc/operator_mag_dp.html"},{"title":"operator_mag_el_sp – swiftest","text":"pure function operator_mag_el_sp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:,:) :: A Return Value real(kind=SP),\n  dimension(:),allocatable Contents None","tags":"","loc":"proc/operator_mag_el_sp.html"},{"title":"operator_mag_el_dp – swiftest","text":"pure function operator_mag_el_dp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A Return Value real(kind=DP),\n  dimension(:),allocatable Contents None","tags":"","loc":"proc/operator_mag_el_dp.html"},{"title":"operator_mag_el_qp – swiftest","text":"pure function operator_mag_el_qp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A Return Value real(kind=QP),\n  dimension(:),allocatable Contents None","tags":"","loc":"proc/operator_mag_el_qp.html"},{"title":"util_solve_linear_system_d – swiftest","text":"function util_solve_linear_system_d(A, b, n, lerr) result(x) Uses ieee_exceptions proc~~util_solve_linear_system_d~~UsesGraph proc~util_solve_linear_system_d util_solve_linear_system_d ieee_exceptions ieee_exceptions proc~util_solve_linear_system_d->ieee_exceptions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Solves the linear equation of the form A*x = b for x. \n   A is an (n,n) arrays\n   x and b are (n) arrays\n Uses Gaussian elimination, so will have issues if system is ill-conditioned.\n Uses quad precision intermidiate values, so works best on small arrays. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A real(kind=DP), intent(in), dimension(:) :: b integer(kind=I4B), intent(in) :: n logical, intent(out) :: lerr Return Value real(kind=DP),\n  dimension(n) Calls proc~~util_solve_linear_system_d~~CallsGraph proc~util_solve_linear_system_d util_solve_linear_system_d proc~ge_wpp ge_wpp proc~util_solve_linear_system_d->proc~ge_wpp proc~solve_wbs solve_wbs proc~util_solve_linear_system_d->proc~solve_wbs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_solve_linear_system_d.html"},{"title":"util_solve_linear_system_q – swiftest","text":"function util_solve_linear_system_q(A, b, n, lerr) result(x) Uses ieee_exceptions proc~~util_solve_linear_system_q~~UsesGraph proc~util_solve_linear_system_q util_solve_linear_system_q ieee_exceptions ieee_exceptions proc~util_solve_linear_system_q->ieee_exceptions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Solves the linear equation of the form A*x = b for x. \n   A is an (n,n) arrays\n   x and b are (n) arrays\n Uses Gaussian elimination, so will have issues if system is ill-conditioned.\n Uses quad precision intermidiate values, so works best on small arrays. Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A real(kind=QP), intent(in), dimension(:) :: b integer(kind=I4B), intent(in) :: n logical, intent(out) :: lerr Return Value real(kind=QP),\n  dimension(n) Calls proc~~util_solve_linear_system_q~~CallsGraph proc~util_solve_linear_system_q util_solve_linear_system_q proc~ge_wpp ge_wpp proc~util_solve_linear_system_q->proc~ge_wpp proc~solve_wbs solve_wbs proc~util_solve_linear_system_q->proc~solve_wbs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_solve_linear_system_q.html"},{"title":"util_solve_rkf45 – swiftest","text":"module function util_solve_rkf45(f, y0in, t1, dt0, tol) result(y1) Interface → Implements the 4th order Runge-Kutta-Fehlberg ODE solver for initial value problems of the form f=dy/dt, y0 = y(t=0), solving for y1 = y(t=t1). Uses a 5th order adaptive step size control.\n Uses a lambda function object as defined in the lambda_function module Arguments Type Intent Optional Attributes Name class(lambda_obj), intent(inout) :: f lambda function object that has been initialized to be a function of derivatives. The object will return with components lastarg and lasteval set real(kind=DP), intent(in), dimension(:) :: y0in Initial value at t=0 real(kind=DP), intent(in) :: t1 Final time real(kind=DP), intent(in) :: dt0 Initial step size guess real(kind=DP), intent(in) :: tol Tolerance on solution Return Value real(kind=DP),\n  dimension(:),allocatable Final result Calls proc~~util_solve_rkf45~~CallsGraph proc~util_solve_rkf45 util_solve_rkf45 interface~util_exit util_exit proc~util_solve_rkf45->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_solve_rkf45~~CalledByGraph proc~util_solve_rkf45 util_solve_rkf45 interface~util_solve_rkf45 util_solve_rkf45 interface~util_solve_rkf45->proc~util_solve_rkf45 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_solve_rkf45.html"},{"title":"util_set_beg_end_pl – swiftest","text":"module subroutine util_set_beg_end_pl(self, xbeg, xend, vbeg) Interface → Sets one or more of the values of xbeg, xend, and vbeg Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object real(kind=DP), intent(in), optional dimension(:,:) :: xbeg real(kind=DP), intent(in), optional dimension(:,:) :: xend real(kind=DP), intent(in), optional dimension(:,:) :: vbeg Called by proc~~util_set_beg_end_pl~~CalledByGraph proc~util_set_beg_end_pl util_set_beg_end_pl interface~util_set_beg_end_pl util_set_beg_end_pl interface~util_set_beg_end_pl->proc~util_set_beg_end_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_set_beg_end_pl.html"},{"title":"util_set_ir3h – swiftest","text":"module subroutine util_set_ir3h(self) Interface → Sets the inverse heliocentric radius term (1/rh**3) for all bodies in a structure Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object Called by proc~~util_set_ir3h~~CalledByGraph proc~util_set_ir3h util_set_ir3h interface~util_set_ir3h util_set_ir3h interface~util_set_ir3h->proc~util_set_ir3h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_set_ir3h.html"},{"title":"util_set_msys – swiftest","text":"module subroutine util_set_msys(self) Interface → Sets the value of msys and the vector mass quantities based on the total mass of the system Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nobdy system object Called by proc~~util_set_msys~~CalledByGraph proc~util_set_msys util_set_msys interface~util_set_msys util_set_msys interface~util_set_msys->proc~util_set_msys Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_set_msys.html"},{"title":"util_set_mu_pl – swiftest","text":"module subroutine util_set_mu_pl(self, cb) Interface → Computes G * (M + m) for each massive body Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object Called by proc~~util_set_mu_pl~~CalledByGraph proc~util_set_mu_pl util_set_mu_pl interface~util_set_mu_pl util_set_mu_pl interface~util_set_mu_pl->proc~util_set_mu_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_set_mu_pl.html"},{"title":"util_set_mu_tp – swiftest","text":"module subroutine util_set_mu_tp(self, cb) Interface → Converts certain scalar values to arrays so that they can be used in elemental functions Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object Called by proc~~util_set_mu_tp~~CalledByGraph proc~util_set_mu_tp util_set_mu_tp interface~util_set_mu_tp util_set_mu_tp interface~util_set_mu_tp->proc~util_set_mu_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_set_mu_tp.html"},{"title":"util_set_particle_info – swiftest","text":"module subroutine util_set_particle_info(self, name, particle_type, status, origin_type, origin_time, origin_xh, origin_vh, discard_time, discard_xh, discard_vh, discard_body_id) Interface → Sets one or more values of the particle information metadata object Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(inout) :: self character(len=*), intent(in), optional :: name Non-unique name character(len=*), intent(in), optional :: particle_type String containing a description of the particle type (e.g. Central Body, Massive Body, Test Particle) character(len=*), intent(in), optional :: status Particle status description: ACTIVE, MERGED, FRAGMENTED, etc. character(len=*), intent(in), optional :: origin_type String containing a description of the origin of the particle (e.g. Initial Conditions, Supercatastrophic, Disruption, etc.) real(kind=DP), intent(in), optional :: origin_time The time of the particle's formation real(kind=DP), intent(in), optional dimension(:) :: origin_xh The heliocentric distance vector at the time of the particle's formation real(kind=DP), intent(in), optional dimension(:) :: origin_vh The heliocentric velocity vector at the time of the particle's formation real(kind=DP), intent(in), optional :: discard_time The time of the particle's discard real(kind=DP), intent(in), optional dimension(:) :: discard_xh The heliocentric distance vector at the time of the particle's discard real(kind=DP), intent(in), optional dimension(:) :: discard_vh The heliocentric velocity vector at the time of the particle's discard integer(kind=I4B), intent(in), optional :: discard_body_id The id of the other body involved in the discard (0 if no other body involved) Called by proc~~util_set_particle_info~~CalledByGraph proc~util_set_particle_info util_set_particle_info interface~util_set_particle_info util_set_particle_info interface~util_set_particle_info->proc~util_set_particle_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_set_particle_info.html"},{"title":"util_set_rhill – swiftest","text":"module subroutine util_set_rhill(self, cb) Interface → Sets the value of the Hill's radius Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object Called by proc~~util_set_rhill~~CalledByGraph proc~util_set_rhill util_set_rhill interface~util_set_rhill util_set_rhill interface~util_set_rhill->proc~util_set_rhill Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_set_rhill.html"},{"title":"util_set_rhill_approximate – swiftest","text":"module subroutine util_set_rhill_approximate(self, cb) Interface → Sets the approximate value of the Hill's radius using the heliocentric radius instead of computing the semimajor axis Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object Called by proc~~util_set_rhill_approximate~~CalledByGraph proc~util_set_rhill_approximate util_set_rhill_approximate interface~util_set_rhill_approximate util_set_rhill_approximate interface~util_set_rhill_approximate->proc~util_set_rhill_approximate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_set_rhill_approximate.html"},{"title":"util_peri_tp – swiftest","text":"module subroutine util_peri_tp(self, system, param) Interface → Determine system pericenter passages for test particles\n Note:  If the coordinate system used is barycentric, then this routine assumes that the barycentric coordinates in the\n        test particle structures are up-to-date and are not recomputed Adapted from David E. Kaufmann's Swifter routine: util_peri.f90\n Adapted from Hal Levison's Swift routine util_peri.f Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~util_peri_tp~~CallsGraph proc~util_peri_tp util_peri_tp interface~orbel_xv2aeq orbel_xv2aeq proc~util_peri_tp->interface~orbel_xv2aeq proc~orbel_xv2aeq orbel_xv2aeq interface~orbel_xv2aeq->proc~orbel_xv2aeq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_peri_tp~~CalledByGraph proc~util_peri_tp util_peri_tp interface~util_peri_tp util_peri_tp interface~util_peri_tp->proc~util_peri_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_peri_tp.html"},{"title":"util_coord_h2b_pl – swiftest","text":"module subroutine util_coord_h2b_pl(self, cb) Interface → Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) Adapted from David E. Kaufmann's Swifter routine coord_h2b.f90 \n Adapted from Hal Levison's Swift routine coord_h2b.f Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object Called by proc~~util_coord_h2b_pl~~CalledByGraph proc~util_coord_h2b_pl util_coord_h2b_pl interface~util_coord_h2b_pl util_coord_h2b_pl interface~util_coord_h2b_pl->proc~util_coord_h2b_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_coord_h2b_pl.html"},{"title":"util_coord_h2b_tp – swiftest","text":"module subroutine util_coord_h2b_tp(self, cb) Interface → Convert test particles from heliocentric to barycentric coordinates (position and velocity) Adapted from David E. Kaufmann's Swifter routine coord_h2b_tp.f90 \n Adapted from Hal Levison's Swift routine coord_h2b_tp.f Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object Called by proc~~util_coord_h2b_tp~~CalledByGraph proc~util_coord_h2b_tp util_coord_h2b_tp interface~util_coord_h2b_tp util_coord_h2b_tp interface~util_coord_h2b_tp->proc~util_coord_h2b_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_coord_h2b_tp.html"},{"title":"util_coord_b2h_pl – swiftest","text":"module subroutine util_coord_b2h_pl(self, cb) Interface → Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) Adapted from David E. Kaufmann's Swifter routine coord_b2h.f90 \n Adapted from Hal Levison's Swift routine coord_b2h.f Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object Called by proc~~util_coord_b2h_pl~~CalledByGraph proc~util_coord_b2h_pl util_coord_b2h_pl interface~util_coord_b2h_pl util_coord_b2h_pl interface~util_coord_b2h_pl->proc~util_coord_b2h_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_coord_b2h_pl.html"},{"title":"util_coord_b2h_tp – swiftest","text":"module subroutine util_coord_b2h_tp(self, cb) Interface → Convert test particles from barycentric to heliocentric coordinates (position and velocity) Adapted from David E. Kaufmann's Swifter routine coord_b2h_tp.f90 \n Adapted from Hal Levison's Swift routine coord_b2h_tp.f Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(in) :: cb Swiftest central body object Called by proc~~util_coord_b2h_tp~~CalledByGraph proc~util_coord_b2h_tp util_coord_b2h_tp interface~util_coord_b2h_tp util_coord_b2h_tp interface~util_coord_b2h_tp->proc~util_coord_b2h_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_coord_b2h_tp.html"},{"title":"util_coord_vb2vh_pl – swiftest","text":"module subroutine util_coord_vb2vh_pl(self, cb) Interface → Convert massive bodies from barycentric to heliocentric coordinates (velocity only) Adapted from David E. Kaufmann's Swifter routine coord_vb2vh.f90 \n Adapted from Hal Levison's Swift routine coord_vb2vh.f Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object Called by proc~~util_coord_vb2vh_pl~~CalledByGraph proc~util_coord_vb2vh_pl util_coord_vb2vh_pl interface~util_coord_vb2vh_pl util_coord_vb2vh_pl interface~util_coord_vb2vh_pl->proc~util_coord_vb2vh_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_coord_vb2vh_pl.html"},{"title":"util_coord_vb2vh_tp – swiftest","text":"module subroutine util_coord_vb2vh_tp(self, vbcb) Interface → Convert test particles from barycentric to heliocentric coordinates (velocity only) Adapted from David E. Kaufmann's Swifter routine coord_vb2vh_tp.f90 \n Adapted from Hal Levison's Swift routine coord_vb2h_tp.f Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body Called by proc~~util_coord_vb2vh_tp~~CalledByGraph proc~util_coord_vb2vh_tp util_coord_vb2vh_tp interface~util_coord_vb2vh_tp util_coord_vb2vh_tp interface~util_coord_vb2vh_tp->proc~util_coord_vb2vh_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_coord_vb2vh_tp.html"},{"title":"util_coord_vh2vb_pl – swiftest","text":"module subroutine util_coord_vh2vb_pl(self, cb) Interface → Convert massive bodies from heliocentric to barycentric coordinates (velocity only) Adapted from David E. Kaufmann's Swifter routine coord_vh2vb.f90 \n Adapted from Hal Levison's Swift routine coord_vh2b.f Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object Called by proc~~util_coord_vh2vb_pl~~CalledByGraph proc~util_coord_vh2vb_pl util_coord_vh2vb_pl interface~util_coord_vh2vb_pl util_coord_vh2vb_pl interface~util_coord_vh2vb_pl->proc~util_coord_vh2vb_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_coord_vh2vb_pl.html"},{"title":"util_coord_vh2vb_tp – swiftest","text":"module subroutine util_coord_vh2vb_tp(self, vbcb) Interface → Convert test particles from heliocentric to barycentric coordinates (velocity only) Adapted from David E. Kaufmann's Swifter routine coord_vh2vb_tp.f90\n Adapted from Hal Levison's Swift routine coord_vh2b_tp.f Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body Called by proc~~util_coord_vh2vb_tp~~CalledByGraph proc~util_coord_vh2vb_tp util_coord_vh2vb_tp interface~util_coord_vh2vb_tp util_coord_vh2vb_tp interface~util_coord_vh2vb_tp->proc~util_coord_vh2vb_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_coord_vh2vb_tp.html"},{"title":"util_coord_xh2xb_pl – swiftest","text":"module subroutine util_coord_xh2xb_pl(self, cb) Interface → Convert position vectors of massive bodies from heliocentric to barycentric coordinates (position only) Adapted from David E. Kaufmann's Swifter routine coord_h2b.f90 \n Adapted from Hal Levison's Swift routine coord_h2b.f Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object Called by proc~~util_coord_xh2xb_pl~~CalledByGraph proc~util_coord_xh2xb_pl util_coord_xh2xb_pl interface~util_coord_xh2xb_pl util_coord_xh2xb_pl interface~util_coord_xh2xb_pl->proc~util_coord_xh2xb_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_coord_xh2xb_pl.html"},{"title":"util_coord_xh2xb_tp – swiftest","text":"module subroutine util_coord_xh2xb_tp(self, cb) Interface → Convert test particles from heliocentric to barycentric coordinates (position only) Adapted from David E. Kaufmann's Swifter routine coord_h2b_tp.f90 \n Adapted from Hal Levison's Swift routine coord_h2b_tp.f Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object Called by proc~~util_coord_xh2xb_tp~~CalledByGraph proc~util_coord_xh2xb_tp util_coord_xh2xb_tp interface~util_coord_xh2xb_tp util_coord_xh2xb_tp interface~util_coord_xh2xb_tp->proc~util_coord_xh2xb_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_coord_xh2xb_tp.html"},{"title":"util_index_eucl_ij_to_k – swiftest","text":"pure module subroutine util_index_eucl_ij_to_k(n, i, j, k) Interface → Turns i,j indices into k index for use in the Euclidean distance matrix for pl-pl interactions. Reference: Mélodie Angeletti, Jean-Marie Bonny, Jonas Koko. Parallel Euclidean distance matrix computation on big datasets *. 2019. hal-0204751 Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n Number of bodies integer(kind=I4B), intent(in) :: i Index of the ith body integer(kind=I4B), intent(in) :: j Index of the jth body integer(kind=I8B), intent(out) :: k Index of the flattened matrix Called by proc~~util_index_eucl_ij_to_k~~CalledByGraph proc~util_index_eucl_ij_to_k util_index_eucl_ij_to_k interface~util_index_eucl_ij_to_k util_index_eucl_ij_to_k interface~util_index_eucl_ij_to_k->proc~util_index_eucl_ij_to_k proc~util_index_eucl_plpl util_index_eucl_plpl proc~util_index_eucl_plpl->interface~util_index_eucl_ij_to_k interface~util_index_eucl_plpl util_index_eucl_plpl interface~util_index_eucl_plpl->proc~util_index_eucl_plpl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_index_eucl_ij_to_k.html"},{"title":"util_index_eucl_k_to_ij – swiftest","text":"pure module subroutine util_index_eucl_k_to_ij(n, k, i, j) Interface → Turns k index into i,j indices for use in the Euclidean distance matrix for pl-pl interactions. Reference: Mélodie Angeletti, Jean-Marie Bonny, Jonas Koko. Parallel Euclidean distance matrix computation on big datasets *. 2019. hal-0204751 Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n Number of bodies integer(kind=I8B), intent(in) :: k Index of the flattened matrix integer(kind=I4B), intent(out) :: i Index of the ith body integer(kind=I4B), intent(out) :: j Index of the jth body Called by proc~~util_index_eucl_k_to_ij~~CalledByGraph proc~util_index_eucl_k_to_ij util_index_eucl_k_to_ij interface~util_index_eucl_k_to_ij util_index_eucl_k_to_ij interface~util_index_eucl_k_to_ij->proc~util_index_eucl_k_to_ij Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_index_eucl_k_to_ij.html"},{"title":"util_index_eucl_plpl – swiftest","text":"module subroutine util_index_eucl_plpl(self, param) Interface → Turns i,j indices into k index for use in the Euclidean distance matrix for pl-pl interactions for a Swiftest massive body object Reference: Mélodie Angeletti, Jean-Marie Bonny, Jonas Koko. Parallel Euclidean distance matrix computation on big datasets *. 2019. hal-0204751 Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~util_index_eucl_plpl~~CallsGraph proc~util_index_eucl_plpl util_index_eucl_plpl interface~util_index_eucl_ij_to_k util_index_eucl_ij_to_k proc~util_index_eucl_plpl->interface~util_index_eucl_ij_to_k proc~util_index_eucl_ij_to_k util_index_eucl_ij_to_k interface~util_index_eucl_ij_to_k->proc~util_index_eucl_ij_to_k Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_index_eucl_plpl~~CalledByGraph proc~util_index_eucl_plpl util_index_eucl_plpl interface~util_index_eucl_plpl util_index_eucl_plpl interface~util_index_eucl_plpl->proc~util_index_eucl_plpl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_index_eucl_plpl.html"},{"title":"util_index_eucl_pltp – swiftest","text":"module subroutine util_index_eucl_pltp(self, pl, param) Interface → Turns i,j indices into k index for use in the Euclidean distance matrix for pl-tp interactions Reference: Mélodie Angeletti, Jean-Marie Bonny, Jonas Koko. Parallel Euclidean distance matrix computation on big datasets *. 2019. hal-0204751 Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_pl ), intent(in) :: pl Swiftest massive body object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Called by proc~~util_index_eucl_pltp~~CalledByGraph proc~util_index_eucl_pltp util_index_eucl_pltp interface~util_index_eucl_pltp util_index_eucl_pltp interface~util_index_eucl_pltp->proc~util_index_eucl_pltp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_index_eucl_pltp.html"},{"title":"util_rescale_system – swiftest","text":"module subroutine util_rescale_system(self, param, mscale, dscale, tscale) Interface → Rescales an nbody system to a new set of units. Inputs are the multipliers on the mass (mscale), distance (dscale), and time units (tscale). \n Rescales all united quantities in the system, as well as the mass conversion factors, gravitational constant, and Einstein's constant in the parameter object. Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters. Returns with new values of the scale vactors and GU real(kind=DP), intent(in) :: mscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: dscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: tscale Scale factors for mass, distance, and time units, respectively. Called by proc~~util_rescale_system~~CalledByGraph proc~util_rescale_system util_rescale_system interface~util_rescale_system util_rescale_system interface~util_rescale_system->proc~util_rescale_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_rescale_system.html"},{"title":"util_version – swiftest","text":"module subroutine util_version() Interface → Print program version information to terminale Adapted from David E. Kaufmann's Swifter routine: util_version.f90 Arguments None Called by proc~~util_version~~CalledByGraph proc~util_version util_version interface~util_version util_version interface~util_version->proc~util_version proc~io_get_args io_get_args proc~io_get_args->interface~util_version interface~io_get_args io_get_args interface~io_get_args->proc~io_get_args Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_version.html"},{"title":"util_sort_body – swiftest","text":"module subroutine util_sort_body(self, sortby, ascending) Interface → Sort a Swiftest body structure in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order Called by proc~~util_sort_body~~CalledByGraph proc~util_sort_body util_sort_body interface~util_sort_body util_sort_body interface~util_sort_body->proc~util_sort_body proc~util_sort_pl util_sort_pl proc~util_sort_pl->interface~util_sort_body proc~util_sort_tp util_sort_tp proc~util_sort_tp->interface~util_sort_body interface~util_sort_tp util_sort_tp interface~util_sort_tp->proc~util_sort_tp interface~util_sort_pl util_sort_pl interface~util_sort_pl->proc~util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_sort_body.html"},{"title":"util_sort_dp – swiftest","text":"subroutine util_sort_dp(arr) Sort input double precision array in place into ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:) :: arr Contents None","tags":"","loc":"proc/util_sort_dp.html"},{"title":"util_sort_index_dp – swiftest","text":"subroutine util_sort_index_dp(arr, ind) Sort input double precision array by index in ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind Contents None","tags":"","loc":"proc/util_sort_index_dp.html"},{"title":"util_sort_i4b – swiftest","text":"subroutine util_sort_i4b(arr) Sort input integer array in place into ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:) :: arr Contents None","tags":"","loc":"proc/util_sort_i4b.html"},{"title":"util_sort_index_i4b – swiftest","text":"subroutine util_sort_index_i4b(arr, ind) Sort input integer array by index in ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind Contents None","tags":"","loc":"proc/util_sort_index_i4b.html"},{"title":"util_sort_sp – swiftest","text":"subroutine util_sort_sp(arr) Sort input single precision array in place into ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), dimension(:) :: arr Contents None","tags":"","loc":"proc/util_sort_sp.html"},{"title":"util_sort_index_sp – swiftest","text":"subroutine util_sort_index_sp(arr, ind) Sort input single precision array by index in ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind Contents None","tags":"","loc":"proc/util_sort_index_sp.html"},{"title":"util_sort_pl – swiftest","text":"module subroutine util_sort_pl(self, sortby, ascending) Interface → Sort a Swiftest massive body object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order Calls proc~~util_sort_pl~~CallsGraph proc~util_sort_pl util_sort_pl interface~util_sort_body util_sort_body proc~util_sort_pl->interface~util_sort_body proc~util_sort_body util_sort_body interface~util_sort_body->proc~util_sort_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_sort_pl~~CalledByGraph proc~util_sort_pl util_sort_pl interface~util_sort_pl util_sort_pl interface~util_sort_pl->proc~util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_sort_pl.html"},{"title":"util_sort_tp – swiftest","text":"module subroutine util_sort_tp(self, sortby, ascending) Interface → Sort a Swiftest test particle object  in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order Calls proc~~util_sort_tp~~CallsGraph proc~util_sort_tp util_sort_tp interface~util_sort_body util_sort_body proc~util_sort_tp->interface~util_sort_body proc~util_sort_body util_sort_body interface~util_sort_body->proc~util_sort_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_sort_tp~~CalledByGraph proc~util_sort_tp util_sort_tp interface~util_sort_tp util_sort_tp interface~util_sort_tp->proc~util_sort_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_sort_tp.html"},{"title":"util_sort_rearrange_body – swiftest","text":"module subroutine util_sort_rearrange_body(self, ind) Interface → Rearrange Swiftest body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) Calls proc~~util_sort_rearrange_body~~CallsGraph proc~util_sort_rearrange_body util_sort_rearrange_body interface~util_sort_rearrange~2 util_sort_rearrange proc~util_sort_rearrange_body->interface~util_sort_rearrange~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_sort_rearrange_body~~CalledByGraph proc~util_sort_rearrange_body util_sort_rearrange_body interface~util_sort_rearrange_body util_sort_rearrange_body interface~util_sort_rearrange_body->proc~util_sort_rearrange_body proc~util_sort_rearrange_tp util_sort_rearrange_tp proc~util_sort_rearrange_tp->interface~util_sort_rearrange_body proc~util_sort_rearrange_pl util_sort_rearrange_pl proc~util_sort_rearrange_pl->interface~util_sort_rearrange_body interface~util_sort_rearrange_pl util_sort_rearrange_pl interface~util_sort_rearrange_pl->proc~util_sort_rearrange_pl interface~util_sort_rearrange_tp util_sort_rearrange_tp interface~util_sort_rearrange_tp->proc~util_sort_rearrange_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_sort_rearrange_body.html"},{"title":"util_sort_rearrange_arr_char_string – swiftest","text":"subroutine util_sort_rearrange_arr_char_string(arr, ind, n) Rearrange a single array of character string in-place from an index list. Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange Contents None","tags":"","loc":"proc/util_sort_rearrange_arr_char_string.html"},{"title":"util_sort_rearrange_arr_DP – swiftest","text":"subroutine util_sort_rearrange_arr_DP(arr, ind, n) Rearrange a single array of DP type in-place from an index list. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange Contents None","tags":"","loc":"proc/util_sort_rearrange_arr_dp.html"},{"title":"util_sort_rearrange_arr_DPvec – swiftest","text":"subroutine util_sort_rearrange_arr_DPvec(arr, ind, n) Rearrange a single array of (NDIM,n) DP-type vectors in-place from an index list. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange Contents None","tags":"","loc":"proc/util_sort_rearrange_arr_dpvec.html"},{"title":"util_sort_rearrange_arr_I4B – swiftest","text":"subroutine util_sort_rearrange_arr_I4B(arr, ind, n) Rearrange a single array of integers in-place from an index list. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange Contents None","tags":"","loc":"proc/util_sort_rearrange_arr_i4b.html"},{"title":"util_sort_rearrange_arr_logical – swiftest","text":"subroutine util_sort_rearrange_arr_logical(arr, ind, n) Rearrange a single array of logicals in-place from an index list. Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange Contents None","tags":"","loc":"proc/util_sort_rearrange_arr_logical.html"},{"title":"util_sort_rearrange_arr_info – swiftest","text":"subroutine util_sort_rearrange_arr_info(arr, ind, n) Rearrange a single array of particle information type in-place from an index list. Arguments Type Intent Optional Attributes Name type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange Calls proc~~util_sort_rearrange_arr_info~~CallsGraph proc~util_sort_rearrange_arr_info util_sort_rearrange_arr_info interface~util_copy_particle_info_arr util_copy_particle_info_arr proc~util_sort_rearrange_arr_info->interface~util_copy_particle_info_arr proc~util_copy_particle_info_arr util_copy_particle_info_arr interface~util_copy_particle_info_arr->proc~util_copy_particle_info_arr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_sort_rearrange_arr_info.html"},{"title":"util_sort_rearrange_pl – swiftest","text":"module subroutine util_sort_rearrange_pl(self, ind) Interface → Rearrange Swiftest massive body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) Calls proc~~util_sort_rearrange_pl~~CallsGraph proc~util_sort_rearrange_pl util_sort_rearrange_pl interface~util_sort_rearrange~2 util_sort_rearrange proc~util_sort_rearrange_pl->interface~util_sort_rearrange~2 interface~util_sort_rearrange_body util_sort_rearrange_body proc~util_sort_rearrange_pl->interface~util_sort_rearrange_body proc~util_sort_rearrange_body util_sort_rearrange_body interface~util_sort_rearrange_body->proc~util_sort_rearrange_body proc~util_sort_rearrange_body->interface~util_sort_rearrange~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_sort_rearrange_pl~~CalledByGraph proc~util_sort_rearrange_pl util_sort_rearrange_pl interface~util_sort_rearrange_pl util_sort_rearrange_pl interface~util_sort_rearrange_pl->proc~util_sort_rearrange_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_sort_rearrange_pl.html"},{"title":"util_sort_rearrange_tp – swiftest","text":"module subroutine util_sort_rearrange_tp(self, ind) Interface → Rearrange Swiftest massive body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) Calls proc~~util_sort_rearrange_tp~~CallsGraph proc~util_sort_rearrange_tp util_sort_rearrange_tp interface~util_sort_rearrange~2 util_sort_rearrange proc~util_sort_rearrange_tp->interface~util_sort_rearrange~2 interface~util_sort_rearrange_body util_sort_rearrange_body proc~util_sort_rearrange_tp->interface~util_sort_rearrange_body proc~util_sort_rearrange_body util_sort_rearrange_body interface~util_sort_rearrange_body->proc~util_sort_rearrange_body proc~util_sort_rearrange_body->interface~util_sort_rearrange~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_sort_rearrange_tp~~CalledByGraph proc~util_sort_rearrange_tp util_sort_rearrange_tp interface~util_sort_rearrange_tp util_sort_rearrange_tp interface~util_sort_rearrange_tp->proc~util_sort_rearrange_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_sort_rearrange_tp.html"},{"title":"util_spill_arr_char_string – swiftest","text":"subroutine util_spill_arr_char_string(keeps, discards, lspill_list, ldestructive) Performs a spill operation on a single array of type character strings\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: keeps Array of values to keep character(len=STRMAX), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not Contents None","tags":"","loc":"proc/util_spill_arr_char_string.html"},{"title":"util_spill_arr_DP – swiftest","text":"subroutine util_spill_arr_DP(keeps, discards, lspill_list, ldestructive) Performs a spill operation on a single array of type DP\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: keeps Array of values to keep real(kind=DP), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not Contents None","tags":"","loc":"proc/util_spill_arr_dp.html"},{"title":"util_spill_arr_DPvec – swiftest","text":"subroutine util_spill_arr_DPvec(keeps, discards, lspill_list, ldestructive) Performs a spill operation on a single array of DP vectors with shape (NDIM, n)\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: keeps Array of values to keep real(kind=DP), intent(inout), dimension(:,:), allocatable :: discards Array discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not Contents None","tags":"","loc":"proc/util_spill_arr_dpvec.html"},{"title":"util_spill_arr_I4B – swiftest","text":"subroutine util_spill_arr_I4B(keeps, discards, lspill_list, ldestructive) Performs a spill operation on a single array of type I4B\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: keeps Array of values to keep integer(kind=I4B), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not Contents None","tags":"","loc":"proc/util_spill_arr_i4b.html"},{"title":"util_spill_arr_I8B – swiftest","text":"subroutine util_spill_arr_I8B(keeps, discards, lspill_list, ldestructive) Performs a spill operation on a single array of type I4B\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(inout), dimension(:), allocatable :: keeps Array of values to keep integer(kind=I8B), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not Contents None","tags":"","loc":"proc/util_spill_arr_i8b.html"},{"title":"util_spill_arr_info – swiftest","text":"subroutine util_spill_arr_info(keeps, discards, lspill_list, ldestructive) Performs a spill operation on a single array of particle origin information types\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not Calls proc~~util_spill_arr_info~~CallsGraph proc~util_spill_arr_info util_spill_arr_info interface~util_copy_particle_info_arr util_copy_particle_info_arr proc~util_spill_arr_info->interface~util_copy_particle_info_arr proc~util_copy_particle_info_arr util_copy_particle_info_arr interface~util_copy_particle_info_arr->proc~util_copy_particle_info_arr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_spill_arr_info.html"},{"title":"util_spill_arr_logical – swiftest","text":"subroutine util_spill_arr_logical(keeps, discards, lspill_list, ldestructive) Performs a spill operation on a single array of logicals\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: keeps Array of values to keep logical, intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or no Contents None","tags":"","loc":"proc/util_spill_arr_logical.html"},{"title":"util_spill_body – swiftest","text":"module subroutine util_spill_body(self, discards, lspill_list, ldestructive) Interface → Move spilled (discarded) Swiftest generic particle structure from active list to discard list\n Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90\n Spill all the common components Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list Calls proc~~util_spill_body~~CallsGraph proc~util_spill_body util_spill_body interface~util_spill~2 util_spill proc~util_spill_body->interface~util_spill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_spill_body~~CalledByGraph proc~util_spill_body util_spill_body interface~util_spill_body util_spill_body interface~util_spill_body->proc~util_spill_body proc~util_spill_pl util_spill_pl proc~util_spill_pl->interface~util_spill_body proc~util_spill_tp util_spill_tp proc~util_spill_tp->interface~util_spill_body interface~util_spill_tp util_spill_tp interface~util_spill_tp->proc~util_spill_tp interface~util_spill_pl util_spill_pl interface~util_spill_pl->proc~util_spill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_spill_body.html"},{"title":"util_spill_encounter – swiftest","text":"module subroutine util_spill_encounter(self, discards, lspill_list, ldestructive) Interface → Move spilled (discarded) Swiftest encounter structure from active list to discard list Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list Calls proc~~util_spill_encounter~~CallsGraph proc~util_spill_encounter util_spill_encounter interface~util_spill~2 util_spill proc~util_spill_encounter->interface~util_spill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_spill_encounter~~CalledByGraph proc~util_spill_encounter util_spill_encounter interface~util_spill_encounter util_spill_encounter interface~util_spill_encounter->proc~util_spill_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_spill_encounter.html"},{"title":"util_spill_pl – swiftest","text":"module subroutine util_spill_pl(self, discards, lspill_list, ldestructive) Interface → Move spilled (discarded) Swiftest massive body structure from active list to discard list\n Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90\n Spill components specific to the massive body class Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list Calls proc~~util_spill_pl~~CallsGraph proc~util_spill_pl util_spill_pl interface~util_spill~2 util_spill proc~util_spill_pl->interface~util_spill~2 interface~util_spill_body util_spill_body proc~util_spill_pl->interface~util_spill_body proc~util_spill_body util_spill_body interface~util_spill_body->proc~util_spill_body proc~util_spill_body->interface~util_spill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_spill_pl~~CalledByGraph proc~util_spill_pl util_spill_pl interface~util_spill_pl util_spill_pl interface~util_spill_pl->proc~util_spill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_spill_pl.html"},{"title":"util_spill_tp – swiftest","text":"module subroutine util_spill_tp(self, discards, lspill_list, ldestructive) Interface → Move spilled (discarded) Swiftest test particle structure from active list to discard list\n Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90\n Spill components specific to the test particle class Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardse logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list Calls proc~~util_spill_tp~~CallsGraph proc~util_spill_tp util_spill_tp interface~util_spill~2 util_spill proc~util_spill_tp->interface~util_spill~2 interface~util_spill_body util_spill_body proc~util_spill_tp->interface~util_spill_body proc~util_spill_body util_spill_body interface~util_spill_body->proc~util_spill_body proc~util_spill_body->interface~util_spill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_spill_tp~~CalledByGraph proc~util_spill_tp util_spill_tp interface~util_spill_tp util_spill_tp interface~util_spill_tp->proc~util_spill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_spill_tp.html"},{"title":"util_valid_id_system – swiftest","text":"module subroutine util_valid_id_system(self, param) Interface → Validate massive body and test particle ids\n Subroutine causes program to exit with error if any ids are not unique Adapted from David E. Kaufmann's Swifter routine: util_valid.f90 Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Calls proc~~util_valid_id_system~~CallsGraph proc~util_valid_id_system util_valid_id_system interface~util_exit util_exit proc~util_valid_id_system->interface~util_exit interface~util_sort util_sort proc~util_valid_id_system->interface~util_sort proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_valid_id_system~~CalledByGraph proc~util_valid_id_system util_valid_id_system interface~util_valid_id_system util_valid_id_system interface~util_valid_id_system->proc~util_valid_id_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_valid_id_system.html"},{"title":"util_exit – swiftest","text":"module subroutine util_exit(code) Interface → Print termination message and exit program Adapted from David E. Kaufmann's Swifter routine: util_exit.f90\n Adapted from Hal Levison's Swift routine util_exit.f Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: code Called by proc~~util_exit~~CalledByGraph proc~util_exit util_exit interface~util_exit util_exit interface~util_exit->proc~util_exit proc~io_write_encounter io_write_encounter proc~io_write_encounter->interface~util_exit proc~io_read_in_cb io_read_in_cb proc~io_read_in_cb->interface~util_exit proc~util_append_pl util_append_pl proc~util_append_pl->interface~util_exit proc~util_append_tp util_append_tp proc~util_append_tp->interface~util_exit proc~io_read_encounter io_read_encounter proc~io_read_encounter->interface~util_exit proc~setup_construct_system setup_construct_system proc~setup_construct_system->interface~util_exit proc~io_read_particle_info_system io_read_particle_info_system proc~io_read_particle_info_system->interface~util_exit proc~check check proc~check->interface~util_exit proc~io_write_discard io_write_discard proc~io_write_discard->interface~util_exit proc~io_dump_particle_info_base io_dump_particle_info_base proc~io_dump_particle_info_base->interface~util_exit proc~io_dump_particle_info io_dump_particle_info proc~io_dump_particle_info->interface~util_exit proc~io_dump_param io_dump_param proc~io_dump_param->interface~util_exit proc~io_write_frame_encounter io_write_frame_encounter proc~io_write_frame_encounter->interface~util_exit proc~io_conservation_report io_conservation_report proc~io_conservation_report->interface~util_exit proc~io_read_frame_cb io_read_frame_cb proc~io_read_frame_cb->interface~util_exit proc~io_read_in_particle_info io_read_in_particle_info proc~io_read_in_particle_info->interface~util_exit proc~io_get_old_t_final_system io_get_old_t_final_system proc~io_get_old_t_final_system->interface~util_exit proc~io_dump_base io_dump_base proc~io_dump_base->interface~util_exit interface~io_write_frame_body io_write_frame_body proc~io_dump_base->interface~io_write_frame_body interface~io_write_frame_cb io_write_frame_cb proc~io_dump_base->interface~io_write_frame_cb proc~io_write_hdr_system io_write_hdr_system proc~io_write_hdr_system->interface~util_exit proc~io_read_in_param io_read_in_param proc~io_read_in_param->interface~util_exit proc~util_solve_rkf45 util_solve_rkf45 proc~util_solve_rkf45->interface~util_exit proc~io_read_frame_body io_read_frame_body proc~io_read_frame_body->interface~util_exit proc~io_write_frame_body io_write_frame_body proc~io_write_frame_body->interface~util_exit proc~util_valid_id_system util_valid_id_system proc~util_valid_id_system->interface~util_exit proc~io_write_frame_cb io_write_frame_cb proc~io_write_frame_cb->interface~util_exit proc~io_write_frame_system io_write_frame_system proc~io_write_frame_system->interface~util_exit proc~io_get_args io_get_args proc~io_get_args->interface~util_exit interface~io_conservation_report io_conservation_report interface~io_conservation_report->proc~io_conservation_report interface~util_solve_rkf45 util_solve_rkf45 interface~util_solve_rkf45->proc~util_solve_rkf45 interface~io_dump_particle_info_base io_dump_particle_info_base interface~io_dump_particle_info_base->proc~io_dump_particle_info_base interface~setup_construct_system setup_construct_system interface~setup_construct_system->proc~setup_construct_system interface~io_write_hdr_system io_write_hdr_system interface~io_write_hdr_system->proc~io_write_hdr_system interface~io_read_frame_cb io_read_frame_cb interface~io_read_frame_cb->proc~io_read_frame_cb interface~io_read_in_cb io_read_in_cb interface~io_read_in_cb->proc~io_read_in_cb interface~io_write_encounter io_write_encounter interface~io_write_encounter->proc~io_write_encounter interface~io_dump_param io_dump_param interface~io_dump_param->proc~io_dump_param interface~io_get_args io_get_args interface~io_get_args->proc~io_get_args interface~io_read_frame_body io_read_frame_body interface~io_read_frame_body->proc~io_read_frame_body interface~util_append_tp util_append_tp interface~util_append_tp->proc~util_append_tp interface~io_write_frame_encounter io_write_frame_encounter interface~io_write_frame_encounter->proc~io_write_frame_encounter interface~io_write_frame_body->proc~io_write_frame_body interface~util_valid_id_system util_valid_id_system interface~util_valid_id_system->proc~util_valid_id_system interface~io_read_particle_info_system io_read_particle_info_system interface~io_read_particle_info_system->proc~io_read_particle_info_system interface~io_write_discard io_write_discard interface~io_write_discard->proc~io_write_discard interface~io_dump_base io_dump_base interface~io_dump_base->proc~io_dump_base interface~util_append_pl util_append_pl interface~util_append_pl->proc~util_append_pl interface~io_dump_particle_info io_dump_particle_info interface~io_dump_particle_info->proc~io_dump_particle_info interface~io_write_frame_system io_write_frame_system interface~io_write_frame_system->proc~io_write_frame_system interface~io_read_in_param io_read_in_param interface~io_read_in_param->proc~io_read_in_param interface~io_write_frame_cb->proc~io_write_frame_cb interface~io_get_old_t_final_system io_get_old_t_final_system interface~io_get_old_t_final_system->proc~io_get_old_t_final_system interface~io_read_in_particle_info io_read_in_particle_info interface~io_read_in_particle_info->proc~io_read_in_particle_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_exit.html"},{"title":"util_fill_arr_char_string – swiftest","text":"subroutine util_fill_arr_char_string(keeps, inserts, lfill_list) Performs a fill operation on a single array of type character strings\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: keeps Array of values to keep character(len=STRMAX), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Contents None","tags":"","loc":"proc/util_fill_arr_char_string.html"},{"title":"util_fill_arr_DP – swiftest","text":"subroutine util_fill_arr_DP(keeps, inserts, lfill_list) Performs a fill operation on a single array of type DP\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: keeps Array of values to keep real(kind=DP), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Contents None","tags":"","loc":"proc/util_fill_arr_dp.html"},{"title":"util_fill_arr_DPvec – swiftest","text":"subroutine util_fill_arr_DPvec(keeps, inserts, lfill_list) Performs a fill operation on a single array of DP vectors with shape (NDIM, n)\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: keeps Array of values to keep real(kind=DP), intent(in), dimension(:,:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Contents None","tags":"","loc":"proc/util_fill_arr_dpvec.html"},{"title":"util_fill_arr_I4B – swiftest","text":"subroutine util_fill_arr_I4B(keeps, inserts, lfill_list) Performs a fill operation on a single array of type I4B\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: keeps Array of values to keep integer(kind=I4B), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Contents None","tags":"","loc":"proc/util_fill_arr_i4b.html"},{"title":"util_fill_arr_info – swiftest","text":"subroutine util_fill_arr_info(keeps, inserts, lfill_list) Performs a fill operation on a single array of particle origin information types\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( swiftest_particle_info ), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Calls proc~~util_fill_arr_info~~CallsGraph proc~util_fill_arr_info util_fill_arr_info interface~util_copy_particle_info_arr util_copy_particle_info_arr proc~util_fill_arr_info->interface~util_copy_particle_info_arr proc~util_copy_particle_info_arr util_copy_particle_info_arr interface~util_copy_particle_info_arr->proc~util_copy_particle_info_arr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_fill_arr_info.html"},{"title":"util_fill_arr_logical – swiftest","text":"subroutine util_fill_arr_logical(keeps, inserts, lfill_list) Performs a fill operation on a single array of logicals\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: keeps Array of values to keep logical, intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Contents None","tags":"","loc":"proc/util_fill_arr_logical.html"},{"title":"util_fill_body – swiftest","text":"module subroutine util_fill_body(self, inserts, lfill_list) Interface → Insert new Swiftest generic particle structure into an old one. \n This is the inverse of a spill operation.\n Fill all the common components Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_body ), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Calls proc~~util_fill_body~~CallsGraph proc~util_fill_body util_fill_body interface~util_fill~2 util_fill proc~util_fill_body->interface~util_fill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_fill_body~~CalledByGraph proc~util_fill_body util_fill_body interface~util_fill_body util_fill_body interface~util_fill_body->proc~util_fill_body proc~util_fill_tp util_fill_tp proc~util_fill_tp->interface~util_fill_body proc~util_fill_pl util_fill_pl proc~util_fill_pl->interface~util_fill_body interface~util_fill_tp util_fill_tp interface~util_fill_tp->proc~util_fill_tp interface~util_fill_pl util_fill_pl interface~util_fill_pl->proc~util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_fill_body.html"},{"title":"util_fill_pl – swiftest","text":"module subroutine util_fill_pl(self, inserts, lfill_list) Interface → Insert new Swiftest massive body structure into an old one. \n This is the inverse of a spill operation.\n Fill components specific to the massive body class Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Calls proc~~util_fill_pl~~CallsGraph proc~util_fill_pl util_fill_pl interface~util_fill~2 util_fill proc~util_fill_pl->interface~util_fill~2 interface~util_fill_body util_fill_body proc~util_fill_pl->interface~util_fill_body proc~util_fill_body util_fill_body interface~util_fill_body->proc~util_fill_body proc~util_fill_body->interface~util_fill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_fill_pl~~CalledByGraph proc~util_fill_pl util_fill_pl interface~util_fill_pl util_fill_pl interface~util_fill_pl->proc~util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_fill_pl.html"},{"title":"util_fill_tp – swiftest","text":"module subroutine util_fill_tp(self, inserts, lfill_list) Interface → Insert new Swiftest test particle structure into an old one. \n This is the inverse of a fill operation.\n Spill components specific to the test particle class Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Calls proc~~util_fill_tp~~CallsGraph proc~util_fill_tp util_fill_tp interface~util_fill~2 util_fill proc~util_fill_tp->interface~util_fill~2 interface~util_fill_body util_fill_body proc~util_fill_tp->interface~util_fill_body proc~util_fill_body util_fill_body interface~util_fill_body->proc~util_fill_body proc~util_fill_body->interface~util_fill~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_fill_tp~~CalledByGraph proc~util_fill_tp util_fill_tp interface~util_fill_tp util_fill_tp interface~util_fill_tp->proc~util_fill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_fill_tp.html"},{"title":"util_resize_arr_char_string – swiftest","text":"subroutine util_resize_arr_char_string(arr, nnew) Resizes an array component of type character string. nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size Contents None","tags":"","loc":"proc/util_resize_arr_char_string.html"},{"title":"util_resize_arr_DP – swiftest","text":"subroutine util_resize_arr_DP(arr, nnew) Resizes an array component of double precision type. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size Contents None","tags":"","loc":"proc/util_resize_arr_dp.html"},{"title":"util_resize_arr_DPvec – swiftest","text":"subroutine util_resize_arr_DPvec(arr, nnew) Resizes an array component of double precision vectors of size (NDIM, n). Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size Contents None","tags":"","loc":"proc/util_resize_arr_dpvec.html"},{"title":"util_resize_arr_I4B – swiftest","text":"subroutine util_resize_arr_I4B(arr, nnew) Resizes an array component of integer type. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size Contents None","tags":"","loc":"proc/util_resize_arr_i4b.html"},{"title":"util_resize_arr_info – swiftest","text":"subroutine util_resize_arr_info(arr, nnew) Resizes an array component of type character string. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size Contents None","tags":"","loc":"proc/util_resize_arr_info.html"},{"title":"util_resize_arr_logical – swiftest","text":"subroutine util_resize_arr_logical(arr, nnew) Resizes an array component of logical type. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size Contents None","tags":"","loc":"proc/util_resize_arr_logical.html"},{"title":"util_resize_body – swiftest","text":"module subroutine util_resize_body(self, nnew) Interface → Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in) :: nnew New size neded Calls proc~~util_resize_body~~CallsGraph proc~util_resize_body util_resize_body interface~util_resize~2 util_resize proc~util_resize_body->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_resize_body~~CalledByGraph proc~util_resize_body util_resize_body interface~util_resize_body util_resize_body interface~util_resize_body->proc~util_resize_body proc~util_resize_tp util_resize_tp proc~util_resize_tp->interface~util_resize_body proc~util_resize_pl util_resize_pl proc~util_resize_pl->interface~util_resize_body interface~util_resize_pl util_resize_pl interface~util_resize_pl->proc~util_resize_pl interface~util_resize_tp util_resize_tp interface~util_resize_tp->proc~util_resize_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_resize_body.html"},{"title":"util_resize_encounter – swiftest","text":"module subroutine util_resize_encounter(self, nnew) Interface → Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small.\n Note: The reason to extend it by a factor of 2 is for performance. When there are many enounters per step, resizing every time you want to add an \n encounter takes significant computational effort. Resizing by a factor of 2 is a tradeoff between performance (fewer resize calls) and memory managment\n Memory usage grows by a factor of 2 each time it fills up, but no more. Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list integer(kind=I4B), intent(in) :: nnew New size of list needed Called by proc~~util_resize_encounter~~CalledByGraph proc~util_resize_encounter util_resize_encounter interface~util_resize_encounter util_resize_encounter interface~util_resize_encounter->proc~util_resize_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_resize_encounter.html"},{"title":"util_resize_pl – swiftest","text":"module subroutine util_resize_pl(self, nnew) Interface → Checks the current size of a Swiftest massive body against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: nnew New size neded Calls proc~~util_resize_pl~~CallsGraph proc~util_resize_pl util_resize_pl interface~util_resize~2 util_resize proc~util_resize_pl->interface~util_resize~2 interface~util_resize_body util_resize_body proc~util_resize_pl->interface~util_resize_body proc~util_resize_body util_resize_body interface~util_resize_body->proc~util_resize_body proc~util_resize_body->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_resize_pl~~CalledByGraph proc~util_resize_pl util_resize_pl interface~util_resize_pl util_resize_pl interface~util_resize_pl->proc~util_resize_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_resize_pl.html"},{"title":"util_resize_tp – swiftest","text":"module subroutine util_resize_tp(self, nnew) Interface → Checks the current size of a Swiftest test particle against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: nnew New size neded Calls proc~~util_resize_tp~~CallsGraph proc~util_resize_tp util_resize_tp interface~util_resize~2 util_resize proc~util_resize_tp->interface~util_resize~2 interface~util_resize_body util_resize_body proc~util_resize_tp->interface~util_resize_body proc~util_resize_body util_resize_body interface~util_resize_body->proc~util_resize_body proc~util_resize_body->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_resize_tp~~CalledByGraph proc~util_resize_tp util_resize_tp interface~util_resize_tp util_resize_tp interface~util_resize_tp->proc~util_resize_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_resize_tp.html"},{"title":"util_copy_encounter – swiftest","text":"module subroutine util_copy_encounter(self, source) Interface → Copies elements from the source encounter list into self. Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Encounter list class( swiftest_encounter ), intent(in) :: source Source object to copy into Called by proc~~util_copy_encounter~~CalledByGraph proc~util_copy_encounter util_copy_encounter interface~util_copy_encounter util_copy_encounter interface~util_copy_encounter->proc~util_copy_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_copy_encounter.html"},{"title":"util_copy_particle_info – swiftest","text":"module subroutine util_copy_particle_info(self, source) Interface → Copies one set of information object components into another, component-by-component Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(inout) :: self class( swiftest_particle_info ), intent(in) :: source Called by proc~~util_copy_particle_info~~CalledByGraph proc~util_copy_particle_info util_copy_particle_info interface~util_copy_particle_info util_copy_particle_info interface~util_copy_particle_info->proc~util_copy_particle_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_copy_particle_info.html"},{"title":"util_copy_particle_info_arr – swiftest","text":"module subroutine util_copy_particle_info_arr(source, dest, idx) Interface → Copies contents from an array of one particle information objects to another. Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(in), dimension(:) :: source Source object to copy into class( swiftest_particle_info ), intent(inout), dimension(:) :: dest Swiftest body object with particle metadata information object integer(kind=I4B), intent(in), optional dimension(:) :: idx Optional array of indices to draw the source object Called by proc~~util_copy_particle_info_arr~~CalledByGraph proc~util_copy_particle_info_arr util_copy_particle_info_arr interface~util_copy_particle_info_arr util_copy_particle_info_arr interface~util_copy_particle_info_arr->proc~util_copy_particle_info_arr proc~util_sort_rearrange_arr_info util_sort_rearrange_arr_info proc~util_sort_rearrange_arr_info->interface~util_copy_particle_info_arr proc~util_fill_arr_info util_fill_arr_info proc~util_fill_arr_info->interface~util_copy_particle_info_arr proc~util_spill_arr_info util_spill_arr_info proc~util_spill_arr_info->interface~util_copy_particle_info_arr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_copy_particle_info_arr.html"},{"title":"util_minimize_bfgs – swiftest","text":"module function util_minimize_bfgs(f, N, x0, eps, maxloop, lerr) result(x1) Interface → Uses ieee_exceptions proc~~util_minimize_bfgs~~UsesGraph proc~util_minimize_bfgs util_minimize_bfgs ieee_exceptions ieee_exceptions proc~util_minimize_bfgs->ieee_exceptions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. This function implements the Broyden-Fletcher-Goldfarb-Shanno method to determine the minimum of a function of N variables. It recieves as input:\n   f%eval(x) : lambda function object containing the objective function as the eval metho\n   N       : Number of variables of function f\n   x0      : Initial starting value of x\n   eps     : Accuracy of 1 - dimensional minimization at each step\n   maxloop : Maximum number of loops to attempt to find a solution\n The outputs include\n   lerr :  Returns .true. if it could not find the minimum\n Returns\n   x1   :  Final minimum (all 0 if none found)\n   0 = No miniumum found Arguments Type Intent Optional Attributes Name class(lambda_obj), intent(inout) :: f integer(kind=I4B), intent(in) :: N real(kind=DP), intent(in), dimension(:) :: x0 real(kind=DP), intent(in) :: eps integer(kind=I4B), intent(in) :: maxloop logical, intent(out) :: lerr Return Value real(kind=DP),\n  dimension(:),allocatable Called by proc~~util_minimize_bfgs~~CalledByGraph proc~util_minimize_bfgs util_minimize_bfgs interface~util_minimize_bfgs util_minimize_bfgs interface~util_minimize_bfgs->proc~util_minimize_bfgs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_minimize_bfgs.html"},{"title":"util_append_arr_char_string – swiftest","text":"subroutine util_append_arr_char_string(arr, source, nold, nsrc, lsource_mask) Append a single array of character string type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: arr Destination array character(len=STRMAX), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~util_append_arr_char_string~~CallsGraph proc~util_append_arr_char_string util_append_arr_char_string interface~util_resize~2 util_resize proc~util_append_arr_char_string->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_append_arr_char_string.html"},{"title":"util_append_arr_DP – swiftest","text":"subroutine util_append_arr_DP(arr, source, nold, nsrc, lsource_mask) Append a single array of double precision type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: arr Destination array real(kind=DP), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~util_append_arr_dp~~CallsGraph proc~util_append_arr_dp util_append_arr_DP interface~util_resize~2 util_resize proc~util_append_arr_dp->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_append_arr_dp.html"},{"title":"util_append_arr_DPvec – swiftest","text":"subroutine util_append_arr_DPvec(arr, source, nold, nsrc, lsource_mask) Append a single array of double precision vector type of size (NDIM, n) onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: arr Destination array real(kind=DP), intent(in), dimension(:,:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~util_append_arr_dpvec~~CallsGraph proc~util_append_arr_dpvec util_append_arr_DPvec interface~util_resize~2 util_resize proc~util_append_arr_dpvec->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_append_arr_dpvec.html"},{"title":"util_append_arr_I4B – swiftest","text":"subroutine util_append_arr_I4B(arr, source, nold, nsrc, lsource_mask) Append a single array of integer(I4B) onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~util_append_arr_i4b~~CallsGraph proc~util_append_arr_i4b util_append_arr_I4B interface~util_resize~2 util_resize proc~util_append_arr_i4b->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_append_arr_i4b.html"},{"title":"util_append_arr_info – swiftest","text":"subroutine util_append_arr_info(arr, source, nold, nsrc, lsource_mask) Append a single array of particle information type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: arr Destination array type( swiftest_particle_info ), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~util_append_arr_info~~CallsGraph proc~util_append_arr_info util_append_arr_info interface~util_resize~2 util_resize proc~util_append_arr_info->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_append_arr_info.html"},{"title":"util_append_arr_logical – swiftest","text":"subroutine util_append_arr_logical(arr, source, nold, nsrc, lsource_mask) Append a single array of logical type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: arr Destination array logical, intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~util_append_arr_logical~~CallsGraph proc~util_append_arr_logical util_append_arr_logical interface~util_resize~2 util_resize proc~util_append_arr_logical->interface~util_resize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_append_arr_logical.html"},{"title":"util_append_body – swiftest","text":"module subroutine util_append_body(self, source, lsource_mask) Interface → Append components from one Swiftest body object to another. \n This method will automatically resize the destination body if it is too small Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~util_append_body~~CallsGraph proc~util_append_body util_append_body interface~util_append~2 util_append proc~util_append_body->interface~util_append~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_append_body~~CalledByGraph proc~util_append_body util_append_body interface~util_append_body util_append_body interface~util_append_body->proc~util_append_body proc~util_append_pl util_append_pl proc~util_append_pl->interface~util_append_body proc~util_append_tp util_append_tp proc~util_append_tp->interface~util_append_body interface~util_append_tp util_append_tp interface~util_append_tp->proc~util_append_tp interface~util_append_pl util_append_pl interface~util_append_pl->proc~util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_append_body.html"},{"title":"util_append_encounter – swiftest","text":"module subroutine util_append_encounter(self, source, lsource_mask) Interface → Append components from one Swiftest body object to another. \n This method will automatically resize the destination body if it is too small Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list object class( swiftest_encounter ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~util_append_encounter~~CallsGraph proc~util_append_encounter util_append_encounter interface~util_append~2 util_append proc~util_append_encounter->interface~util_append~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_append_encounter~~CalledByGraph proc~util_append_encounter util_append_encounter interface~util_append_encounter util_append_encounter interface~util_append_encounter->proc~util_append_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_append_encounter.html"},{"title":"util_append_pl – swiftest","text":"module subroutine util_append_pl(self, source, lsource_mask) Interface → Append components from one Swiftest body object to another. \n This method will automatically resize the destination body if it is too small Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~util_append_pl~~CallsGraph proc~util_append_pl util_append_pl interface~util_append_body util_append_body proc~util_append_pl->interface~util_append_body interface~util_append~2 util_append proc~util_append_pl->interface~util_append~2 interface~util_exit util_exit proc~util_append_pl->interface~util_exit proc~util_append_body util_append_body interface~util_append_body->proc~util_append_body proc~util_exit util_exit interface~util_exit->proc~util_exit proc~util_append_body->interface~util_append~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_append_pl~~CalledByGraph proc~util_append_pl util_append_pl interface~util_append_pl util_append_pl interface~util_append_pl->proc~util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_append_pl.html"},{"title":"util_append_tp – swiftest","text":"module subroutine util_append_tp(self, source, lsource_mask) Interface → Append components from one Swiftest body object to another. \n This method will automatically resize the destination body if it is too small Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~util_append_tp~~CallsGraph proc~util_append_tp util_append_tp interface~util_append_body util_append_body proc~util_append_tp->interface~util_append_body interface~util_append~2 util_append proc~util_append_tp->interface~util_append~2 interface~util_exit util_exit proc~util_append_tp->interface~util_exit proc~util_append_body util_append_body interface~util_append_body->proc~util_append_body proc~util_exit util_exit interface~util_exit->proc~util_exit proc~util_append_body->interface~util_append~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_append_tp~~CalledByGraph proc~util_append_tp util_append_tp interface~util_append_tp util_append_tp interface~util_append_tp->proc~util_append_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_append_tp.html"},{"title":"util_get_energy_momentum_system – swiftest","text":"module subroutine util_get_energy_momentum_system(self, param) Interface → Compute total system angular momentum vector and kinetic, potential and total system energy Adapted from David E. Kaufmann Swifter routine symba_energy_eucl.f90 Adapted from Martin Duncan's Swift routine anal_energy.f Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~util_get_energy_momentum_system~~CallsGraph proc~util_get_energy_momentum_system util_get_energy_momentum_system proc~util_get_energy_potential util_get_energy_potential proc~util_get_energy_momentum_system->proc~util_get_energy_potential Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~util_get_energy_momentum_system~~CalledByGraph proc~util_get_energy_momentum_system util_get_energy_momentum_system interface~util_get_energy_momentum_system util_get_energy_momentum_system interface~util_get_energy_momentum_system->proc~util_get_energy_momentum_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/util_get_energy_momentum_system.html"},{"title":"gr_kick_getaccb_ns_body – swiftest","text":"pure module subroutine gr_kick_getaccb_ns_body(self, system, param) Interface → Add relativistic correction acceleration for non-symplectic integrators.\n Based on Quinn et al. (1991) eq. 5 Reference: Quinn, T.R., Tremaine, S., Duncan, M., 1991. A three million year integration of the earth’s orbit. \n       AJ 101, 2287–2305. https://doi.org/10.1086/115850 Adapted from David A. Minton's Swifter routine routine gr_kick_getaccb_ns.f90 Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Called by proc~~gr_kick_getaccb_ns_body~~CalledByGraph proc~gr_kick_getaccb_ns_body gr_kick_getaccb_ns_body interface~gr_kick_getaccb_ns_body gr_kick_getaccb_ns_body interface~gr_kick_getaccb_ns_body->proc~gr_kick_getaccb_ns_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gr_kick_getaccb_ns_body.html"},{"title":"gr_kick_getacch – swiftest","text":"pure module subroutine gr_kick_getacch(mu, x, lmask, n, inv_c2, agr) Interface → Compute relativisitic accelerations of massive bodies\n    Based on Saha & Tremaine (1994) Eq. 28 Adapted from David A. Minton's Swifter routine routine gr_whm_kick_getacch.f90 Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:,:) :: x Position vectors logical, intent(in), dimension(:) :: lmask Logical mask indicating which bodies to compute integer(kind=I4B), intent(in) :: n Total number of bodies real(kind=DP), intent(in) :: inv_c2 Inverse speed of light squared: 1 / c**2 real(kind=DP), intent(out), dimension(:,:) :: agr Accelerations Called by proc~~gr_kick_getacch~~CalledByGraph proc~gr_kick_getacch gr_kick_getacch interface~gr_kick_getacch gr_kick_getacch interface~gr_kick_getacch->proc~gr_kick_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gr_kick_getacch.html"},{"title":"gr_p4_pos_kick – swiftest","text":"pure module subroutine gr_p4_pos_kick(param, x, v, dt) Interface → Position kick due to p**4 term in the post-Newtonian correction\n    Based on Saha & Tremaine (1994) Eq. 28 Reference:\n    Saha, P., Tremaine, S., 1994. Long-term planetary integration with individual time steps. \n       AJ 108, 1962–1969. https://doi.org/10.1086/117210 Adapted from David A. Minton's Swifter routine gr_whm_p4.f90 Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(inout), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(in) :: dt Step size Called by proc~~gr_p4_pos_kick~~CalledByGraph proc~gr_p4_pos_kick gr_p4_pos_kick interface~gr_p4_pos_kick gr_p4_pos_kick interface~gr_p4_pos_kick->proc~gr_p4_pos_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gr_p4_pos_kick.html"},{"title":"gr_pseudovel2vel – swiftest","text":"pure module subroutine gr_pseudovel2vel(param, mu, xh, pv, vh) Interface → Converts the relativistic pseudovelocity back into a veliocentric velocity\n    Based on Saha & Tremaine (1994) Eq. 32 Reference:\n    Saha, P., Tremaine, S., 1994. Long-term planetary integration with individual time steps. \n       AJ 108, 1962–1969. https://doi.org/10.1086/117210 Adapted from David A. Minton's Swifter routine gr_pseudovel2vel.f90 Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real(kind=DP), intent(in), dimension(:) :: xh Heliocentric position vector real(kind=DP), intent(in), dimension(:) :: pv Pseudovelocity velocity vector - see Saha & Tremain (1994), eq. (32) real(kind=DP), intent(out), dimension(:) :: vh Heliocentric velocity vector Called by proc~~gr_pseudovel2vel~~CalledByGraph proc~gr_pseudovel2vel gr_pseudovel2vel interface~gr_pseudovel2vel gr_pseudovel2vel interface~gr_pseudovel2vel->proc~gr_pseudovel2vel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gr_pseudovel2vel.html"},{"title":"gr_pv2vh_body – swiftest","text":"pure module subroutine gr_pv2vh_body(self, param) Interface → Wrapper function that converts from pseudovelocity to heliocentric velocity for swiftest bodies Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Called by proc~~gr_pv2vh_body~~CalledByGraph proc~gr_pv2vh_body gr_pv2vh_body interface~gr_pv2vh_body gr_pv2vh_body interface~gr_pv2vh_body->proc~gr_pv2vh_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gr_pv2vh_body.html"},{"title":"gr_vel2pseudovel – swiftest","text":"pure module subroutine gr_vel2pseudovel(param, mu, xh, vh, pv) Interface → Converts the heliocentric velocity into a pseudovelocity with relativistic corrections. \n Uses Newton-Raphson method with direct inversion of the Jacobian (yeah, it's slow, but \n this is only done once per run). Reference:\n    Saha, P., Tremaine, S., 1994. Long-term planetary integration with individual time steps. \n       AJ 108, 1962–1969. https://doi.org/10.1086/117210 Adapted from David A. Minton's Swifter routine gr_vel2pseudovel.f90 Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real(kind=DP), intent(in), dimension(:) :: xh Heliocentric position vector real(kind=DP), intent(in), dimension(:) :: vh Heliocentric velocity vector real(kind=DP), intent(out), dimension(:) :: pv Pseudovelocity vector - see Saha & Tremain (1994), eq. (32) Called by proc~~gr_vel2pseudovel~~CalledByGraph proc~gr_vel2pseudovel gr_vel2pseudovel interface~gr_vel2pseudovel gr_vel2pseudovel interface~gr_vel2pseudovel->proc~gr_vel2pseudovel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gr_vel2pseudovel.html"},{"title":"gr_vh2pv_body – swiftest","text":"pure module subroutine gr_vh2pv_body(self, param) Interface → Wrapper function that converts from heliocentric velocity to pseudovelocity for Swiftest bodies Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Called by proc~~gr_vh2pv_body~~CalledByGraph proc~gr_vh2pv_body gr_vh2pv_body interface~gr_vh2pv_body gr_vh2pv_body interface~gr_vh2pv_body->proc~gr_vh2pv_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gr_vh2pv_body.html"},{"title":"discard_system – swiftest","text":"module subroutine discard_system(self, param) Interface → Calls the discard methods for each body class and then the write method if any discards were detected Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Called by proc~~discard_system~~CalledByGraph proc~discard_system discard_system interface~discard_system discard_system interface~discard_system->proc~discard_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/discard_system.html"},{"title":"discard_pl – swiftest","text":"module subroutine discard_pl(self, system, param) Interface → Placeholder method for discarding massive bodies. This method does nothing except to ensure that the discard flag is set to false. \n  This method is intended to be overridden by more advanced integrators. Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameter Called by proc~~discard_pl~~CalledByGraph proc~discard_pl discard_pl interface~discard_pl discard_pl interface~discard_pl->proc~discard_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/discard_pl.html"},{"title":"discard_tp – swiftest","text":"module subroutine discard_tp(self, system, param) Interface → Check to see if particles should be discarded based on their positions relative to the massive bodies Adapted from David E. Kaufmann's Swifter routine: discard.f90\n Adapted from Hal Levison's Swift routine discard. Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameter Called by proc~~discard_tp~~CalledByGraph proc~discard_tp discard_tp interface~discard_tp discard_tp interface~discard_tp->proc~discard_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/discard_tp.html"},{"title":"helio_step_system – swiftest","text":"module subroutine helio_step_system(self, param, t, dt) Interface → Step massive bodies and and active test particles ahead in heliocentric coordinates. Currently there's no difference between this and the WHM system stepper, so this is just\n a wrapper function to keep the method calls consistent for inherited types. Adapted from Hal Levison's Swift routine step_kdk.f\n Adapted from David E. Kaufmann's Swifter routine helio_step.f90 Arguments Type Intent Optional Attributes Name class( helio_nbody_system ), intent(inout) :: self Helio nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize Calls proc~~helio_step_system~~CallsGraph proc~helio_step_system helio_step_system whm_step_system whm_step_system proc~helio_step_system->whm_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helio_step_system~~CalledByGraph proc~helio_step_system helio_step_system interface~helio_step_system helio_step_system interface~helio_step_system->proc~helio_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_step_system.html"},{"title":"helio_step_pl – swiftest","text":"module subroutine helio_step_pl(self, system, param, t, dt) Interface → Step massive bodies ahead Democratic Heliocentric method Adapted from David E. Kaufmann's Swifter helio_step_pl.f90\n Adapted from Hal Levison's Swift routine helio_step_pl.f Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nboody system class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize Called by proc~~helio_step_pl~~CalledByGraph proc~helio_step_pl helio_step_pl interface~helio_step_pl helio_step_pl interface~helio_step_pl->proc~helio_step_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_step_pl.html"},{"title":"helio_step_tp – swiftest","text":"module subroutine helio_step_tp(self, system, param, t, dt) Interface → Step active test particles ahead using Democratic Heliocentric method Adapted from David E. Kaufmann's Swifter routine helio_step_tp.f90\n Adapted from Hal Levison's Swift routine helio_step_tp.f Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nboody system class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize Called by proc~~helio_step_tp~~CalledByGraph proc~helio_step_tp helio_step_tp interface~helio_step_tp helio_step_tp interface~helio_step_tp->proc~helio_step_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_step_tp.html"},{"title":"helio_setup_initialize_system – swiftest","text":"module subroutine helio_setup_initialize_system(self, param) Interface → Initialize a Helio nbody system from files, converting all heliocentric quantities to barycentric. Arguments Type Intent Optional Attributes Name class( helio_nbody_system ), intent(inout) :: self Helio nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters Calls proc~~helio_setup_initialize_system~~CallsGraph proc~helio_setup_initialize_system helio_setup_initialize_system whm_setup_initialize_system whm_setup_initialize_system proc~helio_setup_initialize_system->whm_setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helio_setup_initialize_system~~CalledByGraph proc~helio_setup_initialize_system helio_setup_initialize_system interface~helio_setup_initialize_system helio_setup_initialize_system interface~helio_setup_initialize_system->proc~helio_setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_setup_initialize_system.html"},{"title":"helio_gr_kick_getacch_pl – swiftest","text":"pure module subroutine helio_gr_kick_getacch_pl(self, param) Interface → Compute relativisitic accelerations of massive bodies\n    Based on Saha & Tremaine (1994) Eq. 28 Adapted from David A. Minton's Swifter routine routine gr_whm_kick_getacch.f90 Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters Calls proc~~helio_gr_kick_getacch_pl~~CallsGraph proc~helio_gr_kick_getacch_pl helio_gr_kick_getacch_pl gr_kick_getacch gr_kick_getacch proc~helio_gr_kick_getacch_pl->gr_kick_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helio_gr_kick_getacch_pl~~CalledByGraph proc~helio_gr_kick_getacch_pl helio_gr_kick_getacch_pl interface~helio_gr_kick_getacch_pl helio_gr_kick_getacch_pl interface~helio_gr_kick_getacch_pl->proc~helio_gr_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_gr_kick_getacch_pl.html"},{"title":"helio_gr_kick_getacch_tp – swiftest","text":"pure module subroutine helio_gr_kick_getacch_tp(self, param) Interface → Compute relativisitic accelerations of test particles\n    Based on Saha & Tremaine (1994) Eq. 28 Adapted from David A. Minton's Swifter routine routine gr_helio_kick_getacch.f90 Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters Calls proc~~helio_gr_kick_getacch_tp~~CallsGraph proc~helio_gr_kick_getacch_tp helio_gr_kick_getacch_tp gr_kick_getacch gr_kick_getacch proc~helio_gr_kick_getacch_tp->gr_kick_getacch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helio_gr_kick_getacch_tp~~CalledByGraph proc~helio_gr_kick_getacch_tp helio_gr_kick_getacch_tp interface~helio_gr_kick_getacch_tp helio_gr_kick_getacch_tp interface~helio_gr_kick_getacch_tp->proc~helio_gr_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_gr_kick_getacch_tp.html"},{"title":"helio_gr_p4_pl – swiftest","text":"pure module subroutine helio_gr_p4_pl(self, param, dt) Interface → Position kick to massive bodies due to p**4 term in the post-Newtonian correction\n    Based on Saha & Tremaine (1994) Eq. 28 Adapted from David A. Minton's Swifter routine routine gr_helio_p4.f90 Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size Calls proc~~helio_gr_p4_pl~~CallsGraph proc~helio_gr_p4_pl helio_gr_p4_pl gr_p4_pos_kick gr_p4_pos_kick proc~helio_gr_p4_pl->gr_p4_pos_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helio_gr_p4_pl~~CalledByGraph proc~helio_gr_p4_pl helio_gr_p4_pl interface~helio_gr_p4_pl helio_gr_p4_pl interface~helio_gr_p4_pl->proc~helio_gr_p4_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_gr_p4_pl.html"},{"title":"helio_gr_p4_tp – swiftest","text":"pure module subroutine helio_gr_p4_tp(self, param, dt) Interface → Position kick to test particles due to p**4 term in the post-Newtonian correction\n    Based on Saha & Tremaine (1994) Eq. 28 Adapted from David A. Minton's Swifter routine routine gr_helio_p4.f90 Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size Calls proc~~helio_gr_p4_tp~~CallsGraph proc~helio_gr_p4_tp helio_gr_p4_tp gr_p4_pos_kick gr_p4_pos_kick proc~helio_gr_p4_tp->gr_p4_pos_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helio_gr_p4_tp~~CalledByGraph proc~helio_gr_p4_tp helio_gr_p4_tp interface~helio_gr_p4_tp helio_gr_p4_tp interface~helio_gr_p4_tp->proc~helio_gr_p4_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_gr_p4_tp.html"},{"title":"helio_kick_getacch_pl – swiftest","text":"module subroutine helio_kick_getacch_pl(self, system, param, t, lbeg) Interface → Compute heliocentric accelerations of massive bodies Adapted from David E. Kaufmann's Swifter routine helio_kick_getacch.f90\n Adapted from Hal Levison's Swift routine helio_kick_getacch.f Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step Called by proc~~helio_kick_getacch_pl~~CalledByGraph proc~helio_kick_getacch_pl helio_kick_getacch_pl interface~helio_kick_getacch_pl helio_kick_getacch_pl interface~helio_kick_getacch_pl->proc~helio_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_kick_getacch_pl.html"},{"title":"helio_kick_getacch_tp – swiftest","text":"module subroutine helio_kick_getacch_tp(self, system, param, t, lbeg) Interface → Compute heliocentric accelerations of test particles Adapted from David E. Kaufmann's Swifter routine helio_kick_getacch_tp.f90\n Adapted from Hal Levison's Swift routine helio_kick_getacch_tp.f Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step Called by proc~~helio_kick_getacch_tp~~CalledByGraph proc~helio_kick_getacch_tp helio_kick_getacch_tp interface~helio_kick_getacch_tp helio_kick_getacch_tp interface~helio_kick_getacch_tp->proc~helio_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_kick_getacch_tp.html"},{"title":"helio_kick_vb_pl – swiftest","text":"module subroutine helio_kick_vb_pl(self, system, param, t, dt, lbeg) Interface → Kick barycentric velocities of bodies Adapted from Martin Duncan and Hal Levison's Swift routine kickvh.f \n Adapted from David E. Kaufmann's Swifter routine helio_kick_vb.f90 Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. Called by proc~~helio_kick_vb_pl~~CalledByGraph proc~helio_kick_vb_pl helio_kick_vb_pl interface~helio_kick_vb_pl helio_kick_vb_pl interface~helio_kick_vb_pl->proc~helio_kick_vb_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_kick_vb_pl.html"},{"title":"helio_kick_vb_tp – swiftest","text":"module subroutine helio_kick_vb_tp(self, system, param, t, dt, lbeg) Interface → Kick barycentric velocities of bodies Adapted from Martin Duncan and Hal Levison's Swift routine kickvh_tp.f\n Adapted from David E. Kaufmann's Swifter routine helio_kick_vb_tp.f90 Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. Called by proc~~helio_kick_vb_tp~~CalledByGraph proc~helio_kick_vb_tp helio_kick_vb_tp interface~helio_kick_vb_tp helio_kick_vb_tp interface~helio_kick_vb_tp->proc~helio_kick_vb_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_kick_vb_tp.html"},{"title":"helio_drift_body – swiftest","text":"module subroutine helio_drift_body(self, system, param, dt) Interface → Loop through bodies and call Danby drift routine on democratic heliocentric coordinates Adapted from David E. Kaufmann's Swifter routine helio_drift.f90\n Adapted from Hal Levison's Swift routine drift.f Arguments Type Intent Optional Attributes Name class(swiftest_body), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize Calls proc~~helio_drift_body~~CallsGraph proc~helio_drift_body helio_drift_body drift_all drift_all proc~helio_drift_body->drift_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helio_drift_body~~CalledByGraph proc~helio_drift_body helio_drift_body interface~helio_drift_body helio_drift_body interface~helio_drift_body->proc~helio_drift_body proc~helio_drift_pl helio_drift_pl proc~helio_drift_pl->interface~helio_drift_body proc~helio_drift_tp helio_drift_tp proc~helio_drift_tp->interface~helio_drift_body interface~helio_drift_pl helio_drift_pl interface~helio_drift_pl->proc~helio_drift_pl interface~helio_drift_tp helio_drift_tp interface~helio_drift_tp->proc~helio_drift_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_drift_body.html"},{"title":"helio_drift_pl – swiftest","text":"module subroutine helio_drift_pl(self, system, param, dt) Interface → Wrapper function used to call the body drift routine from a helio_pl structure Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize Calls proc~~helio_drift_pl~~CallsGraph proc~helio_drift_pl helio_drift_pl interface~helio_drift_body helio_drift_body proc~helio_drift_pl->interface~helio_drift_body proc~helio_drift_body helio_drift_body interface~helio_drift_body->proc~helio_drift_body drift_all drift_all proc~helio_drift_body->drift_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helio_drift_pl~~CalledByGraph proc~helio_drift_pl helio_drift_pl interface~helio_drift_pl helio_drift_pl interface~helio_drift_pl->proc~helio_drift_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_drift_pl.html"},{"title":"helio_drift_tp – swiftest","text":"module subroutine helio_drift_tp(self, system, param, dt) Interface → Wrapper function used to call the body drift routine from a helio_pl structure Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize Calls proc~~helio_drift_tp~~CallsGraph proc~helio_drift_tp helio_drift_tp interface~helio_drift_body helio_drift_body proc~helio_drift_tp->interface~helio_drift_body proc~helio_drift_body helio_drift_body interface~helio_drift_body->proc~helio_drift_body drift_all drift_all proc~helio_drift_body->drift_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~helio_drift_tp~~CalledByGraph proc~helio_drift_tp helio_drift_tp interface~helio_drift_tp helio_drift_tp interface~helio_drift_tp->proc~helio_drift_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_drift_tp.html"},{"title":"helio_drift_linear_pl – swiftest","text":"module subroutine helio_drift_linear_pl(self, cb, dt, lbeg) Interface → Perform linear drift of massive bodies due to barycentric momentum of Sun Adapted from David E. Kaufmann's Swifter routine helio_lindrift.f90\n Adapted from Hal Levison's Swift routine helio_lindrift.f Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( helio_cb ), intent(inout) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step Called by proc~~helio_drift_linear_pl~~CalledByGraph proc~helio_drift_linear_pl helio_drift_linear_pl interface~helio_drift_linear_pl helio_drift_linear_pl interface~helio_drift_linear_pl->proc~helio_drift_linear_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_drift_linear_pl.html"},{"title":"helio_drift_linear_tp – swiftest","text":"module subroutine helio_drift_linear_tp(self, cb, dt, lbeg) Interface → Perform linear drift of test particles due to barycentric momentum of Sun\n New vectorized version included Adapted from David E. Kaufmann's Swifter routine helio_lindrift_tp.f90\n Adapted from Hal Levison's Swift routine helio_lindrift_tp.f Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particleb object class( helio_cb ), intent(in) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step Called by proc~~helio_drift_linear_tp~~CalledByGraph proc~helio_drift_linear_tp helio_drift_linear_tp interface~helio_drift_linear_tp helio_drift_linear_tp interface~helio_drift_linear_tp->proc~helio_drift_linear_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/helio_drift_linear_tp.html"},{"title":"io_get_args – swiftest","text":"module function io_get_args(integrator, param_file_name) result(ierr) Interface → Reads in the name of the parameter file from command line arguments. Arguments Type Intent Optional Attributes Name integer(kind=I4B) :: integrator Symbolic code of the requested integrator character(len=:), allocatable :: param_file_name Name of the input parameters file Return Value integer(kind=I4B) I/O error code Calls proc~~io_get_args~~CallsGraph proc~io_get_args io_get_args interface~util_version util_version proc~io_get_args->interface~util_version interface~util_exit util_exit proc~io_get_args->interface~util_exit interface~io_toupper io_toupper proc~io_get_args->interface~io_toupper proc~util_version util_version interface~util_version->proc~util_version proc~util_exit util_exit interface~util_exit->proc~util_exit proc~io_toupper io_toupper interface~io_toupper->proc~io_toupper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_get_args~~CalledByGraph proc~io_get_args io_get_args interface~io_get_args io_get_args interface~io_get_args->proc~io_get_args Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_get_args.html"},{"title":"io_get_old_t_final_system – swiftest","text":"module function io_get_old_t_final_system(self, param) result(old_t_final) Interface → Validates the dump file to check whether the dump file initial conditions duplicate the last frame of the binary output. Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self class( swiftest_parameters ), intent(in) :: param Return Value real(kind=DP) Calls proc~~io_get_old_t_final_system~~CallsGraph proc~io_get_old_t_final_system io_get_old_t_final_system interface~util_exit util_exit proc~io_get_old_t_final_system->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_get_old_t_final_system~~CalledByGraph proc~io_get_old_t_final_system io_get_old_t_final_system interface~io_get_old_t_final_system io_get_old_t_final_system interface~io_get_old_t_final_system->proc~io_get_old_t_final_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_get_old_t_final_system.html"},{"title":"io_get_token – swiftest","text":"module function io_get_token(buffer, ifirst, ilast, ierr) result(token) Interface → Retrieves a character token from an input string. Here a token is defined as any set of contiguous non-blank characters not \n beginning with or containing \"!\". If \"!\" is present, any remaining part of the buffer including the \"!\" is ignored Adapted from David E. Kaufmann's Swifter routine io_get_token.f90\n Bad input\n No valid token Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: buffer Input string buffer integer(kind=I4B), intent(inout) :: ifirst Index of the buffer at which to start the search for a token integer(kind=I4B), intent(out) :: ilast Index of the buffer at the end of the returned token integer(kind=I4B), intent(out) :: ierr Error code Return Value character(len=:),\n  allocatable Returned token string Called by proc~~io_get_token~~CalledByGraph proc~io_get_token io_get_token interface~io_get_token io_get_token interface~io_get_token->proc~io_get_token proc~io_param_reader io_param_reader proc~io_param_reader->interface~io_get_token interface~io_param_reader io_param_reader interface~io_param_reader->proc~io_param_reader Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_get_token.html"},{"title":"io_read_frame_body – swiftest","text":"module function io_read_frame_body(self, iu, param) result(ierr) Interface → Reads a frame of output of either test particle or massive body data from a binary output file Adapted from David E. Kaufmann's Swifter routine  io_read_frame.f90\n Adapted from Hal Levison's Swift routine io_read_frame.F Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful Calls proc~~io_read_frame_body~~CallsGraph proc~io_read_frame_body io_read_frame_body interface~util_exit util_exit proc~io_read_frame_body->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_read_frame_body~~CalledByGraph proc~io_read_frame_body io_read_frame_body interface~io_read_frame_body io_read_frame_body interface~io_read_frame_body->proc~io_read_frame_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_frame_body.html"},{"title":"io_read_frame_cb – swiftest","text":"module function io_read_frame_cb(self, iu, param) result(ierr) Interface → Reads a frame of output of central body data to the binary output file Adapted from David E. Kaufmann's Swifter routine  io_read_frame.f90\n Adapted from Hal Levison's Swift routine io_read_frame.F Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful Calls proc~~io_read_frame_cb~~CallsGraph proc~io_read_frame_cb io_read_frame_cb interface~util_exit util_exit proc~io_read_frame_cb->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_read_frame_cb~~CalledByGraph proc~io_read_frame_cb io_read_frame_cb interface~io_read_frame_cb io_read_frame_cb interface~io_read_frame_cb->proc~io_read_frame_cb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_frame_cb.html"},{"title":"io_read_frame_system – swiftest","text":"module function io_read_frame_system(self, iu, param) result(ierr) Interface → Read a frame (header plus records for each massive body and active test particle) from a output binary file Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful Calls proc~~io_read_frame_system~~CallsGraph proc~io_read_frame_system io_read_frame_system proc~io_read_hdr io_read_hdr proc~io_read_frame_system->proc~io_read_hdr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_read_frame_system~~CalledByGraph proc~io_read_frame_system io_read_frame_system interface~io_read_frame_system io_read_frame_system interface~io_read_frame_system->proc~io_read_frame_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_frame_system.html"},{"title":"io_conservation_report – swiftest","text":"module subroutine io_conservation_report(self, param, lterminal) Interface → Reports the current state of energy, mass, and angular momentum conservation in a run Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Input colleciton of user-defined parameters logical, intent(in) :: lterminal Indicates whether to output information to the terminal screen Calls proc~~io_conservation_report~~CallsGraph proc~io_conservation_report io_conservation_report interface~util_exit util_exit proc~io_conservation_report->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_conservation_report~~CalledByGraph proc~io_conservation_report io_conservation_report interface~io_conservation_report io_conservation_report interface~io_conservation_report->proc~io_conservation_report Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_conservation_report.html"},{"title":"io_dump_param – swiftest","text":"module subroutine io_dump_param(self, param_file_name) Interface → Dump integration parameters to file Adapted from David E. Kaufmann's Swifter routine io_dump_param.f90\n Adapted from Martin Duncan's Swift routine io_dump_param.f\n todo: Currently this procedure does not work in user-defined derived-type input mode \n    due to compiler incompatabilities Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Output collection of parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in) Calls proc~~io_dump_param~~CallsGraph proc~io_dump_param io_dump_param interface~util_exit util_exit proc~io_dump_param->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_dump_param~~CalledByGraph proc~io_dump_param io_dump_param interface~io_dump_param io_dump_param interface~io_dump_param->proc~io_dump_param Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_dump_param.html"},{"title":"io_dump_particle_info – swiftest","text":"module subroutine io_dump_particle_info(self, iu) Interface → Reads in particle information object information from an open file unformatted file Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(in) :: self Particle metadata information object integer(kind=I4B), intent(in) :: iu Open file unit number Calls proc~~io_dump_particle_info~~CallsGraph proc~io_dump_particle_info io_dump_particle_info interface~util_exit util_exit proc~io_dump_particle_info->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_dump_particle_info~~CalledByGraph proc~io_dump_particle_info io_dump_particle_info interface~io_dump_particle_info io_dump_particle_info interface~io_dump_particle_info->proc~io_dump_particle_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_dump_particle_info.html"},{"title":"io_dump_particle_info_base – swiftest","text":"module subroutine io_dump_particle_info_base(self, param, idx) Interface → Dumps the particle information data to a file. \n Pass a list of array indices for test particles (tpidx) and/or massive bodies (plidx) to append Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file Calls proc~~io_dump_particle_info_base~~CallsGraph proc~io_dump_particle_info_base io_dump_particle_info_base interface~util_exit util_exit proc~io_dump_particle_info_base->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_dump_particle_info_base~~CalledByGraph proc~io_dump_particle_info_base io_dump_particle_info_base interface~io_dump_particle_info_base io_dump_particle_info_base interface~io_dump_particle_info_base->proc~io_dump_particle_info_base Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_dump_particle_info_base.html"},{"title":"io_dump_base – swiftest","text":"module subroutine io_dump_base(self, param) Interface → Dump massive body data to files Adapted from David E. Kaufmann's Swifter routine: io_dump_pl.f90 and io_dump_tp.f90\n Adapted from Hal Levison's Swift routine io_dump_pl.f and io_dump_tp.f Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Calls proc~~io_dump_base~~CallsGraph proc~io_dump_base io_dump_base interface~util_exit util_exit proc~io_dump_base->interface~util_exit interface~io_write_frame_cb io_write_frame_cb proc~io_dump_base->interface~io_write_frame_cb interface~io_write_frame_body io_write_frame_body proc~io_dump_base->interface~io_write_frame_body proc~util_exit util_exit interface~util_exit->proc~util_exit proc~io_write_frame_cb io_write_frame_cb interface~io_write_frame_cb->proc~io_write_frame_cb proc~io_write_frame_body io_write_frame_body interface~io_write_frame_body->proc~io_write_frame_body proc~io_write_frame_body->interface~util_exit proc~io_write_frame_cb->interface~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_dump_base~~CalledByGraph proc~io_dump_base io_dump_base interface~io_dump_base io_dump_base interface~io_dump_base->proc~io_dump_base Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_dump_base.html"},{"title":"io_dump_system – swiftest","text":"module subroutine io_dump_system(self, param) Interface → Dumps the state of the system to files in case the simulation is interrupted.\n As a safety mechanism, there are two dump files that are written in alternating order\n so that if a dump file gets corrupted during writing, the user can restart from the older one. Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Calls proc~~io_dump_system~~CallsGraph proc~io_dump_system io_dump_system dump_tp_file dump_tp_file proc~io_dump_system->dump_tp_file dump_param_file dump_param_file proc~io_dump_system->dump_param_file dump_pl_file dump_pl_file proc~io_dump_system->dump_pl_file dump_cb_file dump_cb_file proc~io_dump_system->dump_cb_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_dump_system~~CalledByGraph proc~io_dump_system io_dump_system interface~io_dump_system io_dump_system interface~io_dump_system->proc~io_dump_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_dump_system.html"},{"title":"io_param_reader – swiftest","text":"module subroutine io_param_reader(self, unit, iotype, v_list, iostat, iomsg) Interface → Read in parameters for the integration\n Currently this procedure does not work in user-defined derived-type input mode \n    e.g. read(unit,'(DT)') param \n as the newline characters are ignored in the input file when compiled in ifort. Adapted from David E. Kaufmann's Swifter routine io_init_param.f90\n Adapted from Martin Duncan's Swift routine io_init_param.f\n Do basic sanity checks on the input values Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Collection of parameters integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) The first element passes the integrator code to the reader integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 Calls proc~~io_param_reader~~CallsGraph proc~io_param_reader io_param_reader interface~io_get_token io_get_token proc~io_param_reader->interface~io_get_token interface~io_toupper io_toupper proc~io_param_reader->interface~io_toupper proc~io_get_token io_get_token interface~io_get_token->proc~io_get_token proc~io_toupper io_toupper interface~io_toupper->proc~io_toupper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_param_reader~~CalledByGraph proc~io_param_reader io_param_reader interface~io_param_reader io_param_reader interface~io_param_reader->proc~io_param_reader Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_param_reader.html"},{"title":"io_param_writer – swiftest","text":"module subroutine io_param_writer(self, unit, iotype, v_list, iostat, iomsg) Interface → Dump integration parameters to file Adapted from David E. Kaufmann's Swifter routine io_dump_param.f90\n Adapted from Martin Duncan's Swift routine io_dump_param.f Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Collection of parameters integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) Not used in this procedure integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 Called by proc~~io_param_writer~~CalledByGraph proc~io_param_writer io_param_writer interface~io_param_writer io_param_writer interface~io_param_writer->proc~io_param_writer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_param_writer.html"},{"title":"io_read_in_body – swiftest","text":"module subroutine io_read_in_body(self, param) Interface → Read in either test particle or massive body data Adapted from David E. Kaufmann's Swifter routine swiftest_init_pl.f90 and swiftest_init_tp.f90\n Adapted from Martin Duncan's Swift routine swiftest_init_pl.f and swiftest_init_tp.f Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Called by proc~~io_read_in_body~~CalledByGraph proc~io_read_in_body io_read_in_body interface~io_read_in_body io_read_in_body interface~io_read_in_body->proc~io_read_in_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_in_body.html"},{"title":"io_read_in_cb – swiftest","text":"module subroutine io_read_in_cb(self, param) Interface → Reads in central body data Adapted from David E. Kaufmann's Swifter routine swiftest_init_pl.f90\n Adapted from Martin Duncan's Swift routine swiftest_init_pl.f Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self class( swiftest_parameters ), intent(inout) :: param Calls proc~~io_read_in_cb~~CallsGraph proc~io_read_in_cb io_read_in_cb interface~util_exit util_exit proc~io_read_in_cb->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_read_in_cb~~CalledByGraph proc~io_read_in_cb io_read_in_cb interface~io_read_in_cb io_read_in_cb interface~io_read_in_cb->proc~io_read_in_cb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_in_cb.html"},{"title":"io_read_in_param – swiftest","text":"module subroutine io_read_in_param(self, param_file_name) Interface → Read in parameters for the integration Adapted from David E. Kaufmann's Swifter routine io_init_param.f90\n Adapted from Martin Duncan's Swift routine io_init_param.f\n todo: Currently this procedure does not work in user-defined derived-type input mode \n    as the newline characters are ignored in the input file when compiled in ifort. Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Current run configuration parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in) Calls proc~~io_read_in_param~~CallsGraph proc~io_read_in_param io_read_in_param interface~util_exit util_exit proc~io_read_in_param->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_read_in_param~~CalledByGraph proc~io_read_in_param io_read_in_param interface~io_read_in_param io_read_in_param interface~io_read_in_param->proc~io_read_in_param Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_in_param.html"},{"title":"io_read_in_particle_info – swiftest","text":"module subroutine io_read_in_particle_info(self, iu) Interface → Reads in particle information object information from an open file unformatted file Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(inout) :: self Particle metadata information object integer(kind=I4B), intent(in) :: iu Open file unit number Calls proc~~io_read_in_particle_info~~CallsGraph proc~io_read_in_particle_info io_read_in_particle_info interface~util_exit util_exit proc~io_read_in_particle_info->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_read_in_particle_info~~CalledByGraph proc~io_read_in_particle_info io_read_in_particle_info interface~io_read_in_particle_info io_read_in_particle_info interface~io_read_in_particle_info->proc~io_read_in_particle_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_in_particle_info.html"},{"title":"io_read_particle_info_system – swiftest","text":"module subroutine io_read_particle_info_system(self, param) Interface → Reads an old particle information file for a restartd run Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Calls proc~~io_read_particle_info_system~~CallsGraph proc~io_read_particle_info_system io_read_particle_info_system interface~util_exit util_exit proc~io_read_particle_info_system->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_read_particle_info_system~~CalledByGraph proc~io_read_particle_info_system io_read_particle_info_system interface~io_read_particle_info_system io_read_particle_info_system interface~io_read_particle_info_system->proc~io_read_particle_info_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_read_particle_info_system.html"},{"title":"io_toupper – swiftest","text":"module subroutine io_toupper(string) Interface → Convert string to uppercase Adapted from David E. Kaufmann's Swifter routine: util_toupper.f90 Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string String to make upper case Called by proc~~io_toupper~~CalledByGraph proc~io_toupper io_toupper interface~io_toupper io_toupper interface~io_toupper->proc~io_toupper proc~io_get_args io_get_args proc~io_get_args->interface~io_toupper proc~io_param_reader io_param_reader proc~io_param_reader->interface~io_toupper interface~io_get_args io_get_args interface~io_get_args->proc~io_get_args interface~io_param_reader io_param_reader interface~io_param_reader->proc~io_param_reader Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_toupper.html"},{"title":"io_write_discard – swiftest","text":"module subroutine io_write_discard(self, param) Interface → Write out information about discarded test particle Adapted from David E. Kaufmann's Swifter routine  io_discard_write.f90\n Adapted from Hal Levison's Swift routine io_discard_write.f Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Calls proc~~io_write_discard~~CallsGraph proc~io_write_discard io_write_discard interface~util_exit util_exit proc~io_write_discard->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_write_discard~~CalledByGraph proc~io_write_discard io_write_discard interface~io_write_discard io_write_discard interface~io_write_discard->proc~io_write_discard Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_write_discard.html"},{"title":"io_write_encounter – swiftest","text":"module subroutine io_write_encounter(self, pl, encbody, param) Interface → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(in) :: self Swiftest encounter list object class( swiftest_pl ), intent(in) :: pl Swiftest massive body object class( swiftest_body ), intent(in) :: encbody Encountering body - Swiftest generic body object (pl or tp) class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~io_write_encounter~~CallsGraph proc~io_write_encounter io_write_encounter ind1 ind1 proc~io_write_encounter->ind1 interface~util_exit util_exit proc~io_write_encounter->interface~util_exit ind2 ind2 proc~io_write_encounter->ind2 proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_write_encounter~~CalledByGraph proc~io_write_encounter io_write_encounter interface~io_write_encounter io_write_encounter interface~io_write_encounter->proc~io_write_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_write_encounter.html"},{"title":"io_write_frame_body – swiftest","text":"module subroutine io_write_frame_body(self, iu, param) Interface → Write a frame of output of either test particle or massive body data to the binary output file\n    Note: If outputting to orbital elements, but sure that the conversion is done prior to calling this method Adapted from David E. Kaufmann's Swifter routine  io_write_frame.f90\n Adapted from Hal Levison's Swift routine io_write_frame.F Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest particle object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~io_write_frame_body~~CallsGraph proc~io_write_frame_body io_write_frame_body interface~util_exit util_exit proc~io_write_frame_body->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_write_frame_body~~CalledByGraph proc~io_write_frame_body io_write_frame_body interface~io_write_frame_body io_write_frame_body interface~io_write_frame_body->proc~io_write_frame_body proc~io_dump_base io_dump_base proc~io_dump_base->interface~io_write_frame_body interface~io_dump_base io_dump_base interface~io_dump_base->proc~io_dump_base Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_write_frame_body.html"},{"title":"io_write_frame_cb – swiftest","text":"module subroutine io_write_frame_cb(self, iu, param) Interface → Write a frame of output of central body data to the binary output file Adapted from David E. Kaufmann's Swifter routine  io_write_frame.f90\n Adapted from Hal Levison's Swift routine io_write_frame.F Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~io_write_frame_cb~~CallsGraph proc~io_write_frame_cb io_write_frame_cb interface~util_exit util_exit proc~io_write_frame_cb->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_write_frame_cb~~CalledByGraph proc~io_write_frame_cb io_write_frame_cb interface~io_write_frame_cb io_write_frame_cb interface~io_write_frame_cb->proc~io_write_frame_cb proc~io_dump_base io_dump_base proc~io_dump_base->interface~io_write_frame_cb interface~io_dump_base io_dump_base interface~io_dump_base->proc~io_dump_base Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_write_frame_cb.html"},{"title":"io_write_frame_encounter – swiftest","text":"module subroutine io_write_frame_encounter(iu, t, id1, id2, Gmass1, Gmass2, radius1, radius2, xh1, xh2, vh1, vh2) Interface → Write a single frame of close encounter data to output binary files Adapted from David E. Kaufmann's Swifter routine: io_write_encounter.f90\n Adapted from Hal Levison's Swift routine io_write_encounter.f Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu Open file unit number real(kind=DP), intent(in) :: t Time of encounter integer(kind=I4B), intent(in) :: id1 ids of the two encountering bodies integer(kind=I4B), intent(in) :: id2 ids of the two encountering bodies real(kind=DP), intent(in) :: Gmass1 G*mass of the two encountering bodies real(kind=DP), intent(in) :: Gmass2 G*mass of the two encountering bodies real(kind=DP), intent(in) :: radius1 Radii of the two encountering bodies real(kind=DP), intent(in) :: radius2 Radii of the two encountering bodies real(kind=DP), intent(in), dimension(:) :: xh1 Heliocentric position vectors of the two encountering bodies real(kind=DP), intent(in), dimension(:) :: xh2 Heliocentric position vectors of the two encountering bodies real(kind=DP), intent(in), dimension(:) :: vh1 Heliocentric velocity vectors of the two encountering bodies real(kind=DP), intent(in), dimension(:) :: vh2 Heliocentric velocity vectors of the two encountering bodies Calls proc~~io_write_frame_encounter~~CallsGraph proc~io_write_frame_encounter io_write_frame_encounter interface~util_exit util_exit proc~io_write_frame_encounter->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_write_frame_encounter~~CalledByGraph proc~io_write_frame_encounter io_write_frame_encounter interface~io_write_frame_encounter io_write_frame_encounter interface~io_write_frame_encounter->proc~io_write_frame_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_write_frame_encounter.html"},{"title":"io_write_frame_system – swiftest","text":"module subroutine io_write_frame_system(self, param) Interface → Write a frame (header plus records for each massive body and active test particle) to output binary file\n There is no direct file output from this subroutine Adapted from David E. Kaufmann's Swifter routine  io_write_frame.f90\n Adapted from Hal Levison's Swift routine io_write_frame.F Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Calls proc~~io_write_frame_system~~CallsGraph proc~io_write_frame_system io_write_frame_system interface~util_exit util_exit proc~io_write_frame_system->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_write_frame_system~~CalledByGraph proc~io_write_frame_system io_write_frame_system interface~io_write_frame_system io_write_frame_system interface~io_write_frame_system->proc~io_write_frame_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_write_frame_system.html"},{"title":"io_write_hdr_system – swiftest","text":"module subroutine io_write_hdr_system(self, iu, param) Interface → Write frame header to output binary file Adapted from David Adapted from David E. Kaufmann's Swifter routine io_write_hdr.f90\n Adapted from Hal Levison's Swift routine io_write_hdr.F Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest nbody system object integer(kind=I4B), intent(inout) :: iu Output file unit number class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~io_write_hdr_system~~CallsGraph proc~io_write_hdr_system io_write_hdr_system interface~util_exit util_exit proc~io_write_hdr_system->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~io_write_hdr_system~~CalledByGraph proc~io_write_hdr_system io_write_hdr_system interface~io_write_hdr_system io_write_hdr_system interface~io_write_hdr_system->proc~io_write_hdr_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/io_write_hdr_system.html"},{"title":"setup_construct_system – swiftest","text":"module subroutine setup_construct_system(system, param) Interface → Constructor for a Swiftest nbody system. Creates the nbody system object based on the user-input integrator Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout), allocatable :: system Swiftest system object class( swiftest_parameters ), intent(inout) :: param Swiftest parameters Calls proc~~setup_construct_system~~CallsGraph proc~setup_construct_system setup_construct_system interface~util_exit util_exit proc~setup_construct_system->interface~util_exit proc~util_exit util_exit interface~util_exit->proc~util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~setup_construct_system~~CalledByGraph proc~setup_construct_system setup_construct_system interface~setup_construct_system setup_construct_system interface~setup_construct_system->proc~setup_construct_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/setup_construct_system.html"},{"title":"setup_encounter – swiftest","text":"module subroutine setup_encounter(self, n) Interface → A constructor that sets the number of encounters and allocates and initializes all arrays Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for Called by proc~~setup_encounter~~CalledByGraph proc~setup_encounter setup_encounter interface~setup_encounter setup_encounter interface~setup_encounter->proc~setup_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/setup_encounter.html"},{"title":"setup_initialize_particle_info_system – swiftest","text":"module subroutine setup_initialize_particle_info_system(self, param) Interface → Setup up particle information metadata from initial conditions Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Called by proc~~setup_initialize_particle_info_system~~CalledByGraph proc~setup_initialize_particle_info_system setup_initialize_particle_info_system interface~setup_initialize_particle_info_system setup_initialize_particle_info_system interface~setup_initialize_particle_info_system->proc~setup_initialize_particle_info_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/setup_initialize_particle_info_system.html"},{"title":"setup_initialize_system – swiftest","text":"module subroutine setup_initialize_system(self, param) Interface → Wrapper method to initialize a basic Swiftest nbody system from files Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Called by proc~~setup_initialize_system~~CalledByGraph proc~setup_initialize_system setup_initialize_system interface~setup_initialize_system setup_initialize_system interface~setup_initialize_system->proc~setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/setup_initialize_system.html"},{"title":"setup_body – swiftest","text":"module subroutine setup_body(self, n, param) Interface → Constructor for base Swiftest particle class. Allocates space for all particles and\n initializes all components with a value.\n Note: Timing tests indicate that (NDIM, n) is more efficient than (NDIM, n) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter Called by proc~~setup_body~~CalledByGraph proc~setup_body setup_body interface~setup_body setup_body interface~setup_body->proc~setup_body proc~setup_pl setup_pl proc~setup_pl->interface~setup_body proc~setup_tp setup_tp proc~setup_tp->interface~setup_body interface~setup_tp setup_tp interface~setup_tp->proc~setup_tp interface~setup_pl setup_pl interface~setup_pl->proc~setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/setup_body.html"},{"title":"setup_pl – swiftest","text":"module subroutine setup_pl(self, n, param) Interface → Constructor for base Swiftest massive body class. Allocates space for all particles and\n initializes all components with a value. \n Call allocation method for parent class\n The parent class here is the abstract swiftest_body class, so we can't use the type-bound procedure Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter Calls proc~~setup_pl~~CallsGraph proc~setup_pl setup_pl interface~setup_body setup_body proc~setup_pl->interface~setup_body proc~setup_body setup_body interface~setup_body->proc~setup_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~setup_pl~~CalledByGraph proc~setup_pl setup_pl interface~setup_pl setup_pl interface~setup_pl->proc~setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/setup_pl.html"},{"title":"setup_tp – swiftest","text":"module subroutine setup_tp(self, n, param) Interface → Constructor for base Swiftest test particle particle class. Allocates space for \n all particles and initializes all components with a value. \n Call allocation method for parent class\n The parent class here is the abstract swiftest_body class, so we can't use the type-bound procedure Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter Calls proc~~setup_tp~~CallsGraph proc~setup_tp setup_tp interface~setup_body setup_body proc~setup_tp->interface~setup_body proc~setup_body setup_body interface~setup_body->proc~setup_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~setup_tp~~CalledByGraph proc~setup_tp setup_tp interface~setup_tp setup_tp interface~setup_tp->proc~setup_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/setup_tp.html"},{"title":"user_kick_getacch_body – swiftest","text":"module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Interface → Add user-supplied heliocentric accelerations to planets. Adapted from David E. Kaufmann's Swifter routine whm_user_kick_getacch.f90 Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters user parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the ste Called by proc~~user_kick_getacch_body~~CalledByGraph proc~user_kick_getacch_body user_kick_getacch_body interface~user_kick_getacch_body user_kick_getacch_body interface~user_kick_getacch_body->proc~user_kick_getacch_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/user_kick_getacch_body.html"},{"title":"drift_body – swiftest","text":"module subroutine drift_body(self, system, param, dt) Interface → Loop bodies and call Danby drift routine on the heliocentric position and velocities. Adapted from Hal Levison's Swift routine drift_tp.f \n Adapted from David E. Kaufmann's Swifter routine whm_drift_tp.f90 Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize Calls proc~~drift_body~~CallsGraph proc~drift_body drift_body interface~drift_all drift_all proc~drift_body->interface~drift_all proc~drift_all drift_all interface~drift_all->proc~drift_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~drift_body~~CalledByGraph proc~drift_body drift_body interface~drift_body drift_body interface~drift_body->proc~drift_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_body.html"},{"title":"drift_all – swiftest","text":"module subroutine drift_all(mu, x, v, n, param, dt, lmask, iflag) Interface → Loop bodies and call Danby drift routine on all bodies for the given position and velocity vector. Adapted from Hal Levison's Swift routine drift_tp.f \n Adapted from David E. Kaufmann's Swifter routine whm_drift_tp.f9 Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: mu Vector of gravitational constants real(kind=DP), intent(inout), dimension(:,:) :: x Position and velocity vectors real(kind=DP), intent(inout), dimension(:,:) :: v Position and velocity vectors integer(kind=I4B), intent(in) :: n number of bodies class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize logical, intent(in), dimension(:) :: lmask Logical mask of size self%nbody that determines which bodies to drift. integer(kind=I4B), intent(out), dimension(:) :: iflag Vector of error flags. 0 means no problem Called by proc~~drift_all~~CalledByGraph proc~drift_all drift_all interface~drift_all drift_all interface~drift_all->proc~drift_all proc~drift_body drift_body proc~drift_body->interface~drift_all interface~drift_body drift_body interface~drift_body->proc~drift_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_all.html"},{"title":"drift_one – swiftest","text":"pure elemental module subroutine drift_one(mu, px, py, pz, vx, vy, vz, dt, iflag) Interface → Perform Danby drift for one body, redoing drift with smaller substeps if original accuracy is insufficient Adapted from David E. Kaufmann's Swifter routine routine drift_one.f90\n Adapted from Hal Levison and Martin Duncan's Swift routine drift_one.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body to drift real(kind=DP), intent(inout) :: px Position and velocity of body to drift real(kind=DP), intent(inout) :: py Position and velocity of body to drift real(kind=DP), intent(inout) :: pz Position and velocity of body to drift real(kind=DP), intent(inout) :: vx Position and velocity of body to drift real(kind=DP), intent(inout) :: vy Position and velocity of body to drift real(kind=DP), intent(inout) :: vz Position and velocity of body to drift real(kind=DP), intent(in) :: dt Step size integer(kind=I4B), intent(out) :: iflag iflag : error status flag for Danby drift (0 = OK, nonzero = ERROR) Called by proc~~drift_one~~CalledByGraph proc~drift_one drift_one interface~drift_one drift_one interface~drift_one->proc~drift_one Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drift_one.html"},{"title":"symba_util_append_arr_kin – swiftest","text":"subroutine symba_util_append_arr_kin(arr, source, nold, nsrc, lsource_mask) Append a single array of kinship type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: arr Destination array type( symba_kinship ), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~symba_util_append_arr_kin~~CallsGraph proc~symba_util_append_arr_kin symba_util_append_arr_kin interface~util_resize util_resize proc~symba_util_append_arr_kin->interface~util_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_append_arr_kin.html"},{"title":"symba_util_append_encounter – swiftest","text":"module subroutine symba_util_append_encounter(self, source, lsource_mask) Interface → Append components from one encounter list (pl-pl or pl-tp) body object to another. \n This method will automatically resize the destination body if it is too small Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA encounter list object class( swiftest_encounter ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~symba_util_append_encounter~~CallsGraph proc~symba_util_append_encounter symba_util_append_encounter interface~util_append util_append proc~symba_util_append_encounter->interface~util_append util_append_encounter util_append_encounter proc~symba_util_append_encounter->util_append_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_append_encounter~~CalledByGraph proc~symba_util_append_encounter symba_util_append_encounter interface~symba_util_append_encounter symba_util_append_encounter interface~symba_util_append_encounter->proc~symba_util_append_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_append_encounter.html"},{"title":"symba_util_append_pl – swiftest","text":"module subroutine symba_util_append_pl(self, source, lsource_mask) Interface → Append components from one massive body object to another. \n This method will automatically resize the destination body if it is too small\n Arguments Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~symba_util_append_pl~~CallsGraph proc~symba_util_append_pl symba_util_append_pl interface~util_append util_append proc~symba_util_append_pl->interface~util_append util_append_pl util_append_pl proc~symba_util_append_pl->util_append_pl util_exit util_exit proc~symba_util_append_pl->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_append_pl~~CalledByGraph proc~symba_util_append_pl symba_util_append_pl interface~symba_util_append_pl symba_util_append_pl interface~symba_util_append_pl->proc~symba_util_append_pl proc~symba_util_append_merger symba_util_append_merger proc~symba_util_append_merger->interface~symba_util_append_pl interface~symba_util_append_merger symba_util_append_merger interface~symba_util_append_merger->proc~symba_util_append_merger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_append_pl.html"},{"title":"symba_util_append_merger – swiftest","text":"module subroutine symba_util_append_merger(self, source, lsource_mask) Interface → Append components from one massive body object to another. \n This method will automatically resize the destination body if it is too small Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~symba_util_append_merger~~CallsGraph proc~symba_util_append_merger symba_util_append_merger interface~util_append util_append proc~symba_util_append_merger->interface~util_append util_exit util_exit proc~symba_util_append_merger->util_exit interface~symba_util_append_pl symba_util_append_pl proc~symba_util_append_merger->interface~symba_util_append_pl proc~symba_util_append_pl symba_util_append_pl interface~symba_util_append_pl->proc~symba_util_append_pl proc~symba_util_append_pl->interface~util_append proc~symba_util_append_pl->util_exit util_append_pl util_append_pl proc~symba_util_append_pl->util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_append_merger~~CalledByGraph proc~symba_util_append_merger symba_util_append_merger interface~symba_util_append_merger symba_util_append_merger interface~symba_util_append_merger->proc~symba_util_append_merger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_append_merger.html"},{"title":"symba_util_append_tp – swiftest","text":"module subroutine symba_util_append_tp(self, source, lsource_mask) Interface → Append components from test particle object to another. \n This method will automatically resize the destination body if it is too small\n Arguments Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~symba_util_append_tp~~CallsGraph proc~symba_util_append_tp symba_util_append_tp interface~util_append util_append proc~symba_util_append_tp->interface~util_append util_exit util_exit proc~symba_util_append_tp->util_exit util_append_tp util_append_tp proc~symba_util_append_tp->util_append_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_append_tp~~CalledByGraph proc~symba_util_append_tp symba_util_append_tp interface~symba_util_append_tp symba_util_append_tp interface~symba_util_append_tp->proc~symba_util_append_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_append_tp.html"},{"title":"symba_util_copy_encounter – swiftest","text":"module subroutine symba_util_copy_encounter(self, source) Interface → Copies elements from the source encounter list into self. Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self Encounter list class( swiftest_encounter ), intent(in) :: source Source object to copy into Calls proc~~symba_util_copy_encounter~~CallsGraph proc~symba_util_copy_encounter symba_util_copy_encounter util_copy_encounter util_copy_encounter proc~symba_util_copy_encounter->util_copy_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_copy_encounter~~CalledByGraph proc~symba_util_copy_encounter symba_util_copy_encounter interface~symba_util_copy_encounter symba_util_copy_encounter interface~symba_util_copy_encounter->proc~symba_util_copy_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_copy_encounter.html"},{"title":"symba_util_fill_arr_kin – swiftest","text":"subroutine symba_util_fill_arr_kin(keeps, inserts, lfill_list) Performs a fill operation on a single array of particle kinship types\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_kinship ), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Contents None","tags":"","loc":"proc/symba_util_fill_arr_kin.html"},{"title":"symba_util_fill_pl – swiftest","text":"module subroutine symba_util_fill_pl(self, inserts, lfill_list) Interface → Insert new SyMBA test particle structure into an old one. \n This is the inverse of a fill operation. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA masive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Calls proc~~symba_util_fill_pl~~CallsGraph proc~symba_util_fill_pl symba_util_fill_pl util_exit util_exit proc~symba_util_fill_pl->util_exit interface~util_fill util_fill proc~symba_util_fill_pl->interface~util_fill util_fill_pl util_fill_pl proc~symba_util_fill_pl->util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_fill_pl~~CalledByGraph proc~symba_util_fill_pl symba_util_fill_pl interface~symba_util_fill_pl symba_util_fill_pl interface~symba_util_fill_pl->proc~symba_util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_fill_pl.html"},{"title":"symba_util_fill_tp – swiftest","text":"module subroutine symba_util_fill_tp(self, inserts, lfill_list) Interface → Insert new SyMBA test particle structure into an old one. \n This is the inverse of a fill operation. Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Calls proc~~symba_util_fill_tp~~CallsGraph proc~symba_util_fill_tp symba_util_fill_tp util_exit util_exit proc~symba_util_fill_tp->util_exit interface~util_fill util_fill proc~symba_util_fill_tp->interface~util_fill util_fill_tp util_fill_tp proc~symba_util_fill_tp->util_fill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_fill_tp~~CalledByGraph proc~symba_util_fill_tp symba_util_fill_tp interface~symba_util_fill_tp symba_util_fill_tp interface~symba_util_fill_tp->proc~symba_util_fill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_fill_tp.html"},{"title":"symba_util_index_eucl_plpl – swiftest","text":"module subroutine symba_util_index_eucl_plpl(self, param) Interface → Turns i,j indices into k index for use in the Euclidean distance matrix. This also sets the lmtiny flag and computes the\n number of interactions that excludes semi-interacting bodies with each other (Gmass < GMTINY).\n This method will also sort the bodies in descending order by Mass Reference: Mélodie Angeletti, Jean-Marie Bonny, Jonas Koko. Parallel Euclidean distance matrix computation on big datasets *. 2019. hal-0204751 Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~symba_util_index_eucl_plpl~~CallsGraph proc~symba_util_index_eucl_plpl symba_util_index_eucl_plpl util_index_eucl_ij_to_k util_index_eucl_ij_to_k proc~symba_util_index_eucl_plpl->util_index_eucl_ij_to_k Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_index_eucl_plpl~~CalledByGraph proc~symba_util_index_eucl_plpl symba_util_index_eucl_plpl interface~symba_util_index_eucl_plpl symba_util_index_eucl_plpl interface~symba_util_index_eucl_plpl->proc~symba_util_index_eucl_plpl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_index_eucl_plpl.html"},{"title":"symba_util_peri_pl – swiftest","text":"module subroutine symba_util_peri_pl(self, system, param) Interface → Determine system pericenter passages for planets in SyMBA Adapted from David E. Kaufmann's Swifter routine: symba_peri.f90\n Adapted from Hal Levison's Swift routine util_mass_peri.f Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~symba_util_peri_pl~~CallsGraph proc~symba_util_peri_pl symba_util_peri_pl orbel_xv2aeq orbel_xv2aeq proc~symba_util_peri_pl->orbel_xv2aeq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_peri_pl~~CalledByGraph proc~symba_util_peri_pl symba_util_peri_pl interface~symba_util_peri_pl symba_util_peri_pl interface~symba_util_peri_pl->proc~symba_util_peri_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_peri_pl.html"},{"title":"symba_util_rearray_pl – swiftest","text":"module subroutine symba_util_rearray_pl(self, system, param) Interface → Clean up the massive body structures to remove discarded bodies and add new bodies Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class( symba_nbody_system ), intent(inout) :: system Swiftest nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters Called by proc~~symba_util_rearray_pl~~CalledByGraph proc~symba_util_rearray_pl symba_util_rearray_pl interface~symba_util_rearray_pl symba_util_rearray_pl interface~symba_util_rearray_pl->proc~symba_util_rearray_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_rearray_pl.html"},{"title":"symba_util_reset_kinship – swiftest","text":"module subroutine symba_util_reset_kinship(self, idx) Interface → Resets the kinship status of bodies. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: idx Index array of bodies to reset Called by proc~~symba_util_reset_kinship~~CalledByGraph proc~symba_util_reset_kinship symba_util_reset_kinship interface~symba_util_reset_kinship symba_util_reset_kinship interface~symba_util_reset_kinship->proc~symba_util_reset_kinship Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_reset_kinship.html"},{"title":"symba_util_resize_arr_kin – swiftest","text":"subroutine symba_util_resize_arr_kin(arr, nnew) Resizes an array component of type character string. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size Contents None","tags":"","loc":"proc/symba_util_resize_arr_kin.html"},{"title":"symba_util_resize_merger – swiftest","text":"module subroutine symba_util_resize_merger(self, nnew) Interface → Checks the current size of a SyMBA merger list against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: nnew New size neded Calls proc~~symba_util_resize_merger~~CallsGraph proc~symba_util_resize_merger symba_util_resize_merger interface~symba_util_resize_pl symba_util_resize_pl proc~symba_util_resize_merger->interface~symba_util_resize_pl interface~util_resize util_resize proc~symba_util_resize_merger->interface~util_resize proc~symba_util_resize_pl symba_util_resize_pl interface~symba_util_resize_pl->proc~symba_util_resize_pl proc~symba_util_resize_pl->interface~util_resize util_resize_pl util_resize_pl proc~symba_util_resize_pl->util_resize_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_resize_merger~~CalledByGraph proc~symba_util_resize_merger symba_util_resize_merger interface~symba_util_resize_merger symba_util_resize_merger interface~symba_util_resize_merger->proc~symba_util_resize_merger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_resize_merger.html"},{"title":"symba_util_resize_pl – swiftest","text":"module subroutine symba_util_resize_pl(self, nnew) Interface → Checks the current size of a SyMBA massive body object against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: nnew New size neded Calls proc~~symba_util_resize_pl~~CallsGraph proc~symba_util_resize_pl symba_util_resize_pl util_resize_pl util_resize_pl proc~symba_util_resize_pl->util_resize_pl interface~util_resize util_resize proc~symba_util_resize_pl->interface~util_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_resize_pl~~CalledByGraph proc~symba_util_resize_pl symba_util_resize_pl interface~symba_util_resize_pl symba_util_resize_pl interface~symba_util_resize_pl->proc~symba_util_resize_pl proc~symba_util_resize_merger symba_util_resize_merger proc~symba_util_resize_merger->interface~symba_util_resize_pl interface~symba_util_resize_merger symba_util_resize_merger interface~symba_util_resize_merger->proc~symba_util_resize_merger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_resize_pl.html"},{"title":"symba_util_resize_tp – swiftest","text":"module subroutine symba_util_resize_tp(self, nnew) Interface → Checks the current size of a test particle object against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object integer(kind=I4B), intent(in) :: nnew New size neded Calls proc~~symba_util_resize_tp~~CallsGraph proc~symba_util_resize_tp symba_util_resize_tp util_resize_tp util_resize_tp proc~symba_util_resize_tp->util_resize_tp interface~util_resize util_resize proc~symba_util_resize_tp->interface~util_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_resize_tp~~CalledByGraph proc~symba_util_resize_tp symba_util_resize_tp interface~symba_util_resize_tp symba_util_resize_tp interface~symba_util_resize_tp->proc~symba_util_resize_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_resize_tp.html"},{"title":"symba_util_sort_pl – swiftest","text":"module subroutine symba_util_sort_pl(self, sortby, ascending) Interface → Sort a SyMBA massive body object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order Calls proc~~symba_util_sort_pl~~CallsGraph proc~symba_util_sort_pl symba_util_sort_pl util_sort_pl util_sort_pl proc~symba_util_sort_pl->util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_sort_pl~~CalledByGraph proc~symba_util_sort_pl symba_util_sort_pl interface~symba_util_sort_pl symba_util_sort_pl interface~symba_util_sort_pl->proc~symba_util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_sort_pl.html"},{"title":"symba_util_sort_tp – swiftest","text":"module subroutine symba_util_sort_tp(self, sortby, ascending) Interface → Sort a SyMBA test particle object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order Calls proc~~symba_util_sort_tp~~CallsGraph proc~symba_util_sort_tp symba_util_sort_tp util_sort_tp util_sort_tp proc~symba_util_sort_tp->util_sort_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_sort_tp~~CalledByGraph proc~symba_util_sort_tp symba_util_sort_tp interface~symba_util_sort_tp symba_util_sort_tp interface~symba_util_sort_tp->proc~symba_util_sort_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_sort_tp.html"},{"title":"symba_util_sort_rearrange_arr_kin – swiftest","text":"subroutine symba_util_sort_rearrange_arr_kin(arr, ind, n) Rearrange a single array of particle kinship type in-place from an index list. Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange Contents None","tags":"","loc":"proc/symba_util_sort_rearrange_arr_kin.html"},{"title":"symba_util_sort_rearrange_pl – swiftest","text":"module subroutine symba_util_sort_rearrange_pl(self, ind) Interface → Rearrange SyMBA massive body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) Calls proc~~symba_util_sort_rearrange_pl~~CallsGraph proc~symba_util_sort_rearrange_pl symba_util_sort_rearrange_pl util_sort_rearrange_pl util_sort_rearrange_pl proc~symba_util_sort_rearrange_pl->util_sort_rearrange_pl interface~util_sort_rearrange util_sort_rearrange proc~symba_util_sort_rearrange_pl->interface~util_sort_rearrange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_sort_rearrange_pl~~CalledByGraph proc~symba_util_sort_rearrange_pl symba_util_sort_rearrange_pl interface~symba_util_sort_rearrange_pl symba_util_sort_rearrange_pl interface~symba_util_sort_rearrange_pl->proc~symba_util_sort_rearrange_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_sort_rearrange_pl.html"},{"title":"symba_util_sort_rearrange_tp – swiftest","text":"module subroutine symba_util_sort_rearrange_tp(self, ind) Interface → Rearrange SyMBA test particle object in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) Calls proc~~symba_util_sort_rearrange_tp~~CallsGraph proc~symba_util_sort_rearrange_tp symba_util_sort_rearrange_tp util_sort_rearrange_tp util_sort_rearrange_tp proc~symba_util_sort_rearrange_tp->util_sort_rearrange_tp interface~util_sort_rearrange util_sort_rearrange proc~symba_util_sort_rearrange_tp->interface~util_sort_rearrange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_sort_rearrange_tp~~CalledByGraph proc~symba_util_sort_rearrange_tp symba_util_sort_rearrange_tp interface~symba_util_sort_rearrange_tp symba_util_sort_rearrange_tp interface~symba_util_sort_rearrange_tp->proc~symba_util_sort_rearrange_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_sort_rearrange_tp.html"},{"title":"symba_util_spill_arr_kin – swiftest","text":"subroutine symba_util_spill_arr_kin(keeps, discards, lspill_list, ldestructive) Performs a spill operation on a single array of particle kinships\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_kinship ), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not Contents None","tags":"","loc":"proc/symba_util_spill_arr_kin.html"},{"title":"symba_util_spill_pl – swiftest","text":"module subroutine symba_util_spill_pl(self, discards, lspill_list, ldestructive) Interface → Move spilled (discarded) SyMBA massive body particle structure from active list to discard list\n Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90\n Spill all the common components Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list Calls proc~~symba_util_spill_pl~~CallsGraph proc~symba_util_spill_pl symba_util_spill_pl util_exit util_exit proc~symba_util_spill_pl->util_exit interface~util_spill util_spill proc~symba_util_spill_pl->interface~util_spill util_spill_pl util_spill_pl proc~symba_util_spill_pl->util_spill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_spill_pl~~CalledByGraph proc~symba_util_spill_pl symba_util_spill_pl interface~symba_util_spill_pl symba_util_spill_pl interface~symba_util_spill_pl->proc~symba_util_spill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_spill_pl.html"},{"title":"symba_util_spill_encounter – swiftest","text":"module subroutine symba_util_spill_encounter(self, discards, lspill_list, ldestructive) Interface → Move spilled (discarded) SyMBA encounter structure from active list to discard list\n Note: Because the symba_plplenc currently does not contain any additional variable components, this method can recieve it as an input as well. Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-tp encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list Calls proc~~symba_util_spill_encounter~~CallsGraph proc~symba_util_spill_encounter symba_util_spill_encounter util_exit util_exit proc~symba_util_spill_encounter->util_exit interface~util_spill util_spill proc~symba_util_spill_encounter->interface~util_spill util_spill_encounter util_spill_encounter proc~symba_util_spill_encounter->util_spill_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_spill_encounter~~CalledByGraph proc~symba_util_spill_encounter symba_util_spill_encounter interface~symba_util_spill_encounter symba_util_spill_encounter interface~symba_util_spill_encounter->proc~symba_util_spill_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_spill_encounter.html"},{"title":"symba_util_spill_tp – swiftest","text":"module subroutine symba_util_spill_tp(self, discards, lspill_list, ldestructive) Interface → Move spilled (discarded) SyMBA test particle structure from active list to discard list\n Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90\n Spill all the common components Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list Calls proc~~symba_util_spill_tp~~CallsGraph proc~symba_util_spill_tp symba_util_spill_tp util_exit util_exit proc~symba_util_spill_tp->util_exit interface~util_spill util_spill proc~symba_util_spill_tp->interface~util_spill util_spill_tp util_spill_tp proc~symba_util_spill_tp->util_spill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_util_spill_tp~~CalledByGraph proc~symba_util_spill_tp symba_util_spill_tp interface~symba_util_spill_tp symba_util_spill_tp interface~symba_util_spill_tp->proc~symba_util_spill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_util_spill_tp.html"},{"title":"symba_collision_casedisruption – swiftest","text":"module function symba_collision_casedisruption(system, param, colliders, frag) result(status) Interface → Create the fragments resulting from a non-catastrophic disruption collision Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions class( fraggle_colliders ), intent(inout) :: colliders Fraggle colliders object class( fraggle_fragments ), intent(inout) :: frag Fraggle fragmentation system object Return Value integer(kind=I4B) Status flag assigned to this outcome Calls proc~~symba_collision_casedisruption~~CallsGraph proc~symba_collision_casedisruption symba_collision_casedisruption proc~symba_collision_collider_message symba_collision_collider_message proc~symba_collision_casedisruption->proc~symba_collision_collider_message proc~symba_collision_mergeaddsub symba_collision_mergeaddsub proc~symba_collision_casedisruption->proc~symba_collision_mergeaddsub fraggle_io_log_one_message fraggle_io_log_one_message proc~symba_collision_casedisruption->fraggle_io_log_one_message fraggle_io_log_pl fraggle_io_log_pl proc~symba_collision_mergeaddsub->fraggle_io_log_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_collision_casedisruption~~CalledByGraph proc~symba_collision_casedisruption symba_collision_casedisruption interface~symba_collision_casedisruption symba_collision_casedisruption interface~symba_collision_casedisruption->proc~symba_collision_casedisruption proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations proc~symba_collision_resolve_fragmentations->interface~symba_collision_casedisruption interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_collision_casedisruption.html"},{"title":"symba_collision_casehitandrun – swiftest","text":"module function symba_collision_casehitandrun(system, param, colliders, frag) result(status) Interface → Create the fragments resulting from a non-catastrophic hit-and-run collision Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions class( fraggle_colliders ), intent(inout) :: colliders Fraggle colliders object class( fraggle_fragments ), intent(inout) :: frag Fraggle fragmentation system object Return Value integer(kind=I4B) Status flag assigned to this outcom Calls proc~~symba_collision_casehitandrun~~CallsGraph proc~symba_collision_casehitandrun symba_collision_casehitandrun proc~symba_collision_collider_message symba_collision_collider_message proc~symba_collision_casehitandrun->proc~symba_collision_collider_message proc~symba_collision_mergeaddsub symba_collision_mergeaddsub proc~symba_collision_casehitandrun->proc~symba_collision_mergeaddsub fraggle_io_log_one_message fraggle_io_log_one_message proc~symba_collision_casehitandrun->fraggle_io_log_one_message fraggle_io_log_pl fraggle_io_log_pl proc~symba_collision_mergeaddsub->fraggle_io_log_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_collision_casehitandrun~~CalledByGraph proc~symba_collision_casehitandrun symba_collision_casehitandrun interface~symba_collision_casehitandrun symba_collision_casehitandrun interface~symba_collision_casehitandrun->proc~symba_collision_casehitandrun proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations proc~symba_collision_resolve_fragmentations->interface~symba_collision_casehitandrun interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_collision_casehitandrun.html"},{"title":"symba_collision_casemerge – swiftest","text":"module function symba_collision_casemerge(system, param, colliders, frag) result(status) Interface → Merge massive bodies. Adapted from David E. Kaufmann's Swifter routines symba_merge_pl.f90 and symba_discard_merge_pl.f90 Adapted from Hal Levison's Swift routines symba5_merge.f and discard_mass_merge.f Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions class( fraggle_colliders ), intent(inout) :: colliders Fraggle colliders object class( fraggle_fragments ), intent(inout) :: frag Fraggle fragmentation system object Return Value integer(kind=I4B) Status flag assigned to this outcome Calls proc~~symba_collision_casemerge~~CallsGraph proc~symba_collision_casemerge symba_collision_casemerge proc~symba_collision_collider_message symba_collision_collider_message proc~symba_collision_casemerge->proc~symba_collision_collider_message proc~symba_collision_mergeaddsub symba_collision_mergeaddsub proc~symba_collision_casemerge->proc~symba_collision_mergeaddsub fraggle_io_log_one_message fraggle_io_log_one_message proc~symba_collision_casemerge->fraggle_io_log_one_message fraggle_io_log_pl fraggle_io_log_pl proc~symba_collision_mergeaddsub->fraggle_io_log_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_collision_casemerge~~CalledByGraph proc~symba_collision_casemerge symba_collision_casemerge interface~symba_collision_casemerge symba_collision_casemerge interface~symba_collision_casemerge->proc~symba_collision_casemerge proc~symba_collision_resolve_mergers symba_collision_resolve_mergers proc~symba_collision_resolve_mergers->interface~symba_collision_casemerge proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations proc~symba_collision_resolve_fragmentations->interface~symba_collision_casemerge interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations interface~symba_collision_resolve_mergers symba_collision_resolve_mergers interface~symba_collision_resolve_mergers->proc~symba_collision_resolve_mergers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_collision_casemerge.html"},{"title":"symba_collision_check_encounter – swiftest","text":"module function symba_collision_check_encounter(self, system, param, t, dt, irec) result(lany_collision) Interface → Check for merger between massive bodies and test particles in SyMBA Adapted from David E. Kaufmann's Swifter routine symba_merge.f90 and symba_merge_tp.f90 Adapted from Hal Levison's Swift routine symba5_merge.f Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t current time real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if cany pair of encounters resulted in a collision Calls proc~~symba_collision_check_encounter~~CallsGraph proc~symba_collision_check_encounter symba_collision_check_encounter proc~symba_collision_check_one symba_collision_check_one proc~symba_collision_check_encounter->proc~symba_collision_check_one fraggle_io_log_one_message fraggle_io_log_one_message proc~symba_collision_check_encounter->fraggle_io_log_one_message orbel_xv2aeq orbel_xv2aeq proc~symba_collision_check_one->orbel_xv2aeq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_collision_check_encounter~~CalledByGraph proc~symba_collision_check_encounter symba_collision_check_encounter interface~symba_collision_check_encounter symba_collision_check_encounter interface~symba_collision_check_encounter->proc~symba_collision_check_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_collision_check_encounter.html"},{"title":"symba_collision_encounter_extract_collisions – swiftest","text":"module subroutine symba_collision_encounter_extract_collisions(self, system, param) Interface → Processes the pl-pl encounter list remove only those encounters that led to a collision Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~symba_collision_encounter_extract_collisions~~CallsGraph proc~symba_collision_encounter_extract_collisions symba_collision_encounter_extract_collisions idx2 idx2 proc~symba_collision_encounter_extract_collisions->idx2 idx1 idx1 proc~symba_collision_encounter_extract_collisions->idx1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_collision_encounter_extract_collisions~~CalledByGraph proc~symba_collision_encounter_extract_collisions symba_collision_encounter_extract_collisions interface~symba_collision_encounter_extract_collisions symba_collision_encounter_extract_collisions interface~symba_collision_encounter_extract_collisions->proc~symba_collision_encounter_extract_collisions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_collision_encounter_extract_collisions.html"},{"title":"symba_collision_make_colliders_pl – swiftest","text":"module subroutine symba_collision_make_colliders_pl(self, idx) Interface → When a single body is involved in more than one collision in a single step, it becomes part of a colliders%idx.\n The largest body involved in a multi-body collision is the \"parent\" and all bodies that collide with it are its \"children,\"\n including those that collide with the children. Adapted from David E. Kaufmann's Swifter routine symba_merge_pl.f90 Adapted from Hal Levison's Swift routine symba5_merge.f Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(2) :: idx Array holding the indices of the two bodies involved in the collision Called by proc~~symba_collision_make_colliders_pl~~CalledByGraph proc~symba_collision_make_colliders_pl symba_collision_make_colliders_pl interface~symba_collision_make_colliders_pl symba_collision_make_colliders_pl interface~symba_collision_make_colliders_pl->proc~symba_collision_make_colliders_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_collision_make_colliders_pl.html"},{"title":"symba_collision_resolve_fragmentations – swiftest","text":"module subroutine symba_collision_resolve_fragmentations(self, system, param) Interface → Process list of collisions, determine the collisional regime, and then create fragments. Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions Calls proc~~symba_collision_resolve_fragmentations~~CallsGraph proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations idx2 idx2 proc~symba_collision_resolve_fragmentations->idx2 util_exit util_exit proc~symba_collision_resolve_fragmentations->util_exit idx1 idx1 proc~symba_collision_resolve_fragmentations->idx1 proc~symba_collision_consolidate_colliders symba_collision_consolidate_colliders proc~symba_collision_resolve_fragmentations->proc~symba_collision_consolidate_colliders interface~symba_collision_casedisruption symba_collision_casedisruption proc~symba_collision_resolve_fragmentations->interface~symba_collision_casedisruption interface~symba_collision_casemerge symba_collision_casemerge proc~symba_collision_resolve_fragmentations->interface~symba_collision_casemerge interface~symba_collision_casehitandrun symba_collision_casehitandrun proc~symba_collision_resolve_fragmentations->interface~symba_collision_casehitandrun idx_arr idx_arr proc~symba_collision_consolidate_colliders->idx_arr id_arr id_arr proc~symba_collision_consolidate_colliders->id_arr proc~symba_collision_casedisruption symba_collision_casedisruption interface~symba_collision_casedisruption->proc~symba_collision_casedisruption proc~symba_collision_casemerge symba_collision_casemerge interface~symba_collision_casemerge->proc~symba_collision_casemerge proc~symba_collision_casehitandrun symba_collision_casehitandrun interface~symba_collision_casehitandrun->proc~symba_collision_casehitandrun proc~symba_collision_collider_message symba_collision_collider_message proc~symba_collision_casedisruption->proc~symba_collision_collider_message proc~symba_collision_mergeaddsub symba_collision_mergeaddsub proc~symba_collision_casedisruption->proc~symba_collision_mergeaddsub fraggle_io_log_one_message fraggle_io_log_one_message proc~symba_collision_casedisruption->fraggle_io_log_one_message proc~symba_collision_casehitandrun->proc~symba_collision_collider_message proc~symba_collision_casehitandrun->proc~symba_collision_mergeaddsub proc~symba_collision_casehitandrun->fraggle_io_log_one_message proc~symba_collision_casemerge->proc~symba_collision_collider_message proc~symba_collision_casemerge->proc~symba_collision_mergeaddsub proc~symba_collision_casemerge->fraggle_io_log_one_message fraggle_io_log_pl fraggle_io_log_pl proc~symba_collision_mergeaddsub->fraggle_io_log_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_collision_resolve_fragmentations~~CalledByGraph proc~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations symba_collision_resolve_fragmentations interface~symba_collision_resolve_fragmentations->proc~symba_collision_resolve_fragmentations Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_collision_resolve_fragmentations.html"},{"title":"symba_collision_resolve_mergers – swiftest","text":"module subroutine symba_collision_resolve_mergers(self, system, param) Interface → Process list of collisions and merge colliding bodies together. Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions Calls proc~~symba_collision_resolve_mergers~~CallsGraph proc~symba_collision_resolve_mergers symba_collision_resolve_mergers idx2 idx2 proc~symba_collision_resolve_mergers->idx2 proc~symba_collision_consolidate_colliders symba_collision_consolidate_colliders proc~symba_collision_resolve_mergers->proc~symba_collision_consolidate_colliders idx1 idx1 proc~symba_collision_resolve_mergers->idx1 interface~symba_collision_casemerge symba_collision_casemerge proc~symba_collision_resolve_mergers->interface~symba_collision_casemerge idx_arr idx_arr proc~symba_collision_consolidate_colliders->idx_arr id_arr id_arr proc~symba_collision_consolidate_colliders->id_arr proc~symba_collision_casemerge symba_collision_casemerge interface~symba_collision_casemerge->proc~symba_collision_casemerge proc~symba_collision_collider_message symba_collision_collider_message proc~symba_collision_casemerge->proc~symba_collision_collider_message proc~symba_collision_mergeaddsub symba_collision_mergeaddsub proc~symba_collision_casemerge->proc~symba_collision_mergeaddsub fraggle_io_log_one_message fraggle_io_log_one_message proc~symba_collision_casemerge->fraggle_io_log_one_message fraggle_io_log_pl fraggle_io_log_pl proc~symba_collision_mergeaddsub->fraggle_io_log_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_collision_resolve_mergers~~CalledByGraph proc~symba_collision_resolve_mergers symba_collision_resolve_mergers interface~symba_collision_resolve_mergers symba_collision_resolve_mergers interface~symba_collision_resolve_mergers->proc~symba_collision_resolve_mergers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_collision_resolve_mergers.html"},{"title":"symba_collision_resolve_plplenc – swiftest","text":"module subroutine symba_collision_resolve_plplenc(self, system, param, t, dt, irec) Interface → Process the pl-pl collision list, then modifiy the massive bodies based on the outcome of the collision Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current simulation step size integer(kind=I4B), intent(in) :: irec Current recursion level Calls proc~~symba_collision_resolve_plplenc~~CallsGraph proc~symba_collision_resolve_plplenc symba_collision_resolve_plplenc fraggle_io_log_one_message fraggle_io_log_one_message proc~symba_collision_resolve_plplenc->fraggle_io_log_one_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_collision_resolve_plplenc~~CalledByGraph proc~symba_collision_resolve_plplenc symba_collision_resolve_plplenc interface~symba_collision_resolve_plplenc symba_collision_resolve_plplenc interface~symba_collision_resolve_plplenc->proc~symba_collision_resolve_plplenc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_collision_resolve_plplenc.html"},{"title":"symba_collision_resolve_pltpenc – swiftest","text":"module subroutine symba_collision_resolve_pltpenc(self, system, param, t, dt, irec) Interface → Process the pl-tp collision list, then modifiy the massive bodies based on the outcome of the collision Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions real(kind=DP), intent(in) :: t Current simulation tim real(kind=DP), intent(in) :: dt Current simulation step size integer(kind=I4B), intent(in) :: irec Current recursion level Called by proc~~symba_collision_resolve_pltpenc~~CalledByGraph proc~symba_collision_resolve_pltpenc symba_collision_resolve_pltpenc interface~symba_collision_resolve_pltpenc symba_collision_resolve_pltpenc interface~symba_collision_resolve_pltpenc->proc~symba_collision_resolve_pltpenc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_collision_resolve_pltpenc.html"},{"title":"symba_setup_initialize_system – swiftest","text":"module subroutine symba_setup_initialize_system(self, param) Interface → Initialize an SyMBA nbody system from files and sets up the planetocentric structures.\n This subroutine will also sort the massive bodies in descending order by mass Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Calls proc~~symba_setup_initialize_system~~CallsGraph proc~symba_setup_initialize_system symba_setup_initialize_system helio_setup_initialize_system helio_setup_initialize_system proc~symba_setup_initialize_system->helio_setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_setup_initialize_system~~CalledByGraph proc~symba_setup_initialize_system symba_setup_initialize_system interface~symba_setup_initialize_system symba_setup_initialize_system interface~symba_setup_initialize_system->proc~symba_setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_setup_initialize_system.html"},{"title":"symba_setup_merger – swiftest","text":"module subroutine symba_setup_merger(self, n, param) Interface → Allocate SyMBA test particle structure Equivalent in functionality to David E. Kaufmann's Swifter routine symba_setup.f90\n Call allocation method for parent class. In this case, helio_pl does not have its own setup method so we use the base method for swiftest_pl Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA merger list object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter Calls proc~~symba_setup_merger~~CallsGraph proc~symba_setup_merger symba_setup_merger interface~symba_setup_pl symba_setup_pl proc~symba_setup_merger->interface~symba_setup_pl proc~symba_setup_pl symba_setup_pl interface~symba_setup_pl->proc~symba_setup_pl setup_pl setup_pl proc~symba_setup_pl->setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_setup_merger~~CalledByGraph proc~symba_setup_merger symba_setup_merger interface~symba_setup_merger symba_setup_merger interface~symba_setup_merger->proc~symba_setup_merger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_setup_merger.html"},{"title":"symba_setup_pl – swiftest","text":"module subroutine symba_setup_pl(self, n, param) Interface → Allocate SyMBA test particle structure Equivalent in functionality to David E. Kaufmann's Swifter routine symba_setup.f90\n Call allocation method for parent class. In this case, helio_pl does not have its own setup method so we use the base method for swiftest_pl Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter Calls proc~~symba_setup_pl~~CallsGraph proc~symba_setup_pl symba_setup_pl setup_pl setup_pl proc~symba_setup_pl->setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_setup_pl~~CalledByGraph proc~symba_setup_pl symba_setup_pl interface~symba_setup_pl symba_setup_pl interface~symba_setup_pl->proc~symba_setup_pl proc~symba_setup_merger symba_setup_merger proc~symba_setup_merger->interface~symba_setup_pl interface~symba_setup_merger symba_setup_merger interface~symba_setup_merger->proc~symba_setup_merger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_setup_pl.html"},{"title":"symba_setup_encounter – swiftest","text":"module subroutine symba_setup_encounter(self, n) Interface → A constructor that sets the number of encounters and allocates and initializes all arrays Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-tp encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for Calls proc~~symba_setup_encounter~~CallsGraph proc~symba_setup_encounter symba_setup_encounter setup_encounter setup_encounter proc~symba_setup_encounter->setup_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_setup_encounter~~CalledByGraph proc~symba_setup_encounter symba_setup_encounter interface~symba_setup_encounter symba_setup_encounter interface~symba_setup_encounter->proc~symba_setup_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_setup_encounter.html"},{"title":"symba_setup_tp – swiftest","text":"module subroutine symba_setup_tp(self, n, param) Interface → Allocate WHM test particle structure Equivalent in functionality to David E. Kaufmann's Swifter routine whm_setup.f90\n Call allocation method for parent class. In this case, helio_tp does not have its own setup method so we use the base method for swiftest_tp Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter Calls proc~~symba_setup_tp~~CallsGraph proc~symba_setup_tp symba_setup_tp setup_tp setup_tp proc~symba_setup_tp->setup_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_setup_tp~~CalledByGraph proc~symba_setup_tp symba_setup_tp interface~symba_setup_tp symba_setup_tp interface~symba_setup_tp->proc~symba_setup_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_setup_tp.html"},{"title":"symba_kick_getacch_int_pl – swiftest","text":"module subroutine symba_kick_getacch_int_pl(self) Interface → Compute direct cross (third) term heliocentric accelerations of massive bodies, with no mutual interactions between bodies below GMTINY Adapted from Hal Levison's Swift routine symba5_helio_getacch.f\n Adapted from David E. Kaufmann's Swifter routine helio_kick_getacch_int.f90 Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self Calls proc~~symba_kick_getacch_int_pl~~CallsGraph proc~symba_kick_getacch_int_pl symba_kick_getacch_int_pl kick_getacch_int_all_pl kick_getacch_int_all_pl proc~symba_kick_getacch_int_pl->kick_getacch_int_all_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_kick_getacch_int_pl~~CalledByGraph proc~symba_kick_getacch_int_pl symba_kick_getacch_int_pl interface~symba_kick_getacch_int_pl symba_kick_getacch_int_pl interface~symba_kick_getacch_int_pl->proc~symba_kick_getacch_int_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_kick_getacch_int_pl.html"},{"title":"symba_kick_getacch_pl – swiftest","text":"module subroutine symba_kick_getacch_pl(self, system, param, t, lbeg) Interface → Compute heliocentric accelerations of massive bodies Adapted from David E. Kaufmann's Swifter routine symba_kick_getacch.f90\n Adapted from Hal Levison's Swift routine symba5_kick_getacch.f Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step Calls proc~~symba_kick_getacch_pl~~CallsGraph proc~symba_kick_getacch_pl symba_kick_getacch_pl kick_getacch_int_all_pl kick_getacch_int_all_pl proc~symba_kick_getacch_pl->kick_getacch_int_all_pl helio_kick_getacch_pl helio_kick_getacch_pl proc~symba_kick_getacch_pl->helio_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_kick_getacch_pl~~CalledByGraph proc~symba_kick_getacch_pl symba_kick_getacch_pl interface~symba_kick_getacch_pl symba_kick_getacch_pl interface~symba_kick_getacch_pl->proc~symba_kick_getacch_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_kick_getacch_pl.html"},{"title":"symba_kick_getacch_tp – swiftest","text":"module subroutine symba_kick_getacch_tp(self, system, param, t, lbeg) Interface → Compute heliocentric accelerations of test particles Adapted from David E. Kaufmann's Swifter routine symba_kick_getacch_tp.f90\n Adapted from Hal Levison's Swift routine symba5_kick_getacch.f Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step Calls proc~~symba_kick_getacch_tp~~CallsGraph proc~symba_kick_getacch_tp symba_kick_getacch_tp helio_kick_getacch_tp helio_kick_getacch_tp proc~symba_kick_getacch_tp->helio_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_kick_getacch_tp~~CalledByGraph proc~symba_kick_getacch_tp symba_kick_getacch_tp interface~symba_kick_getacch_tp symba_kick_getacch_tp interface~symba_kick_getacch_tp->proc~symba_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_kick_getacch_tp.html"},{"title":"symba_kick_encounter – swiftest","text":"module subroutine symba_kick_encounter(self, system, dt, irec, sgn) Interface → Kick barycentric velocities of massive bodies and ACTIVE test particles within SyMBA recursion.\n Note: This method works for the polymorphic symba_pltpenc and symba_plplenc types Adapted from David E. Kaufmann's Swifter routine: symba_kick.f90\n Adapted from Hal Levison's Swift routine symba5_kick.f Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(in) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level integer(kind=I4B), intent(in) :: sgn sign to be applied to acceleration Called by proc~~symba_kick_encounter~~CalledByGraph proc~symba_kick_encounter symba_kick_encounter interface~symba_kick_encounter symba_kick_encounter interface~symba_kick_encounter->proc~symba_kick_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_kick_encounter.html"},{"title":"symba_encounter_check_pl – swiftest","text":"module function symba_encounter_check_pl(self, system, dt, irec) result(lany_encounter) Interface → Check for an encounter between massive bodies. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter Calls proc~~symba_encounter_check_pl~~CallsGraph proc~symba_encounter_check_pl symba_encounter_check_pl util_index_eucl_ij_to_k util_index_eucl_ij_to_k proc~symba_encounter_check_pl->util_index_eucl_ij_to_k proc~symba_encounter_check_all symba_encounter_check_all proc~symba_encounter_check_pl->proc~symba_encounter_check_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_encounter_check_pl~~CalledByGraph proc~symba_encounter_check_pl symba_encounter_check_pl interface~symba_encounter_check_pl symba_encounter_check_pl interface~symba_encounter_check_pl->proc~symba_encounter_check_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_encounter_check_pl.html"},{"title":"symba_encounter_check – swiftest","text":"module function symba_encounter_check(self, system, dt, irec) result(lany_encounter) Interface → Check for an encounter between test particles and massive bodies in the pltpenc list.\n Note: This method works for the polymorphic symba_pltpenc and symba_plplenc types. Adapted from portions of David E. Kaufmann's Swifter routine: symba_step_recur.f90 Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-pl encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter Called by proc~~symba_encounter_check~~CalledByGraph proc~symba_encounter_check symba_encounter_check interface~symba_encounter_check symba_encounter_check interface~symba_encounter_check->proc~symba_encounter_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_encounter_check.html"},{"title":"symba_encounter_check_tp – swiftest","text":"module function symba_encounter_check_tp(self, system, dt, irec) result(lany_encounter) Interface → Check for an encounter between test particles and massive bodies. Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter Called by proc~~symba_encounter_check_tp~~CalledByGraph proc~symba_encounter_check_tp symba_encounter_check_tp interface~symba_encounter_check_tp symba_encounter_check_tp interface~symba_encounter_check_tp->proc~symba_encounter_check_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_encounter_check_tp.html"},{"title":"symba_encounter_check_one – swiftest","text":"pure module subroutine symba_encounter_check_one(xr, yr, zr, vxr, vyr, vzr, rhill1, rhill2, dt, irec, lencounter, lvdotr) Interface → Check for an encounter. Adapted from David E. Kaufmann's Swifter routine: symba_chk.f90\n Adapted from Hal Levison's Swift routine symba5_chk.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: xr real(kind=DP), intent(in) :: yr real(kind=DP), intent(in) :: zr real(kind=DP), intent(in) :: vxr real(kind=DP), intent(in) :: vyr real(kind=DP), intent(in) :: vzr real(kind=DP), intent(in) :: rhill1 real(kind=DP), intent(in) :: rhill2 real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: irec logical, intent(out) :: lencounter logical, intent(out) :: lvdotr Calls proc~~symba_encounter_check_one~~CallsGraph proc~symba_encounter_check_one symba_encounter_check_one rmvs_chk_ind rmvs_chk_ind proc~symba_encounter_check_one->rmvs_chk_ind Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_encounter_check_one~~CalledByGraph proc~symba_encounter_check_one symba_encounter_check_one interface~symba_encounter_check_one symba_encounter_check_one interface~symba_encounter_check_one->proc~symba_encounter_check_one Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_encounter_check_one.html"},{"title":"symba_io_param_reader – swiftest","text":"module subroutine symba_io_param_reader(self, unit, iotype, v_list, iostat, iomsg) Interface → Read in parameters specific to the SyMBA integrator, then calls the base io_param_reader. Adapted from David E. Kaufmann's Swifter routine io_init_param.f90\n Adapted from Martin Duncan's Swift routine io_init_param.f Arguments Type Intent Optional Attributes Name class( symba_parameters ), intent(inout) :: self Collection of parameters integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) The first element passes the integrator code to the reader integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 Calls proc~~symba_io_param_reader~~CallsGraph proc~symba_io_param_reader symba_io_param_reader io_get_token io_get_token proc~symba_io_param_reader->io_get_token io_toupper io_toupper proc~symba_io_param_reader->io_toupper io_param_reader io_param_reader proc~symba_io_param_reader->io_param_reader fraggle_io_log_start fraggle_io_log_start proc~symba_io_param_reader->fraggle_io_log_start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_io_param_reader~~CalledByGraph proc~symba_io_param_reader symba_io_param_reader interface~symba_io_param_reader symba_io_param_reader interface~symba_io_param_reader->proc~symba_io_param_reader Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_io_param_reader.html"},{"title":"symba_io_param_writer – swiftest","text":"module subroutine symba_io_param_writer(self, unit, iotype, v_list, iostat, iomsg) Interface → Dump integration parameters specific to SyMBA to file and then call the base io_param_writer method. Adapted from David E. Kaufmann's Swifter routine io_dump_param.f90\n Adapted from Martin Duncan's Swift routine io_dump_param.f Arguments Type Intent Optional Attributes Name class( symba_parameters ), intent(in) :: self Collection of SyMBA parameters integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) Not used in this procedure integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 Calls proc~~symba_io_param_writer~~CallsGraph proc~symba_io_param_writer symba_io_param_writer io_param_writer io_param_writer proc~symba_io_param_writer->io_param_writer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_io_param_writer~~CalledByGraph proc~symba_io_param_writer symba_io_param_writer interface~symba_io_param_writer symba_io_param_writer interface~symba_io_param_writer->proc~symba_io_param_writer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_io_param_writer.html"},{"title":"symba_io_write_discard – swiftest","text":"module subroutine symba_io_write_discard(self, param) Interface → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Calls proc~~symba_io_write_discard~~CallsGraph proc~symba_io_write_discard symba_io_write_discard util_exit util_exit proc~symba_io_write_discard->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_io_write_discard~~CalledByGraph proc~symba_io_write_discard symba_io_write_discard interface~symba_io_write_discard symba_io_write_discard interface~symba_io_write_discard->proc~symba_io_write_discard Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_io_write_discard.html"},{"title":"symba_discard_pl – swiftest","text":"module subroutine symba_discard_pl(self, system, param) Interface → Call the various flavors of discards for massive bodies in SyMBA runs, including discards due to colliding with the central body or escaping the system Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Calls proc~~symba_discard_pl~~CallsGraph proc~symba_discard_pl symba_discard_pl proc~symba_discard_nonplpl symba_discard_nonplpl proc~symba_discard_pl->proc~symba_discard_nonplpl proc~symba_discard_nonplpl_conservation symba_discard_nonplpl_conservation proc~symba_discard_pl->proc~symba_discard_nonplpl_conservation proc~symba_discard_cb_pl symba_discard_cb_pl proc~symba_discard_nonplpl->proc~symba_discard_cb_pl fraggle_io_log_one_message fraggle_io_log_one_message proc~symba_discard_cb_pl->fraggle_io_log_one_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_discard_pl~~CalledByGraph proc~symba_discard_pl symba_discard_pl interface~symba_discard_pl symba_discard_pl interface~symba_discard_pl->proc~symba_discard_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_discard_pl.html"},{"title":"symba_step_system – swiftest","text":"module subroutine symba_step_system(self, param, t, dt) Interface → Step planets and active test particles ahead in democratic heliocentric coordinates, descending the recursive\n   branch if necessary to handle possible close encounters Adapted from David E. Kaufmann's Swifter routine: symba_step.f90\n Adapted from Hal Levison's Swift routine symba5_step_pl.f Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize Calls proc~~symba_step_system~~CallsGraph proc~symba_step_system symba_step_system helio_step_system helio_step_system proc~symba_step_system->helio_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_step_system~~CalledByGraph proc~symba_step_system symba_step_system interface~symba_step_system symba_step_system interface~symba_step_system->proc~symba_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_step_system.html"},{"title":"symba_step_interp_system – swiftest","text":"module subroutine symba_step_interp_system(self, param, t, dt) Interface → Step planets and active test particles ahead in democratic heliocentric coordinates, calling the recursive\n         subroutine to descend to the appropriate level to handle close encounters Adapted from David E. Kaufmann's Swifter routine: symba_step_interp.f90\n Adapted from Hal Levison's Swift routine symba5_step_interp.f Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize Called by proc~~symba_step_interp_system~~CalledByGraph proc~symba_step_interp_system symba_step_interp_system interface~symba_step_interp_system symba_step_interp_system interface~symba_step_interp_system->proc~symba_step_interp_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_step_interp_system.html"},{"title":"symba_step_set_recur_levels_system – swiftest","text":"module subroutine symba_step_set_recur_levels_system(self, ireci) Interface → Resets pl, tp,and encounter structures at the start of a new step Adapted from David E. Kaufmann's Swifter routine: symba_step_recur.f90\n Adapted from Hal Levison's Swift routine symba5_step_recur.f Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object integer(kind=I4B), intent(in) :: ireci Input recursion level Called by proc~~symba_step_set_recur_levels_system~~CalledByGraph proc~symba_step_set_recur_levels_system symba_step_set_recur_levels_system interface~symba_step_set_recur_levels_system symba_step_set_recur_levels_system interface~symba_step_set_recur_levels_system->proc~symba_step_set_recur_levels_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_step_set_recur_levels_system.html"},{"title":"symba_step_recur_system – swiftest","text":"recursive module subroutine symba_step_recur_system(self, param, t, ireci) Interface → Step interacting planets and active test particles ahead in democratic heliocentric coordinates at the current\n         recursion level, if applicable, and descend to the next deeper level if necessarys Adapted from David E. Kaufmann's Swifter routine: symba_step_recur.f90\n Adapted from Hal Levison's Swift routine symba5_step_recur.f Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: ireci input recursion level Calls proc~~symba_step_recur_system~~CallsGraph proc~symba_step_recur_system symba_step_recur_system util_exit util_exit proc~symba_step_recur_system->util_exit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_step_recur_system~~CalledByGraph proc~symba_step_recur_system symba_step_recur_system interface~symba_step_recur_system symba_step_recur_system interface~symba_step_recur_system->proc~symba_step_recur_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_step_recur_system.html"},{"title":"symba_step_reset_system – swiftest","text":"module subroutine symba_step_reset_system(self, param) Interface → Resets pl, tp,and encounter structures at the start of a new step Adapted from David E. Kaufmann's Swifter routine: symba_step.f90\n Adapted from Hal Levison's Swift routine symba5_step.f Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions Called by proc~~symba_step_reset_system~~CalledByGraph proc~symba_step_reset_system symba_step_reset_system interface~symba_step_reset_system symba_step_reset_system interface~symba_step_reset_system->proc~symba_step_reset_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_step_reset_system.html"},{"title":"symba_drift_pl – swiftest","text":"module subroutine symba_drift_pl(self, system, param, dt) Interface → Wrapper function used to call the body drift routine from a symba_pl structure Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize Calls proc~~symba_drift_pl~~CallsGraph proc~symba_drift_pl symba_drift_pl helio_drift_body helio_drift_body proc~symba_drift_pl->helio_drift_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_drift_pl~~CalledByGraph proc~symba_drift_pl symba_drift_pl interface~symba_drift_pl symba_drift_pl interface~symba_drift_pl->proc~symba_drift_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_drift_pl.html"},{"title":"symba_drift_tp – swiftest","text":"module subroutine symba_drift_tp(self, system, param, dt) Interface → Wrapper function used to call the body drift routine from a symba_pl structure Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize Calls proc~~symba_drift_tp~~CallsGraph proc~symba_drift_tp symba_drift_tp helio_drift_body helio_drift_body proc~symba_drift_tp->helio_drift_body Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~symba_drift_tp~~CalledByGraph proc~symba_drift_tp symba_drift_tp interface~symba_drift_tp symba_drift_tp interface~symba_drift_tp->proc~symba_drift_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/symba_drift_tp.html"},{"title":"netcdf_close – swiftest","text":"module subroutine netcdf_close(self, param) Interface → Closes a NetCDF file Arguments Type Intent Optional Attributes Name class( netcdf_parameters ), intent(inout) :: self Parameters used to identify a particular NetCDF dataset class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~netcdf_close~~CallsGraph proc~netcdf_close netcdf_close nf90_close nf90_close proc~netcdf_close->nf90_close Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~netcdf_close~~CalledByGraph proc~netcdf_close netcdf_close interface~netcdf_close netcdf_close interface~netcdf_close->proc~netcdf_close Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/netcdf_close.html"},{"title":"netcdf_initialize_output – swiftest","text":"module subroutine netcdf_initialize_output(self, param) Interface → Uses ieee_arithmetic proc~~netcdf_initialize_output~~UsesGraph proc~netcdf_initialize_output netcdf_initialize_output ieee_arithmetic ieee_arithmetic proc~netcdf_initialize_output->ieee_arithmetic Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Initialize a NetCDF file system and defines all variables.\n Create the new output file, deleting any previously existing output file of the same name\n Define the variables Arguments Type Intent Optional Attributes Name class( netcdf_parameters ), intent(inout) :: self Parameters used to identify a particular NetCDF dataset class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~netcdf_initialize_output~~CallsGraph proc~netcdf_initialize_output netcdf_initialize_output nf90_def_var nf90_def_var proc~netcdf_initialize_output->nf90_def_var nf90_def_dim nf90_def_dim proc~netcdf_initialize_output->nf90_def_dim nf90_create nf90_create proc~netcdf_initialize_output->nf90_create nf90_def_var_fill nf90_def_var_fill proc~netcdf_initialize_output->nf90_def_var_fill nf90_inquire nf90_inquire proc~netcdf_initialize_output->nf90_inquire nf90_inquire_variable nf90_inquire_variable proc~netcdf_initialize_output->nf90_inquire_variable Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~netcdf_initialize_output~~CalledByGraph proc~netcdf_initialize_output netcdf_initialize_output interface~netcdf_initialize_output netcdf_initialize_output interface~netcdf_initialize_output->proc~netcdf_initialize_output Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/netcdf_initialize_output.html"},{"title":"netcdf_open – swiftest","text":"module subroutine netcdf_open(self, param) Interface → Opens a NetCDF file and does the variable inquiries to activate variable ids Arguments Type Intent Optional Attributes Name class( netcdf_parameters ), intent(inout) :: self Parameters used to identify a particular NetCDF dataset class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~netcdf_open~~CallsGraph proc~netcdf_open netcdf_open nf90_inq_varid nf90_inq_varid proc~netcdf_open->nf90_inq_varid nf90_open nf90_open proc~netcdf_open->nf90_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~netcdf_open~~CalledByGraph proc~netcdf_open netcdf_open interface~netcdf_open netcdf_open interface~netcdf_open->proc~netcdf_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/netcdf_open.html"},{"title":"netcdf_write_frame_base – swiftest","text":"module subroutine netcdf_write_frame_base(self, iu, param) Interface → Write a frame of output of either test particle or massive body data to the binary output file\n    Note: If outputting to orbital elements, but sure that the conversion is done prior to calling this method Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~netcdf_write_frame_base~~CallsGraph proc~netcdf_write_frame_base netcdf_write_frame_base nf90_set_fill nf90_set_fill proc~netcdf_write_frame_base->nf90_set_fill nf90_put_var nf90_put_var proc~netcdf_write_frame_base->nf90_put_var interface~util_sort util_sort proc~netcdf_write_frame_base->interface~util_sort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~netcdf_write_frame_base~~CalledByGraph proc~netcdf_write_frame_base netcdf_write_frame_base interface~netcdf_write_frame_base netcdf_write_frame_base interface~netcdf_write_frame_base->proc~netcdf_write_frame_base Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/netcdf_write_frame_base.html"},{"title":"netcdf_write_particle_info_base – swiftest","text":"module subroutine netcdf_write_particle_info_base(self, iu) Interface → Write all current particle to file Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset Calls proc~~netcdf_write_particle_info_base~~CallsGraph proc~netcdf_write_particle_info_base netcdf_write_particle_info_base nf90_set_fill nf90_set_fill proc~netcdf_write_particle_info_base->nf90_set_fill nf90_put_var nf90_put_var proc~netcdf_write_particle_info_base->nf90_put_var interface~util_sort util_sort proc~netcdf_write_particle_info_base->interface~util_sort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~netcdf_write_particle_info_base~~CalledByGraph proc~netcdf_write_particle_info_base netcdf_write_particle_info_base interface~netcdf_write_particle_info_base netcdf_write_particle_info_base interface~netcdf_write_particle_info_base->proc~netcdf_write_particle_info_base Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/netcdf_write_particle_info_base.html"},{"title":"netcdf_write_hdr_system – swiftest","text":"module subroutine netcdf_write_hdr_system(self, iu, param) Interface → Writes header information (variables that change with time, but not particle id). \n This subroutine significantly improves the output over the original binary file, allowing us to track energy, momentum, and other quantities that \n previously were handled as separate output files. Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest nbody system object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Calls proc~~netcdf_write_hdr_system~~CallsGraph proc~netcdf_write_hdr_system netcdf_write_hdr_system nf90_put_var nf90_put_var proc~netcdf_write_hdr_system->nf90_put_var nf90_open nf90_open proc~netcdf_write_hdr_system->nf90_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~netcdf_write_hdr_system~~CalledByGraph proc~netcdf_write_hdr_system netcdf_write_hdr_system interface~netcdf_write_hdr_system netcdf_write_hdr_system interface~netcdf_write_hdr_system->proc~netcdf_write_hdr_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/netcdf_write_hdr_system.html"},{"title":"fraggle_util_vmag_to_vb – swiftest","text":"module function fraggle_util_vmag_to_vb(v_r_mag, v_r_unit, v_t_mag, v_t_unit, m_frag, vcom) result(vb) Interface → Converts radial and tangential velocity magnitudes into barycentric velocity Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: v_r_mag Unknown radial component of fragment velocity vector real(kind=DP), intent(in), dimension(:,:) :: v_r_unit Radial and tangential unit vectors for each fragment real(kind=DP), intent(in), dimension(:) :: v_t_mag Tangential component of velocity vector set previously by angular momentum constraint real(kind=DP), intent(in), dimension(:,:) :: v_t_unit Radial and tangential unit vectors for each fragment real(kind=DP), intent(in), dimension(:) :: m_frag Fragment masses real(kind=DP), intent(in), dimension(:) :: vcom Barycentric velocity of collisional system center of mass Return Value real(kind=DP),\n  dimension(:,:),allocatable Calls proc~~fraggle_util_vmag_to_vb~~CallsGraph proc~fraggle_util_vmag_to_vb fraggle_util_vmag_to_vb interface~fraggle_util_shift_vector_to_origin fraggle_util_shift_vector_to_origin proc~fraggle_util_vmag_to_vb->interface~fraggle_util_shift_vector_to_origin proc~fraggle_util_shift_vector_to_origin fraggle_util_shift_vector_to_origin interface~fraggle_util_shift_vector_to_origin->proc~fraggle_util_shift_vector_to_origin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fraggle_util_vmag_to_vb~~CalledByGraph proc~fraggle_util_vmag_to_vb fraggle_util_vmag_to_vb interface~fraggle_util_vmag_to_vb fraggle_util_vmag_to_vb interface~fraggle_util_vmag_to_vb->proc~fraggle_util_vmag_to_vb proc~fraggle_generate_tan_vel fraggle_generate_tan_vel proc~fraggle_generate_tan_vel->interface~fraggle_util_vmag_to_vb proc~fraggle_generate_rad_vel fraggle_generate_rad_vel proc~fraggle_generate_rad_vel->interface~fraggle_util_vmag_to_vb proc~fraggle_generate_fragments fraggle_generate_fragments proc~fraggle_generate_fragments->proc~fraggle_generate_tan_vel proc~fraggle_generate_fragments->proc~fraggle_generate_rad_vel interface~fraggle_generate_fragments fraggle_generate_fragments interface~fraggle_generate_fragments->proc~fraggle_generate_fragments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_util_vmag_to_vb.html"},{"title":"fraggle_util_add_fragments_to_system – swiftest","text":"module subroutine fraggle_util_add_fragments_to_system(frag, colliders, system, param) Interface → Adds fragments to the temporary system pl object Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(in) :: frag Fraggle fragment system object class( fraggle_colliders ), intent(in) :: colliders Fraggle collider system object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current swiftest run configuration parameters Called by proc~~fraggle_util_add_fragments_to_system~~CalledByGraph proc~fraggle_util_add_fragments_to_system fraggle_util_add_fragments_to_system interface~fraggle_util_add_fragments_to_system fraggle_util_add_fragments_to_system interface~fraggle_util_add_fragments_to_system->proc~fraggle_util_add_fragments_to_system proc~fraggle_util_get_energy_momentum fraggle_util_get_energy_momentum proc~fraggle_util_get_energy_momentum->interface~fraggle_util_add_fragments_to_system interface~fraggle_util_get_energy_momentum fraggle_util_get_energy_momentum interface~fraggle_util_get_energy_momentum->proc~fraggle_util_get_energy_momentum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_util_add_fragments_to_system.html"},{"title":"fraggle_util_ang_mtm – swiftest","text":"module subroutine fraggle_util_ang_mtm(self) Interface → Calcualtes the current angular momentum of the fragments Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object Called by proc~~fraggle_util_ang_mtm~~CalledByGraph proc~fraggle_util_ang_mtm fraggle_util_ang_mtm interface~fraggle_util_ang_mtm fraggle_util_ang_mtm interface~fraggle_util_ang_mtm->proc~fraggle_util_ang_mtm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_util_ang_mtm.html"},{"title":"fraggle_util_construct_temporary_system – swiftest","text":"module subroutine fraggle_util_construct_temporary_system(frag, system, param, tmpsys, tmpparam) Interface → Constructs a temporary internal system consisting of active bodies and additional fragments. This internal temporary system is used to calculate system energy with and without fragments\n and optionally including fragments. Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(in) :: frag Fraggle fragment system object class( swiftest_nbody_system ), intent(in) :: system Original swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current swiftest run configuration parameters class( swiftest_nbody_system ), intent(out), allocatable :: tmpsys Output temporary swiftest nbody system object class( swiftest_parameters ), intent(out), allocatable :: tmpparam Output temporary configuration run parameters Calls proc~~fraggle_util_construct_temporary_system~~CallsGraph proc~fraggle_util_construct_temporary_system fraggle_util_construct_temporary_system setup_construct_system setup_construct_system proc~fraggle_util_construct_temporary_system->setup_construct_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fraggle_util_construct_temporary_system~~CalledByGraph proc~fraggle_util_construct_temporary_system fraggle_util_construct_temporary_system interface~fraggle_util_construct_temporary_system fraggle_util_construct_temporary_system interface~fraggle_util_construct_temporary_system->proc~fraggle_util_construct_temporary_system proc~fraggle_util_get_energy_momentum fraggle_util_get_energy_momentum proc~fraggle_util_get_energy_momentum->interface~fraggle_util_construct_temporary_system interface~fraggle_util_get_energy_momentum fraggle_util_get_energy_momentum interface~fraggle_util_get_energy_momentum->proc~fraggle_util_get_energy_momentum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_util_construct_temporary_system.html"},{"title":"fraggle_util_get_energy_momentum – swiftest","text":"module subroutine fraggle_util_get_energy_momentum(self, colliders, system, param, lbefore) Interface → Calculates total system energy in either the pre-collision outcome state (lbefore = .true.) or the post-collision outcome state (lbefore = .false.)\n This subrourtine works by building a temporary internal massive body object out of the non-excluded bodies and optionally with fragments appended. \n This will get passed to the energy calculation subroutine so that energy is computed exactly the same way is it is in the main program. \n This will temporarily expand the massive body object in a temporary system object called tmpsys to feed it into symba_energy Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current swiftest run configuration parameters logical, intent(in) :: lbefore Flag indicating that this the \"before\" state of the system, with colliders included and fragments excluded or vice versa Calls proc~~fraggle_util_get_energy_momentum~~CallsGraph proc~fraggle_util_get_energy_momentum fraggle_util_get_energy_momentum util_exit util_exit proc~fraggle_util_get_energy_momentum->util_exit interface~fraggle_util_add_fragments_to_system fraggle_util_add_fragments_to_system proc~fraggle_util_get_energy_momentum->interface~fraggle_util_add_fragments_to_system interface~fraggle_util_construct_temporary_system fraggle_util_construct_temporary_system proc~fraggle_util_get_energy_momentum->interface~fraggle_util_construct_temporary_system proc~fraggle_util_add_fragments_to_system fraggle_util_add_fragments_to_system interface~fraggle_util_add_fragments_to_system->proc~fraggle_util_add_fragments_to_system proc~fraggle_util_construct_temporary_system fraggle_util_construct_temporary_system interface~fraggle_util_construct_temporary_system->proc~fraggle_util_construct_temporary_system setup_construct_system setup_construct_system proc~fraggle_util_construct_temporary_system->setup_construct_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fraggle_util_get_energy_momentum~~CalledByGraph proc~fraggle_util_get_energy_momentum fraggle_util_get_energy_momentum interface~fraggle_util_get_energy_momentum fraggle_util_get_energy_momentum interface~fraggle_util_get_energy_momentum->proc~fraggle_util_get_energy_momentum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_util_get_energy_momentum.html"},{"title":"fraggle_util_restructure – swiftest","text":"module subroutine fraggle_util_restructure(self, colliders, try, f_spin, r_max_start) Interface → Restructure the inputs after a failed attempt failed to find a set of positions and velocities that satisfy the energy and momentum constraints Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(in) :: colliders Fraggle collider system object integer(kind=I4B), intent(in) :: try The current number of times Fraggle has tried to find a solution real(kind=DP), intent(inout) :: f_spin Fraction of energy/momentum that goes into spin. This decreases ater a failed attempt real(kind=DP), intent(inout) :: r_max_start The maximum radial distance that the position calculation starts with. This increases after a failed attempt Called by proc~~fraggle_util_restructure~~CalledByGraph proc~fraggle_util_restructure fraggle_util_restructure interface~fraggle_util_restructure fraggle_util_restructure interface~fraggle_util_restructure->proc~fraggle_util_restructure Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_util_restructure.html"},{"title":"fraggle_util_shift_vector_to_origin – swiftest","text":"module subroutine fraggle_util_shift_vector_to_origin(m_frag, vec_frag) Interface → Adjusts the position or velocity of the fragments as needed to align them with the origin Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: m_frag Fragment masses real(kind=DP), intent(inout), dimension(:,:) :: vec_frag Fragment positions or velocities in the center of mass frame Called by proc~~fraggle_util_shift_vector_to_origin~~CalledByGraph proc~fraggle_util_shift_vector_to_origin fraggle_util_shift_vector_to_origin interface~fraggle_util_shift_vector_to_origin fraggle_util_shift_vector_to_origin interface~fraggle_util_shift_vector_to_origin->proc~fraggle_util_shift_vector_to_origin proc~fraggle_util_vmag_to_vb fraggle_util_vmag_to_vb proc~fraggle_util_vmag_to_vb->interface~fraggle_util_shift_vector_to_origin proc~fraggle_generate_pos_vec fraggle_generate_pos_vec proc~fraggle_generate_pos_vec->interface~fraggle_util_shift_vector_to_origin interface~fraggle_util_vmag_to_vb fraggle_util_vmag_to_vb interface~fraggle_util_vmag_to_vb->proc~fraggle_util_vmag_to_vb proc~fraggle_generate_fragments fraggle_generate_fragments proc~fraggle_generate_fragments->proc~fraggle_generate_pos_vec proc~fraggle_generate_tan_vel fraggle_generate_tan_vel proc~fraggle_generate_fragments->proc~fraggle_generate_tan_vel proc~fraggle_generate_rad_vel fraggle_generate_rad_vel proc~fraggle_generate_fragments->proc~fraggle_generate_rad_vel proc~fraggle_generate_tan_vel->interface~fraggle_util_vmag_to_vb proc~fraggle_generate_rad_vel->interface~fraggle_util_vmag_to_vb interface~fraggle_generate_fragments fraggle_generate_fragments interface~fraggle_generate_fragments->proc~fraggle_generate_fragments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_util_shift_vector_to_origin.html"},{"title":"fraggle_io_log_generate – swiftest","text":"module subroutine fraggle_io_log_generate(frag) Interface → Writes a log of the results of the fragment generation Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(in) :: frag Called by proc~~fraggle_io_log_generate~~CalledByGraph proc~fraggle_io_log_generate fraggle_io_log_generate interface~fraggle_io_log_generate fraggle_io_log_generate interface~fraggle_io_log_generate->proc~fraggle_io_log_generate proc~fraggle_generate_fragments fraggle_generate_fragments proc~fraggle_generate_fragments->interface~fraggle_io_log_generate interface~fraggle_generate_fragments fraggle_generate_fragments interface~fraggle_generate_fragments->proc~fraggle_generate_fragments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_io_log_generate.html"},{"title":"fraggle_io_log_one_message – swiftest","text":"module subroutine fraggle_io_log_one_message(message) Interface → Writes a single message to the fraggle log file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Called by proc~~fraggle_io_log_one_message~~CalledByGraph proc~fraggle_io_log_one_message fraggle_io_log_one_message interface~fraggle_io_log_one_message fraggle_io_log_one_message interface~fraggle_io_log_one_message->proc~fraggle_io_log_one_message proc~fraggle_generate_fragments fraggle_generate_fragments proc~fraggle_generate_fragments->interface~fraggle_io_log_one_message proc~fraggle_generate_rad_vel fraggle_generate_rad_vel proc~fraggle_generate_fragments->proc~fraggle_generate_rad_vel proc~fraggle_generate_tan_vel fraggle_generate_tan_vel proc~fraggle_generate_fragments->proc~fraggle_generate_tan_vel proc~fraggle_generate_spins fraggle_generate_spins proc~fraggle_generate_fragments->proc~fraggle_generate_spins proc~fraggle_generate_rad_vel->interface~fraggle_io_log_one_message proc~fraggle_regime_collresolve fraggle_regime_collresolve proc~fraggle_regime_collresolve->interface~fraggle_io_log_one_message proc~fraggle_generate_tan_vel->interface~fraggle_io_log_one_message proc~fraggle_generate_spins->interface~fraggle_io_log_one_message interface~fraggle_generate_fragments fraggle_generate_fragments interface~fraggle_generate_fragments->proc~fraggle_generate_fragments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_io_log_one_message.html"},{"title":"fraggle_io_log_pl – swiftest","text":"module subroutine fraggle_io_log_pl(pl, param) Interface → Writes a single message to the fraggle log file Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(in) :: pl Swiftest massive body object (only the new bodies generated in a collision) class( swiftest_parameters ), intent(in) :: param Current swiftest run configuration parameters Called by proc~~fraggle_io_log_pl~~CalledByGraph proc~fraggle_io_log_pl fraggle_io_log_pl interface~fraggle_io_log_pl fraggle_io_log_pl interface~fraggle_io_log_pl->proc~fraggle_io_log_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_io_log_pl.html"},{"title":"fraggle_io_log_regime – swiftest","text":"module subroutine fraggle_io_log_regime(colliders, frag) Interface → Writes a log of the results of the collisional regime determination Arguments Type Intent Optional Attributes Name class( fraggle_colliders ), intent(in) :: colliders Fraggle collider system object class( fraggle_fragments ), intent(in) :: frag Fraggle fragment object Called by proc~~fraggle_io_log_regime~~CalledByGraph proc~fraggle_io_log_regime fraggle_io_log_regime interface~fraggle_io_log_regime fraggle_io_log_regime interface~fraggle_io_log_regime->proc~fraggle_io_log_regime proc~fraggle_regime_colliders fraggle_regime_colliders proc~fraggle_regime_colliders->interface~fraggle_io_log_regime interface~fraggle_regime_colliders fraggle_regime_colliders interface~fraggle_regime_colliders->proc~fraggle_regime_colliders Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_io_log_regime.html"},{"title":"fraggle_io_log_start – swiftest","text":"module subroutine fraggle_io_log_start(param) Interface → Checks to see if the Fraggle log file needs to be replaced if this is a new run, or appended if this is a restarted run Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Called by proc~~fraggle_io_log_start~~CalledByGraph proc~fraggle_io_log_start fraggle_io_log_start interface~fraggle_io_log_start fraggle_io_log_start interface~fraggle_io_log_start->proc~fraggle_io_log_start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_io_log_start.html"},{"title":"fraggle_generate_fragments – swiftest","text":"module subroutine fraggle_generate_fragments(self, colliders, system, param, lfailure) Interface → Uses ieee_exceptions proc~~fraggle_generate_fragments~~UsesGraph proc~fraggle_generate_fragments fraggle_generate_fragments ieee_exceptions ieee_exceptions proc~fraggle_generate_fragments->ieee_exceptions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Generates a system of fragments in barycentric coordinates that conserves energy and momentum. Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle system object the outputs will be the fragmentation class( fraggle_colliders ), intent(inout) :: colliders Fraggle colliders object containing the two-body equivalent values of the colliding bodies class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters logical, intent(out) :: lfailure Answers the question: Should this have been a merger instead? Calls proc~~fraggle_generate_fragments~~CallsGraph proc~fraggle_generate_fragments fraggle_generate_fragments interface~fraggle_io_log_generate fraggle_io_log_generate proc~fraggle_generate_fragments->interface~fraggle_io_log_generate proc~fraggle_generate_pos_vec fraggle_generate_pos_vec proc~fraggle_generate_fragments->proc~fraggle_generate_pos_vec proc~fraggle_generate_rad_vel fraggle_generate_rad_vel proc~fraggle_generate_fragments->proc~fraggle_generate_rad_vel interface~fraggle_io_log_one_message fraggle_io_log_one_message proc~fraggle_generate_fragments->interface~fraggle_io_log_one_message proc~fraggle_generate_tan_vel fraggle_generate_tan_vel proc~fraggle_generate_fragments->proc~fraggle_generate_tan_vel proc~fraggle_generate_spins fraggle_generate_spins proc~fraggle_generate_fragments->proc~fraggle_generate_spins proc~fraggle_io_log_generate fraggle_io_log_generate interface~fraggle_io_log_generate->proc~fraggle_io_log_generate interface~fraggle_util_shift_vector_to_origin fraggle_util_shift_vector_to_origin proc~fraggle_generate_pos_vec->interface~fraggle_util_shift_vector_to_origin proc~fraggle_generate_rad_vel->interface~fraggle_io_log_one_message lambda_obj lambda_obj proc~fraggle_generate_rad_vel->lambda_obj util_minimize_bfgs util_minimize_bfgs proc~fraggle_generate_rad_vel->util_minimize_bfgs interface~fraggle_util_vmag_to_vb fraggle_util_vmag_to_vb proc~fraggle_generate_rad_vel->interface~fraggle_util_vmag_to_vb proc~fraggle_io_log_one_message fraggle_io_log_one_message interface~fraggle_io_log_one_message->proc~fraggle_io_log_one_message proc~fraggle_generate_tan_vel->interface~fraggle_io_log_one_message proc~fraggle_generate_tan_vel->lambda_obj proc~fraggle_generate_tan_vel->util_minimize_bfgs proc~fraggle_generate_tan_vel->interface~fraggle_util_vmag_to_vb proc~fraggle_generate_spins->interface~fraggle_io_log_one_message proc~fraggle_util_vmag_to_vb fraggle_util_vmag_to_vb interface~fraggle_util_vmag_to_vb->proc~fraggle_util_vmag_to_vb proc~fraggle_util_shift_vector_to_origin fraggle_util_shift_vector_to_origin interface~fraggle_util_shift_vector_to_origin->proc~fraggle_util_shift_vector_to_origin proc~fraggle_util_vmag_to_vb->interface~fraggle_util_shift_vector_to_origin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fraggle_generate_fragments~~CalledByGraph proc~fraggle_generate_fragments fraggle_generate_fragments interface~fraggle_generate_fragments fraggle_generate_fragments interface~fraggle_generate_fragments->proc~fraggle_generate_fragments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_generate_fragments.html"},{"title":"fraggle_regime_colliders – swiftest","text":"module subroutine fraggle_regime_colliders(self, frag, system, param) Interface → Determine which fragmentation regime the set of colliders will be. This subroutine is a wrapper for the non-polymorphic raggle_regime_collresolve subroutine.\n It converts to SI units prior to calling\n The two-body equivalent masses of the collider system\n The two-body equivalent radii of the collider system\n The two-body equivalent density of the collider system\n The first body of the two-body equivalent position vector the collider system\n The first body of the two-body equivalent velocity vector the collider system\n The second body of the two-body equivalent position vector the collider system\n The second body of the two-body equivalent velocity vector the collider system\n The central body mass of the system\n The minimum fragment mass to generate. Collider systems that would otherwise generate less massive fragments than this value will be forced to merge instead\n Use the positions and velocities of the parents from indside the step (at collision) to calculate the collisional regime Arguments Type Intent Optional Attributes Name class( fraggle_colliders ), intent(inout) :: self Fraggle colliders object class( fraggle_fragments ), intent(inout) :: frag Fraggle fragment system object class( swiftest_nbody_system ), intent(in) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current Swiftest run configuration parameters Calls proc~~fraggle_regime_colliders~~CallsGraph proc~fraggle_regime_colliders fraggle_regime_colliders interface~fraggle_io_log_regime fraggle_io_log_regime proc~fraggle_regime_colliders->interface~fraggle_io_log_regime proc~fraggle_io_log_regime fraggle_io_log_regime interface~fraggle_io_log_regime->proc~fraggle_io_log_regime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fraggle_regime_colliders~~CalledByGraph proc~fraggle_regime_colliders fraggle_regime_colliders interface~fraggle_regime_colliders fraggle_regime_colliders interface~fraggle_regime_colliders->proc~fraggle_regime_colliders Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_regime_colliders.html"},{"title":"fraggle_placeholder_accel – swiftest","text":"module subroutine fraggle_placeholder_accel(self, system, param, t, lbeg) Interface → The following interfaces are placeholders intended to satisfy the required abstract methods given by the parent class Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step Called by proc~~fraggle_placeholder_accel~~CalledByGraph proc~fraggle_placeholder_accel fraggle_placeholder_accel interface~fraggle_placeholder_accel fraggle_placeholder_accel interface~fraggle_placeholder_accel->proc~fraggle_placeholder_accel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_placeholder_accel.html"},{"title":"fraggle_placeholder_kick – swiftest","text":"module subroutine fraggle_placeholder_kick(self, system, param, t, dt, lbeg) Interface → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system objec class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. Called by proc~~fraggle_placeholder_kick~~CalledByGraph proc~fraggle_placeholder_kick fraggle_placeholder_kick interface~fraggle_placeholder_kick fraggle_placeholder_kick interface~fraggle_placeholder_kick->proc~fraggle_placeholder_kick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_placeholder_kick.html"},{"title":"fraggle_placeholder_step – swiftest","text":"module subroutine fraggle_placeholder_step(self, system, param, t, dt) Interface → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize Called by proc~~fraggle_placeholder_step~~CalledByGraph proc~fraggle_placeholder_step fraggle_placeholder_step interface~fraggle_placeholder_step fraggle_placeholder_step interface~fraggle_placeholder_step->proc~fraggle_placeholder_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_placeholder_step.html"},{"title":"fraggle_setup_reset_fragments – swiftest","text":"module subroutine fraggle_setup_reset_fragments(self) Interface → Resets all position and velocity-dependent fragment quantities in order to do a fresh calculation (does not reset mass, radius, or other values that get set prior to the call to fraggle_generate) Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Called by proc~~fraggle_setup_reset_fragments~~CalledByGraph proc~fraggle_setup_reset_fragments fraggle_setup_reset_fragments interface~fraggle_setup_reset_fragments fraggle_setup_reset_fragments interface~fraggle_setup_reset_fragments->proc~fraggle_setup_reset_fragments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_setup_reset_fragments.html"},{"title":"fraggle_setup_fragments – swiftest","text":"module subroutine fraggle_setup_fragments(self, n, param) Interface → Allocates arrays for n fragments in a Fraggle system. Passing n = 0 deallocates all arrays. Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self integer(kind=I4B), intent(in) :: n class( swiftest_parameters ), intent(in) :: param Calls proc~~fraggle_setup_fragments~~CallsGraph proc~fraggle_setup_fragments fraggle_setup_fragments setup_pl setup_pl proc~fraggle_setup_fragments->setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fraggle_setup_fragments~~CalledByGraph proc~fraggle_setup_fragments fraggle_setup_fragments interface~fraggle_setup_fragments fraggle_setup_fragments interface~fraggle_setup_fragments->proc~fraggle_setup_fragments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_setup_fragments.html"},{"title":"fraggle_set_budgets_fragments – swiftest","text":"module subroutine fraggle_set_budgets_fragments(self, colliders) Interface → Sets the energy and momentum budgets of the fragments based on the collider values and the before/after values of energy and momentum Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object Called by proc~~fraggle_set_budgets_fragments~~CalledByGraph proc~fraggle_set_budgets_fragments fraggle_set_budgets_fragments interface~fraggle_set_budgets_fragments fraggle_set_budgets_fragments interface~fraggle_set_budgets_fragments->proc~fraggle_set_budgets_fragments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_set_budgets_fragments.html"},{"title":"fraggle_set_mass_dist_fragments – swiftest","text":"module subroutine fraggle_set_mass_dist_fragments(self, colliders, param) Interface → Sets the mass of fragments based on the mass distribution returned by the regime calculation.\n This subroutine must be run after the the setup rourtine has been run on the fragments Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object class( swiftest_parameters ), intent(in) :: param Current Swiftest run configuration parameters Called by proc~~fraggle_set_mass_dist_fragments~~CalledByGraph proc~fraggle_set_mass_dist_fragments fraggle_set_mass_dist_fragments interface~fraggle_set_mass_dist_fragments fraggle_set_mass_dist_fragments interface~fraggle_set_mass_dist_fragments->proc~fraggle_set_mass_dist_fragments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_set_mass_dist_fragments.html"},{"title":"fraggle_set_coordinate_system – swiftest","text":"module subroutine fraggle_set_coordinate_system(self, colliders) Interface → Defines the collisional coordinate system, including the unit vectors of both the system and individual fragments. Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object Called by proc~~fraggle_set_coordinate_system~~CalledByGraph proc~fraggle_set_coordinate_system fraggle_set_coordinate_system interface~fraggle_set_coordinate_system fraggle_set_coordinate_system interface~fraggle_set_coordinate_system->proc~fraggle_set_coordinate_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_set_coordinate_system.html"},{"title":"fraggle_set_natural_scale_factors – swiftest","text":"module subroutine fraggle_set_natural_scale_factors(self, colliders) Interface → Scales dimenional quantities to ~O(1) with respect to the collisional system. \n This scaling makes it easier for the non-linear minimization to converge on a solution Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object Called by proc~~fraggle_set_natural_scale_factors~~CalledByGraph proc~fraggle_set_natural_scale_factors fraggle_set_natural_scale_factors interface~fraggle_set_natural_scale_factors fraggle_set_natural_scale_factors interface~fraggle_set_natural_scale_factors->proc~fraggle_set_natural_scale_factors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_set_natural_scale_factors.html"},{"title":"fraggle_set_original_scale_factors – swiftest","text":"module subroutine fraggle_set_original_scale_factors(self, colliders) Interface → Uses ieee_exceptions proc~~fraggle_set_original_scale_factors~~UsesGraph proc~fraggle_set_original_scale_factors fraggle_set_original_scale_factors ieee_exceptions ieee_exceptions proc~fraggle_set_original_scale_factors->ieee_exceptions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Restores dimenional quantities back to the system units Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object Called by proc~~fraggle_set_original_scale_factors~~CalledByGraph proc~fraggle_set_original_scale_factors fraggle_set_original_scale_factors interface~fraggle_set_original_scale_factors fraggle_set_original_scale_factors interface~fraggle_set_original_scale_factors->proc~fraggle_set_original_scale_factors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fraggle_set_original_scale_factors.html"},{"title":"rmvs_discard_tp – swiftest","text":"module subroutine rmvs_discard_tp(self, system, param) Interface → Check to see if test particles should be discarded based on pericenter passage distances with respect to planets encountered Adapted from Hal Levison's Swift routine discard_pl.f\n Adapted from Hal Levison's Swift routine rmvs_discard_pl.f90 Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters Calls proc~~rmvs_discard_tp~~CallsGraph proc~rmvs_discard_tp rmvs_discard_tp discard_tp discard_tp proc~rmvs_discard_tp->discard_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_discard_tp~~CalledByGraph proc~rmvs_discard_tp rmvs_discard_tp interface~rmvs_discard_tp rmvs_discard_tp interface~rmvs_discard_tp->proc~rmvs_discard_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_discard_tp.html"},{"title":"rmvs_util_append_pl – swiftest","text":"module subroutine rmvs_util_append_pl(self, source, lsource_mask) Interface → Append components from one massive body object to another. \n This method will automatically resize the destination body if it is too small\n Arguments Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~rmvs_util_append_pl~~CallsGraph proc~rmvs_util_append_pl rmvs_util_append_pl util_exit util_exit proc~rmvs_util_append_pl->util_exit util_append util_append proc~rmvs_util_append_pl->util_append whm_util_append_pl whm_util_append_pl proc~rmvs_util_append_pl->whm_util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_append_pl~~CalledByGraph proc~rmvs_util_append_pl rmvs_util_append_pl interface~rmvs_util_append_pl rmvs_util_append_pl interface~rmvs_util_append_pl->proc~rmvs_util_append_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_append_pl.html"},{"title":"rmvs_util_append_tp – swiftest","text":"module subroutine rmvs_util_append_tp(self, source, lsource_mask) Interface → Append components from test particle object to another. \n This method will automatically resize the destination body if it is too small\n Arguments Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to Calls proc~~rmvs_util_append_tp~~CallsGraph proc~rmvs_util_append_tp rmvs_util_append_tp util_exit util_exit proc~rmvs_util_append_tp->util_exit util_append_tp util_append_tp proc~rmvs_util_append_tp->util_append_tp util_append util_append proc~rmvs_util_append_tp->util_append Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_append_tp~~CalledByGraph proc~rmvs_util_append_tp rmvs_util_append_tp interface~rmvs_util_append_tp rmvs_util_append_tp interface~rmvs_util_append_tp->proc~rmvs_util_append_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_append_tp.html"},{"title":"rmvs_util_fill_pl – swiftest","text":"module subroutine rmvs_util_fill_pl(self, inserts, lfill_list) Interface → Insert new RMVS massive body structure into an old one. \n This is the inverse of a fill operation. Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Calls proc~~rmvs_util_fill_pl~~CallsGraph proc~rmvs_util_fill_pl rmvs_util_fill_pl util_exit util_exit proc~rmvs_util_fill_pl->util_exit util_fill util_fill proc~rmvs_util_fill_pl->util_fill whm_util_fill_pl whm_util_fill_pl proc~rmvs_util_fill_pl->whm_util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_fill_pl~~CalledByGraph proc~rmvs_util_fill_pl rmvs_util_fill_pl interface~rmvs_util_fill_pl rmvs_util_fill_pl interface~rmvs_util_fill_pl->proc~rmvs_util_fill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_fill_pl.html"},{"title":"rmvs_util_fill_tp – swiftest","text":"module subroutine rmvs_util_fill_tp(self, inserts, lfill_list) Interface → Insert new RMVS test particle structure into an old one. \n This is the inverse of a fill operation. Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps Calls proc~~rmvs_util_fill_tp~~CallsGraph proc~rmvs_util_fill_tp rmvs_util_fill_tp util_exit util_exit proc~rmvs_util_fill_tp->util_exit util_fill_tp util_fill_tp proc~rmvs_util_fill_tp->util_fill_tp util_fill util_fill proc~rmvs_util_fill_tp->util_fill Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_fill_tp~~CalledByGraph proc~rmvs_util_fill_tp rmvs_util_fill_tp interface~rmvs_util_fill_tp rmvs_util_fill_tp interface~rmvs_util_fill_tp->proc~rmvs_util_fill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_fill_tp.html"},{"title":"rmvs_util_resize_pl – swiftest","text":"module subroutine rmvs_util_resize_pl(self, nnew) Interface → Checks the current size of a massive body object against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in) :: nnew New size neded Calls proc~~rmvs_util_resize_pl~~CallsGraph proc~rmvs_util_resize_pl rmvs_util_resize_pl util_resize util_resize proc~rmvs_util_resize_pl->util_resize whm_util_resize_pl whm_util_resize_pl proc~rmvs_util_resize_pl->whm_util_resize_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_resize_pl~~CalledByGraph proc~rmvs_util_resize_pl rmvs_util_resize_pl interface~rmvs_util_resize_pl rmvs_util_resize_pl interface~rmvs_util_resize_pl->proc~rmvs_util_resize_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_resize_pl.html"},{"title":"rmvs_util_resize_tp – swiftest","text":"module subroutine rmvs_util_resize_tp(self, nnew) Interface → Checks the current size of a test particle object against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: nnew New size neded Calls proc~~rmvs_util_resize_tp~~CallsGraph proc~rmvs_util_resize_tp rmvs_util_resize_tp util_resize_tp util_resize_tp proc~rmvs_util_resize_tp->util_resize_tp util_resize util_resize proc~rmvs_util_resize_tp->util_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_resize_tp~~CalledByGraph proc~rmvs_util_resize_tp rmvs_util_resize_tp interface~rmvs_util_resize_tp rmvs_util_resize_tp interface~rmvs_util_resize_tp->proc~rmvs_util_resize_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_resize_tp.html"},{"title":"rmvs_util_sort_pl – swiftest","text":"module subroutine rmvs_util_sort_pl(self, sortby, ascending) Interface → Sort a RMVS massive body object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order Calls proc~~rmvs_util_sort_pl~~CallsGraph proc~rmvs_util_sort_pl rmvs_util_sort_pl whm_util_sort_pl whm_util_sort_pl proc~rmvs_util_sort_pl->whm_util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_sort_pl~~CalledByGraph proc~rmvs_util_sort_pl rmvs_util_sort_pl interface~rmvs_util_sort_pl rmvs_util_sort_pl interface~rmvs_util_sort_pl->proc~rmvs_util_sort_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_sort_pl.html"},{"title":"rmvs_util_sort_tp – swiftest","text":"module subroutine rmvs_util_sort_tp(self, sortby, ascending) Interface → Sort a RMVS test particle object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order Calls proc~~rmvs_util_sort_tp~~CallsGraph proc~rmvs_util_sort_tp rmvs_util_sort_tp util_sort_tp util_sort_tp proc~rmvs_util_sort_tp->util_sort_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_sort_tp~~CalledByGraph proc~rmvs_util_sort_tp rmvs_util_sort_tp interface~rmvs_util_sort_tp rmvs_util_sort_tp interface~rmvs_util_sort_tp->proc~rmvs_util_sort_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_sort_tp.html"},{"title":"rmvs_util_sort_rearrange_pl – swiftest","text":"module subroutine rmvs_util_sort_rearrange_pl(self, ind) Interface → Rearrange RMVS massive body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) Calls proc~~rmvs_util_sort_rearrange_pl~~CallsGraph proc~rmvs_util_sort_rearrange_pl rmvs_util_sort_rearrange_pl util_sort_rearrange_pl util_sort_rearrange_pl proc~rmvs_util_sort_rearrange_pl->util_sort_rearrange_pl util_sort_rearrange util_sort_rearrange proc~rmvs_util_sort_rearrange_pl->util_sort_rearrange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_sort_rearrange_pl~~CalledByGraph proc~rmvs_util_sort_rearrange_pl rmvs_util_sort_rearrange_pl interface~rmvs_util_sort_rearrange_pl rmvs_util_sort_rearrange_pl interface~rmvs_util_sort_rearrange_pl->proc~rmvs_util_sort_rearrange_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_sort_rearrange_pl.html"},{"title":"rmvs_util_sort_rearrange_tp – swiftest","text":"module subroutine rmvs_util_sort_rearrange_tp(self, ind) Interface → Rearrange RMVS test particle object in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) Calls proc~~rmvs_util_sort_rearrange_tp~~CallsGraph proc~rmvs_util_sort_rearrange_tp rmvs_util_sort_rearrange_tp util_sort_rearrange util_sort_rearrange proc~rmvs_util_sort_rearrange_tp->util_sort_rearrange util_sort_rearrange_tp util_sort_rearrange_tp proc~rmvs_util_sort_rearrange_tp->util_sort_rearrange_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_sort_rearrange_tp~~CalledByGraph proc~rmvs_util_sort_rearrange_tp rmvs_util_sort_rearrange_tp interface~rmvs_util_sort_rearrange_tp rmvs_util_sort_rearrange_tp interface~rmvs_util_sort_rearrange_tp->proc~rmvs_util_sort_rearrange_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_sort_rearrange_tp.html"},{"title":"rmvs_util_spill_pl – swiftest","text":"module subroutine rmvs_util_spill_pl(self, discards, lspill_list, ldestructive) Interface → Move spilled (discarded) RMVS test particle structure from active list to discard list Adapted from David E. Kaufmann's Swifter routine discard_discard_spill.f90 Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not Calls proc~~rmvs_util_spill_pl~~CallsGraph proc~rmvs_util_spill_pl rmvs_util_spill_pl util_exit util_exit proc~rmvs_util_spill_pl->util_exit whm_util_spill_pl whm_util_spill_pl proc~rmvs_util_spill_pl->whm_util_spill_pl util_spill util_spill proc~rmvs_util_spill_pl->util_spill Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_spill_pl~~CalledByGraph proc~rmvs_util_spill_pl rmvs_util_spill_pl interface~rmvs_util_spill_pl rmvs_util_spill_pl interface~rmvs_util_spill_pl->proc~rmvs_util_spill_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_spill_pl.html"},{"title":"rmvs_util_spill_tp – swiftest","text":"module subroutine rmvs_util_spill_tp(self, discards, lspill_list, ldestructive) Interface → Move spilled (discarded) RMVS test particle structure from active list to discard list Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90 Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not Calls proc~~rmvs_util_spill_tp~~CallsGraph proc~rmvs_util_spill_tp rmvs_util_spill_tp util_exit util_exit proc~rmvs_util_spill_tp->util_exit util_spill util_spill proc~rmvs_util_spill_tp->util_spill util_spill_tp util_spill_tp proc~rmvs_util_spill_tp->util_spill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_util_spill_tp~~CalledByGraph proc~rmvs_util_spill_tp rmvs_util_spill_tp interface~rmvs_util_spill_tp rmvs_util_spill_tp interface~rmvs_util_spill_tp->proc~rmvs_util_spill_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_util_spill_tp.html"},{"title":"rmvs_kick_getacch_tp – swiftest","text":"module subroutine rmvs_kick_getacch_tp(self, system, param, t, lbeg) Interface → Compute the oblateness acceleration in the inner encounter region with planets Performs a similar task as David E. Kaufmann's Swifter routine rmvs_kick_getacch_tp.f90, but \n uses object polymorphism, and so is not directly adapted. Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest central body particle data structuree class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step Calls proc~~rmvs_kick_getacch_tp~~CallsGraph proc~rmvs_kick_getacch_tp rmvs_kick_getacch_tp whm_kick_getacch_tp whm_kick_getacch_tp proc~rmvs_kick_getacch_tp->whm_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_kick_getacch_tp~~CalledByGraph proc~rmvs_kick_getacch_tp rmvs_kick_getacch_tp interface~rmvs_kick_getacch_tp rmvs_kick_getacch_tp interface~rmvs_kick_getacch_tp->proc~rmvs_kick_getacch_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_kick_getacch_tp.html"},{"title":"rmvs_io_write_encounter – swiftest","text":"module subroutine rmvs_io_write_encounter(t, id1, id2, Gmass1, Gmass2, radius1, radius2, xh1, xh2, vh1, vh2, enc_out) Interface → Write close encounter data from RMVS to output binary files\n  There is no direct file output from this subroutine Adapted from David E. Kaufmann's Swifter routine: io_write_encounter.f90\n Adapted from Hal Levison's Swift routine io_write_encounter.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: id1 integer(kind=I4B), intent(in) :: id2 real(kind=DP), intent(in) :: Gmass1 real(kind=DP), intent(in) :: Gmass2 real(kind=DP), intent(in) :: radius1 real(kind=DP), intent(in) :: radius2 real(kind=DP), intent(in), dimension(:) :: xh1 real(kind=DP), intent(in), dimension(:) :: xh2 real(kind=DP), intent(in), dimension(:) :: vh1 real(kind=DP), intent(in), dimension(:) :: vh2 character(len=*), intent(in) :: enc_out Calls proc~~rmvs_io_write_encounter~~CallsGraph proc~rmvs_io_write_encounter rmvs_io_write_encounter util_exit util_exit proc~rmvs_io_write_encounter->util_exit io_write_frame_encounter io_write_frame_encounter proc~rmvs_io_write_encounter->io_write_frame_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_io_write_encounter~~CalledByGraph proc~rmvs_io_write_encounter rmvs_io_write_encounter interface~rmvs_io_write_encounter rmvs_io_write_encounter interface~rmvs_io_write_encounter->proc~rmvs_io_write_encounter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_io_write_encounter.html"},{"title":"rmvs_setup_pl – swiftest","text":"module subroutine rmvs_setup_pl(self, n, param) Interface → Allocate RMVS test particle structure Equivalent in functionality to David E. Kaufmann's Swifter routine rmvs_setup.f90\n Call allocation method for parent class Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameter Calls proc~~rmvs_setup_pl~~CallsGraph proc~rmvs_setup_pl rmvs_setup_pl whm_setup_pl whm_setup_pl proc~rmvs_setup_pl->whm_setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_setup_pl~~CalledByGraph proc~rmvs_setup_pl rmvs_setup_pl interface~rmvs_setup_pl rmvs_setup_pl interface~rmvs_setup_pl->proc~rmvs_setup_pl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_setup_pl.html"},{"title":"rmvs_setup_initialize_system – swiftest","text":"module subroutine rmvs_setup_initialize_system(self, param) Interface → Initialize an RMVS nbody system from files and sets up the planetocentric structures. We currently rearrange the pl order to keep it consistent with the way Swifter does it \n In Swifter, the central body occupies the first position in the pl list, and during\n encounters, the encountering planet is skipped in loops. In Swiftest, we instantiate an\n RMVS nbody system object attached to each pl to store planetocentric versions of the system\n to use during close encounters. Arguments Type Intent Optional Attributes Name class( rmvs_nbody_system ), intent(inout) :: self RMVS system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters Calls proc~~rmvs_setup_initialize_system~~CallsGraph proc~rmvs_setup_initialize_system rmvs_setup_initialize_system whm_setup_initialize_system whm_setup_initialize_system proc~rmvs_setup_initialize_system->whm_setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_setup_initialize_system~~CalledByGraph proc~rmvs_setup_initialize_system rmvs_setup_initialize_system interface~rmvs_setup_initialize_system rmvs_setup_initialize_system interface~rmvs_setup_initialize_system->proc~rmvs_setup_initialize_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_setup_initialize_system.html"},{"title":"rmvs_setup_tp – swiftest","text":"module subroutine rmvs_setup_tp(self, n, param) Interface → Allocate WHM test particle structure Equivalent in functionality to David E. Kaufmann's Swifter routine whm_setup.f90\n Call allocation method for parent class. In this case, whm does not have its own setup method, so we use the base method for swiftest_tp Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameter Calls proc~~rmvs_setup_tp~~CallsGraph proc~rmvs_setup_tp rmvs_setup_tp setup_tp setup_tp proc~rmvs_setup_tp->setup_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_setup_tp~~CalledByGraph proc~rmvs_setup_tp rmvs_setup_tp interface~rmvs_setup_tp rmvs_setup_tp interface~rmvs_setup_tp->proc~rmvs_setup_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_setup_tp.html"},{"title":"rmvs_step_system – swiftest","text":"module subroutine rmvs_step_system(self, param, t, dt) Interface → Step massive bodies and and active test particles ahead in heliocentric coordinates Adapted from Hal Levison's Swift routine rmvs3_step.f\n Adapted from David E. Kaufmann's Swifter routine rmvs_step.f90 Arguments Type Intent Optional Attributes Name class( rmvs_nbody_system ), intent(inout) :: self RMVS nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current stepsiz Calls proc~~rmvs_step_system~~CallsGraph proc~rmvs_step_system rmvs_step_system proc~rmvs_step_out rmvs_step_out proc~rmvs_step_system->proc~rmvs_step_out whm_step_system whm_step_system proc~rmvs_step_system->whm_step_system proc~rmvs_interp_out rmvs_interp_out proc~rmvs_step_system->proc~rmvs_interp_out proc~rmvs_interp_in rmvs_interp_in proc~rmvs_step_out->proc~rmvs_interp_in proc~rmvs_step_in rmvs_step_in proc~rmvs_step_out->proc~rmvs_step_in util_exit util_exit proc~rmvs_interp_out->util_exit proc~rmvs_interp_in->util_exit proc~rmvs_make_planetocentric rmvs_make_planetocentric proc~rmvs_step_in->proc~rmvs_make_planetocentric proc~rmvs_peri_tp rmvs_peri_tp proc~rmvs_step_in->proc~rmvs_peri_tp proc~rmvs_end_planetocentric rmvs_end_planetocentric proc~rmvs_step_in->proc~rmvs_end_planetocentric vpc vpc proc~rmvs_peri_tp->vpc xpc xpc proc~rmvs_peri_tp->xpc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmvs_step_system~~CalledByGraph proc~rmvs_step_system rmvs_step_system interface~rmvs_step_system rmvs_step_system interface~rmvs_step_system->proc~rmvs_step_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_step_system.html"},{"title":"rmvs_encounter_check_tp – swiftest","text":"module function rmvs_encounter_check_tp(self, system, dt) result(lencounter) Interface → Determine whether a test particle and planet are having or will have an encounter within the next time step Adapted from David E. Kaufmann's Swifter routine: rmvs_chk.f90\n Adapted from Hal Levison's Swift routine rmvs3_chk.f Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class( rmvs_nbody_system ), intent(inout) :: system RMVS nbody system object real(kind=DP), intent(in) :: dt step size Return Value logical Returns true if there is at least one close encounter Called by proc~~rmvs_encounter_check_tp~~CalledByGraph proc~rmvs_encounter_check_tp rmvs_encounter_check_tp interface~rmvs_encounter_check_tp rmvs_encounter_check_tp interface~rmvs_encounter_check_tp->proc~rmvs_encounter_check_tp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_encounter_check_tp.html"},{"title":"rmvs_chk_ind – swiftest","text":"pure module subroutine rmvs_chk_ind(xr, yr, zr, vxr, vyr, vzr, dt, r2crit, lencounter, lvdotr) Interface → Determine whether a test particle and planet are having or will have an encounter within the next time step Adapted from David E. Kaufmann's Swifter routine: rmvs_chk_ind.f90\n Adapted from Hal Levison's Swift routine rmvs_chk_ind.f Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: xr Relative distance vector components real(kind=DP), intent(in) :: yr Relative distance vector components real(kind=DP), intent(in) :: zr Relative distance vector components real(kind=DP), intent(in) :: vxr Relative velocity vector components real(kind=DP), intent(in) :: vyr Relative velocity vector components real(kind=DP), intent(in) :: vzr Relative velocity vector components real(kind=DP), intent(in) :: dt Step size real(kind=DP), intent(in) :: r2crit Square of the critical encounter distance logical, intent(out) :: lencounter Flag indicating that an encounter has occurred logical, intent(out) :: lvdotr Logical flag indicating the direction of the v .dot. r vector Called by proc~~rmvs_chk_ind~~CalledByGraph proc~rmvs_chk_ind rmvs_chk_ind interface~rmvs_chk_ind rmvs_chk_ind interface~rmvs_chk_ind->proc~rmvs_chk_ind Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmvs_chk_ind.html"},{"title":"orbel – swiftest","text":"Uses swiftest module~~orbel~~UsesGraph module~orbel orbel module~swiftest swiftest module~orbel->module~swiftest module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines xv2el Subroutines public pure elemental subroutine xv2el (mu, px, py, pz, vx, vy, vz, a, e, inc, capom, omega, capm) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: mu real(kind=8), intent(in) :: px real(kind=8), intent(in) :: py real(kind=8), intent(in) :: pz real(kind=8), intent(in) :: vx real(kind=8), intent(in) :: vy real(kind=8), intent(in) :: vz real(kind=8), intent(out) :: a real(kind=8), intent(out) :: e real(kind=8), intent(out) :: inc real(kind=8), intent(out) :: capom real(kind=8), intent(out) :: omega real(kind=8), intent(out) :: capm","tags":"","loc":"module/orbel.html"},{"title":"rmvs_classes – swiftest","text":"Definition of classes and methods specific to the Regularized Mixed Variable Symplectic (RMVS) integrator\n Partially adapted from David E. Kaufmann's Swifter module: module_rmvs.f90 rmvs_cb class definitions and method interfaces rmvs_tp class definitions and method interfaces RMVS test particle class rmvs_pl class definitions and method interfaces Uses swiftest_globals whm_classes module~~rmvs_classes~~UsesGraph module~rmvs_classes rmvs_classes module~swiftest_globals swiftest_globals module~rmvs_classes->module~swiftest_globals module~whm_classes whm_classes module~rmvs_classes->module~whm_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~swiftest_classes swiftest_classes module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: s_rmvs_chk s_rmvs_discard s_rmvs_io s_rmvs_kick s_rmvs_setup s_rmvs_step s_rmvs_util module~~rmvs_classes~~UsedByGraph module~rmvs_classes rmvs_classes module~s_rmvs_io s_rmvs_io module~s_rmvs_io->module~rmvs_classes module~swiftest swiftest module~s_rmvs_io->module~swiftest module~s_rmvs_chk s_rmvs_chk module~s_rmvs_chk->module~rmvs_classes module~s_rmvs_chk->module~swiftest module~s_rmvs_discard s_rmvs_discard module~s_rmvs_discard->module~rmvs_classes module~s_rmvs_discard->module~swiftest module~s_rmvs_step s_rmvs_step module~s_rmvs_step->module~rmvs_classes module~s_rmvs_step->module~swiftest module~swiftest->module~rmvs_classes module~s_rmvs_setup s_rmvs_setup module~s_rmvs_setup->module~rmvs_classes module~s_rmvs_setup->module~swiftest module~s_rmvs_kick s_rmvs_kick module~s_rmvs_kick->module~rmvs_classes module~s_rmvs_kick->module~swiftest module~s_rmvs_util s_rmvs_util module~s_rmvs_util->module~rmvs_classes module~s_rmvs_util->module~swiftest module~s_fraggle_placeholder s_fraggle_placeholder module~s_fraggle_placeholder->module~swiftest module~s_gr s_gr module~s_gr->module~swiftest module~s_util_valid s_util_valid module~s_util_valid->module~swiftest module~s_symba_collision s_symba_collision module~s_symba_collision->module~swiftest module~s_obl s_obl module~s_obl->module~swiftest module~s_fraggle_setup s_fraggle_setup module~s_fraggle_setup->module~swiftest module~s_util_coord s_util_coord module~s_util_coord->module~swiftest module~s_symba_encounter_check s_symba_encounter_check module~s_symba_encounter_check->module~swiftest module~s_whm_coord s_whm_coord module~s_whm_coord->module~swiftest module~s_util_rescale s_util_rescale module~s_util_rescale->module~swiftest module~s_util_get_energy_momentum s_util_get_energy_momentum module~s_util_get_energy_momentum->module~swiftest module~s_util_index s_util_index module~s_util_index->module~swiftest proc~ge_wpp ge_wpp proc~ge_wpp->module~swiftest module~s_operator_cross s_operator_cross module~s_operator_cross->module~swiftest module~s_fraggle_set s_fraggle_set module~s_fraggle_set->module~swiftest module~s_fraggle_io s_fraggle_io module~s_fraggle_io->module~swiftest module~s_util_set s_util_set module~s_util_set->module~swiftest module~s_util_version s_util_version module~s_util_version->module~swiftest module~s_tides_step_spin s_tides_step_spin module~s_tides_step_spin->module~swiftest proc~solve_wbs solve_wbs proc~solve_wbs->module~swiftest module~s_orbel s_orbel module~s_orbel->module~swiftest module~s_whm_gr s_whm_gr module~s_whm_gr->module~swiftest module~s_fraggle_regime s_fraggle_regime module~s_fraggle_regime->module~swiftest module~s_util_exit s_util_exit module~s_util_exit->module~swiftest module~s_netcdf s_netcdf module~s_netcdf->module~swiftest module~s_util_peri s_util_peri module~s_util_peri->module~swiftest module~s_helio_drift s_helio_drift module~s_helio_drift->module~swiftest module~s_setup s_setup module~s_setup->module~swiftest module~s_helio_kick s_helio_kick module~s_helio_kick->module~swiftest module~s_util_append s_util_append module~s_util_append->module~swiftest program~swiftest_driver swiftest_driver program~swiftest_driver->module~swiftest module~s_symba_step s_symba_step module~s_symba_step->module~swiftest module~s_symba_util s_symba_util module~s_symba_util->module~swiftest module~s_util_copy s_util_copy module~s_util_copy->module~swiftest module~s_discard s_discard module~s_discard->module~swiftest module~s_util_sort s_util_sort module~s_util_sort->module~swiftest module~s_whm_setup s_whm_setup module~s_whm_setup->module~swiftest module~s_util_resize s_util_resize module~s_util_resize->module~swiftest module~s_helio_gr s_helio_gr module~s_helio_gr->module~swiftest module~orbel orbel module~orbel->module~swiftest module~s_whm_util s_whm_util module~s_whm_util->module~swiftest module~s_util_spill s_util_spill module~s_util_spill->module~swiftest module~s_util_minimize_bfgs s_util_minimize_bfgs module~s_util_minimize_bfgs->module~swiftest module~s_user_kick_getacch s_user_kick_getacch module~s_user_kick_getacch->module~swiftest module~s_whm_kick s_whm_kick module~s_whm_kick->module~swiftest module~s_symba_discard s_symba_discard module~s_symba_discard->module~swiftest module~s_symba_drift s_symba_drift module~s_symba_drift->module~swiftest module~whm_drift whm_drift module~whm_drift->module~swiftest module~s_tides_kick_getacch s_tides_kick_getacch module~s_tides_kick_getacch->module~swiftest module~s_util_fill s_util_fill module~s_util_fill->module~swiftest module~s_io s_io module~s_io->module~swiftest module~s_helio_setup s_helio_setup module~s_helio_setup->module~swiftest module~s_symba_kick s_symba_kick module~s_symba_kick->module~swiftest module~s_fraggle_util s_fraggle_util module~s_fraggle_util->module~swiftest module~s_util_solve s_util_solve module~s_util_solve->module~swiftest module~s_helio_step s_helio_step module~s_helio_step->module~swiftest module~s_whm_step s_whm_step module~s_whm_step->module~swiftest module~s_symba_setup s_symba_setup module~s_symba_setup->module~swiftest module~s_fraggle_generate s_fraggle_generate module~s_fraggle_generate->module~swiftest module~s_symba_io s_symba_io module~s_symba_io->module~swiftest module~s_kick s_kick module~s_kick->module~swiftest module~drift_implementation drift_implementation module~drift_implementation->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables NTENC NTPHENC NTPENC RHSCALE RHPSCALE FACQDT Interfaces rmvs_encounter_check_tp rmvs_chk_ind rmvs_discard_tp rmvs_io_write_encounter rmvs_kick_getacch_tp rmvs_setup_pl rmvs_setup_initialize_system rmvs_setup_tp rmvs_util_append_pl rmvs_util_append_tp rmvs_util_fill_pl rmvs_util_fill_tp rmvs_util_resize_pl rmvs_util_resize_tp rmvs_util_sort_pl rmvs_util_sort_tp rmvs_util_sort_rearrange_pl rmvs_util_sort_rearrange_tp rmvs_util_spill_pl rmvs_util_spill_tp rmvs_step_system Derived Types rmvs_nbody_system rmvs_interp rmvs_cb rmvs_tp rmvs_pl Variables Type Visibility Attributes Name Initial integer(kind=I4B), private, parameter :: NTENC = 10 integer(kind=I4B), private, parameter :: NTPHENC = 3 integer(kind=I4B), private, parameter :: NTPENC = NTENC*NTPHENC real(kind=DP), private, parameter :: RHSCALE = 3.5_DP real(kind=DP), private, parameter :: RHPSCALE = 1.0_DP real(kind=DP), private, parameter :: FACQDT = 2.0_DP rmvs_nbody_system class definitions and method interfaces Interfaces interface public module function rmvs_encounter_check_tp(self, system, dt) result(lencounter) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class( rmvs_nbody_system ), intent(inout) :: system RMVS nbody system object real(kind=DP), intent(in) :: dt step size Return Value logical Returns true if there is at least one close encounter interface public pure module subroutine rmvs_chk_ind(xr, yr, zr, vxr, vyr, vzr, dt, r2crit, lencounter, lvdotr) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: xr Relative distance vector components real(kind=DP), intent(in) :: yr Relative distance vector components real(kind=DP), intent(in) :: zr Relative distance vector components real(kind=DP), intent(in) :: vxr Relative velocity vector components real(kind=DP), intent(in) :: vyr Relative velocity vector components real(kind=DP), intent(in) :: vzr Relative velocity vector components real(kind=DP), intent(in) :: dt Step size real(kind=DP), intent(in) :: r2crit Square of the critical encounter distance logical, intent(out) :: lencounter Flag indicating that an encounter has occurred logical, intent(out) :: lvdotr Logical flag indicating the direction of the v .dot. r vector interface public module subroutine rmvs_discard_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters interface public module subroutine rmvs_io_write_encounter(t, id1, id2, Gmass1, Gmass2, radius1, radius2, xh1, xh2, vh1, vh2, enc_out) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: id1 integer(kind=I4B), intent(in) :: id2 real(kind=DP), intent(in) :: Gmass1 real(kind=DP), intent(in) :: Gmass2 real(kind=DP), intent(in) :: radius1 real(kind=DP), intent(in) :: radius2 real(kind=DP), intent(in), dimension(:) :: xh1 real(kind=DP), intent(in), dimension(:) :: xh2 real(kind=DP), intent(in), dimension(:) :: vh1 real(kind=DP), intent(in), dimension(:) :: vh2 character(len=*), intent(in) :: enc_out interface public module subroutine rmvs_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest central body particle data structuree class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step interface public module subroutine rmvs_setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameters interface public module subroutine rmvs_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_nbody_system ), intent(inout) :: self RMVS system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters interface public module subroutine rmvs_setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parametere interface public module subroutine rmvs_util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine rmvs_util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine rmvs_util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps interface public module subroutine rmvs_util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps interface public module subroutine rmvs_util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in) :: nnew New size neded interface public module subroutine rmvs_util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: nnew New size neded interface public module subroutine rmvs_util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order interface public module subroutine rmvs_util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order interface public module subroutine rmvs_util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) interface public module subroutine rmvs_util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) interface public module subroutine rmvs_util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not interface public module subroutine rmvs_util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not interface public module subroutine rmvs_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( rmvs_nbody_system ), intent(inout) :: self RMVS nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize Derived Types type, public, extends( whm_nbody_system ) :: rmvs_nbody_system Components Type Visibility Attributes Name Initial class( swiftest_cb ), public, allocatable :: cb Central body data structure class( swiftest_pl ), public, allocatable :: pl Massive body data structure class( swiftest_tp ), public, allocatable :: tp Test particle data structure class( swiftest_tp ), public, allocatable :: tp_discards Discarded test particle data structure class( swiftest_pl ), public, allocatable :: pl_discards Discarded massive body particle data structure real(kind=DP), public :: GMtot = 0.0_DP Total system mass - used for barycentric coordinate conversion real(kind=DP), public :: ke_orbit = 0.0_DP System orbital kinetic energy real(kind=DP), public :: ke_spin = 0.0_DP System spin kinetic energy real(kind=DP), public :: pe = 0.0_DP System potential energy real(kind=DP), public :: te = 0.0_DP System total energy real(kind=DP), public :: oblpot = 0.0_DP System potential energy due to oblateness of the central body real(kind=DP), public, dimension(NDIM) :: Lorbit = 0.0_DP System orbital angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lspin = 0.0_DP System spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Ltot = 0.0_DP System angular momentum vector logical, public :: lbeg True if this is the beginning of a step. This is used so that test particle steps can be calculated \n    separately from massive bodies.  Massive body variables are saved at half steps, and passed to \n    the test particles logical, public :: lplanetocentric = .false. In the RMVS integrator, only test particles are discarded\n Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations real(kind=DP), public :: rts fraction of Hill's sphere radius to use as radius of encounter region real(kind=DP), public, dimension(:,:), allocatable :: vbeg Planet velocities at beginning ot step Type-Bound Procedures procedure, public :: discard => discard_system Perform a discard step on the system procedure, public :: conservation_report => io_conservation_report Compute energy and momentum and print out the change with time procedure, public :: dump => io_dump_system Dump the state of the system to a file procedure, public :: get_old_t_final => io_get_old_t_final_system Validates the dump file to check whether the dump file initial conditions duplicate the last frame of the binary output. procedure, public :: read_frame => io_read_frame_system Read in a frame of input data from file procedure, public :: read_particle_info => io_read_particle_info_system Read in particle metadata from file procedure, public :: write_discard => io_write_discard Write out information about discarded test particles procedure, public :: write_frame => io_write_frame_system Append a frame of output data to file procedure, public :: write_hdr_bin => io_write_hdr_system Write a header for an output frame in Fortran binary format procedure, public :: write_hdr_netcdf => netcdf_write_hdr_system Write a header for an output frame in NetCDF format procedure, public :: obl_pot => obl_pot_system Compute the contribution to the total gravitational potential due solely to the oblateness of the central body procedure, public :: init_particle_info => setup_initialize_particle_info_system Initialize the system from input files procedure, public :: step_spin => tides_step_spin_system Steps the spins of the massive & central bodies due to tides. procedure, public :: set_msys => util_set_msys Sets the value of msys from the masses of system bodies. procedure, public :: get_energy_and_momentum => util_get_energy_momentum_system Calculates the total system energy and momentum procedure, public :: rescale => util_rescale_system Rescales the system into a new set of units procedure, public :: validate_ids => util_valid_id_system Validate the numerical ids passed to the system and save the maximum value generic, public :: write_hdr => write_hdr_bin, write_hdr_netcdf Generic method call for writing headers procedure, public :: initialize => rmvs_setup_initialize_system Replace the abstract procedures with concrete ones\n Performs RMVS-specific initilization steps, including generating the close encounter planetocentric structures procedure, public :: step => rmvs_step_system Advance the RMVS nbody system forward in time by one step type, private :: rmvs_interp Components Type Visibility Attributes Name Initial real(kind=DP), public, dimension(:, :), allocatable :: x interpolated heliocentric planet position for outer encounter real(kind=DP), public, dimension(:, :), allocatable :: v interpolated heliocentric planet velocity for outer encounter real(kind=DP), public, dimension(:, :), allocatable :: aobl Encountering planet's oblateness acceleration value real(kind=DP), public, dimension(:, :), allocatable :: atide Encountering planet's tidal acceleration value type, public, extends( whm_cb ) :: rmvs_cb RMVS central body particle class Components Type Visibility Attributes Name Initial type( swiftest_particle_info ), public :: info Particle metadata information integer(kind=I4B), public :: id = 0 External identifier (unique) real(kind=DP), public :: mass = 0.0_DP Central body mass (units MU) real(kind=DP), public :: Gmass = 0.0_DP Central mass gravitational term G * mass (units GU * MU) real(kind=DP), public :: radius = 0.0_DP Central body radius (units DU) real(kind=DP), public :: density = 1.0_DP Central body mass density - calculated internally (units MU / DU**3) real(kind=DP), public :: j2rp2 = 0.0_DP J2*R&#94;2 term for central body real(kind=DP), public :: j4rp4 = 0.0_DP J4*R&#94;2 term for central body real(kind=DP), public, dimension(NDIM) :: aobl = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: atide = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: aoblbeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: aoblend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: atidebeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: atideend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: xb = 0.0_DP Barycentric position (units DU) real(kind=DP), public, dimension(NDIM) :: vb = 0.0_DP Barycentric velocity (units DU / TU) real(kind=DP), public, dimension(NDIM) :: agr = 0.0_DP Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(NDIM) :: Ip = 0.0_DP Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(NDIM) :: rot = 0.0_DP Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public :: k2 = 0.0_DP Tidal Love number real(kind=DP), public :: Q = 0.0_DP Tidal quality factor real(kind=DP), public :: tlag = 0.0_DP Tidal phase lag angle real(kind=DP), public, dimension(NDIM) :: L0 = 0.0_DP Initial angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: dL = 0.0_DP Change in angular momentum of the central body type( rmvs_interp ), public, dimension(:), allocatable :: outer interpolated heliocentric central body position for outer encounters type( rmvs_interp ), public, dimension(:), allocatable :: inner interpolated heliocentric central body position for inner encounters logical, public :: lplanetocentric = .false. Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file generic, public :: write_particle_info => write_particle_info_netcdf procedure, public :: read_in => io_read_in_cb I/O routine for reading in central body data procedure, public :: read_frame => io_read_frame_cb I/O routine for reading out a single frame of time-series data for the central body procedure, public :: write_frame_bin => io_write_frame_cb I/O routine for writing out a single frame of time-series data for the central body generic, public :: write_frame => write_frame_netcdf, write_frame_bin Write a frame (either binary or NetCDF, using generic procedures) type, public, extends( whm_tp ) :: rmvs_tp Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the\n    component list, such as rmvs_setup_tp and rmvs_util_spill_tp Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill integer(kind=I4B), public, dimension(:), allocatable :: isperi Perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri Perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp Semimajor axis following perihelion passage integer(kind=I4B), public, dimension(:,:), allocatable :: k_pltp Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: npltp Number of pl-tp comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_tp and util_spill_tp logical, public, dimension(:), allocatable :: lperi planetocentric pericenter passage flag (persistent for a full rmvs time step) over a full RMVS time step) integer(kind=I4B), public, dimension(:), allocatable :: plperP index of planet associated with pericenter distance peri (persistent over a full RMVS time step) integer(kind=I4B), public, dimension(:), allocatable :: plencP index of planet that test particle is encountering (not persistent for a full RMVS time step) type( rmvs_cb ), public :: cb_heliocentric Copy of original central body object passed to close encounter (used for oblateness acceleration during planetocentric encoountters) real(kind=DP), public, dimension(:,:), allocatable :: xheliocentric original heliocentric position (used for oblateness calculation during close encounters) integer(kind=I4B), public :: index inner substep number within current set integer(kind=I4B), public :: ipleP index value of encountering planet logical, public :: lplanetocentric = .false. Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file generic, public :: write_particle_info => write_particle_info_netcdf procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) generic, public :: write_frame => write_frame_netcdf, write_frame_bin Add the generic write frame for Fortran binary files procedure, public :: accel_int => kick_getacch_int_tp Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies procedure, public :: accel_obl => obl_acc_tp Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: h2b => util_coord_h2b_tp Convert test particles from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_tp Convert test particles from barycentric to heliocentric coordinates (position and velocity) procedure, public :: vb2vh => util_coord_vb2vh_tp Convert test particles from barycentric to heliocentric coordinates (velocity only) procedure, public :: vh2vb => util_coord_vh2vb_tp Convert test particles from heliocentric to barycentric coordinates (velocity only) procedure, public :: xh2xb => util_coord_xh2xb_tp Convert test particles from heliocentric to barycentric coordinates (position only) procedure, public :: get_peri => util_peri_tp Determine system pericenter passages for test particles procedure, public :: set_mu => util_set_mu_tp Method used to construct the vectorized form of the central body mass procedure, public :: accel_gr => whm_gr_kick_getacch_tp Acceleration term arising from the post-Newtonian correction procedure, public :: gr_pos_kick => whm_gr_p4_tp Position kick due to p**4 term in the post-Newtonian correction procedure, public :: kick => whm_kick_vh_tp Kick heliocentric velocities of test particles procedure, public :: step => whm_step_tp Steps the particle forward one stepsize procedure, public :: discard => rmvs_discard_tp Check to see if test particles should be discarded based on pericenter passage distances with respect to planets encountered procedure, public :: encounter_check => rmvs_encounter_check_tp Checks if any test particles are undergoing a close encounter with a massive body procedure, public :: accel => rmvs_kick_getacch_tp Calculates either the standard or modified version of the acceleration depending if the\n    if the test particle is undergoing a close encounter or not procedure, public :: setup => rmvs_setup_tp Constructor method - Allocates space for the input number of bodiess procedure, public :: append => rmvs_util_append_tp Appends elements from one structure to another procedure, public :: fill => rmvs_util_fill_tp \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: resize => rmvs_util_resize_tp Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure, public :: sort => rmvs_util_sort_tp Sorts body arrays by a sortable componen procedure, public :: rearrange => rmvs_util_sort_rearrange_tp Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => rmvs_util_spill_tp \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) type, public, extends( whm_pl ) :: rmvs_pl RMVS massive body particle class Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl real(kind=DP), public, dimension(:), allocatable :: eta Jacobi mass real(kind=DP), public, dimension(:,:), allocatable :: xj Jacobi position real(kind=DP), public, dimension(:,:), allocatable :: vj Jacobi velocity real(kind=DP), public, dimension(:), allocatable :: muj Jacobi mu: GMcb * eta(i) / eta(i - 1) real(kind=DP), public, dimension(:), allocatable :: ir3j Third term of heliocentric acceleration\n Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the\n    component list, such as whm_setup_pl and whm_util_spill_pl integer(kind=I4B), public, dimension(:), allocatable :: nenc number of test particles encountering planet this full rmvs time step integer(kind=I4B), public, dimension(:), allocatable :: tpenc1P index of first test particle encountering planet integer(kind=I4B), public, dimension(:), allocatable :: plind Connects the planetocentric indices back to the heliocentric planet list type( rmvs_interp ), public, dimension(:), allocatable :: outer interpolated heliocentric central body position for outer encounters type( rmvs_interp ), public, dimension(:), allocatable :: inner interpolated heliocentric central body position for inner encounters class( rmvs_nbody_system ), public, dimension(:), allocatable :: planetocentric Planetocentric version of the massive body objects (one for each massive body) logical, public :: lplanetocentric = .false. Flag that indicates that the object is a planetocentric set of masive bodies used for close encounter calculations Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file generic, public :: write_particle_info => write_particle_info_netcdf procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets generic, public :: write_frame => write_frame_netcdf, write_frame_bin Add the generic write frame for Fortran binary files procedure, public :: discard => discard_pl Placeholder method for discarding massive bodies procedure, public :: index => util_index_eucl_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) procedure, public :: vh2vb => util_coord_vh2vb_pl Convert massive bodies from heliocentric to barycentric coordinates (velocity only) procedure, public :: vb2vh => util_coord_vb2vh_pl Convert massive bodies from barycentric to heliocentric coordinates (velocity only) procedure, public :: xh2xb => util_coord_xh2xb_pl Convert massive bodies from heliocentric to barycentric coordinates (position only) procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body procedure, public :: h2j => whm_coord_h2j_pl Convert position and velcoity vectors from heliocentric to Jacobi coordinates procedure, public :: j2h => whm_coord_j2h_pl Convert position and velcoity vectors from Jacobi to helliocentric coordinates procedure, public :: vh2vj => whm_coord_vh2vj_pl Convert velocity vectors from heliocentric to Jacobi coordinates procedure, public :: drift => whm_drift_pl Loop through massive bodies and call Danby drift routine to jacobi coordinates procedure, public :: accel_gr => whm_gr_kick_getacch_pl Acceleration term arising from the post-Newtonian correction procedure, public :: gr_pos_kick => whm_gr_p4_pl Position kick due to p**4 term in the post-Newtonian correction procedure, public :: accel => whm_kick_getacch_pl Compute heliocentric accelerations of massive bodies procedure, public :: kick => whm_kick_vh_pl Kick heliocentric velocities of massive bodies procedure, public :: set_ir3 => whm_util_set_ir3j Sets both the heliocentric and jacobi inverse radius terms (1/rj 3 and 1/rh 3) procedure, public :: set_mu => whm_util_set_mu_eta_pl Sets the Jacobi mass value for all massive bodies. procedure, public :: step => whm_step_pl Steps the body forward one stepsize procedure, public :: setup => rmvs_setup_pl Constructor method - Allocates space for the input number of bodiess procedure, public :: append => rmvs_util_append_pl Appends elements from one structure to another procedure, public :: fill => rmvs_util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: resize => rmvs_util_resize_pl Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure, public :: sort => rmvs_util_sort_pl Sorts body arrays by a sortable componen procedure, public :: rearrange => rmvs_util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => rmvs_util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic)","tags":"","loc":"module/rmvs_classes.html"},{"title":"swiftest_globals – swiftest","text":"Basic parameters, definitions, and global type definitions used throughout the Swiftest project\n Adapted from David E. Kaufmann's Swifter routine: swiftest_globals.f90 and module_swifter.f90 Uses iso_fortran_env Contents Variables I8B I4B I2B I1B SP DP QP PIBY2 PI PI3BY2 TWOPI THIRD DEG2RAD RAD2DEG GC einsteinC LOWERCASE_BEGIN LOWERCASE_END UPPERCASE_OFFSET VERSION_NUMBER UNKNOWN_INTEGRATOR BS HELIO RA15 TU4 WHM RMVS SYMBA RINGMOONS STRMAX NAMELEN ASCII_TYPE REAL4_TYPE REAL8_TYPE NETCDF_FLOAT_TYPE NETCDF_DOUBLE_TYPE EL XV XVEL CB_TYPE_NAME PL_TYPE_NAME TP_TYPE_NAME PL_TINY_TYPE_NAME nthreads NTHERSHOLD SUCCESS FAILURE USAGE HELP SUCCESS_MSG FAIL_MSG USAGE_MSG HELP_MSG ELLIPSE PARABOLA HYPERBOLA ACTIVE INACTIVE DISCARDED_RMAX DISCARDED_RMIN DISCARDED_RMAXU DISCARDED_PERI DISCARDED_PLR DISCARDED_PLQ DISCARDED_DRIFTERR MERGED DISRUPTION SUPERCATASTROPHIC GRAZE_AND_MERGE HIT_AND_RUN_DISRUPT HIT_AND_RUN_PURE COLLISION NEW_PARTICLE OLD_PARTICLE COLLRESOLVE_REGIME_MERGE COLLRESOLVE_REGIME_DISRUPTION COLLRESOLVE_REGIME_SUPERCATASTROPHIC COLLRESOLVE_REGIME_GRAZE_AND_MERGE COLLRESOLVE_REGIME_HIT_AND_RUN ADD SUB NDUMPFILES DUMP_CB_FILE DUMP_PL_FILE DUMP_TP_FILE DUMP_PARAM_FILE CB_INFILE PL_INFILE TP_INFILE BIN_OUTFILE BINUNIT PARTICLE_OUTFILE PARTICLEUNIT NDIM NDIM2 VSMALL NETCDF_OUTFILE TIME_DIMNAME ID_DIMNAME STR_DIMNAME PTYPE_VARNAME NAME_VARNAME NPL_VARNAME NTP_VARNAME A_VARNAME E_VARNAME INC_VARNAME CAPOM_VARNAME OMEGA_VARNAME CAPM_VARNAME XHX_VARNAME XHY_VARNAME XHZ_VARNAME VHX_VARNAME VHY_VARNAME VHZ_VARNAME GMASS_VARNAME RHILL_VARNAME RADIUS_VARNAME IP1_VARNAME IP2_VARNAME IP3_VARNAME ROTX_VARNAME ROTY_VARNAME ROTZ_VARNAME K2_VARNAME Q_VARNAME KE_ORB_VARNAME KE_SPIN_VARNAME PE_VARNAME L_ORBX_VARNAME L_ORBY_VARNAME L_ORBZ_VARNAME L_SPINX_VARNAME L_SPINY_VARNAME L_SPINZ_VARNAME L_ESCAPEX_VARNAME L_ESCAPEY_VARNAME L_ESCAPEZ_VARNAME ECOLLISIONS_VARNAME EUNTRACKED_VARNAME GMESCAPE_VARNAME STATUS_VARNAME ORIGIN_TYPE_VARNAME ORIGIN_TIME_VARNAME ORIGIN_XHX_VARNAME ORIGIN_XHY_VARNAME ORIGIN_XHZ_VARNAME ORIGIN_VHX_VARNAME ORIGIN_VHY_VARNAME ORIGIN_VHZ_VARNAME DISCARD_TIME_VARNAME DISCARD_XHX_VARNAME DISCARD_XHY_VARNAME DISCARD_XHZ_VARNAME DISCARD_VHX_VARNAME DISCARD_VHY_VARNAME DISCARD_VHZ_VARNAME DISCARD_BODY_ID_VARNAME Variables Type Visibility Attributes Name Initial integer, public, parameter :: I8B = int64 Symbolic name for kind types of 8-byte integers integer, public, parameter :: I4B = int32 Symbolic name for kind types of 4-byte integers integer, public, parameter :: I2B = int16 Symbolic name for kind types of 2-byte integers integer, public, parameter :: I1B = int8 Symbolic name for kind types of 1-byte integers integer, public, parameter :: SP = real32 Symbolic name for kind types of single-precision reals integer, public, parameter :: DP = real64 Symbolic name for kind types of double-precision reals integer, public, parameter :: QP = real128 Symbolic name for kind types of quad-precision reals real(kind=DP), public, parameter :: PIBY2 = 1.570796326794896619231321691639751442099_DP Definition of /(\\pi / 2) real(kind=DP), public, parameter :: PI = 3.141592653589793238462643383279502884197_DP Definition of /(\\pi) real(kind=DP), public, parameter :: PI3BY2 = 4.712388980384689857693965074919254326296_DP Definition of /(3 \\pi / 2) real(kind=DP), public, parameter :: TWOPI = 6.283185307179586476925286766559005768394_DP Definition of 2 \\pi real(kind=DP), public, parameter :: THIRD = 0.333333333333333333333333333333333333333_DP Definition of 1 / 3 real(kind=DP), public, parameter :: DEG2RAD = PI/180.0_DP Definition of conversion factor from degrees to radians real(kind=DP), public, parameter :: RAD2DEG = 180.0_DP/PI Definition of conversion factor from degrees to radians real(kind=DP), public, parameter :: GC = 6.6743E-11_DP Universal gravitational constant in SI units real(kind=DP), public, parameter :: einsteinC = 299792458.0_DP Speed of light in SI units integer(kind=I4B), public, parameter :: LOWERCASE_BEGIN = iachar('a') ASCII character set parameter for lower to upper conversion - start of lowercase integer(kind=I4B), public, parameter :: LOWERCASE_END = iachar('z') ASCII character set parameter for lower to upper conversion - end of lowercase integer(kind=I4B), public, parameter :: UPPERCASE_OFFSET = iachar('A')-iachar('a') ASCII character set parameter for lower to upper conversion - offset between upper and lower real(kind=SP), public, parameter :: VERSION_NUMBER = 0.1_SP swiftest version integer(kind=I4B), public, parameter :: UNKNOWN_INTEGRATOR = 1 Symbolic name for integrator types integer(kind=I4B), public, parameter :: BS = 2 integer(kind=I4B), public, parameter :: HELIO = 3 integer(kind=I4B), public, parameter :: RA15 = 4 integer(kind=I4B), public, parameter :: TU4 = 5 integer(kind=I4B), public, parameter :: WHM = 6 integer(kind=I4B), public, parameter :: RMVS = 7 integer(kind=I4B), public, parameter :: SYMBA = 8 integer(kind=I4B), public, parameter :: RINGMOONS = 9 integer(kind=I4B), public, parameter :: STRMAX = 512 Maximum size of character strings integer(kind=I4B), public, parameter :: NAMELEN = 32 Maximum size of name strings character(len=*), public, parameter :: ASCII_TYPE = 'ASCII' Symbolic name for ASCII file type character(len=*), public, parameter :: REAL4_TYPE = 'REAL4' Symbolic name for binary file type REAL4 character(len=*), public, parameter :: REAL8_TYPE = 'REAL8' Symbolic name for binary file type REAL8 character(len=*), public, parameter :: NETCDF_FLOAT_TYPE = 'NETCDF_FLOAT' Symbolic name for binary file type REAL8 character(len=*), public, parameter :: NETCDF_DOUBLE_TYPE = 'NETCDF_DOUBLE' Symbolic name for binary file type REAL8 character(len=*), public, parameter :: EL = 'EL' Symbolic name for binary output file contents for orbital elements character(len=*), public, parameter :: XV = 'XV' Symbolic name for binary output file contents for cartesian position and velocity vectors character(len=*), public, parameter :: XVEL = 'XVEL' Symbolic name for binary output file contents for both cartesian position and velocity and orbital elements character(len=*), public, parameter :: CB_TYPE_NAME = \"Central Body\" character(len=*), public, parameter :: PL_TYPE_NAME = \"Massive Body\" character(len=*), public, parameter :: TP_TYPE_NAME = \"Test Particle\" character(len=*), public, parameter :: PL_TINY_TYPE_NAME = \"Semi-Interacting Massive Body\" integer(kind=I4B), public :: nthreads = 1 Number of OpenMP threads integer(kind=I4B), public, parameter :: NTHERSHOLD = 1000 Threshold value for OpenMP loop parallelization integer(kind=I4B), public, parameter :: SUCCESS = 0 Symbolic name for function return/flag code for success integer(kind=I4B), public, parameter :: FAILURE = -1 Symbolic name for function return/flag code for failure integer(kind=I4B), public, parameter :: USAGE = -2 Symbolic name for function return/flag code for printing the usage message integer(kind=I4B), public, parameter :: HELP = -3 Symbolic name for function return/flag code for printing the usage message character(len=*), public, parameter :: SUCCESS_MSG = '(/, \"Normal termination of Swiftest (version \", f3.1, \")\")' character(len=*), public, parameter :: FAIL_MSG = '(/, \"Terminating Swiftest (version \", f3.1, \") due to error!!\")' character(len=*), public, parameter :: USAGE_MSG = '(\"Usage: swiftest [bs|helio|ra15|rmvs|symba|tu4|whm] \")' character(len=*), public, parameter :: HELP_MSG = USAGE_MSG integer(kind=I4B), public, parameter :: ELLIPSE = -1 Symbolic names for orbit types - ellipse integer(kind=I4B), public, parameter :: PARABOLA = 0 Symbolic names for orbit types - parabola integer(kind=I4B), public, parameter :: HYPERBOLA = 1 Symbolic names for orbit types - hyperbola integer(kind=I4B), public, parameter :: ACTIVE = 0 Symbolic names for body/particle status codes: integer(kind=I4B), public, parameter :: INACTIVE = 1 integer(kind=I4B), public, parameter :: DISCARDED_RMAX = -1 integer(kind=I4B), public, parameter :: DISCARDED_RMIN = -2 integer(kind=I4B), public, parameter :: DISCARDED_RMAXU = -3 integer(kind=I4B), public, parameter :: DISCARDED_PERI = -4 integer(kind=I4B), public, parameter :: DISCARDED_PLR = -5 integer(kind=I4B), public, parameter :: DISCARDED_PLQ = -6 integer(kind=I4B), public, parameter :: DISCARDED_DRIFTERR = -7 integer(kind=I4B), public, parameter :: MERGED = -8 integer(kind=I4B), public, parameter :: DISRUPTION = -9 integer(kind=I4B), public, parameter :: SUPERCATASTROPHIC = -10 integer(kind=I4B), public, parameter :: GRAZE_AND_MERGE = -11 integer(kind=I4B), public, parameter :: HIT_AND_RUN_DISRUPT = -12 integer(kind=I4B), public, parameter :: HIT_AND_RUN_PURE = -13 integer(kind=I4B), public, parameter :: COLLISION = -14 integer(kind=I4B), public, parameter :: NEW_PARTICLE = -15 integer(kind=I4B), public, parameter :: OLD_PARTICLE = -16 integer(kind=I4B), public, parameter :: COLLRESOLVE_REGIME_MERGE = 1 Symbolic names for collisional outcomes from collresolve_resolve: integer(kind=I4B), public, parameter :: COLLRESOLVE_REGIME_DISRUPTION = 2 integer(kind=I4B), public, parameter :: COLLRESOLVE_REGIME_SUPERCATASTROPHIC = 3 integer(kind=I4B), public, parameter :: COLLRESOLVE_REGIME_GRAZE_AND_MERGE = 4 integer(kind=I4B), public, parameter :: COLLRESOLVE_REGIME_HIT_AND_RUN = 5 character(len=*), public, parameter :: ADD = '+1' String labels for body/particle addition/subtraction in discard file character(len=*), public, parameter :: SUB = '-1' integer(kind=I4B), public, parameter :: NDUMPFILES = 2 Standard file names character(len=*), public, parameter, dimension(2) :: DUMP_CB_FILE = ['dump_cb1.bin', 'dump_cb2.bin'] character(len=*), public, parameter, dimension(2) :: DUMP_PL_FILE = ['dump_pl1.bin', 'dump_pl2.bin'] character(len=*), public, parameter, dimension(2) :: DUMP_TP_FILE = ['dump_tp1.bin', 'dump_tp2.bin'] character(len=*), public, parameter, dimension(2) :: DUMP_PARAM_FILE = ['dump_param1.in', 'dump_param2.in'] character(len=*), public, parameter :: CB_INFILE = 'cb.in' Default file names that can be changed by the user in the parameters file character(len=*), public, parameter :: PL_INFILE = 'pl.in' character(len=*), public, parameter :: TP_INFILE = 'tp.in' character(len=*), public, parameter :: BIN_OUTFILE = 'bin.dat' integer(kind=I4B), public, parameter :: BINUNIT = 20 File unit number for the binary output file character(len=*), public, parameter :: PARTICLE_OUTFILE = 'particle.dat' integer(kind=I4B), public, parameter :: PARTICLEUNIT = 44 File unit number for the binary particle info output file integer(kind=I4B), public, parameter :: NDIM = 3 Miscellaneous constants:\n Number of dimensions in our reality integer(kind=I4B), public, parameter :: NDIM2 = 2*NDIM 2x the number of dimensions real(kind=DP), public, parameter :: VSMALL = 2*epsilon(1._DP) Very small number used to prevent floating underflow character(len=*), public, parameter :: NETCDF_OUTFILE = 'bin.nc' NetCDF variable names and constants\n Default output file name character(len=*), public, parameter :: TIME_DIMNAME = \"time\" NetCDF name of the time dimension character(len=*), public, parameter :: ID_DIMNAME = \"id\" NetCDF name of the particle id dimension character(len=*), public, parameter :: STR_DIMNAME = \"str\" NetCDF name of the particle id dimension character(len=*), public, parameter :: PTYPE_VARNAME = \"particle_type\" NetCDF name of the particle type variable character(len=*), public, parameter :: NAME_VARNAME = \"name\" NetCDF name of the particle name variable character(len=*), public, parameter :: NPL_VARNAME = \"npl\" NetCDF name of the number of active massive bodies variable character(len=*), public, parameter :: NTP_VARNAME = \"ntp\" NetCDF name of the number of active test particles variable character(len=*), public, parameter :: A_VARNAME = \"a\" NetCDF name of the semimajor axis variable character(len=*), public, parameter :: E_VARNAME = \"e\" NetCDF name of the eccentricity variable character(len=*), public, parameter :: INC_VARNAME = \"inc\" NetCDF name of the inclination variable character(len=*), public, parameter :: CAPOM_VARNAME = \"capom\" NetCDF name of the long. asc. node variable character(len=*), public, parameter :: OMEGA_VARNAME = \"omega\" NetCDF name of the arg. periapsis variable character(len=*), public, parameter :: CAPM_VARNAME = \"capm\" NetCDF name of the mean anomaly variable character(len=*), public, parameter :: XHX_VARNAME = \"xhx\" NetCDF name of the heliocentric position x variable character(len=*), public, parameter :: XHY_VARNAME = \"xhy\" NetCDF name of the heliocentric position y variable character(len=*), public, parameter :: XHZ_VARNAME = \"xhz\" NetCDF name of the heliocentric position z variable character(len=*), public, parameter :: VHX_VARNAME = \"vhx\" NetCDF name of the heliocentric velocity x variable character(len=*), public, parameter :: VHY_VARNAME = \"vhy\" NetCDF name of the heliocentric velocity y variable character(len=*), public, parameter :: VHZ_VARNAME = \"vhz\" NetCDF name of the heliocentric velocity z variable character(len=*), public, parameter :: GMASS_VARNAME = \"Gmass\" NetCDF name of the mass variable character(len=*), public, parameter :: RHILL_VARNAME = \"rhill\" NetCDF name of the hill radius variable character(len=*), public, parameter :: RADIUS_VARNAME = \"radius\" NetCDF name of the radius variable character(len=*), public, parameter :: IP1_VARNAME = \"Ip1\" NetCDF name of the axis 1 principal moment of inertial variable character(len=*), public, parameter :: IP2_VARNAME = \"Ip2\" NetCDF name of the axis 2 principal moment of inertial variable character(len=*), public, parameter :: IP3_VARNAME = \"Ip3\" NetCDF name of the axis 3 principal moment of inertial variable character(len=*), public, parameter :: ROTX_VARNAME = \"rotx\" NetCDF name of the rotation x variable character(len=*), public, parameter :: ROTY_VARNAME = \"roty\" NetCDF name of the rotation y variable character(len=*), public, parameter :: ROTZ_VARNAME = \"rotz\" NetCDF name of the rotation z variable character(len=*), public, parameter :: K2_VARNAME = \"k2\" NetCDF name of the Love number variable character(len=*), public, parameter :: Q_VARNAME = \"Q\" NetCDF name of the energy dissipation variable character(len=*), public, parameter :: KE_ORB_VARNAME = \"KE_orb\" NetCDF name of the system orbital kinetic energy variable character(len=*), public, parameter :: KE_SPIN_VARNAME = \"KE_spin\" NetCDF name of the system spin kinetic energy variable character(len=*), public, parameter :: PE_VARNAME = \"PE\" NetCDF name of the system potential energy variable character(len=*), public, parameter :: L_ORBX_VARNAME = \"L_orbx\" NetCDF name of the orbital angular momentum x variable character(len=*), public, parameter :: L_ORBY_VARNAME = \"L_orby\" NetCDF name of the orbital angular momentum y variable character(len=*), public, parameter :: L_ORBZ_VARNAME = \"L_orbz\" NetCDF name of the orbital angular momentum z variable character(len=*), public, parameter :: L_SPINX_VARNAME = \"L_spinx\" NetCDF name of the spin angular momentum x variable character(len=*), public, parameter :: L_SPINY_VARNAME = \"L_spiny\" NetCDF name of the spin angular momentum y variable character(len=*), public, parameter :: L_SPINZ_VARNAME = \"L_spinz\" NetCDF name of the spin angular momentum z variable character(len=*), public, parameter :: L_ESCAPEX_VARNAME = \"L_escapex\" NetCDF name of the escaped angular momentum x variable character(len=*), public, parameter :: L_ESCAPEY_VARNAME = \"L_escapey\" NetCDF name of the escaped angular momentum y variable character(len=*), public, parameter :: L_ESCAPEZ_VARNAME = \"L_escapez\" NetCDF name of the escaped angular momentum z variable character(len=*), public, parameter :: ECOLLISIONS_VARNAME = \"Ecollisions\" NetCDF name of the escaped angular momentum y variable character(len=*), public, parameter :: EUNTRACKED_VARNAME = \"Euntracked\" NetCDF name of the energy that is untracked due to loss (untracked potential energy due to mergers and body energy for escaped bodies) character(len=*), public, parameter :: GMESCAPE_VARNAME = \"GMescape\" NetCDF name of the G*Mass of bodies that escape the system character(len=*), public, parameter :: STATUS_VARNAME = \"status\" NetCDF name of the current status of the body variable (includes discard type) character(len=*), public, parameter :: ORIGIN_TYPE_VARNAME = \"origin_type\" NetCDF name of the origin type variable (Initial Conditions, Disruption, etc.) character(len=*), public, parameter :: ORIGIN_TIME_VARNAME = \"origin_time\" NetCDF name of the time of origin variable character(len=*), public, parameter :: ORIGIN_XHX_VARNAME = \"origin_xhx\" NetCDF name of the heliocentric position of the body at the time of origin x variable character(len=*), public, parameter :: ORIGIN_XHY_VARNAME = \"origin_xhy\" NetCDF name of the heliocentric position of the body at the time of origin y variable character(len=*), public, parameter :: ORIGIN_XHZ_VARNAME = \"origin_xhz\" NetCDF name of the heliocentric position of the body at the time of origin z variable character(len=*), public, parameter :: ORIGIN_VHX_VARNAME = \"origin_vhx\" NetCDF name of the heliocentric velocity of the body at the time of origin x variable character(len=*), public, parameter :: ORIGIN_VHY_VARNAME = \"origin_vhy\" NetCDF name of the heliocentric velocity of the body at the time of origin y variable character(len=*), public, parameter :: ORIGIN_VHZ_VARNAME = \"origin_vhz\" NetCDF name of the heliocentric velocity of the body at the time of origin z variable character(len=*), public, parameter :: DISCARD_TIME_VARNAME = \"discard_time\" NetCDF name of the time of discard variable character(len=*), public, parameter :: DISCARD_XHX_VARNAME = \"discard_xhx\" NetCDF name of the heliocentric position of the body at the time of discard x variable character(len=*), public, parameter :: DISCARD_XHY_VARNAME = \"discard_xhy\" NetCDF name of the heliocentric position of the body at the time of discard y variable character(len=*), public, parameter :: DISCARD_XHZ_VARNAME = \"discard_xhz\" NetCDF name of the heliocentric position of the body at the time of discard z variable character(len=*), public, parameter :: DISCARD_VHX_VARNAME = \"discard_vhx\" NetCDF name of the heliocentric velocity of the body at the time of discard x variable character(len=*), public, parameter :: DISCARD_VHY_VARNAME = \"discard_vhy\" NetCDF name of the heliocentric velocity of the body at the time of discard y variable character(len=*), public, parameter :: DISCARD_VHZ_VARNAME = \"discard_vhz\" NetCDF name of the heliocentric velocity of the body at the time of discard z variable character(len=*), public, parameter :: DISCARD_BODY_ID_VARNAME = \"discard_body_id\" NetCDF name of the id of the other body involved in the discard","tags":"","loc":"module/swiftest_globals.html"},{"title":"walltime_classes – swiftest","text":"Classes and methods used to compute elasped wall time Uses swiftest_globals module~~walltime_classes~~UsesGraph module~walltime_classes walltime_classes module~swiftest_globals swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~walltime_classes~~UsedByGraph module~walltime_classes walltime_classes module~swiftest swiftest module~swiftest->module~walltime_classes module~s_fraggle_placeholder s_fraggle_placeholder module~s_fraggle_placeholder->module~swiftest module~s_gr s_gr module~s_gr->module~swiftest module~s_util_valid s_util_valid module~s_util_valid->module~swiftest module~s_symba_collision s_symba_collision module~s_symba_collision->module~swiftest module~s_obl s_obl module~s_obl->module~swiftest module~s_fraggle_setup s_fraggle_setup module~s_fraggle_setup->module~swiftest module~s_util_coord s_util_coord module~s_util_coord->module~swiftest module~s_symba_encounter_check s_symba_encounter_check module~s_symba_encounter_check->module~swiftest module~s_whm_coord s_whm_coord module~s_whm_coord->module~swiftest module~s_util_rescale s_util_rescale module~s_util_rescale->module~swiftest module~s_util_get_energy_momentum s_util_get_energy_momentum module~s_util_get_energy_momentum->module~swiftest module~s_rmvs_step s_rmvs_step module~s_rmvs_step->module~swiftest module~s_util_index s_util_index module~s_util_index->module~swiftest proc~ge_wpp ge_wpp proc~ge_wpp->module~swiftest module~s_operator_cross s_operator_cross module~s_operator_cross->module~swiftest module~s_fraggle_set s_fraggle_set module~s_fraggle_set->module~swiftest module~s_fraggle_io s_fraggle_io module~s_fraggle_io->module~swiftest module~s_rmvs_kick s_rmvs_kick module~s_rmvs_kick->module~swiftest module~s_util_set s_util_set module~s_util_set->module~swiftest module~s_rmvs_io s_rmvs_io module~s_rmvs_io->module~swiftest module~s_util_version s_util_version module~s_util_version->module~swiftest module~s_tides_step_spin s_tides_step_spin module~s_tides_step_spin->module~swiftest proc~solve_wbs solve_wbs proc~solve_wbs->module~swiftest module~s_orbel s_orbel module~s_orbel->module~swiftest module~s_whm_gr s_whm_gr module~s_whm_gr->module~swiftest module~s_rmvs_chk s_rmvs_chk module~s_rmvs_chk->module~swiftest module~s_fraggle_regime s_fraggle_regime module~s_fraggle_regime->module~swiftest module~s_util_exit s_util_exit module~s_util_exit->module~swiftest module~s_netcdf s_netcdf module~s_netcdf->module~swiftest module~s_rmvs_discard s_rmvs_discard module~s_rmvs_discard->module~swiftest module~s_util_peri s_util_peri module~s_util_peri->module~swiftest module~s_helio_drift s_helio_drift module~s_helio_drift->module~swiftest module~s_setup s_setup module~s_setup->module~swiftest module~s_helio_kick s_helio_kick module~s_helio_kick->module~swiftest module~s_util_append s_util_append module~s_util_append->module~swiftest module~s_rmvs_util s_rmvs_util module~s_rmvs_util->module~swiftest program~swiftest_driver swiftest_driver program~swiftest_driver->module~swiftest module~s_symba_step s_symba_step module~s_symba_step->module~swiftest module~s_symba_util s_symba_util module~s_symba_util->module~swiftest module~s_util_copy s_util_copy module~s_util_copy->module~swiftest module~s_discard s_discard module~s_discard->module~swiftest module~s_util_sort s_util_sort module~s_util_sort->module~swiftest module~s_whm_setup s_whm_setup module~s_whm_setup->module~swiftest module~s_util_resize s_util_resize module~s_util_resize->module~swiftest module~s_helio_gr s_helio_gr module~s_helio_gr->module~swiftest module~orbel orbel module~orbel->module~swiftest module~s_whm_util s_whm_util module~s_whm_util->module~swiftest module~s_rmvs_setup s_rmvs_setup module~s_rmvs_setup->module~swiftest module~s_util_spill s_util_spill module~s_util_spill->module~swiftest module~s_util_minimize_bfgs s_util_minimize_bfgs module~s_util_minimize_bfgs->module~swiftest module~s_user_kick_getacch s_user_kick_getacch module~s_user_kick_getacch->module~swiftest module~s_whm_kick s_whm_kick module~s_whm_kick->module~swiftest module~s_symba_discard s_symba_discard module~s_symba_discard->module~swiftest module~s_symba_drift s_symba_drift module~s_symba_drift->module~swiftest module~whm_drift whm_drift module~whm_drift->module~swiftest module~s_tides_kick_getacch s_tides_kick_getacch module~s_tides_kick_getacch->module~swiftest module~s_util_fill s_util_fill module~s_util_fill->module~swiftest module~s_io s_io module~s_io->module~swiftest module~s_helio_setup s_helio_setup module~s_helio_setup->module~swiftest module~s_symba_kick s_symba_kick module~s_symba_kick->module~swiftest module~s_fraggle_util s_fraggle_util module~s_fraggle_util->module~swiftest module~s_util_solve s_util_solve module~s_util_solve->module~swiftest module~s_helio_step s_helio_step module~s_helio_step->module~swiftest module~s_whm_step s_whm_step module~s_whm_step->module~swiftest module~s_symba_setup s_symba_setup module~s_symba_setup->module~swiftest module~s_fraggle_generate s_fraggle_generate module~s_fraggle_generate->module~swiftest module~s_symba_io s_symba_io module~s_symba_io->module~swiftest module~s_kick s_kick module~s_kick->module~swiftest module~drift_implementation drift_implementation module~drift_implementation->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces walltime_finish walltime_reset walltime_start Derived Types walltimer Subroutines walltime_finish walltime_reset walltime_start Interfaces interface public subroutine walltime_finish(self, nsubsteps, message) Arguments Type Intent Optional Attributes Name class( walltimer ), intent(inout) :: self Walltimer object integer(kind=I4B), intent(in) :: nsubsteps Number of substeps used to compute the time per step character(len=*), intent(in) :: message Message to prepend to the wall time terminal output interface public subroutine walltime_reset(self) Arguments Type Intent Optional Attributes Name class( walltimer ), intent(inout) :: self Walltimer object interface public subroutine walltime_start(self) Arguments Type Intent Optional Attributes Name class( walltimer ), intent(inout) :: self Walltimer object Derived Types type, public :: walltimer Components Type Visibility Attributes Name Initial integer(kind=I8B), public :: count_rate Rate at wich the clock ticks integer(kind=I8B), public :: count_max Maximum value of the clock ticker integer(kind=I8B), public :: count_start_main Value of the clock ticker at when the timer is first called integer(kind=I8B), public :: count_start_step Value of the clock ticker at the start of a timed step integer(kind=I8B), public :: count_finish_step Value of the clock ticker at the end of a timed step logical, public :: lmain_is_started = .false. Logical flag indicating whether or not the main timer has been reset or not Type-Bound Procedures procedure, public :: reset => walltime_reset Resets the clock ticker, settting main_start to the current ticker value procedure, public :: start => walltime_start Starts the timer, setting step_start to the current ticker value procedure, public :: finish => walltime_finish Ends the timer, setting step_finish to the current ticker value and printing the elapsed time information to the terminal Subroutines public subroutine walltime_finish (self, nsubsteps, message) Author David A. Minton Ends the timer, setting step_finish to the current ticker value and printing the elapsed time information to the terminal Arguments Type Intent Optional Attributes Name class( walltimer ), intent(inout) :: self Walltimer object integer(kind=I4B), intent(in) :: nsubsteps Number of substeps used to compute the time per step character(len=*), intent(in) :: message Message to prepend to the wall time terminal output public subroutine walltime_reset (self) Author David A. Minton Resets the clock ticker, settting main_start to the current ticker value Arguments Type Intent Optional Attributes Name class( walltimer ), intent(inout) :: self public subroutine walltime_start (self) Author David A. Minton Starts the timer, setting step_start to the current ticker value Arguments Type Intent Optional Attributes Name class( walltimer ), intent(inout) :: self","tags":"","loc":"module/walltime_classes.html"},{"title":"swiftest_operators – swiftest","text":"Custom operators, including\n   A .cross. B = Cross product of A(1:3) and B(1:3) Each operator can also do element-wise computation on arrays of the form .mag. A(1:3, 1:n) Interfaces for .cross. operator Interfaces for .mag. operator Uses swiftest_globals module~~swiftest_operators~~UsesGraph module~swiftest_operators swiftest_operators module~swiftest_globals swiftest_globals module~swiftest_operators->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: s_operator_mag s_operator_cross module~~swiftest_operators~~UsedByGraph module~swiftest_operators swiftest_operators module~swiftest swiftest module~swiftest->module~swiftest_operators module~s_operator_mag s_operator_mag module~s_operator_mag->module~swiftest_operators module~s_operator_cross s_operator_cross module~s_operator_cross->module~swiftest_operators module~s_operator_cross->module~swiftest module~s_fraggle_placeholder s_fraggle_placeholder module~s_fraggle_placeholder->module~swiftest module~s_gr s_gr module~s_gr->module~swiftest module~s_util_valid s_util_valid module~s_util_valid->module~swiftest module~s_symba_collision s_symba_collision module~s_symba_collision->module~swiftest module~s_obl s_obl module~s_obl->module~swiftest module~s_fraggle_setup s_fraggle_setup module~s_fraggle_setup->module~swiftest module~s_util_coord s_util_coord module~s_util_coord->module~swiftest module~s_symba_encounter_check s_symba_encounter_check module~s_symba_encounter_check->module~swiftest module~s_whm_coord s_whm_coord module~s_whm_coord->module~swiftest module~s_util_rescale s_util_rescale module~s_util_rescale->module~swiftest module~s_util_get_energy_momentum s_util_get_energy_momentum module~s_util_get_energy_momentum->module~swiftest module~s_rmvs_step s_rmvs_step module~s_rmvs_step->module~swiftest module~s_util_index s_util_index module~s_util_index->module~swiftest proc~ge_wpp ge_wpp proc~ge_wpp->module~swiftest module~s_fraggle_set s_fraggle_set module~s_fraggle_set->module~swiftest module~s_fraggle_io s_fraggle_io module~s_fraggle_io->module~swiftest module~s_rmvs_kick s_rmvs_kick module~s_rmvs_kick->module~swiftest module~s_util_set s_util_set module~s_util_set->module~swiftest module~s_rmvs_io s_rmvs_io module~s_rmvs_io->module~swiftest module~s_util_version s_util_version module~s_util_version->module~swiftest module~s_tides_step_spin s_tides_step_spin module~s_tides_step_spin->module~swiftest proc~solve_wbs solve_wbs proc~solve_wbs->module~swiftest module~s_orbel s_orbel module~s_orbel->module~swiftest module~s_whm_gr s_whm_gr module~s_whm_gr->module~swiftest module~s_rmvs_chk s_rmvs_chk module~s_rmvs_chk->module~swiftest module~s_fraggle_regime s_fraggle_regime module~s_fraggle_regime->module~swiftest module~s_util_exit s_util_exit module~s_util_exit->module~swiftest module~s_netcdf s_netcdf module~s_netcdf->module~swiftest module~s_rmvs_discard s_rmvs_discard module~s_rmvs_discard->module~swiftest module~s_util_peri s_util_peri module~s_util_peri->module~swiftest module~s_helio_drift s_helio_drift module~s_helio_drift->module~swiftest module~s_setup s_setup module~s_setup->module~swiftest module~s_helio_kick s_helio_kick module~s_helio_kick->module~swiftest module~s_util_append s_util_append module~s_util_append->module~swiftest module~s_rmvs_util s_rmvs_util module~s_rmvs_util->module~swiftest program~swiftest_driver swiftest_driver program~swiftest_driver->module~swiftest module~s_symba_step s_symba_step module~s_symba_step->module~swiftest module~s_symba_util s_symba_util module~s_symba_util->module~swiftest module~s_util_copy s_util_copy module~s_util_copy->module~swiftest module~s_discard s_discard module~s_discard->module~swiftest module~s_util_sort s_util_sort module~s_util_sort->module~swiftest module~s_whm_setup s_whm_setup module~s_whm_setup->module~swiftest module~s_util_resize s_util_resize module~s_util_resize->module~swiftest module~s_helio_gr s_helio_gr module~s_helio_gr->module~swiftest module~orbel orbel module~orbel->module~swiftest module~s_whm_util s_whm_util module~s_whm_util->module~swiftest module~s_rmvs_setup s_rmvs_setup module~s_rmvs_setup->module~swiftest module~s_util_spill s_util_spill module~s_util_spill->module~swiftest module~s_util_minimize_bfgs s_util_minimize_bfgs module~s_util_minimize_bfgs->module~swiftest module~s_user_kick_getacch s_user_kick_getacch module~s_user_kick_getacch->module~swiftest module~s_whm_kick s_whm_kick module~s_whm_kick->module~swiftest module~s_symba_discard s_symba_discard module~s_symba_discard->module~swiftest module~s_symba_drift s_symba_drift module~s_symba_drift->module~swiftest module~whm_drift whm_drift module~whm_drift->module~swiftest module~s_tides_kick_getacch s_tides_kick_getacch module~s_tides_kick_getacch->module~swiftest module~s_util_fill s_util_fill module~s_util_fill->module~swiftest module~s_io s_io module~s_io->module~swiftest module~s_helio_setup s_helio_setup module~s_helio_setup->module~swiftest module~s_symba_kick s_symba_kick module~s_symba_kick->module~swiftest module~s_fraggle_util s_fraggle_util module~s_fraggle_util->module~swiftest module~s_util_solve s_util_solve module~s_util_solve->module~swiftest module~s_helio_step s_helio_step module~s_helio_step->module~swiftest module~s_whm_step s_whm_step module~s_whm_step->module~swiftest module~s_symba_setup s_symba_setup module~s_symba_setup->module~swiftest module~s_fraggle_generate s_fraggle_generate module~s_fraggle_generate->module~swiftest module~s_symba_io s_symba_io module~s_symba_io->module~swiftest module~s_kick s_kick module~s_kick->module~swiftest module~drift_implementation drift_implementation module~drift_implementation->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces operator(.cross.) operator(.mag.) Interfaces public interface operator(.cross.) public pure function operator_cross_sp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: A real(kind=SP), intent(in), dimension(:) :: B Return Value real(kind=SP),\n  dimension(3) public pure function operator_cross_dp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: A real(kind=DP), intent(in), dimension(:) :: B Return Value real(kind=DP),\n  dimension(3) public pure function operator_cross_qp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:) :: A real(kind=QP), intent(in), dimension(:) :: B Return Value real(kind=QP),\n  dimension(3) public pure function operator_cross_i1b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in), dimension(:) :: A integer(kind=I1B), intent(in), dimension(:) :: B Return Value integer(kind=I1B),\n  dimension(3) public pure function operator_cross_i2b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in), dimension(:) :: A integer(kind=I2B), intent(in), dimension(:) :: B Return Value integer(kind=I2B),\n  dimension(3) public pure function operator_cross_i4b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:) :: A integer(kind=I4B), intent(in), dimension(:) :: B Return Value integer(kind=I4B),\n  dimension(3) public pure function operator_cross_i8b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in), dimension(:) :: A integer(kind=I8B), intent(in), dimension(:) :: B Return Value integer(kind=I8B),\n  dimension(3) public pure function operator_cross_el_sp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:,:) :: A real(kind=SP), intent(in), dimension(:,:) :: B Return Value real(kind=SP),\n  dimension(:,:), allocatable public pure function operator_cross_el_dp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A real(kind=DP), intent(in), dimension(:,:) :: B Return Value real(kind=DP),\n  dimension(:,:), allocatable public pure function operator_cross_el_qp(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A real(kind=QP), intent(in), dimension(:,:) :: B Return Value real(kind=QP),\n  dimension(:,:), allocatable public pure function operator_cross_el_i1b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in), dimension(:,:) :: A integer(kind=I1B), intent(in), dimension(:,:) :: B Return Value integer(kind=I1B),\n  dimension(:,:), allocatable public pure function operator_cross_el_i2b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in), dimension(:,:) :: A integer(kind=I2B), intent(in), dimension(:,:) :: B Return Value integer(kind=I2B),\n  dimension(:,:), allocatable public pure function operator_cross_el_i4b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:,:) :: A integer(kind=I4B), intent(in), dimension(:,:) :: B Return Value integer(kind=I4B),\n  dimension(:,:), allocatable public pure function operator_cross_el_i8b(A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in), dimension(:,:) :: A integer(kind=I8B), intent(in), dimension(:,:) :: B Return Value integer(kind=I8B),\n  dimension(:,:), allocatable public interface operator(.mag.) public pure function operator_mag_sp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: A Return Value real(kind=SP) public pure function operator_mag_dp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: A Return Value real(kind=DP) public pure function operator_mag_qp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:) :: A Return Value real(kind=QP) public pure function operator_mag_el_sp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:,:) :: A Return Value real(kind=SP),\n  dimension(:), allocatable public pure function operator_mag_el_dp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A Return Value real(kind=DP),\n  dimension(:), allocatable public pure function operator_mag_el_qp(A) result(B) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A Return Value real(kind=QP),\n  dimension(:), allocatable","tags":"","loc":"module/swiftest_operators.html"},{"title":"helio_classes – swiftest","text":"Definition of classes and methods specific to the Democratic Heliocentric Method\n Adapted from David E. Kaufmann's Swifter routine: module_helio.f90 helio_nbody_system class definitions and method interfaces helio_cb class definitions and method interfaces helio_pl class definitions and method interfaces Helio massive body particle class helio_tp class definitions and method interfaces Helio test particle class Uses swiftest_globals swiftest_classes whm_classes module~~helio_classes~~UsesGraph module~helio_classes helio_classes module~swiftest_globals swiftest_globals module~helio_classes->module~swiftest_globals module~whm_classes whm_classes module~helio_classes->module~whm_classes module~swiftest_classes swiftest_classes module~helio_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~swiftest_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: s_helio_drift s_helio_gr s_helio_kick s_helio_setup s_helio_step module~~helio_classes~~UsedByGraph module~helio_classes helio_classes module~s_helio_setup s_helio_setup module~s_helio_setup->module~helio_classes module~swiftest swiftest module~s_helio_setup->module~swiftest module~s_helio_step s_helio_step module~s_helio_step->module~helio_classes module~s_helio_step->module~swiftest module~symba_classes symba_classes module~symba_classes->module~helio_classes module~swiftest->module~helio_classes module~swiftest->module~symba_classes module~s_helio_drift s_helio_drift module~s_helio_drift->module~helio_classes module~s_helio_drift->module~swiftest module~s_helio_gr s_helio_gr module~s_helio_gr->module~helio_classes module~s_helio_gr->module~swiftest module~s_helio_kick s_helio_kick module~s_helio_kick->module~helio_classes module~s_helio_kick->module~swiftest module~s_fraggle_placeholder s_fraggle_placeholder module~s_fraggle_placeholder->module~swiftest module~s_gr s_gr module~s_gr->module~swiftest module~s_symba_collision s_symba_collision module~s_symba_collision->module~symba_classes module~s_symba_collision->module~swiftest module~s_util_valid s_util_valid module~s_util_valid->module~swiftest module~s_obl s_obl module~s_obl->module~swiftest module~s_fraggle_setup s_fraggle_setup module~s_fraggle_setup->module~swiftest module~s_util_coord s_util_coord module~s_util_coord->module~swiftest module~s_symba_encounter_check s_symba_encounter_check module~s_symba_encounter_check->module~symba_classes module~s_symba_encounter_check->module~swiftest module~s_whm_coord s_whm_coord module~s_whm_coord->module~swiftest module~s_util_rescale s_util_rescale module~s_util_rescale->module~swiftest module~s_util_get_energy_momentum s_util_get_energy_momentum module~s_util_get_energy_momentum->module~swiftest module~s_rmvs_step s_rmvs_step module~s_rmvs_step->module~swiftest module~s_util_index s_util_index module~s_util_index->module~swiftest proc~ge_wpp ge_wpp proc~ge_wpp->module~swiftest module~s_operator_cross s_operator_cross module~s_operator_cross->module~swiftest module~s_fraggle_set s_fraggle_set module~s_fraggle_set->module~swiftest module~s_fraggle_io s_fraggle_io module~s_fraggle_io->module~swiftest module~s_rmvs_kick s_rmvs_kick module~s_rmvs_kick->module~swiftest module~s_util_set s_util_set module~s_util_set->module~swiftest module~s_rmvs_io s_rmvs_io module~s_rmvs_io->module~swiftest module~s_util_version s_util_version module~s_util_version->module~swiftest module~s_tides_step_spin s_tides_step_spin module~s_tides_step_spin->module~swiftest proc~solve_wbs solve_wbs proc~solve_wbs->module~swiftest module~s_orbel s_orbel module~s_orbel->module~swiftest module~s_whm_gr s_whm_gr module~s_whm_gr->module~swiftest module~s_rmvs_chk s_rmvs_chk module~s_rmvs_chk->module~swiftest module~s_fraggle_regime s_fraggle_regime module~s_fraggle_regime->module~swiftest module~s_util_exit s_util_exit module~s_util_exit->module~swiftest module~s_netcdf s_netcdf module~s_netcdf->module~swiftest module~s_rmvs_discard s_rmvs_discard module~s_rmvs_discard->module~swiftest module~s_util_peri s_util_peri module~s_util_peri->module~swiftest module~s_setup s_setup module~s_setup->module~swiftest module~s_util_append s_util_append module~s_util_append->module~swiftest module~s_rmvs_util s_rmvs_util module~s_rmvs_util->module~swiftest program~swiftest_driver swiftest_driver program~swiftest_driver->module~swiftest module~s_symba_step s_symba_step module~s_symba_step->module~symba_classes module~s_symba_step->module~swiftest module~s_symba_util s_symba_util module~s_symba_util->module~symba_classes module~s_symba_util->module~swiftest module~s_util_copy s_util_copy module~s_util_copy->module~swiftest module~s_discard s_discard module~s_discard->module~swiftest module~s_util_sort s_util_sort module~s_util_sort->module~swiftest module~s_whm_setup s_whm_setup module~s_whm_setup->module~swiftest module~s_util_resize s_util_resize module~s_util_resize->module~swiftest module~orbel orbel module~orbel->module~swiftest module~s_whm_util s_whm_util module~s_whm_util->module~swiftest module~s_rmvs_setup s_rmvs_setup module~s_rmvs_setup->module~swiftest module~s_util_spill s_util_spill module~s_util_spill->module~swiftest module~s_util_minimize_bfgs s_util_minimize_bfgs module~s_util_minimize_bfgs->module~swiftest module~s_user_kick_getacch s_user_kick_getacch module~s_user_kick_getacch->module~swiftest module~s_symba_discard s_symba_discard module~s_symba_discard->module~symba_classes module~s_symba_discard->module~swiftest module~s_symba_drift s_symba_drift module~s_symba_drift->module~symba_classes module~s_symba_drift->module~swiftest module~s_whm_kick s_whm_kick module~s_whm_kick->module~swiftest module~whm_drift whm_drift module~whm_drift->module~swiftest module~s_symba_kick s_symba_kick module~s_symba_kick->module~symba_classes module~s_symba_kick->module~swiftest module~s_tides_kick_getacch s_tides_kick_getacch module~s_tides_kick_getacch->module~swiftest module~s_util_fill s_util_fill module~s_util_fill->module~swiftest module~s_io s_io module~s_io->module~swiftest module~s_fraggle_util s_fraggle_util module~s_fraggle_util->module~swiftest module~s_util_solve s_util_solve module~s_util_solve->module~swiftest module~s_whm_step s_whm_step module~s_whm_step->module~swiftest module~s_symba_setup s_symba_setup module~s_symba_setup->module~symba_classes module~s_symba_setup->module~swiftest module~s_fraggle_generate s_fraggle_generate module~s_fraggle_generate->module~swiftest module~s_symba_io s_symba_io module~s_symba_io->module~symba_classes module~s_symba_io->module~swiftest module~s_kick s_kick module~s_kick->module~swiftest module~drift_implementation drift_implementation module~drift_implementation->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces helio_drift_body helio_drift_pl helio_drift_tp helio_drift_linear_pl helio_drift_linear_tp helio_gr_kick_getacch_pl helio_gr_kick_getacch_tp helio_gr_p4_pl helio_gr_p4_tp helio_kick_getacch_pl helio_kick_getacch_tp helio_kick_vb_pl helio_kick_vb_tp helio_setup_initialize_system helio_step_pl helio_step_system helio_step_tp Derived Types helio_nbody_system helio_cb helio_pl helio_tp Interfaces interface public module subroutine helio_drift_body(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class(swiftest_body), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize interface public module subroutine helio_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize interface public module subroutine helio_drift_tp(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize interface public module subroutine helio_drift_linear_pl(self, cb, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( helio_cb ), intent(inout) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step interface public module subroutine helio_drift_linear_tp(self, cb, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( helio_cb ), intent(in) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step interface public pure module subroutine helio_gr_kick_getacch_pl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters interface public pure module subroutine helio_gr_kick_getacch_tp(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters interface public pure module subroutine helio_gr_p4_pl(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size interface public pure module subroutine helio_gr_p4_tp(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size interface public module subroutine helio_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step interface public module subroutine helio_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step interface public module subroutine helio_kick_vb_pl(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. interface public module subroutine helio_kick_vb_tp(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. interface public module subroutine helio_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( helio_nbody_system ), intent(inout) :: self Helio nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters interface public module subroutine helio_step_pl(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nboody system class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize interface public module subroutine helio_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_nbody_system ), intent(inout) :: self Helio nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize interface public module subroutine helio_step_tp(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsizee Derived Types type, public, extends( whm_nbody_system ) :: helio_nbody_system Components Type Visibility Attributes Name Initial class( swiftest_cb ), public, allocatable :: cb Central body data structure class( swiftest_pl ), public, allocatable :: pl Massive body data structure class( swiftest_tp ), public, allocatable :: tp Test particle data structure class( swiftest_tp ), public, allocatable :: tp_discards Discarded test particle data structure class( swiftest_pl ), public, allocatable :: pl_discards Discarded massive body particle data structure real(kind=DP), public :: GMtot = 0.0_DP Total system mass - used for barycentric coordinate conversion real(kind=DP), public :: ke_orbit = 0.0_DP System orbital kinetic energy real(kind=DP), public :: ke_spin = 0.0_DP System spin kinetic energy real(kind=DP), public :: pe = 0.0_DP System potential energy real(kind=DP), public :: te = 0.0_DP System total energy real(kind=DP), public :: oblpot = 0.0_DP System potential energy due to oblateness of the central body real(kind=DP), public, dimension(NDIM) :: Lorbit = 0.0_DP System orbital angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lspin = 0.0_DP System spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Ltot = 0.0_DP System angular momentum vector logical, public :: lbeg True if this is the beginning of a step. This is used so that test particle steps can be calculated \n    separately from massive bodies.  Massive body variables are saved at half steps, and passed to \n    the test particles Type-Bound Procedures procedure, public :: discard => discard_system Perform a discard step on the system procedure, public :: conservation_report => io_conservation_report Compute energy and momentum and print out the change with time procedure, public :: dump => io_dump_system Dump the state of the system to a file procedure, public :: get_old_t_final => io_get_old_t_final_system Validates the dump file to check whether the dump file initial conditions duplicate the last frame of the binary output. procedure, public :: read_frame => io_read_frame_system Read in a frame of input data from file procedure, public :: read_particle_info => io_read_particle_info_system Read in particle metadata from file procedure, public :: write_discard => io_write_discard Write out information about discarded test particles procedure, public :: write_frame => io_write_frame_system Append a frame of output data to file procedure, public :: write_hdr_bin => io_write_hdr_system Write a header for an output frame in Fortran binary format procedure, public :: write_hdr_netcdf => netcdf_write_hdr_system Write a header for an output frame in NetCDF format procedure, public :: obl_pot => obl_pot_system Compute the contribution to the total gravitational potential due solely to the oblateness of the central body procedure, public :: init_particle_info => setup_initialize_particle_info_system Initialize the system from input files procedure, public :: step_spin => tides_step_spin_system Steps the spins of the massive & central bodies due to tides. procedure, public :: set_msys => util_set_msys Sets the value of msys from the masses of system bodies. procedure, public :: get_energy_and_momentum => util_get_energy_momentum_system Calculates the total system energy and momentum procedure, public :: rescale => util_rescale_system Rescales the system into a new set of units procedure, public :: validate_ids => util_valid_id_system Validate the numerical ids passed to the system and save the maximum value generic, public :: write_hdr => write_hdr_bin, write_hdr_netcdf Generic method call for writing headers procedure, public :: step => helio_step_system Advance the Helio nbody system forward in time by one step procedure, public :: initialize => helio_setup_initialize_system Performs Helio-specific initilization steps, including converting to DH coordinates type, public, extends( swiftest_cb ) :: helio_cb Helio central body particle class Components Type Visibility Attributes Name Initial type( swiftest_particle_info ), public :: info Particle metadata information integer(kind=I4B), public :: id = 0 External identifier (unique) real(kind=DP), public :: mass = 0.0_DP Central body mass (units MU) real(kind=DP), public :: Gmass = 0.0_DP Central mass gravitational term G * mass (units GU * MU) real(kind=DP), public :: radius = 0.0_DP Central body radius (units DU) real(kind=DP), public :: density = 1.0_DP Central body mass density - calculated internally (units MU / DU**3) real(kind=DP), public :: j2rp2 = 0.0_DP J2*R&#94;2 term for central body real(kind=DP), public :: j4rp4 = 0.0_DP J4*R&#94;2 term for central body real(kind=DP), public, dimension(NDIM) :: aobl = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: atide = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: aoblbeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: aoblend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: atidebeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: atideend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: xb = 0.0_DP Barycentric position (units DU) real(kind=DP), public, dimension(NDIM) :: vb = 0.0_DP Barycentric velocity (units DU / TU) real(kind=DP), public, dimension(NDIM) :: agr = 0.0_DP Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(NDIM) :: Ip = 0.0_DP Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(NDIM) :: rot = 0.0_DP Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public :: k2 = 0.0_DP Tidal Love number real(kind=DP), public :: Q = 0.0_DP Tidal quality factor real(kind=DP), public :: tlag = 0.0_DP Tidal phase lag angle real(kind=DP), public, dimension(NDIM) :: L0 = 0.0_DP Initial angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: dL = 0.0_DP Change in angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: ptbeg negative barycentric velocity of the central body at the beginning of time step real(kind=DP), public, dimension(NDIM) :: ptend negative barycentric velocity of the central body at the end of time step Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file generic, public :: write_particle_info => write_particle_info_netcdf procedure, public :: read_in => io_read_in_cb I/O routine for reading in central body data procedure, public :: read_frame => io_read_frame_cb I/O routine for reading out a single frame of time-series data for the central body procedure, public :: write_frame_bin => io_write_frame_cb I/O routine for writing out a single frame of time-series data for the central body generic, public :: write_frame => write_frame_netcdf, write_frame_bin Write a frame (either binary or NetCDF, using generic procedures) type, public, extends( swiftest_pl ) :: helio_pl Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file generic, public :: write_particle_info => write_particle_info_netcdf procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) generic, public :: write_frame => write_frame_netcdf, write_frame_bin Add the generic write frame for Fortran binary files procedure, public :: discard => discard_pl Placeholder method for discarding massive bodies procedure, public :: index => util_index_eucl_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: setup => setup_pl A base constructor that sets the number of bodies and allocates and initializes all arrays procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body procedure, public :: append => util_append_pl Appends elements from one structure to another procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) procedure, public :: vh2vb => util_coord_vh2vb_pl Convert massive bodies from heliocentric to barycentric coordinates (velocity only) procedure, public :: vb2vh => util_coord_vb2vh_pl Convert massive bodies from barycentric to heliocentric coordinates (velocity only) procedure, public :: xh2xb => util_coord_xh2xb_pl Convert massive bodies from heliocentric to barycentric coordinates (position only) procedure, public :: fill => util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: resize => util_resize_pl Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. procedure, public :: set_mu => util_set_mu_pl Method used to construct the vectorized form of the central body mass procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body procedure, public :: sort => util_sort_pl Sorts body arrays by a sortable component procedure, public :: rearrange => util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure, public :: drift => helio_drift_pl Method for Danby drift in Democratic Heliocentric coordinates procedure, public :: lindrift => helio_drift_linear_pl Method for linear drift of massive bodies due to barycentric momentum of Sun procedure, public :: accel_gr => helio_gr_kick_getacch_pl Acceleration term arising from the post-Newtonian correction procedure, public :: gr_pos_kick => helio_gr_p4_pl Position kick due to p**4 term in the post-Newtonian correction procedure, public :: accel => helio_kick_getacch_pl Compute heliocentric accelerations of massive bodies procedure, public :: kick => helio_kick_vb_pl Kicks the barycentric velocities procedure, public :: step => helio_step_pl Steps the body forward one stepsize type, public, extends( swiftest_tp ) :: helio_tp Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill integer(kind=I4B), public, dimension(:), allocatable :: isperi Perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri Perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp Semimajor axis following perihelion passage integer(kind=I4B), public, dimension(:,:), allocatable :: k_pltp Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: npltp Number of pl-tp comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_tp and util_spill_tp Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file generic, public :: write_particle_info => write_particle_info_netcdf procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) generic, public :: write_frame => write_frame_netcdf, write_frame_bin Add the generic write frame for Fortran binary files procedure, public :: discard => discard_tp Check to see if test particles should be discarded based on their positions relative to the massive bodies procedure, public :: accel_int => kick_getacch_int_tp Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies procedure, public :: accel_obl => obl_acc_tp Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: setup => setup_tp A base constructor that sets the number of bodies and procedure, public :: append => util_append_tp Appends elements from one structure to another procedure, public :: h2b => util_coord_h2b_tp Convert test particles from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_tp Convert test particles from barycentric to heliocentric coordinates (position and velocity) procedure, public :: vb2vh => util_coord_vb2vh_tp Convert test particles from barycentric to heliocentric coordinates (velocity only) procedure, public :: vh2vb => util_coord_vh2vb_tp Convert test particles from heliocentric to barycentric coordinates (velocity only) procedure, public :: xh2xb => util_coord_xh2xb_tp Convert test particles from heliocentric to barycentric coordinates (position only) procedure, public :: fill => util_fill_tp \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: get_peri => util_peri_tp Determine system pericenter passages for test particles procedure, public :: resize => util_resize_tp Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure, public :: set_mu => util_set_mu_tp Method used to construct the vectorized form of the central body mass procedure, public :: sort => util_sort_tp Sorts body arrays by a sortable component procedure, public :: rearrange => util_sort_rearrange_tp Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => util_spill_tp \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure, public :: lindrift => helio_drift_linear_tp Method for linear drift of massive bodies due to barycentric momentum of Sun procedure, public :: drift => helio_drift_tp Method for Danby drift in Democratic Heliocentric coordinates procedure, public :: accel_gr => helio_gr_kick_getacch_tp Acceleration term arising from the post-Newtonian correction procedure, public :: gr_pos_kick => helio_gr_p4_tp Position kick due to p**4 term in the post-Newtonian correction procedure, public :: accel => helio_kick_getacch_tp Compute heliocentric accelerations of massive bodies procedure, public :: kick => helio_kick_vb_tp Kicks the barycentric velocities procedure, public :: step => helio_step_tp Steps the body forward one stepsize","tags":"","loc":"module/helio_classes.html"},{"title":"whm_classes – swiftest","text":"Definition of classes and methods specific to the Democratic Heliocentric Method\n Partially adapted from David E. Kaufmann's Swifter module: module_whm.f90 whm_cb class definitions and method interfaces whm_pl class definitions and method interfaces whm_tp class definitions and method interfaces WHM test particle class whm_nbody_system class definitions and method interfaces Uses swiftest_globals swiftest_classes module~~whm_classes~~UsesGraph module~whm_classes whm_classes module~swiftest_globals swiftest_globals module~whm_classes->module~swiftest_globals module~swiftest_classes swiftest_classes module~whm_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~swiftest_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: s_whm_coord s_whm_gr s_whm_kick s_whm_setup s_whm_step s_whm_util whm_drift module~~whm_classes~~UsedByGraph module~whm_classes whm_classes module~s_whm_kick s_whm_kick module~s_whm_kick->module~whm_classes module~swiftest swiftest module~s_whm_kick->module~swiftest module~whm_drift whm_drift module~whm_drift->module~whm_classes module~whm_drift->module~swiftest module~s_whm_gr s_whm_gr module~s_whm_gr->module~whm_classes module~s_whm_gr->module~swiftest module~helio_classes helio_classes module~helio_classes->module~whm_classes module~s_whm_coord s_whm_coord module~s_whm_coord->module~whm_classes module~s_whm_coord->module~swiftest module~swiftest->module~whm_classes module~swiftest->module~helio_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~symba_classes symba_classes module~swiftest->module~symba_classes module~s_whm_step s_whm_step module~s_whm_step->module~whm_classes module~s_whm_step->module~swiftest module~s_whm_setup s_whm_setup module~s_whm_setup->module~whm_classes module~s_whm_setup->module~swiftest module~rmvs_classes->module~whm_classes module~s_whm_util s_whm_util module~s_whm_util->module~whm_classes module~s_whm_util->module~swiftest module~s_fraggle_placeholder s_fraggle_placeholder module~s_fraggle_placeholder->module~swiftest module~s_gr s_gr module~s_gr->module~swiftest module~s_util_valid s_util_valid module~s_util_valid->module~swiftest module~s_symba_collision s_symba_collision module~s_symba_collision->module~swiftest module~s_symba_collision->module~symba_classes module~s_obl s_obl module~s_obl->module~swiftest module~s_fraggle_setup s_fraggle_setup module~s_fraggle_setup->module~swiftest module~s_util_coord s_util_coord module~s_util_coord->module~swiftest module~s_symba_encounter_check s_symba_encounter_check module~s_symba_encounter_check->module~swiftest module~s_symba_encounter_check->module~symba_classes module~s_util_rescale s_util_rescale module~s_util_rescale->module~swiftest module~s_rmvs_step s_rmvs_step module~s_rmvs_step->module~swiftest module~s_rmvs_step->module~rmvs_classes module~s_util_get_energy_momentum s_util_get_energy_momentum module~s_util_get_energy_momentum->module~swiftest module~s_util_index s_util_index module~s_util_index->module~swiftest proc~ge_wpp ge_wpp proc~ge_wpp->module~swiftest module~s_operator_cross s_operator_cross module~s_operator_cross->module~swiftest module~s_fraggle_set s_fraggle_set module~s_fraggle_set->module~swiftest module~s_fraggle_io s_fraggle_io module~s_fraggle_io->module~swiftest module~s_rmvs_kick s_rmvs_kick module~s_rmvs_kick->module~swiftest module~s_rmvs_kick->module~rmvs_classes module~s_util_set s_util_set module~s_util_set->module~swiftest module~s_rmvs_io s_rmvs_io module~s_rmvs_io->module~swiftest module~s_rmvs_io->module~rmvs_classes module~s_util_version s_util_version module~s_util_version->module~swiftest module~s_tides_step_spin s_tides_step_spin module~s_tides_step_spin->module~swiftest proc~solve_wbs solve_wbs proc~solve_wbs->module~swiftest module~s_orbel s_orbel module~s_orbel->module~swiftest module~s_rmvs_chk s_rmvs_chk module~s_rmvs_chk->module~swiftest module~s_rmvs_chk->module~rmvs_classes module~s_fraggle_regime s_fraggle_regime module~s_fraggle_regime->module~swiftest module~symba_classes->module~helio_classes module~s_util_exit s_util_exit module~s_util_exit->module~swiftest module~s_netcdf s_netcdf module~s_netcdf->module~swiftest module~s_rmvs_discard s_rmvs_discard module~s_rmvs_discard->module~swiftest module~s_rmvs_discard->module~rmvs_classes module~s_helio_drift s_helio_drift module~s_helio_drift->module~helio_classes module~s_helio_drift->module~swiftest module~s_util_peri s_util_peri module~s_util_peri->module~swiftest module~s_setup s_setup module~s_setup->module~swiftest module~s_helio_kick s_helio_kick module~s_helio_kick->module~helio_classes module~s_helio_kick->module~swiftest module~s_util_append s_util_append module~s_util_append->module~swiftest module~s_rmvs_util s_rmvs_util module~s_rmvs_util->module~swiftest module~s_rmvs_util->module~rmvs_classes program~swiftest_driver swiftest_driver program~swiftest_driver->module~swiftest module~s_symba_step s_symba_step module~s_symba_step->module~swiftest module~s_symba_step->module~symba_classes module~s_symba_util s_symba_util module~s_symba_util->module~swiftest module~s_symba_util->module~symba_classes module~s_util_copy s_util_copy module~s_util_copy->module~swiftest module~s_discard s_discard module~s_discard->module~swiftest module~s_util_sort s_util_sort module~s_util_sort->module~swiftest module~s_util_resize s_util_resize module~s_util_resize->module~swiftest module~s_helio_gr s_helio_gr module~s_helio_gr->module~helio_classes module~s_helio_gr->module~swiftest module~orbel orbel module~orbel->module~swiftest module~s_rmvs_setup s_rmvs_setup module~s_rmvs_setup->module~swiftest module~s_rmvs_setup->module~rmvs_classes module~s_util_spill s_util_spill module~s_util_spill->module~swiftest module~s_util_minimize_bfgs s_util_minimize_bfgs module~s_util_minimize_bfgs->module~swiftest module~s_user_kick_getacch s_user_kick_getacch module~s_user_kick_getacch->module~swiftest module~s_symba_discard s_symba_discard module~s_symba_discard->module~swiftest module~s_symba_discard->module~symba_classes module~s_symba_drift s_symba_drift module~s_symba_drift->module~swiftest module~s_symba_drift->module~symba_classes module~s_fraggle_util s_fraggle_util module~s_fraggle_util->module~swiftest module~s_tides_kick_getacch s_tides_kick_getacch module~s_tides_kick_getacch->module~swiftest module~s_util_fill s_util_fill module~s_util_fill->module~swiftest module~s_io s_io module~s_io->module~swiftest module~s_helio_setup s_helio_setup module~s_helio_setup->module~helio_classes module~s_helio_setup->module~swiftest module~s_symba_kick s_symba_kick module~s_symba_kick->module~swiftest module~s_symba_kick->module~symba_classes module~s_helio_step s_helio_step module~s_helio_step->module~helio_classes module~s_helio_step->module~swiftest module~s_util_solve s_util_solve module~s_util_solve->module~swiftest module~s_symba_setup s_symba_setup module~s_symba_setup->module~swiftest module~s_symba_setup->module~symba_classes module~s_fraggle_generate s_fraggle_generate module~s_fraggle_generate->module~swiftest module~s_symba_io s_symba_io module~s_symba_io->module~swiftest module~s_symba_io->module~symba_classes module~s_kick s_kick module~s_kick->module~swiftest module~drift_implementation drift_implementation module~drift_implementation->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces whm_coord_h2j_pl whm_coord_j2h_pl whm_coord_vh2vj_pl whm_drift_pl whm_util_index_eucl_plpl whm_kick_getacch_pl whm_kick_getacch_tp whm_kick_vh_pl whm_kick_vh_tp whm_gr_kick_getacch_pl whm_gr_kick_getacch_tp whm_gr_p4_pl whm_gr_p4_tp whm_setup_pl whm_setup_initialize_system whm_step_pl whm_step_system whm_step_tp whm_util_append_pl whm_util_spill_pl whm_util_fill_pl whm_util_resize_pl whm_util_set_ir3j whm_util_set_mu_eta_pl whm_util_sort_pl whm_util_sort_rearrange_pl Derived Types whm_cb whm_pl whm_tp whm_nbody_system Interfaces interface public module subroutine whm_coord_h2j_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree interface public module subroutine whm_coord_j2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree interface public module subroutine whm_coord_vh2vj_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree interface public module subroutine whm_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize interface public subroutine whm_util_index_eucl_plpl(self, param) Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_parameters), intent(in) :: param Current run configuration parameters interface public module subroutine whm_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Get heliocentric accelration of massive bodies Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step interface public module subroutine whm_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Get heliocentric accelration of the test particle Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step interface public module subroutine whm_kick_vh_pl(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. interface public module subroutine whm_kick_vh_tp(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. interface public pure module subroutine whm_gr_kick_getacch_pl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters interface public pure module subroutine whm_gr_kick_getacch_tp(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters interface public pure module subroutine whm_gr_p4_pl(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size interface public pure module subroutine whm_gr_p4_tp(self, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size interface public module subroutine whm_setup_pl(self, n, param) Implementation → Reads WHM massive body object in from file Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body objectobject integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameters interface public module subroutine whm_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( whm_nbody_system ), intent(inout) :: self WHM nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters interface public module subroutine whm_step_pl(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize interface public module subroutine whm_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_nbody_system ), intent(inout) :: self WHM system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize interface public module subroutine whm_step_tp(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize interface public module subroutine whm_util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine whm_util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not interface public module subroutine whm_util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(in) :: inserts inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps interface public module subroutine whm_util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object integer(kind=I4B), intent(in) :: nnew New size neded interface public module subroutine whm_util_set_ir3j(self) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object interface public module subroutine whm_util_set_mu_eta_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object interface public module subroutine whm_util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order interface public module subroutine whm_util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) Derived Types type, public, extends( swiftest_cb ) :: whm_cb Swiftest central body particle class Components Type Visibility Attributes Name Initial type( swiftest_particle_info ), public :: info Particle metadata information integer(kind=I4B), public :: id = 0 External identifier (unique) real(kind=DP), public :: mass = 0.0_DP Central body mass (units MU) real(kind=DP), public :: Gmass = 0.0_DP Central mass gravitational term G * mass (units GU * MU) real(kind=DP), public :: radius = 0.0_DP Central body radius (units DU) real(kind=DP), public :: density = 1.0_DP Central body mass density - calculated internally (units MU / DU**3) real(kind=DP), public :: j2rp2 = 0.0_DP J2*R&#94;2 term for central body real(kind=DP), public :: j4rp4 = 0.0_DP J4*R&#94;2 term for central body real(kind=DP), public, dimension(NDIM) :: aobl = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: atide = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: aoblbeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: aoblend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: atidebeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: atideend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: xb = 0.0_DP Barycentric position (units DU) real(kind=DP), public, dimension(NDIM) :: vb = 0.0_DP Barycentric velocity (units DU / TU) real(kind=DP), public, dimension(NDIM) :: agr = 0.0_DP Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(NDIM) :: Ip = 0.0_DP Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(NDIM) :: rot = 0.0_DP Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public :: k2 = 0.0_DP Tidal Love number real(kind=DP), public :: Q = 0.0_DP Tidal quality factor real(kind=DP), public :: tlag = 0.0_DP Tidal phase lag angle real(kind=DP), public, dimension(NDIM) :: L0 = 0.0_DP Initial angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: dL = 0.0_DP Change in angular momentum of the central body Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file generic, public :: write_particle_info => write_particle_info_netcdf procedure, public :: read_in => io_read_in_cb I/O routine for reading in central body data procedure, public :: read_frame => io_read_frame_cb I/O routine for reading out a single frame of time-series data for the central body procedure, public :: write_frame_bin => io_write_frame_cb I/O routine for writing out a single frame of time-series data for the central body generic, public :: write_frame => write_frame_netcdf, write_frame_bin Write a frame (either binary or NetCDF, using generic procedures) type, public, extends( swiftest_pl ) :: whm_pl WHM massive body particle class Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl real(kind=DP), public, dimension(:), allocatable :: eta Jacobi mass real(kind=DP), public, dimension(:,:), allocatable :: xj Jacobi position real(kind=DP), public, dimension(:,:), allocatable :: vj Jacobi velocity real(kind=DP), public, dimension(:), allocatable :: muj Jacobi mu: GMcb * eta(i) / eta(i - 1) real(kind=DP), public, dimension(:), allocatable :: ir3j Third term of heliocentric acceleration\n Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the\n    component list, such as whm_setup_pl and whm_util_spill_pl Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file generic, public :: write_particle_info => write_particle_info_netcdf procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets generic, public :: write_frame => write_frame_netcdf, write_frame_bin Add the generic write frame for Fortran binary files procedure, public :: discard => discard_pl Placeholder method for discarding massive bodies procedure, public :: index => util_index_eucl_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) procedure, public :: vh2vb => util_coord_vh2vb_pl Convert massive bodies from heliocentric to barycentric coordinates (velocity only) procedure, public :: vb2vh => util_coord_vb2vh_pl Convert massive bodies from barycentric to heliocentric coordinates (velocity only) procedure, public :: xh2xb => util_coord_xh2xb_pl Convert massive bodies from heliocentric to barycentric coordinates (position only) procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body procedure, public :: h2j => whm_coord_h2j_pl Convert position and velcoity vectors from heliocentric to Jacobi coordinates procedure, public :: j2h => whm_coord_j2h_pl Convert position and velcoity vectors from Jacobi to helliocentric coordinates procedure, public :: vh2vj => whm_coord_vh2vj_pl Convert velocity vectors from heliocentric to Jacobi coordinates procedure, public :: drift => whm_drift_pl Loop through massive bodies and call Danby drift routine to jacobi coordinates procedure, public :: accel_gr => whm_gr_kick_getacch_pl Acceleration term arising from the post-Newtonian correction procedure, public :: gr_pos_kick => whm_gr_p4_pl Position kick due to p**4 term in the post-Newtonian correction procedure, public :: accel => whm_kick_getacch_pl Compute heliocentric accelerations of massive bodies procedure, public :: kick => whm_kick_vh_pl Kick heliocentric velocities of massive bodies procedure, public :: append => whm_util_append_pl Appends elements from one structure to another procedure, public :: fill => whm_util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: resize => whm_util_resize_pl Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure, public :: set_ir3 => whm_util_set_ir3j Sets both the heliocentric and jacobi inverse radius terms (1/rj 3 and 1/rh 3) procedure, public :: set_mu => whm_util_set_mu_eta_pl Sets the Jacobi mass value for all massive bodies. procedure, public :: sort => whm_util_sort_pl Sort a WHM massive body object in-place. procedure, public :: rearrange => whm_util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => whm_util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure, public :: setup => whm_setup_pl Constructor method - Allocates space for the input number of bodiess procedure, public :: step => whm_step_pl Steps the body forward one stepsize type, public, extends( swiftest_tp ) :: whm_tp Note to developers: If you add componenets to this class, be sure to update methods and subroutines that traverse the\n    component list, such as whm_util_spill_tp Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill integer(kind=I4B), public, dimension(:), allocatable :: isperi Perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri Perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp Semimajor axis following perihelion passage integer(kind=I4B), public, dimension(:,:), allocatable :: k_pltp Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: npltp Number of pl-tp comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_tp and util_spill_tp Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file generic, public :: write_particle_info => write_particle_info_netcdf procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) generic, public :: write_frame => write_frame_netcdf, write_frame_bin Add the generic write frame for Fortran binary files procedure, public :: discard => discard_tp Check to see if test particles should be discarded based on their positions relative to the massive bodies procedure, public :: accel_int => kick_getacch_int_tp Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies procedure, public :: accel_obl => obl_acc_tp Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: setup => setup_tp A base constructor that sets the number of bodies and procedure, public :: append => util_append_tp Appends elements from one structure to another procedure, public :: h2b => util_coord_h2b_tp Convert test particles from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_tp Convert test particles from barycentric to heliocentric coordinates (position and velocity) procedure, public :: vb2vh => util_coord_vb2vh_tp Convert test particles from barycentric to heliocentric coordinates (velocity only) procedure, public :: vh2vb => util_coord_vh2vb_tp Convert test particles from heliocentric to barycentric coordinates (velocity only) procedure, public :: xh2xb => util_coord_xh2xb_tp Convert test particles from heliocentric to barycentric coordinates (position only) procedure, public :: fill => util_fill_tp \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: get_peri => util_peri_tp Determine system pericenter passages for test particles procedure, public :: resize => util_resize_tp Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure, public :: set_mu => util_set_mu_tp Method used to construct the vectorized form of the central body mass procedure, public :: sort => util_sort_tp Sorts body arrays by a sortable component procedure, public :: rearrange => util_sort_rearrange_tp Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => util_spill_tp \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure, public :: accel_gr => whm_gr_kick_getacch_tp Acceleration term arising from the post-Newtonian correction procedure, public :: gr_pos_kick => whm_gr_p4_tp Position kick due to p**4 term in the post-Newtonian correction procedure, public :: accel => whm_kick_getacch_tp Compute heliocentric accelerations of test particles procedure, public :: kick => whm_kick_vh_tp Kick heliocentric velocities of test particles procedure, public :: step => whm_step_tp Steps the particle forward one stepsize type, public, extends( swiftest_nbody_system ) :: whm_nbody_system An abstract class for the WHM integrator nbody system Components Type Visibility Attributes Name Initial class( swiftest_cb ), public, allocatable :: cb Central body data structure class( swiftest_pl ), public, allocatable :: pl Massive body data structure class( swiftest_tp ), public, allocatable :: tp Test particle data structure class( swiftest_tp ), public, allocatable :: tp_discards Discarded test particle data structure class( swiftest_pl ), public, allocatable :: pl_discards Discarded massive body particle data structure real(kind=DP), public :: GMtot = 0.0_DP Total system mass - used for barycentric coordinate conversion real(kind=DP), public :: ke_orbit = 0.0_DP System orbital kinetic energy real(kind=DP), public :: ke_spin = 0.0_DP System spin kinetic energy real(kind=DP), public :: pe = 0.0_DP System potential energy real(kind=DP), public :: te = 0.0_DP System total energy real(kind=DP), public :: oblpot = 0.0_DP System potential energy due to oblateness of the central body real(kind=DP), public, dimension(NDIM) :: Lorbit = 0.0_DP System orbital angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lspin = 0.0_DP System spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Ltot = 0.0_DP System angular momentum vector logical, public :: lbeg True if this is the beginning of a step. This is used so that test particle steps can be calculated \n    separately from massive bodies.  Massive body variables are saved at half steps, and passed to \n    the test particles Type-Bound Procedures procedure, public :: discard => discard_system Perform a discard step on the system procedure, public :: conservation_report => io_conservation_report Compute energy and momentum and print out the change with time procedure, public :: dump => io_dump_system Dump the state of the system to a file procedure, public :: get_old_t_final => io_get_old_t_final_system Validates the dump file to check whether the dump file initial conditions duplicate the last frame of the binary output. procedure, public :: read_frame => io_read_frame_system Read in a frame of input data from file procedure, public :: read_particle_info => io_read_particle_info_system Read in particle metadata from file procedure, public :: write_discard => io_write_discard Write out information about discarded test particles procedure, public :: write_frame => io_write_frame_system Append a frame of output data to file procedure, public :: write_hdr_bin => io_write_hdr_system Write a header for an output frame in Fortran binary format procedure, public :: write_hdr_netcdf => netcdf_write_hdr_system Write a header for an output frame in NetCDF format procedure, public :: obl_pot => obl_pot_system Compute the contribution to the total gravitational potential due solely to the oblateness of the central body procedure, public :: init_particle_info => setup_initialize_particle_info_system Initialize the system from input files procedure, public :: step_spin => tides_step_spin_system Steps the spins of the massive & central bodies due to tides. procedure, public :: set_msys => util_set_msys Sets the value of msys from the masses of system bodies. procedure, public :: get_energy_and_momentum => util_get_energy_momentum_system Calculates the total system energy and momentum procedure, public :: rescale => util_rescale_system Rescales the system into a new set of units procedure, public :: validate_ids => util_valid_id_system Validate the numerical ids passed to the system and save the maximum value generic, public :: write_hdr => write_hdr_bin, write_hdr_netcdf Generic method call for writing headers procedure, public :: initialize => whm_setup_initialize_system Replace the abstract procedures with concrete ones procedure, public :: step => whm_step_system Advance the WHM nbody system forward in time by one step","tags":"","loc":"module/whm_classes.html"},{"title":"fraggle_classes – swiftest","text":"Definition of classes and methods specific to Fraggel: The Fragment Generation Model fraggle_fragments class definitions and method interfaces Uses swiftest_globals swiftest_classes module~~fraggle_classes~~UsesGraph module~fraggle_classes fraggle_classes module~swiftest_globals swiftest_globals module~fraggle_classes->module~swiftest_globals module~swiftest_classes swiftest_classes module~fraggle_classes->module~swiftest_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~swiftest_classes->module~swiftest_globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: s_fraggle_generate s_fraggle_io s_fraggle_placeholder s_fraggle_regime s_fraggle_set s_fraggle_setup s_fraggle_util module~~fraggle_classes~~UsedByGraph module~fraggle_classes fraggle_classes module~s_fraggle_util s_fraggle_util module~s_fraggle_util->module~fraggle_classes module~swiftest swiftest module~s_fraggle_util->module~swiftest module~s_fraggle_placeholder s_fraggle_placeholder module~s_fraggle_placeholder->module~fraggle_classes module~s_fraggle_placeholder->module~swiftest module~s_fraggle_setup s_fraggle_setup module~s_fraggle_setup->module~fraggle_classes module~s_fraggle_setup->module~swiftest module~s_fraggle_regime s_fraggle_regime module~s_fraggle_regime->module~fraggle_classes module~s_fraggle_regime->module~swiftest module~symba_classes symba_classes module~symba_classes->module~fraggle_classes module~swiftest->module~fraggle_classes module~swiftest->module~symba_classes module~s_fraggle_set s_fraggle_set module~s_fraggle_set->module~fraggle_classes module~s_fraggle_set->module~swiftest module~s_fraggle_generate s_fraggle_generate module~s_fraggle_generate->module~fraggle_classes module~s_fraggle_generate->module~swiftest module~s_fraggle_io s_fraggle_io module~s_fraggle_io->module~fraggle_classes module~s_fraggle_io->module~swiftest module~s_gr s_gr module~s_gr->module~swiftest module~s_symba_collision s_symba_collision module~s_symba_collision->module~symba_classes module~s_symba_collision->module~swiftest module~s_util_valid s_util_valid module~s_util_valid->module~swiftest module~s_obl s_obl module~s_obl->module~swiftest module~s_util_coord s_util_coord module~s_util_coord->module~swiftest module~s_symba_encounter_check s_symba_encounter_check module~s_symba_encounter_check->module~symba_classes module~s_symba_encounter_check->module~swiftest module~s_whm_coord s_whm_coord module~s_whm_coord->module~swiftest module~s_util_rescale s_util_rescale module~s_util_rescale->module~swiftest module~s_util_get_energy_momentum s_util_get_energy_momentum module~s_util_get_energy_momentum->module~swiftest module~s_rmvs_step s_rmvs_step module~s_rmvs_step->module~swiftest module~s_util_index s_util_index module~s_util_index->module~swiftest proc~ge_wpp ge_wpp proc~ge_wpp->module~swiftest module~s_operator_cross s_operator_cross module~s_operator_cross->module~swiftest module~s_rmvs_kick s_rmvs_kick module~s_rmvs_kick->module~swiftest module~s_util_set s_util_set module~s_util_set->module~swiftest module~s_rmvs_io s_rmvs_io module~s_rmvs_io->module~swiftest module~s_util_version s_util_version module~s_util_version->module~swiftest module~s_tides_step_spin s_tides_step_spin module~s_tides_step_spin->module~swiftest proc~solve_wbs solve_wbs proc~solve_wbs->module~swiftest module~s_orbel s_orbel module~s_orbel->module~swiftest module~s_whm_gr s_whm_gr module~s_whm_gr->module~swiftest module~s_rmvs_chk s_rmvs_chk module~s_rmvs_chk->module~swiftest module~s_rmvs_discard s_rmvs_discard module~s_rmvs_discard->module~swiftest module~s_util_exit s_util_exit module~s_util_exit->module~swiftest module~s_netcdf s_netcdf module~s_netcdf->module~swiftest module~s_util_peri s_util_peri module~s_util_peri->module~swiftest module~s_helio_drift s_helio_drift module~s_helio_drift->module~swiftest module~s_setup s_setup module~s_setup->module~swiftest module~s_helio_kick s_helio_kick module~s_helio_kick->module~swiftest module~s_util_append s_util_append module~s_util_append->module~swiftest module~s_rmvs_util s_rmvs_util module~s_rmvs_util->module~swiftest program~swiftest_driver swiftest_driver program~swiftest_driver->module~swiftest module~s_symba_step s_symba_step module~s_symba_step->module~symba_classes module~s_symba_step->module~swiftest module~s_symba_util s_symba_util module~s_symba_util->module~symba_classes module~s_symba_util->module~swiftest module~s_util_copy s_util_copy module~s_util_copy->module~swiftest module~s_discard s_discard module~s_discard->module~swiftest module~s_util_sort s_util_sort module~s_util_sort->module~swiftest module~s_whm_setup s_whm_setup module~s_whm_setup->module~swiftest module~s_util_resize s_util_resize module~s_util_resize->module~swiftest module~s_helio_gr s_helio_gr module~s_helio_gr->module~swiftest module~orbel orbel module~orbel->module~swiftest module~s_whm_util s_whm_util module~s_whm_util->module~swiftest module~s_rmvs_setup s_rmvs_setup module~s_rmvs_setup->module~swiftest module~s_util_spill s_util_spill module~s_util_spill->module~swiftest module~s_util_minimize_bfgs s_util_minimize_bfgs module~s_util_minimize_bfgs->module~swiftest module~s_user_kick_getacch s_user_kick_getacch module~s_user_kick_getacch->module~swiftest module~s_symba_discard s_symba_discard module~s_symba_discard->module~symba_classes module~s_symba_discard->module~swiftest module~s_symba_drift s_symba_drift module~s_symba_drift->module~symba_classes module~s_symba_drift->module~swiftest module~s_whm_kick s_whm_kick module~s_whm_kick->module~swiftest module~whm_drift whm_drift module~whm_drift->module~swiftest module~s_symba_kick s_symba_kick module~s_symba_kick->module~symba_classes module~s_symba_kick->module~swiftest module~s_tides_kick_getacch s_tides_kick_getacch module~s_tides_kick_getacch->module~swiftest module~s_util_fill s_util_fill module~s_util_fill->module~swiftest module~s_io s_io module~s_io->module~swiftest module~s_helio_setup s_helio_setup module~s_helio_setup->module~swiftest module~s_util_solve s_util_solve module~s_util_solve->module~swiftest module~s_helio_step s_helio_step module~s_helio_step->module~swiftest module~s_whm_step s_whm_step module~s_whm_step->module~swiftest module~s_symba_setup s_symba_setup module~s_symba_setup->module~symba_classes module~s_symba_setup->module~swiftest module~s_symba_io s_symba_io module~s_symba_io->module~symba_classes module~s_symba_io->module~swiftest module~s_kick s_kick module~s_kick->module~swiftest module~drift_implementation drift_implementation module~drift_implementation->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables FRAGGLE_NMASS_DIST FRAGGLE_LOG_OUT FRAGGLE_LOG_UNIT Interfaces fraggle_util_vmag_to_vb fraggle_generate_fragments fraggle_io_log_generate fraggle_io_log_one_message fraggle_io_log_pl fraggle_io_log_regime fraggle_io_log_start fraggle_placeholder_accel fraggle_placeholder_kick fraggle_placeholder_step fraggle_regime_colliders fraggle_set_budgets_fragments fraggle_set_coordinate_system fraggle_set_mass_dist_fragments fraggle_set_natural_scale_factors fraggle_set_original_scale_factors fraggle_setup_fragments fraggle_setup_reset_fragments fraggle_util_add_fragments_to_system fraggle_util_ang_mtm fraggle_util_construct_temporary_system fraggle_util_get_energy_momentum fraggle_util_restructure fraggle_util_shift_vector_to_origin Derived Types fraggle_colliders fraggle_fragments Variables Type Visibility Attributes Name Initial integer(kind=I4B), public, parameter :: FRAGGLE_NMASS_DIST = 3 Number of mass bins returned by the regime calculation (largest fragment, second largest, and remainder) character(len=*), public, parameter :: FRAGGLE_LOG_OUT = \"fraggle.log\" Name of log file for Fraggle diagnostic information integer(kind=I4B), public, parameter :: FRAGGLE_LOG_UNIT = 76 Unit number for Fraggle log file fraggle_colliders class definitions and method interfaces Interfaces interface public module function fraggle_util_vmag_to_vb(v_r_mag, v_r_unit, v_t_mag, v_t_unit, m_frag, vcom) result(vb) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: v_r_mag Unknown radial component of fragment velocity vector real(kind=DP), intent(in), dimension(:,:) :: v_r_unit Radial and tangential unit vectors for each fragment real(kind=DP), intent(in), dimension(:) :: v_t_mag Tangential component of velocity vector set previously by angular momentum constraint real(kind=DP), intent(in), dimension(:,:) :: v_t_unit Radial and tangential unit vectors for each fragment real(kind=DP), intent(in), dimension(:) :: m_frag Fragment masses real(kind=DP), intent(in), dimension(:) :: vcom Barycentric velocity of collisional system center of mass Return Value real(kind=DP),\n  dimension(:,:), allocatable interface public module subroutine fraggle_generate_fragments(self, colliders, system, param, lfailure) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle colliders object containing the two-body equivalent values of the colliding bodies class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters logical, intent(out) :: lfailure Answers the question: Should this have been a merger instead? interface public module subroutine fraggle_io_log_generate(frag) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(in) :: frag interface public module subroutine fraggle_io_log_one_message(message) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message interface public module subroutine fraggle_io_log_pl(pl, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(in) :: pl Swiftest massive body object (only the new bodies generated in a collision) class( swiftest_parameters ), intent(in) :: param Current swiftest run configuration parameters interface public module subroutine fraggle_io_log_regime(colliders, frag) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_colliders ), intent(in) :: colliders class( fraggle_fragments ), intent(in) :: frag interface public module subroutine fraggle_io_log_start(param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param interface public module subroutine fraggle_placeholder_accel(self, system, param, t, lbeg) Implementation → The following interfaces are placeholders intended to satisfy the required abstract methods given by the parent class Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step interface public module subroutine fraggle_placeholder_kick(self, system, param, t, dt, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system objec class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. interface public module subroutine fraggle_placeholder_step(self, system, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Helio massive body particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nboody system class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsiz interface public module subroutine fraggle_regime_colliders(self, frag, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_colliders ), intent(inout) :: self Fraggle colliders object class( fraggle_fragments ), intent(inout) :: frag Fraggle fragment system object class( swiftest_nbody_system ), intent(in) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current Swiftest run configuration parameters interface public module subroutine fraggle_set_budgets_fragments(self, colliders) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object interface public module subroutine fraggle_set_coordinate_system(self, colliders) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object interface public module subroutine fraggle_set_mass_dist_fragments(self, colliders, param) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object class( swiftest_parameters ), intent(in) :: param Current Swiftest run configuration parameters interface public module subroutine fraggle_set_natural_scale_factors(self, colliders) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object interface public module subroutine fraggle_set_original_scale_factors(self, colliders) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object interface public module subroutine fraggle_setup_fragments(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object integer(kind=I4B), intent(in) :: n Number of fragments class( swiftest_parameters ), intent(in) :: param Current swiftest run configuration parameters interface public module subroutine fraggle_setup_reset_fragments(self) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self interface public module subroutine fraggle_util_add_fragments_to_system(frag, colliders, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(in) :: frag Fraggle fragment system object class( fraggle_colliders ), intent(in) :: colliders Fraggle collider system object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current swiftest run configuration parameters interface public module subroutine fraggle_util_ang_mtm(self) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object interface public module subroutine fraggle_util_construct_temporary_system(frag, system, param, tmpsys, tmpparam) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(in) :: frag Fraggle fragment system object class( swiftest_nbody_system ), intent(in) :: system Original swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current swiftest run configuration parameters class( swiftest_nbody_system ), intent(out), allocatable :: tmpsys Output temporary swiftest nbody system object class( swiftest_parameters ), intent(out), allocatable :: tmpparam Output temporary configuration run parameters interface public module subroutine fraggle_util_get_energy_momentum(self, colliders, system, param, lbefore) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current swiftest run configuration parameters logical, intent(in) :: lbefore Flag indicating that this the \"before\" state of the system, with colliders included and fragments excluded or vice versa interface public module subroutine fraggle_util_restructure(self, colliders, try, f_spin, r_max_start) Implementation → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(in) :: colliders Fraggle collider system object integer(kind=I4B), intent(in) :: try The current number of times Fraggle has tried to find a solution real(kind=DP), intent(inout) :: f_spin Fraction of energy/momentum that goes into spin. This decreases ater a failed attempt real(kind=DP), intent(inout) :: r_max_start The maximum radial distance that the position calculation starts with. This increases after a failed attempt interface public module subroutine fraggle_util_shift_vector_to_origin(m_frag, vec_frag) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: m_frag Fragment masses real(kind=DP), intent(inout), dimension(:,:) :: vec_frag Fragment positions or velocities in the center of mass frame Derived Types type, public :: fraggle_colliders Class definition for the variables that describe the bodies involved in the collision Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: ncoll Number of bodies involved in the collision integer(kind=I4B), public, dimension(:), allocatable :: idx Index of bodies involved in the collision real(kind=DP), public, dimension(NDIM,2) :: xb Two-body equivalent position vectors of the collider bodies prior to collision real(kind=DP), public, dimension(NDIM,2) :: vb Two-body equivalent velocity vectors of the collider bodies prior to collision real(kind=DP), public, dimension(NDIM,2) :: rot Two-body equivalent principal axes moments of inertia the collider bodies prior to collision real(kind=DP), public, dimension(NDIM,2) :: L_spin Two-body equivalent spin angular momentum vectors of the collider bodies prior to collision real(kind=DP), public, dimension(NDIM,2) :: L_orbit Two-body equivalent orbital angular momentum vectors of the collider bodies prior to collision real(kind=DP), public, dimension(NDIM,2) :: Ip Two-body equivalent principal axes moments of inertia the collider bodies prior to collision real(kind=DP), public, dimension(2) :: mass Two-body equivalent mass of the collider bodies prior to the collision real(kind=DP), public, dimension(2) :: radius Two-body equivalent radii of the collider bodies prior to the collision Type-Bound Procedures procedure, public :: regime => fraggle_regime_colliders Determine which fragmentation regime the set of colliders will be type, public, extends( swiftest_pl ) :: fraggle_fragments Class definition for the variables that describe a collection of fragments by Fraggle barycentric coordinates Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl real(kind=DP), public :: mtot Total mass of fragments real(kind=DP), public :: Qloss Energy lost during the collision real(kind=DP), public, dimension(FRAGGLE_NMASS_DIST) :: mass_dist Distribution of fragment mass determined by the regime calculation (largest fragment, second largest, and remainder) integer(kind=I4B), public :: regime Collresolve regime code for this collision real(kind=DP), public, dimension(NDIM) :: xbcom Center of mass position vector of the collider system in system barycentric coordinates real(kind=DP), public, dimension(NDIM) :: vbcom Velocity vector of the center of mass of the collider system in system barycentric coordinates real(kind=DP), public, dimension(NDIM) :: x_coll_unit x-direction unit vector of collisional system real(kind=DP), public, dimension(NDIM) :: y_coll_unit y-direction unit vector of collisional system real(kind=DP), public, dimension(NDIM) :: z_coll_unit z-direction unit vector of collisional system real(kind=DP), public, dimension(:,:), allocatable :: x_coll Array of fragment position vectors in the collisional coordinate frame real(kind=DP), public, dimension(:,:), allocatable :: v_coll Array of fragment velocity vectors in the collisional coordinate frame real(kind=DP), public, dimension(:,:), allocatable :: v_r_unit Array of radial direction unit vectors of individual fragments in the collisional coordinate frame real(kind=DP), public, dimension(:,:), allocatable :: v_t_unit Array of tangential direction unit vectors of individual fragments in the collisional coordinate frame real(kind=DP), public, dimension(:,:), allocatable :: v_n_unit Array of normal direction unit vectors of individual fragments in the collisional coordinate frame real(kind=DP), public, dimension(:), allocatable :: rmag Array of radial distance magnitudes of individual fragments in the collisional coordinate frame real(kind=DP), public, dimension(:), allocatable :: rotmag Array of rotation magnitudes of individual fragments real(kind=DP), public, dimension(:), allocatable :: v_r_mag Array of radial direction velocity magnitudes of individual fragments real(kind=DP), public, dimension(:), allocatable :: v_t_mag Array of tangential direction velocity magnitudes of individual fragments real(kind=DP), public :: ke_orbit Current orbital kinetic energy of the system of fragments in the collisional frame real(kind=DP), public :: ke_spin Current spin kinetic energy of the system of fragments in the collisional frame real(kind=DP), public, dimension(NDIM) :: L_orbit Current orbital angular momentum of the system of fragments in the collisional frame real(kind=DP), public, dimension(NDIM) :: L_spin Current spin angular momentum of the system of fragments in the collisional frame real(kind=DP), public :: ke_budget Total kinetic energy budget for the system of fragmens in the collisional frame real(kind=DP), public, dimension(NDIM) :: L_budget Total angular momentum budget for the system of fragmens in the collisional frame real(kind=DP), public, dimension(NDIM) :: Lorbit_before Before/after orbital angular momentum real(kind=DP), public, dimension(NDIM) :: Lorbit_after Before/after orbital angular momentum real(kind=DP), public, dimension(NDIM) :: Lspin_before Before/after spin angular momentum real(kind=DP), public, dimension(NDIM) :: Lspin_after Before/after spin angular momentum real(kind=DP), public, dimension(NDIM) :: Ltot_before Before/after total system angular momentum real(kind=DP), public, dimension(NDIM) :: Ltot_after Before/after total system angular momentum real(kind=DP), public :: ke_orbit_before Before/after orbital kinetic energy real(kind=DP), public :: ke_orbit_after Before/after orbital kinetic energy real(kind=DP), public :: ke_spin_before Before/after spin kinetic energy real(kind=DP), public :: ke_spin_after Before/after spin kinetic energy real(kind=DP), public :: pe_before Before/after potential energy real(kind=DP), public :: pe_after Before/after potential energy real(kind=DP), public :: Etot_before Before/after total system energy real(kind=DP), public :: Etot_after Before/after total system energy real(kind=DP), public :: dscale Distance dimension scale factor real(kind=DP), public :: mscale Mass scale factor real(kind=DP), public :: tscale Time scale factor real(kind=DP), public :: vscale Velocity scale factor (a convenience unit that is derived from dscale and tscale) real(kind=DP), public :: Escale Energy scale factor (a convenience unit that is derived from dscale, tscale, and mscale) real(kind=DP), public :: Lscale Angular momentum scale factor (a convenience unit that is derived from dscale, tscale, and mscale) Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file generic, public :: write_particle_info => write_particle_info_netcdf procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) generic, public :: write_frame => write_frame_netcdf, write_frame_bin Add the generic write frame for Fortran binary files procedure, public :: discard => discard_pl Placeholder method for discarding massive bodies procedure, public :: index => util_index_eucl_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body procedure, public :: append => util_append_pl Appends elements from one structure to another procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) procedure, public :: vh2vb => util_coord_vh2vb_pl Convert massive bodies from heliocentric to barycentric coordinates (velocity only) procedure, public :: vb2vh => util_coord_vb2vh_pl Convert massive bodies from barycentric to heliocentric coordinates (velocity only) procedure, public :: xh2xb => util_coord_xh2xb_pl Convert massive bodies from heliocentric to barycentric coordinates (position only) procedure, public :: fill => util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: resize => util_resize_pl Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. procedure, public :: set_mu => util_set_mu_pl Method used to construct the vectorized form of the central body mass procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body procedure, public :: sort => util_sort_pl Sorts body arrays by a sortable component procedure, public :: rearrange => util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure, public :: generate_fragments => fraggle_generate_fragments Generates a system of fragments in barycentric coordinates that conserves energy and momentum. procedure, public :: accel => fraggle_placeholder_accel Placeholder subroutine to fulfill requirement for an accel method procedure, public :: kick => fraggle_placeholder_kick Placeholder subroutine to fulfill requirement for a kick method procedure, public :: step => fraggle_placeholder_step Placeholder subroutine to fulfill requirement for a step method procedure, public :: set_budgets => fraggle_set_budgets_fragments Sets the energy and momentum budgets of the fragments based on the collider value procedure, public :: set_coordinate_system => fraggle_set_coordinate_system Defines the collisional coordinate system, including the unit vectors of both the system and individual fragments. procedure, public :: set_mass_dist => fraggle_set_mass_dist_fragments Sets the distribution of mass among the fragments depending on the regime type procedure, public :: set_natural_scale => fraggle_set_natural_scale_factors Scales dimenional quantities to ~O(1) with respect to the collisional system. procedure, public :: set_original_scale => fraggle_set_original_scale_factors Restores dimenional quantities back to the original system units procedure, public :: setup => fraggle_setup_fragments Allocates arrays for n fragments in a Fraggle system. Passing n = 0 deallocates all arrays. procedure, public :: reset => fraggle_setup_reset_fragments Resets all position and velocity-dependent fragment quantities in order to do a fresh calculation (does not reset mass, radius, or other values that get set prior to the call to fraggle_generate) procedure, public :: get_ang_mtm => fraggle_util_ang_mtm Calcualtes the current angular momentum of the fragments procedure, public :: get_energy_and_momentum => fraggle_util_get_energy_momentum Calculates total system energy in either the pre-collision outcome state (lbefore = .true.) or the post-collision outcome state (lbefore = .false.) procedure, public :: restructure => fraggle_util_restructure Restructure the inputs after a failed attempt failed to find a set of positions and velocities that satisfy the energy and momentum constraints","tags":"","loc":"module/fraggle_classes.html"},{"title":"symba_classes – swiftest","text":"Definition of classes and methods specific to the SyMBA integrator\n Adapted from David E. Kaufmann's Swifter routine: module_symba.f90 symba_kinship class definitions and method interfaces symba_cb class definitions and method interfaces symba_pl class definitions and method interfaces symba_tp class definitions and method interfaces symba_encounter class definitions and method interfaces symba_pltpenc class definitions and method interfaces symba_plplenc class definitions and method interfaces symba_nbody_system class definitions and method interfaces Uses swiftest_globals swiftest_classes helio_classes fraggle_classes module~~symba_classes~~UsesGraph module~symba_classes symba_classes module~swiftest_globals swiftest_globals module~symba_classes->module~swiftest_globals module~swiftest_classes swiftest_classes module~symba_classes->module~swiftest_classes module~helio_classes helio_classes module~symba_classes->module~helio_classes module~fraggle_classes fraggle_classes module~symba_classes->module~fraggle_classes iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env module~swiftest_classes->module~swiftest_globals module~helio_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~whm_classes whm_classes module~helio_classes->module~whm_classes module~fraggle_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: s_symba_collision s_symba_discard s_symba_drift s_symba_encounter_check s_symba_io s_symba_kick s_symba_setup s_symba_step s_symba_util module~~symba_classes~~UsedByGraph module~symba_classes symba_classes module~s_symba_discard s_symba_discard module~s_symba_discard->module~symba_classes module~swiftest swiftest module~s_symba_discard->module~swiftest module~s_symba_drift s_symba_drift module~s_symba_drift->module~symba_classes module~s_symba_drift->module~swiftest module~s_symba_collision s_symba_collision module~s_symba_collision->module~symba_classes module~s_symba_collision->module~swiftest module~s_symba_kick s_symba_kick module~s_symba_kick->module~symba_classes module~s_symba_kick->module~swiftest module~s_symba_step s_symba_step module~s_symba_step->module~symba_classes module~s_symba_step->module~swiftest module~s_symba_util s_symba_util module~s_symba_util->module~symba_classes module~s_symba_util->module~swiftest module~s_symba_encounter_check s_symba_encounter_check module~s_symba_encounter_check->module~symba_classes module~s_symba_encounter_check->module~swiftest module~swiftest->module~symba_classes module~s_symba_setup s_symba_setup module~s_symba_setup->module~symba_classes module~s_symba_setup->module~swiftest module~s_symba_io s_symba_io module~s_symba_io->module~symba_classes module~s_symba_io->module~swiftest module~s_fraggle_placeholder s_fraggle_placeholder module~s_fraggle_placeholder->module~swiftest module~s_gr s_gr module~s_gr->module~swiftest module~s_util_valid s_util_valid module~s_util_valid->module~swiftest module~s_obl s_obl module~s_obl->module~swiftest module~s_fraggle_setup s_fraggle_setup module~s_fraggle_setup->module~swiftest module~s_util_coord s_util_coord module~s_util_coord->module~swiftest module~s_whm_coord s_whm_coord module~s_whm_coord->module~swiftest module~s_util_rescale s_util_rescale module~s_util_rescale->module~swiftest module~s_util_get_energy_momentum s_util_get_energy_momentum module~s_util_get_energy_momentum->module~swiftest module~s_rmvs_step s_rmvs_step module~s_rmvs_step->module~swiftest module~s_util_index s_util_index module~s_util_index->module~swiftest proc~ge_wpp ge_wpp proc~ge_wpp->module~swiftest module~s_operator_cross s_operator_cross module~s_operator_cross->module~swiftest module~s_fraggle_set s_fraggle_set module~s_fraggle_set->module~swiftest module~s_fraggle_io s_fraggle_io module~s_fraggle_io->module~swiftest module~s_rmvs_kick s_rmvs_kick module~s_rmvs_kick->module~swiftest module~s_util_set s_util_set module~s_util_set->module~swiftest module~s_rmvs_io s_rmvs_io module~s_rmvs_io->module~swiftest module~s_util_version s_util_version module~s_util_version->module~swiftest module~s_tides_step_spin s_tides_step_spin module~s_tides_step_spin->module~swiftest proc~solve_wbs solve_wbs proc~solve_wbs->module~swiftest module~s_orbel s_orbel module~s_orbel->module~swiftest module~s_whm_gr s_whm_gr module~s_whm_gr->module~swiftest module~s_rmvs_chk s_rmvs_chk module~s_rmvs_chk->module~swiftest module~s_fraggle_regime s_fraggle_regime module~s_fraggle_regime->module~swiftest module~s_util_exit s_util_exit module~s_util_exit->module~swiftest module~s_netcdf s_netcdf module~s_netcdf->module~swiftest module~s_rmvs_discard s_rmvs_discard module~s_rmvs_discard->module~swiftest module~s_util_peri s_util_peri module~s_util_peri->module~swiftest module~s_helio_drift s_helio_drift module~s_helio_drift->module~swiftest module~s_setup s_setup module~s_setup->module~swiftest module~s_helio_kick s_helio_kick module~s_helio_kick->module~swiftest module~s_util_append s_util_append module~s_util_append->module~swiftest module~s_rmvs_util s_rmvs_util module~s_rmvs_util->module~swiftest program~swiftest_driver swiftest_driver program~swiftest_driver->module~swiftest module~s_util_copy s_util_copy module~s_util_copy->module~swiftest module~s_discard s_discard module~s_discard->module~swiftest module~s_util_sort s_util_sort module~s_util_sort->module~swiftest module~s_whm_setup s_whm_setup module~s_whm_setup->module~swiftest module~s_util_resize s_util_resize module~s_util_resize->module~swiftest module~s_helio_gr s_helio_gr module~s_helio_gr->module~swiftest module~orbel orbel module~orbel->module~swiftest module~s_whm_util s_whm_util module~s_whm_util->module~swiftest module~s_rmvs_setup s_rmvs_setup module~s_rmvs_setup->module~swiftest module~s_util_spill s_util_spill module~s_util_spill->module~swiftest module~s_util_minimize_bfgs s_util_minimize_bfgs module~s_util_minimize_bfgs->module~swiftest module~s_user_kick_getacch s_user_kick_getacch module~s_user_kick_getacch->module~swiftest module~s_whm_kick s_whm_kick module~s_whm_kick->module~swiftest module~s_fraggle_util s_fraggle_util module~s_fraggle_util->module~swiftest module~whm_drift whm_drift module~whm_drift->module~swiftest module~s_tides_kick_getacch s_tides_kick_getacch module~s_tides_kick_getacch->module~swiftest module~s_util_fill s_util_fill module~s_util_fill->module~swiftest module~s_io s_io module~s_io->module~swiftest module~s_helio_setup s_helio_setup module~s_helio_setup->module~swiftest module~s_util_solve s_util_solve module~s_util_solve->module~swiftest module~s_helio_step s_helio_step module~s_helio_step->module~swiftest module~s_whm_step s_whm_step module~s_whm_step->module~swiftest module~s_kick s_kick module~s_kick->module~swiftest module~s_fraggle_generate s_fraggle_generate module~s_fraggle_generate->module~swiftest module~drift_implementation drift_implementation module~drift_implementation->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables NENMAX NTENC RHSCALE RSHELL Interfaces symba_collision_check_encounter symba_encounter_check_pl symba_encounter_check symba_encounter_check_tp symba_collision_casedisruption symba_collision_casehitandrun symba_collision_casemerge symba_collision_encounter_extract_collisions symba_collision_make_colliders_pl symba_collision_resolve_fragmentations symba_collision_resolve_mergers symba_collision_resolve_plplenc symba_collision_resolve_pltpenc symba_discard_pl symba_drift_pl symba_drift_tp symba_encounter_check_one symba_util_index_eucl_plpl symba_io_param_reader symba_io_param_writer symba_io_write_discard symba_kick_getacch_int_pl symba_kick_getacch_pl symba_kick_getacch_tp symba_kick_encounter symba_setup_initialize_system symba_setup_merger symba_setup_pl symba_setup_encounter symba_setup_tp symba_step_system symba_step_interp_system symba_step_set_recur_levels_system symba_step_recur_system symba_step_reset_system util_append symba_util_append_encounter symba_util_append_merger symba_util_append_pl symba_util_append_tp symba_util_copy_encounter util_fill symba_util_fill_pl symba_util_fill_tp symba_util_peri_pl symba_util_rearray_pl symba_util_reset_kinship util_resize symba_util_resize_merger symba_util_resize_pl symba_util_resize_tp symba_util_sort_pl symba_util_sort_tp util_sort_rearrange symba_util_sort_rearrange_pl symba_util_sort_rearrange_tp util_spill symba_util_spill_pl symba_util_spill_encounter symba_util_spill_tp Derived Types symba_parameters symba_kinship symba_cb symba_pl symba_merger symba_tp symba_encounter symba_pltpenc symba_plplenc symba_nbody_system Variables Type Visibility Attributes Name Initial integer(kind=I4B), private, parameter :: NENMAX = 32767 integer(kind=I4B), private, parameter :: NTENC = 3 real(kind=DP), private, parameter :: RHSCALE = 6.5_DP real(kind=DP), private, parameter :: RSHELL = 0.48075_DP Interfaces interface public module function symba_collision_check_encounter(self, system, param, t, dt, irec) result(lany_collision) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t current time real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if cany pair of encounters resulted in a collision n interface public module function symba_encounter_check_pl(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter interface public module function symba_encounter_check(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-pl encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter interface public module function symba_encounter_check_tp(self, system, dt, irec) result(lany_encounter) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter interface public module function symba_collision_casedisruption(system, param, colliders, frag) result(status) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions class( fraggle_colliders ), intent(inout) :: colliders Fraggle colliders object class( fraggle_fragments ), intent(inout) :: frag Fraggle fragmentation system object Return Value integer(kind=I4B) Status flag assigned to this outcome interface public module function symba_collision_casehitandrun(system, param, colliders, frag) result(status) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions class( fraggle_colliders ), intent(inout) :: colliders Fraggle colliders object class( fraggle_fragments ), intent(inout) :: frag Fraggle fragmentation system object Return Value integer(kind=I4B) Status flag assigned to this outcome interface public module function symba_collision_casemerge(system, param, colliders, frag) result(status) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions class( fraggle_colliders ), intent(inout) :: colliders Fraggle colliders object class( fraggle_fragments ), intent(inout) :: frag Fraggle fragmentation system object Return Value integer(kind=I4B) Status flag assigned to this outcome interface public module subroutine symba_collision_encounter_extract_collisions(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine symba_collision_make_colliders_pl(self, idx) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(2) :: idx Array holding the indices of the two bodies involved in the collision interface public module subroutine symba_collision_resolve_fragmentations(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions interface public module subroutine symba_collision_resolve_mergers(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions interface public module subroutine symba_collision_resolve_plplenc(self, system, param, t, dt, irec) Implementation → Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current simulation step size integer(kind=I4B), intent(in) :: irec Current recursion level interface public module subroutine symba_collision_resolve_pltpenc(self, system, param, t, dt, irec) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-tp encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current simulation step size integer(kind=I4B), intent(in) :: irec Current recursion level interface public module subroutine symba_discard_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine symba_drift_pl(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize interface public module subroutine symba_drift_tp(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize interface public pure module subroutine symba_encounter_check_one(xr, yr, zr, vxr, vyr, vzr, rhill1, rhill2, dt, irec, lencounter, lvdotr) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: xr real(kind=DP), intent(in) :: yr real(kind=DP), intent(in) :: zr real(kind=DP), intent(in) :: vxr real(kind=DP), intent(in) :: vyr real(kind=DP), intent(in) :: vzr real(kind=DP), intent(in) :: rhill1 real(kind=DP), intent(in) :: rhill2 real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: irec logical, intent(out) :: lencounter logical, intent(out) :: lvdotr interface public module subroutine symba_util_index_eucl_plpl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine symba_io_param_reader(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_parameters ), intent(inout) :: self Current run configuration parameters with SyMBA additionss integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) The first element passes the integrator code to the reader integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 interface public module subroutine symba_io_param_writer(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_parameters ), intent(in) :: self Current run configuration parameters with SyMBA additions integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) Not used in this procedure integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 interface public module subroutine symba_io_write_discard(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine symba_kick_getacch_int_pl(self) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self interface public module subroutine symba_kick_getacch_pl(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step interface public module subroutine symba_kick_getacch_tp(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step interface public module subroutine symba_kick_encounter(self, system, dt, irec, sgn) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(in) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level integer(kind=I4B), intent(in) :: sgn sign to be applied to acceleration interface public module subroutine symba_setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine symba_setup_merger(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA merger list object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine symba_setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine symba_setup_encounter(self, n) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-tp encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for interface public module subroutine symba_setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter interface public module subroutine symba_step_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize interface public module subroutine symba_step_interp_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize interface public module subroutine symba_step_set_recur_levels_system(self, ireci) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system objec integer(kind=I4B), intent(in) :: ireci Input recursion level interface public recursive module subroutine symba_step_recur_system(self, param, t, ireci) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: ireci input recursion level interface public module subroutine symba_step_reset_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions public interface util_append public subroutine symba_util_append_arr_kin(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: arr Destination array type( symba_kinship ), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine symba_util_append_encounter(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA encounter list object class( swiftest_encounter ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine symba_util_append_merger(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine symba_util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine symba_util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine symba_util_copy_encounter(self, source) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self Encounter list class( swiftest_encounter ), intent(in) :: source Source object to copy into public interface util_fill public subroutine symba_util_fill_arr_kin(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_kinship ), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps interface public module subroutine symba_util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps interface public module subroutine symba_util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps interface public module subroutine symba_util_peri_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine symba_util_rearray_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions interface public module subroutine symba_util_reset_kinship(self, idx) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: idx Index array of bodies to reset public interface util_resize public subroutine symba_util_resize_arr_kin(arr, nnew) Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size interface public module subroutine symba_util_resize_merger(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA merger list object integer(kind=I4B), intent(in) :: nnew New size neded interface public module subroutine symba_util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: nnew New size neded interface public module subroutine symba_util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: nnew New size neded interface public module subroutine symba_util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order interface public module subroutine symba_util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order public interface util_sort_rearrange public subroutine symba_util_sort_rearrange_arr_kin(arr, ind, n) Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange interface public module subroutine symba_util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) interface public module subroutine symba_util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) public interface util_spill public subroutine symba_util_spill_arr_kin(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_kinship ), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not interface public module subroutine symba_util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not interface public module subroutine symba_util_spill_encounter(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-tp encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list interface public module subroutine symba_util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not Derived Types type, public, extends( swiftest_parameters ) :: symba_parameters Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: integrator = UNKNOWN_INTEGRATOR Symbolic name of the nbody integrator  used integer(kind=I4B), public :: maxid = -1 The current maximum particle id number real(kind=DP), public :: t0 = -1.0_DP Integration start time real(kind=DP), public :: t = -1.0_DP Integration current time real(kind=DP), public :: tstop = -1.0_DP Integration stop time real(kind=DP), public :: dt = -1.0_DP Time step integer(kind=I8B), public :: ioutput = 0_I8B Output counter character(len=STRMAX), public :: incbfile = CB_INFILE Name of input file for the central body character(len=STRMAX), public :: inplfile = PL_INFILE Name of input file for massive bodies character(len=STRMAX), public :: intpfile = TP_INFILE Name of input file for test particles character(len=STRMAX), public :: in_type = ASCII_TYPE Data representation type of input data files character(len=STRMAX), public :: in_form = XV Format of input data files (EL or XV) integer(kind=I4B), public :: istep_out = -1 Number of time steps between binary outputs character(len=STRMAX), public :: outfile = NETCDF_OUTFILE Name of output binary file character(len=STRMAX), public :: out_type = NETCDF_DOUBLE_TYPE Binary format of output file character(len=STRMAX), public :: out_form = XVEL Data to write to output file character(len=STRMAX), public :: out_stat = 'NEW' Open status for output binary file character(len=STRMAX), public :: particle_out = PARTICLE_OUTFILE Name of output particle information file integer(kind=I4B), public :: istep_dump = -1 Number of time steps between dumps real(kind=DP), public :: rmin = -1.0_DP Minimum heliocentric radius for test particle real(kind=DP), public :: rmax = -1.0_DP Maximum heliocentric radius for test particle real(kind=DP), public :: rmaxu = -1.0_DP Maximum unbound heliocentric radius for test particle real(kind=DP), public :: qmin = -1.0_DP Minimum pericenter distance for test particle character(len=STRMAX), public :: qmin_coord = 'HELIO' Coordinate frame to use for qmin real(kind=DP), public :: qmin_alo = -1.0_DP Minimum semimajor axis for qmin real(kind=DP), public :: qmin_ahi = -1.0_DP Maximum semimajor axis for qmin character(len=STRMAX), public :: enc_out = \"\" Name of output file for encounters character(len=STRMAX), public :: discard_out = \"\" Name of output file for discards real(kind=QP), public :: MU2KG = -1.0_QP Converts mass units to grams real(kind=QP), public :: TU2S = -1.0_QP Converts time units to seconds real(kind=QP), public :: DU2M = -1.0_QP Converts distance unit to centimeters real(kind=DP), public :: GU = -1.0_DP Universal gravitational constant in the system units real(kind=DP), public :: inv_c2 = -1.0_DP Inverse speed of light squared in the system units character(len=STRMAX), public :: energy_out = \"\" Name of output energy and momentum report file logical, public :: lrhill_present = .false. Hill radii are given as an input rather than calculated by the code (can be used to inflate close encounter regions manually) logical, public :: lextra_force = .false. User defined force function turned on logical, public :: lbig_discard = .false. Save big bodies on every discard logical, public :: lclose = .false. Turn on close encounters logical, public :: lenergy = .false. Track the total energy of the system logical, public :: loblatecb = .false. Calculate acceleration from oblate central body (automatically turns true if nonzero J2 is input) logical, public :: lrotation = .false. Include rotation states of big bodies logical, public :: ltides = .false. Include tidal dissipation real(kind=DP), public :: Eorbit_orig = 0.0_DP Initial orbital energy real(kind=DP), public :: GMtot_orig = 0.0_DP Initial system mass real(kind=DP), public, dimension(NDIM) :: Ltot_orig = 0.0_DP Initial total angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lorbit_orig = 0.0_DP Initial orbital angular momentum real(kind=DP), public, dimension(NDIM) :: Lspin_orig = 0.0_DP Initial spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lescape = 0.0_DP Angular momentum of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: GMescape = 0.0_DP Mass of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Ecollisions = 0.0_DP Energy lost from system due to collisions real(kind=DP), public :: Euntracked = 0.0_DP Energy gained from system due to escaped bodies logical, public :: lfirstenergy = .true. This is the first time computing energe logical, public :: lfirstkick = .true. Initiate the first kick in a symplectic step logical, public :: lrestart = .false. Indicates whether or not this is a restarted run logical, public :: lgr = .false. Turn on GR logical, public :: lyarkovsky = .false. Turn on Yarkovsky effect logical, public :: lyorp = .false. Turn on YORP effect type( netcdf_parameters ), public :: nciu Object containing NetCDF parameters real(kind=DP), public :: GMTINY = -1.0_DP Smallest G*mass that is fully gravitating real(kind=DP), public :: min_GMfrag = -1.0_DP Smallest G*mass that can be produced in a fragmentation event integer(kind=I4B), public, dimension(:), allocatable :: seed Random seeds logical, public :: lfragmentation = .false. Do fragmentation modeling instead of simple merger. Type-Bound Procedures procedure, public :: dump => io_dump_param procedure, public :: read_in => io_read_in_param procedure, public :: reader => symba_io_param_reader procedure, public :: writer => symba_io_param_writer type, public :: symba_kinship Class definition for the kinship relationships used in bookkeeping multiple collisions bodies in a single time step. Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: parent Index of parent particle integer(kind=I4B), public :: nchild number of children in merger list integer(kind=I4B), public, dimension(:), allocatable :: child Index of children particles type, public, extends( helio_cb ) :: symba_cb SyMBA central body particle class Components Type Visibility Attributes Name Initial type( swiftest_particle_info ), public :: info Particle metadata information integer(kind=I4B), public :: id = 0 External identifier (unique) real(kind=DP), public :: mass = 0.0_DP Central body mass (units MU) real(kind=DP), public :: Gmass = 0.0_DP Central mass gravitational term G * mass (units GU * MU) real(kind=DP), public :: radius = 0.0_DP Central body radius (units DU) real(kind=DP), public :: density = 1.0_DP Central body mass density - calculated internally (units MU / DU**3) real(kind=DP), public :: j2rp2 = 0.0_DP J2*R&#94;2 term for central body real(kind=DP), public :: j4rp4 = 0.0_DP J4*R&#94;2 term for central body real(kind=DP), public, dimension(NDIM) :: aobl = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: atide = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: aoblbeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: aoblend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: atidebeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: atideend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: xb = 0.0_DP Barycentric position (units DU) real(kind=DP), public, dimension(NDIM) :: vb = 0.0_DP Barycentric velocity (units DU / TU) real(kind=DP), public, dimension(NDIM) :: agr = 0.0_DP Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(NDIM) :: Ip = 0.0_DP Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(NDIM) :: rot = 0.0_DP Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public :: k2 = 0.0_DP Tidal Love number real(kind=DP), public :: Q = 0.0_DP Tidal quality factor real(kind=DP), public :: tlag = 0.0_DP Tidal phase lag angle real(kind=DP), public, dimension(NDIM) :: L0 = 0.0_DP Initial angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: dL = 0.0_DP Change in angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: ptbeg negative barycentric velocity of the central body at the beginning of time step real(kind=DP), public, dimension(NDIM) :: ptend negative barycentric velocity of the central body at the end of time step real(kind=DP), public :: GM0 = 0.0_DP Initial G*mass of the central body real(kind=DP), public :: dGM = 0.0_DP Change in G*mass of the central body real(kind=DP), public :: R0 = 0.0_DP Initial radius of the central body real(kind=DP), public :: dR = 0.0_DP Change in the radius of the central body Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file generic, public :: write_particle_info => write_particle_info_netcdf procedure, public :: read_in => io_read_in_cb I/O routine for reading in central body data procedure, public :: read_frame => io_read_frame_cb I/O routine for reading out a single frame of time-series data for the central body procedure, public :: write_frame_bin => io_write_frame_cb I/O routine for writing out a single frame of time-series data for the central body generic, public :: write_frame => write_frame_netcdf, write_frame_bin Write a frame (either binary or NetCDF, using generic procedures) type, public, extends( helio_pl ) :: symba_pl SyMBA massive body class Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl logical, public, dimension(:), allocatable :: lcollision flag indicating whether body has merged with another this time step logical, public, dimension(:), allocatable :: lencounter flag indicating whether body is part of an encounter this time step logical, public, dimension(:), allocatable :: lmtiny flag indicating whether this body is below the GMTINY cutoff value integer(kind=I4B), public :: nplm number of bodies above the GMTINY limit integer(kind=I8B), public :: nplplm Number of body (all massive)-body (only those above GMTINY) comparisons in the flattened upper triangular matrix integer(kind=I4B), public, dimension(:), allocatable :: nplenc number of encounters with other planets this time step integer(kind=I4B), public, dimension(:), allocatable :: ntpenc number of encounters with test particles this time step integer(kind=I4B), public, dimension(:), allocatable :: levelg level at which this body should be moved integer(kind=I4B), public, dimension(:), allocatable :: levelm deepest encounter level achieved this time step integer(kind=I4B), public, dimension(:), allocatable :: isperi perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp semimajor axis following perihelion passage type( symba_kinship ), public, dimension(:), allocatable :: kin Array of merger relationship structures that can account for multiple pairwise mergers in a single step Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file generic, public :: write_particle_info => write_particle_info_netcdf procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) generic, public :: write_frame => write_frame_netcdf, write_frame_bin Add the generic write frame for Fortran binary files procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) procedure, public :: vh2vb => util_coord_vh2vb_pl Convert massive bodies from heliocentric to barycentric coordinates (velocity only) procedure, public :: vb2vh => util_coord_vb2vh_pl Convert massive bodies from barycentric to heliocentric coordinates (velocity only) procedure, public :: xh2xb => util_coord_xh2xb_pl Convert massive bodies from heliocentric to barycentric coordinates (position only) procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. procedure, public :: set_mu => util_set_mu_pl Method used to construct the vectorized form of the central body mass procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body procedure, public :: lindrift => helio_drift_linear_pl Method for linear drift of massive bodies due to barycentric momentum of Sun procedure, public :: accel_gr => helio_gr_kick_getacch_pl Acceleration term arising from the post-Newtonian correction procedure, public :: gr_pos_kick => helio_gr_p4_pl Position kick due to p**4 term in the post-Newtonian correction procedure, public :: kick => helio_kick_vb_pl Kicks the barycentric velocities procedure, public :: step => helio_step_pl Steps the body forward one stepsize procedure, public :: make_colliders => symba_collision_make_colliders_pl When a single body is involved in more than one collision in a single step, it becomes part of a family procedure, public :: index => symba_util_index_eucl_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix procedure, public :: discard => symba_discard_pl Process massive body discards procedure, public :: drift => symba_drift_pl Method for Danby drift in Democratic Heliocentric coordinates. Sets the mask to the current recursion level procedure, public :: encounter_check => symba_encounter_check_pl Checks if massive bodies are going through close encounters with each other procedure, public :: accel_int => symba_kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodiess, with no mutual interactions between bodies below GMTINY procedure, public :: accel => symba_kick_getacch_pl Compute heliocentric accelerations of massive bodies procedure, public :: setup => symba_setup_pl Constructor method - Allocates space for the input number of bodies procedure, public :: append => symba_util_append_pl Appends elements from one structure to another procedure, public :: fill => symba_util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: get_peri => symba_util_peri_pl Determine system pericenter passages for massive bodies procedure, public :: rearray => symba_util_rearray_pl Clean up the massive body structures to remove discarded bodies and add new bodies procedure, public :: reset_kinship => symba_util_reset_kinship Resets the kinship status of bodies procedure, public :: resize => symba_util_resize_pl Checks the current size of a SyMBA massive body against the requested size and resizes it if it is too small. procedure, public :: sort => symba_util_sort_pl Sorts body arrays by a sortable componen procedure, public :: rearrange => symba_util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => symba_util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) type, public, extends( symba_pl ) :: symba_merger Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl logical, public, dimension(:), allocatable :: lcollision flag indicating whether body has merged with another this time step logical, public, dimension(:), allocatable :: lencounter flag indicating whether body is part of an encounter this time step logical, public, dimension(:), allocatable :: lmtiny flag indicating whether this body is below the GMTINY cutoff value integer(kind=I4B), public :: nplm number of bodies above the GMTINY limit integer(kind=I8B), public :: nplplm Number of body (all massive)-body (only those above GMTINY) comparisons in the flattened upper triangular matrix integer(kind=I4B), public, dimension(:), allocatable :: nplenc number of encounters with other planets this time step integer(kind=I4B), public, dimension(:), allocatable :: ntpenc number of encounters with test particles this time step integer(kind=I4B), public, dimension(:), allocatable :: levelg level at which this body should be moved integer(kind=I4B), public, dimension(:), allocatable :: levelm deepest encounter level achieved this time step integer(kind=I4B), public, dimension(:), allocatable :: isperi perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp semimajor axis following perihelion passage type( symba_kinship ), public, dimension(:), allocatable :: kin Array of merger relationship structures that can account for multiple pairwise mergers in a single step integer(kind=I4B), public, dimension(:), allocatable :: ncomp Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file generic, public :: write_particle_info => write_particle_info_netcdf procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) generic, public :: write_frame => write_frame_netcdf, write_frame_bin Add the generic write frame for Fortran binary files procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) procedure, public :: vh2vb => util_coord_vh2vb_pl Convert massive bodies from heliocentric to barycentric coordinates (velocity only) procedure, public :: vb2vh => util_coord_vb2vh_pl Convert massive bodies from barycentric to heliocentric coordinates (velocity only) procedure, public :: xh2xb => util_coord_xh2xb_pl Convert massive bodies from heliocentric to barycentric coordinates (position only) procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. procedure, public :: set_mu => util_set_mu_pl Method used to construct the vectorized form of the central body mass procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body procedure, public :: lindrift => helio_drift_linear_pl Method for linear drift of massive bodies due to barycentric momentum of Sun procedure, public :: accel_gr => helio_gr_kick_getacch_pl Acceleration term arising from the post-Newtonian correction procedure, public :: gr_pos_kick => helio_gr_p4_pl Position kick due to p**4 term in the post-Newtonian correction procedure, public :: kick => helio_kick_vb_pl Kicks the barycentric velocities procedure, public :: step => helio_step_pl Steps the body forward one stepsize procedure, public :: make_colliders => symba_collision_make_colliders_pl When a single body is involved in more than one collision in a single step, it becomes part of a family procedure, public :: index => symba_util_index_eucl_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix procedure, public :: discard => symba_discard_pl Process massive body discards procedure, public :: drift => symba_drift_pl Method for Danby drift in Democratic Heliocentric coordinates. Sets the mask to the current recursion level procedure, public :: encounter_check => symba_encounter_check_pl Checks if massive bodies are going through close encounters with each other procedure, public :: accel_int => symba_kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodiess, with no mutual interactions between bodies below GMTINY procedure, public :: accel => symba_kick_getacch_pl Compute heliocentric accelerations of massive bodies procedure, public :: fill => symba_util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: get_peri => symba_util_peri_pl Determine system pericenter passages for massive bodies procedure, public :: rearray => symba_util_rearray_pl Clean up the massive body structures to remove discarded bodies and add new bodies procedure, public :: reset_kinship => symba_util_reset_kinship Resets the kinship status of bodies procedure, public :: sort => symba_util_sort_pl Sorts body arrays by a sortable componen procedure, public :: rearrange => symba_util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => symba_util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure, public :: append => symba_util_append_merger Appends elements from one structure to another procedure, public :: resize => symba_util_resize_merger Checks the current size of a SyMBA merger list against the requested size and resizes it if it is too small. procedure, public :: setup => symba_setup_merger Constructor method - Allocates space for the input number of bodies type, public, extends( helio_tp ) :: symba_tp SyMBA test particle class Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill integer(kind=I4B), public, dimension(:), allocatable :: isperi Perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri Perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp Semimajor axis following perihelion passage integer(kind=I4B), public, dimension(:,:), allocatable :: k_pltp Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: npltp Number of pl-tp comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_tp and util_spill_tp integer(kind=I4B), public, dimension(:), allocatable :: nplenc number of encounters with planets this time step integer(kind=I4B), public, dimension(:), allocatable :: levelg level at which this particle should be moved integer(kind=I4B), public, dimension(:), allocatable :: levelm deepest encounter level achieved this time step Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file generic, public :: write_particle_info => write_particle_info_netcdf procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) generic, public :: write_frame => write_frame_netcdf, write_frame_bin Add the generic write frame for Fortran binary files procedure, public :: discard => discard_tp Check to see if test particles should be discarded based on their positions relative to the massive bodies procedure, public :: accel_int => kick_getacch_int_tp Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies procedure, public :: accel_obl => obl_acc_tp Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: h2b => util_coord_h2b_tp Convert test particles from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_tp Convert test particles from barycentric to heliocentric coordinates (position and velocity) procedure, public :: vb2vh => util_coord_vb2vh_tp Convert test particles from barycentric to heliocentric coordinates (velocity only) procedure, public :: vh2vb => util_coord_vh2vb_tp Convert test particles from heliocentric to barycentric coordinates (velocity only) procedure, public :: xh2xb => util_coord_xh2xb_tp Convert test particles from heliocentric to barycentric coordinates (position only) procedure, public :: get_peri => util_peri_tp Determine system pericenter passages for test particles procedure, public :: set_mu => util_set_mu_tp Method used to construct the vectorized form of the central body mass procedure, public :: lindrift => helio_drift_linear_tp Method for linear drift of massive bodies due to barycentric momentum of Sun procedure, public :: accel_gr => helio_gr_kick_getacch_tp Acceleration term arising from the post-Newtonian correction procedure, public :: gr_pos_kick => helio_gr_p4_tp Position kick due to p**4 term in the post-Newtonian correction procedure, public :: kick => helio_kick_vb_tp Kicks the barycentric velocities procedure, public :: step => helio_step_tp Steps the body forward one stepsize procedure, public :: drift => symba_drift_tp Method for Danby drift in Democratic Heliocentric coordinates. Sets the mask to the current recursion level procedure, public :: encounter_check => symba_encounter_check_tp Checks if any test particles are undergoing a close encounter with a massive body procedure, public :: accel => symba_kick_getacch_tp Compute heliocentric accelerations of test particles procedure, public :: setup => symba_setup_tp Constructor method - Allocates space for the input number of bodies procedure, public :: append => symba_util_append_tp Appends elements from one structure to another procedure, public :: fill => symba_util_fill_tp \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: resize => symba_util_resize_tp Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure, public :: sort => symba_util_sort_tp Sorts body arrays by a sortable componen procedure, public :: rearrange => symba_util_sort_rearrange_tp Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => symba_util_spill_tp \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) type, public, extends( swiftest_encounter ) :: symba_encounter SyMBA class for tracking close encounters in a step Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: nenc Total number of encounters logical, public, dimension(:), allocatable :: lvdotr relative vdotr flag integer(kind=I4B), public, dimension(:), allocatable :: status status of the interaction integer(kind=I8B), public, dimension(:), allocatable :: kidx index value of the encounter from the master k_plpl encounter list integer(kind=I4B), public, dimension(:), allocatable :: index1 position of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: index2 position of the second body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: id1 id of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: id2 id of the second body in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x1 the position of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x2 the position of body 2 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v1 the velocity of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v2 the velocity of body 2 in the encounter real(kind=DP), public, dimension(:), allocatable :: t Time of encounter integer(kind=I4B), public, dimension(:), allocatable :: level encounter recursion level Type-Bound Procedures procedure, public :: resize => util_resize_encounter Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small. procedure, public :: write => io_write_encounter Write close encounter data to output binary file procedure, public :: collision_check => symba_collision_check_encounter Checks if a test particle is going to collide with a massive body procedure, public :: encounter_check => symba_encounter_check Checks if massive bodies are going through close encounters with each other procedure, public :: kick => symba_kick_encounter Kick barycentric velocities of active test particles within SyMBA recursion procedure, public :: setup => symba_setup_encounter A constructor that sets the number of encounters and allocates and initializes all arrays procedure, public :: copy => symba_util_copy_encounter Copies elements from the source encounter list into self. procedure, public :: spill => symba_util_spill_encounter \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure, public :: append => symba_util_append_encounter Appends elements from one structure to another type, public, extends( symba_encounter ) :: symba_pltpenc SyMBA class for tracking pl-tp close encounters in a step Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: nenc Total number of encounters logical, public, dimension(:), allocatable :: lvdotr relative vdotr flag integer(kind=I4B), public, dimension(:), allocatable :: status status of the interaction integer(kind=I8B), public, dimension(:), allocatable :: kidx index value of the encounter from the master k_plpl encounter list integer(kind=I4B), public, dimension(:), allocatable :: index1 position of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: index2 position of the second body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: id1 id of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: id2 id of the second body in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x1 the position of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x2 the position of body 2 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v1 the velocity of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v2 the velocity of body 2 in the encounter real(kind=DP), public, dimension(:), allocatable :: t Time of encounter integer(kind=I4B), public, dimension(:), allocatable :: level encounter recursion level Type-Bound Procedures procedure, public :: resize => util_resize_encounter Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small. procedure, public :: write => io_write_encounter Write close encounter data to output binary file procedure, public :: collision_check => symba_collision_check_encounter Checks if a test particle is going to collide with a massive body procedure, public :: encounter_check => symba_encounter_check Checks if massive bodies are going through close encounters with each other procedure, public :: kick => symba_kick_encounter Kick barycentric velocities of active test particles within SyMBA recursion procedure, public :: setup => symba_setup_encounter A constructor that sets the number of encounters and allocates and initializes all arrays procedure, public :: copy => symba_util_copy_encounter Copies elements from the source encounter list into self. procedure, public :: spill => symba_util_spill_encounter \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure, public :: append => symba_util_append_encounter Appends elements from one structure to another procedure, public :: resolve_collision => symba_collision_resolve_pltpenc Process the pl-tp collision list, then modifiy the massive bodies based on the outcome of the c type, public, extends( symba_encounter ) :: symba_plplenc SyMBA class for tracking pl-pl close encounters in a step Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: nenc Total number of encounters logical, public, dimension(:), allocatable :: lvdotr relative vdotr flag integer(kind=I4B), public, dimension(:), allocatable :: status status of the interaction integer(kind=I8B), public, dimension(:), allocatable :: kidx index value of the encounter from the master k_plpl encounter list integer(kind=I4B), public, dimension(:), allocatable :: index1 position of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: index2 position of the second body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: id1 id of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: id2 id of the second body in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x1 the position of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x2 the position of body 2 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v1 the velocity of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v2 the velocity of body 2 in the encounter real(kind=DP), public, dimension(:), allocatable :: t Time of encounter integer(kind=I4B), public, dimension(:), allocatable :: level encounter recursion level Type-Bound Procedures procedure, public :: resize => util_resize_encounter Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small. procedure, public :: write => io_write_encounter Write close encounter data to output binary file procedure, public :: collision_check => symba_collision_check_encounter Checks if a test particle is going to collide with a massive body procedure, public :: encounter_check => symba_encounter_check Checks if massive bodies are going through close encounters with each other procedure, public :: kick => symba_kick_encounter Kick barycentric velocities of active test particles within SyMBA recursion procedure, public :: setup => symba_setup_encounter A constructor that sets the number of encounters and allocates and initializes all arrays procedure, public :: copy => symba_util_copy_encounter Copies elements from the source encounter list into self. procedure, public :: spill => symba_util_spill_encounter \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure, public :: append => symba_util_append_encounter Appends elements from one structure to another procedure, public :: extract_collisions => symba_collision_encounter_extract_collisions Processes the pl-pl encounter list remove only those encounters that led to a collision procedure, public :: resolve_fragmentations => symba_collision_resolve_fragmentations Process list of collisions, determine the collisional regime, and then create fragments procedure, public :: resolve_mergers => symba_collision_resolve_mergers Process list of collisions and merge colliding bodies together procedure, public :: resolve_collision => symba_collision_resolve_plplenc Process the pl-pl collision list, then modifiy the massive bodies based on the outcome of the c type, public, extends( helio_nbody_system ) :: symba_nbody_system Components Type Visibility Attributes Name Initial class( swiftest_cb ), public, allocatable :: cb Central body data structure class( swiftest_pl ), public, allocatable :: pl Massive body data structure class( swiftest_tp ), public, allocatable :: tp Test particle data structure class( swiftest_tp ), public, allocatable :: tp_discards Discarded test particle data structure class( swiftest_pl ), public, allocatable :: pl_discards Discarded massive body particle data structure real(kind=DP), public :: GMtot = 0.0_DP Total system mass - used for barycentric coordinate conversion real(kind=DP), public :: ke_orbit = 0.0_DP System orbital kinetic energy real(kind=DP), public :: ke_spin = 0.0_DP System spin kinetic energy real(kind=DP), public :: pe = 0.0_DP System potential energy real(kind=DP), public :: te = 0.0_DP System total energy real(kind=DP), public :: oblpot = 0.0_DP System potential energy due to oblateness of the central body real(kind=DP), public, dimension(NDIM) :: Lorbit = 0.0_DP System orbital angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lspin = 0.0_DP System spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Ltot = 0.0_DP System angular momentum vector logical, public :: lbeg True if this is the beginning of a step. This is used so that test particle steps can be calculated \n    separately from massive bodies.  Massive body variables are saved at half steps, and passed to \n    the test particles class( symba_merger ), public, allocatable :: pl_adds List of added bodies in mergers or collisions class( symba_pltpenc ), public, allocatable :: pltpenc_list List of massive body-test particle encounters in a single step class( symba_plplenc ), public, allocatable :: plplenc_list List of massive body-massive body encounters in a single step class( symba_plplenc ), public, allocatable :: plplcollision_list List of massive body-massive body collisions in a single step integer(kind=I4B), public :: irec System recursion level Type-Bound Procedures procedure, public :: discard => discard_system Perform a discard step on the system procedure, public :: conservation_report => io_conservation_report Compute energy and momentum and print out the change with time procedure, public :: dump => io_dump_system Dump the state of the system to a file procedure, public :: get_old_t_final => io_get_old_t_final_system Validates the dump file to check whether the dump file initial conditions duplicate the last frame of the binary output. procedure, public :: read_frame => io_read_frame_system Read in a frame of input data from file procedure, public :: read_particle_info => io_read_particle_info_system Read in particle metadata from file procedure, public :: write_frame => io_write_frame_system Append a frame of output data to file procedure, public :: write_hdr_bin => io_write_hdr_system Write a header for an output frame in Fortran binary format procedure, public :: write_hdr_netcdf => netcdf_write_hdr_system Write a header for an output frame in NetCDF format procedure, public :: obl_pot => obl_pot_system Compute the contribution to the total gravitational potential due solely to the oblateness of the central body procedure, public :: init_particle_info => setup_initialize_particle_info_system Initialize the system from input files procedure, public :: step_spin => tides_step_spin_system Steps the spins of the massive & central bodies due to tides. procedure, public :: set_msys => util_set_msys Sets the value of msys from the masses of system bodies. procedure, public :: get_energy_and_momentum => util_get_energy_momentum_system Calculates the total system energy and momentum procedure, public :: rescale => util_rescale_system Rescales the system into a new set of units procedure, public :: validate_ids => util_valid_id_system Validate the numerical ids passed to the system and save the maximum value generic, public :: write_hdr => write_hdr_bin, write_hdr_netcdf Generic method call for writing headers procedure, public :: write_discard => symba_io_write_discard Write out information about discarded and merged planets and test particles in SyMBA procedure, public :: initialize => symba_setup_initialize_system Performs SyMBA-specific initilization steps procedure, public :: step => symba_step_system Advance the SyMBA nbody system forward in time by one step procedure, public :: interp => symba_step_interp_system Perform an interpolation step on the SymBA nbody system procedure, public :: set_recur_levels => symba_step_set_recur_levels_system Sets recursion levels of bodies and encounter lists to the current system level procedure, public :: recursive_step => symba_step_recur_system Step interacting planets and active test particles ahead in democratic heliocentric coordinates at the current recursion level, if applicable, and descend to the next deeper level if necessary procedure, public :: reset => symba_step_reset_system Resets pl, tp,and encounter structures at the start of a new step","tags":"","loc":"module/symba_classes.html"},{"title":"swiftest – swiftest","text":"This module serves to combine all of the Swiftest project modules under a single umbrella so that they can be accessed from individual submodule implementations with a simple \"use swiftest\" line. Uses swiftest_globals swiftest_operators swiftest_classes whm_classes rmvs_classes helio_classes symba_classes fraggle_classes lambda_function walltime_classes Contents None","tags":"","loc":"module/swiftest.html"},{"title":"swiftest_classes – swiftest","text":"Definition of data and structures generic to all integrators.\n Adapted from David E. Kaufmann's Swifter routine: module_swifter.f90 swiftest_parameters class definitions swiftest_swiftest_particle_info class definitions and method interfaces swiftest_base class definitions and methods swiftest_cb class definitions and methods swiftest_body definitions and methods swiftest_pl definitions and methods swiftest_tp definitions and methods swiftest_nbody_system class definitions and methods Uses swiftest_globals module~~swiftest_classes~~UsesGraph module~swiftest_classes swiftest_classes module~swiftest_globals swiftest_globals module~swiftest_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: drift_implementation s_discard s_gr s_io s_kick s_netcdf s_obl s_orbel s_setup s_tides_kick_getacch s_tides_step_spin s_user_kick_getacch s_util_append s_util_coord s_util_copy s_util_exit s_util_fill s_util_get_energy_momentum s_util_index s_util_minimize_bfgs s_util_peri s_util_rescale s_util_resize s_util_set s_util_solve s_util_sort s_util_spill s_util_valid s_util_version module~~swiftest_classes~~UsedByGraph module~swiftest_classes swiftest_classes module~s_gr s_gr module~s_gr->module~swiftest_classes module~swiftest swiftest module~s_gr->module~swiftest module~s_util_valid s_util_valid module~s_util_valid->module~swiftest_classes module~s_util_valid->module~swiftest module~s_obl s_obl module~s_obl->module~swiftest_classes module~s_obl->module~swiftest module~s_util_coord s_util_coord module~s_util_coord->module~swiftest_classes module~s_util_coord->module~swiftest module~s_util_rescale s_util_rescale module~s_util_rescale->module~swiftest_classes module~s_util_rescale->module~swiftest module~swiftest->module~swiftest_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~symba_classes symba_classes module~swiftest->module~symba_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~s_util_get_energy_momentum s_util_get_energy_momentum module~s_util_get_energy_momentum->module~swiftest_classes module~s_util_get_energy_momentum->module~swiftest module~s_util_index s_util_index module~s_util_index->module~swiftest_classes module~s_util_index->module~swiftest proc~xv2el xv2el proc~xv2el->module~swiftest_classes module~s_util_set s_util_set module~s_util_set->module~swiftest_classes module~s_util_set->module~swiftest module~s_util_version s_util_version module~s_util_version->module~swiftest_classes module~s_util_version->module~swiftest module~s_tides_step_spin s_tides_step_spin module~s_tides_step_spin->module~swiftest_classes module~s_tides_step_spin->module~swiftest module~s_orbel s_orbel module~s_orbel->module~swiftest_classes module~s_orbel->module~swiftest module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~s_util_exit s_util_exit module~s_util_exit->module~swiftest_classes module~s_util_exit->module~swiftest module~fraggle_classes->module~swiftest_classes module~s_netcdf s_netcdf module~s_netcdf->module~swiftest_classes module~s_netcdf->module~swiftest module~s_util_peri s_util_peri module~s_util_peri->module~swiftest_classes module~s_util_peri->module~swiftest module~s_setup s_setup module~s_setup->module~swiftest_classes module~s_setup->module~swiftest module~s_util_append s_util_append module~s_util_append->module~swiftest_classes module~s_util_append->module~swiftest module~s_util_copy s_util_copy module~s_util_copy->module~swiftest_classes module~s_util_copy->module~swiftest module~s_discard s_discard module~s_discard->module~swiftest_classes module~s_discard->module~swiftest module~s_util_sort s_util_sort module~s_util_sort->module~swiftest_classes module~s_util_sort->module~swiftest module~s_util_resize s_util_resize module~s_util_resize->module~swiftest_classes module~s_util_resize->module~swiftest module~s_util_spill s_util_spill module~s_util_spill->module~swiftest_classes module~s_util_spill->module~swiftest module~s_util_minimize_bfgs s_util_minimize_bfgs module~s_util_minimize_bfgs->module~swiftest_classes module~s_util_minimize_bfgs->module~swiftest module~s_user_kick_getacch s_user_kick_getacch module~s_user_kick_getacch->module~swiftest_classes module~s_user_kick_getacch->module~swiftest module~whm_classes->module~swiftest_classes module~s_tides_kick_getacch s_tides_kick_getacch module~s_tides_kick_getacch->module~swiftest_classes module~s_tides_kick_getacch->module~swiftest module~s_util_fill s_util_fill module~s_util_fill->module~swiftest_classes module~s_util_fill->module~swiftest module~s_io s_io module~s_io->module~swiftest_classes module~s_io->module~swiftest module~s_util_solve s_util_solve module~s_util_solve->module~swiftest_classes module~s_util_solve->module~swiftest module~s_kick s_kick module~s_kick->module~swiftest_classes module~s_kick->module~swiftest module~drift_implementation drift_implementation module~drift_implementation->module~swiftest_classes module~drift_implementation->module~swiftest module~s_fraggle_placeholder s_fraggle_placeholder module~s_fraggle_placeholder->module~swiftest module~s_fraggle_placeholder->module~fraggle_classes module~s_symba_collision s_symba_collision module~s_symba_collision->module~swiftest module~s_symba_collision->module~symba_classes module~s_fraggle_setup s_fraggle_setup module~s_fraggle_setup->module~swiftest module~s_fraggle_setup->module~fraggle_classes module~s_symba_encounter_check s_symba_encounter_check module~s_symba_encounter_check->module~swiftest module~s_symba_encounter_check->module~symba_classes module~s_whm_coord s_whm_coord module~s_whm_coord->module~swiftest module~s_whm_coord->module~whm_classes module~s_rmvs_step s_rmvs_step module~s_rmvs_step->module~swiftest module~s_rmvs_step->module~rmvs_classes proc~ge_wpp ge_wpp proc~ge_wpp->module~swiftest module~s_operator_cross s_operator_cross module~s_operator_cross->module~swiftest module~s_fraggle_set s_fraggle_set module~s_fraggle_set->module~swiftest module~s_fraggle_set->module~fraggle_classes module~s_fraggle_io s_fraggle_io module~s_fraggle_io->module~swiftest module~s_fraggle_io->module~fraggle_classes module~s_rmvs_kick s_rmvs_kick module~s_rmvs_kick->module~swiftest module~s_rmvs_kick->module~rmvs_classes module~s_rmvs_io s_rmvs_io module~s_rmvs_io->module~swiftest module~s_rmvs_io->module~rmvs_classes proc~solve_wbs solve_wbs proc~solve_wbs->module~swiftest module~s_whm_gr s_whm_gr module~s_whm_gr->module~swiftest module~s_whm_gr->module~whm_classes module~s_rmvs_chk s_rmvs_chk module~s_rmvs_chk->module~swiftest module~s_rmvs_chk->module~rmvs_classes module~s_fraggle_regime s_fraggle_regime module~s_fraggle_regime->module~swiftest module~s_fraggle_regime->module~fraggle_classes module~s_rmvs_discard s_rmvs_discard module~s_rmvs_discard->module~swiftest module~s_rmvs_discard->module~rmvs_classes module~s_helio_drift s_helio_drift module~s_helio_drift->module~swiftest module~s_helio_drift->module~helio_classes module~s_helio_kick s_helio_kick module~s_helio_kick->module~swiftest module~s_helio_kick->module~helio_classes module~s_rmvs_util s_rmvs_util module~s_rmvs_util->module~swiftest module~s_rmvs_util->module~rmvs_classes program~swiftest_driver swiftest_driver program~swiftest_driver->module~swiftest module~s_symba_step s_symba_step module~s_symba_step->module~swiftest module~s_symba_step->module~symba_classes module~s_symba_util s_symba_util module~s_symba_util->module~swiftest module~s_symba_util->module~symba_classes module~s_whm_setup s_whm_setup module~s_whm_setup->module~swiftest module~s_whm_setup->module~whm_classes module~s_helio_gr s_helio_gr module~s_helio_gr->module~swiftest module~s_helio_gr->module~helio_classes module~orbel orbel module~orbel->module~swiftest module~s_whm_util s_whm_util module~s_whm_util->module~swiftest module~s_whm_util->module~whm_classes module~s_rmvs_setup s_rmvs_setup module~s_rmvs_setup->module~swiftest module~s_rmvs_setup->module~rmvs_classes module~s_whm_kick s_whm_kick module~s_whm_kick->module~swiftest module~s_whm_kick->module~whm_classes module~s_symba_discard s_symba_discard module~s_symba_discard->module~swiftest module~s_symba_discard->module~symba_classes module~s_symba_drift s_symba_drift module~s_symba_drift->module~swiftest module~s_symba_drift->module~symba_classes module~whm_drift whm_drift module~whm_drift->module~swiftest module~whm_drift->module~whm_classes module~s_symba_kick s_symba_kick module~s_symba_kick->module~swiftest module~s_symba_kick->module~symba_classes module~s_fraggle_util s_fraggle_util module~s_fraggle_util->module~swiftest module~s_fraggle_util->module~fraggle_classes module~s_helio_setup s_helio_setup module~s_helio_setup->module~swiftest module~s_helio_setup->module~helio_classes module~s_helio_step s_helio_step module~s_helio_step->module~swiftest module~s_helio_step->module~helio_classes module~s_whm_step s_whm_step module~s_whm_step->module~swiftest module~s_whm_step->module~whm_classes module~rmvs_classes->module~whm_classes module~s_symba_setup s_symba_setup module~s_symba_setup->module~swiftest module~s_symba_setup->module~symba_classes module~s_fraggle_generate s_fraggle_generate module~s_fraggle_generate->module~swiftest module~s_fraggle_generate->module~fraggle_classes module~s_symba_io s_symba_io module~s_symba_io->module~swiftest module~s_symba_io->module~symba_classes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces io_get_args io_get_old_t_final_system io_get_token io_read_frame_body io_read_frame_cb io_read_frame_system discard_pl discard_system discard_tp drift_all drift_body drift_one util_index_eucl_ij_to_k util_index_eucl_k_to_ij util_index_eucl_plpl util_index_eucl_pltp gr_kick_getaccb_ns_body gr_kick_getacch gr_p4_pos_kick gr_pseudovel2vel gr_pv2vh_body gr_vel2pseudovel gr_vh2pv_body io_conservation_report io_dump_param io_dump_particle_info_base io_dump_particle_info io_dump_base io_dump_system io_param_reader io_param_writer io_read_in_body io_read_in_cb io_read_in_param io_read_in_particle_info io_read_particle_info_system io_write_discard io_toupper io_write_encounter io_write_frame_body io_write_frame_cb io_write_frame_encounter io_write_frame_system io_write_hdr_system kick_getacch_int_pl kick_getacch_int_tp kick_getacch_int_all_pl kick_getacch_int_all_tp kick_getacch_int_one_pl kick_getacch_int_one_tp netcdf_close netcdf_initialize_output netcdf_open netcdf_write_frame_base netcdf_write_frame_system netcdf_write_hdr_system netcdf_write_particle_info_base obl_acc_body obl_acc_pl obl_acc_tp obl_pot_system orbel_el2xv_vec orbel_scget orbel_xv2aeq orbel_xv2aqt orbel_xv2el orbel_xv2el_vec setup_body setup_construct_system setup_encounter setup_initialize_particle_info_system setup_initialize_system setup_pl setup_tp tides_kick_getacch_pl tides_step_spin_system user_kick_getacch_body util_append util_append_body util_append_encounter util_append_pl util_append_tp util_coord_b2h_pl util_coord_b2h_tp util_coord_h2b_pl util_coord_h2b_tp util_coord_vb2vh_pl util_coord_vb2vh_tp util_coord_vh2vb_pl util_coord_vh2vb_tp util_coord_xh2xb_pl util_coord_xh2xb_tp util_copy_encounter util_copy_particle_info util_copy_particle_info_arr util_exit util_fill_body util_fill_pl util_fill_tp util_fill util_minimize_bfgs util_rescale_system util_peri_tp util_resize util_resize_body util_resize_encounter util_resize_pl util_resize_tp util_get_energy_momentum_system util_set_beg_end_pl util_set_ir3h util_set_msys util_set_mu_pl util_set_mu_tp util_set_particle_info util_set_rhill util_set_rhill_approximate util_solve_linear_system util_solve_rkf45 util_sort util_sort_rearrange util_sort_rearrange_body util_sort_rearrange_pl util_sort_rearrange_tp util_sort_body util_sort_pl util_sort_tp util_spill util_spill_body util_spill_encounter util_spill_pl util_spill_tp util_valid_id_system util_version Abstract Interfaces abstract_read_frame abstract_discard_body abstract_accel abstract_kick_body abstract_set_mu abstract_step_body abstract_step_system Derived Types netcdf_parameters swiftest_parameters swiftest_particle_info swiftest_base swiftest_cb swiftest_body swiftest_pl swiftest_tp swiftest_nbody_system swiftest_encounter Interfaces interface public module function io_get_args(integrator, param_file_name) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=I4B) :: integrator Symbolic code of the requested integrator character(len=:), allocatable :: param_file_name Name of the input parameters file Return Value integer(kind=I4B) I/O error code interface public module function io_get_old_t_final_system(self, param) result(old_t_final) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self class( swiftest_parameters ), intent(in) :: param Return Value real(kind=DP) interface public module function io_get_token(buffer, ifirst, ilast, ierr) result(token) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: buffer Input string buffer integer(kind=I4B), intent(inout) :: ifirst Index of the buffer at which to start the search for a token integer(kind=I4B), intent(out) :: ilast Index of the buffer at the end of the returned token integer(kind=I4B), intent(out) :: ierr Error code Return Value character(len=:),\n  allocatable Returned token string interface public module function io_read_frame_body(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful interface public module function io_read_frame_cb(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful interface public module function io_read_frame_system(self, iu, param) result(ierr) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful interface public module subroutine discard_pl(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameter interface public module subroutine discard_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine discard_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine drift_all(mu, x, v, n, param, dt, lmask, iflag) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: mu Vector of gravitational constants real(kind=DP), intent(inout), dimension(:,:) :: x Position and velocity vectors real(kind=DP), intent(inout), dimension(:,:) :: v Position and velocity vectors integer(kind=I4B), intent(in) :: n number of bodies class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize logical, intent(in), dimension(:) :: lmask Logical mask of size self%nbody that determines which bodies to drift. integer(kind=I4B), intent(out), dimension(:) :: iflag Vector of error flags. 0 means no problem interface public module subroutine drift_body(self, system, param, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize interface public pure elemental module subroutine drift_one(mu, px, py, pz, vx, vy, vz, dt, iflag) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body to drift real(kind=DP), intent(inout) :: px Position and velocity of body to drift real(kind=DP), intent(inout) :: py Position and velocity of body to drift real(kind=DP), intent(inout) :: pz Position and velocity of body to drift real(kind=DP), intent(inout) :: vx Position and velocity of body to drift real(kind=DP), intent(inout) :: vy Position and velocity of body to drift real(kind=DP), intent(inout) :: vz Position and velocity of body to drift real(kind=DP), intent(in) :: dt Step size integer(kind=I4B), intent(out) :: iflag iflag : error status flag for Danby drift (0 = OK, nonzero = ERROR) interface public pure module subroutine util_index_eucl_ij_to_k(n, i, j, k) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n Number of bodies integer(kind=I4B), intent(in) :: i Index of the ith body integer(kind=I4B), intent(in) :: j Index of the jth body integer(kind=I8B), intent(out) :: k Index of the flattened matrix interface public pure module subroutine util_index_eucl_k_to_ij(n, k, i, j) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n Number of bodies integer(kind=I8B), intent(in) :: k Index of the flattened matrix integer(kind=I4B), intent(out) :: i Index of the ith body integer(kind=I4B), intent(out) :: j Index of the jth body interface public module subroutine util_index_eucl_plpl(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine util_index_eucl_pltp(self, pl, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_pl ), intent(in) :: pl Swiftest massive body object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public pure module subroutine gr_kick_getaccb_ns_body(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public pure module subroutine gr_kick_getacch(mu, x, lmask, n, inv_c2, agr) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:,:) :: x Position vectors logical, intent(in), dimension(:) :: lmask Logical mask indicating which bodies to compute integer(kind=I4B), intent(in) :: n Total number of bodies real(kind=DP), intent(in) :: inv_c2 Inverse speed of light squared: 1 / c**2 real(kind=DP), intent(out), dimension(:,:) :: agr Accelerations interface public pure module subroutine gr_p4_pos_kick(param, x, v, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(inout), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(in) :: dt Step size interface public pure module subroutine gr_pseudovel2vel(param, mu, xh, pv, vh) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real(kind=DP), intent(in), dimension(:) :: xh Swiftestcentric position vector real(kind=DP), intent(in), dimension(:) :: pv Pseudovelocity velocity vector - see Saha & Tremain (1994), eq. (32) real(kind=DP), intent(out), dimension(:) :: vh Swiftestcentric velocity vector interface public pure module subroutine gr_pv2vh_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public pure module subroutine gr_vel2pseudovel(param, mu, xh, vh, pv) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real(kind=DP), intent(in), dimension(:) :: xh Swiftestcentric position vector real(kind=DP), intent(in), dimension(:) :: vh Swiftestcentric velocity vector real(kind=DP), intent(out), dimension(:) :: pv Pseudovelocity vector - see Saha & Tremain (1994), eq. (32) interface public pure module subroutine gr_vh2pv_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine io_conservation_report(self, param, lterminal) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Input colleciton of user-defined parameters logical, intent(in) :: lterminal Indicates whether to output information to the terminal screen interface public module subroutine io_dump_param(self, param_file_name) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Output collection of parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in) interface public module subroutine io_dump_particle_info_base(self, param, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file interface public module subroutine io_dump_particle_info(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(in) :: self Swiftest particle info metadata object integer(kind=I4B), intent(in) :: iu Open unformatted file unit number interface public module subroutine io_dump_base(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine io_dump_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine io_param_reader(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Collection of parameters integer(kind=I4B), intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer(kind=I4B), intent(in) :: v_list (:) The first element passes the integrator code to the reader integer(kind=I4B), intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 interface public module subroutine io_param_writer(self, unit, iotype, v_list, iostat, iomsg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Collection of parameters integer(kind=I4B), intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer(kind=I4B), intent(in) :: v_list (:) Not used in this procedure integer(kind=I4B), intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 interface public module subroutine io_read_in_body(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine io_read_in_cb(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine io_read_in_param(self, param_file_name) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Current run configuration parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in) interface public module subroutine io_read_in_particle_info(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(inout) :: self Particle metadata information object integer(kind=I4B), intent(in) :: iu Open file unit number interface public module subroutine io_read_particle_info_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine io_write_discard(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine io_toupper(string) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string String to make upper case interface public module subroutine io_write_encounter(self, pl, encbody, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(in) :: self Swiftest encounter list object class( swiftest_pl ), intent(in) :: pl Swiftest massive body object class( swiftest_body ), intent(in) :: encbody Encountering body - Swiftest generic body object (pl or tp) class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine io_write_frame_body(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine io_write_frame_cb(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine io_write_frame_encounter(iu, t, id1, id2, Gmass1, Gmass2, radius1, radius2, xh1, xh2, vh1, vh2) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu Open file unit number real(kind=DP), intent(in) :: t Time of encounter integer(kind=I4B), intent(in) :: id1 ids of the two encountering bodies integer(kind=I4B), intent(in) :: id2 ids of the two encountering bodies real(kind=DP), intent(in) :: Gmass1 G*mass of the two encountering bodies real(kind=DP), intent(in) :: Gmass2 G*mass of the two encountering bodies real(kind=DP), intent(in) :: radius1 Radii of the two encountering bodies real(kind=DP), intent(in) :: radius2 Radii of the two encountering bodies real(kind=DP), intent(in), dimension(:) :: xh1 Swiftestcentric position vectors of the two encountering bodies real(kind=DP), intent(in), dimension(:) :: xh2 Swiftestcentric position vectors of the two encountering bodies real(kind=DP), intent(in), dimension(:) :: vh1 Swiftestcentric velocity vectors of the two encountering bodies real(kind=DP), intent(in), dimension(:) :: vh2 Swiftestcentric velocity vectors of the two encountering bodies interface public module subroutine io_write_frame_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine io_write_hdr_system(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest nbody system object integer(kind=I4B), intent(inout) :: iu Output file unit number class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine kick_getacch_int_pl(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object interface public module subroutine kick_getacch_int_tp(self, GMpl, xhp, npl) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle real(kind=DP), intent(in), dimension(:) :: GMpl Massive body masses real(kind=DP), intent(in), dimension(:,:) :: xhp Massive body position vectors integer(kind=I4B), intent(in) :: npl Number of active massive bodies interface public module subroutine kick_getacch_int_all_pl(npl, nplpl, k_plpl, x, Gmass, radius, acc) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl Number of massive bodies integer(kind=I8B), intent(in) :: nplpl Number of massive body interactions to compute integer(kind=I4B), intent(in), dimension(:,:) :: k_plpl Array of interaction pair indices (flattened upper triangular matrix) real(kind=DP), intent(in), dimension(:,:) :: x Position vector array real(kind=DP), intent(in), dimension(:) :: Gmass Array of massive body G*mass real(kind=DP), intent(in), dimension(:) :: radius Array of massive body radii real(kind=DP), intent(inout), dimension(:,:) :: acc Acceleration vector array interface public module subroutine kick_getacch_int_all_tp(ntp, npl, xtp, xpl, GMpl, lmask, acc) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp Number of test particles integer(kind=I4B), intent(in) :: npl Number of massive bodies real(kind=DP), intent(in), dimension(:,:) :: xtp Test particle position vector array real(kind=DP), intent(in), dimension(:,:) :: xpl Massive body particle position vector array real(kind=DP), intent(in), dimension(:) :: GMpl Array of massive body G*mass logical, intent(in), dimension(:) :: lmask Logical mask indicating which test particles should be computed real(kind=DP), intent(inout), dimension(:,:) :: acc Acceleration vector array interface public pure module subroutine kick_getacch_int_one_pl(rji2, xr, yr, zr, Gmi, Gmj, axi, ayi, azi, axj, ayj, azj) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: rji2 Square of distance between the two bodies real(kind=DP), intent(in) :: xr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: yr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: zr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: Gmi G*mass of body i real(kind=DP), intent(in) :: Gmj G*mass of body j real(kind=DP), intent(inout) :: axi Acceleration vector components of body i real(kind=DP), intent(inout) :: ayi Acceleration vector components of body i real(kind=DP), intent(inout) :: azi Acceleration vector components of body i real(kind=DP), intent(inout) :: axj Acceleration vector components of body j real(kind=DP), intent(inout) :: ayj Acceleration vector components of body j real(kind=DP), intent(inout) :: azj Acceleration vector components of body j interface public pure module subroutine kick_getacch_int_one_tp(rji2, xr, yr, zr, Gmpl, ax, ay, az) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: rji2 Square of distance between the test particle and massive body real(kind=DP), intent(in) :: xr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: yr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: zr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: Gmpl G*mass of massive body real(kind=DP), intent(inout) :: ax Acceleration vector components of test particle real(kind=DP), intent(inout) :: ay Acceleration vector components of test particle real(kind=DP), intent(inout) :: az Acceleration vector components of test particle interface public module subroutine netcdf_close(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( netcdf_parameters ), intent(inout) :: self Parameters used to identify a particular NetCDF dataset class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine netcdf_initialize_output(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( netcdf_parameters ), intent(inout) :: self Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine netcdf_open(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( netcdf_parameters ), intent(inout) :: self Parameters used to identify a particular NetCDF dataset class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine netcdf_write_frame_base(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest base object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public subroutine netcdf_write_frame_system(self, iu, param) Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine netcdf_write_hdr_system(self, iu, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest nbody system object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine netcdf_write_particle_info_base(self, iu) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset interface public module subroutine obl_acc_body(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object interface public module subroutine obl_acc_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object interface public module subroutine obl_acc_tp(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object interface public module subroutine obl_pot_system(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object interface public module subroutine orbel_el2xv_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object interface public pure module subroutine orbel_scget(angle, sx, cx) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: angle real(kind=DP), intent(out) :: sx real(kind=DP), intent(out) :: cx interface public pure module subroutine orbel_xv2aeq(mu, x, v, a, e, q) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(out) :: a semimajor axis real(kind=DP), intent(out) :: e eccentricity real(kind=DP), intent(out) :: q periapsis interface public pure module subroutine orbel_xv2aqt(mu, x, v, a, q, capm, tperi) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(out) :: a semimajor axis real(kind=DP), intent(out) :: q periapsis real(kind=DP), intent(out) :: capm mean anomaly real(kind=DP), intent(out) :: tperi time of pericenter passage interface public pure module subroutine orbel_xv2el(mu, x, v, a, e, inc, capom, omega, capm) Implementation → Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(out) :: a semimajor axis real(kind=DP), intent(out) :: e eccentricity real(kind=DP), intent(out) :: inc inclination real(kind=DP), intent(out) :: capom longitude of ascending node real(kind=DP), intent(out) :: omega argument of periapsis real(kind=DP), intent(out) :: capm mean anomaly interface public module subroutine orbel_xv2el_vec(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object interface public module subroutine setup_body(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine setup_construct_system(system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout), allocatable :: system Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine setup_encounter(self, n) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for interface public module subroutine setup_initialize_particle_info_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine setup_initialize_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine setup_pl(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine setup_tp(self, n, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parametersr interface public module subroutine tides_kick_getacch_pl(self, system) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object interface public module subroutine tides_step_spin_system(self, param, t, dt) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize interface public module subroutine user_kick_getacch_body(self, system, param, t, lbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step public interface util_append public subroutine util_append_arr_char_string(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: arr Destination array character(len=STRMAX), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to public subroutine util_append_arr_DP(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: arr Destination array real(kind=DP), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to public subroutine util_append_arr_DPvec(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: arr Destination array real(kind=DP), intent(in), dimension(:,:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to public subroutine util_append_arr_I4B(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to public subroutine util_append_arr_info(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: arr Destination array type( swiftest_particle_info ), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to public subroutine util_append_arr_logical(arr, source, nold, nsrc, lsource_mask) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: arr Destination array logical, intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine util_append_body(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine util_append_encounter(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list object class( swiftest_encounter ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine util_append_pl(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine util_append_tp(self, source, lsource_mask) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to interface public module subroutine util_coord_b2h_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object interface public module subroutine util_coord_b2h_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object interface public module subroutine util_coord_h2b_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object interface public module subroutine util_coord_h2b_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object interface public module subroutine util_coord_vb2vh_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object interface public module subroutine util_coord_vb2vh_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body interface public module subroutine util_coord_vh2vb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object interface public module subroutine util_coord_vh2vb_tp(self, vbcb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body interface public module subroutine util_coord_xh2xb_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object interface public module subroutine util_coord_xh2xb_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object interface public module subroutine util_copy_encounter(self, source) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Encounter list class( swiftest_encounter ), intent(in) :: source Source object to copy into interface public module subroutine util_copy_particle_info(self, source) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(inout) :: self class( swiftest_particle_info ), intent(in) :: source interface public module subroutine util_copy_particle_info_arr(source, dest, idx) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(in), dimension(:) :: source Source object to copy into class( swiftest_particle_info ), intent(inout), dimension(:) :: dest Swiftest body object with particle metadata information object integer(kind=I4B), intent(in), optional dimension(:) :: idx Optional array of indices to draw the source object interface public module subroutine util_exit(code) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: code Failure exit code interface public module subroutine util_fill_body(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps interface public module subroutine util_fill_pl(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps interface public module subroutine util_fill_tp(self, inserts, lfill_list) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public interface util_fill public subroutine util_fill_arr_char_string(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: keeps Array of values to keep character(len=STRMAX), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public subroutine util_fill_arr_DP(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: keeps Array of values to keep real(kind=DP), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public subroutine util_fill_arr_DPvec(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: keeps Array of values to keep real(kind=DP), intent(in), dimension(:,:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public subroutine util_fill_arr_I4B(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: keeps Array of values to keep integer(kind=I4B), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public subroutine util_fill_arr_info(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( swiftest_particle_info ), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps public subroutine util_fill_arr_logical(keeps, inserts, lfill_list) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: keeps Array of values to keep logical, intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps interface public module function util_minimize_bfgs(f, N, x0, eps, maxloop, lerr) result(x1) Implementation → Arguments Type Intent Optional Attributes Name class(lambda_obj), intent(inout) :: f integer(kind=I4B), intent(in) :: N real(kind=DP), intent(in), dimension(:) :: x0 real(kind=DP), intent(in) :: eps integer(kind=I4B), intent(in) :: maxloop logical, intent(out) :: lerr Return Value real(kind=DP),\n  dimension(:), allocatable interface public module subroutine util_rescale_system(self, param, mscale, dscale, tscale) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters. Returns with new values of the scale vactors and GU real(kind=DP), intent(in) :: mscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: dscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: tscale Scale factors for mass, distance, and time units, respectively. interface public module subroutine util_peri_tp(self, system, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters public interface util_resize public subroutine util_resize_arr_char_string(arr, nnew) Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size public subroutine util_resize_arr_DP(arr, nnew) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size public subroutine util_resize_arr_DPvec(arr, nnew) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size public subroutine util_resize_arr_I4B(arr, nnew) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size public subroutine util_resize_arr_info(arr, nnew) Arguments Type Intent Optional Attributes Name type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size public subroutine util_resize_arr_logical(arr, nnew) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size interface public module subroutine util_resize_body(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in) :: nnew New size neded interface public module subroutine util_resize_encounter(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list integer(kind=I4B), intent(in) :: nnew New size of list needed interface public module subroutine util_resize_pl(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: nnew New size neded interface public module subroutine util_resize_tp(self, nnew) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: nnew New size neded interface public module subroutine util_get_energy_momentum_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters interface public module subroutine util_set_beg_end_pl(self, xbeg, xend, vbeg) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object real(kind=DP), intent(in), optional dimension(:,:) :: xbeg Position vectors at beginning of step real(kind=DP), intent(in), optional dimension(:,:) :: xend Positions vectors at end of step real(kind=DP), intent(in), optional dimension(:,:) :: vbeg vbeg is an unused variable to keep this method forward compatible with RMVS interface public module subroutine util_set_ir3h(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object interface public module subroutine util_set_msys(self) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object interface public module subroutine util_set_mu_pl(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object interface public module subroutine util_set_mu_tp(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object interface public module subroutine util_set_particle_info(self, name, particle_type, status, origin_type, origin_time, origin_xh, origin_vh, discard_time, discard_xh, discard_vh, discard_body_id) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(inout) :: self character(len=*), intent(in), optional :: name Non-unique name character(len=*), intent(in), optional :: particle_type String containing a description of the particle type (e.g. Central Body, Massive Body, Test Particle) character(len=*), intent(in), optional :: status Particle status description: Active, Merged, Fragmented, etc. character(len=*), intent(in), optional :: origin_type String containing a description of the origin of the particle (e.g. Initial Conditions, Supercatastrophic, Disruption, etc.) real(kind=DP), intent(in), optional :: origin_time The time of the particle's formation real(kind=DP), intent(in), optional dimension(:) :: origin_xh The heliocentric distance vector at the time of the particle's formation real(kind=DP), intent(in), optional dimension(:) :: origin_vh The heliocentric velocity vector at the time of the particle's formation real(kind=DP), intent(in), optional :: discard_time The time of the particle's discard real(kind=DP), intent(in), optional dimension(:) :: discard_xh The heliocentric distance vector at the time of the particle's discard real(kind=DP), intent(in), optional dimension(:) :: discard_vh The heliocentric velocity vector at the time of the particle's discard integer(kind=I4B), intent(in), optional :: discard_body_id The id of the other body involved in the discard (0 if no other body involved) interface public module subroutine util_set_rhill(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object interface public module subroutine util_set_rhill_approximate(self, cb) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object public interface util_solve_linear_system public function util_solve_linear_system_d(A, b, n, lerr) result(x) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A real(kind=DP), intent(in), dimension(:) :: b integer(kind=I4B), intent(in) :: n logical, intent(out) :: lerr Return Value real(kind=DP),\n  dimension(n) public function util_solve_linear_system_q(A, b, n, lerr) result(x) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A real(kind=QP), intent(in), dimension(:) :: b integer(kind=I4B), intent(in) :: n logical, intent(out) :: lerr Return Value real(kind=QP),\n  dimension(n) interface public module function util_solve_rkf45(f, y0in, t1, dt0, tol) result(y1) Implementation → Arguments Type Intent Optional Attributes Name class(lambda_obj), intent(inout) :: f lambda function object that has been initialized to be a function of derivatives. The object will return with components lastarg and lasteval set real(kind=DP), intent(in), dimension(:) :: y0in Initial value at t=0 real(kind=DP), intent(in) :: t1 Final time real(kind=DP), intent(in) :: dt0 Initial step size guess real(kind=DP), intent(in) :: tol Tolerance on solution Return Value real(kind=DP),\n  dimension(:), allocatable Final result public interface util_sort public subroutine util_sort_i4b(arr) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:) :: arr public subroutine util_sort_index_i4b(arr, ind) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind public subroutine util_sort_sp(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), dimension(:) :: arr public subroutine util_sort_index_sp(arr, ind) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind public subroutine util_sort_dp(arr) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:) :: arr public subroutine util_sort_index_dp(arr, ind) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind public interface util_sort_rearrange public subroutine util_sort_rearrange_arr_char_string(arr, ind, n) Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange public subroutine util_sort_rearrange_arr_DP(arr, ind, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange public subroutine util_sort_rearrange_arr_DPvec(arr, ind, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange public subroutine util_sort_rearrange_arr_I4B(arr, ind, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange public subroutine util_sort_rearrange_arr_info(arr, ind, n) Arguments Type Intent Optional Attributes Name type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange public subroutine util_sort_rearrange_arr_logical(arr, ind, n) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange interface public module subroutine util_sort_rearrange_body(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) interface public module subroutine util_sort_rearrange_pl(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) interface public module subroutine util_sort_rearrange_tp(self, ind) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) interface public module subroutine util_sort_body(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order interface public module subroutine util_sort_pl(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order interface public module subroutine util_sort_tp(self, sortby, ascending) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order public interface util_spill public subroutine util_spill_arr_char_string(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: keeps Array of values to keep character(len=STRMAX), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine util_spill_arr_DP(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: keeps Array of values to keep real(kind=DP), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine util_spill_arr_DPvec(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: keeps Array of values to keep real(kind=DP), intent(inout), dimension(:,:), allocatable :: discards Array discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine util_spill_arr_I4B(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: keeps Array of values to keep integer(kind=I4B), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine util_spill_arr_I8B(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(inout), dimension(:), allocatable :: keeps Array of values to keep integer(kind=I8B), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine util_spill_arr_info(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not public subroutine util_spill_arr_logical(keeps, discards, lspill_list, ldestructive) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: keeps Array of values to keep logical, intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not interface public module subroutine util_spill_body(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not interface public module subroutine util_spill_encounter(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list interface public module subroutine util_spill_pl(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not interface public module subroutine util_spill_tp(self, discards, lspill_list, ldestructive) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not interface public module subroutine util_valid_id_system(self, param) Implementation → Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters interface public module subroutine util_version() Implementation → Arguments None Abstract Interfaces abstract interface public function abstract_read_frame(self, iu, param) result(ierr) Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful abstract interface public subroutine abstract_discard_body(self, system, param) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters abstract interface public subroutine abstract_accel(self, system, param, t, lbeg) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step abstract interface public subroutine abstract_kick_body(self, system, param, t, dt, lbeg) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system objec class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. abstract interface public subroutine abstract_set_mu(self, cb) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object abstract interface public subroutine abstract_step_body(self, system, param, t, dt) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize abstract interface public subroutine abstract_step_system(self, param, t, dt) Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize Derived Types type, public :: netcdf_parameters Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: out_type NetCDF output type (will be assigned either NF90_DOUBLE or NF90_FLOAT, depending on the user parameter) integer(kind=I4B), public :: ncid NetCDF ID for the output file integer(kind=I4B), public :: dimids (3) Dimensions of the NetCDF file integer(kind=I4B), public :: time_dimid NetCDF ID for the time dimension integer(kind=I4B), public :: id_dimid NetCDF ID for the particle id dimension integer(kind=I4B), public :: str_dimid NetCDF ID for the character string dimension integer(kind=I4B), public :: time_varid NetCDF ID for the time variable integer(kind=I4B), public :: id_varid NetCDF ID for the particle name variable integer(kind=I4B), public :: name_varid NetCDF ID for the namevariable integer(kind=I4B), public :: ptype_varid NetCDF ID for the particle type variable integer(kind=I4B), public :: npl_varid NetCDF ID for the number of active massive bodies variable integer(kind=I4B), public :: ntp_varid NetCDF ID for the number of active test particles variable integer(kind=I4B), public :: a_varid NetCDF ID for the semimajor axis variable integer(kind=I4B), public :: e_varid NetCDF ID for the eccentricity variable integer(kind=I4B), public :: inc_varid NetCDF ID for the inclination variable integer(kind=I4B), public :: capom_varid NetCDF ID for the long. asc. node variable integer(kind=I4B), public :: omega_varid NetCDF ID for the arg. periapsis variable integer(kind=I4B), public :: capm_varid NetCDF ID for the mean anomaly variable integer(kind=I4B), public :: xhx_varid NetCDF ID for the heliocentric position x variable integer(kind=I4B), public :: xhy_varid NetCDF ID for the heliocentric position y variable integer(kind=I4B), public :: xhz_varid NetCDF ID for the heliocentric position z variable integer(kind=I4B), public :: vhx_varid NetCDF ID for the heliocentric velocity x variable integer(kind=I4B), public :: vhy_varid NetCDF ID for the heliocentric velocity y variable integer(kind=I4B), public :: vhz_varid NetCDF ID for the heliocentric velocity z variable integer(kind=I4B), public :: Gmass_varid NetCDF ID for the mass variable integer(kind=I4B), public :: rhill_varid NetCDF ID for the hill radius variable integer(kind=I4B), public :: radius_varid NetCDF ID for the radius variable integer(kind=I4B), public :: Ip1_varid NetCDF ID for the axis 1 principal moment of inertia variable integer(kind=I4B), public :: Ip2_varid NetCDF ID for the axis 2 principal moment of inertia variable integer(kind=I4B), public :: Ip3_varid NetCDF ID for the axis 3 principal moment of inertia variable integer(kind=I4B), public :: rotx_varid NetCDF ID for the rotation x variable integer(kind=I4B), public :: roty_varid NetCDF ID for the rotation y variable integer(kind=I4B), public :: rotz_varid NetCDF ID for the rotation z variable integer(kind=I4B), public :: k2_varid NetCDF ID for the Love number variable integer(kind=I4B), public :: Q_varid NetCDF ID for the energy dissipation variable integer(kind=I4B), public :: KE_orb_varid NetCDF ID for the system orbital kinetic energy variable integer(kind=I4B), public :: KE_spin_varid NetCDF ID for the system spin kinetic energy variable integer(kind=I4B), public :: PE_varid NetCDF ID for the system potential energy variable integer(kind=I4B), public :: L_orbx_varid NetCDF ID for the system orbital angular momentum x variable integer(kind=I4B), public :: L_orby_varid NetCDF ID for the system orbital angular momentum y variable integer(kind=I4B), public :: L_orbz_varid NetCDF ID for the system orbital angular momentum z variable integer(kind=I4B), public :: L_spinx_varid NetCDF ID for the system spin angular momentum x variable integer(kind=I4B), public :: L_spiny_varid NetCDF ID for the system spin angular momentum y variable integer(kind=I4B), public :: L_spinz_varid NetCDF ID for the system spin angular momentum z variable integer(kind=I4B), public :: L_escapex_varid NetCDF ID for the escaped angular momentum x variable integer(kind=I4B), public :: L_escapey_varid NetCDF ID for the escaped angular momentum x variable integer(kind=I4B), public :: L_escapez_varid NetCDF ID for the escaped angular momentum x variable integer(kind=I4B), public :: Ecollisions_varid NetCDF ID for the energy lost in collisions variable integer(kind=I4B), public :: Euntracked_varid NetCDF ID for the energy that is untracked due to loss (untracked potential energy due to mergers and body energy for escaped bodies) integer(kind=I4B), public :: GMescape_varid NetCDF ID for the G*Mass of bodies that escape the system integer(kind=I4B), public :: status_varid NetCDF ID for the status variable integer(kind=I4B), public :: origin_type_varid NetCDF ID for the origin type integer(kind=I4B), public :: origin_time_varid NetCDF ID for the origin time integer(kind=I4B), public :: origin_xhx_varid NetCDF ID for the origin xh x component integer(kind=I4B), public :: origin_xhy_varid NetCDF ID for the origin xh y component integer(kind=I4B), public :: origin_xhz_varid NetCDF ID for the origin xh z component integer(kind=I4B), public :: origin_vhx_varid NetCDF ID for the origin xh x component integer(kind=I4B), public :: origin_vhy_varid NetCDF ID for the origin xh y component integer(kind=I4B), public :: origin_vhz_varid NetCDF ID for the origin xh z component integer(kind=I4B), public :: discard_time_varid NetCDF ID for the time of discard variable integer(kind=I4B), public :: discard_xhx_varid NetCDF ID for the heliocentric position of the body at the time of discard x variable integer(kind=I4B), public :: discard_xhy_varid NetCDF ID for the heliocentric position of the body at the time of discard y variable integer(kind=I4B), public :: discard_xhz_varid NetCDF ID for the heliocentric position of the body at the time of discard z variable integer(kind=I4B), public :: discard_vhx_varid NetCDF ID for the heliocentric velocity of the body at the time of discard x variable integer(kind=I4B), public :: discard_vhy_varid NetCDF ID for the heliocentric velocity of the body at the time of discard y variable integer(kind=I4B), public :: discard_vhz_varid NetCDF ID for the heliocentric velocity of the body at the time of discard z variable integer(kind=I4B), public :: discard_body_id_varid NetCDF ID for the id of the other body involved in the discard Type-Bound Procedures procedure, public :: close => netcdf_close Closes an open NetCDF file procedure, public :: initialize => netcdf_initialize_output Initialize a set of parameters used to identify a NetCDF output object procedure, public :: open => netcdf_open Opens a NetCDF file type, public :: swiftest_parameters User defined parameters that are read in from the parameters input file. \n    Each paramter is initialized to a default values. Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: integrator = UNKNOWN_INTEGRATOR Symbolic name of the nbody integrator  used integer(kind=I4B), public :: maxid = -1 The current maximum particle id number real(kind=DP), public :: t0 = -1.0_DP Integration start time real(kind=DP), public :: t = -1.0_DP Integration current time real(kind=DP), public :: tstop = -1.0_DP Integration stop time real(kind=DP), public :: dt = -1.0_DP Time step integer(kind=I8B), public :: ioutput = 0_I8B Output counter character(len=STRMAX), public :: incbfile = CB_INFILE Name of input file for the central body character(len=STRMAX), public :: inplfile = PL_INFILE Name of input file for massive bodies character(len=STRMAX), public :: intpfile = TP_INFILE Name of input file for test particles character(len=STRMAX), public :: in_type = ASCII_TYPE Data representation type of input data files character(len=STRMAX), public :: in_form = XV Format of input data files (EL or XV) integer(kind=I4B), public :: istep_out = -1 Number of time steps between binary outputs character(len=STRMAX), public :: outfile = NETCDF_OUTFILE Name of output binary file character(len=STRMAX), public :: out_type = NETCDF_DOUBLE_TYPE Binary format of output file character(len=STRMAX), public :: out_form = XVEL Data to write to output file character(len=STRMAX), public :: out_stat = 'NEW' Open status for output binary file character(len=STRMAX), public :: particle_out = PARTICLE_OUTFILE Name of output particle information file integer(kind=I4B), public :: istep_dump = -1 Number of time steps between dumps real(kind=DP), public :: rmin = -1.0_DP Minimum heliocentric radius for test particle real(kind=DP), public :: rmax = -1.0_DP Maximum heliocentric radius for test particle real(kind=DP), public :: rmaxu = -1.0_DP Maximum unbound heliocentric radius for test particle real(kind=DP), public :: qmin = -1.0_DP Minimum pericenter distance for test particle character(len=STRMAX), public :: qmin_coord = 'HELIO' Coordinate frame to use for qmin real(kind=DP), public :: qmin_alo = -1.0_DP Minimum semimajor axis for qmin real(kind=DP), public :: qmin_ahi = -1.0_DP Maximum semimajor axis for qmin character(len=STRMAX), public :: enc_out = \"\" Name of output file for encounters character(len=STRMAX), public :: discard_out = \"\" Name of output file for discards real(kind=QP), public :: MU2KG = -1.0_QP Converts mass units to grams real(kind=QP), public :: TU2S = -1.0_QP Converts time units to seconds real(kind=QP), public :: DU2M = -1.0_QP Converts distance unit to centimeters real(kind=DP), public :: GU = -1.0_DP Universal gravitational constant in the system units real(kind=DP), public :: inv_c2 = -1.0_DP Inverse speed of light squared in the system units character(len=STRMAX), public :: energy_out = \"\" Name of output energy and momentum report file logical, public :: lrhill_present = .false. Hill radii are given as an input rather than calculated by the code (can be used to inflate close encounter regions manually) logical, public :: lextra_force = .false. User defined force function turned on logical, public :: lbig_discard = .false. Save big bodies on every discard logical, public :: lclose = .false. Turn on close encounters logical, public :: lenergy = .false. Track the total energy of the system logical, public :: loblatecb = .false. Calculate acceleration from oblate central body (automatically turns true if nonzero J2 is input) logical, public :: lrotation = .false. Include rotation states of big bodies logical, public :: ltides = .false. Include tidal dissipation real(kind=DP), public :: Eorbit_orig = 0.0_DP Initial orbital energy real(kind=DP), public :: GMtot_orig = 0.0_DP Initial system mass real(kind=DP), public, dimension(NDIM) :: Ltot_orig = 0.0_DP Initial total angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lorbit_orig = 0.0_DP Initial orbital angular momentum real(kind=DP), public, dimension(NDIM) :: Lspin_orig = 0.0_DP Initial spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lescape = 0.0_DP Angular momentum of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: GMescape = 0.0_DP Mass of bodies that escaped the system (used for bookeeping) real(kind=DP), public :: Ecollisions = 0.0_DP Energy lost from system due to collisions real(kind=DP), public :: Euntracked = 0.0_DP Energy gained from system due to escaped bodies logical, public :: lfirstenergy = .true. This is the first time computing energe logical, public :: lfirstkick = .true. Initiate the first kick in a symplectic step logical, public :: lrestart = .false. Indicates whether or not this is a restarted run logical, public :: lgr = .false. Turn on GR logical, public :: lyarkovsky = .false. Turn on Yarkovsky effect logical, public :: lyorp = .false. Turn on YORP effect type( netcdf_parameters ), public :: nciu Object containing NetCDF parameters Type-Bound Procedures procedure, public :: reader => io_param_reader procedure, public :: writer => io_param_writer procedure, public :: dump => io_dump_param procedure, public :: read_in => io_read_in_param type, public :: swiftest_particle_info Class definition for the particle origin information object. This object is used to track time, location, and collisional regime\n of fragments produced in collisional events. Components Type Visibility Attributes Name Initial character(len=NAMELEN), public :: name Non-unique name character(len=NAMELEN), public :: particle_type String containing a description of the particle type (e.g. Central Body, Massive Body, Test Particle) character(len=NAMELEN), public :: origin_type String containing a description of the origin of the particle (e.g. Initial Conditions, Supercatastrophic, Disruption, etc.) real(kind=DP), public :: origin_time The time of the particle's formation real(kind=DP), public, dimension(NDIM) :: origin_xh The heliocentric distance vector at the time of the particle's formation real(kind=DP), public, dimension(NDIM) :: origin_vh The heliocentric velocity vector at the time of the particle's formation real(kind=DP), public :: discard_time The time of the particle's discard character(len=NAMELEN), public :: status Particle status description: Active, Merged, Fragmented, etc. real(kind=DP), public, dimension(NDIM) :: discard_xh The heliocentric distance vector at the time of the particle's discard real(kind=DP), public, dimension(NDIM) :: discard_vh The heliocentric velocity vector at the time of the particle's discard integer(kind=I4B), public :: discard_body_id The id of the other body involved in the discard (0 if no other body involved) Type-Bound Procedures procedure, public :: dump => io_dump_particle_info Dumps contents of particle information to file procedure, public :: read_in => io_read_in_particle_info Read in a particle information object from an open file procedure, public :: copy => util_copy_particle_info Copies one set of information object components into another, component-by-component procedure, public :: set_value => util_set_particle_info Sets one or more values of the particle information metadata object type, public, abstract :: swiftest_base An abstract superclass for a generic Swiftest object\n The minimal methods that all systems must have Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file generic, public :: write_frame => write_frame_netcdf Set up generic procedure that will switch between NetCDF or Fortran binary depending on arguments generic, public :: write_particle_info => write_particle_info_netcdf type, public, abstract, extends( swiftest_base ) :: swiftest_cb A concrete lass for the central body in a Swiftest simulation Components Type Visibility Attributes Name Initial type( swiftest_particle_info ), public :: info Particle metadata information integer(kind=I4B), public :: id = 0 External identifier (unique) real(kind=DP), public :: mass = 0.0_DP Central body mass (units MU) real(kind=DP), public :: Gmass = 0.0_DP Central mass gravitational term G * mass (units GU * MU) real(kind=DP), public :: radius = 0.0_DP Central body radius (units DU) real(kind=DP), public :: density = 1.0_DP Central body mass density - calculated internally (units MU / DU**3) real(kind=DP), public :: j2rp2 = 0.0_DP J2*R&#94;2 term for central body real(kind=DP), public :: j4rp4 = 0.0_DP J4*R&#94;2 term for central body real(kind=DP), public, dimension(NDIM) :: aobl = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: atide = 0.0_DP Barycentric acceleration due to central body oblatenes real(kind=DP), public, dimension(NDIM) :: aoblbeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: aoblend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: atidebeg = 0.0_DP Barycentric acceleration due to central body oblatenes at beginning of step real(kind=DP), public, dimension(NDIM) :: atideend = 0.0_DP Barycentric acceleration due to central body oblatenes at end of step real(kind=DP), public, dimension(NDIM) :: xb = 0.0_DP Barycentric position (units DU) real(kind=DP), public, dimension(NDIM) :: vb = 0.0_DP Barycentric velocity (units DU / TU) real(kind=DP), public, dimension(NDIM) :: agr = 0.0_DP Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(NDIM) :: Ip = 0.0_DP Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(NDIM) :: rot = 0.0_DP Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public :: k2 = 0.0_DP Tidal Love number real(kind=DP), public :: Q = 0.0_DP Tidal quality factor real(kind=DP), public :: tlag = 0.0_DP Tidal phase lag angle real(kind=DP), public, dimension(NDIM) :: L0 = 0.0_DP Initial angular momentum of the central body real(kind=DP), public, dimension(NDIM) :: dL = 0.0_DP Change in angular momentum of the central body Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file generic, public :: write_particle_info => write_particle_info_netcdf procedure, public :: read_in => io_read_in_cb I/O routine for reading in central body data procedure, public :: read_frame => io_read_frame_cb I/O routine for reading out a single frame of time-series data for the central body procedure, public :: write_frame_bin => io_write_frame_cb I/O routine for writing out a single frame of time-series data for the central body generic, public :: write_frame => write_frame_netcdf, write_frame_bin Write a frame (either binary or NetCDF, using generic procedures) type, public, abstract, extends( swiftest_base ) :: swiftest_body An abstract class for a generic collection of Swiftest bodies\n Superclass that defines the generic elements of a Swiftest particle Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file generic, public :: write_particle_info => write_particle_info_netcdf procedure(abstract_discard_body), public :: discard procedure(abstract_kick_body), public :: kick procedure(abstract_set_mu), public :: set_mu procedure(abstract_step_body), public :: step procedure(abstract_accel), public :: accel procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: accel_obl => obl_acc_body Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: setup => setup_body A constructor that sets the number of bodies and allocates all allocatable arrays procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: append => util_append_body Appends elements from one structure to another procedure, public :: fill => util_fill_body \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: resize => util_resize_body Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) procedure, public :: sort => util_sort_body Sorts body arrays by a sortable componen procedure, public :: rearrange => util_sort_rearrange_body Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => util_spill_body \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) generic, public :: write_frame => write_frame_netcdf, write_frame_bin Add the generic write frame for Fortran binary files type, public, abstract, extends( swiftest_body ) :: swiftest_pl An abstract class for a generic collection of Swiftest massive bodies\n Superclass that defines the generic elements of a Swiftest particle Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill real(kind=DP), public, dimension(:), allocatable :: mass Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: Gmass Mass gravitational term G * mass (units GU * MU) real(kind=DP), public, dimension(:), allocatable :: rhill Body mass (units MU) real(kind=DP), public, dimension(:), allocatable :: radius Body radius (units DU) real(kind=DP), public, dimension(:,:), allocatable :: xbeg Position at beginning of step real(kind=DP), public, dimension(:,:), allocatable :: xend Position at end of step real(kind=DP), public, dimension(:,:), allocatable :: vbeg Velocity at beginning of step real(kind=DP), public, dimension(:), allocatable :: density Body mass density - calculated internally (units MU / DU**3) real(kind=DP), public, dimension(:,:), allocatable :: Ip Unitless principal moments of inertia (I1, I2, I3) / (MR**2). Principal axis rotation assumed. real(kind=DP), public, dimension(:,:), allocatable :: rot Body rotation vector in inertial coordinate frame (units rad / TU) real(kind=DP), public, dimension(:), allocatable :: k2 Tidal Love number real(kind=DP), public, dimension(:), allocatable :: Q Tidal quality factor real(kind=DP), public, dimension(:), allocatable :: tlag Tidal phase lag integer(kind=I4B), public, dimension(:,:), allocatable :: k_plpl Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: nplpl Number of body-body comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_pl and util_spill_pl Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file generic, public :: write_particle_info => write_particle_info_netcdf procedure(abstract_kick_body), public :: kick procedure(abstract_step_body), public :: step procedure(abstract_accel), public :: accel procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) generic, public :: write_frame => write_frame_netcdf, write_frame_bin Add the generic write frame for Fortran binary files procedure, public :: discard => discard_pl Placeholder method for discarding massive bodies procedure, public :: index => util_index_eucl_plpl Sets up the (i, j) -> k indexing used for the single-loop blocking Euclidean distance matrix procedure, public :: accel_int => kick_getacch_int_pl Compute direct cross (third) term heliocentric accelerations of massive bodies procedure, public :: accel_obl => obl_acc_pl Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: setup => setup_pl A base constructor that sets the number of bodies and allocates and initializes all arrays procedure, public :: accel_tides => tides_kick_getacch_pl Compute the accelerations of bodies due to tidal interactions with the central body procedure, public :: append => util_append_pl Appends elements from one structure to another procedure, public :: h2b => util_coord_h2b_pl Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_pl Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) procedure, public :: vh2vb => util_coord_vh2vb_pl Convert massive bodies from heliocentric to barycentric coordinates (velocity only) procedure, public :: vb2vh => util_coord_vb2vh_pl Convert massive bodies from barycentric to heliocentric coordinates (velocity only) procedure, public :: xh2xb => util_coord_xh2xb_pl Convert massive bodies from heliocentric to barycentric coordinates (position only) procedure, public :: fill => util_fill_pl \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: resize => util_resize_pl Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure, public :: set_beg_end => util_set_beg_end_pl Sets the beginning and ending positions and velocities of planets. procedure, public :: set_mu => util_set_mu_pl Method used to construct the vectorized form of the central body mass procedure, public :: set_rhill => util_set_rhill Calculates the Hill's radii for each body procedure, public :: sort => util_sort_pl Sorts body arrays by a sortable component procedure, public :: rearrange => util_sort_rearrange_pl Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => util_spill_pl \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) type, public, abstract, extends( swiftest_body ) :: swiftest_tp An abstract class for a generic collection of Swiftest test particles\n Superclass that defines the generic elements of a Swiftest test particle Components Type Visibility Attributes Name Initial logical, public :: lfirst = .true. Run the current step as a first integer(kind=I4B), public :: nbody = 0 Number of bodies type( swiftest_particle_info ), public, dimension(:), allocatable :: info Particle metadata information integer(kind=I4B), public, dimension(:), allocatable :: id External identifier (unique) integer(kind=I4B), public, dimension(:), allocatable :: status An integrator-specific status indicator logical, public, dimension(:), allocatable :: ldiscard Body should be discarded logical, public, dimension(:), allocatable :: lmask Logical mask used to select a subset of bodies when performing certain operations (drift, kick, accel, etc.) real(kind=DP), public, dimension(:), allocatable :: mu G * (Mcb + [m]) real(kind=DP), public, dimension(:,:), allocatable :: xh Swiftestcentric position real(kind=DP), public, dimension(:,:), allocatable :: vh Swiftestcentric velocity real(kind=DP), public, dimension(:,:), allocatable :: xb Barycentric position real(kind=DP), public, dimension(:,:), allocatable :: vb Barycentric velocity real(kind=DP), public, dimension(:,:), allocatable :: ah Total heliocentric acceleration real(kind=DP), public, dimension(:,:), allocatable :: aobl Barycentric accelerations of bodies due to central body oblatenes real(kind=DP), public, dimension(:,:), allocatable :: atide Tanngential component of acceleration of bodies due to tides real(kind=DP), public, dimension(:,:), allocatable :: agr Acceleration due to post-Newtonian correction real(kind=DP), public, dimension(:), allocatable :: ir3h Inverse heliocentric radius term (1/rh**3) real(kind=DP), public, dimension(:), allocatable :: a Semimajor axis (pericentric distance for a parabolic orbit) real(kind=DP), public, dimension(:), allocatable :: e Eccentricity real(kind=DP), public, dimension(:), allocatable :: inc Inclination real(kind=DP), public, dimension(:), allocatable :: capom Longitude of ascending node real(kind=DP), public, dimension(:), allocatable :: omega Argument of pericenter real(kind=DP), public, dimension(:), allocatable :: capm Mean anomaly\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_body and util_spill integer(kind=I4B), public, dimension(:), allocatable :: isperi Perihelion passage flag real(kind=DP), public, dimension(:), allocatable :: peri Perihelion distance real(kind=DP), public, dimension(:), allocatable :: atp Semimajor axis following perihelion passage integer(kind=I4B), public, dimension(:,:), allocatable :: k_pltp Index array used to convert flattened the body-body comparison upper triangular matrix integer(kind=I8B), public :: npltp Number of pl-tp comparisons in the flattened upper triangular matrix\n Note to developers: If you add components to this class, be sure to update methods and subroutines that traverse the\n    component list, such as setup_tp and util_spill_tp Type-Bound Procedures procedure, public :: dump => io_dump_base Dump contents to file procedure, public :: dump_particle_info => io_dump_particle_info_base Dump contents of particle information metadata to file procedure, public :: write_frame_netcdf => netcdf_write_frame_base I/O routine for writing out a single frame of time-series data for all bodies in the system in NetCDF format procedure, public :: write_particle_info_netcdf => netcdf_write_particle_info_base Writes out the particle information metadata to NetCDF file generic, public :: write_particle_info => write_particle_info_netcdf procedure(abstract_kick_body), public :: kick procedure(abstract_step_body), public :: step procedure(abstract_accel), public :: accel procedure, public :: drift => drift_body Loop through bodies and call Danby drift routine on heliocentric variables procedure, public :: v2pv => gr_vh2pv_body Converts from velocity to psudeovelocity for GR calculations using symplectic integrators procedure, public :: pv2v => gr_pv2vh_body Converts from psudeovelocity to velocity for GR calculations using symplectic integrators procedure, public :: read_in => io_read_in_body Read in body initial conditions from a file procedure, public :: read_frame => io_read_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: write_frame_bin => io_write_frame_body I/O routine for writing out a single frame of time-series data for the central body procedure, public :: el2xv => orbel_el2xv_vec Convert orbital elements to position and velocity vectors procedure, public :: xv2el => orbel_xv2el_vec Convert position and velocity vectors to orbital  elements procedure, public :: accel_user => user_kick_getacch_body Add user-supplied heliocentric accelerations to planets procedure, public :: set_ir3 => util_set_ir3h Sets the inverse heliocentric radius term (1/rh**3) generic, public :: write_frame => write_frame_netcdf, write_frame_bin Add the generic write frame for Fortran binary files procedure, public :: discard => discard_tp Check to see if test particles should be discarded based on their positions relative to the massive bodies procedure, public :: accel_int => kick_getacch_int_tp Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies procedure, public :: accel_obl => obl_acc_tp Compute the barycentric accelerations of bodies due to the oblateness of the central body procedure, public :: setup => setup_tp A base constructor that sets the number of bodies and procedure, public :: append => util_append_tp Appends elements from one structure to another procedure, public :: h2b => util_coord_h2b_tp Convert test particles from heliocentric to barycentric coordinates (position and velocity) procedure, public :: b2h => util_coord_b2h_tp Convert test particles from barycentric to heliocentric coordinates (position and velocity) procedure, public :: vb2vh => util_coord_vb2vh_tp Convert test particles from barycentric to heliocentric coordinates (velocity only) procedure, public :: vh2vb => util_coord_vh2vb_tp Convert test particles from heliocentric to barycentric coordinates (velocity only) procedure, public :: xh2xb => util_coord_xh2xb_tp Convert test particles from heliocentric to barycentric coordinates (position only) procedure, public :: fill => util_fill_tp \"Fills\" bodies from one object into another depending on the results of a mask (uses the UNPACK intrinsic) procedure, public :: get_peri => util_peri_tp Determine system pericenter passages for test particles procedure, public :: resize => util_resize_tp Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. procedure, public :: set_mu => util_set_mu_tp Method used to construct the vectorized form of the central body mass procedure, public :: sort => util_sort_tp Sorts body arrays by a sortable component procedure, public :: rearrange => util_sort_rearrange_tp Rearranges the order of array elements of body based on an input index array. Used in sorting methods procedure, public :: spill => util_spill_tp \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) type, public, abstract :: swiftest_nbody_system An abstract class for a basic Swiftest nbody system \n  This superclass contains a minimial system of a set of test particles (tp), massive bodies (pl), and a central body (cb) Components Type Visibility Attributes Name Initial class( swiftest_cb ), public, allocatable :: cb Central body data structure class( swiftest_pl ), public, allocatable :: pl Massive body data structure class( swiftest_tp ), public, allocatable :: tp Test particle data structure class( swiftest_tp ), public, allocatable :: tp_discards Discarded test particle data structure class( swiftest_pl ), public, allocatable :: pl_discards Discarded massive body particle data structure real(kind=DP), public :: GMtot = 0.0_DP Total system mass - used for barycentric coordinate conversion real(kind=DP), public :: ke_orbit = 0.0_DP System orbital kinetic energy real(kind=DP), public :: ke_spin = 0.0_DP System spin kinetic energy real(kind=DP), public :: pe = 0.0_DP System potential energy real(kind=DP), public :: te = 0.0_DP System total energy real(kind=DP), public :: oblpot = 0.0_DP System potential energy due to oblateness of the central body real(kind=DP), public, dimension(NDIM) :: Lorbit = 0.0_DP System orbital angular momentum vector real(kind=DP), public, dimension(NDIM) :: Lspin = 0.0_DP System spin angular momentum vector real(kind=DP), public, dimension(NDIM) :: Ltot = 0.0_DP System angular momentum vector logical, public :: lbeg True if this is the beginning of a step. This is used so that test particle steps can be calculated \n    separately from massive bodies.  Massive body variables are saved at half steps, and passed to \n    the test particles Type-Bound Procedures procedure(abstract_step_system), public :: step Each integrator will have its own version of the step procedure, public :: discard => discard_system Perform a discard step on the system procedure, public :: conservation_report => io_conservation_report Compute energy and momentum and print out the change with time procedure, public :: dump => io_dump_system Dump the state of the system to a file procedure, public :: get_old_t_final => io_get_old_t_final_system Validates the dump file to check whether the dump file initial conditions duplicate the last frame of the binary output. procedure, public :: read_frame => io_read_frame_system Read in a frame of input data from file procedure, public :: read_particle_info => io_read_particle_info_system Read in particle metadata from file procedure, public :: write_discard => io_write_discard Write out information about discarded test particles procedure, public :: write_frame => io_write_frame_system Append a frame of output data to file procedure, public :: write_hdr_bin => io_write_hdr_system Write a header for an output frame in Fortran binary format procedure, public :: write_hdr_netcdf => netcdf_write_hdr_system Write a header for an output frame in NetCDF format procedure, public :: obl_pot => obl_pot_system Compute the contribution to the total gravitational potential due solely to the oblateness of the central body procedure, public :: initialize => setup_initialize_system Initialize the system from input files procedure, public :: init_particle_info => setup_initialize_particle_info_system Initialize the system from input files procedure, public :: step_spin => tides_step_spin_system Steps the spins of the massive & central bodies due to tides. procedure, public :: set_msys => util_set_msys Sets the value of msys from the masses of system bodies. procedure, public :: get_energy_and_momentum => util_get_energy_momentum_system Calculates the total system energy and momentum procedure, public :: rescale => util_rescale_system Rescales the system into a new set of units procedure, public :: validate_ids => util_valid_id_system Validate the numerical ids passed to the system and save the maximum value generic, public :: write_hdr => write_hdr_bin, write_hdr_netcdf Generic method call for writing headers type, public :: swiftest_encounter Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: nenc Total number of encounters logical, public, dimension(:), allocatable :: lvdotr relative vdotr flag integer(kind=I4B), public, dimension(:), allocatable :: status status of the interaction integer(kind=I8B), public, dimension(:), allocatable :: kidx index value of the encounter from the master k_plpl encounter list integer(kind=I4B), public, dimension(:), allocatable :: index1 position of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: index2 position of the second body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: id1 id of the first body in the encounter integer(kind=I4B), public, dimension(:), allocatable :: id2 id of the second body in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x1 the position of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: x2 the position of body 2 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v1 the velocity of body 1 in the encounter real(kind=DP), public, dimension(:,:), allocatable :: v2 the velocity of body 2 in the encounter real(kind=DP), public, dimension(:), allocatable :: t Time of encounter Type-Bound Procedures procedure, public :: setup => setup_encounter A constructor that sets the number of encounters and allocates and initializes all arrays procedure, public :: append => util_append_encounter Appends elements from one structure to another procedure, public :: copy => util_copy_encounter Copies elements from the source encounter list into self. procedure, public :: spill => util_spill_encounter \"Spills\" bodies from one object to another depending on the results of a mask (uses the PACK intrinsic) procedure, public :: resize => util_resize_encounter Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small. procedure, public :: write => io_write_encounter Write close encounter data to output binary file","tags":"","loc":"module/swiftest_classes.html"},{"title":"lambda_function – swiftest","text":"Defines a class that can enable objects that behave like lambda functions. To use this class, define a type of either lambda_obj or lambda_obj_err, or extend the lambda_obj class as necessary, such that an interface that matches the function you wish to lambdafy.\n Once defined, the lambda object can evaluate itself by calling the type-bound procedure eval. e.g. f%eval(x) (or f%eval(x, lerr), f%eval(x, [argument list], etc)) Example - Defining a lambda function f(x,rval,ival) where rval and ival are a real and integer argument, respectively. This implementation uses an abstract interface, though this is not\n strictly necessary unless you want to bind more than one function with the same interface. module lambda_new \n    use swiftest ! This will bring in the lambda_function module\n    ! Define types in a module type , extends ( lambda_obj ) :: lambda_obj_ri_args procedure ( abstract_lambda_ri_args ), pointer , nopass :: lambdaptr_ri_args => null () real ( DP ) :: rval !! Real parameter integer ( I4B ) :: ival !! Integer paramete contains generic :: init => lambda_ri_args_init procedure :: eval => lambda_ri_args_eval procedure , nopass :: lambda_ri_args_init final :: lambda_ri_args_destroy end type interface lambda_obj module procedure lambda_ri_args_init end interface abstract interface function abstract_lambda_ri_args ( x , rval , ival ) result ( y ) ! Template for the lambda function import DP , I4B real ( DP ), dimension (:), intent ( in ) :: x !! Dependent variable real ( DP ), intent ( in ) :: rval !! Real parameter integer ( I4B ), intent ( in ) :: ival !! Integer parameter real ( DP ) :: y !! Real result end function end interface contains\n    type(lambda_obj_ri_args) function lambda_ri_args_init(lambda, rval, ival)\n       !! Initializes the lambda function parameters (can be used as a structure constructor)\n       implicit none\n       procedure(abstract_lambda_ri_args)  :: lambda !! The lambda function that will be passed\n       real(DP),     intent(in)            :: rval     !! Real parameter\n       integer(I4B), intent(in)            :: ival     !! Integer parameter ! Assign the procedure passed to this function to the procedure pointer lambda_ri_args_init % lambdaptr_ri_args => lambda ! Assign the argument values lambda_ri_args_init % rval = rval lambda_ri_args_init % ival = ival return end function lambda_ri_args_init function lambda_ri_args_eval ( self , x ) result ( y ) !! Defines the evaluation method , allowing the lambda function to be called with a single argument implicit none class ( lambda_obj_ri_args ), intent ( inout ) :: self real ( DP ), dimension (:), intent ( in ) :: x real ( DP ) :: y if ( associated ( self % lambdaptr_ri_args )) then y = self % lambdaptr_ri_args ( x , self % rval , self % ival ) self % lastval = y if ( allocated ( self % lastarg )) deallocate ( self % lastarg ) allocate ( self % lastarg , source = x ) else error stop \"Lambda function was not initialized\" end if end function lambda_ri_args_eval subroutine lambda_ri_args_destroy ( self ) !! Finalizer method . Use this as a template for cleaning up the object upon destruction , such as nullifying pointers implicit none type ( lambda_obj_ri_args ) :: self if ( associated ( self % lambdaptr_ri_args )) nullify ( self % lambdaptr_ri_args ) end subroutine lambda_ri_args_destroy function example_function ( x , rval , ival ) result ( y ) ! This is the actual function you are going to use as the lambda function . Its interface must match the abstract interface previously defined implicit none ! Arguments real ( DP ), dimension (:), intent ( in ) :: x real ( DP ), intent ( in ) :: rval integer ( I4B ), intent ( in ) :: ival ! Result real ( DP ) :: y ! Internals integer ( I4B ) :: i , n n = size ( x ) y = 42 . _DP * ival do i = 1 , n y = y + x ( i ) ** 2 end do return end function example_function end module lambda_new program usage\n    use swiftest\n    use lambda_new\n    implicit none\n    type(lambda_obj_ri_args) :: f\n    real(DP) :: sigma_par\n    integer(I4B) :: iwonky, i,j\n    real(DP), dimension(12) :: xarr sigma_par = 3 . 14 _DP iwonky = 13 f = lambda_obj ( example_function , sigma_par , iwonky ) do i = 1 , 10 xarr (:) = [( j * 0 . 25 _DP / i , j = 1 , 12 )] write ( * , * ) i , f % eval ( xarr ) end do end program usage Uses swiftest_globals module~~lambda_function~~UsesGraph module~lambda_function lambda_function module~swiftest_globals swiftest_globals module~lambda_function->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~lambda_function~~UsedByGraph module~lambda_function lambda_function module~swiftest swiftest module~swiftest->module~lambda_function module~s_fraggle_placeholder s_fraggle_placeholder module~s_fraggle_placeholder->module~swiftest module~s_gr s_gr module~s_gr->module~swiftest module~s_util_valid s_util_valid module~s_util_valid->module~swiftest module~s_symba_collision s_symba_collision module~s_symba_collision->module~swiftest module~s_obl s_obl module~s_obl->module~swiftest module~s_fraggle_setup s_fraggle_setup module~s_fraggle_setup->module~swiftest module~s_util_coord s_util_coord module~s_util_coord->module~swiftest module~s_symba_encounter_check s_symba_encounter_check module~s_symba_encounter_check->module~swiftest module~s_whm_coord s_whm_coord module~s_whm_coord->module~swiftest module~s_util_rescale s_util_rescale module~s_util_rescale->module~swiftest module~s_util_get_energy_momentum s_util_get_energy_momentum module~s_util_get_energy_momentum->module~swiftest module~s_rmvs_step s_rmvs_step module~s_rmvs_step->module~swiftest module~s_util_index s_util_index module~s_util_index->module~swiftest proc~ge_wpp ge_wpp proc~ge_wpp->module~swiftest module~s_operator_cross s_operator_cross module~s_operator_cross->module~swiftest module~s_fraggle_set s_fraggle_set module~s_fraggle_set->module~swiftest module~s_fraggle_io s_fraggle_io module~s_fraggle_io->module~swiftest module~s_rmvs_kick s_rmvs_kick module~s_rmvs_kick->module~swiftest module~s_util_set s_util_set module~s_util_set->module~swiftest module~s_rmvs_io s_rmvs_io module~s_rmvs_io->module~swiftest module~s_util_version s_util_version module~s_util_version->module~swiftest module~s_tides_step_spin s_tides_step_spin module~s_tides_step_spin->module~swiftest proc~solve_wbs solve_wbs proc~solve_wbs->module~swiftest module~s_orbel s_orbel module~s_orbel->module~swiftest module~s_whm_gr s_whm_gr module~s_whm_gr->module~swiftest module~s_rmvs_chk s_rmvs_chk module~s_rmvs_chk->module~swiftest module~s_fraggle_regime s_fraggle_regime module~s_fraggle_regime->module~swiftest module~s_util_exit s_util_exit module~s_util_exit->module~swiftest module~s_netcdf s_netcdf module~s_netcdf->module~swiftest module~s_rmvs_discard s_rmvs_discard module~s_rmvs_discard->module~swiftest module~s_util_peri s_util_peri module~s_util_peri->module~swiftest module~s_helio_drift s_helio_drift module~s_helio_drift->module~swiftest module~s_setup s_setup module~s_setup->module~swiftest module~s_helio_kick s_helio_kick module~s_helio_kick->module~swiftest module~s_util_append s_util_append module~s_util_append->module~swiftest module~s_rmvs_util s_rmvs_util module~s_rmvs_util->module~swiftest program~swiftest_driver swiftest_driver program~swiftest_driver->module~swiftest module~s_symba_step s_symba_step module~s_symba_step->module~swiftest module~s_symba_util s_symba_util module~s_symba_util->module~swiftest module~s_util_copy s_util_copy module~s_util_copy->module~swiftest module~s_discard s_discard module~s_discard->module~swiftest module~s_util_sort s_util_sort module~s_util_sort->module~swiftest module~s_whm_setup s_whm_setup module~s_whm_setup->module~swiftest module~s_util_resize s_util_resize module~s_util_resize->module~swiftest module~s_helio_gr s_helio_gr module~s_helio_gr->module~swiftest module~orbel orbel module~orbel->module~swiftest module~s_whm_util s_whm_util module~s_whm_util->module~swiftest module~s_rmvs_setup s_rmvs_setup module~s_rmvs_setup->module~swiftest module~s_util_spill s_util_spill module~s_util_spill->module~swiftest module~s_util_minimize_bfgs s_util_minimize_bfgs module~s_util_minimize_bfgs->module~swiftest module~s_user_kick_getacch s_user_kick_getacch module~s_user_kick_getacch->module~swiftest module~s_whm_kick s_whm_kick module~s_whm_kick->module~swiftest module~s_symba_discard s_symba_discard module~s_symba_discard->module~swiftest module~s_symba_drift s_symba_drift module~s_symba_drift->module~swiftest module~whm_drift whm_drift module~whm_drift->module~swiftest module~s_tides_kick_getacch s_tides_kick_getacch module~s_tides_kick_getacch->module~swiftest module~s_util_fill s_util_fill module~s_util_fill->module~swiftest module~s_io s_io module~s_io->module~swiftest module~s_helio_setup s_helio_setup module~s_helio_setup->module~swiftest module~s_symba_kick s_symba_kick module~s_symba_kick->module~swiftest module~s_fraggle_util s_fraggle_util module~s_fraggle_util->module~swiftest module~s_util_solve s_util_solve module~s_util_solve->module~swiftest module~s_helio_step s_helio_step module~s_helio_step->module~swiftest module~s_whm_step s_whm_step module~s_whm_step->module~swiftest module~s_symba_setup s_symba_setup module~s_symba_setup->module~swiftest module~s_fraggle_generate s_fraggle_generate module~s_fraggle_generate->module~swiftest module~s_symba_io s_symba_io module~s_symba_io->module~swiftest module~s_kick s_kick module~s_kick->module~swiftest module~drift_implementation drift_implementation module~drift_implementation->module~swiftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces lambda_obj Abstract Interfaces lambda0 lambda0err lambda0tvar Derived Types lambda_obj lambda_obj_err lambda_obj_tvar Functions lambda_init_0 lambda_init_0_err lambda_init_tvar lambda_eval_0 lambda_eval_0_err lambda_eval_tvar Subroutines lambda_destroy Interfaces public interface lambda_obj public function lambda_init_0 (lambda) Arguments Type Intent Optional Attributes Name procedure( lambda0 ) :: lambda Return Value type( lambda_obj ) public function lambda_init_0_err (lambda, lerr) Arguments Type Intent Optional Attributes Name procedure( lambda0err ) :: lambda logical, intent(in) :: lerr Return Value type( lambda_obj_err ) public function lambda_init_tvar (lambda, t) Arguments Type Intent Optional Attributes Name procedure( lambda0tvar ) :: lambda real(kind=DP), intent(in) :: t Return Value type( lambda_obj_tvar ) Abstract Interfaces abstract interface public function lambda0(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: x Return Value real(kind=DP) abstract interface public function lambda0err(x, lerr) result(y) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: x logical, intent(out) :: lerr Return Value real(kind=DP) abstract interface public function lambda0tvar(x, t) result(y) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in) :: t Return Value real(kind=DP),\n  dimension(:), allocatable Derived Types type, public :: lambda_obj Base class for an lambda function object. This object takes no additional arguments other than the dependent variable x, an array of real numbers Components Type Visibility Attributes Name Initial procedure( lambda0 ), public, pointer, nopass :: lambdaptr => null() real(kind=DP), public :: lastval real(kind=DP), public, dimension(:), allocatable :: lastarg Constructor public  function lambda_init_0 (lambda) public  function lambda_init_0_err (lambda, lerr) public  function lambda_init_tvar (lambda, t) Finalizations Procedures final :: lambda_destroy","tags":"","loc":"module/lambda_function.html"},{"title":"s_kick – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_kick~~UsesGraph module~s_kick s_kick module~swiftest swiftest module~s_kick->module~swiftest module~swiftest_classes swiftest_classes module~s_kick->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines kick_getacch_int_pl kick_getacch_int_tp kick_getacch_int_all_pl kick_getacch_int_all_tp kick_getacch_int_one_pl kick_getacch_int_one_tp Module Subroutines module subroutine kick_getacch_int_pl (self) Interface → Author David A. Minton Compute direct cross (third) term heliocentric accelerations of massive bodies Read more… Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object module subroutine kick_getacch_int_tp (self, GMpl, xhp, npl) Interface → Author David A. Minton Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object real(kind=DP), intent(in), dimension(:) :: GMpl Massive body masses real(kind=DP), intent(in), dimension(:,:) :: xhp Massive body position vectors integer(kind=I4B), intent(in) :: npl Number of active massive bodies module subroutine kick_getacch_int_all_pl (npl, nplpl, k_plpl, x, Gmass, radius, acc) Interface → Author David A. Minton Compute direct cross (third) term heliocentric accelerations for massive bodies, with parallelization Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl Number of massive bodies integer(kind=I8B), intent(in) :: nplpl Number of massive body interactions to compute integer(kind=I4B), intent(in), dimension(:,:) :: k_plpl Array of interaction pair indices (flattened upper triangular matrix) real(kind=DP), intent(in), dimension(:,:) :: x Position vector array real(kind=DP), intent(in), dimension(:) :: Gmass Array of massive body G*mass real(kind=DP), intent(in), dimension(:) :: radius Array of massive body radii real(kind=DP), intent(inout), dimension(:,:) :: acc Acceleration vector array module subroutine kick_getacch_int_all_tp (ntp, npl, xtp, xpl, GMpl, lmask, acc) Interface → Author David A. Minton Compute direct cross (third) term heliocentric accelerations of test particles by massive bodies with parallelisim Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntp Number of test particles integer(kind=I4B), intent(in) :: npl Number of massive bodies real(kind=DP), intent(in), dimension(:,:) :: xtp Test particle position vector array real(kind=DP), intent(in), dimension(:,:) :: xpl Massive body particle position vector array real(kind=DP), intent(in), dimension(:) :: GMpl Array of massive body G*mass logical, intent(in), dimension(:) :: lmask Logical mask indicating which test particles should be computed real(kind=DP), intent(inout), dimension(:,:) :: acc Acceleration vector array pure module subroutine kick_getacch_int_one_pl (rji2, xr, yr, zr, Gmi, Gmj, axi, ayi, azi, axj, ayj, azj) Interface → Author David A. Minton Compute direct cross (third) term heliocentric accelerations for a single pair of massive bodies Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: rji2 Square of distance between the two bodies real(kind=DP), intent(in) :: xr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: yr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: zr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: Gmi G*mass of body i real(kind=DP), intent(in) :: Gmj G*mass of body j real(kind=DP), intent(inout) :: axi Acceleration vector components of body i real(kind=DP), intent(inout) :: ayi Acceleration vector components of body i real(kind=DP), intent(inout) :: azi Acceleration vector components of body i real(kind=DP), intent(inout) :: axj Acceleration vector components of body j real(kind=DP), intent(inout) :: ayj Acceleration vector components of body j real(kind=DP), intent(inout) :: azj Acceleration vector components of body j pure module subroutine kick_getacch_int_one_tp (rji2, xr, yr, zr, Gmpl, ax, ay, az) Interface → Author David A. Minton Compute direct cross (third) term heliocentric accelerations of a single test particle massive body pair. Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: rji2 Square of distance between the test particle and massive body real(kind=DP), intent(in) :: xr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: yr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: zr Distances between the two bodies in x, y, and z directions real(kind=DP), intent(in) :: Gmpl G*mass of massive body real(kind=DP), intent(inout) :: ax Acceleration vector components of test particle real(kind=DP), intent(inout) :: ay Acceleration vector components of test particle real(kind=DP), intent(inout) :: az Acceleration vector components of test particle","tags":"","loc":"module/s_kick.html"},{"title":"s_tides_kick_getacch – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_tides_kick_getacch~~UsesGraph module~s_tides_kick_getacch s_tides_kick_getacch module~swiftest swiftest module~s_tides_kick_getacch->module~swiftest module~swiftest_classes swiftest_classes module~s_tides_kick_getacch->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines tides_kick_getacch_pl Module Subroutines module subroutine tides_kick_getacch_pl (self, system) Interface → Author Jennifer L.L. Pouplin, Carlisle A. wishard, and David A. Minton Calculated tidal torques from central body to any planet and from any planet to central body\n planet - planet interactions are considered negligable.\n This is a constant time lag model. Read more… Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object","tags":"","loc":"module/s_tides_kick_getacch.html"},{"title":"s_tides_step_spin – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_tides_step_spin~~UsesGraph module~s_tides_step_spin s_tides_step_spin module~swiftest swiftest module~s_tides_step_spin->module~swiftest module~swiftest_classes swiftest_classes module~s_tides_step_spin->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces lambda_obj Abstract Interfaces tidederiv Derived Types tides_derivs_func Functions tides_spin_derivs tides_derivs_eval tides_derivs_init Module Subroutines tides_step_spin_system Interfaces interface lambda_obj function tides_derivs_init (lambda, dt, xbeg, xend) result(f) Arguments Type Intent Optional Attributes Name procedure( tidederiv ) :: lambda real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), dimension(:,:) :: xbeg real(kind=DP), intent(in), dimension(:,:) :: xend Return Value type( tides_derivs_func ) Abstract Interfaces abstract interface function tidederiv(x, t, dt, xbeg, xend) result(y) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in) :: t real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), dimension(:,:) :: xbeg real(kind=DP), intent(in), dimension(:,:) :: xend Return Value real(kind=DP),\n  dimension(:), allocatable Derived Types type, extends(lambda_obj_tvar) :: tides_derivs_func Base class for an lambda function object. This object takes no additional arguments other than the dependent variable x, an array of real numbers Components Type Visibility Attributes Name Initial procedure( tidederiv ), public, pointer, nopass :: lambdaptr_tides_deriv real(kind=DP), public, dimension(:,:), allocatable :: xbeg real(kind=DP), public, dimension(:,:), allocatable :: xend real(kind=DP), public :: dt Type-Bound Procedures generic, public :: init => tides_derivs_init procedure, public :: evalt => tides_derivs_eval procedure, public, nopass :: tides_derivs_init Functions function tides_spin_derivs (rot_pl_cb, t, dt, xbeg, xend) result(drot) Need to add more arguments so we can pull in mass, radius, Ip, J2, etc...\n author: Jennifer L.L. Pouplin and David A. Minton Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: rot_pl_cb Array of rotations. The last element is the central body, and all others are massive bodies real(kind=DP), intent(in) :: t Current time, which is used to interpolate the massive body positions real(kind=DP), intent(in) :: dt Total step size real(kind=DP), intent(in), dimension(:,:) :: xbeg real(kind=DP), intent(in), dimension(:,:) :: xend Return Value real(kind=DP),\n  dimension(:,:), allocatable function tides_derivs_eval (self, x, t) result(y) Arguments Type Intent Optional Attributes Name class( tides_derivs_func ), intent(inout) :: self real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in) :: t Return Value real(kind=DP),\n  dimension(:), allocatable function tides_derivs_init (lambda, dt, xbeg, xend) result(f) Arguments Type Intent Optional Attributes Name procedure( tidederiv ) :: lambda real(kind=DP), intent(in) :: dt real(kind=DP), intent(in), dimension(:,:) :: xbeg real(kind=DP), intent(in), dimension(:,:) :: xend Return Value type( tides_derivs_func ) Module Subroutines module subroutine tides_step_spin_system (self, param, t, dt) Interface → Author Jennifer L.L. Pouplin and David A. Minton Integrates the spin equations for central and massive bodies of the system subjected to tides. Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"module/s_tides_step_spin.html"},{"title":"s_obl – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_obl~~UsesGraph module~s_obl s_obl module~swiftest swiftest module~s_obl->module~swiftest module~swiftest_classes swiftest_classes module~s_obl->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions obl_pot_one Module Subroutines obl_acc_body obl_acc_pl obl_acc_tp obl_pot_system Functions elemental function obl_pot_one (npl, GMcb, GMpl, j2rp2, j4rp4, zh, irh) result(oblpot) Author David A. Minton Compute the contribution to the total gravitational potential due solely to the oblateness of the central body from a single massive body\n    Returned value does not include monopole term or terms higher than J4 Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl Number of massive bodies real(kind=DP), intent(in) :: GMcb G*mass of the central body real(kind=DP), intent(in) :: GMpl G*mass of the massive body real(kind=DP), intent(in) :: j2rp2 J_2 / R**2 of the central body real(kind=DP), intent(in) :: j4rp4 J_2 / R**4 of the central body real(kind=DP), intent(in) :: zh z-component of the heliocentric distance vector of the massive body real(kind=DP), intent(in) :: irh Inverse of the heliocentric distance magnitude of the massive body Return Value real(kind=DP) Gravitational potential Module Subroutines module subroutine obl_acc_body (self, system) Interface → Author David A. Minton Compute the barycentric accelerations of bodies due to the oblateness of the central body\n      Returned values do not include monopole term or terms higher than J4 Read more… Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object module subroutine obl_acc_pl (self, system) Interface → Author David A. Minton Compute the barycentric accelerations of massive bodies due to the oblateness of the central body Read more… Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object module subroutine obl_acc_tp (self, system) Interface → Author David A. Minton Compute the barycentric accelerations of massive bodies due to the oblateness of the central body Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object module subroutine obl_pot_system (self) Interface → Author David A. Minton Compute the contribution to the total gravitational potential due solely to the oblateness of the central body\n    Returned value does not include monopole term or terms higher than J4 Read more… Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object","tags":"","loc":"module/s_obl.html"},{"title":"s_orbel – swiftest","text":"Code converted to Modern Fortran by David A. Minton\n Date: 2020-06-29 ORBEL_SCHGET.F PURPOSE : Given an angle , efficiently compute sinh and cosh . Input : angle ==> angle in radians ( real scalar ) Output : shx ==> sinh ( angle ) ( real scalar ) chx ==> cosh ( angle ) ( real scalar ) ALGORITHM : Obvious from the code REMARKS : Based on the routine SCGET for sine 's and cosine' s . We use the sqrt rather than cosh ( it 's faster) BE SURE THE ANGLE IS IN RADIANS AND IT CAN' T BE LARGER THAN 300 OR OVERFLOWS WILL OCCUR ! AUTHOR : M . Duncan . DATE WRITTEN : May 6 , 1992 . REVISIONS : Code converted to Modern Fortran by David A. Minton\n Date: 2020-06-29 !                    ORBEL_FLON.F PURPOSE : Solves Kepler ' s eqn . for hyperbola using hybrid approach . Input : e ==> eccentricity anomaly . ( real scalar ) capn ==> hyperbola mean anomaly . ( real scalar ) Returns : orbel_flon ==> eccentric anomaly . ( real scalar ) ALGORITHM : Uses power series for N in terms of F and Newton , s method REMARKS : ONLY GOOD FOR LOW VALUES OF N ( N < 0 . 636 * e - 0 . 6 ) AUTHOR : M . Duncan DATE WRITTEN : May 26 , 1992 . REVISIONS : Code converted to Modern Fortran by David A. Minton\n Date: 2020-06-29 ORBEL_FGET.F PURPOSE : Solves Kepler 's eqn. for hyperbola using hybrid approach. Input: e ==> eccentricity anomaly. (real scalar) capn ==> hyperbola mean anomaly. (real scalar) Returns: orbel_fget ==>  eccentric anomaly. (real scalar) ALGORITHM: Based on pp. 70-72 of Fitzpatrick' s book \"Principles of Cel. Mech. \" . Quartic convergence from Danby ' s book . REMARKS : AUTHOR : M . Duncan DATE WRITTEN : May 11 , 1992 . REVISIONS : 2 / 26 / 93 hfl Code converted to Modern Fortran by David A. Minton\n Date: 2020-06-29 ORBEL_ZGET.F PURPOSE : Solves the equivalent of Kepler 's eqn. for a parabola given Q (Fitz. notation.) Input: q ==>  parabola mean anomaly. (real scalar) Returns: orbel_zget ==>  eccentric anomaly. (real scalar) ALGORITHM: p. 70-72 of Fitzpatrick' s book \"Princ. of Cel. Mech.\" REMARKS : For a parabola we can solve analytically . AUTHOR : M . Duncan DATE WRITTEN : May 11 , 1992 . REVISIONS : May 27 - corrected it for negative Q and use power series for small Q . Code converted to Modern Fortran by David A. Minton\n Date: 2020-06-29 ORBEL_ESOLMD.F PURPOSE : Solves Kepler ' s eqn . e is ecc . m is mean anomaly . Input : e ==> eccentricity anomaly . ( real scalar ) m ==> mean anomaly . ( real scalar ) Returns : orbel_esolmd ==> eccentric anomaly . ( real scalar ) ALGORITHM : Some sort of quartic convergence from Wisdom . REMARKS : ONLY GOOD FOR SMALL ECCENTRICITY SINCE IT ONLY ITERATES ONCE . ( GOOD FOR PLANET CALCS .) ALSO DOES NOT PUT M OR E BETWEEN 0 . AND 2 * PI INCLUDES : needs SCGET . F AUTHOR : M . Duncan DATE WRITTEN : May 7 , 1992 . REVISIONS : 2 / 26 / 93 hfl Code converted to Modern Fortran by David A. Minton\n Date: 2020-06-29 ORBEL_EHIE.F PURPOSE : Solves Kepler 's eqn.   e is ecc.   m is mean anomaly. Input: e ==> eccentricity anomaly. (real scalar) m ==> mean anomaly. (real scalar) Returns: orbel_ehybrid ==>  eccentric anomaly. (real scalar) ALGORITHM: Use Danby' s quartic for 3 iterations . Eqn . is f ( x ) = x - e * sin ( x + M ). Note that E = x + M . First guess is very good for e near 1 . Need to first get M between 0 . and PI and use symmetry to return right answer if M between PI and 2PI\n     REMARKS: Modifies M so that both E and M are in range (0,TWOPI)\n     AUTHOR: M. Duncan\n     DATE WRITTEN: May 25,1992.\n     REVISIONS: Code converted to Modern Fortran by David A. Minton\n Date: 2020-06-29 ORBEL_EGET.F PURPOSE : Solves Kepler ' s eqn . e is ecc . m is mean anomaly . Input : e ==> eccentricity anomaly . ( real scalar ) m ==> mean anomaly . ( real scalar ) Returns : orbel_eget ==> eccentric anomaly . ( real scalar ) ALGORITHM : Quartic convergence from Danby REMARKS : For results very near roundoff , give it M between 0 and 2 * pi . One can condition M before calling EGET by calling my double precision function MOD2PI ( M ). This is not done within the routine to speed it up and because it works fine even for large M . AUTHOR : M . Duncan DATE WRITTEN : May 7 , 1992. REVISIONS : May 21 , 1992. Now have it go through EXACTLY two iterations with the premise that it will only be called if we have an ellipse with e between 0.15 and 0.8 Code converted to Modern Fortran by David A. Minton\n Date: 2020-06-29 ORBEL_EHYBRID.F PURPOSE : Solves Kepler ' s eqn . e is ecc . m is mean anomaly . Input : e ==> eccentricity anomaly . ( real scalar ) m ==> mean anomaly . ( real scalar ) Returns : orbel_ehybrid ==> eccentric anomaly . ( real scalar ) ALGORITHM : For e < 0 . 18 uses fast routine ESOLMD For larger e but less than 0 . 8 , uses EGET For e > 0 . 8 uses EHIE REMARKS : Only EHIE brings M and E into range ( 0 , TWOPI ) AUTHOR : M . Duncan DATE WRITTEN : May 25 , 1992 . REVISIONS : 2 / 26 / 93 hfl Code converted to Modern Fortran by David A. Minton\n Date: 2020-06-29 ORBEL_FHYBRID.F PURPOSE : Solves Kepler ' s eqn . for hyperbola using hybrid approach . Input : e ==> eccentricity anomaly . ( real scalar ) n ==> hyperbola mean anomaly . ( real scalar ) Returns : orbel_fhybrid ==> eccentric anomaly . ( real scalar ) ALGORITHM : For abs ( N ) < 0 . 636 * ecc - 0 . 6 , use FLON For larger N , uses FGET REMARKS : AUTHOR : M . Duncan DATE WRITTEN : May 26 , 1992 . REVISIONS :: REVISIONS : 2 / 26 / 93 hfl Uses swiftest Ancestors: swiftest_classes module~~s_orbel~~UsesGraph module~s_orbel s_orbel module~swiftest swiftest module~s_orbel->module~swiftest module~swiftest_classes swiftest_classes module~s_orbel->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions orbel_flon orbel_fget orbel_zget orbel_esolmd orbel_ehie orbel_eget orbel_ehybrid orbel_fhybrid Subroutines orbel_el2xv orbel_schget Module Subroutines orbel_el2xv_vec orbel_scget orbel_xv2aeq orbel_xv2aqt orbel_xv2el_vec orbel_xv2el Functions pure function orbel_flon (e, icapn) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: icapn Return Value real(kind=DP) pure function orbel_fget (e, capn) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: capn Return Value real(kind=DP) pure function orbel_zget (iq) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: iq Return Value real(kind=DP) pure function orbel_esolmd (e, m) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: m Return Value real(kind=DP) pure function orbel_ehie (e, im) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: im Return Value real(kind=DP) pure function orbel_eget (e, m) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: m Return Value real(kind=DP) pure function orbel_ehybrid (e, m) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: m Return Value real(kind=DP) pure function orbel_fhybrid (e, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: e real(kind=DP), intent(in) :: n Return Value real(kind=DP) Subroutines pure subroutine orbel_el2xv (mu, a, ie, inc, capom, omega, capm, x, v) Author David A. Minton Compute osculating orbital elements from relative C)rtesian position and velocity\n  All angular measures are returned in radians\n      If inclination < TINY, longitude of the ascending node is arbitrarily set to 0 Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: a real(kind=DP), intent(in) :: ie real(kind=DP), intent(in) :: inc real(kind=DP), intent(in) :: capom real(kind=DP), intent(in) :: omega real(kind=DP), intent(in) :: capm real(kind=DP), intent(out), dimension(:) :: x real(kind=DP), intent(out), dimension(:) :: v pure subroutine orbel_schget (angle, shx, chx) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: angle real(kind=DP), intent(out) :: shx real(kind=DP), intent(out) :: chx Module Subroutines module subroutine orbel_el2xv_vec (self, cb) Interface → Author David A. Minton A wrapper method that converts all of the orbital element vectors into cartesian position and velocity vectors for a Swiftest body object.\n This method deallocates all of the orbital elements after it is finished. Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body objec pure module subroutine orbel_scget (angle, sx, cx) Interface → Author David A. Minton Efficiently compute the sine and cosine of an input angle\n      Input angle must be in radians Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: angle real(kind=DP), intent(out) :: sx real(kind=DP), intent(out) :: cx pure module subroutine orbel_xv2aeq (mu, x, v, a, e, q) Interface → Author David A. Minton Compute semimajor axis, eccentricity, and pericentric distance from relative Cartesian position and velocity Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu real(kind=DP), intent(in), dimension(:) :: x real(kind=DP), intent(in), dimension(:) :: v real(kind=DP), intent(out) :: a real(kind=DP), intent(out) :: e real(kind=DP), intent(out) :: q pure module subroutine orbel_xv2aqt (mu, x, v, a, q, capm, tperi) Interface → Author David A. Minton Compute semimajor axis, pericentric distance, mean anomaly, and time to nearest pericenter passage from\n relative Cartesian position and velocity\n      tperi > 0 means nearest pericenter passage is in the future\n      tperi < 0 means nearest pericenter passage is in the past Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(out) :: a semimajor axis real(kind=DP), intent(out) :: q periapsis real(kind=DP), intent(out) :: capm mean anomaly real(kind=DP), intent(out) :: tperi time of pericenter passage module subroutine orbel_xv2el_vec (self, cb) Interface → Author David A. Minton A wrapper method that converts all of the cartesian position and velocity vectors of a Swiftest body object to orbital elements. Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object pure module subroutine orbel_xv2el (mu, x, v, a, e, inc, capom, omega, capm) Interface → Author David A. Minton Compute osculating orbital elements from relative Cartesian position and velocity\n  All angular measures are returned in radians\n      If inclination < TINY, longitude of the ascending node is arbitrarily set to 0 Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(out) :: a semimajor axis real(kind=DP), intent(out) :: e eccentricity real(kind=DP), intent(out) :: inc inclination real(kind=DP), intent(out) :: capom longitude of ascending node real(kind=DP), intent(out) :: omega argument of periapsis real(kind=DP), intent(out) :: capm mean anomaly","tags":"","loc":"module/s_orbel.html"},{"title":"s_whm_coord – swiftest","text":"Uses swiftest Ancestors: whm_classes module~~s_whm_coord~~UsesGraph module~s_whm_coord s_whm_coord module~swiftest swiftest module~s_whm_coord->module~swiftest module~whm_classes whm_classes module~s_whm_coord->module~whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines whm_coord_h2j_pl whm_coord_j2h_pl whm_coord_vh2vj_pl Module Subroutines module subroutine whm_coord_h2j_pl (self, cb) Interface → Author David A. Minton Convert from heliocentric to Jacobi coordinates, massive bodies only Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree module subroutine whm_coord_j2h_pl (self, cb) Interface → Author David A. Minton Convert from Jacobi to heliocentric coordinates, massive bodies only. Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree module subroutine whm_coord_vh2vj_pl (self, cb) Interface → Author David A. Minton Convert from heliocentric to Jadcobi coordinates, massive body velocities only Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_cb ), intent(inout) :: cb Swiftest central body particle data structuree","tags":"","loc":"module/s_whm_coord.html"},{"title":"s_whm_gr – swiftest","text":"Uses swiftest Ancestors: whm_classes module~~s_whm_gr~~UsesGraph module~s_whm_gr s_whm_gr module~swiftest swiftest module~s_whm_gr->module~swiftest module~whm_classes whm_classes module~s_whm_gr->module~whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines whm_gr_kick_getacch_pl whm_gr_kick_getacch_tp whm_gr_p4_pl whm_gr_p4_tp Module Subroutines pure module subroutine whm_gr_kick_getacch_pl (self, param) Interface → Author David A. Minton Compute relativisitic accelerations of massive bodies\n    Based on Saha & Tremaine (1994) Eq. 28 Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters pure module subroutine whm_gr_kick_getacch_tp (self, param) Interface → Author David A. Minton Compute relativisitic accelerations of test particles\n    Based on Saha & Tremaine (1994) Eq. 28 Read more… Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters pure module subroutine whm_gr_p4_pl (self, param, dt) Interface → Author David A. Minton Position kick to massive bodies due to p**4 term in the post-Newtonian correction\n    Based on Saha & Tremaine (1994) Eq. 28 Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size pure module subroutine whm_gr_p4_tp (self, param, dt) Interface → Author David A. Minton Position kick to test particles due to p**4 term in the post-Newtonian correction\n    Based on Saha & Tremaine (1994) Eq. 28 Read more… Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size","tags":"","loc":"module/s_whm_gr.html"},{"title":"s_whm_step – swiftest","text":"Uses swiftest Ancestors: whm_classes module~~s_whm_step~~UsesGraph module~s_whm_step s_whm_step module~swiftest swiftest module~s_whm_step->module~swiftest module~whm_classes whm_classes module~s_whm_step->module~whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines whm_step_system whm_step_pl whm_step_tp Module Subroutines module subroutine whm_step_system (self, param, t, dt) Interface → Author David A. Minton Step massive bodies and and active test particles ahead in heliocentric coordinates Read more… Arguments Type Intent Optional Attributes Name class( whm_nbody_system ), intent(inout) :: self WHM nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current stepsize module subroutine whm_step_pl (self, system, param, t, dt) Interface → Author David A. Minton Step planets ahead using kick-drift-kick algorithm Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current stepsize module subroutine whm_step_tp (self, system, param, t, dt) Interface → Author David A. Minton Step active test particles ahead using kick-drift-kick algorithm Read more… Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"module/s_whm_step.html"},{"title":"whm_drift – swiftest","text":"Uses swiftest Ancestors: whm_classes module~~whm_drift~~UsesGraph module~whm_drift whm_drift module~swiftest swiftest module~whm_drift->module~swiftest module~whm_classes whm_classes module~whm_drift->module~whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines whm_drift_pl Module Subroutines module subroutine whm_drift_pl (self, system, param, dt) Interface → Author David A. Minton Loop through planets and call Danby drift routine Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system WHM nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"module/whm_drift.html"},{"title":"s_whm_kick – swiftest","text":"Uses swiftest Ancestors: whm_classes module~~s_whm_kick~~UsesGraph module~s_whm_kick s_whm_kick module~swiftest swiftest module~s_whm_kick->module~swiftest module~whm_classes whm_classes module~s_whm_kick->module~whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions whm_kick_getacch_ah0 Subroutines whm_kick_getacch_ah1 whm_kick_getacch_ah2 Module Subroutines whm_kick_getacch_pl whm_kick_getacch_tp whm_kick_vh_pl whm_kick_vh_tp Functions function whm_kick_getacch_ah0 (mu, xhp, n) result(ah0) Author David A. Minton Compute zeroth term heliocentric accelerations of planets Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: mu real(kind=DP), intent(in), dimension(:,:) :: xhp integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  dimension(NDIM) Subroutines pure subroutine whm_kick_getacch_ah1 (cb, pl) Author David A. Minton Compute first term heliocentric accelerations of planets Read more… Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: cb WHM central body object class( whm_pl ), intent(inout) :: pl WHM massive body object pure subroutine whm_kick_getacch_ah2 (cb, pl) Author David A. Minton Compute second term heliocentric accelerations of planets Read more… Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: cb Swiftest central body object class( whm_pl ), intent(inout) :: pl WHM massive body object Module Subroutines module subroutine whm_kick_getacch_pl (self, system, param, t, lbeg) Interface → Author David A. Minton Compute heliocentric accelerations of planets Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest central body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step module subroutine whm_kick_getacch_tp (self, system, param, t, lbeg) Interface → Author David A. Minton Compute heliocentric accelerations of test particles Read more… Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest central body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step module subroutine whm_kick_vh_pl (self, system, param, t, dt, lbeg) Interface → Author David A. Minton Kick heliocentric velocities of massive bodies Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. module subroutine whm_kick_vh_tp (self, system, param, t, dt, lbeg) Interface → Author David A. Minton Kick heliocentric velocities of test particles Read more… Arguments Type Intent Optional Attributes Name class( whm_tp ), intent(inout) :: self WHM massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not.","tags":"","loc":"module/s_whm_kick.html"},{"title":"s_whm_setup – swiftest","text":"Uses swiftest Ancestors: whm_classes module~~s_whm_setup~~UsesGraph module~s_whm_setup s_whm_setup module~swiftest swiftest module~s_whm_setup->module~swiftest module~whm_classes whm_classes module~s_whm_setup->module~whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines whm_setup_pl whm_util_set_mu_eta_pl whm_setup_initialize_system Module Subroutines module subroutine whm_setup_pl (self, n, param) Interface → Author David A. Minton Allocate WHM planet structure Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameter module subroutine whm_util_set_mu_eta_pl (self, cb) Interface → Author David A. Minton Sets the Jacobi mass value eta for all massive bodies Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM system object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object module subroutine whm_setup_initialize_system (self, param) Interface → Author David A. Minton Initialize a WHM nbody system from files Arguments Type Intent Optional Attributes Name class( whm_nbody_system ), intent(inout) :: self WHM nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters","tags":"","loc":"module/s_whm_setup.html"},{"title":"s_whm_util – swiftest","text":"Uses swiftest Ancestors: whm_classes module~~s_whm_util~~UsesGraph module~s_whm_util s_whm_util module~swiftest swiftest module~s_whm_util->module~swiftest module~whm_classes whm_classes module~s_whm_util->module~whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines whm_util_append_pl whm_util_fill_pl whm_util_resize_pl whm_util_set_ir3j whm_util_sort_pl whm_util_sort_rearrange_pl whm_util_spill_pl Module Subroutines module subroutine whm_util_append_pl (self, source, lsource_mask) Interface → Author David A. Minton Append components from one massive body object to another. \n This method will automatically resize the destination body if it is too small\n Arguments Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to module subroutine whm_util_fill_pl (self, inserts, lfill_list) Interface → Author David A. Minton Insert new WHM test particle structure into an old one. \n This is the inverse of a fill operation. Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(in) :: inserts inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps module subroutine whm_util_resize_pl (self, nnew) Interface → Author David A. Minton Checks the current size of a massive body against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object integer(kind=I4B), intent(in) :: nnew New size neded module subroutine whm_util_set_ir3j (self) Interface → Author David A. Minton Sets the inverse Jacobi and heliocentric radii cubed (1/rj 3 and 1/rh 3) Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object module subroutine whm_util_sort_pl (self, sortby, ascending) Interface → Author David A. Minton Sort a WHM massive body object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order module subroutine whm_util_sort_rearrange_pl (self, ind) Interface → Author David A. Minton Rearrange WHM massive body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) module subroutine whm_util_spill_pl (self, discards, lspill_list, ldestructive) Interface → Author David A. Minton Move spilled (discarded) WHM test particle structure from active list to discard list Read more… Arguments Type Intent Optional Attributes Name class( whm_pl ), intent(inout) :: self WHM massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"module/s_whm_util.html"},{"title":"s_operator_cross – swiftest","text":"Contains implementations for the .cross. operator for all defined integer and real types\n Single vector implementations: C(1:3)   = A(1:3)   .cross. B(1:3) \n Vector list implementations:   C(1:3, :) = A(1:3, :) .cross. B(1:3, :) Uses swiftest Ancestors: swiftest_operators module~~s_operator_cross~~UsesGraph module~s_operator_cross s_operator_cross module~swiftest swiftest module~s_operator_cross->module~swiftest module~swiftest_operators swiftest_operators module~s_operator_cross->module~swiftest_operators module~swiftest->module~swiftest_operators module~whm_classes whm_classes module~swiftest->module~whm_classes module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Functions operator_cross_sp operator_cross_dp operator_cross_qp operator_cross_i1b operator_cross_i2b operator_cross_i4b operator_cross_i8b operator_cross_el_sp operator_cross_el_dp operator_cross_el_qp operator_cross_el_i1b operator_cross_el_i2b operator_cross_el_i4b operator_cross_el_i8b Module Functions pure function operator_cross_sp (A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: A real(kind=SP), intent(in), dimension(:) :: B Return Value real(kind=SP),\n  dimension(3) pure function operator_cross_dp (A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: A real(kind=DP), intent(in), dimension(:) :: B Return Value real(kind=DP),\n  dimension(3) pure function operator_cross_qp (A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:) :: A real(kind=QP), intent(in), dimension(:) :: B Return Value real(kind=QP),\n  dimension(3) pure function operator_cross_i1b (A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in), dimension(:) :: A integer(kind=I1B), intent(in), dimension(:) :: B Return Value integer(kind=I1B),\n  dimension(3) pure function operator_cross_i2b (A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in), dimension(:) :: A integer(kind=I2B), intent(in), dimension(:) :: B Return Value integer(kind=I2B),\n  dimension(3) pure function operator_cross_i4b (A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:) :: A integer(kind=I4B), intent(in), dimension(:) :: B Return Value integer(kind=I4B),\n  dimension(3) pure function operator_cross_i8b (A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in), dimension(:) :: A integer(kind=I8B), intent(in), dimension(:) :: B Return Value integer(kind=I8B),\n  dimension(3) pure function operator_cross_el_sp (A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:,:) :: A real(kind=SP), intent(in), dimension(:,:) :: B Return Value real(kind=SP),\n  dimension(:,:), allocatable pure function operator_cross_el_dp (A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A real(kind=DP), intent(in), dimension(:,:) :: B Return Value real(kind=DP),\n  dimension(:,:), allocatable pure function operator_cross_el_qp (A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A real(kind=QP), intent(in), dimension(:,:) :: B Return Value real(kind=QP),\n  dimension(:,:), allocatable pure function operator_cross_el_i1b (A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I1B), intent(in), dimension(:,:) :: A integer(kind=I1B), intent(in), dimension(:,:) :: B Return Value integer(kind=I1B),\n  dimension(:,:), allocatable pure function operator_cross_el_i2b (A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in), dimension(:,:) :: A integer(kind=I2B), intent(in), dimension(:,:) :: B Return Value integer(kind=I2B),\n  dimension(:,:), allocatable pure function operator_cross_el_i4b (A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:,:) :: A integer(kind=I4B), intent(in), dimension(:,:) :: B Return Value integer(kind=I4B),\n  dimension(:,:), allocatable pure function operator_cross_el_i8b (A, B) result(C) Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in), dimension(:,:) :: A integer(kind=I8B), intent(in), dimension(:,:) :: B Return Value integer(kind=I8B),\n  dimension(:,:), allocatable","tags":"","loc":"module/s_operator_cross.html"},{"title":"s_operator_mag – swiftest","text":"Contains implementations for the .mag. operator for all defined real types\n Single vector implementations:  B   = .mag. A(1:3)\n Vector list implementations:   B(:) = .mag. A(1:3, :) Uses Ancestors: swiftest_operators module~~s_operator_mag~~UsesGraph module~s_operator_mag s_operator_mag module~swiftest_operators swiftest_operators module~s_operator_mag->module~swiftest_operators module~swiftest_globals swiftest_globals module~swiftest_operators->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Functions operator_mag_sp operator_mag_dp operator_mag_el_sp operator_mag_el_dp operator_mag_el_qp Module Functions pure function operator_mag_sp (A) result(B) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: A Return Value real(kind=SP) pure function operator_mag_dp (A) result(B) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: A Return Value real(kind=DP) pure function operator_mag_el_sp (A) result(B) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:,:) :: A Return Value real(kind=SP),\n  dimension(:), allocatable pure function operator_mag_el_dp (A) result(B) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A Return Value real(kind=DP),\n  dimension(:), allocatable pure function operator_mag_el_qp (A) result(B) Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A Return Value real(kind=QP),\n  dimension(:), allocatable","tags":"","loc":"module/s_operator_mag.html"},{"title":"s_util_solve – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_solve~~UsesGraph module~s_util_solve s_util_solve module~swiftest swiftest module~s_util_solve->module~swiftest module~swiftest_classes swiftest_classes module~s_util_solve->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions solve_wbs ge_wpp Module Functions util_solve_linear_system_d util_solve_linear_system_q util_solve_rkf45 Functions function solve_wbs (u) result(x) Based on code available on Rosetta Code: https://rosettacode.org/wiki/Gaussian_elimination#Fortran Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:), allocatable :: u Return Value real(kind=QP),\n  dimension(:), allocatable function ge_wpp (A, b) result(u) Solve  Ax=b  using Gaussian elimination then backwards substitution.\n   A being an n by n matrix.\n   x and b are n by 1 vectors. \n Based on code available on Rosetta Code: https://rosettacode.org/wiki/Gaussian_elimination#Fortran Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A real(kind=QP), intent(in), dimension(:) :: b Return Value real(kind=QP),\n  dimension(:,:), allocatable Module Functions function util_solve_linear_system_d (A, b, n, lerr) result(x) Author David A. Minton Solves the linear equation of the form A*x = b for x. \n   A is an (n,n) arrays\n   x and b are (n) arrays\n Uses Gaussian elimination, so will have issues if system is ill-conditioned.\n Uses quad precision intermidiate values, so works best on small arrays. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:,:) :: A real(kind=DP), intent(in), dimension(:) :: b integer(kind=I4B), intent(in) :: n logical, intent(out) :: lerr Return Value real(kind=DP),\n  dimension(n) function util_solve_linear_system_q (A, b, n, lerr) result(x) Author David A. Minton Solves the linear equation of the form A*x = b for x. \n   A is an (n,n) arrays\n   x and b are (n) arrays\n Uses Gaussian elimination, so will have issues if system is ill-conditioned.\n Uses quad precision intermidiate values, so works best on small arrays. Arguments Type Intent Optional Attributes Name real(kind=QP), intent(in), dimension(:,:) :: A real(kind=QP), intent(in), dimension(:) :: b integer(kind=I4B), intent(in) :: n logical, intent(out) :: lerr Return Value real(kind=QP),\n  dimension(n) module function util_solve_rkf45 (f, y0in, t1, dt0, tol) result(y1) Interface → Author David A. Minton Implements the 4th order Runge-Kutta-Fehlberg ODE solver for initial value problems of the form f=dy/dt, y0 = y(t=0), solving for y1 = y(t=t1). Uses a 5th order adaptive step size control.\n Uses a lambda function object as defined in the lambda_function module Arguments Type Intent Optional Attributes Name class(lambda_obj), intent(inout) :: f lambda function object that has been initialized to be a function of derivatives. The object will return with components lastarg and lasteval set real(kind=DP), intent(in), dimension(:) :: y0in Initial value at t=0 real(kind=DP), intent(in) :: t1 Final time real(kind=DP), intent(in) :: dt0 Initial step size guess real(kind=DP), intent(in) :: tol Tolerance on solution Return Value real(kind=DP),\n  dimension(:), allocatable Final result","tags":"","loc":"module/s_util_solve.html"},{"title":"s_util_set – swiftest","text":"This submodule contains a collection of setter method implementations Uses swiftest Ancestors: swiftest_classes module~~s_util_set~~UsesGraph module~s_util_set s_util_set module~swiftest swiftest module~s_util_set->module~swiftest module~swiftest_classes swiftest_classes module~s_util_set->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_set_beg_end_pl util_set_ir3h util_set_msys util_set_mu_pl util_set_mu_tp util_set_particle_info util_set_rhill util_set_rhill_approximate Module Subroutines module subroutine util_set_beg_end_pl (self, xbeg, xend, vbeg) Interface → Author David A. Minton Sets one or more of the values of xbeg, xend, and vbeg Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object real(kind=DP), intent(in), optional dimension(:,:) :: xbeg real(kind=DP), intent(in), optional dimension(:,:) :: xend real(kind=DP), intent(in), optional dimension(:,:) :: vbeg module subroutine util_set_ir3h (self) Interface → Author David A. Minton Sets the inverse heliocentric radius term (1/rh**3) for all bodies in a structure Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object module subroutine util_set_msys (self) Interface → Author David A. Minton Sets the value of msys and the vector mass quantities based on the total mass of the system Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nobdy system object module subroutine util_set_mu_pl (self, cb) Interface → Author David A. Minton Computes G * (M + m) for each massive body Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object module subroutine util_set_mu_tp (self, cb) Interface → Author David A. Minton Converts certain scalar values to arrays so that they can be used in elemental functions Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object module subroutine util_set_particle_info (self, name, particle_type, status, origin_type, origin_time, origin_xh, origin_vh, discard_time, discard_xh, discard_vh, discard_body_id) Interface → Author David A. Minton Sets one or more values of the particle information metadata object Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(inout) :: self character(len=*), intent(in), optional :: name Non-unique name character(len=*), intent(in), optional :: particle_type String containing a description of the particle type (e.g. Central Body, Massive Body, Test Particle) character(len=*), intent(in), optional :: status Particle status description: ACTIVE, MERGED, FRAGMENTED, etc. character(len=*), intent(in), optional :: origin_type String containing a description of the origin of the particle (e.g. Initial Conditions, Supercatastrophic, Disruption, etc.) real(kind=DP), intent(in), optional :: origin_time The time of the particle's formation real(kind=DP), intent(in), optional dimension(:) :: origin_xh The heliocentric distance vector at the time of the particle's formation real(kind=DP), intent(in), optional dimension(:) :: origin_vh The heliocentric velocity vector at the time of the particle's formation real(kind=DP), intent(in), optional :: discard_time The time of the particle's discard real(kind=DP), intent(in), optional dimension(:) :: discard_xh The heliocentric distance vector at the time of the particle's discard real(kind=DP), intent(in), optional dimension(:) :: discard_vh The heliocentric velocity vector at the time of the particle's discard integer(kind=I4B), intent(in), optional :: discard_body_id The id of the other body involved in the discard (0 if no other body involved) module subroutine util_set_rhill (self, cb) Interface → Author David A. Minton Sets the value of the Hill's radius Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object module subroutine util_set_rhill_approximate (self, cb) Interface → Author David A. Minton Sets the approximate value of the Hill's radius using the heliocentric radius instead of computing the semimajor axis Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object","tags":"","loc":"module/s_util_set.html"},{"title":"s_util_peri – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_peri~~UsesGraph module~s_util_peri s_util_peri module~swiftest swiftest module~s_util_peri->module~swiftest module~swiftest_classes swiftest_classes module~s_util_peri->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_peri_tp Module Subroutines module subroutine util_peri_tp (self, system, param) Interface → Author David A. Minton Determine system pericenter passages for test particles\n Note:  If the coordinate system used is barycentric, then this routine assumes that the barycentric coordinates in the\n        test particle structures are up-to-date and are not recomputed Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"module/s_util_peri.html"},{"title":"s_util_coord – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_coord~~UsesGraph module~s_util_coord s_util_coord module~swiftest swiftest module~s_util_coord->module~swiftest module~swiftest_classes swiftest_classes module~s_util_coord->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_coord_h2b_pl util_coord_h2b_tp util_coord_b2h_pl util_coord_b2h_tp util_coord_vb2vh_pl util_coord_vb2vh_tp util_coord_vh2vb_pl util_coord_vh2vb_tp util_coord_xh2xb_pl util_coord_xh2xb_tp Module Subroutines module subroutine util_coord_h2b_pl (self, cb) Interface → Author David A. Minton Convert massive bodies from heliocentric to barycentric coordinates (position and velocity) Read more… Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object module subroutine util_coord_h2b_tp (self, cb) Interface → Author David A. Minton Convert test particles from heliocentric to barycentric coordinates (position and velocity) Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object module subroutine util_coord_b2h_pl (self, cb) Interface → Author David A. Minton Convert massive bodies from barycentric to heliocentric coordinates (position and velocity) Read more… Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object module subroutine util_coord_b2h_tp (self, cb) Interface → Author David A. Minton Convert test particles from barycentric to heliocentric coordinates (position and velocity) Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(in) :: cb Swiftest central body object module subroutine util_coord_vb2vh_pl (self, cb) Interface → Author David A. Minton Convert massive bodies from barycentric to heliocentric coordinates (velocity only) Read more… Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object module subroutine util_coord_vb2vh_tp (self, vbcb) Interface → Author David A. Minton Convert test particles from barycentric to heliocentric coordinates (velocity only) Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body module subroutine util_coord_vh2vb_pl (self, cb) Interface → Author David A. Minton Convert massive bodies from heliocentric to barycentric coordinates (velocity only) Read more… Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object module subroutine util_coord_vh2vb_tp (self, vbcb) Interface → Author David A. Minton Convert test particles from heliocentric to barycentric coordinates (velocity only) Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object real(kind=DP), intent(in), dimension(:) :: vbcb Barycentric velocity of the central body module subroutine util_coord_xh2xb_pl (self, cb) Interface → Author David A. Minton Convert position vectors of massive bodies from heliocentric to barycentric coordinates (position only) Read more… Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_cb ), intent(inout) :: cb Swiftest central body object module subroutine util_coord_xh2xb_tp (self, cb) Interface → Author David A. Minton Convert test particles from heliocentric to barycentric coordinates (position only) Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_cb ), intent(in) :: cb Swiftest central body object","tags":"","loc":"module/s_util_coord.html"},{"title":"s_util_index – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_index~~UsesGraph module~s_util_index s_util_index module~swiftest swiftest module~s_util_index->module~swiftest module~swiftest_classes swiftest_classes module~s_util_index->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_index_eucl_ij_to_k util_index_eucl_k_to_ij util_index_eucl_plpl util_index_eucl_pltp Module Subroutines pure module subroutine util_index_eucl_ij_to_k (n, i, j, k) Interface → Author Jacob R. Elliott and David A. Minton Turns i,j indices into k index for use in the Euclidean distance matrix for pl-pl interactions. Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n Number of bodies integer(kind=I4B), intent(in) :: i Index of the ith body integer(kind=I4B), intent(in) :: j Index of the jth body integer(kind=I8B), intent(out) :: k Index of the flattened matrix pure module subroutine util_index_eucl_k_to_ij (n, k, i, j) Interface → Author Jacob R. Elliott and David A. Minton Turns k index into i,j indices for use in the Euclidean distance matrix for pl-pl interactions. Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n Number of bodies integer(kind=I8B), intent(in) :: k Index of the flattened matrix integer(kind=I4B), intent(out) :: i Index of the ith body integer(kind=I4B), intent(out) :: j Index of the jth body module subroutine util_index_eucl_plpl (self, param) Interface → Author Jacob R. Elliott and David A. Minton Turns i,j indices into k index for use in the Euclidean distance matrix for pl-pl interactions for a Swiftest massive body object Read more… Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters module subroutine util_index_eucl_pltp (self, pl, param) Interface → Author Jacob R. Elliott and David A. Minton Turns i,j indices into k index for use in the Euclidean distance matrix for pl-tp interactions Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_pl ), intent(in) :: pl Swiftest massive body object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"module/s_util_index.html"},{"title":"s_util_rescale – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_rescale~~UsesGraph module~s_util_rescale s_util_rescale module~swiftest swiftest module~s_util_rescale->module~swiftest module~swiftest_classes swiftest_classes module~s_util_rescale->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_rescale_system Module Subroutines module subroutine util_rescale_system (self, param, mscale, dscale, tscale) Interface → Author David A. Minton Rescales an nbody system to a new set of units. Inputs are the multipliers on the mass (mscale), distance (dscale), and time units (tscale). \n Rescales all united quantities in the system, as well as the mass conversion factors, gravitational constant, and Einstein's constant in the parameter object. Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters. Returns with new values of the scale vactors and GU real(kind=DP), intent(in) :: mscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: dscale Scale factors for mass, distance, and time units, respectively. real(kind=DP), intent(in) :: tscale Scale factors for mass, distance, and time units, respectively.","tags":"","loc":"module/s_util_rescale.html"},{"title":"s_util_version – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_version~~UsesGraph module~s_util_version s_util_version module~swiftest swiftest module~s_util_version->module~swiftest module~swiftest_classes swiftest_classes module~s_util_version->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_version Module Subroutines module subroutine util_version () Interface → Author David A. Minton Print program version information to terminale Read more… Arguments None","tags":"","loc":"module/s_util_version.html"},{"title":"s_util_sort – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_sort~~UsesGraph module~s_util_sort s_util_sort module~swiftest swiftest module~s_util_sort->module~swiftest module~swiftest_classes swiftest_classes module~s_util_sort->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_sort_body util_sort_dp util_sort_index_dp util_sort_i4b util_sort_index_i4b util_sort_sp util_sort_index_sp util_sort_pl util_sort_tp util_sort_rearrange_body util_sort_rearrange_arr_char_string util_sort_rearrange_arr_DP util_sort_rearrange_arr_DPvec util_sort_rearrange_arr_I4B util_sort_rearrange_arr_logical util_sort_rearrange_arr_info util_sort_rearrange_pl util_sort_rearrange_tp Module Subroutines module subroutine util_sort_body (self, sortby, ascending) Interface → Author David A. Minton Sort a Swiftest body structure in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order subroutine util_sort_dp (arr) Author David A. Minton Sort input double precision array in place into ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:) :: arr subroutine util_sort_index_dp (arr, ind) Author David A. Minton Sort input double precision array by index in ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind subroutine util_sort_i4b (arr) Author David A. Minton Sort input integer array in place into ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:) :: arr subroutine util_sort_index_i4b (arr, ind) Author David A. Minton Sort input integer array by index in ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind subroutine util_sort_sp (arr) Author David A. Minton Sort input single precision array in place into ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), dimension(:) :: arr subroutine util_sort_index_sp (arr, ind) Author David A. Minton Sort input single precision array by index in ascending numerical order using insertion sort.\n This algorithm works well for partially sorted arrays (which is usually the case here) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), dimension(:) :: arr integer(kind=I4B), intent(out), dimension(:) :: ind module subroutine util_sort_pl (self, sortby, ascending) Interface → Author David A. Minton Sort a Swiftest massive body object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order module subroutine util_sort_tp (self, sortby, ascending) Interface → Author David A. Minton Sort a Swiftest test particle object  in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order module subroutine util_sort_rearrange_body (self, ind) Interface → Author David A. Minton Rearrange Swiftest body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) subroutine util_sort_rearrange_arr_char_string (arr, ind, n) Author David A. Minton Rearrange a single array of character string in-place from an index list. Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange subroutine util_sort_rearrange_arr_DP (arr, ind, n) Author David A. Minton Rearrange a single array of DP type in-place from an index list. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange subroutine util_sort_rearrange_arr_DPvec (arr, ind, n) Author David A. Minton Rearrange a single array of (NDIM,n) DP-type vectors in-place from an index list. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange subroutine util_sort_rearrange_arr_I4B (arr, ind, n) Author David A. Minton Rearrange a single array of integers in-place from an index list. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange subroutine util_sort_rearrange_arr_logical (arr, ind, n) Author David A. Minton Rearrange a single array of logicals in-place from an index list. Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange subroutine util_sort_rearrange_arr_info (arr, ind, n) Author David A. Minton Rearrange a single array of particle information type in-place from an index list. Arguments Type Intent Optional Attributes Name type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange module subroutine util_sort_rearrange_pl (self, ind) Interface → Author David A. Minton Rearrange Swiftest massive body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) module subroutine util_sort_rearrange_tp (self, ind) Interface → Author David A. Minton Rearrange Swiftest massive body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order)","tags":"","loc":"module/s_util_sort.html"},{"title":"s_util_spill – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_spill~~UsesGraph module~s_util_spill s_util_spill module~swiftest swiftest module~s_util_spill->module~swiftest module~swiftest_classes swiftest_classes module~s_util_spill->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_spill_arr_char_string util_spill_arr_DP util_spill_arr_DPvec util_spill_arr_I4B util_spill_arr_I8B util_spill_arr_info util_spill_arr_logical util_spill_body util_spill_encounter util_spill_pl util_spill_tp Module Subroutines subroutine util_spill_arr_char_string (keeps, discards, lspill_list, ldestructive) Author David A. Minton Performs a spill operation on a single array of type character strings\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: keeps Array of values to keep character(len=STRMAX), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not subroutine util_spill_arr_DP (keeps, discards, lspill_list, ldestructive) Author David A. Minton Performs a spill operation on a single array of type DP\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: keeps Array of values to keep real(kind=DP), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not subroutine util_spill_arr_DPvec (keeps, discards, lspill_list, ldestructive) Author David A. Minton Performs a spill operation on a single array of DP vectors with shape (NDIM, n)\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: keeps Array of values to keep real(kind=DP), intent(inout), dimension(:,:), allocatable :: discards Array discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not subroutine util_spill_arr_I4B (keeps, discards, lspill_list, ldestructive) Author David A. Minton Performs a spill operation on a single array of type I4B\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: keeps Array of values to keep integer(kind=I4B), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not subroutine util_spill_arr_I8B (keeps, discards, lspill_list, ldestructive) Author David A. Minton Performs a spill operation on a single array of type I4B\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(inout), dimension(:), allocatable :: keeps Array of values to keep integer(kind=I8B), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not subroutine util_spill_arr_info (keeps, discards, lspill_list, ldestructive) Author David A. Minton Performs a spill operation on a single array of particle origin information types\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not subroutine util_spill_arr_logical (keeps, discards, lspill_list, ldestructive) Author David A. Minton Performs a spill operation on a single array of logicals\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: keeps Array of values to keep logical, intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or no module subroutine util_spill_body (self, discards, lspill_list, ldestructive) Interface → Author David A. Minton Move spilled (discarded) Swiftest generic particle structure from active list to discard list\n Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90\n Spill all the common components Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list module subroutine util_spill_encounter (self, discards, lspill_list, ldestructive) Interface → Author David A. Minton Move spilled (discarded) Swiftest encounter structure from active list to discard list Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list module subroutine util_spill_pl (self, discards, lspill_list, ldestructive) Interface → Author David A. Minton Move spilled (discarded) Swiftest massive body structure from active list to discard list\n Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90\n Spill components specific to the massive body class Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list module subroutine util_spill_tp (self, discards, lspill_list, ldestructive) Interface → Author David A. Minton Move spilled (discarded) Swiftest test particle structure from active list to discard list\n Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90\n Spill components specific to the test particle class Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardse logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list","tags":"","loc":"module/s_util_spill.html"},{"title":"s_util_valid – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_valid~~UsesGraph module~s_util_valid s_util_valid module~swiftest swiftest module~s_util_valid->module~swiftest module~swiftest_classes swiftest_classes module~s_util_valid->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_valid_id_system Module Subroutines module subroutine util_valid_id_system (self, param) Interface → Author David A. Minton Validate massive body and test particle ids\n Subroutine causes program to exit with error if any ids are not unique Read more… Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"module/s_util_valid.html"},{"title":"s_util_exit – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_exit~~UsesGraph module~s_util_exit s_util_exit module~swiftest swiftest module~s_util_exit->module~swiftest module~swiftest_classes swiftest_classes module~s_util_exit->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_exit Module Subroutines module subroutine util_exit (code) Interface → Author David A. Minton Print termination message and exit program Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: code","tags":"","loc":"module/s_util_exit.html"},{"title":"s_util_fill – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_fill~~UsesGraph module~s_util_fill s_util_fill module~swiftest swiftest module~s_util_fill->module~swiftest module~swiftest_classes swiftest_classes module~s_util_fill->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_fill_arr_char_string util_fill_arr_DP util_fill_arr_DPvec util_fill_arr_I4B util_fill_arr_info util_fill_arr_logical util_fill_body util_fill_pl util_fill_tp Module Subroutines subroutine util_fill_arr_char_string (keeps, inserts, lfill_list) Author David A. Minton Performs a fill operation on a single array of type character strings\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: keeps Array of values to keep character(len=STRMAX), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps subroutine util_fill_arr_DP (keeps, inserts, lfill_list) Author David A. Minton Performs a fill operation on a single array of type DP\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: keeps Array of values to keep real(kind=DP), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps subroutine util_fill_arr_DPvec (keeps, inserts, lfill_list) Author David A. Minton Performs a fill operation on a single array of DP vectors with shape (NDIM, n)\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: keeps Array of values to keep real(kind=DP), intent(in), dimension(:,:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps subroutine util_fill_arr_I4B (keeps, inserts, lfill_list) Author David A. Minton Performs a fill operation on a single array of type I4B\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: keeps Array of values to keep integer(kind=I4B), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps subroutine util_fill_arr_info (keeps, inserts, lfill_list) Author David A. Minton Performs a fill operation on a single array of particle origin information types\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( swiftest_particle_info ), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps subroutine util_fill_arr_logical (keeps, inserts, lfill_list) Author David A. Minton Performs a fill operation on a single array of logicals\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: keeps Array of values to keep logical, intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps module subroutine util_fill_body (self, inserts, lfill_list) Interface → Author David A. Minton Insert new Swiftest generic particle structure into an old one. \n This is the inverse of a spill operation.\n Fill all the common components Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_body ), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps module subroutine util_fill_pl (self, inserts, lfill_list) Interface → Author David A. Minton Insert new Swiftest massive body structure into an old one. \n This is the inverse of a spill operation.\n Fill components specific to the massive body class Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps module subroutine util_fill_tp (self, inserts, lfill_list) Interface → Author David A. Minton Insert new Swiftest test particle structure into an old one. \n This is the inverse of a fill operation.\n Spill components specific to the test particle class Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: inserts Swiftest body object to be inserted logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps","tags":"","loc":"module/s_util_fill.html"},{"title":"s_util_resize – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_resize~~UsesGraph module~s_util_resize s_util_resize module~swiftest swiftest module~s_util_resize->module~swiftest module~swiftest_classes swiftest_classes module~s_util_resize->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_resize_arr_char_string util_resize_arr_DP util_resize_arr_DPvec util_resize_arr_I4B util_resize_arr_info util_resize_arr_logical util_resize_body util_resize_encounter util_resize_pl util_resize_tp Module Subroutines subroutine util_resize_arr_char_string (arr, nnew) Author David A. Minton Resizes an array component of type character string. nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size subroutine util_resize_arr_DP (arr, nnew) Author David A. Minton Resizes an array component of double precision type. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size subroutine util_resize_arr_DPvec (arr, nnew) Author David A. Minton Resizes an array component of double precision vectors of size (NDIM, n). Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size subroutine util_resize_arr_I4B (arr, nnew) Author David A. Minton Resizes an array component of integer type. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size subroutine util_resize_arr_info (arr, nnew) Author David A. Minton Resizes an array component of type character string. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size subroutine util_resize_arr_logical (arr, nnew) Author David A. Minton Resizes an array component of logical type. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size module subroutine util_resize_body (self, nnew) Interface → Author David A. Minton Checks the current size of a Swiftest body against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object integer(kind=I4B), intent(in) :: nnew New size neded module subroutine util_resize_encounter (self, nnew) Interface → Author David A. Minton Checks the current size of the encounter list against the required size and extends it by a factor of 2 more than requested if it is too small.\n Note: The reason to extend it by a factor of 2 is for performance. When there are many enounters per step, resizing every time you want to add an \n encounter takes significant computational effort. Resizing by a factor of 2 is a tradeoff between performance (fewer resize calls) and memory managment\n Memory usage grows by a factor of 2 each time it fills up, but no more. Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list integer(kind=I4B), intent(in) :: nnew New size of list needed module subroutine util_resize_pl (self, nnew) Interface → Author David A. Minton Checks the current size of a Swiftest massive body against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: nnew New size neded module subroutine util_resize_tp (self, nnew) Interface → Author David A. Minton Checks the current size of a Swiftest test particle against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: nnew New size neded","tags":"","loc":"module/s_util_resize.html"},{"title":"s_util_copy – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_copy~~UsesGraph module~s_util_copy s_util_copy module~swiftest swiftest module~s_util_copy->module~swiftest module~swiftest_classes swiftest_classes module~s_util_copy->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_copy_encounter util_copy_particle_info util_copy_particle_info_arr Module Subroutines module subroutine util_copy_encounter (self, source) Interface → Author David A. Minton Copies elements from the source encounter list into self. Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Encounter list class( swiftest_encounter ), intent(in) :: source Source object to copy into module subroutine util_copy_particle_info (self, source) Interface → Author David A. Minton Copies one set of information object components into another, component-by-component Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(inout) :: self class( swiftest_particle_info ), intent(in) :: source module subroutine util_copy_particle_info_arr (source, dest, idx) Interface → Author David A. Minton Copies contents from an array of one particle information objects to another. Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(in), dimension(:) :: source Source object to copy into class( swiftest_particle_info ), intent(inout), dimension(:) :: dest Swiftest body object with particle metadata information object integer(kind=I4B), intent(in), optional dimension(:) :: idx Optional array of indices to draw the source object","tags":"","loc":"module/s_util_copy.html"},{"title":"s_util_minimize_bfgs – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_minimize_bfgs~~UsesGraph module~s_util_minimize_bfgs s_util_minimize_bfgs module~swiftest swiftest module~s_util_minimize_bfgs->module~swiftest module~swiftest_classes swiftest_classes module~s_util_minimize_bfgs->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Functions util_minimize_bfgs Module Functions module function util_minimize_bfgs (f, N, x0, eps, maxloop, lerr) result(x1) Interface → Author David A. Minton This function implements the Broyden-Fletcher-Goldfarb-Shanno method to determine the minimum of a function of N variables. It recieves as input:\n   f%eval(x) : lambda function object containing the objective function as the eval metho\n   N       : Number of variables of function f\n   x0      : Initial starting value of x\n   eps     : Accuracy of 1 - dimensional minimization at each step\n   maxloop : Maximum number of loops to attempt to find a solution\n The outputs include\n   lerr :  Returns .true. if it could not find the minimum\n Returns\n   x1   :  Final minimum (all 0 if none found)\n   0 = No miniumum found Read more… Arguments Type Intent Optional Attributes Name class(lambda_obj), intent(inout) :: f integer(kind=I4B), intent(in) :: N real(kind=DP), intent(in), dimension(:) :: x0 real(kind=DP), intent(in) :: eps integer(kind=I4B), intent(in) :: maxloop logical, intent(out) :: lerr Return Value real(kind=DP),\n  dimension(:), allocatable","tags":"","loc":"module/s_util_minimize_bfgs.html"},{"title":"s_util_append – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_append~~UsesGraph module~s_util_append s_util_append module~swiftest swiftest module~s_util_append->module~swiftest module~swiftest_classes swiftest_classes module~s_util_append->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines util_append_arr_char_string util_append_arr_DP util_append_arr_DPvec util_append_arr_I4B util_append_arr_info util_append_arr_logical util_append_body util_append_encounter util_append_pl util_append_tp Module Subroutines subroutine util_append_arr_char_string (arr, source, nold, nsrc, lsource_mask) Author David A. Minton Append a single array of character string type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name character(len=STRMAX), intent(inout), dimension(:), allocatable :: arr Destination array character(len=STRMAX), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to subroutine util_append_arr_DP (arr, source, nold, nsrc, lsource_mask) Author David A. Minton Append a single array of double precision type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:), allocatable :: arr Destination array real(kind=DP), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to subroutine util_append_arr_DPvec (arr, source, nold, nsrc, lsource_mask) Author David A. Minton Append a single array of double precision vector type of size (NDIM, n) onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), dimension(:,:), allocatable :: arr Destination array real(kind=DP), intent(in), dimension(:,:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to subroutine util_append_arr_I4B (arr, source, nold, nsrc, lsource_mask) Author David A. Minton Append a single array of integer(I4B) onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to subroutine util_append_arr_info (arr, source, nold, nsrc, lsource_mask) Author David A. Minton Append a single array of particle information type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name type( swiftest_particle_info ), intent(inout), dimension(:), allocatable :: arr Destination array type( swiftest_particle_info ), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to subroutine util_append_arr_logical (arr, source, nold, nsrc, lsource_mask) Author David A. Minton Append a single array of logical type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:), allocatable :: arr Destination array logical, intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to module subroutine util_append_body (self, source, lsource_mask) Interface → Author David A. Minton Append components from one Swiftest body object to another. \n This method will automatically resize the destination body if it is too small Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to module subroutine util_append_encounter (self, source, lsource_mask) Interface → Author David A. Minton Append components from one Swiftest body object to another. \n This method will automatically resize the destination body if it is too small Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter list object class( swiftest_encounter ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to module subroutine util_append_pl (self, source, lsource_mask) Interface → Author David A. Minton Append components from one Swiftest body object to another. \n This method will automatically resize the destination body if it is too small Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to module subroutine util_append_tp (self, source, lsource_mask) Interface → Author David A. Minton Append components from one Swiftest body object to another. \n This method will automatically resize the destination body if it is too small Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_body ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to","tags":"","loc":"module/s_util_append.html"},{"title":"s_util_get_energy_momentum – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_util_get_energy_momentum~~UsesGraph module~s_util_get_energy_momentum s_util_get_energy_momentum module~swiftest swiftest module~s_util_get_energy_momentum->module~swiftest module~swiftest_classes swiftest_classes module~s_util_get_energy_momentum->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines util_get_energy_potential Module Subroutines util_get_energy_momentum_system Subroutines subroutine util_get_energy_potential (npl, nplpl, k_plpl, lmask, GMcb, Gmass, mass, xb, pe) Author David A. Minton Compute total system potential energy Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: npl integer(kind=I8B), intent(in) :: nplpl integer(kind=I4B), intent(in), dimension(:,:) :: k_plpl logical, intent(in), dimension(:) :: lmask real(kind=DP), intent(in) :: GMcb real(kind=DP), intent(in), dimension(:) :: Gmass real(kind=DP), intent(in), dimension(:) :: mass real(kind=DP), intent(in), dimension(:,:) :: xb real(kind=DP), intent(out) :: pe Module Subroutines module subroutine util_get_energy_momentum_system (self, param) Interface → Author David A. Minton Compute total system angular momentum vector and kinetic, potential and total system energy Read more… Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"module/s_util_get_energy_momentum.html"},{"title":"s_gr – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_gr~~UsesGraph module~s_gr s_gr module~swiftest swiftest module~s_gr->module~swiftest module~swiftest_classes swiftest_classes module~s_gr->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines gr_kick_getaccb_ns_body gr_kick_getacch gr_p4_pos_kick gr_pseudovel2vel gr_pv2vh_body gr_vel2pseudovel gr_vh2pv_body Module Subroutines pure module subroutine gr_kick_getaccb_ns_body (self, system, param) Interface → Author David A. Minton Add relativistic correction acceleration for non-symplectic integrators.\n Based on Quinn et al. (1991) eq. 5 Read more… Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters pure module subroutine gr_kick_getacch (mu, x, lmask, n, inv_c2, agr) Interface → Author David A. Minton Compute relativisitic accelerations of massive bodies\n    Based on Saha & Tremaine (1994) Eq. 28 Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: mu Gravitational constant real(kind=DP), intent(in), dimension(:,:) :: x Position vectors logical, intent(in), dimension(:) :: lmask Logical mask indicating which bodies to compute integer(kind=I4B), intent(in) :: n Total number of bodies real(kind=DP), intent(in) :: inv_c2 Inverse speed of light squared: 1 / c**2 real(kind=DP), intent(out), dimension(:,:) :: agr Accelerations pure module subroutine gr_p4_pos_kick (param, x, v, dt) Interface → Author David A. Minton Position kick due to p**4 term in the post-Newtonian correction\n    Based on Saha & Tremaine (1994) Eq. 28 Read more… Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(inout), dimension(:) :: x Position vector real(kind=DP), intent(in), dimension(:) :: v Velocity vector real(kind=DP), intent(in) :: dt Step size pure module subroutine gr_pseudovel2vel (param, mu, xh, pv, vh) Interface → Author David A. Minton Converts the relativistic pseudovelocity back into a veliocentric velocity\n    Based on Saha & Tremaine (1994) Eq. 32 Read more… Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real(kind=DP), intent(in), dimension(:) :: xh Heliocentric position vector real(kind=DP), intent(in), dimension(:) :: pv Pseudovelocity velocity vector - see Saha & Tremain (1994), eq. (32) real(kind=DP), intent(out), dimension(:) :: vh Heliocentric velocity vector pure module subroutine gr_pv2vh_body (self, param) Interface → Author David A. Minton Wrapper function that converts from pseudovelocity to heliocentric velocity for swiftest bodies Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters pure module subroutine gr_vel2pseudovel (param, mu, xh, vh, pv) Interface → Author David A. Minton Converts the heliocentric velocity into a pseudovelocity with relativistic corrections. \n Uses Newton-Raphson method with direct inversion of the Jacobian (yeah, it's slow, but \n this is only done once per run). Read more… Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body real(kind=DP), intent(in), dimension(:) :: xh Heliocentric position vector real(kind=DP), intent(in), dimension(:) :: vh Heliocentric velocity vector real(kind=DP), intent(out), dimension(:) :: pv Pseudovelocity vector - see Saha & Tremain (1994), eq. (32) pure module subroutine gr_vh2pv_body (self, param) Interface → Author David A. Minton Wrapper function that converts from heliocentric velocity to pseudovelocity for Swiftest bodies Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"module/s_gr.html"},{"title":"s_discard – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_discard~~UsesGraph module~s_discard s_discard module~swiftest swiftest module~s_discard->module~swiftest module~swiftest_classes swiftest_classes module~s_discard->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines discard_cb_tp discard_peri_tp discard_pl_tp discard_pl_close Module Subroutines discard_system discard_pl discard_tp Subroutines subroutine discard_cb_tp (tp, system, param) Author David A. Minton Check to see if test particles should be discarded based on their positions relative to the Sun\n        or because they are unbound from the system Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: tp Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters subroutine discard_peri_tp (tp, system, param) Author David A. Minton Check to see if a test particle should be discarded because its perihelion distance becomes too small Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: tp Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameterss subroutine discard_pl_tp (tp, system, param) Author David A. Minton Check to see if test particles should be discarded based on their positions relative to the massive bodies Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: tp Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters subroutine discard_pl_close (dx, dv, dt, r2crit, iflag, r2min) Author David A. Minton Check to see if a test particle and massive body are having, or will have within the next time step, an encounter such\n          that the separation distance r is less than some critical radius rcrit (or r 2 < rcrit 2 = r2crit) Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: dx real(kind=DP), intent(in), dimension(:) :: dv real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r2crit integer(kind=I4B), intent(out) :: iflag real(kind=DP), intent(out) :: r2min Module Subroutines module subroutine discard_system (self, param) Interface → Author David A. Minton Calls the discard methods for each body class and then the write method if any discards were detected Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters module subroutine discard_pl (self, system, param) Interface → Author David A. Minton Placeholder method for discarding massive bodies. This method does nothing except to ensure that the discard flag is set to false. \n  This method is intended to be overridden by more advanced integrators. Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameter module subroutine discard_tp (self, system, param) Interface → Author David A. Minton Check to see if particles should be discarded based on their positions relative to the massive bodies Read more… Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameter","tags":"","loc":"module/s_discard.html"},{"title":"s_helio_step – swiftest","text":"Uses swiftest Ancestors: helio_classes module~~s_helio_step~~UsesGraph module~s_helio_step s_helio_step module~swiftest swiftest module~s_helio_step->module~swiftest module~helio_classes helio_classes module~s_helio_step->module~helio_classes module~swiftest->module~helio_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines helio_step_system helio_step_pl helio_step_tp Module Subroutines module subroutine helio_step_system (self, param, t, dt) Interface → Author David A. Minton Step massive bodies and and active test particles ahead in heliocentric coordinates. Read more… Arguments Type Intent Optional Attributes Name class( helio_nbody_system ), intent(inout) :: self Helio nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize module subroutine helio_step_pl (self, system, param, t, dt) Interface → Author David A. Minton Step massive bodies ahead Democratic Heliocentric method Read more… Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nboody system class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize module subroutine helio_step_tp (self, system, param, t, dt) Interface → Author David A. Minton Step active test particles ahead using Democratic Heliocentric method Read more… Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nboody system class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"module/s_helio_step.html"},{"title":"s_helio_setup – swiftest","text":"Uses swiftest Ancestors: helio_classes module~~s_helio_setup~~UsesGraph module~s_helio_setup s_helio_setup module~swiftest swiftest module~s_helio_setup->module~swiftest module~helio_classes helio_classes module~s_helio_setup->module~helio_classes module~swiftest->module~helio_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines helio_setup_initialize_system Module Subroutines module subroutine helio_setup_initialize_system (self, param) Interface → Author David A. Minton Initialize a Helio nbody system from files, converting all heliocentric quantities to barycentric. Arguments Type Intent Optional Attributes Name class( helio_nbody_system ), intent(inout) :: self Helio nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters","tags":"","loc":"module/s_helio_setup.html"},{"title":"s_helio_gr – swiftest","text":"Uses swiftest Ancestors: helio_classes module~~s_helio_gr~~UsesGraph module~s_helio_gr s_helio_gr module~swiftest swiftest module~s_helio_gr->module~swiftest module~helio_classes helio_classes module~s_helio_gr->module~helio_classes module~swiftest->module~helio_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines helio_gr_kick_getacch_pl helio_gr_kick_getacch_tp helio_gr_p4_pl helio_gr_p4_tp Module Subroutines pure module subroutine helio_gr_kick_getacch_pl (self, param) Interface → Author David A. Minton Compute relativisitic accelerations of massive bodies\n    Based on Saha & Tremaine (1994) Eq. 28 Read more… Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters pure module subroutine helio_gr_kick_getacch_tp (self, param) Interface → Author David A. Minton Compute relativisitic accelerations of test particles\n    Based on Saha & Tremaine (1994) Eq. 28 Read more… Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body particle data structure class(swiftest_parameters), intent(in) :: param Current run configuration parameters pure module subroutine helio_gr_p4_pl (self, param, dt) Interface → Author David A. Minton Position kick to massive bodies due to p**4 term in the post-Newtonian correction\n    Based on Saha & Tremaine (1994) Eq. 28 Read more… Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size pure module subroutine helio_gr_p4_tp (self, param, dt) Interface → Author David A. Minton Position kick to test particles due to p**4 term in the post-Newtonian correction\n    Based on Saha & Tremaine (1994) Eq. 28 Read more… Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Swiftest particle object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Step size","tags":"","loc":"module/s_helio_gr.html"},{"title":"s_helio_kick – swiftest","text":"Uses swiftest Ancestors: helio_classes module~~s_helio_kick~~UsesGraph module~s_helio_kick s_helio_kick module~swiftest swiftest module~s_helio_kick->module~swiftest module~helio_classes helio_classes module~s_helio_kick->module~helio_classes module~swiftest->module~helio_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines helio_kick_getacch_pl helio_kick_getacch_tp helio_kick_vb_pl helio_kick_vb_tp Module Subroutines module subroutine helio_kick_getacch_pl (self, system, param, t, lbeg) Interface → Author David A. Minton Compute heliocentric accelerations of massive bodies Read more… Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step module subroutine helio_kick_getacch_tp (self, system, param, t, lbeg) Interface → Author David A. Minton Compute heliocentric accelerations of test particles Read more… Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step module subroutine helio_kick_vb_pl (self, system, param, t, dt, lbeg) Interface → Author David A. Minton Kick barycentric velocities of bodies Read more… Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. module subroutine helio_kick_vb_tp (self, system, param, t, dt, lbeg) Interface → Author David A. Minton Kick barycentric velocities of bodies Read more… Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Swiftest generic body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not.","tags":"","loc":"module/s_helio_kick.html"},{"title":"s_helio_drift – swiftest","text":"Uses swiftest Ancestors: helio_classes module~~s_helio_drift~~UsesGraph module~s_helio_drift s_helio_drift module~swiftest swiftest module~s_helio_drift->module~swiftest module~helio_classes helio_classes module~s_helio_drift->module~helio_classes module~swiftest->module~helio_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines helio_drift_body helio_drift_pl helio_drift_tp helio_drift_linear_pl helio_drift_linear_tp Module Subroutines module subroutine helio_drift_body (self, system, param, dt) Interface → Author David A. Minton Loop through bodies and call Danby drift routine on democratic heliocentric coordinates Read more… Arguments Type Intent Optional Attributes Name class(swiftest_body), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize module subroutine helio_drift_pl (self, system, param, dt) Interface → Author David A. Minton Wrapper function used to call the body drift routine from a helio_pl structure Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize module subroutine helio_drift_tp (self, system, param, dt) Interface → Author David A. Minton Wrapper function used to call the body drift routine from a helio_pl structure Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio massive body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize module subroutine helio_drift_linear_pl (self, cb, dt, lbeg) Interface → Author David A. Minton Perform linear drift of massive bodies due to barycentric momentum of Sun Read more… Arguments Type Intent Optional Attributes Name class( helio_pl ), intent(inout) :: self Helio massive body object class( helio_cb ), intent(inout) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step module subroutine helio_drift_linear_tp (self, cb, dt, lbeg) Interface → Author David A. Minton Perform linear drift of test particles due to barycentric momentum of Sun\n New vectorized version included Read more… Arguments Type Intent Optional Attributes Name class( helio_tp ), intent(inout) :: self Helio test particleb object class( helio_cb ), intent(in) :: cb Helio central body real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Argument that determines whether or not this is the beginning or end of the step","tags":"","loc":"module/s_helio_drift.html"},{"title":"s_io – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_io~~UsesGraph module~s_io s_io module~swiftest swiftest module~s_io->module~swiftest module~swiftest_classes swiftest_classes module~s_io->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions io_read_encounter io_read_hdr Module Functions io_get_args io_get_old_t_final_system io_get_token io_read_frame_body io_read_frame_cb io_read_frame_system Module Subroutines io_conservation_report io_dump_param io_dump_particle_info io_dump_particle_info_base io_dump_base io_dump_system io_param_reader io_param_writer io_read_in_body io_read_in_cb io_read_in_param io_read_in_particle_info io_read_particle_info_system io_toupper io_write_discard io_write_encounter io_write_frame_body io_write_frame_cb io_write_frame_encounter io_write_frame_system io_write_hdr_system Functions function io_read_encounter (t, id1, id2, Gmass1, Gmass2, radius1, radius2, xh1, xh2, vh1, vh2, enc_out, out_type) result(ierr) Author David A. Minton Read close encounter data from input binary files\n     Other than time t, there is no direct file input from this function\n     Function returns read error status (0 = OK, nonzero = ERROR)\n Adapted from David E. Kaufmann's Swifter routine: io_read_encounter.f90 Arguments Type Intent Optional Attributes Name real(kind=DP), intent(out) :: t integer(kind=I4B), intent(out) :: id1 integer(kind=I4B), intent(out) :: id2 real(kind=DP), intent(out) :: Gmass1 real(kind=DP), intent(out) :: Gmass2 real(kind=DP), intent(out) :: radius1 real(kind=DP), intent(out) :: radius2 real(kind=DP), intent(out), dimension(:) :: xh1 real(kind=DP), intent(out), dimension(:) :: xh2 real(kind=DP), intent(out), dimension(:) :: vh1 real(kind=DP), intent(out), dimension(:) :: vh2 character(len=*), intent(in) :: enc_out character(len=*), intent(in) :: out_type Return Value integer(kind=I4B) function io_read_hdr (iu, t, npl, ntp, out_form, out_type) result(ierr) Author David A. Minton Read frame header from input binary files\n     Function returns read error status (0 = OK, nonzero = ERROR)\n Adapted from David E. Kaufmann's Swifter routine: io_read_hdr.f90\n Adapted from Hal Levison's Swift routine io_read_hdr.f Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu real(kind=DP), intent(out) :: t integer(kind=I4B), intent(out) :: npl integer(kind=I4B), intent(out) :: ntp character(len=*), intent(out) :: out_form character(len=*), intent(in) :: out_type Return Value integer(kind=I4B) Module Functions module function io_get_args (integrator, param_file_name) result(ierr) Interface → Author David A. Minton Reads in the name of the parameter file from command line arguments. Arguments Type Intent Optional Attributes Name integer(kind=I4B) :: integrator Symbolic code of the requested integrator character(len=:), allocatable :: param_file_name Name of the input parameters file Return Value integer(kind=I4B) I/O error code module function io_get_old_t_final_system (self, param) result(old_t_final) Interface → Author David A. Minton Validates the dump file to check whether the dump file initial conditions duplicate the last frame of the binary output. Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self class( swiftest_parameters ), intent(in) :: param Return Value real(kind=DP) module function io_get_token (buffer, ifirst, ilast, ierr) result(token) Interface → Author David A. Minton Retrieves a character token from an input string. Here a token is defined as any set of contiguous non-blank characters not \n beginning with or containing \"!\". If \"!\" is present, any remaining part of the buffer including the \"!\" is ignored Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: buffer Input string buffer integer(kind=I4B), intent(inout) :: ifirst Index of the buffer at which to start the search for a token integer(kind=I4B), intent(out) :: ilast Index of the buffer at the end of the returned token integer(kind=I4B), intent(out) :: ierr Error code Return Value character(len=:),\n  allocatable Returned token string module function io_read_frame_body (self, iu, param) result(ierr) Interface → Author David A. Minton Reads a frame of output of either test particle or massive body data from a binary output file Read more… Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful module function io_read_frame_cb (self, iu, param) result(ierr) Interface → Author David A. Minton Reads a frame of output of central body data to the binary output file Read more… Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful module function io_read_frame_system (self, iu, param) result(ierr) Interface → Author The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott Read a frame (header plus records for each massive body and active test particle) from a output binary file Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters Return Value integer(kind=I4B) Error code: returns 0 if the read is successful Module Subroutines module subroutine io_conservation_report (self, param, lterminal) Interface → Author The Purdue Swiftest Team -  David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott Reports the current state of energy, mass, and angular momentum conservation in a run Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Input colleciton of user-defined parameters logical, intent(in) :: lterminal Indicates whether to output information to the terminal screen module subroutine io_dump_param (self, param_file_name) Interface → Author David A. Minton Dump integration parameters to file Read more… Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Output collection of parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in) module subroutine io_dump_particle_info (self, iu) Interface → Author David A. Minton Reads in particle information object information from an open file unformatted file Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(in) :: self Particle metadata information object integer(kind=I4B), intent(in) :: iu Open file unit number module subroutine io_dump_particle_info_base (self, param, idx) Interface → Author David A. Minton Dumps the particle information data to a file. \n Pass a list of array indices for test particles (tpidx) and/or massive bodies (plidx) to append Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object (can be cb, pl, or tp) class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters integer(kind=I4B), intent(in), optional dimension(:) :: idx Array of test particle indices to append to the particle file module subroutine io_dump_base (self, param) Interface → Author David A. Minton Dump massive body data to files Read more… Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(inout) :: self Swiftest base object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters module subroutine io_dump_system (self, param) Interface → Author David A. Minton Dumps the state of the system to files in case the simulation is interrupted.\n As a safety mechanism, there are two dump files that are written in alternating order\n so that if a dump file gets corrupted during writing, the user can restart from the older one. Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters module subroutine io_param_reader (self, unit, iotype, v_list, iostat, iomsg) Interface → Author The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott Read in parameters for the integration\n Currently this procedure does not work in user-defined derived-type input mode \n    e.g. read(unit,'(DT)') param \n as the newline characters are ignored in the input file when compiled in ifort. Read more… Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Collection of parameters integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) The first element passes the integrator code to the reader integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 module subroutine io_param_writer (self, unit, iotype, v_list, iostat, iomsg) Interface → Author David A. Minton Dump integration parameters to file Read more… Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: self Collection of parameters integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) Not used in this procedure integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 module subroutine io_read_in_body (self, param) Interface → Author The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott Read in either test particle or massive body data Read more… Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest particle object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters module subroutine io_read_in_cb (self, param) Interface → Author David A. Minton Reads in central body data Read more… Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(inout) :: self class( swiftest_parameters ), intent(inout) :: param module subroutine io_read_in_param (self, param_file_name) Interface → Author David A. Minton Read in parameters for the integration Read more… Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(inout) :: self Current run configuration parameters character(len=*), intent(in) :: param_file_name Parameter input file name (i.e. param.in) module subroutine io_read_in_particle_info (self, iu) Interface → Author David A. Minton Reads in particle information object information from an open file unformatted file Arguments Type Intent Optional Attributes Name class( swiftest_particle_info ), intent(inout) :: self Particle metadata information object integer(kind=I4B), intent(in) :: iu Open file unit number module subroutine io_read_particle_info_system (self, param) Interface → Author David A. Minton Reads an old particle information file for a restartd run Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters module subroutine io_toupper (string) Interface → Author David A. Minton Convert string to uppercase Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string String to make upper case module subroutine io_write_discard (self, param) Interface → Author David A. Minton Write out information about discarded test particle Read more… Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters module subroutine io_write_encounter (self, pl, encbody, param) Interface → Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(in) :: self Swiftest encounter list object class( swiftest_pl ), intent(in) :: pl Swiftest massive body object class( swiftest_body ), intent(in) :: encbody Encountering body - Swiftest generic body object (pl or tp) class( swiftest_parameters ), intent(in) :: param Current run configuration parameters module subroutine io_write_frame_body (self, iu, param) Interface → Author David A. Minton Write a frame of output of either test particle or massive body data to the binary output file\n    Note: If outputting to orbital elements, but sure that the conversion is done prior to calling this method Read more… Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(in) :: self Swiftest particle object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters module subroutine io_write_frame_cb (self, iu, param) Interface → Author David A. Minton Write a frame of output of central body data to the binary output file Read more… Arguments Type Intent Optional Attributes Name class( swiftest_cb ), intent(in) :: self Swiftest central body object integer(kind=I4B), intent(inout) :: iu Unit number for the output file to write frame to class( swiftest_parameters ), intent(in) :: param Current run configuration parameters module subroutine io_write_frame_encounter (iu, t, id1, id2, Gmass1, Gmass2, radius1, radius2, xh1, xh2, vh1, vh2) Interface → Author David A. Minton Write a single frame of close encounter data to output binary files Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iu Open file unit number real(kind=DP), intent(in) :: t Time of encounter integer(kind=I4B), intent(in) :: id1 ids of the two encountering bodies integer(kind=I4B), intent(in) :: id2 ids of the two encountering bodies real(kind=DP), intent(in) :: Gmass1 G*mass of the two encountering bodies real(kind=DP), intent(in) :: Gmass2 G*mass of the two encountering bodies real(kind=DP), intent(in) :: radius1 Radii of the two encountering bodies real(kind=DP), intent(in) :: radius2 Radii of the two encountering bodies real(kind=DP), intent(in), dimension(:) :: xh1 Heliocentric position vectors of the two encountering bodies real(kind=DP), intent(in), dimension(:) :: xh2 Heliocentric position vectors of the two encountering bodies real(kind=DP), intent(in), dimension(:) :: vh1 Heliocentric velocity vectors of the two encountering bodies real(kind=DP), intent(in), dimension(:) :: vh2 Heliocentric velocity vectors of the two encountering bodies module subroutine io_write_frame_system (self, param) Interface → Author The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott Write a frame (header plus records for each massive body and active test particle) to output binary file\n There is no direct file output from this subroutine Read more… Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters module subroutine io_write_hdr_system (self, iu, param) Interface → Author The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott Write frame header to output binary file Read more… Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest nbody system object integer(kind=I4B), intent(inout) :: iu Output file unit number class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"module/s_io.html"},{"title":"s_setup – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_setup~~UsesGraph module~s_setup s_setup module~swiftest swiftest module~s_setup->module~swiftest module~swiftest_classes swiftest_classes module~s_setup->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines setup_construct_system setup_encounter setup_initialize_particle_info_system setup_initialize_system setup_body setup_pl setup_tp Module Subroutines module subroutine setup_construct_system (system, param) Interface → Author David A. Minton Constructor for a Swiftest nbody system. Creates the nbody system object based on the user-input integrator Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout), allocatable :: system Swiftest system object class( swiftest_parameters ), intent(inout) :: param Swiftest parameters module subroutine setup_encounter (self, n) Interface → Author David A. Minton A constructor that sets the number of encounters and allocates and initializes all arrays Arguments Type Intent Optional Attributes Name class( swiftest_encounter ), intent(inout) :: self Swiftest encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for module subroutine setup_initialize_particle_info_system (self, param) Interface → Author David A. Minton Setup up particle information metadata from initial conditions Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters module subroutine setup_initialize_system (self, param) Interface → Author David A. Minton Wrapper method to initialize a basic Swiftest nbody system from files Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(inout) :: self Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters module subroutine setup_body (self, n, param) Interface → Author David A. Minton Constructor for base Swiftest particle class. Allocates space for all particles and\n initializes all components with a value.\n Note: Timing tests indicate that (NDIM, n) is more efficient than (NDIM, n) Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest generic body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter module subroutine setup_pl (self, n, param) Interface → Author David A. Minton Constructor for base Swiftest massive body class. Allocates space for all particles and\n initializes all components with a value. \n Call allocation method for parent class\n The parent class here is the abstract swiftest_body class, so we can't use the type-bound procedure Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(inout) :: self Swiftest massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter module subroutine setup_tp (self, n, param) Interface → Author David A. Minton Constructor for base Swiftest test particle particle class. Allocates space for \n all particles and initializes all components with a value. \n Call allocation method for parent class\n The parent class here is the abstract swiftest_body class, so we can't use the type-bound procedure Arguments Type Intent Optional Attributes Name class( swiftest_tp ), intent(inout) :: self Swiftest test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter","tags":"","loc":"module/s_setup.html"},{"title":"s_user_kick_getacch – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~s_user_kick_getacch~~UsesGraph module~s_user_kick_getacch s_user_kick_getacch module~swiftest swiftest module~s_user_kick_getacch->module~swiftest module~swiftest_classes swiftest_classes module~s_user_kick_getacch->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines user_kick_getacch_body Module Subroutines module subroutine user_kick_getacch_body (self, system, param, t, lbeg) Interface → Author David A. Minton Add user-supplied heliocentric accelerations to planets. Read more… Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest massive body particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody_system_object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters user parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the ste","tags":"","loc":"module/s_user_kick_getacch.html"},{"title":"drift_implementation – swiftest","text":"Uses swiftest Ancestors: swiftest_classes module~~drift_implementation~~UsesGraph module~drift_implementation drift_implementation module~swiftest swiftest module~drift_implementation->module~swiftest module~swiftest_classes swiftest_classes module~drift_implementation->module~swiftest_classes module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables E2MAX DM2MAX E2DM2MAX DANBYB NLAG1 NLAG2 Subroutines drift_dan drift_kepmd drift_kepu drift_kepu_fchk drift_kepu_guess drift_kepu_lag drift_kepu_new drift_kepu_p3solve drift_kepu_stumpff Module Subroutines drift_body drift_all drift_one Variables Type Visibility Attributes Name Initial real(kind=DP), private, parameter :: E2MAX = 0.36_DP Integration control parameters: real(kind=DP), private, parameter :: DM2MAX = 0.16_DP real(kind=DP), private, parameter :: E2DM2MAX = 0.0016_DP real(kind=DP), private, parameter :: DANBYB = 1.0E-13_DP integer(kind=I2B), private, parameter :: NLAG1 = 50 integer(kind=I2B), private, parameter :: NLAG2 = 40 Subroutines pure subroutine drift_dan (mu, x0, v0, dt0, iflag) Author David A. Minton Perform Kepler drift, solving Kepler's equation in appropriate variables Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu real(kind=DP), intent(inout), dimension(:) :: x0 real(kind=DP), intent(inout), dimension(:) :: v0 real(kind=DP), intent(in) :: dt0 integer(kind=I4B), intent(out) :: iflag pure subroutine drift_kepmd (dm, es, ec, x, s, c) Author David A. Minton Solve Kepler's equation in difference form for an ellipse for small input dm and eccentricity\n    Original disclaimer: built for speed, does not check how well the original equation is solved\n    Can do that in calling routine by checking how close (x - ec s + es (1.0 - c) - dm) is to zero Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dm real(kind=DP), intent(in) :: es real(kind=DP), intent(in) :: ec real(kind=DP), intent(out) :: x real(kind=DP), intent(out) :: s real(kind=DP), intent(out) :: c pure subroutine drift_kepu (dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Author David A. Minton Solve Kepler's equation in universal variables Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: fp real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 integer(kind=I4B), intent(out) :: iflag pure subroutine drift_kepu_fchk (dt, r0, mu, alpha, u, s, f) Author David A. Minton Computes the value of f, the function whose root we are trying to find in universal variables Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(in) :: s real(kind=DP), intent(out) :: f pure subroutine drift_kepu_guess (dt, r0, mu, alpha, u, s) Author David A. Minton Compute initial guess for solving Kepler's equation using universal variables Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: s pure subroutine drift_kepu_lag (s, dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Author David A. Minton Solve Kepler's equation in universal variables using Laguerre's method\n      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 178 - 180. Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout) :: s real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: fp real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 integer(kind=I4B), intent(out) :: iflag pure subroutine drift_kepu_new (s, dt, r0, mu, alpha, u, fp, c1, c2, c3, iflag) Author David A. Minton Solve Kepler's equation in universal variables using Newton's method\n      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 174 - 175. Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout) :: s real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: fp real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 integer(kind=I4B), intent(out) :: iflag pure subroutine drift_kepu_p3solve (dt, r0, mu, alpha, u, s, iflag) Author David A. Minton Computes real root of cubic involved in setting initial guess for solving Kepler's equation in universal variables\n      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 177 - 178. Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: dt real(kind=DP), intent(in) :: r0 real(kind=DP), intent(in) :: mu real(kind=DP), intent(in) :: alpha real(kind=DP), intent(in) :: u real(kind=DP), intent(out) :: s integer(kind=I4B), intent(out) :: iflag pure subroutine drift_kepu_stumpff (x, c0, c1, c2, c3) Author David A. Minton Compute Stumpff functions needed for Kepler drift in universal variables\n      Reference: Danby, J. M. A. 1988. Fundamentals of Celestial Mechanics, (Willmann-Bell, Inc.), 171 - 172. Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout) :: x real(kind=DP), intent(out) :: c0 real(kind=DP), intent(out) :: c1 real(kind=DP), intent(out) :: c2 real(kind=DP), intent(out) :: c3 Module Subroutines module subroutine drift_body (self, system, param, dt) Interface → Author David A. Minton Loop bodies and call Danby drift routine on the heliocentric position and velocities. Read more… Arguments Type Intent Optional Attributes Name class( swiftest_body ), intent(inout) :: self Swiftest test particle data structure class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize module subroutine drift_all (mu, x, v, n, param, dt, lmask, iflag) Interface → Author David A. Minton Loop bodies and call Danby drift routine on all bodies for the given position and velocity vector. Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: mu Vector of gravitational constants real(kind=DP), intent(inout), dimension(:,:) :: x Position and velocity vectors real(kind=DP), intent(inout), dimension(:,:) :: v Position and velocity vectors integer(kind=I4B), intent(in) :: n number of bodies class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize logical, intent(in), dimension(:) :: lmask Logical mask of size self%nbody that determines which bodies to drift. integer(kind=I4B), intent(out), dimension(:) :: iflag Vector of error flags. 0 means no problem pure elemental module subroutine drift_one (mu, px, py, pz, vx, vy, vz, dt, iflag) Interface → Author The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott Perform Danby drift for one body, redoing drift with smaller substeps if original accuracy is insufficient Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: mu G * (Mcb + m), G = gravitational constant, Mcb = mass of central body, m = mass of body to drift real(kind=DP), intent(inout) :: px Position and velocity of body to drift real(kind=DP), intent(inout) :: py Position and velocity of body to drift real(kind=DP), intent(inout) :: pz Position and velocity of body to drift real(kind=DP), intent(inout) :: vx Position and velocity of body to drift real(kind=DP), intent(inout) :: vy Position and velocity of body to drift real(kind=DP), intent(inout) :: vz Position and velocity of body to drift real(kind=DP), intent(in) :: dt Step size integer(kind=I4B), intent(out) :: iflag iflag : error status flag for Danby drift (0 = OK, nonzero = ERROR)","tags":"","loc":"module/drift_implementation.html"},{"title":"s_symba_util – swiftest","text":"Uses swiftest Ancestors: symba_classes module~~s_symba_util~~UsesGraph module~s_symba_util s_symba_util module~swiftest swiftest module~s_symba_util->module~swiftest module~symba_classes symba_classes module~s_symba_util->module~symba_classes module~swiftest->module~symba_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines symba_util_append_arr_kin symba_util_append_encounter symba_util_append_pl symba_util_append_merger symba_util_append_tp symba_util_copy_encounter symba_util_fill_arr_kin symba_util_fill_pl symba_util_fill_tp symba_util_index_eucl_plpl symba_util_peri_pl symba_util_rearray_pl symba_util_reset_kinship symba_util_resize_arr_kin symba_util_resize_merger symba_util_resize_pl symba_util_resize_tp symba_util_sort_pl symba_util_sort_tp symba_util_sort_rearrange_arr_kin symba_util_sort_rearrange_pl symba_util_sort_rearrange_tp symba_util_spill_arr_kin symba_util_spill_pl symba_util_spill_encounter symba_util_spill_tp Module Subroutines subroutine symba_util_append_arr_kin (arr, source, nold, nsrc, lsource_mask) Author David A. Minton Append a single array of kinship type onto another. If the destination array is not allocated, or is not big enough, this will allocate space for it. Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: arr Destination array type( symba_kinship ), intent(in), dimension(:), allocatable :: source Array to append integer(kind=I4B), intent(in) :: nold Extend of the old array and the source array, respectively integer(kind=I4B), intent(in) :: nsrc Extend of the old array and the source array, respectively logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to module subroutine symba_util_append_encounter (self, source, lsource_mask) Interface → Author David A. Minton Append components from one encounter list (pl-pl or pl-tp) body object to another. \n This method will automatically resize the destination body if it is too small Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA encounter list object class( swiftest_encounter ), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to module subroutine symba_util_append_pl (self, source, lsource_mask) Interface → Author David A. Minton Append components from one massive body object to another. \n This method will automatically resize the destination body if it is too small\n Arguments Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to module subroutine symba_util_append_merger (self, source, lsource_mask) Interface → Author David A. Minton Append components from one massive body object to another. \n This method will automatically resize the destination body if it is too small Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to module subroutine symba_util_append_tp (self, source, lsource_mask) Interface → Author David A. Minton Append components from test particle object to another. \n This method will automatically resize the destination body if it is too small\n Arguments Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to module subroutine symba_util_copy_encounter (self, source) Interface → Author David A. Minton Copies elements from the source encounter list into self. Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self Encounter list class( swiftest_encounter ), intent(in) :: source Source object to copy into subroutine symba_util_fill_arr_kin (keeps, inserts, lfill_list) Author David A. Minton Performs a fill operation on a single array of particle kinship types\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_kinship ), intent(in), dimension(:), allocatable :: inserts Array of values to insert into keep logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps module subroutine symba_util_fill_pl (self, inserts, lfill_list) Interface → Author David A. Minton Insert new SyMBA test particle structure into an old one. \n This is the inverse of a fill operation. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA masive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps module subroutine symba_util_fill_tp (self, inserts, lfill_list) Interface → Author David A. Minton Insert new SyMBA test particle structure into an old one. \n This is the inverse of a fill operation. Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps module subroutine symba_util_index_eucl_plpl (self, param) Interface → Author Jacob R. Elliott and David A. Minton Turns i,j indices into k index for use in the Euclidean distance matrix. This also sets the lmtiny flag and computes the\n number of interactions that excludes semi-interacting bodies with each other (Gmass < GMTINY).\n This method will also sort the bodies in descending order by Mass Read more… Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters module subroutine symba_util_peri_pl (self, system, param) Interface → Author David A. Minton Determine system pericenter passages for planets in SyMBA Read more… Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters module subroutine symba_util_rearray_pl (self, system, param) Interface → Author the Purdue Swiftest Team -  David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott Clean up the massive body structures to remove discarded bodies and add new bodies Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class( symba_nbody_system ), intent(inout) :: system Swiftest nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters module subroutine symba_util_reset_kinship (self, idx) Interface → Author David A. Minton Resets the kinship status of bodies. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: idx Index array of bodies to reset subroutine symba_util_resize_arr_kin (arr, nnew) Author David A. Minton Resizes an array component of type character string. Array will only be resized if has previously been allocated. Passing nnew = 0 will deallocate. Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: arr Array to resize integer(kind=I4B), intent(in) :: nnew New size module subroutine symba_util_resize_merger (self, nnew) Interface → Author David A. Minton Checks the current size of a SyMBA merger list against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: nnew New size neded module subroutine symba_util_resize_pl (self, nnew) Interface → Author David A. Minton Checks the current size of a SyMBA massive body object against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: nnew New size neded module subroutine symba_util_resize_tp (self, nnew) Interface → Author David A. Minton Checks the current size of a test particle object against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object integer(kind=I4B), intent(in) :: nnew New size neded module subroutine symba_util_sort_pl (self, sortby, ascending) Interface → Author David A. Minton Sort a SyMBA massive body object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order module subroutine symba_util_sort_tp (self, sortby, ascending) Interface → Author David A. Minton Sort a SyMBA test particle object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order subroutine symba_util_sort_rearrange_arr_kin (arr, ind, n) Author David A. Minton Rearrange a single array of particle kinship type in-place from an index list. Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: arr Destination array integer(kind=I4B), intent(in), dimension(:) :: ind Index to rearrange against integer(kind=I4B), intent(in) :: n Number of elements in arr and ind to rearrange module subroutine symba_util_sort_rearrange_pl (self, ind) Interface → Author David A. Minton Rearrange SyMBA massive body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) module subroutine symba_util_sort_rearrange_tp (self, ind) Interface → Author David A. Minton Rearrange SyMBA test particle object in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) subroutine symba_util_spill_arr_kin (keeps, discards, lspill_list, ldestructive) Author David A. Minton Performs a spill operation on a single array of particle kinships\n This is the inverse of a spill operation Arguments Type Intent Optional Attributes Name type( symba_kinship ), intent(inout), dimension(:), allocatable :: keeps Array of values to keep type( symba_kinship ), intent(inout), dimension(:), allocatable :: discards Array of discards logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discardss logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not module subroutine symba_util_spill_pl (self, discards, lspill_list, ldestructive) Interface → Author David A. Minton Move spilled (discarded) SyMBA massive body particle structure from active list to discard list\n Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90\n Spill all the common components Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list module subroutine symba_util_spill_encounter (self, discards, lspill_list, ldestructive) Interface → Author David A. Minton Move spilled (discarded) SyMBA encounter structure from active list to discard list\n Note: Because the symba_plplenc currently does not contain any additional variable components, this method can recieve it as an input as well. Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-tp encounter list class( swiftest_encounter ), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list module subroutine symba_util_spill_tp (self, discards, lspill_list, ldestructive) Interface → Author David A. Minton Move spilled (discarded) SyMBA test particle structure from active list to discard list\n Adapted from David E. Kaufmann's Swifter routine whm_discard_spill.f90\n Spill all the common components Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter body by removing the discard list","tags":"","loc":"module/s_symba_util.html"},{"title":"s_symba_collision – swiftest","text":"Uses swiftest Ancestors: symba_classes module~~s_symba_collision~~UsesGraph module~s_symba_collision s_symba_collision module~swiftest swiftest module~s_symba_collision->module~swiftest module~symba_classes symba_classes module~s_symba_collision->module~symba_classes module~swiftest->module~symba_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions symba_collision_check_one symba_collision_consolidate_colliders Subroutines symba_collision_collider_message symba_collision_mergeaddsub Module Functions symba_collision_casedisruption symba_collision_casehitandrun symba_collision_casemerge symba_collision_check_encounter Module Subroutines symba_collision_encounter_extract_collisions symba_collision_make_colliders_pl symba_collision_resolve_fragmentations symba_collision_resolve_mergers symba_collision_resolve_plplenc symba_collision_resolve_pltpenc Functions pure elemental function symba_collision_check_one (xr, yr, zr, vxr, vyr, vzr, Gmtot, rlim, dt, lvdotr) result(lcollision) Author David A. Minton Check for a merger between a single pair of particles Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: xr Relative position vector components real(kind=DP), intent(in) :: yr Relative position vector components real(kind=DP), intent(in) :: zr Relative position vector components real(kind=DP), intent(in) :: vxr Relative velocity vector components real(kind=DP), intent(in) :: vyr Relative velocity vector components real(kind=DP), intent(in) :: vzr Relative velocity vector components real(kind=DP), intent(in) :: Gmtot Sum of G*mass of colliding bodies real(kind=DP), intent(in) :: rlim Collision limit - Typically the sum of the radii of colliding bodies real(kind=DP), intent(in) :: dt Step size logical, intent(in) :: lvdotr Logical flag indicating that these two bodies are approaching in the current substep Return Value logical Logical flag indicating whether these two bodies will collide or not function symba_collision_consolidate_colliders (pl, cb, param, idx_parent, colliders) result(lflag) Author David A. Minton Loops through the pl-pl collision list and groups families together by index. Outputs the indices of all colliders%idx members, \n and pairs of quantities (x and v vectors, mass, radius, L_spin, and Ip) that can be used to resolve the collisional outcome. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl SyMBA massive body object class( symba_cb ), intent(inout) :: cb SyMBA central body object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions integer(kind=I4B), intent(inout), dimension(2) :: idx_parent Index of the two bodies considered the \"parents\" of the collision class( fraggle_colliders ), intent(out) :: colliders Return Value logical Logical flag indicating whether a colliders%idx was successfully created or not Subroutines subroutine symba_collision_collider_message (pl, collidx, collider_message) Author David A. Minton Prints a nicely formatted message about which bodies collided, including their names and ids.\n This subroutine appends the body names and ids to an input message. Arguments Type Intent Optional Attributes Name class(swiftest_pl), intent(in) :: pl Swiftest massive body object integer(kind=I4B), intent(in), dimension(:) :: collidx Index of collisional colliders%idx members character(len=*), intent(inout) :: collider_message The message to print to the screen. subroutine symba_collision_mergeaddsub (system, param, colliders, frag, status) Author David A. Minton Fills the pl_discards and pl_adds with removed and added bodies Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions class( fraggle_colliders ), intent(inout) :: colliders Fraggle colliders object class( fraggle_fragments ), intent(inout) :: frag Fraggle fragmentation system object integer(kind=I4B), intent(in) :: status Status flag to assign to adds Module Functions module function symba_collision_casedisruption (system, param, colliders, frag) result(status) Interface → Author Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton Create the fragments resulting from a non-catastrophic disruption collision Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions class( fraggle_colliders ), intent(inout) :: colliders Fraggle colliders object class( fraggle_fragments ), intent(inout) :: frag Fraggle fragmentation system object Return Value integer(kind=I4B) Status flag assigned to this outcome module function symba_collision_casehitandrun (system, param, colliders, frag) result(status) Interface → Author Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton Create the fragments resulting from a non-catastrophic hit-and-run collision Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions class( fraggle_colliders ), intent(inout) :: colliders Fraggle colliders object class( fraggle_fragments ), intent(inout) :: frag Fraggle fragmentation system object Return Value integer(kind=I4B) Status flag assigned to this outcom module function symba_collision_casemerge (system, param, colliders, frag) result(status) Interface → Author Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton Merge massive bodies. Read more… Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions class( fraggle_colliders ), intent(inout) :: colliders Fraggle colliders object class( fraggle_fragments ), intent(inout) :: frag Fraggle fragmentation system object Return Value integer(kind=I4B) Status flag assigned to this outcome module function symba_collision_check_encounter (self, system, param, t, dt, irec) result(lany_collision) Interface → Author David A. Minton Check for merger between massive bodies and test particles in SyMBA Read more… Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t current time real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if cany pair of encounters resulted in a collision Module Subroutines module subroutine symba_collision_encounter_extract_collisions (self, system, param) Interface → Author David A. Minton Processes the pl-pl encounter list remove only those encounters that led to a collision Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters module subroutine symba_collision_make_colliders_pl (self, idx) Interface → Author Jennifer L.L. Pouplin, Carlisle A. wishard, and David A. Minton When a single body is involved in more than one collision in a single step, it becomes part of a colliders%idx.\n The largest body involved in a multi-body collision is the \"parent\" and all bodies that collide with it are its \"children,\"\n including those that collide with the children. Read more… Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in), dimension(2) :: idx Array holding the indices of the two bodies involved in the collision module subroutine symba_collision_resolve_fragmentations (self, system, param) Interface → Author David A. Minton Process list of collisions, determine the collisional regime, and then create fragments. Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions module subroutine symba_collision_resolve_mergers (self, system, param) Interface → Author David A. Minton Process list of collisions and merge colliding bodies together. Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions module subroutine symba_collision_resolve_plplenc (self, system, param, t, dt, irec) Interface → Author David A. Minton Process the pl-pl collision list, then modifiy the massive bodies based on the outcome of the collision Arguments Type Intent Optional Attributes Name class( symba_plplenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current simulation step size integer(kind=I4B), intent(in) :: irec Current recursion level module subroutine symba_collision_resolve_pltpenc (self, system, param, t, dt, irec) Interface → Author David A. Minton Process the pl-tp collision list, then modifiy the massive bodies based on the outcome of the collision Arguments Type Intent Optional Attributes Name class( symba_pltpenc ), intent(inout) :: self SyMBA pl-pl encounter list class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters with SyMBA additions real(kind=DP), intent(in) :: t Current simulation tim real(kind=DP), intent(in) :: dt Current simulation step size integer(kind=I4B), intent(in) :: irec Current recursion level","tags":"","loc":"module/s_symba_collision.html"},{"title":"s_symba_setup – swiftest","text":"Uses swiftest Ancestors: symba_classes module~~s_symba_setup~~UsesGraph module~s_symba_setup s_symba_setup module~swiftest swiftest module~s_symba_setup->module~swiftest module~symba_classes symba_classes module~s_symba_setup->module~symba_classes module~swiftest->module~symba_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines symba_setup_initialize_system symba_setup_merger symba_setup_pl symba_setup_encounter symba_setup_tp Module Subroutines module subroutine symba_setup_initialize_system (self, param) Interface → Author David A. Minton Initialize an SyMBA nbody system from files and sets up the planetocentric structures.\n This subroutine will also sort the massive bodies in descending order by mass Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters module subroutine symba_setup_merger (self, n, param) Interface → Author David A. Minton Allocate SyMBA test particle structure Read more… Arguments Type Intent Optional Attributes Name class( symba_merger ), intent(inout) :: self SyMBA merger list object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter module subroutine symba_setup_pl (self, n, param) Interface → Author David A. Minton Allocate SyMBA test particle structure Read more… Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter module subroutine symba_setup_encounter (self, n) Interface → Author David A. Minton A constructor that sets the number of encounters and allocates and initializes all arrays Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-tp encounter structure integer(kind=I4B), intent(in) :: n Number of encounters to allocate space for module subroutine symba_setup_tp (self, n, param) Interface → Author David A. Minton Allocate WHM test particle structure Read more… Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class( swiftest_parameters ), intent(in) :: param Current run configuration parameter","tags":"","loc":"module/s_symba_setup.html"},{"title":"s_symba_kick – swiftest","text":"Uses swiftest Ancestors: symba_classes module~~s_symba_kick~~UsesGraph module~s_symba_kick s_symba_kick module~swiftest swiftest module~s_symba_kick->module~swiftest module~symba_classes symba_classes module~s_symba_kick->module~symba_classes module~swiftest->module~symba_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines symba_kick_getacch_int_pl symba_kick_getacch_pl symba_kick_getacch_tp symba_kick_encounter Module Subroutines module subroutine symba_kick_getacch_int_pl (self) Interface → Author David A. Minton Compute direct cross (third) term heliocentric accelerations of massive bodies, with no mutual interactions between bodies below GMTINY Read more… Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self module subroutine symba_kick_getacch_pl (self, system, param, t, lbeg) Interface → Author David A. Minton Compute heliocentric accelerations of massive bodies Read more… Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA massive body particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step module subroutine symba_kick_getacch_tp (self, system, param, t, lbeg) Interface → Author David A. Minton Compute heliocentric accelerations of test particles Read more… Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step module subroutine symba_kick_encounter (self, system, dt, irec, sgn) Interface → Author David A. Minton Kick barycentric velocities of massive bodies and ACTIVE test particles within SyMBA recursion.\n Note: This method works for the polymorphic symba_pltpenc and symba_plplenc types Read more… Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(in) :: self SyMBA pl-tp encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level integer(kind=I4B), intent(in) :: sgn sign to be applied to acceleration","tags":"","loc":"module/s_symba_kick.html"},{"title":"s_symba_encounter_check – swiftest","text":"Uses swiftest Ancestors: symba_classes module~~s_symba_encounter_check~~UsesGraph module~s_symba_encounter_check s_symba_encounter_check module~swiftest swiftest module~s_symba_encounter_check->module~swiftest module~symba_classes symba_classes module~s_symba_encounter_check->module~symba_classes module~swiftest->module~symba_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines symba_encounter_check_all Module Functions symba_encounter_check_pl symba_encounter_check symba_encounter_check_tp Module Subroutines symba_encounter_check_one Subroutines subroutine symba_encounter_check_all (nplplm, k_plpl, x, v, rhill, dt, irec, lencounter, loc_lvdotr) Author David A. Minton Check for encounters between massive bodies. Split off from the main subroutine for performance Arguments Type Intent Optional Attributes Name integer(kind=I8B), intent(in) :: nplplm integer(kind=I4B), intent(in), dimension(:,:) :: k_plpl real(kind=DP), intent(in), dimension(:,:) :: x real(kind=DP), intent(in), dimension(:,:) :: v real(kind=DP), intent(in), dimension(:) :: rhill real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: irec logical, intent(out), dimension(:) :: lencounter logical, intent(out), dimension(:) :: loc_lvdotr Module Functions module function symba_encounter_check_pl (self, system, dt, irec) result(lany_encounter) Interface → Author David A. Minton Check for an encounter between massive bodies. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter module function symba_encounter_check (self, system, dt, irec) result(lany_encounter) Interface → Author David A. Minton Check for an encounter between test particles and massive bodies in the pltpenc list.\n Note: This method works for the polymorphic symba_pltpenc and symba_plplenc types. Read more… Arguments Type Intent Optional Attributes Name class( symba_encounter ), intent(inout) :: self SyMBA pl-pl encounter list object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter module function symba_encounter_check_tp (self, system, dt, irec) result(lany_encounter) Interface → Author David A. Minton Check for an encounter between test particles and massive bodies. Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object real(kind=DP), intent(in) :: dt step size integer(kind=I4B), intent(in) :: irec Current recursion level Return Value logical Returns true if there is at least one close encounter Module Subroutines pure module subroutine symba_encounter_check_one (xr, yr, zr, vxr, vyr, vzr, rhill1, rhill2, dt, irec, lencounter, lvdotr) Interface → Author David A. Minton Check for an encounter. Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: xr real(kind=DP), intent(in) :: yr real(kind=DP), intent(in) :: zr real(kind=DP), intent(in) :: vxr real(kind=DP), intent(in) :: vyr real(kind=DP), intent(in) :: vzr real(kind=DP), intent(in) :: rhill1 real(kind=DP), intent(in) :: rhill2 real(kind=DP), intent(in) :: dt integer(kind=I4B), intent(in) :: irec logical, intent(out) :: lencounter logical, intent(out) :: lvdotr","tags":"","loc":"module/s_symba_encounter_check.html"},{"title":"s_symba_io – swiftest","text":"Uses swiftest Ancestors: symba_classes module~~s_symba_io~~UsesGraph module~s_symba_io s_symba_io module~swiftest swiftest module~s_symba_io->module~swiftest module~symba_classes symba_classes module~s_symba_io->module~symba_classes module~swiftest->module~symba_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines symba_io_param_reader symba_io_param_writer symba_io_write_discard Module Subroutines module subroutine symba_io_param_reader (self, unit, iotype, v_list, iostat, iomsg) Interface → Author The Purdue Swiftest Team - David A. Minton, Carlisle A. Wishard, Jennifer L.L. Pouplin, and Jacob R. Elliott Read in parameters specific to the SyMBA integrator, then calls the base io_param_reader. Read more… Arguments Type Intent Optional Attributes Name class( symba_parameters ), intent(inout) :: self Collection of parameters integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) The first element passes the integrator code to the reader integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 module subroutine symba_io_param_writer (self, unit, iotype, v_list, iostat, iomsg) Interface → Author David A. Minton Dump integration parameters specific to SyMBA to file and then call the base io_param_writer method. Read more… Arguments Type Intent Optional Attributes Name class( symba_parameters ), intent(in) :: self Collection of SyMBA parameters integer, intent(in) :: unit File unit number character(len=*), intent(in) :: iotype Dummy argument passed to the  input/output procedure contains the text from the char-literal-constant, prefixed with DT. \n    If you do not include a char-literal-constant, the iotype argument contains only DT. integer, intent(in) :: v_list (:) Not used in this procedure integer, intent(out) :: iostat IO status code character(len=*), intent(inout) :: iomsg Message to pass if iostat /= 0 module subroutine symba_io_write_discard (self, param) Interface → Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"module/s_symba_io.html"},{"title":"s_symba_discard – swiftest","text":"Uses swiftest Ancestors: symba_classes module~~s_symba_discard~~UsesGraph module~s_symba_discard s_symba_discard module~swiftest swiftest module~s_symba_discard->module~swiftest module~symba_classes symba_classes module~s_symba_discard->module~symba_classes module~swiftest->module~symba_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines symba_discard_cb_pl symba_discard_conserve_mtm symba_discard_nonplpl symba_discard_nonplpl_conservation symba_discard_peri_pl Module Subroutines symba_discard_pl Subroutines subroutine symba_discard_cb_pl (pl, system, param) Author David A. Minton Check to see if planets should be discarded based on their positions relative to the central body.\n If a body gets flagged here when it has also been previously flagged for a collision with another massive body,\n its collisional status will be revoked. Discards due to colliding with or escaping the central body take precedence \n over pl-pl collisions Read more… Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl SyMBA massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters subroutine symba_discard_conserve_mtm (pl, system, param, ipl, lescape_body) Author David A. Minton Conserves system momentum when a body is lost from the system or collides with central body Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl class( symba_nbody_system ), intent(inout) :: system class( symba_parameters ), intent(inout) :: param integer(kind=I4B), intent(in) :: ipl logical, intent(in) :: lescape_body subroutine symba_discard_nonplpl (pl, system, param) Author David A. Minton Check to see if planets should be discarded based on their positions or because they are unbound Read more… Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl SyMBA test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters subroutine symba_discard_nonplpl_conservation (pl, system, param) Author David A. Minton If there are any bodies that are removed due to either colliding with the central body or escaping the systme,\n we need to track the conserved quantities with the system bookkeeping terms. Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl SyMBA test particle object class( symba_nbody_system ), intent(inout) :: system SyMBA nbody system object class( symba_parameters ), intent(inout) :: param Current run configuration parameters subroutine symba_discard_peri_pl (pl, system, param) Author David A. Minton Check to see if a test particle should be discarded because its perihelion distance becomes too small Read more… Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: pl SyMBA massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters Module Subroutines module subroutine symba_discard_pl (self, system, param) Interface → Author David A. Minton Call the various flavors of discards for massive bodies in SyMBA runs, including discards due to colliding with the central body or escaping the system Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self SyMBA test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters","tags":"","loc":"module/s_symba_discard.html"},{"title":"s_symba_step – swiftest","text":"Uses swiftest Ancestors: symba_classes module~~s_symba_step~~UsesGraph module~s_symba_step s_symba_step module~swiftest swiftest module~s_symba_step->module~swiftest module~symba_classes symba_classes module~s_symba_step->module~symba_classes module~swiftest->module~symba_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines symba_step_system symba_step_interp_system symba_step_set_recur_levels_system symba_step_recur_system symba_step_reset_system Module Subroutines module subroutine symba_step_system (self, param, t, dt) Interface → Author David A. Minton Step planets and active test particles ahead in democratic heliocentric coordinates, descending the recursive\n   branch if necessary to handle possible close encounters Read more… Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize module subroutine symba_step_interp_system (self, param, t, dt) Interface → Author David A. Minton Step planets and active test particles ahead in democratic heliocentric coordinates, calling the recursive\n         subroutine to descend to the appropriate level to handle close encounters Read more… Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize module subroutine symba_step_set_recur_levels_system (self, ireci) Interface → Author David A. Minton Resets pl, tp,and encounter structures at the start of a new step Read more… Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object integer(kind=I4B), intent(in) :: ireci Input recursion level recursive module subroutine symba_step_recur_system (self, param, t, ireci) Interface → Author David A. Minton Step interacting planets and active test particles ahead in democratic heliocentric coordinates at the current\n         recursion level, if applicable, and descend to the next deeper level if necessarys Read more… Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: ireci input recursion level module subroutine symba_step_reset_system (self, param) Interface → Author David A. Minton Resets pl, tp,and encounter structures at the start of a new step Read more… Arguments Type Intent Optional Attributes Name class( symba_nbody_system ), intent(inout) :: self SyMBA nbody system object class( symba_parameters ), intent(in) :: param Current run configuration parameters with SyMBA additions","tags":"","loc":"module/s_symba_step.html"},{"title":"s_symba_drift – swiftest","text":"Uses swiftest Ancestors: symba_classes module~~s_symba_drift~~UsesGraph module~s_symba_drift s_symba_drift module~swiftest swiftest module~s_symba_drift->module~swiftest module~symba_classes symba_classes module~s_symba_drift->module~symba_classes module~swiftest->module~symba_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines symba_drift_pl symba_drift_tp Module Subroutines module subroutine symba_drift_pl (self, system, param, dt) Interface → Author David A. Minton Wrapper function used to call the body drift routine from a symba_pl structure Arguments Type Intent Optional Attributes Name class( symba_pl ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize module subroutine symba_drift_tp (self, system, param, dt) Interface → Author David A. Minton Wrapper function used to call the body drift routine from a symba_pl structure Arguments Type Intent Optional Attributes Name class( symba_tp ), intent(inout) :: self Helio massive body object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: dt Stepsize","tags":"","loc":"module/s_symba_drift.html"},{"title":"s_netcdf – swiftest","text":"Uses swiftest netcdf Ancestors: swiftest_classes module~~s_netcdf~~UsesGraph module~s_netcdf s_netcdf module~swiftest swiftest module~s_netcdf->module~swiftest module~swiftest_classes swiftest_classes module~s_netcdf->module~swiftest_classes netcdf netcdf module~s_netcdf->netcdf module~swiftest->module~swiftest_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~swiftest_classes module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~swiftest_classes module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines check Module Subroutines netcdf_close netcdf_initialize_output netcdf_open netcdf_write_frame_base netcdf_write_particle_info_base netcdf_write_hdr_system Subroutines subroutine check (status) Author Carlisle A. Wishard, Dana Singh, and David A. Minton Checks the status of all NetCDF operations to catch errors Arguments Type Intent Optional Attributes Name integer, intent(in) :: status Module Subroutines module subroutine netcdf_close (self, param) Interface → Author Carlisle A. Wishard, Dana Singh, and David A. Minton Closes a NetCDF file Arguments Type Intent Optional Attributes Name class( netcdf_parameters ), intent(inout) :: self Parameters used to identify a particular NetCDF dataset class( swiftest_parameters ), intent(in) :: param Current run configuration parameters module subroutine netcdf_initialize_output (self, param) Interface → Author Carlisle A. Wishard, Dana Singh, and David A. Minton Initialize a NetCDF file system and defines all variables.\n Create the new output file, deleting any previously existing output file of the same name\n Define the variables Arguments Type Intent Optional Attributes Name class( netcdf_parameters ), intent(inout) :: self Parameters used to identify a particular NetCDF dataset class( swiftest_parameters ), intent(in) :: param Current run configuration parameters module subroutine netcdf_open (self, param) Interface → Author Carlisle A. Wishard, Dana Singh, and David A. Minton Opens a NetCDF file and does the variable inquiries to activate variable ids Arguments Type Intent Optional Attributes Name class( netcdf_parameters ), intent(inout) :: self Parameters used to identify a particular NetCDF dataset class( swiftest_parameters ), intent(in) :: param Current run configuration parameters module subroutine netcdf_write_frame_base (self, iu, param) Interface → Author Carlisle A. Wishard, Dana Singh, and David A. Minton Write a frame of output of either test particle or massive body data to the binary output file\n    Note: If outputting to orbital elements, but sure that the conversion is done prior to calling this method Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset class( swiftest_parameters ), intent(in) :: param Current run configuration parameters module subroutine netcdf_write_particle_info_base (self, iu) Interface → Author Carlisle A. Wishard, Dana Singh, and David A. Minton Write all current particle to file Arguments Type Intent Optional Attributes Name class( swiftest_base ), intent(in) :: self Swiftest particle object class( netcdf_parameters ), intent(inout) :: iu Parameters used to identify a particular NetCDF dataset module subroutine netcdf_write_hdr_system (self, iu, param) Interface → Author David A. Minton Writes header information (variables that change with time, but not particle id). \n This subroutine significantly improves the output over the original binary file, allowing us to track energy, momentum, and other quantities that \n previously were handled as separate output files. Arguments Type Intent Optional Attributes Name class( swiftest_nbody_system ), intent(in) :: self Swiftest nbody system object class( netcdf_parameters ), intent(inout) :: iu Parameters used to for writing a NetCDF dataset to file class( swiftest_parameters ), intent(in) :: param Current run configuration parameters","tags":"","loc":"module/s_netcdf.html"},{"title":"s_fraggle_util – swiftest","text":"Uses swiftest Ancestors: fraggle_classes module~~s_fraggle_util~~UsesGraph module~s_fraggle_util s_fraggle_util module~swiftest swiftest module~s_fraggle_util->module~swiftest module~fraggle_classes fraggle_classes module~s_fraggle_util->module~fraggle_classes module~swiftest->module~fraggle_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~fraggle_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Functions fraggle_util_vmag_to_vb Module Subroutines fraggle_util_add_fragments_to_system fraggle_util_ang_mtm fraggle_util_construct_temporary_system fraggle_util_get_energy_momentum fraggle_util_restructure fraggle_util_shift_vector_to_origin Module Functions module function fraggle_util_vmag_to_vb (v_r_mag, v_r_unit, v_t_mag, v_t_unit, m_frag, vcom) result(vb) Interface → Author David A. Minton Converts radial and tangential velocity magnitudes into barycentric velocity Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: v_r_mag Unknown radial component of fragment velocity vector real(kind=DP), intent(in), dimension(:,:) :: v_r_unit Radial and tangential unit vectors for each fragment real(kind=DP), intent(in), dimension(:) :: v_t_mag Tangential component of velocity vector set previously by angular momentum constraint real(kind=DP), intent(in), dimension(:,:) :: v_t_unit Radial and tangential unit vectors for each fragment real(kind=DP), intent(in), dimension(:) :: m_frag Fragment masses real(kind=DP), intent(in), dimension(:) :: vcom Barycentric velocity of collisional system center of mass Return Value real(kind=DP),\n  dimension(:,:), allocatable Module Subroutines module subroutine fraggle_util_add_fragments_to_system (frag, colliders, system, param) Interface → Author David A. Minton Adds fragments to the temporary system pl object Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(in) :: frag Fraggle fragment system object class( fraggle_colliders ), intent(in) :: colliders Fraggle collider system object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current swiftest run configuration parameters module subroutine fraggle_util_ang_mtm (self) Interface → Author David A. Minton Calcualtes the current angular momentum of the fragments Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object module subroutine fraggle_util_construct_temporary_system (frag, system, param, tmpsys, tmpparam) Interface → Author David A. Minton Constructs a temporary internal system consisting of active bodies and additional fragments. This internal temporary system is used to calculate system energy with and without fragments\n and optionally including fragments. Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(in) :: frag Fraggle fragment system object class( swiftest_nbody_system ), intent(in) :: system Original swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current swiftest run configuration parameters class( swiftest_nbody_system ), intent(out), allocatable :: tmpsys Output temporary swiftest nbody system object class( swiftest_parameters ), intent(out), allocatable :: tmpparam Output temporary configuration run parameters module subroutine fraggle_util_get_energy_momentum (self, colliders, system, param, lbefore) Interface → Author David A. Minton Calculates total system energy in either the pre-collision outcome state (lbefore = .true.) or the post-collision outcome state (lbefore = .false.)\n This subrourtine works by building a temporary internal massive body object out of the non-excluded bodies and optionally with fragments appended. \n This will get passed to the energy calculation subroutine so that energy is computed exactly the same way is it is in the main program. \n This will temporarily expand the massive body object in a temporary system object called tmpsys to feed it into symba_energy Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current swiftest run configuration parameters logical, intent(in) :: lbefore Flag indicating that this the \"before\" state of the system, with colliders included and fragments excluded or vice versa module subroutine fraggle_util_restructure (self, colliders, try, f_spin, r_max_start) Interface → Author David A. Minton Restructure the inputs after a failed attempt failed to find a set of positions and velocities that satisfy the energy and momentum constraints Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(in) :: colliders Fraggle collider system object integer(kind=I4B), intent(in) :: try The current number of times Fraggle has tried to find a solution real(kind=DP), intent(inout) :: f_spin Fraction of energy/momentum that goes into spin. This decreases ater a failed attempt real(kind=DP), intent(inout) :: r_max_start The maximum radial distance that the position calculation starts with. This increases after a failed attempt module subroutine fraggle_util_shift_vector_to_origin (m_frag, vec_frag) Interface → Author Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton Adjusts the position or velocity of the fragments as needed to align them with the origin Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), dimension(:) :: m_frag Fragment masses real(kind=DP), intent(inout), dimension(:,:) :: vec_frag Fragment positions or velocities in the center of mass frame","tags":"","loc":"module/s_fraggle_util.html"},{"title":"s_fraggle_io – swiftest","text":"Uses swiftest Ancestors: fraggle_classes module~~s_fraggle_io~~UsesGraph module~s_fraggle_io s_fraggle_io module~swiftest swiftest module~s_fraggle_io->module~swiftest module~fraggle_classes fraggle_classes module~s_fraggle_io->module~fraggle_classes module~swiftest->module~fraggle_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~fraggle_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines fraggle_io_log_generate fraggle_io_log_one_message fraggle_io_log_pl fraggle_io_log_regime fraggle_io_log_start Module Subroutines module subroutine fraggle_io_log_generate (frag) Interface → Author David A. Minton Writes a log of the results of the fragment generation Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(in) :: frag module subroutine fraggle_io_log_one_message (message) Interface → Author David A. Minton Writes a single message to the fraggle log file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message module subroutine fraggle_io_log_pl (pl, param) Interface → Author David A. Minton Writes a single message to the fraggle log file Arguments Type Intent Optional Attributes Name class( swiftest_pl ), intent(in) :: pl Swiftest massive body object (only the new bodies generated in a collision) class( swiftest_parameters ), intent(in) :: param Current swiftest run configuration parameters module subroutine fraggle_io_log_regime (colliders, frag) Interface → Author David A. Minton Writes a log of the results of the collisional regime determination Arguments Type Intent Optional Attributes Name class( fraggle_colliders ), intent(in) :: colliders Fraggle collider system object class( fraggle_fragments ), intent(in) :: frag Fraggle fragment object module subroutine fraggle_io_log_start (param) Interface → Author David A. Minton Checks to see if the Fraggle log file needs to be replaced if this is a new run, or appended if this is a restarted run Arguments Type Intent Optional Attributes Name class( swiftest_parameters ), intent(in) :: param","tags":"","loc":"module/s_fraggle_io.html"},{"title":"s_fraggle_generate – swiftest","text":"Uses swiftest Ancestors: fraggle_classes module~~s_fraggle_generate~~UsesGraph module~s_fraggle_generate s_fraggle_generate module~swiftest swiftest module~s_fraggle_generate->module~swiftest module~fraggle_classes fraggle_classes module~s_fraggle_generate->module~fraggle_classes module~swiftest->module~fraggle_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~fraggle_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables NFRAG_MIN F_SPIN_FIRST FRAGGLE_LTOL FRAGGLE_ETOL Subroutines fraggle_generate_pos_vec fraggle_generate_spins fraggle_generate_tan_vel fraggle_generate_rad_vel Module Subroutines fraggle_generate_fragments Variables Type Visibility Attributes Name Initial integer(kind=I4B), private, parameter :: NFRAG_MIN = 7 The minimum allowable number of fragments (set to 6 because that's how many unknowns are needed in the tangential velocity calculation) real(kind=DP), private, parameter :: F_SPIN_FIRST = 0.05_DP The initial try value of the fraction of energy or momenum in spin (whichever has the lowest kinetic energy) real(kind=DP), private, parameter :: FRAGGLE_LTOL = 10*epsilon(1.0_DP) real(kind=DP), private, parameter :: FRAGGLE_ETOL = 1e-8_DP Subroutines subroutine fraggle_generate_pos_vec (frag, colliders, r_max_start) Author Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton Initializes the orbits of the fragments around the center of mass. The fragments are initially placed on a plane defined by the \n pre-impact angular momentum. They are distributed on an ellipse surrounding the center of mass.\n The initial positions do not conserve energy or momentum, so these need to be adjusted later. Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: frag Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object real(kind=DP), intent(in) :: r_max_start Initial guess for the starting maximum radial distance of fragments subroutine fraggle_generate_spins (frag, colliders, f_spin, lfailure) Author Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton Calculates the spins of a collection of fragments such that they conserve angular momentum without blowing the fragment kinetic energy budget. Read more… Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: frag Fraggle fragment system object class( fraggle_colliders ), intent(in) :: colliders Fraggle collider system object real(kind=DP), intent(in) :: f_spin Fraction of energy or momentum that goes into spin (whichever gives the lowest kinetic energy) logical, intent(out) :: lfailure Logical flag indicating whether this step fails or succeeds! subroutine fraggle_generate_tan_vel (frag, colliders, lfailure) Author Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton Adjusts the tangential velocities and spins of a collection of fragments such that they conserve angular momentum without blowing the fragment kinetic energy budget.\n This procedure works in several stages, with a goal to solve the angular and linear momentum constraints on the fragments, while still leaving a positive balance of\n our fragment kinetic energy (frag%ke_budget) that we can put into the radial velocity distribution. Read more… Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: frag Fraggle fragment system object class( fraggle_colliders ), intent(in) :: colliders Fraggle collider system object logical, intent(out) :: lfailure Logical flag indicating whether this step fails or succeeds subroutine fraggle_generate_rad_vel (frag, colliders, lfailure) Author Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton Adjust the fragment velocities to set the fragment orbital kinetic energy. This will minimize the difference between the fragment kinetic energy and the energy budget Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: frag Fraggle fragment system object class( fraggle_colliders ), intent(in) :: colliders Fraggle collider system object logical, intent(out) :: lfailure Logical flag indicating whether this step fails or succeeds! Module Subroutines module subroutine fraggle_generate_fragments (self, colliders, system, param, lfailure) Interface → Author Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton Generates a system of fragments in barycentric coordinates that conserves energy and momentum. Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle system object the outputs will be the fragmentation class( fraggle_colliders ), intent(inout) :: colliders Fraggle colliders object containing the two-body equivalent values of the colliding bodies class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters logical, intent(out) :: lfailure Answers the question: Should this have been a merger instead?","tags":"","loc":"module/s_fraggle_generate.html"},{"title":"s_fraggle_regime – swiftest","text":"Uses swiftest Ancestors: fraggle_classes module~~s_fraggle_regime~~UsesGraph module~s_fraggle_regime s_fraggle_regime module~swiftest swiftest module~s_fraggle_regime->module~swiftest module~fraggle_classes fraggle_classes module~s_fraggle_regime->module~fraggle_classes module~swiftest->module~fraggle_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~fraggle_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines fraggle_regime_collresolve Module Subroutines fraggle_regime_colliders Subroutines subroutine fraggle_regime_collresolve (Mcb, m1, m2, rad1, rad2, xh1, xh2, vb1, vb2, den1, den2, min_mfrag, regime, Mlr, Mslr, Qloss) Author Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton Determine the collisional regime of two colliding bodies. \n Current version requires all values to be converted to SI units prior to calling the function\n       References:\n       Kokubo, E., Genda, H., 2010. Formation of Terrestrial Planets from Protoplanets Under a Realistic Accretion \n          Condition. ApJL 714, L21. https://doi.org/10.1088/2041-8205/714/1/L21\n       Leinhardt, Z.M., Stewart, S.T., 2012. Collisions between Gravity-dominated Bodies. I. Outcome Regimes and Scaling \n          Laws 745, 79. https://doi.org/10.1088/0004-637X/745/1/79\n       Mustill, A.J., Davies, M.B., Johansen, A., 2018. The dynamical evolution of transiting planetary systems including \n          a realistic collision prescription. Mon Not R Astron Soc 478, 2896–2908. https://doi.org/10.1093/mnras/sty1273\n       Rufu, R., Aharonson, O., 2019. Impact Dynamics of Moons Within a Planetary Potential. J. Geophys. Res. Planets 124, \n          1008–1019. https://doi.org/10.1029/2018JE005798\n       Stewart, S.T., Leinhardt, Z.M., 2012. Collisions between Gravity-dominated Bodies. II. The Diversity of Impact \n          Outcomes during the End Stage of Planet Formation. ApJ 751, 32. https://doi.org/10.1088/0004-637X/751/1/32 Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: Mcb real(kind=DP), intent(in) :: m1 real(kind=DP), intent(in) :: m2 real(kind=DP), intent(in) :: rad1 real(kind=DP), intent(in) :: rad2 real(kind=DP), intent(in), dimension(:) :: xh1 real(kind=DP), intent(in), dimension(:) :: xh2 real(kind=DP), intent(in), dimension(:) :: vb1 real(kind=DP), intent(in), dimension(:) :: vb2 real(kind=DP), intent(in) :: den1 real(kind=DP), intent(in) :: den2 real(kind=DP), intent(in) :: min_mfrag integer(kind=I4B), intent(out) :: regime real(kind=DP), intent(out) :: Mlr real(kind=DP), intent(out) :: Mslr real(kind=DP), intent(out) :: Qloss The residual energy after the collision Module Subroutines module subroutine fraggle_regime_colliders (self, frag, system, param) Interface → Author Jennifer L.L. Pouplin, Carlisle A. Wishard, and David A. Minton Determine which fragmentation regime the set of colliders will be. This subroutine is a wrapper for the non-polymorphic raggle_regime_collresolve subroutine.\n It converts to SI units prior to calling\n The two-body equivalent masses of the collider system\n The two-body equivalent radii of the collider system\n The two-body equivalent density of the collider system\n The first body of the two-body equivalent position vector the collider system\n The first body of the two-body equivalent velocity vector the collider system\n The second body of the two-body equivalent position vector the collider system\n The second body of the two-body equivalent velocity vector the collider system\n The central body mass of the system\n The minimum fragment mass to generate. Collider systems that would otherwise generate less massive fragments than this value will be forced to merge instead\n Use the positions and velocities of the parents from indside the step (at collision) to calculate the collisional regime Arguments Type Intent Optional Attributes Name class( fraggle_colliders ), intent(inout) :: self Fraggle colliders object class( fraggle_fragments ), intent(inout) :: frag Fraggle fragment system object class( swiftest_nbody_system ), intent(in) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current Swiftest run configuration parameters","tags":"","loc":"module/s_fraggle_regime.html"},{"title":"s_fraggle_placeholder – swiftest","text":"Uses swiftest Ancestors: fraggle_classes module~~s_fraggle_placeholder~~UsesGraph module~s_fraggle_placeholder s_fraggle_placeholder module~swiftest swiftest module~s_fraggle_placeholder->module~swiftest module~fraggle_classes fraggle_classes module~s_fraggle_placeholder->module~fraggle_classes module~swiftest->module~fraggle_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~fraggle_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines fraggle_placeholder_accel fraggle_placeholder_kick fraggle_placeholder_step Module Subroutines module subroutine fraggle_placeholder_accel (self, system, param, t, lbeg) Interface → The following interfaces are placeholders intended to satisfy the required abstract methods given by the parent class Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system object class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time logical, intent(in) :: lbeg Optional argument that determines whether or not this is the beginning or end of the step module subroutine fraggle_placeholder_kick (self, system, param, t, dt, lbeg) Interface → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( swiftest_nbody_system ), intent(inout) :: system Swiftest nbody system objec class( swiftest_parameters ), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time real(kind=DP), intent(in) :: dt Stepsize logical, intent(in) :: lbeg Logical flag indicating whether this is the beginning of the half step or not. module subroutine fraggle_placeholder_step (self, system, param, t, dt) Interface → Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Swiftest body object class( swiftest_nbody_system ), intent(inout) :: system Swiftest system object class( swiftest_parameters ), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Simulation time real(kind=DP), intent(in) :: dt Current stepsize","tags":"","loc":"module/s_fraggle_placeholder.html"},{"title":"s_fraggle_setup – swiftest","text":"Uses swiftest Ancestors: fraggle_classes module~~s_fraggle_setup~~UsesGraph module~s_fraggle_setup s_fraggle_setup module~swiftest swiftest module~s_fraggle_setup->module~swiftest module~fraggle_classes fraggle_classes module~s_fraggle_setup->module~fraggle_classes module~swiftest->module~fraggle_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~fraggle_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines fraggle_setup_reset_fragments fraggle_setup_fragments Module Subroutines module subroutine fraggle_setup_reset_fragments (self) Interface → Author David A. Minton Resets all position and velocity-dependent fragment quantities in order to do a fresh calculation (does not reset mass, radius, or other values that get set prior to the call to fraggle_generate) Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self module subroutine fraggle_setup_fragments (self, n, param) Interface → Author David A. Minton Allocates arrays for n fragments in a Fraggle system. Passing n = 0 deallocates all arrays. Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self integer(kind=I4B), intent(in) :: n class( swiftest_parameters ), intent(in) :: param","tags":"","loc":"module/s_fraggle_setup.html"},{"title":"s_fraggle_set – swiftest","text":"Uses swiftest Ancestors: fraggle_classes module~~s_fraggle_set~~UsesGraph module~s_fraggle_set s_fraggle_set module~swiftest swiftest module~s_fraggle_set->module~swiftest module~fraggle_classes fraggle_classes module~s_fraggle_set->module~fraggle_classes module~swiftest->module~fraggle_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~fraggle_classes module~symba_classes->module~helio_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines fraggle_set_budgets_fragments fraggle_set_mass_dist_fragments fraggle_set_coordinate_system fraggle_set_natural_scale_factors fraggle_set_original_scale_factors Module Subroutines module subroutine fraggle_set_budgets_fragments (self, colliders) Interface → Author David A. Minton Sets the energy and momentum budgets of the fragments based on the collider values and the before/after values of energy and momentum Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object module subroutine fraggle_set_mass_dist_fragments (self, colliders, param) Interface → Author David A. Minton Sets the mass of fragments based on the mass distribution returned by the regime calculation.\n This subroutine must be run after the the setup rourtine has been run on the fragments Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object class( swiftest_parameters ), intent(in) :: param Current Swiftest run configuration parameters module subroutine fraggle_set_coordinate_system (self, colliders) Interface → Author David A. Minton Defines the collisional coordinate system, including the unit vectors of both the system and individual fragments. Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object module subroutine fraggle_set_natural_scale_factors (self, colliders) Interface → Author David A. Minton Scales dimenional quantities to ~O(1) with respect to the collisional system. \n This scaling makes it easier for the non-linear minimization to converge on a solution Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object module subroutine fraggle_set_original_scale_factors (self, colliders) Interface → Author David A. Minton Restores dimenional quantities back to the system units Arguments Type Intent Optional Attributes Name class( fraggle_fragments ), intent(inout) :: self Fraggle fragment system object class( fraggle_colliders ), intent(inout) :: colliders Fraggle collider system object","tags":"","loc":"module/s_fraggle_set.html"},{"title":"s_rmvs_discard – swiftest","text":"Uses swiftest Ancestors: rmvs_classes module~~s_rmvs_discard~~UsesGraph module~s_rmvs_discard s_rmvs_discard module~swiftest swiftest module~s_rmvs_discard->module~swiftest module~rmvs_classes rmvs_classes module~s_rmvs_discard->module~rmvs_classes module~swiftest->module~rmvs_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines rmvs_discard_tp Module Subroutines module subroutine rmvs_discard_tp (self, system, param) Interface → Author David A. Minton Check to see if test particles should be discarded based on pericenter passage distances with respect to planets encountered Read more… Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_nbody_system), intent(inout) :: system Swiftest nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters","tags":"","loc":"module/s_rmvs_discard.html"},{"title":"s_rmvs_util – swiftest","text":"Uses swiftest Ancestors: rmvs_classes module~~s_rmvs_util~~UsesGraph module~s_rmvs_util s_rmvs_util module~swiftest swiftest module~s_rmvs_util->module~swiftest module~rmvs_classes rmvs_classes module~s_rmvs_util->module~rmvs_classes module~swiftest->module~rmvs_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines rmvs_util_append_pl rmvs_util_append_tp rmvs_util_fill_pl rmvs_util_fill_tp rmvs_util_resize_pl rmvs_util_resize_tp rmvs_util_sort_pl rmvs_util_sort_tp rmvs_util_sort_rearrange_pl rmvs_util_sort_rearrange_tp rmvs_util_spill_pl rmvs_util_spill_tp Module Subroutines module subroutine rmvs_util_append_pl (self, source, lsource_mask) Interface → Author David A. Minton Append components from one massive body object to another. \n This method will automatically resize the destination body if it is too small\n Arguments Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to module subroutine rmvs_util_append_tp (self, source, lsource_mask) Interface → Author David A. Minton Append components from test particle object to another. \n This method will automatically resize the destination body if it is too small\n Arguments Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(in) :: source Source object to append logical, intent(in), dimension(:) :: lsource_mask Logical mask indicating which elements to append to module subroutine rmvs_util_fill_pl (self, inserts, lfill_list) Interface → Author David A. Minton Insert new RMVS massive body structure into an old one. \n This is the inverse of a fill operation. Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps module subroutine rmvs_util_fill_tp (self, inserts, lfill_list) Interface → Author David A. Minton Insert new RMVS test particle structure into an old one. \n This is the inverse of a fill operation. Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(in) :: inserts Inserted object logical, intent(in), dimension(:) :: lfill_list Logical array of bodies to merge into the keeps module subroutine rmvs_util_resize_pl (self, nnew) Interface → Author David A. Minton Checks the current size of a massive body object against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in) :: nnew New size neded module subroutine rmvs_util_resize_tp (self, nnew) Interface → Author David A. Minton Checks the current size of a test particle object against the requested size and resizes it if it is too small. Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: nnew New size neded module subroutine rmvs_util_sort_pl (self, sortby, ascending) Interface → Author David A. Minton Sort a RMVS massive body object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order module subroutine rmvs_util_sort_tp (self, sortby, ascending) Interface → Author David A. Minton Sort a RMVS test particle object in-place. \n sortby is a string indicating which array component to sort. Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object character(len=*), intent(in) :: sortby Sorting attribute logical, intent(in) :: ascending Logical flag indicating whether or not the sorting should be in ascending or descending order module subroutine rmvs_util_sort_rearrange_pl (self, ind) Interface → Author David A. Minton Rearrange RMVS massive body structure in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) module subroutine rmvs_util_sort_rearrange_tp (self, ind) Interface → Author David A. Minton Rearrange RMVS test particle object in-place from an index list.\n This is a helper utility used to make polymorphic sorting work on Swiftest structures. Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in), dimension(:) :: ind Index array used to restructure the body (should contain all 1:n index values in the desired order) module subroutine rmvs_util_spill_pl (self, discards, lspill_list, ldestructive) Interface → Author David A. Minton Move spilled (discarded) RMVS test particle structure from active list to discard list Read more… Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS massive body body object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not module subroutine rmvs_util_spill_tp (self, discards, lspill_list, ldestructive) Interface → Author David A. Minton Move spilled (discarded) RMVS test particle structure from active list to discard list Read more… Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class(swiftest_body), intent(inout) :: discards Discarded object logical, intent(in), dimension(:) :: lspill_list Logical array of bodies to spill into the discards logical, intent(in) :: ldestructive Logical flag indicating whether or not this operation should alter the keeps array or not","tags":"","loc":"module/s_rmvs_util.html"},{"title":"s_rmvs_kick – swiftest","text":"Uses swiftest Ancestors: rmvs_classes module~~s_rmvs_kick~~UsesGraph module~s_rmvs_kick s_rmvs_kick module~swiftest swiftest module~s_rmvs_kick->module~swiftest module~rmvs_classes rmvs_classes module~s_rmvs_kick->module~rmvs_classes module~swiftest->module~rmvs_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines rmvs_kick_getacch_tp Module Subroutines module subroutine rmvs_kick_getacch_tp (self, system, param, t, lbeg) Interface → Author David A. Minton Compute the oblateness acceleration in the inner encounter region with planets Read more… Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle data structure class(swiftest_nbody_system), intent(inout) :: system Swiftest central body particle data structuree class(swiftest_parameters), intent(in) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current time logical, intent(in) :: lbeg Logical flag that determines whether or not this is the beginning or end of the step","tags":"","loc":"module/s_rmvs_kick.html"},{"title":"s_rmvs_io – swiftest","text":"Uses swiftest Ancestors: rmvs_classes module~~s_rmvs_io~~UsesGraph module~s_rmvs_io s_rmvs_io module~swiftest swiftest module~s_rmvs_io->module~swiftest module~rmvs_classes rmvs_classes module~s_rmvs_io->module~rmvs_classes module~swiftest->module~rmvs_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines rmvs_io_write_encounter Module Subroutines module subroutine rmvs_io_write_encounter (t, id1, id2, Gmass1, Gmass2, radius1, radius2, xh1, xh2, vh1, vh2, enc_out) Interface → Author David A. Minton Write close encounter data from RMVS to output binary files\n  There is no direct file output from this subroutine Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: t integer(kind=I4B), intent(in) :: id1 integer(kind=I4B), intent(in) :: id2 real(kind=DP), intent(in) :: Gmass1 real(kind=DP), intent(in) :: Gmass2 real(kind=DP), intent(in) :: radius1 real(kind=DP), intent(in) :: radius2 real(kind=DP), intent(in), dimension(:) :: xh1 real(kind=DP), intent(in), dimension(:) :: xh2 real(kind=DP), intent(in), dimension(:) :: vh1 real(kind=DP), intent(in), dimension(:) :: vh2 character(len=*), intent(in) :: enc_out","tags":"","loc":"module/s_rmvs_io.html"},{"title":"s_rmvs_setup – swiftest","text":"Uses swiftest Ancestors: rmvs_classes module~~s_rmvs_setup~~UsesGraph module~s_rmvs_setup s_rmvs_setup module~swiftest swiftest module~s_rmvs_setup->module~swiftest module~rmvs_classes rmvs_classes module~s_rmvs_setup->module~rmvs_classes module~swiftest->module~rmvs_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Subroutines rmvs_setup_pl rmvs_setup_initialize_system rmvs_setup_tp Module Subroutines module subroutine rmvs_setup_pl (self, n, param) Interface → Author David A. Minton Allocate RMVS test particle structure Read more… Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameter module subroutine rmvs_setup_initialize_system (self, param) Interface → Author David A. Minton Initialize an RMVS nbody system from files and sets up the planetocentric structures. Read more… Arguments Type Intent Optional Attributes Name class( rmvs_nbody_system ), intent(inout) :: self RMVS system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters module subroutine rmvs_setup_tp (self, n, param) Interface → Author David A. Minton Allocate WHM test particle structure Read more… Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object integer(kind=I4B), intent(in) :: n Number of particles to allocate space for class(swiftest_parameters), intent(in) :: param Current run configuration parameter","tags":"","loc":"module/s_rmvs_setup.html"},{"title":"s_rmvs_step – swiftest","text":"Uses swiftest Ancestors: rmvs_classes module~~s_rmvs_step~~UsesGraph module~s_rmvs_step s_rmvs_step module~swiftest swiftest module~s_rmvs_step->module~swiftest module~rmvs_classes rmvs_classes module~s_rmvs_step->module~rmvs_classes module~swiftest->module~rmvs_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines rmvs_interp_out rmvs_step_out rmvs_interp_in rmvs_step_in rmvs_make_planetocentric rmvs_peri_tp rmvs_end_planetocentric Module Subroutines rmvs_step_system Subroutines subroutine rmvs_interp_out (cb, pl, dt) Author David A. Minton Interpolate planet positions between two Keplerian orbits in outer encounter region Read more… Arguments Type Intent Optional Attributes Name class( rmvs_cb ), intent(inout) :: cb RMVS central body object class( rmvs_pl ), intent(inout) :: pl RMVS massive body object real(kind=DP), intent(in) :: dt Step size subroutine rmvs_step_out (cb, pl, tp, system, param, t, dt) Author David A. Minton Step ACTIVE test particles ahead in the outer encounter region, setting up and calling the inner region\n    integration if necessar Read more… Arguments Type Intent Optional Attributes Name class( rmvs_cb ), intent(inout) :: cb RMVS central body object class( rmvs_pl ), intent(inout) :: pl RMVS massive body object class( rmvs_tp ), intent(inout) :: tp RMVS test particle object class( rmvs_nbody_system ), intent(inout) :: system RMVS nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current stepsiz subroutine rmvs_interp_in (cb, pl, system, param, dt, outer_index) Author David A. Minton Interpolate planet positions between two Keplerian orbits in inner encounter regio Read more… Arguments Type Intent Optional Attributes Name class( rmvs_cb ), intent(inout) :: cb RMVS cenral body object class( rmvs_pl ), intent(inout) :: pl RMVS massive body object class( rmvs_nbody_system ), intent(inout) :: system RMVS nbody system object class(swiftest_parameters), intent(in) :: param Swiftest parameters file real(kind=DP), intent(in) :: dt Step size integer(kind=I4B), intent(in) :: outer_index Outer substep number within current set subroutine rmvs_step_in (cb, pl, tp, param, outer_time, dto) Author David A. Minton Step active test particles ahead in the inner encounter region Read more… Arguments Type Intent Optional Attributes Name class( rmvs_cb ), intent(inout) :: cb RMVS central body object class( rmvs_pl ), intent(inout) :: pl RMVS massive body object class( rmvs_tp ), intent(inout) :: tp RMVS test particle object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: outer_time Current time real(kind=DP), intent(in) :: dto Outer step size subroutine rmvs_make_planetocentric (param, cb, pl, tp) Author David A. Minton When encounters are detected, this method will call the interpolation methods for the planets and \n creates a Swiftest test particle structure for each planet's encountering test particles to simplify the \n planetocentric calculations. This subroutine is not based on an existing one from Swift and Swifter Arguments Type Intent Optional Attributes Name class(swiftest_parameters), intent(in) :: param Current run configuration paramete class( rmvs_cb ), intent(inout) :: cb RMVS central body object class( rmvs_pl ), intent(inout) :: pl RMVS massive body object class( rmvs_tp ), intent(inout) :: tp RMVS test particle object subroutine rmvs_peri_tp (tp, pl, t, dt, lfirst, inner_index, ipleP, param) Author David A. Minton Determine planetocentric pericenter passages for test particles in close encounters with a planet Read more… Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: tp RMVS test particle object (planetocentric) class( rmvs_pl ), intent(inout) :: pl RMVS massive body object (heliocentric) real(kind=DP), intent(in) :: t current time real(kind=DP), intent(in) :: dt step size logical, intent(in) :: lfirst Logical flag indicating whether current invocation is the first integer(kind=I4B), intent(in) :: inner_index Outer substep number within current set integer(kind=I4B), intent(in) :: ipleP index of RMVS planet being closely encountered class(swiftest_parameters), intent(in) :: param Current run configuration parameters subroutine rmvs_end_planetocentric (pl, tp) Author David A. Minton Deallocates all of the encountering particle data structures for next time Arguments Type Intent Optional Attributes Name class( rmvs_pl ), intent(inout) :: pl RMVS massive body object class( rmvs_tp ), intent(inout) :: tp RMVS test particle objec Module Subroutines module subroutine rmvs_step_system (self, param, t, dt) Interface → Author David A. Minton Step massive bodies and and active test particles ahead in heliocentric coordinates Read more… Arguments Type Intent Optional Attributes Name class( rmvs_nbody_system ), intent(inout) :: self RMVS nbody system object class(swiftest_parameters), intent(inout) :: param Current run configuration parameters real(kind=DP), intent(in) :: t Current simulation time real(kind=DP), intent(in) :: dt Current stepsiz","tags":"","loc":"module/s_rmvs_step.html"},{"title":"s_rmvs_chk – swiftest","text":"Uses swiftest Ancestors: rmvs_classes module~~s_rmvs_chk~~UsesGraph module~s_rmvs_chk s_rmvs_chk module~swiftest swiftest module~s_rmvs_chk->module~swiftest module~rmvs_classes rmvs_classes module~s_rmvs_chk->module~rmvs_classes module~swiftest->module~rmvs_classes module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Functions rmvs_encounter_check_tp Module Subroutines rmvs_chk_ind Module Functions module function rmvs_encounter_check_tp (self, system, dt) result(lencounter) Interface → Author David A. Minton Determine whether a test particle and planet are having or will have an encounter within the next time step Read more… Arguments Type Intent Optional Attributes Name class( rmvs_tp ), intent(inout) :: self RMVS test particle object class( rmvs_nbody_system ), intent(inout) :: system RMVS nbody system object real(kind=DP), intent(in) :: dt step size Return Value logical Returns true if there is at least one close encounter Module Subroutines pure module subroutine rmvs_chk_ind (xr, yr, zr, vxr, vyr, vzr, dt, r2crit, lencounter, lvdotr) Interface → Author David A. Minton Determine whether a test particle and planet are having or will have an encounter within the next time step Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: xr Relative distance vector components real(kind=DP), intent(in) :: yr Relative distance vector components real(kind=DP), intent(in) :: zr Relative distance vector components real(kind=DP), intent(in) :: vxr Relative velocity vector components real(kind=DP), intent(in) :: vyr Relative velocity vector components real(kind=DP), intent(in) :: vzr Relative velocity vector components real(kind=DP), intent(in) :: dt Step size real(kind=DP), intent(in) :: r2crit Square of the critical encounter distance logical, intent(out) :: lencounter Flag indicating that an encounter has occurred logical, intent(out) :: lvdotr Logical flag indicating the direction of the v .dot. r vector","tags":"","loc":"module/s_rmvs_chk.html"},{"title":"swiftest_driver – swiftest","text":"Uses swiftest program~~swiftest_driver~~UsesGraph program~swiftest_driver swiftest_driver module~swiftest swiftest program~swiftest_driver->module~swiftest module~whm_classes whm_classes module~swiftest->module~whm_classes module~swiftest_operators swiftest_operators module~swiftest->module~swiftest_operators module~symba_classes symba_classes module~swiftest->module~symba_classes module~helio_classes helio_classes module~swiftest->module~helio_classes module~fraggle_classes fraggle_classes module~swiftest->module~fraggle_classes module~lambda_function lambda_function module~swiftest->module~lambda_function module~swiftest_classes swiftest_classes module~swiftest->module~swiftest_classes module~rmvs_classes rmvs_classes module~swiftest->module~rmvs_classes module~walltime_classes walltime_classes module~swiftest->module~walltime_classes module~swiftest_globals swiftest_globals module~swiftest->module~swiftest_globals module~whm_classes->module~swiftest_classes module~whm_classes->module~swiftest_globals module~swiftest_operators->module~swiftest_globals module~symba_classes->module~helio_classes module~symba_classes->module~fraggle_classes module~symba_classes->module~swiftest_classes module~symba_classes->module~swiftest_globals module~helio_classes->module~whm_classes module~helio_classes->module~swiftest_classes module~helio_classes->module~swiftest_globals module~fraggle_classes->module~swiftest_classes module~fraggle_classes->module~swiftest_globals module~lambda_function->module~swiftest_globals module~swiftest_classes->module~swiftest_globals module~rmvs_classes->module~whm_classes module~rmvs_classes->module~swiftest_globals module~walltime_classes->module~swiftest_globals iso_fortran_env iso_fortran_env module~swiftest_globals->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Driver program for the Swiftest integrators. Unlike the earlier Swift and Swifter drivers, in Swiftest all integrators \n    are run from this single program. Adapted from Swifter by David E. Kaufmann's Swifter driver programs swifter_[bs,helio,ra15,rmvs,symba,tu4,whm].f90\n Adapted from Hal Levison and Martin Duncan's Swift driver programs\n Read in the user-defined parameters file and the initial conditions of the system\n Define the maximum number of threads Step the system forward in time Evaluate any discards or collisional outcomes If the loop counter is at the output cadence value, append the data file with a single frame\n If the loop counter is at the dump cadence value, dump the state of the system to a file in case it needs to be restarted Calls program~~swiftest_driver~~CallsGraph program~swiftest_driver swiftest_driver util_exit util_exit program~swiftest_driver->util_exit io_get_args io_get_args program~swiftest_driver->io_get_args setup_construct_system setup_construct_system program~swiftest_driver->setup_construct_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables nbody_system param integrator param_file_name ierr iloop idump iout ioutput_t0 nloops old_t_final timer Variables Type Attributes Name Initial class(swiftest_nbody_system), allocatable :: nbody_system Polymorphic object containing the nbody system to be integrated class(swiftest_parameters), allocatable :: param Run configuration parameters integer(kind=I4B) :: integrator Integrator type code (see swiftest_globals for symbolic names) character(len=:), allocatable :: param_file_name Name of the file containing user-defined parameters integer(kind=I4B) :: ierr I/O error code integer(kind=I8B) :: iloop Loop counter integer(kind=I8B) :: idump Dump cadence counter integer(kind=I8B) :: iout Output cadence counter integer(kind=I8B) :: ioutput_t0 The output frame counter at time 0 integer(kind=I8B) :: nloops Number of steps to take in the simulation real(kind=DP) :: old_t_final = 0.0_DP Output time at which writing should start, in order to prevent duplicate lines being written for restarts type(walltimer) :: timer Object used for computing elapsed wall time","tags":"","loc":"program/swiftest_driver.html"}]}